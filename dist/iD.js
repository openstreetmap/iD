(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
    get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
  }) : x2)(function(x2) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x2 + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateAdd = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateMethod = (obj, member, method) => {
    __accessCheck(obj, member, "access private method");
    return method;
  };

  // node_modules/diacritics/index.js
  var require_diacritics = __commonJS({
    "node_modules/diacritics/index.js"(exports2) {
      exports2.remove = removeDiacritics2;
      var replacementList = [
        {
          base: " ",
          chars: "\xA0"
        },
        {
          base: "0",
          chars: "\u07C0"
        },
        {
          base: "A",
          chars: "\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
        },
        {
          base: "AA",
          chars: "\uA732"
        },
        {
          base: "AE",
          chars: "\xC6\u01FC\u01E2"
        },
        {
          base: "AO",
          chars: "\uA734"
        },
        {
          base: "AU",
          chars: "\uA736"
        },
        {
          base: "AV",
          chars: "\uA738\uA73A"
        },
        {
          base: "AY",
          chars: "\uA73C"
        },
        {
          base: "B",
          chars: "\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0181"
        },
        {
          base: "C",
          chars: "\u24B8\uFF23\uA73E\u1E08\u0106C\u0108\u010A\u010C\xC7\u0187\u023B"
        },
        {
          base: "D",
          chars: "\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018A\u0189\u1D05\uA779"
        },
        {
          base: "Dh",
          chars: "\xD0"
        },
        {
          base: "DZ",
          chars: "\u01F1\u01C4"
        },
        {
          base: "Dz",
          chars: "\u01F2\u01C5"
        },
        {
          base: "E",
          chars: "\u025B\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E\u1D07"
        },
        {
          base: "F",
          chars: "\uA77C\u24BB\uFF26\u1E1E\u0191\uA77B"
        },
        {
          base: "G",
          chars: "\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E\u0262"
        },
        {
          base: "H",
          chars: "\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
        },
        {
          base: "I",
          chars: "\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
        },
        {
          base: "J",
          chars: "\u24BF\uFF2A\u0134\u0248\u0237"
        },
        {
          base: "K",
          chars: "\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
        },
        {
          base: "L",
          chars: "\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
        },
        {
          base: "LJ",
          chars: "\u01C7"
        },
        {
          base: "Lj",
          chars: "\u01C8"
        },
        {
          base: "M",
          chars: "\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C\u03FB"
        },
        {
          base: "N",
          chars: "\uA7A4\u0220\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u019D\uA790\u1D0E"
        },
        {
          base: "NJ",
          chars: "\u01CA"
        },
        {
          base: "Nj",
          chars: "\u01CB"
        },
        {
          base: "O",
          chars: "\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
        },
        {
          base: "OE",
          chars: "\u0152"
        },
        {
          base: "OI",
          chars: "\u01A2"
        },
        {
          base: "OO",
          chars: "\uA74E"
        },
        {
          base: "OU",
          chars: "\u0222"
        },
        {
          base: "P",
          chars: "\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
        },
        {
          base: "Q",
          chars: "\u24C6\uFF31\uA756\uA758\u024A"
        },
        {
          base: "R",
          chars: "\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
        },
        {
          base: "S",
          chars: "\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
        },
        {
          base: "T",
          chars: "\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
        },
        {
          base: "Th",
          chars: "\xDE"
        },
        {
          base: "TZ",
          chars: "\uA728"
        },
        {
          base: "U",
          chars: "\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
        },
        {
          base: "V",
          chars: "\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
        },
        {
          base: "VY",
          chars: "\uA760"
        },
        {
          base: "W",
          chars: "\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
        },
        {
          base: "X",
          chars: "\u24CD\uFF38\u1E8A\u1E8C"
        },
        {
          base: "Y",
          chars: "\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
        },
        {
          base: "Z",
          chars: "\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
        },
        {
          base: "a",
          chars: "\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250\u0251"
        },
        {
          base: "aa",
          chars: "\uA733"
        },
        {
          base: "ae",
          chars: "\xE6\u01FD\u01E3"
        },
        {
          base: "ao",
          chars: "\uA735"
        },
        {
          base: "au",
          chars: "\uA737"
        },
        {
          base: "av",
          chars: "\uA739\uA73B"
        },
        {
          base: "ay",
          chars: "\uA73D"
        },
        {
          base: "b",
          chars: "\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253\u0182"
        },
        {
          base: "c",
          chars: "\uFF43\u24D2\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
        },
        {
          base: "d",
          chars: "\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\u018B\u13E7\u0501\uA7AA"
        },
        {
          base: "dh",
          chars: "\xF0"
        },
        {
          base: "dz",
          chars: "\u01F3\u01C6"
        },
        {
          base: "e",
          chars: "\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u01DD"
        },
        {
          base: "f",
          chars: "\u24D5\uFF46\u1E1F\u0192"
        },
        {
          base: "ff",
          chars: "\uFB00"
        },
        {
          base: "fi",
          chars: "\uFB01"
        },
        {
          base: "fl",
          chars: "\uFB02"
        },
        {
          base: "ffi",
          chars: "\uFB03"
        },
        {
          base: "ffl",
          chars: "\uFB04"
        },
        {
          base: "g",
          chars: "\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\uA77F\u1D79"
        },
        {
          base: "h",
          chars: "\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
        },
        {
          base: "hv",
          chars: "\u0195"
        },
        {
          base: "i",
          chars: "\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
        },
        {
          base: "j",
          chars: "\u24D9\uFF4A\u0135\u01F0\u0249"
        },
        {
          base: "k",
          chars: "\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
        },
        {
          base: "l",
          chars: "\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747\u026D"
        },
        {
          base: "lj",
          chars: "\u01C9"
        },
        {
          base: "m",
          chars: "\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
        },
        {
          base: "n",
          chars: "\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5\u043B\u0509"
        },
        {
          base: "nj",
          chars: "\u01CC"
        },
        {
          base: "o",
          chars: "\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\uA74B\uA74D\u0275\u0254\u1D11"
        },
        {
          base: "oe",
          chars: "\u0153"
        },
        {
          base: "oi",
          chars: "\u01A3"
        },
        {
          base: "oo",
          chars: "\uA74F"
        },
        {
          base: "ou",
          chars: "\u0223"
        },
        {
          base: "p",
          chars: "\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755\u03C1"
        },
        {
          base: "q",
          chars: "\u24E0\uFF51\u024B\uA757\uA759"
        },
        {
          base: "r",
          chars: "\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
        },
        {
          base: "s",
          chars: "\u24E2\uFF53\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B\u0282"
        },
        {
          base: "ss",
          chars: "\xDF"
        },
        {
          base: "t",
          chars: "\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
        },
        {
          base: "th",
          chars: "\xFE"
        },
        {
          base: "tz",
          chars: "\uA729"
        },
        {
          base: "u",
          chars: "\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
        },
        {
          base: "v",
          chars: "\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
        },
        {
          base: "vy",
          chars: "\uA761"
        },
        {
          base: "w",
          chars: "\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
        },
        {
          base: "x",
          chars: "\u24E7\uFF58\u1E8B\u1E8D"
        },
        {
          base: "y",
          chars: "\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
        },
        {
          base: "z",
          chars: "\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
        }
      ];
      var diacriticsMap = {};
      for (i3 = 0; i3 < replacementList.length; i3 += 1) {
        chars = replacementList[i3].chars;
        for (j2 = 0; j2 < chars.length; j2 += 1) {
          diacriticsMap[chars[j2]] = replacementList[i3].base;
        }
      }
      var chars;
      var j2;
      var i3;
      function removeDiacritics2(str) {
        return str.replace(/[^\u0000-\u007e]/g, function(c2) {
          return diacriticsMap[c2] || c2;
        });
      }
      exports2.replacementList = replacementList;
      exports2.diacriticsMap = diacriticsMap;
    }
  });

  // node_modules/alif-toolkit/lib/isArabic.js
  var require_isArabic = __commonJS({
    "node_modules/alif-toolkit/lib/isArabic.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var arabicBlocks = [
        [1536, 1791],
        [1872, 1919],
        [2208, 2303],
        [64336, 65023],
        [65136, 65279],
        [69216, 69247],
        [126064, 126143],
        [126464, 126719]
        // Mathematical Alphabetic symbols https://www.unicode.org/charts/PDF/U1EE00.pdf
      ];
      function isArabic(char) {
        if (char.length > 1) {
          throw new Error("isArabic works on only one-character strings");
        }
        let code = char.charCodeAt(0);
        for (let i3 = 0; i3 < arabicBlocks.length; i3++) {
          let block2 = arabicBlocks[i3];
          if (code >= block2[0] && code <= block2[1]) {
            return true;
          }
        }
        return false;
      }
      exports2.isArabic = isArabic;
      function isMath(char) {
        if (char.length > 2) {
          throw new Error("isMath works on only one-character strings");
        }
        let code = char.charCodeAt(0);
        return code >= 1632 && code <= 1644 || code >= 1776 && code <= 1785;
      }
      exports2.isMath = isMath;
    }
  });

  // node_modules/alif-toolkit/lib/unicode-arabic.js
  var require_unicode_arabic = __commonJS({
    "node_modules/alif-toolkit/lib/unicode-arabic.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var arabicReference = {
        "alef": {
          "normal": [
            "\u0627"
          ],
          "madda_above": {
            "normal": [
              "\u0627\u0653",
              "\u0622"
            ],
            "isolated": "\uFE81",
            "final": "\uFE82"
          },
          "hamza_above": {
            "normal": [
              "\u0627\u0654",
              "\u0623"
            ],
            "isolated": "\uFE83",
            "final": "\uFE84"
          },
          "hamza_below": {
            "normal": [
              "\u0627\u0655",
              "\u0625"
            ],
            "isolated": "\uFE87",
            "final": "\uFE88"
          },
          "wasla": {
            "normal": "\u0671",
            "isolated": "\uFB50",
            "final": "\uFB51"
          },
          "wavy_hamza_above": [
            "\u0672"
          ],
          "wavy_hamza_below": [
            "\u0627\u065F",
            "\u0673"
          ],
          "high_hamza": [
            "\u0675",
            "\u0627\u0674"
          ],
          "indic_two_above": [
            "\u0773"
          ],
          "indic_three_above": [
            "\u0774"
          ],
          "fathatan": {
            "normal": [
              "\u0627\u064B"
            ],
            "final": "\uFD3C",
            "isolated": "\uFD3D"
          },
          "isolated": "\uFE8D",
          "final": "\uFE8E"
        },
        "beh": {
          "normal": [
            "\u0628"
          ],
          "dotless": [
            "\u066E"
          ],
          "three_dots_horizontally_below": [
            "\u0750"
          ],
          "dot_below_three_dots_above": [
            "\u0751"
          ],
          "three_dots_pointing_upwards_below": [
            "\u0752"
          ],
          "three_dots_pointing_upwards_below_two_dots_above": [
            "\u0753"
          ],
          "two_dots_below_dot_above": [
            "\u0754"
          ],
          "inverted_small_v_below": [
            "\u0755"
          ],
          "small_v": [
            "\u0756"
          ],
          "small_v_below": [
            "\u08A0"
          ],
          "hamza_above": [
            "\u08A1"
          ],
          "small_meem_above": [
            "\u08B6"
          ],
          "isolated": "\uFE8F",
          "final": "\uFE90",
          "initial": "\uFE91",
          "medial": "\uFE92"
        },
        "teh marbuta": {
          "normal": [
            "\u0629"
          ],
          "isolated": "\uFE93",
          "final": "\uFE94"
        },
        "teh": {
          "normal": [
            "\u062A"
          ],
          "ring": [
            "\u067C"
          ],
          "three_dots_above_downwards": [
            "\u067D"
          ],
          "small_teh_above": [
            "\u08B8"
          ],
          "isolated": "\uFE95",
          "final": "\uFE96",
          "initial": "\uFE97",
          "medial": "\uFE98"
        },
        "theh": {
          "normal": [
            "\u062B"
          ],
          "isolated": "\uFE99",
          "final": "\uFE9A",
          "initial": "\uFE9B",
          "medial": "\uFE9C"
        },
        "jeem": {
          "normal": [
            "\u062C"
          ],
          "two_dots_above": [
            "\u08A2"
          ],
          "isolated": "\uFE9D",
          "final": "\uFE9E",
          "initial": "\uFE9F",
          "medial": "\uFEA0"
        },
        "hah": {
          "normal": [
            "\u062D"
          ],
          "hamza_above": [
            "\u0681"
          ],
          "two_dots_vertical_above": [
            "\u0682"
          ],
          "three_dots_above": [
            "\u0685"
          ],
          "two_dots_above": [
            "\u0757"
          ],
          "three_dots_pointing_upwards_below": [
            "\u0758"
          ],
          "small_tah_below": [
            "\u076E"
          ],
          "small_tah_two_dots": [
            "\u076F"
          ],
          "small_tah_above": [
            "\u0772"
          ],
          "indic_four_below": [
            "\u077C"
          ],
          "isolated": "\uFEA1",
          "final": "\uFEA2",
          "initial": "\uFEA3",
          "medial": "\uFEA4"
        },
        "khah": {
          "normal": [
            "\u062E"
          ],
          "isolated": "\uFEA5",
          "final": "\uFEA6",
          "initial": "\uFEA7",
          "medial": "\uFEA8"
        },
        "dal": {
          "normal": [
            "\u062F"
          ],
          "ring": [
            "\u0689"
          ],
          "dot_below": [
            "\u068A"
          ],
          "dot_below_small_tah": [
            "\u068B"
          ],
          "three_dots_above_downwards": [
            "\u068F"
          ],
          "four_dots_above": [
            "\u0690"
          ],
          "inverted_v": [
            "\u06EE"
          ],
          "two_dots_vertically_below_small_tah": [
            "\u0759"
          ],
          "inverted_small_v_below": [
            "\u075A"
          ],
          "three_dots_below": [
            "\u08AE"
          ],
          "isolated": "\uFEA9",
          "final": "\uFEAA"
        },
        "thal": {
          "normal": [
            "\u0630"
          ],
          "isolated": "\uFEAB",
          "final": "\uFEAC"
        },
        "reh": {
          "normal": [
            "\u0631"
          ],
          "small_v": [
            "\u0692"
          ],
          "ring": [
            "\u0693"
          ],
          "dot_below": [
            "\u0694"
          ],
          "small_v_below": [
            "\u0695"
          ],
          "dot_below_dot_above": [
            "\u0696"
          ],
          "two_dots_above": [
            "\u0697"
          ],
          "four_dots_above": [
            "\u0699"
          ],
          "inverted_v": [
            "\u06EF"
          ],
          "stroke": [
            "\u075B"
          ],
          "two_dots_vertically_above": [
            "\u076B"
          ],
          "hamza_above": [
            "\u076C"
          ],
          "small_tah_two_dots": [
            "\u0771"
          ],
          "loop": [
            "\u08AA"
          ],
          "small_noon_above": [
            "\u08B9"
          ],
          "isolated": "\uFEAD",
          "final": "\uFEAE"
        },
        "zain": {
          "normal": [
            "\u0632"
          ],
          "inverted_v_above": [
            "\u08B2"
          ],
          "isolated": "\uFEAF",
          "final": "\uFEB0"
        },
        "seen": {
          "normal": [
            "\u0633"
          ],
          "dot_below_dot_above": [
            "\u069A"
          ],
          "three_dots_below": [
            "\u069B"
          ],
          "three_dots_below_three_dots_above": [
            "\u069C"
          ],
          "four_dots_above": [
            "\u075C"
          ],
          "two_dots_vertically_above": [
            "\u076D"
          ],
          "small_tah_two_dots": [
            "\u0770"
          ],
          "indic_four_above": [
            "\u077D"
          ],
          "inverted_v": [
            "\u077E"
          ],
          "isolated": "\uFEB1",
          "final": "\uFEB2",
          "initial": "\uFEB3",
          "medial": "\uFEB4"
        },
        "sheen": {
          "normal": [
            "\u0634"
          ],
          "dot_below": [
            "\u06FA"
          ],
          "isolated": "\uFEB5",
          "final": "\uFEB6",
          "initial": "\uFEB7",
          "medial": "\uFEB8"
        },
        "sad": {
          "normal": [
            "\u0635"
          ],
          "two_dots_below": [
            "\u069D"
          ],
          "three_dots_above": [
            "\u069E"
          ],
          "three_dots_below": [
            "\u08AF"
          ],
          "isolated": "\uFEB9",
          "final": "\uFEBA",
          "initial": "\uFEBB",
          "medial": "\uFEBC"
        },
        "dad": {
          "normal": [
            "\u0636"
          ],
          "dot_below": [
            "\u06FB"
          ],
          "isolated": "\uFEBD",
          "final": "\uFEBE",
          "initial": "\uFEBF",
          "medial": "\uFEC0"
        },
        "tah": {
          "normal": [
            "\u0637"
          ],
          "three_dots_above": [
            "\u069F"
          ],
          "two_dots_above": [
            "\u08A3"
          ],
          "isolated": "\uFEC1",
          "final": "\uFEC2",
          "initial": "\uFEC3",
          "medial": "\uFEC4"
        },
        "zah": {
          "normal": [
            "\u0638"
          ],
          "isolated": "\uFEC5",
          "final": "\uFEC6",
          "initial": "\uFEC7",
          "medial": "\uFEC8"
        },
        "ain": {
          "normal": [
            "\u0639"
          ],
          "three_dots_above": [
            "\u06A0"
          ],
          "two_dots_above": [
            "\u075D"
          ],
          "three_dots_pointing_downwards_above": [
            "\u075E"
          ],
          "two_dots_vertically_above": [
            "\u075F"
          ],
          "three_dots_below": [
            "\u08B3"
          ],
          "isolated": "\uFEC9",
          "final": "\uFECA",
          "initial": "\uFECB",
          "medial": "\uFECC"
        },
        "ghain": {
          "normal": [
            "\u063A"
          ],
          "dot_below": [
            "\u06FC"
          ],
          "isolated": "\uFECD",
          "final": "\uFECE",
          "initial": "\uFECF",
          "medial": "\uFED0"
        },
        "feh": {
          "normal": [
            "\u0641"
          ],
          "dotless": [
            "\u06A1"
          ],
          "dot_moved_below": [
            "\u06A2"
          ],
          "dot_below": [
            "\u06A3"
          ],
          "three_dots_below": [
            "\u06A5"
          ],
          "two_dots_below": [
            "\u0760"
          ],
          "three_dots_pointing_upwards_below": [
            "\u0761"
          ],
          "dot_below_three_dots_above": [
            "\u08A4"
          ],
          "isolated": "\uFED1",
          "final": "\uFED2",
          "initial": "\uFED3",
          "medial": "\uFED4"
        },
        "qaf": {
          "normal": [
            "\u0642"
          ],
          "dotless": [
            "\u066F"
          ],
          "dot_above": [
            "\u06A7"
          ],
          "three_dots_above": [
            "\u06A8"
          ],
          "dot_below": [
            "\u08A5"
          ],
          "isolated": "\uFED5",
          "final": "\uFED6",
          "initial": "\uFED7",
          "medial": "\uFED8"
        },
        "kaf": {
          "normal": [
            "\u0643"
          ],
          "swash": [
            "\u06AA"
          ],
          "ring": [
            "\u06AB"
          ],
          "dot_above": [
            "\u06AC"
          ],
          "three_dots_below": [
            "\u06AE"
          ],
          "two_dots_above": [
            "\u077F"
          ],
          "dot_below": [
            "\u08B4"
          ],
          "isolated": "\uFED9",
          "final": "\uFEDA",
          "initial": "\uFEDB",
          "medial": "\uFEDC"
        },
        "lam": {
          "normal": [
            "\u0644"
          ],
          "small_v": [
            "\u06B5"
          ],
          "dot_above": [
            "\u06B6"
          ],
          "three_dots_above": [
            "\u06B7"
          ],
          "three_dots_below": [
            "\u06B8"
          ],
          "bar": [
            "\u076A"
          ],
          "double_bar": [
            "\u08A6"
          ],
          "isolated": "\uFEDD",
          "final": "\uFEDE",
          "initial": "\uFEDF",
          "medial": "\uFEE0"
        },
        "meem": {
          "normal": [
            "\u0645"
          ],
          "dot_above": [
            "\u0765"
          ],
          "dot_below": [
            "\u0766"
          ],
          "three_dots_above": [
            "\u08A7"
          ],
          "isolated": "\uFEE1",
          "final": "\uFEE2",
          "initial": "\uFEE3",
          "medial": "\uFEE4"
        },
        "noon": {
          "normal": [
            "\u0646"
          ],
          "dot_below": [
            "\u06B9"
          ],
          "ring": [
            "\u06BC"
          ],
          "three_dots_above": [
            "\u06BD"
          ],
          "two_dots_below": [
            "\u0767"
          ],
          "small_tah": [
            "\u0768"
          ],
          "small_v": [
            "\u0769"
          ],
          "isolated": "\uFEE5",
          "final": "\uFEE6",
          "initial": "\uFEE7",
          "medial": "\uFEE8"
        },
        "heh": {
          "normal": [
            "\u0647"
          ],
          "isolated": "\uFEE9",
          "final": "\uFEEA",
          "initial": "\uFEEB",
          "medial": "\uFEEC"
        },
        "waw": {
          "normal": [
            "\u0648"
          ],
          "hamza_above": {
            "normal": [
              "\u0624",
              "\u0648\u0654"
            ],
            "isolated": "\uFE85",
            "final": "\uFE86"
          },
          "high_hamza": [
            "\u0676",
            "\u0648\u0674"
          ],
          "ring": [
            "\u06C4"
          ],
          "two_dots_above": [
            "\u06CA"
          ],
          "dot_above": [
            "\u06CF"
          ],
          "indic_two_above": [
            "\u0778"
          ],
          "indic_three_above": [
            "\u0779"
          ],
          "dot_within": [
            "\u08AB"
          ],
          "isolated": "\uFEED",
          "final": "\uFEEE"
        },
        "alef_maksura": {
          "normal": [
            "\u0649"
          ],
          "hamza_above": [
            "\u0626",
            "\u064A\u0654"
          ],
          "initial": "\uFBE8",
          "medial": "\uFBE9",
          "isolated": "\uFEEF",
          "final": "\uFEF0"
        },
        "yeh": {
          "normal": [
            "\u064A"
          ],
          "hamza_above": {
            "normal": [
              "\u0626",
              "\u0649\u0654"
            ],
            "isolated": "\uFE89",
            "final": "\uFE8A",
            "initial": "\uFE8B",
            "medial": "\uFE8C"
          },
          "two_dots_below_hamza_above": [
            "\u08A8"
          ],
          "high_hamza": [
            "\u0678",
            "\u064A\u0674"
          ],
          "tail": [
            "\u06CD"
          ],
          "small_v": [
            "\u06CE"
          ],
          "three_dots_below": [
            "\u06D1"
          ],
          "two_dots_below_dot_above": [
            "\u08A9"
          ],
          "two_dots_below_small_noon_above": [
            "\u08BA"
          ],
          "isolated": "\uFEF1",
          "final": "\uFEF2",
          "initial": "\uFEF3",
          "medial": "\uFEF4"
        },
        "tteh": {
          "normal": [
            "\u0679"
          ],
          "isolated": "\uFB66",
          "final": "\uFB67",
          "initial": "\uFB68",
          "medial": "\uFB69"
        },
        "tteheh": {
          "normal": [
            "\u067A"
          ],
          "isolated": "\uFB5E",
          "final": "\uFB5F",
          "initial": "\uFB60",
          "medial": "\uFB61"
        },
        "beeh": {
          "normal": [
            "\u067B"
          ],
          "isolated": "\uFB52",
          "final": "\uFB53",
          "initial": "\uFB54",
          "medial": "\uFB55"
        },
        "peh": {
          "normal": [
            "\u067E"
          ],
          "small_meem_above": [
            "\u08B7"
          ],
          "isolated": "\uFB56",
          "final": "\uFB57",
          "initial": "\uFB58",
          "medial": "\uFB59"
        },
        "teheh": {
          "normal": [
            "\u067F"
          ],
          "isolated": "\uFB62",
          "final": "\uFB63",
          "initial": "\uFB64",
          "medial": "\uFB65"
        },
        "beheh": {
          "normal": [
            "\u0680"
          ],
          "isolated": "\uFB5A",
          "final": "\uFB5B",
          "initial": "\uFB5C",
          "medial": "\uFB5D"
        },
        "nyeh": {
          "normal": [
            "\u0683"
          ],
          "isolated": "\uFB76",
          "final": "\uFB77",
          "initial": "\uFB78",
          "medial": "\uFB79"
        },
        "dyeh": {
          "normal": [
            "\u0684"
          ],
          "isolated": "\uFB72",
          "final": "\uFB73",
          "initial": "\uFB74",
          "medial": "\uFB75"
        },
        "tcheh": {
          "normal": [
            "\u0686"
          ],
          "dot_above": [
            "\u06BF"
          ],
          "isolated": "\uFB7A",
          "final": "\uFB7B",
          "initial": "\uFB7C",
          "medial": "\uFB7D"
        },
        "tcheheh": {
          "normal": [
            "\u0687"
          ],
          "isolated": "\uFB7E",
          "final": "\uFB7F",
          "initial": "\uFB80",
          "medial": "\uFB81"
        },
        "ddal": {
          "normal": [
            "\u0688"
          ],
          "isolated": "\uFB88",
          "final": "\uFB89"
        },
        "dahal": {
          "normal": [
            "\u068C"
          ],
          "isolated": "\uFB84",
          "final": "\uFB85"
        },
        "ddahal": {
          "normal": [
            "\u068D"
          ],
          "isolated": "\uFB82",
          "final": "\uFB83"
        },
        "dul": {
          "normal": [
            "\u068F",
            "\u068E"
          ],
          "isolated": "\uFB86",
          "final": "\uFB87"
        },
        "rreh": {
          "normal": [
            "\u0691"
          ],
          "isolated": "\uFB8C",
          "final": "\uFB8D"
        },
        "jeh": {
          "normal": [
            "\u0698"
          ],
          "isolated": "\uFB8A",
          "final": "\uFB8B"
        },
        "veh": {
          "normal": [
            "\u06A4"
          ],
          "isolated": "\uFB6A",
          "final": "\uFB6B",
          "initial": "\uFB6C",
          "medial": "\uFB6D"
        },
        "peheh": {
          "normal": [
            "\u06A6"
          ],
          "isolated": "\uFB6E",
          "final": "\uFB6F",
          "initial": "\uFB70",
          "medial": "\uFB71"
        },
        "keheh": {
          "normal": [
            "\u06A9"
          ],
          "dot_above": [
            "\u0762"
          ],
          "three_dots_above": [
            "\u0763"
          ],
          "three_dots_pointing_upwards_below": [
            "\u0764"
          ],
          "isolated": "\uFB8E",
          "final": "\uFB8F",
          "initial": "\uFB90",
          "medial": "\uFB91"
        },
        "ng": {
          "normal": [
            "\u06AD"
          ],
          "isolated": "\uFBD3",
          "final": "\uFBD4",
          "initial": "\uFBD5",
          "medial": "\uFBD6"
        },
        "gaf": {
          "normal": [
            "\u06AF"
          ],
          "ring": [
            "\u06B0"
          ],
          "two_dots_below": [
            "\u06B2"
          ],
          "three_dots_above": [
            "\u06B4"
          ],
          "inverted_stroke": [
            "\u08B0"
          ],
          "isolated": "\uFB92",
          "final": "\uFB93",
          "initial": "\uFB94",
          "medial": "\uFB95"
        },
        "ngoeh": {
          "normal": [
            "\u06B1"
          ],
          "isolated": "\uFB9A",
          "final": "\uFB9B",
          "initial": "\uFB9C",
          "medial": "\uFB9D"
        },
        "gueh": {
          "normal": [
            "\u06B3"
          ],
          "isolated": "\uFB96",
          "final": "\uFB97",
          "initial": "\uFB98",
          "medial": "\uFB99"
        },
        "noon ghunna": {
          "normal": [
            "\u06BA"
          ],
          "isolated": "\uFB9E",
          "final": "\uFB9F"
        },
        "rnoon": {
          "normal": [
            "\u06BB"
          ],
          "isolated": "\uFBA0",
          "final": "\uFBA1",
          "initial": "\uFBA2",
          "medial": "\uFBA3"
        },
        "heh doachashmee": {
          "normal": [
            "\u06BE"
          ],
          "isolated": "\uFBAA",
          "final": "\uFBAB",
          "initial": "\uFBAC",
          "medial": "\uFBAD"
        },
        "heh goal": {
          "normal": [
            "\u06C1"
          ],
          "hamza_above": [
            "\u06C1\u0654",
            "\u06C2"
          ],
          "isolated": "\uFBA6",
          "final": "\uFBA7",
          "initial": "\uFBA8",
          "medial": "\uFBA9"
        },
        "teh marbuta goal": {
          "normal": [
            "\u06C3"
          ]
        },
        "kirghiz oe": {
          "normal": [
            "\u06C5"
          ],
          "isolated": "\uFBE0",
          "final": "\uFBE1"
        },
        "oe": {
          "normal": [
            "\u06C6"
          ],
          "isolated": "\uFBD9",
          "final": "\uFBDA"
        },
        "u": {
          "normal": [
            "\u06C7"
          ],
          "hamza_above": {
            "normal": [
              "\u0677",
              "\u06C7\u0674"
            ],
            "isolated": "\uFBDD"
          },
          "isolated": "\uFBD7",
          "final": "\uFBD8"
        },
        "yu": {
          "normal": [
            "\u06C8"
          ],
          "isolated": "\uFBDB",
          "final": "\uFBDC"
        },
        "kirghiz yu": {
          "normal": [
            "\u06C9"
          ],
          "isolated": "\uFBE2",
          "final": "\uFBE3"
        },
        "ve": {
          "normal": [
            "\u06CB"
          ],
          "isolated": "\uFBDE",
          "final": "\uFBDF"
        },
        "farsi yeh": {
          "normal": [
            "\u06CC"
          ],
          "indic_two_above": [
            "\u0775"
          ],
          "indic_three_above": [
            "\u0776"
          ],
          "indic_four_above": [
            "\u0777"
          ],
          "isolated": "\uFBFC",
          "final": "\uFBFD",
          "initial": "\uFBFE",
          "medial": "\uFBFF"
        },
        "e": {
          "normal": [
            "\u06D0"
          ],
          "isolated": "\uFBE4",
          "final": "\uFBE5",
          "initial": "\uFBE6",
          "medial": "\uFBE7"
        },
        "yeh barree": {
          "normal": [
            "\u06D2"
          ],
          "hamza_above": {
            "normal": [
              "\u06D2\u0654",
              "\u06D3"
            ],
            "isolated": "\uFBB0",
            "final": "\uFBB1"
          },
          "indic_two_above": [
            "\u077A"
          ],
          "indic_three_above": [
            "\u077B"
          ],
          "isolated": "\uFBAE",
          "final": "\uFBAF"
        },
        "ae": {
          "normal": [
            "\u06D5"
          ],
          "isolated": "\u06D5",
          "final": "\uFEEA",
          "yeh_above": {
            "normal": [
              "\u06C0",
              "\u06D5\u0654"
            ],
            "isolated": "\uFBA4",
            "final": "\uFBA5"
          }
        },
        "rohingya yeh": {
          "normal": [
            "\u08AC"
          ]
        },
        "low alef": {
          "normal": [
            "\u08AD"
          ]
        },
        "straight waw": {
          "normal": [
            "\u08B1"
          ]
        },
        "african feh": {
          "normal": [
            "\u08BB"
          ]
        },
        "african qaf": {
          "normal": [
            "\u08BC"
          ]
        },
        "african noon": {
          "normal": [
            "\u08BD"
          ]
        }
      };
      exports2.default = arabicReference;
    }
  });

  // node_modules/alif-toolkit/lib/unicode-ligatures.js
  var require_unicode_ligatures = __commonJS({
    "node_modules/alif-toolkit/lib/unicode-ligatures.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var ligatureReference = {
        "\u0626\u0627": {
          "isolated": "\uFBEA",
          "final": "\uFBEB"
        },
        "\u0626\u06D5": {
          "isolated": "\uFBEC",
          "final": "\uFBED"
        },
        "\u0626\u0648": {
          "isolated": "\uFBEE",
          "final": "\uFBEF"
        },
        "\u0626\u06C7": {
          "isolated": "\uFBF0",
          "final": "\uFBF1"
        },
        "\u0626\u06C6": {
          "isolated": "\uFBF2",
          "final": "\uFBF3"
        },
        "\u0626\u06C8": {
          "isolated": "\uFBF4",
          "final": "\uFBF5"
        },
        "\u0626\u06D0": {
          "isolated": "\uFBF6",
          "final": "\uFBF7",
          "initial": "\uFBF8"
        },
        "\u0626\u0649": {
          "uighur_kirghiz": {
            "isolated": "\uFBF9",
            "final": "\uFBFA",
            "initial": "\uFBFB"
          },
          "isolated": "\uFC03",
          "final": "\uFC68"
        },
        "\u0626\u062C": {
          "isolated": "\uFC00",
          "initial": "\uFC97"
        },
        "\u0626\u062D": {
          "isolated": "\uFC01",
          "initial": "\uFC98"
        },
        "\u0626\u0645": {
          "isolated": "\uFC02",
          "final": "\uFC66",
          "initial": "\uFC9A",
          "medial": "\uFCDF"
        },
        "\u0626\u064A": {
          "isolated": "\uFC04",
          "final": "\uFC69"
        },
        "\u0628\u062C": {
          "isolated": "\uFC05",
          "initial": "\uFC9C"
        },
        "\u0628\u062D": {
          "isolated": "\uFC06",
          "initial": "\uFC9D"
        },
        "\u0628\u062E": {
          "isolated": "\uFC07",
          "initial": "\uFC9E"
        },
        "\u0628\u0645": {
          "isolated": "\uFC08",
          "final": "\uFC6C",
          "initial": "\uFC9F",
          "medial": "\uFCE1"
        },
        "\u0628\u0649": {
          "isolated": "\uFC09",
          "final": "\uFC6E"
        },
        "\u0628\u064A": {
          "isolated": "\uFC0A",
          "final": "\uFC6F"
        },
        "\u062A\u062C": {
          "isolated": "\uFC0B",
          "initial": "\uFCA1"
        },
        "\u062A\u062D": {
          "isolated": "\uFC0C",
          "initial": "\uFCA2"
        },
        "\u062A\u062E": {
          "isolated": "\uFC0D",
          "initial": "\uFCA3"
        },
        "\u062A\u0645": {
          "isolated": "\uFC0E",
          "final": "\uFC72",
          "initial": "\uFCA4",
          "medial": "\uFCE3"
        },
        "\u062A\u0649": {
          "isolated": "\uFC0F",
          "final": "\uFC74"
        },
        "\u062A\u064A": {
          "isolated": "\uFC10",
          "final": "\uFC75"
        },
        "\u062B\u062C": {
          "isolated": "\uFC11"
        },
        "\u062B\u0645": {
          "isolated": "\uFC12",
          "final": "\uFC78",
          "initial": "\uFCA6",
          "medial": "\uFCE5"
        },
        "\u062B\u0649": {
          "isolated": "\uFC13",
          "final": "\uFC7A"
        },
        "\u062B\u0648": {
          "isolated": "\uFC14"
        },
        "\u062C\u062D": {
          "isolated": "\uFC15",
          "initial": "\uFCA7"
        },
        "\u062C\u0645": {
          "isolated": "\uFC16",
          "initial": "\uFCA8"
        },
        "\u062D\u062C": {
          "isolated": "\uFC17",
          "initial": "\uFCA9"
        },
        "\u062D\u0645": {
          "isolated": "\uFC18",
          "initial": "\uFCAA"
        },
        "\u062E\u062C": {
          "isolated": "\uFC19",
          "initial": "\uFCAB"
        },
        "\u062E\u062D": {
          "isolated": "\uFC1A"
        },
        "\u062E\u0645": {
          "isolated": "\uFC1B",
          "initial": "\uFCAC"
        },
        "\u0633\u062C": {
          "isolated": "\uFC1C",
          "initial": "\uFCAD",
          "medial": "\uFD34"
        },
        "\u0633\u062D": {
          "isolated": "\uFC1D",
          "initial": "\uFCAE",
          "medial": "\uFD35"
        },
        "\u0633\u062E": {
          "isolated": "\uFC1E",
          "initial": "\uFCAF",
          "medial": "\uFD36"
        },
        "\u0633\u0645": {
          "isolated": "\uFC1F",
          "initial": "\uFCB0",
          "medial": "\uFCE7"
        },
        "\u0635\u062D": {
          "isolated": "\uFC20",
          "initial": "\uFCB1"
        },
        "\u0635\u0645": {
          "isolated": "\uFC21",
          "initial": "\uFCB3"
        },
        "\u0636\u062C": {
          "isolated": "\uFC22",
          "initial": "\uFCB4"
        },
        "\u0636\u062D": {
          "isolated": "\uFC23",
          "initial": "\uFCB5"
        },
        "\u0636\u062E": {
          "isolated": "\uFC24",
          "initial": "\uFCB6"
        },
        "\u0636\u0645": {
          "isolated": "\uFC25",
          "initial": "\uFCB7"
        },
        "\u0637\u062D": {
          "isolated": "\uFC26",
          "initial": "\uFCB8"
        },
        "\u0637\u0645": {
          "isolated": "\uFC27",
          "initial": "\uFD33",
          "medial": "\uFD3A"
        },
        "\u0638\u0645": {
          "isolated": "\uFC28",
          "initial": "\uFCB9",
          "medial": "\uFD3B"
        },
        "\u0639\u062C": {
          "isolated": "\uFC29",
          "initial": "\uFCBA"
        },
        "\u0639\u0645": {
          "isolated": "\uFC2A",
          "initial": "\uFCBB"
        },
        "\u063A\u062C": {
          "isolated": "\uFC2B",
          "initial": "\uFCBC"
        },
        "\u063A\u0645": {
          "isolated": "\uFC2C",
          "initial": "\uFCBD"
        },
        "\u0641\u062C": {
          "isolated": "\uFC2D",
          "initial": "\uFCBE"
        },
        "\u0641\u062D": {
          "isolated": "\uFC2E",
          "initial": "\uFCBF"
        },
        "\u0641\u062E": {
          "isolated": "\uFC2F",
          "initial": "\uFCC0"
        },
        "\u0641\u0645": {
          "isolated": "\uFC30",
          "initial": "\uFCC1"
        },
        "\u0641\u0649": {
          "isolated": "\uFC31",
          "final": "\uFC7C"
        },
        "\u0641\u064A": {
          "isolated": "\uFC32",
          "final": "\uFC7D"
        },
        "\u0642\u062D": {
          "isolated": "\uFC33",
          "initial": "\uFCC2"
        },
        "\u0642\u0645": {
          "isolated": "\uFC34",
          "initial": "\uFCC3"
        },
        "\u0642\u0649": {
          "isolated": "\uFC35",
          "final": "\uFC7E"
        },
        "\u0642\u064A": {
          "isolated": "\uFC36",
          "final": "\uFC7F"
        },
        "\u0643\u0627": {
          "isolated": "\uFC37",
          "final": "\uFC80"
        },
        "\u0643\u062C": {
          "isolated": "\uFC38",
          "initial": "\uFCC4"
        },
        "\u0643\u062D": {
          "isolated": "\uFC39",
          "initial": "\uFCC5"
        },
        "\u0643\u062E": {
          "isolated": "\uFC3A",
          "initial": "\uFCC6"
        },
        "\u0643\u0644": {
          "isolated": "\uFC3B",
          "final": "\uFC81",
          "initial": "\uFCC7",
          "medial": "\uFCEB"
        },
        "\u0643\u0645": {
          "isolated": "\uFC3C",
          "final": "\uFC82",
          "initial": "\uFCC8",
          "medial": "\uFCEC"
        },
        "\u0643\u0649": {
          "isolated": "\uFC3D",
          "final": "\uFC83"
        },
        "\u0643\u064A": {
          "isolated": "\uFC3E",
          "final": "\uFC84"
        },
        "\u0644\u062C": {
          "isolated": "\uFC3F",
          "initial": "\uFCC9"
        },
        "\u0644\u062D": {
          "isolated": "\uFC40",
          "initial": "\uFCCA"
        },
        "\u0644\u062E": {
          "isolated": "\uFC41",
          "initial": "\uFCCB"
        },
        "\u0644\u0645": {
          "isolated": "\uFC42",
          "final": "\uFC85",
          "initial": "\uFCCC",
          "medial": "\uFCED"
        },
        "\u0644\u0649": {
          "isolated": "\uFC43",
          "final": "\uFC86"
        },
        "\u0644\u064A": {
          "isolated": "\uFC44",
          "final": "\uFC87"
        },
        "\u0645\u062C": {
          "isolated": "\uFC45",
          "initial": "\uFCCE"
        },
        "\u0645\u062D": {
          "isolated": "\uFC46",
          "initial": "\uFCCF"
        },
        "\u0645\u062E": {
          "isolated": "\uFC47",
          "initial": "\uFCD0"
        },
        "\u0645\u0645": {
          "isolated": "\uFC48",
          "final": "\uFC89",
          "initial": "\uFCD1"
        },
        "\u0645\u0649": {
          "isolated": "\uFC49"
        },
        "\u0645\u064A": {
          "isolated": "\uFC4A"
        },
        "\u0646\u062C": {
          "isolated": "\uFC4B",
          "initial": "\uFCD2"
        },
        "\u0646\u062D": {
          "isolated": "\uFC4C",
          "initial": "\uFCD3"
        },
        "\u0646\u062E": {
          "isolated": "\uFC4D",
          "initial": "\uFCD4"
        },
        "\u0646\u0645": {
          "isolated": "\uFC4E",
          "final": "\uFC8C",
          "initial": "\uFCD5",
          "medial": "\uFCEE"
        },
        "\u0646\u0649": {
          "isolated": "\uFC4F",
          "final": "\uFC8E"
        },
        "\u0646\u064A": {
          "isolated": "\uFC50",
          "final": "\uFC8F"
        },
        "\u0647\u062C": {
          "isolated": "\uFC51",
          "initial": "\uFCD7"
        },
        "\u0647\u0645": {
          "isolated": "\uFC52",
          "initial": "\uFCD8"
        },
        "\u0647\u0649": {
          "isolated": "\uFC53"
        },
        "\u0647\u064A": {
          "isolated": "\uFC54"
        },
        "\u064A\u062C": {
          "isolated": "\uFC55",
          "initial": "\uFCDA"
        },
        "\u064A\u062D": {
          "isolated": "\uFC56",
          "initial": "\uFCDB"
        },
        "\u064A\u062E": {
          "isolated": "\uFC57",
          "initial": "\uFCDC"
        },
        "\u064A\u0645": {
          "isolated": "\uFC58",
          "final": "\uFC93",
          "initial": "\uFCDD",
          "medial": "\uFCF0"
        },
        "\u064A\u0649": {
          "isolated": "\uFC59",
          "final": "\uFC95"
        },
        "\u064A\u064A": {
          "isolated": "\uFC5A",
          "final": "\uFC96"
        },
        "\u0630\u0670": {
          "isolated": "\uFC5B"
        },
        "\u0631\u0670": {
          "isolated": "\uFC5C"
        },
        "\u0649\u0670": {
          "isolated": "\uFC5D",
          "final": "\uFC90"
        },
        "\u064C\u0651": {
          "isolated": "\uFC5E"
        },
        "\u064D\u0651": {
          "isolated": "\uFC5F"
        },
        "\u064E\u0651": {
          "isolated": "\uFC60"
        },
        "\u064F\u0651": {
          "isolated": "\uFC61"
        },
        "\u0650\u0651": {
          "isolated": "\uFC62"
        },
        "\u0651\u0670": {
          "isolated": "\uFC63"
        },
        "\u0626\u0631": {
          "final": "\uFC64"
        },
        "\u0626\u0632": {
          "final": "\uFC65"
        },
        "\u0626\u0646": {
          "final": "\uFC67"
        },
        "\u0628\u0631": {
          "final": "\uFC6A"
        },
        "\u0628\u0632": {
          "final": "\uFC6B"
        },
        "\u0628\u0646": {
          "final": "\uFC6D"
        },
        "\u062A\u0631": {
          "final": "\uFC70"
        },
        "\u062A\u0632": {
          "final": "\uFC71"
        },
        "\u062A\u0646": {
          "final": "\uFC73"
        },
        "\u062B\u0631": {
          "final": "\uFC76"
        },
        "\u062B\u0632": {
          "final": "\uFC77"
        },
        "\u062B\u0646": {
          "final": "\uFC79"
        },
        "\u062B\u064A": {
          "final": "\uFC7B"
        },
        "\u0645\u0627": {
          "final": "\uFC88"
        },
        "\u0646\u0631": {
          "final": "\uFC8A"
        },
        "\u0646\u0632": {
          "final": "\uFC8B"
        },
        "\u0646\u0646": {
          "final": "\uFC8D"
        },
        "\u064A\u0631": {
          "final": "\uFC91"
        },
        "\u064A\u0632": {
          "final": "\uFC92"
        },
        "\u064A\u0646": {
          "final": "\uFC94"
        },
        "\u0626\u062E": {
          "initial": "\uFC99"
        },
        "\u0626\u0647": {
          "initial": "\uFC9B",
          "medial": "\uFCE0"
        },
        "\u0628\u0647": {
          "initial": "\uFCA0",
          "medial": "\uFCE2"
        },
        "\u062A\u0647": {
          "initial": "\uFCA5",
          "medial": "\uFCE4"
        },
        "\u0635\u062E": {
          "initial": "\uFCB2"
        },
        "\u0644\u0647": {
          "initial": "\uFCCD"
        },
        "\u0646\u0647": {
          "initial": "\uFCD6",
          "medial": "\uFCEF"
        },
        "\u0647\u0670": {
          "initial": "\uFCD9"
        },
        "\u064A\u0647": {
          "initial": "\uFCDE",
          "medial": "\uFCF1"
        },
        "\u062B\u0647": {
          "medial": "\uFCE6"
        },
        "\u0633\u0647": {
          "medial": "\uFCE8",
          "initial": "\uFD31"
        },
        "\u0634\u0645": {
          "medial": "\uFCE9",
          "isolated": "\uFD0C",
          "final": "\uFD28",
          "initial": "\uFD30"
        },
        "\u0634\u0647": {
          "medial": "\uFCEA",
          "initial": "\uFD32"
        },
        "\u0640\u064E\u0651": {
          "medial": "\uFCF2"
        },
        "\u0640\u064F\u0651": {
          "medial": "\uFCF3"
        },
        "\u0640\u0650\u0651": {
          "medial": "\uFCF4"
        },
        "\u0637\u0649": {
          "isolated": "\uFCF5",
          "final": "\uFD11"
        },
        "\u0637\u064A": {
          "isolated": "\uFCF6",
          "final": "\uFD12"
        },
        "\u0639\u0649": {
          "isolated": "\uFCF7",
          "final": "\uFD13"
        },
        "\u0639\u064A": {
          "isolated": "\uFCF8",
          "final": "\uFD14"
        },
        "\u063A\u0649": {
          "isolated": "\uFCF9",
          "final": "\uFD15"
        },
        "\u063A\u064A": {
          "isolated": "\uFCFA",
          "final": "\uFD16"
        },
        "\u0633\u0649": {
          "isolated": "\uFCFB"
        },
        "\u0633\u064A": {
          "isolated": "\uFCFC",
          "final": "\uFD18"
        },
        "\u0634\u0649": {
          "isolated": "\uFCFD",
          "final": "\uFD19"
        },
        "\u0634\u064A": {
          "isolated": "\uFCFE",
          "final": "\uFD1A"
        },
        "\u062D\u0649": {
          "isolated": "\uFCFF",
          "final": "\uFD1B"
        },
        "\u062D\u064A": {
          "isolated": "\uFD00",
          "final": "\uFD1C"
        },
        "\u062C\u0649": {
          "isolated": "\uFD01",
          "final": "\uFD1D"
        },
        "\u062C\u064A": {
          "isolated": "\uFD02",
          "final": "\uFD1E"
        },
        "\u062E\u0649": {
          "isolated": "\uFD03",
          "final": "\uFD1F"
        },
        "\u062E\u064A": {
          "isolated": "\uFD04",
          "final": "\uFD20"
        },
        "\u0635\u0649": {
          "isolated": "\uFD05",
          "final": "\uFD21"
        },
        "\u0635\u064A": {
          "isolated": "\uFD06",
          "final": "\uFD22"
        },
        "\u0636\u0649": {
          "isolated": "\uFD07",
          "final": "\uFD23"
        },
        "\u0636\u064A": {
          "isolated": "\uFD08",
          "final": "\uFD24"
        },
        "\u0634\u062C": {
          "isolated": "\uFD09",
          "final": "\uFD25",
          "initial": "\uFD2D",
          "medial": "\uFD37"
        },
        "\u0634\u062D": {
          "isolated": "\uFD0A",
          "final": "\uFD26",
          "initial": "\uFD2E",
          "medial": "\uFD38"
        },
        "\u0634\u062E": {
          "isolated": "\uFD0B",
          "final": "\uFD27",
          "initial": "\uFD2F",
          "medial": "\uFD39"
        },
        "\u0634\u0631": {
          "isolated": "\uFD0D",
          "final": "\uFD29"
        },
        "\u0633\u0631": {
          "isolated": "\uFD0E",
          "final": "\uFD2A"
        },
        "\u0635\u0631": {
          "isolated": "\uFD0F",
          "final": "\uFD2B"
        },
        "\u0636\u0631": {
          "isolated": "\uFD10",
          "final": "\uFD2C"
        },
        "\u0633\u0639": {
          "final": "\uFD17"
        },
        "\u062A\u062C\u0645": {
          "initial": "\uFD50"
        },
        "\u062A\u062D\u062C": {
          "final": "\uFD51",
          "initial": "\uFD52"
        },
        "\u062A\u062D\u0645": {
          "initial": "\uFD53"
        },
        "\u062A\u062E\u0645": {
          "initial": "\uFD54"
        },
        "\u062A\u0645\u062C": {
          "initial": "\uFD55"
        },
        "\u062A\u0645\u062D": {
          "initial": "\uFD56"
        },
        "\u062A\u0645\u062E": {
          "initial": "\uFD57"
        },
        "\u062C\u0645\u062D": {
          "final": "\uFD58",
          "initial": "\uFD59"
        },
        "\u062D\u0645\u064A": {
          "final": "\uFD5A"
        },
        "\u062D\u0645\u0649": {
          "final": "\uFD5B"
        },
        "\u0633\u062D\u062C": {
          "initial": "\uFD5C"
        },
        "\u0633\u062C\u062D": {
          "initial": "\uFD5D"
        },
        "\u0633\u062C\u0649": {
          "final": "\uFD5E"
        },
        "\u0633\u0645\u062D": {
          "final": "\uFD5F",
          "initial": "\uFD60"
        },
        "\u0633\u0645\u062C": {
          "initial": "\uFD61"
        },
        "\u0633\u0645\u0645": {
          "final": "\uFD62",
          "initial": "\uFD63"
        },
        "\u0635\u062D\u062D": {
          "final": "\uFD64",
          "initial": "\uFD65"
        },
        "\u0635\u0645\u0645": {
          "final": "\uFD66",
          "initial": "\uFDC5"
        },
        "\u0634\u062D\u0645": {
          "final": "\uFD67",
          "initial": "\uFD68"
        },
        "\u0634\u062C\u064A": {
          "final": "\uFD69"
        },
        "\u0634\u0645\u062E": {
          "final": "\uFD6A",
          "initial": "\uFD6B"
        },
        "\u0634\u0645\u0645": {
          "final": "\uFD6C",
          "initial": "\uFD6D"
        },
        "\u0636\u062D\u0649": {
          "final": "\uFD6E"
        },
        "\u0636\u062E\u0645": {
          "final": "\uFD6F",
          "initial": "\uFD70"
        },
        "\u0636\u0645\u062D": {
          "final": "\uFD71"
        },
        "\u0637\u0645\u062D": {
          "initial": "\uFD72"
        },
        "\u0637\u0645\u0645": {
          "initial": "\uFD73"
        },
        "\u0637\u0645\u064A": {
          "final": "\uFD74"
        },
        "\u0639\u062C\u0645": {
          "final": "\uFD75",
          "initial": "\uFDC4"
        },
        "\u0639\u0645\u0645": {
          "final": "\uFD76",
          "initial": "\uFD77"
        },
        "\u0639\u0645\u0649": {
          "final": "\uFD78"
        },
        "\u063A\u0645\u0645": {
          "final": "\uFD79"
        },
        "\u063A\u0645\u064A": {
          "final": "\uFD7A"
        },
        "\u063A\u0645\u0649": {
          "final": "\uFD7B"
        },
        "\u0641\u062E\u0645": {
          "final": "\uFD7C",
          "initial": "\uFD7D"
        },
        "\u0642\u0645\u062D": {
          "final": "\uFD7E",
          "initial": "\uFDB4"
        },
        "\u0642\u0645\u0645": {
          "final": "\uFD7F"
        },
        "\u0644\u062D\u0645": {
          "final": "\uFD80",
          "initial": "\uFDB5"
        },
        "\u0644\u062D\u064A": {
          "final": "\uFD81"
        },
        "\u0644\u062D\u0649": {
          "final": "\uFD82"
        },
        "\u0644\u062C\u062C": {
          "initial": "\uFD83",
          "final": "\uFD84"
        },
        "\u0644\u062E\u0645": {
          "final": "\uFD85",
          "initial": "\uFD86"
        },
        "\u0644\u0645\u062D": {
          "final": "\uFD87",
          "initial": "\uFD88"
        },
        "\u0645\u062D\u062C": {
          "initial": "\uFD89"
        },
        "\u0645\u062D\u0645": {
          "initial": "\uFD8A"
        },
        "\u0645\u062D\u064A": {
          "final": "\uFD8B"
        },
        "\u0645\u062C\u062D": {
          "initial": "\uFD8C"
        },
        "\u0645\u062C\u0645": {
          "initial": "\uFD8D"
        },
        "\u0645\u062E\u062C": {
          "initial": "\uFD8E"
        },
        "\u0645\u062E\u0645": {
          "initial": "\uFD8F"
        },
        "\u0645\u062C\u062E": {
          "initial": "\uFD92"
        },
        "\u0647\u0645\u062C": {
          "initial": "\uFD93"
        },
        "\u0647\u0645\u0645": {
          "initial": "\uFD94"
        },
        "\u0646\u062D\u0645": {
          "initial": "\uFD95"
        },
        "\u0646\u062D\u0649": {
          "final": "\uFD96"
        },
        "\u0646\u062C\u0645": {
          "final": "\uFD97",
          "initial": "\uFD98"
        },
        "\u0646\u062C\u0649": {
          "final": "\uFD99"
        },
        "\u0646\u0645\u064A": {
          "final": "\uFD9A"
        },
        "\u0646\u0645\u0649": {
          "final": "\uFD9B"
        },
        "\u064A\u0645\u0645": {
          "final": "\uFD9C",
          "initial": "\uFD9D"
        },
        "\u0628\u062E\u064A": {
          "final": "\uFD9E"
        },
        "\u062A\u062C\u064A": {
          "final": "\uFD9F"
        },
        "\u062A\u062C\u0649": {
          "final": "\uFDA0"
        },
        "\u062A\u062E\u064A": {
          "final": "\uFDA1"
        },
        "\u062A\u062E\u0649": {
          "final": "\uFDA2"
        },
        "\u062A\u0645\u064A": {
          "final": "\uFDA3"
        },
        "\u062A\u0645\u0649": {
          "final": "\uFDA4"
        },
        "\u062C\u0645\u064A": {
          "final": "\uFDA5"
        },
        "\u062C\u062D\u0649": {
          "final": "\uFDA6"
        },
        "\u062C\u0645\u0649": {
          "final": "\uFDA7"
        },
        "\u0633\u062E\u0649": {
          "final": "\uFDA8"
        },
        "\u0635\u062D\u064A": {
          "final": "\uFDA9"
        },
        "\u0634\u062D\u064A": {
          "final": "\uFDAA"
        },
        "\u0636\u062D\u064A": {
          "final": "\uFDAB"
        },
        "\u0644\u062C\u064A": {
          "final": "\uFDAC"
        },
        "\u0644\u0645\u064A": {
          "final": "\uFDAD"
        },
        "\u064A\u062D\u064A": {
          "final": "\uFDAE"
        },
        "\u064A\u062C\u064A": {
          "final": "\uFDAF"
        },
        "\u064A\u0645\u064A": {
          "final": "\uFDB0"
        },
        "\u0645\u0645\u064A": {
          "final": "\uFDB1"
        },
        "\u0642\u0645\u064A": {
          "final": "\uFDB2"
        },
        "\u0646\u062D\u064A": {
          "final": "\uFDB3"
        },
        "\u0639\u0645\u064A": {
          "final": "\uFDB6"
        },
        "\u0643\u0645\u064A": {
          "final": "\uFDB7"
        },
        "\u0646\u062C\u062D": {
          "initial": "\uFDB8",
          "final": "\uFDBD"
        },
        "\u0645\u062E\u064A": {
          "final": "\uFDB9"
        },
        "\u0644\u062C\u0645": {
          "initial": "\uFDBA",
          "final": "\uFDBC"
        },
        "\u0643\u0645\u0645": {
          "final": "\uFDBB",
          "initial": "\uFDC3"
        },
        "\u062C\u062D\u064A": {
          "final": "\uFDBE"
        },
        "\u062D\u062C\u064A": {
          "final": "\uFDBF"
        },
        "\u0645\u062C\u064A": {
          "final": "\uFDC0"
        },
        "\u0641\u0645\u064A": {
          "final": "\uFDC1"
        },
        "\u0628\u062D\u064A": {
          "final": "\uFDC2"
        },
        "\u0633\u062E\u064A": {
          "final": "\uFDC6"
        },
        "\u0646\u062C\u064A": {
          "final": "\uFDC7"
        },
        "\u0644\u0622": {
          "isolated": "\uFEF5",
          "final": "\uFEF6"
        },
        "\u0644\u0623": {
          "isolated": "\uFEF7",
          "final": "\uFEF8"
        },
        "\u0644\u0625": {
          "isolated": "\uFEF9",
          "final": "\uFEFA"
        },
        "\u0644\u0627": {
          "isolated": "\uFEFB",
          "final": "\uFEFC"
        },
        "words": {
          "\u0635\u0644\u06D2": "\uFDF0",
          "\u0642\u0644\u06D2": "\uFDF1",
          "\u0627\u0644\u0644\u0647": "\uFDF2",
          "\u0627\u0643\u0628\u0631": "\uFDF3",
          "\u0645\u062D\u0645\u062F": "\uFDF4",
          "\u0635\u0644\u0639\u0645": "\uFDF5",
          "\u0631\u0633\u0648\u0644": "\uFDF6",
          "\u0639\u0644\u064A\u0647": "\uFDF7",
          "\u0648\u0633\u0644\u0645": "\uFDF8",
          "\u0635\u0644\u0649": "\uFDF9",
          "\u0635\u0644\u0649\u0627\u0644\u0644\u0647\u0639\u0644\u064A\u0647\u0648\u0633\u0644\u0645": "\uFDFA",
          "\u062C\u0644\u062C\u0644\u0627\u0644\u0647": "\uFDFB",
          "\u0631\u06CC\u0627\u0644": "\uFDFC"
        }
      };
      exports2.default = ligatureReference;
    }
  });

  // node_modules/alif-toolkit/lib/reference.js
  var require_reference = __commonJS({
    "node_modules/alif-toolkit/lib/reference.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var unicode_arabic_1 = require_unicode_arabic();
      var unicode_ligatures_1 = require_unicode_ligatures();
      var letterList = Object.keys(unicode_arabic_1.default);
      exports2.letterList = letterList;
      var ligatureList = Object.keys(unicode_ligatures_1.default);
      exports2.ligatureList = ligatureList;
      var ligatureWordList = Object.keys(unicode_ligatures_1.default.words);
      exports2.ligatureWordList = ligatureWordList;
      var lams = "\u0644\u06B5\u06B6\u06B7\u06B8";
      exports2.lams = lams;
      var alefs = "\u0627\u0622\u0623\u0625\u0671\u0672\u0673\u0675\u0773\u0774";
      exports2.alefs = alefs;
      var tashkeel = "\u0605\u0640\u0670\u0674\u06DF\u06E7\u06E8";
      exports2.tashkeel = tashkeel;
      function addToTashkeel(start2, finish) {
        for (var i3 = start2; i3 <= finish; i3++) {
          exports2.tashkeel = tashkeel += String.fromCharCode(i3);
        }
      }
      addToTashkeel(1552, 1562);
      addToTashkeel(1611, 1631);
      addToTashkeel(1750, 1756);
      addToTashkeel(1760, 1764);
      addToTashkeel(1770, 1773);
      addToTashkeel(2259, 2273);
      addToTashkeel(2275, 2303);
      addToTashkeel(65136, 65151);
      var lineBreakers = "\u0627\u0629\u0648\u06C0\u06CF\u06FD\u06FE\u076B\u076C\u0771\u0773\u0774\u0778\u0779\u08E2\u08B1\u08B2\u08B9";
      exports2.lineBreakers = lineBreakers;
      function addToLineBreakers(start2, finish) {
        for (var i3 = start2; i3 <= finish; i3++) {
          exports2.lineBreakers = lineBreakers += String.fromCharCode(i3);
        }
      }
      addToLineBreakers(1536, 1567);
      addToLineBreakers(1569, 1573);
      addToLineBreakers(1583, 1586);
      addToLineBreakers(1632, 1645);
      addToLineBreakers(1649, 1655);
      addToLineBreakers(1672, 1689);
      addToLineBreakers(1731, 1739);
      addToLineBreakers(1746, 1785);
      addToLineBreakers(1881, 1883);
      addToLineBreakers(2218, 2222);
      addToLineBreakers(64336, 65021);
      addToLineBreakers(65152, 65276);
      addToLineBreakers(69216, 69247);
      addToLineBreakers(126064, 126143);
      addToLineBreakers(126464, 126719);
    }
  });

  // node_modules/alif-toolkit/lib/GlyphSplitter.js
  var require_GlyphSplitter = __commonJS({
    "node_modules/alif-toolkit/lib/GlyphSplitter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var isArabic_1 = require_isArabic();
      var reference_1 = require_reference();
      function GlyphSplitter(word) {
        let letters = [];
        let lastLetter = "";
        word.split("").forEach((letter) => {
          if (isArabic_1.isArabic(letter)) {
            if (reference_1.tashkeel.indexOf(letter) > -1) {
              letters[letters.length - 1] += letter;
            } else if (lastLetter.length && (reference_1.lams.indexOf(lastLetter) === 0 && reference_1.alefs.indexOf(letter) > -1 || reference_1.lams.indexOf(lastLetter) > 0 && reference_1.alefs.indexOf(letter) === 0)) {
              letters[letters.length - 1] += letter;
            } else {
              letters.push(letter);
            }
          } else {
            letters.push(letter);
          }
          if (reference_1.tashkeel.indexOf(letter) === -1) {
            lastLetter = letter;
          }
        });
        return letters;
      }
      exports2.GlyphSplitter = GlyphSplitter;
    }
  });

  // node_modules/alif-toolkit/lib/BaselineSplitter.js
  var require_BaselineSplitter = __commonJS({
    "node_modules/alif-toolkit/lib/BaselineSplitter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var isArabic_1 = require_isArabic();
      var reference_1 = require_reference();
      function BaselineSplitter(word) {
        let letters = [];
        let lastLetter = "";
        word.split("").forEach((letter) => {
          if (isArabic_1.isArabic(letter) && isArabic_1.isArabic(lastLetter)) {
            if (lastLetter.length && reference_1.tashkeel.indexOf(letter) > -1) {
              letters[letters.length - 1] += letter;
            } else if (reference_1.lineBreakers.indexOf(lastLetter) > -1) {
              letters.push(letter);
            } else {
              letters[letters.length - 1] += letter;
            }
          } else {
            letters.push(letter);
          }
          if (reference_1.tashkeel.indexOf(letter) === -1) {
            lastLetter = letter;
          }
        });
        return letters;
      }
      exports2.BaselineSplitter = BaselineSplitter;
    }
  });

  // node_modules/alif-toolkit/lib/Normalization.js
  var require_Normalization = __commonJS({
    "node_modules/alif-toolkit/lib/Normalization.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var unicode_arabic_1 = require_unicode_arabic();
      var unicode_ligatures_1 = require_unicode_ligatures();
      var isArabic_1 = require_isArabic();
      var reference_1 = require_reference();
      function Normal(word, breakPresentationForm) {
        if (typeof breakPresentationForm === "undefined") {
          breakPresentationForm = true;
        }
        let returnable = "";
        word.split("").forEach((letter) => {
          if (!isArabic_1.isArabic(letter)) {
            returnable += letter;
            return;
          }
          for (let w2 = 0; w2 < reference_1.letterList.length; w2++) {
            let letterForms = unicode_arabic_1.default[reference_1.letterList[w2]];
            let versions = Object.keys(letterForms);
            for (let v2 = 0; v2 < versions.length; v2++) {
              let localVersion = letterForms[versions[v2]];
              if (typeof localVersion === "object" && typeof localVersion.indexOf === "undefined") {
                let embeddedForms = Object.keys(localVersion);
                for (let ef = 0; ef < embeddedForms.length; ef++) {
                  let form = localVersion[embeddedForms[ef]];
                  if (form === letter || typeof form === "object" && form.indexOf && form.indexOf(letter) > -1) {
                    if (form === letter) {
                      if (breakPresentationForm && localVersion["normal"] && ["isolated", "initial", "medial", "final"].indexOf(embeddedForms[ef]) > -1) {
                        if (typeof localVersion["normal"] === "object") {
                          returnable += localVersion["normal"][0];
                        } else {
                          returnable += localVersion["normal"];
                        }
                        return;
                      }
                      returnable += letter;
                      return;
                    } else if (typeof form === "object" && form.indexOf && form.indexOf(letter) > -1) {
                      returnable += form[0];
                      return;
                    }
                  }
                }
              } else if (localVersion === letter) {
                if (breakPresentationForm && letterForms["normal"] && ["isolated", "initial", "medial", "final"].indexOf(versions[v2]) > -1) {
                  if (typeof letterForms["normal"] === "object") {
                    returnable += letterForms["normal"][0];
                  } else {
                    returnable += letterForms["normal"];
                  }
                  return;
                }
                returnable += letter;
                return;
              } else if (typeof localVersion === "object" && localVersion.indexOf && localVersion.indexOf(letter) > -1) {
                returnable += localVersion[0];
                return;
              }
            }
          }
          for (let v2 = 0; v2 < reference_1.ligatureList.length; v2++) {
            let normalForm = reference_1.ligatureList[v2];
            if (normalForm !== "words") {
              let ligForms = Object.keys(unicode_ligatures_1.default[normalForm]);
              for (let f2 = 0; f2 < ligForms.length; f2++) {
                if (unicode_ligatures_1.default[normalForm][ligForms[f2]] === letter) {
                  returnable += normalForm;
                  return;
                }
              }
            }
          }
          for (let v3 = 0; v3 < reference_1.ligatureWordList.length; v3++) {
            let normalForm = reference_1.ligatureWordList[v3];
            if (unicode_ligatures_1.default.words[normalForm] === letter) {
              returnable += normalForm;
              return;
            }
          }
          returnable += letter;
        });
        return returnable;
      }
      exports2.Normal = Normal;
    }
  });

  // node_modules/alif-toolkit/lib/CharShaper.js
  var require_CharShaper = __commonJS({
    "node_modules/alif-toolkit/lib/CharShaper.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var unicode_arabic_1 = require_unicode_arabic();
      var isArabic_1 = require_isArabic();
      var reference_1 = require_reference();
      function CharShaper(letter, form) {
        if (!isArabic_1.isArabic(letter)) {
          throw new Error("Not Arabic");
        }
        if (letter === "\u0621") {
          return "\u0621";
        }
        for (let w2 = 0; w2 < reference_1.letterList.length; w2++) {
          let letterForms = unicode_arabic_1.default[reference_1.letterList[w2]];
          let versions = Object.keys(letterForms);
          for (let v2 = 0; v2 < versions.length; v2++) {
            let localVersion = letterForms[versions[v2]];
            if (localVersion === letter || typeof localVersion === "object" && localVersion.indexOf && localVersion.indexOf(letter) > -1) {
              if (versions.indexOf(form) > -1) {
                return letterForms[form];
              }
            } else if (typeof localVersion === "object" && typeof localVersion.indexOf === "undefined") {
              let embeddedVersions = Object.keys(localVersion);
              for (let ev = 0; ev < embeddedVersions.length; ev++) {
                if (localVersion[embeddedVersions[ev]] === letter || typeof localVersion[embeddedVersions[ev]] === "object" && localVersion[embeddedVersions[ev]].indexOf && localVersion[embeddedVersions[ev]].indexOf(letter) > -1) {
                  if (embeddedVersions.indexOf(form) > -1) {
                    return localVersion[form];
                  }
                }
              }
            }
          }
        }
      }
      exports2.CharShaper = CharShaper;
    }
  });

  // node_modules/alif-toolkit/lib/WordShaper.js
  var require_WordShaper = __commonJS({
    "node_modules/alif-toolkit/lib/WordShaper.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var isArabic_1 = require_isArabic();
      var reference_1 = require_reference();
      var CharShaper_1 = require_CharShaper();
      var unicode_ligatures_1 = require_unicode_ligatures();
      function WordShaper2(word) {
        let state = "initial";
        let output = "";
        for (let w2 = 0; w2 < word.length; w2++) {
          let nextLetter = " ";
          for (let nxw = w2 + 1; nxw < word.length; nxw++) {
            if (!isArabic_1.isArabic(word[nxw])) {
              break;
            }
            if (reference_1.tashkeel.indexOf(word[nxw]) === -1) {
              nextLetter = word[nxw];
              break;
            }
          }
          if (!isArabic_1.isArabic(word[w2]) || isArabic_1.isMath(word[w2])) {
            output += word[w2];
            state = "initial";
          } else if (reference_1.tashkeel.indexOf(word[w2]) > -1) {
            output += word[w2];
          } else if (nextLetter === " " || reference_1.lineBreakers.indexOf(word[w2]) > -1) {
            output += CharShaper_1.CharShaper(word[w2], state === "initial" ? "isolated" : "final");
            state = "initial";
          } else if (reference_1.lams.indexOf(word[w2]) > -1 && reference_1.alefs.indexOf(nextLetter) > -1) {
            output += unicode_ligatures_1.default[word[w2] + nextLetter][state === "initial" ? "isolated" : "final"];
            while (word[w2] !== nextLetter) {
              w2++;
            }
            state = "initial";
          } else {
            output += CharShaper_1.CharShaper(word[w2], state);
            state = "medial";
          }
        }
        return output;
      }
      exports2.WordShaper = WordShaper2;
    }
  });

  // node_modules/alif-toolkit/lib/ParentLetter.js
  var require_ParentLetter = __commonJS({
    "node_modules/alif-toolkit/lib/ParentLetter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var unicode_arabic_1 = require_unicode_arabic();
      var isArabic_1 = require_isArabic();
      var reference_1 = require_reference();
      function ParentLetter(letter) {
        if (!isArabic_1.isArabic(letter)) {
          throw new Error("Not an Arabic letter");
        }
        for (let w2 = 0; w2 < reference_1.letterList.length; w2++) {
          let letterForms = unicode_arabic_1.default[reference_1.letterList[w2]];
          let versions = Object.keys(letterForms);
          for (let v2 = 0; v2 < versions.length; v2++) {
            let localVersion = letterForms[versions[v2]];
            if (typeof localVersion === "object" && typeof localVersion.indexOf === "undefined") {
              let embeddedForms = Object.keys(localVersion);
              for (let ef = 0; ef < embeddedForms.length; ef++) {
                let form = localVersion[embeddedForms[ef]];
                if (form === letter || typeof form === "object" && form.indexOf && form.indexOf(letter) > -1) {
                  return localVersion;
                }
              }
            } else if (localVersion === letter || typeof localVersion === "object" && localVersion.indexOf && localVersion.indexOf(letter) > -1) {
              return letterForms;
            }
          }
          return null;
        }
      }
      exports2.ParentLetter = ParentLetter;
      function GrandparentLetter(letter) {
        if (!isArabic_1.isArabic(letter)) {
          throw new Error("Not an Arabic letter");
        }
        for (let w2 = 0; w2 < reference_1.letterList.length; w2++) {
          let letterForms = unicode_arabic_1.default[reference_1.letterList[w2]];
          let versions = Object.keys(letterForms);
          for (let v2 = 0; v2 < versions.length; v2++) {
            let localVersion = letterForms[versions[v2]];
            if (typeof localVersion === "object" && typeof localVersion.indexOf === "undefined") {
              let embeddedForms = Object.keys(localVersion);
              for (let ef = 0; ef < embeddedForms.length; ef++) {
                let form = localVersion[embeddedForms[ef]];
                if (form === letter || typeof form === "object" && form.indexOf && form.indexOf(letter) > -1) {
                  return letterForms;
                }
              }
            } else if (localVersion === letter || typeof localVersion === "object" && localVersion.indexOf && localVersion.indexOf(letter) > -1) {
              return letterForms;
            }
          }
          return null;
        }
      }
      exports2.GrandparentLetter = GrandparentLetter;
    }
  });

  // node_modules/alif-toolkit/lib/index.js
  var require_lib = __commonJS({
    "node_modules/alif-toolkit/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var isArabic_1 = require_isArabic();
      exports2.isArabic = isArabic_1.isArabic;
      var GlyphSplitter_1 = require_GlyphSplitter();
      exports2.GlyphSplitter = GlyphSplitter_1.GlyphSplitter;
      var BaselineSplitter_1 = require_BaselineSplitter();
      exports2.BaselineSplitter = BaselineSplitter_1.BaselineSplitter;
      var Normalization_1 = require_Normalization();
      exports2.Normal = Normalization_1.Normal;
      var CharShaper_1 = require_CharShaper();
      exports2.CharShaper = CharShaper_1.CharShaper;
      var WordShaper_1 = require_WordShaper();
      exports2.WordShaper = WordShaper_1.WordShaper;
      var ParentLetter_1 = require_ParentLetter();
      exports2.ParentLetter = ParentLetter_1.ParentLetter;
      exports2.GrandparentLetter = ParentLetter_1.GrandparentLetter;
    }
  });

  // node_modules/vparse/index.js
  var require_vparse = __commonJS({
    "node_modules/vparse/index.js"(exports2, module2) {
      (function(window2) {
        "use strict";
        function parseVersion3(v2) {
          var m2 = v2.replace(/[^0-9.]/g, "").match(/[0-9]*\.|[0-9]+/g) || [];
          v2 = {
            major: +m2[0] || 0,
            minor: +m2[1] || 0,
            patch: +m2[2] || 0,
            build: +m2[3] || 0
          };
          v2.isEmpty = !v2.major && !v2.minor && !v2.patch && !v2.build;
          v2.parsed = [v2.major, v2.minor, v2.patch, v2.build];
          v2.text = v2.parsed.join(".");
          v2.compare = compare2;
          return v2;
        }
        function compare2(v2) {
          if (typeof v2 === "string") {
            v2 = parseVersion3(v2);
          }
          for (var i3 = 0; i3 < 4; i3++) {
            if (this.parsed[i3] !== v2.parsed[i3]) {
              return this.parsed[i3] > v2.parsed[i3] ? 1 : -1;
            }
          }
          return 0;
        }
        if (typeof module2 === "object" && module2 && typeof module2.exports === "object") {
          module2.exports = parseVersion3;
        } else {
          window2.parseVersion = parseVersion3;
        }
      })(exports2);
    }
  });

  // node_modules/which-polygon/node_modules/quickselect/quickselect.js
  var require_quickselect = __commonJS({
    "node_modules/which-polygon/node_modules/quickselect/quickselect.js"(exports2, module2) {
      (function(global2, factory) {
        typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.quickselect = factory();
      })(exports2, function() {
        "use strict";
        function quickselect2(arr, k2, left, right, compare2) {
          quickselectStep(arr, k2, left || 0, right || arr.length - 1, compare2 || defaultCompare);
        }
        function quickselectStep(arr, k2, left, right, compare2) {
          while (right > left) {
            if (right - left > 600) {
              var n3 = right - left + 1;
              var m2 = k2 - left + 1;
              var z2 = Math.log(n3);
              var s2 = 0.5 * Math.exp(2 * z2 / 3);
              var sd = 0.5 * Math.sqrt(z2 * s2 * (n3 - s2) / n3) * (m2 - n3 / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k2 - m2 * s2 / n3 + sd));
              var newRight = Math.min(right, Math.floor(k2 + (n3 - m2) * s2 / n3 + sd));
              quickselectStep(arr, k2, newLeft, newRight, compare2);
            }
            var t2 = arr[k2];
            var i3 = left;
            var j2 = right;
            swap2(arr, left, k2);
            if (compare2(arr[right], t2) > 0)
              swap2(arr, left, right);
            while (i3 < j2) {
              swap2(arr, i3, j2);
              i3++;
              j2--;
              while (compare2(arr[i3], t2) < 0)
                i3++;
              while (compare2(arr[j2], t2) > 0)
                j2--;
            }
            if (compare2(arr[left], t2) === 0)
              swap2(arr, left, j2);
            else {
              j2++;
              swap2(arr, j2, right);
            }
            if (j2 <= k2)
              left = j2 + 1;
            if (k2 <= j2)
              right = j2 - 1;
          }
        }
        function swap2(arr, i3, j2) {
          var tmp = arr[i3];
          arr[i3] = arr[j2];
          arr[j2] = tmp;
        }
        function defaultCompare(a2, b2) {
          return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
        }
        return quickselect2;
      });
    }
  });

  // node_modules/which-polygon/node_modules/rbush/index.js
  var require_rbush = __commonJS({
    "node_modules/which-polygon/node_modules/rbush/index.js"(exports2, module2) {
      "use strict";
      module2.exports = rbush;
      module2.exports.default = rbush;
      var quickselect2 = require_quickselect();
      function rbush(maxEntries, format2) {
        if (!(this instanceof rbush))
          return new rbush(maxEntries, format2);
        this._maxEntries = Math.max(4, maxEntries || 9);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        if (format2) {
          this._initFormat(format2);
        }
        this.clear();
      }
      rbush.prototype = {
        all: function() {
          return this._all(this.data, []);
        },
        search: function(bbox2) {
          var node = this.data, result = [], toBBox = this.toBBox;
          if (!intersects(bbox2, node))
            return result;
          var nodesToSearch = [], i3, len, child, childBBox;
          while (node) {
            for (i3 = 0, len = node.children.length; i3 < len; i3++) {
              child = node.children[i3];
              childBBox = node.leaf ? toBBox(child) : child;
              if (intersects(bbox2, childBBox)) {
                if (node.leaf)
                  result.push(child);
                else if (contains(bbox2, childBBox))
                  this._all(child, result);
                else
                  nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return result;
        },
        collides: function(bbox2) {
          var node = this.data, toBBox = this.toBBox;
          if (!intersects(bbox2, node))
            return false;
          var nodesToSearch = [], i3, len, child, childBBox;
          while (node) {
            for (i3 = 0, len = node.children.length; i3 < len; i3++) {
              child = node.children[i3];
              childBBox = node.leaf ? toBBox(child) : child;
              if (intersects(bbox2, childBBox)) {
                if (node.leaf || contains(bbox2, childBBox))
                  return true;
                nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return false;
        },
        load: function(data) {
          if (!(data && data.length))
            return this;
          if (data.length < this._minEntries) {
            for (var i3 = 0, len = data.length; i3 < len; i3++) {
              this.insert(data[i3]);
            }
            return this;
          }
          var node = this._build(data.slice(), 0, data.length - 1, 0);
          if (!this.data.children.length) {
            this.data = node;
          } else if (this.data.height === node.height) {
            this._splitRoot(this.data, node);
          } else {
            if (this.data.height < node.height) {
              var tmpNode = this.data;
              this.data = node;
              node = tmpNode;
            }
            this._insert(node, this.data.height - node.height - 1, true);
          }
          return this;
        },
        insert: function(item) {
          if (item)
            this._insert(item, this.data.height - 1);
          return this;
        },
        clear: function() {
          this.data = createNode([]);
          return this;
        },
        remove: function(item, equalsFn) {
          if (!item)
            return this;
          var node = this.data, bbox2 = this.toBBox(item), path = [], indexes = [], i3, parent, index, goingUp;
          while (node || path.length) {
            if (!node) {
              node = path.pop();
              parent = path[path.length - 1];
              i3 = indexes.pop();
              goingUp = true;
            }
            if (node.leaf) {
              index = findItem(item, node.children, equalsFn);
              if (index !== -1) {
                node.children.splice(index, 1);
                path.push(node);
                this._condense(path);
                return this;
              }
            }
            if (!goingUp && !node.leaf && contains(node, bbox2)) {
              path.push(node);
              indexes.push(i3);
              i3 = 0;
              parent = node;
              node = node.children[0];
            } else if (parent) {
              i3++;
              node = parent.children[i3];
              goingUp = false;
            } else
              node = null;
          }
          return this;
        },
        toBBox: function(item) {
          return item;
        },
        compareMinX: compareNodeMinX,
        compareMinY: compareNodeMinY,
        toJSON: function() {
          return this.data;
        },
        fromJSON: function(data) {
          this.data = data;
          return this;
        },
        _all: function(node, result) {
          var nodesToSearch = [];
          while (node) {
            if (node.leaf)
              result.push.apply(result, node.children);
            else
              nodesToSearch.push.apply(nodesToSearch, node.children);
            node = nodesToSearch.pop();
          }
          return result;
        },
        _build: function(items, left, right, height) {
          var N2 = right - left + 1, M2 = this._maxEntries, node;
          if (N2 <= M2) {
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
          }
          if (!height) {
            height = Math.ceil(Math.log(N2) / Math.log(M2));
            M2 = Math.ceil(N2 / Math.pow(M2, height - 1));
          }
          node = createNode([]);
          node.leaf = false;
          node.height = height;
          var N22 = Math.ceil(N2 / M2), N1 = N22 * Math.ceil(Math.sqrt(M2)), i3, j2, right2, right3;
          multiSelect(items, left, right, N1, this.compareMinX);
          for (i3 = left; i3 <= right; i3 += N1) {
            right2 = Math.min(i3 + N1 - 1, right);
            multiSelect(items, i3, right2, N22, this.compareMinY);
            for (j2 = i3; j2 <= right2; j2 += N22) {
              right3 = Math.min(j2 + N22 - 1, right2);
              node.children.push(this._build(items, j2, right3, height - 1));
            }
          }
          calcBBox(node, this.toBBox);
          return node;
        },
        _chooseSubtree: function(bbox2, node, level, path) {
          var i3, len, child, targetNode, area, enlargement, minArea, minEnlargement;
          while (true) {
            path.push(node);
            if (node.leaf || path.length - 1 === level)
              break;
            minArea = minEnlargement = Infinity;
            for (i3 = 0, len = node.children.length; i3 < len; i3++) {
              child = node.children[i3];
              area = bboxArea(child);
              enlargement = enlargedArea(bbox2, child) - area;
              if (enlargement < minEnlargement) {
                minEnlargement = enlargement;
                minArea = area < minArea ? area : minArea;
                targetNode = child;
              } else if (enlargement === minEnlargement) {
                if (area < minArea) {
                  minArea = area;
                  targetNode = child;
                }
              }
            }
            node = targetNode || node.children[0];
          }
          return node;
        },
        _insert: function(item, level, isNode) {
          var toBBox = this.toBBox, bbox2 = isNode ? item : toBBox(item), insertPath = [];
          var node = this._chooseSubtree(bbox2, this.data, level, insertPath);
          node.children.push(item);
          extend2(node, bbox2);
          while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
              this._split(insertPath, level);
              level--;
            } else
              break;
          }
          this._adjustParentBBoxes(bbox2, insertPath, level);
        },
        // split overflowed node into two
        _split: function(insertPath, level) {
          var node = insertPath[level], M2 = node.children.length, m2 = this._minEntries;
          this._chooseSplitAxis(node, m2, M2);
          var splitIndex = this._chooseSplitIndex(node, m2, M2);
          var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
          newNode.height = node.height;
          newNode.leaf = node.leaf;
          calcBBox(node, this.toBBox);
          calcBBox(newNode, this.toBBox);
          if (level)
            insertPath[level - 1].children.push(newNode);
          else
            this._splitRoot(node, newNode);
        },
        _splitRoot: function(node, newNode) {
          this.data = createNode([node, newNode]);
          this.data.height = node.height + 1;
          this.data.leaf = false;
          calcBBox(this.data, this.toBBox);
        },
        _chooseSplitIndex: function(node, m2, M2) {
          var i3, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
          minOverlap = minArea = Infinity;
          for (i3 = m2; i3 <= M2 - m2; i3++) {
            bbox1 = distBBox(node, 0, i3, this.toBBox);
            bbox2 = distBBox(node, i3, M2, this.toBBox);
            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);
            if (overlap < minOverlap) {
              minOverlap = overlap;
              index = i3;
              minArea = area < minArea ? area : minArea;
            } else if (overlap === minOverlap) {
              if (area < minArea) {
                minArea = area;
                index = i3;
              }
            }
          }
          return index;
        },
        // sorts node children by the best axis for split
        _chooseSplitAxis: function(node, m2, M2) {
          var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m2, M2, compareMinX), yMargin = this._allDistMargin(node, m2, M2, compareMinY);
          if (xMargin < yMargin)
            node.children.sort(compareMinX);
        },
        // total margin of all possible split distributions where each node is at least m full
        _allDistMargin: function(node, m2, M2, compare2) {
          node.children.sort(compare2);
          var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m2, toBBox), rightBBox = distBBox(node, M2 - m2, M2, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i3, child;
          for (i3 = m2; i3 < M2 - m2; i3++) {
            child = node.children[i3];
            extend2(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
          }
          for (i3 = M2 - m2 - 1; i3 >= m2; i3--) {
            child = node.children[i3];
            extend2(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
          }
          return margin;
        },
        _adjustParentBBoxes: function(bbox2, path, level) {
          for (var i3 = level; i3 >= 0; i3--) {
            extend2(path[i3], bbox2);
          }
        },
        _condense: function(path) {
          for (var i3 = path.length - 1, siblings; i3 >= 0; i3--) {
            if (path[i3].children.length === 0) {
              if (i3 > 0) {
                siblings = path[i3 - 1].children;
                siblings.splice(siblings.indexOf(path[i3]), 1);
              } else
                this.clear();
            } else
              calcBBox(path[i3], this.toBBox);
          }
        },
        _initFormat: function(format2) {
          var compareArr = ["return a", " - b", ";"];
          this.compareMinX = new Function("a", "b", compareArr.join(format2[0]));
          this.compareMinY = new Function("a", "b", compareArr.join(format2[1]));
          this.toBBox = new Function(
            "a",
            "return {minX: a" + format2[0] + ", minY: a" + format2[1] + ", maxX: a" + format2[2] + ", maxY: a" + format2[3] + "};"
          );
        }
      };
      function findItem(item, items, equalsFn) {
        if (!equalsFn)
          return items.indexOf(item);
        for (var i3 = 0; i3 < items.length; i3++) {
          if (equalsFn(item, items[i3]))
            return i3;
        }
        return -1;
      }
      function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k2, p2, toBBox, destNode) {
        if (!destNode)
          destNode = createNode(null);
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i3 = k2, child; i3 < p2; i3++) {
          child = node.children[i3];
          extend2(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend2(a2, b2) {
        a2.minX = Math.min(a2.minX, b2.minX);
        a2.minY = Math.min(a2.minY, b2.minY);
        a2.maxX = Math.max(a2.maxX, b2.maxX);
        a2.maxY = Math.max(a2.maxY, b2.maxY);
        return a2;
      }
      function compareNodeMinX(a2, b2) {
        return a2.minX - b2.minX;
      }
      function compareNodeMinY(a2, b2) {
        return a2.minY - b2.minY;
      }
      function bboxArea(a2) {
        return (a2.maxX - a2.minX) * (a2.maxY - a2.minY);
      }
      function bboxMargin(a2) {
        return a2.maxX - a2.minX + (a2.maxY - a2.minY);
      }
      function enlargedArea(a2, b2) {
        return (Math.max(b2.maxX, a2.maxX) - Math.min(b2.minX, a2.minX)) * (Math.max(b2.maxY, a2.maxY) - Math.min(b2.minY, a2.minY));
      }
      function intersectionArea(a2, b2) {
        var minX = Math.max(a2.minX, b2.minX), minY = Math.max(a2.minY, b2.minY), maxX = Math.min(a2.maxX, b2.maxX), maxY = Math.min(a2.maxY, b2.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
      }
      function contains(a2, b2) {
        return a2.minX <= b2.minX && a2.minY <= b2.minY && b2.maxX <= a2.maxX && b2.maxY <= a2.maxY;
      }
      function intersects(a2, b2) {
        return b2.minX <= a2.maxX && b2.minY <= a2.maxY && b2.maxX >= a2.minX && b2.maxY >= a2.minY;
      }
      function createNode(children2) {
        return {
          children: children2,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr, left, right, n3, compare2) {
        var stack = [left, right], mid;
        while (stack.length) {
          right = stack.pop();
          left = stack.pop();
          if (right - left <= n3)
            continue;
          mid = left + Math.ceil((right - left) / n3 / 2) * n3;
          quickselect2(arr, mid, left, right, compare2);
          stack.push(left, mid, mid, right);
        }
      }
    }
  });

  // node_modules/lineclip/index.js
  var require_lineclip = __commonJS({
    "node_modules/lineclip/index.js"(exports2, module2) {
      "use strict";
      module2.exports = lineclip2;
      lineclip2.polyline = lineclip2;
      lineclip2.polygon = polygonclip2;
      function lineclip2(points, bbox2, result) {
        var len = points.length, codeA = bitCode2(points[0], bbox2), part = [], i3, a2, b2, codeB, lastCode;
        if (!result)
          result = [];
        for (i3 = 1; i3 < len; i3++) {
          a2 = points[i3 - 1];
          b2 = points[i3];
          codeB = lastCode = bitCode2(b2, bbox2);
          while (true) {
            if (!(codeA | codeB)) {
              part.push(a2);
              if (codeB !== lastCode) {
                part.push(b2);
                if (i3 < len - 1) {
                  result.push(part);
                  part = [];
                }
              } else if (i3 === len - 1) {
                part.push(b2);
              }
              break;
            } else if (codeA & codeB) {
              break;
            } else if (codeA) {
              a2 = intersect2(a2, b2, codeA, bbox2);
              codeA = bitCode2(a2, bbox2);
            } else {
              b2 = intersect2(a2, b2, codeB, bbox2);
              codeB = bitCode2(b2, bbox2);
            }
          }
          codeA = lastCode;
        }
        if (part.length)
          result.push(part);
        return result;
      }
      function polygonclip2(points, bbox2) {
        var result, edge, prev, prevInside, i3, p2, inside;
        for (edge = 1; edge <= 8; edge *= 2) {
          result = [];
          prev = points[points.length - 1];
          prevInside = !(bitCode2(prev, bbox2) & edge);
          for (i3 = 0; i3 < points.length; i3++) {
            p2 = points[i3];
            inside = !(bitCode2(p2, bbox2) & edge);
            if (inside !== prevInside)
              result.push(intersect2(prev, p2, edge, bbox2));
            if (inside)
              result.push(p2);
            prev = p2;
            prevInside = inside;
          }
          points = result;
          if (!points.length)
            break;
        }
        return result;
      }
      function intersect2(a2, b2, edge, bbox2) {
        return edge & 8 ? [a2[0] + (b2[0] - a2[0]) * (bbox2[3] - a2[1]) / (b2[1] - a2[1]), bbox2[3]] : (
          // top
          edge & 4 ? [a2[0] + (b2[0] - a2[0]) * (bbox2[1] - a2[1]) / (b2[1] - a2[1]), bbox2[1]] : (
            // bottom
            edge & 2 ? [bbox2[2], a2[1] + (b2[1] - a2[1]) * (bbox2[2] - a2[0]) / (b2[0] - a2[0])] : (
              // right
              edge & 1 ? [bbox2[0], a2[1] + (b2[1] - a2[1]) * (bbox2[0] - a2[0]) / (b2[0] - a2[0])] : (
                // left
                null
              )
            )
          )
        );
      }
      function bitCode2(p2, bbox2) {
        var code = 0;
        if (p2[0] < bbox2[0])
          code |= 1;
        else if (p2[0] > bbox2[2])
          code |= 2;
        if (p2[1] < bbox2[1])
          code |= 4;
        else if (p2[1] > bbox2[3])
          code |= 8;
        return code;
      }
    }
  });

  // node_modules/which-polygon/index.js
  var require_which_polygon = __commonJS({
    "node_modules/which-polygon/index.js"(exports2, module2) {
      "use strict";
      var rbush = require_rbush();
      var lineclip2 = require_lineclip();
      module2.exports = whichPolygon5;
      function whichPolygon5(data) {
        var bboxes = [];
        for (var i3 = 0; i3 < data.features.length; i3++) {
          var feature3 = data.features[i3];
          if (!feature3.geometry)
            continue;
          var coords = feature3.geometry.coordinates;
          if (feature3.geometry.type === "Polygon") {
            bboxes.push(treeItem(coords, feature3.properties));
          } else if (feature3.geometry.type === "MultiPolygon") {
            for (var j2 = 0; j2 < coords.length; j2++) {
              bboxes.push(treeItem(coords[j2], feature3.properties));
            }
          }
        }
        var tree = rbush().load(bboxes);
        function query(p2, multi) {
          var output = [], result = tree.search({
            minX: p2[0],
            minY: p2[1],
            maxX: p2[0],
            maxY: p2[1]
          });
          for (var i4 = 0; i4 < result.length; i4++) {
            if (insidePolygon(result[i4].coords, p2)) {
              if (multi)
                output.push(result[i4].props);
              else
                return result[i4].props;
            }
          }
          return multi && output.length ? output : null;
        }
        query.tree = tree;
        query.bbox = function queryBBox(bbox2) {
          var output = [];
          var result = tree.search({
            minX: bbox2[0],
            minY: bbox2[1],
            maxX: bbox2[2],
            maxY: bbox2[3]
          });
          for (var i4 = 0; i4 < result.length; i4++) {
            if (polygonIntersectsBBox(result[i4].coords, bbox2)) {
              output.push(result[i4].props);
            }
          }
          return output;
        };
        return query;
      }
      function polygonIntersectsBBox(polygon2, bbox2) {
        var bboxCenter = [
          (bbox2[0] + bbox2[2]) / 2,
          (bbox2[1] + bbox2[3]) / 2
        ];
        if (insidePolygon(polygon2, bboxCenter))
          return true;
        for (var i3 = 0; i3 < polygon2.length; i3++) {
          if (lineclip2(polygon2[i3], bbox2).length > 0)
            return true;
        }
        return false;
      }
      function insidePolygon(rings, p2) {
        var inside = false;
        for (var i3 = 0, len = rings.length; i3 < len; i3++) {
          var ring = rings[i3];
          for (var j2 = 0, len2 = ring.length, k2 = len2 - 1; j2 < len2; k2 = j2++) {
            if (rayIntersect(p2, ring[j2], ring[k2]))
              inside = !inside;
          }
        }
        return inside;
      }
      function rayIntersect(p2, p1, p22) {
        return p1[1] > p2[1] !== p22[1] > p2[1] && p2[0] < (p22[0] - p1[0]) * (p2[1] - p1[1]) / (p22[1] - p1[1]) + p1[0];
      }
      function treeItem(coords, props) {
        var item = {
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity,
          coords,
          props
        };
        for (var i3 = 0; i3 < coords[0].length; i3++) {
          var p2 = coords[0][i3];
          item.minX = Math.min(item.minX, p2[0]);
          item.minY = Math.min(item.minY, p2[1]);
          item.maxX = Math.max(item.maxX, p2[0]);
          item.maxY = Math.max(item.maxY, p2[1]);
        }
        return item;
      }
    }
  });

  // node_modules/wgs84/index.js
  var require_wgs84 = __commonJS({
    "node_modules/wgs84/index.js"(exports2, module2) {
      module2.exports.RADIUS = 6378137;
      module2.exports.FLATTENING = 1 / 298.257223563;
      module2.exports.POLAR_RADIUS = 63567523142e-4;
    }
  });

  // node_modules/@mapbox/geojson-area/index.js
  var require_geojson_area = __commonJS({
    "node_modules/@mapbox/geojson-area/index.js"(exports2, module2) {
      var wgs84 = require_wgs84();
      module2.exports.geometry = geometry;
      module2.exports.ring = ringArea;
      function geometry(_2) {
        var area = 0, i3;
        switch (_2.type) {
          case "Polygon":
            return polygonArea(_2.coordinates);
          case "MultiPolygon":
            for (i3 = 0; i3 < _2.coordinates.length; i3++) {
              area += polygonArea(_2.coordinates[i3]);
            }
            return area;
          case "Point":
          case "MultiPoint":
          case "LineString":
          case "MultiLineString":
            return 0;
          case "GeometryCollection":
            for (i3 = 0; i3 < _2.geometries.length; i3++) {
              area += geometry(_2.geometries[i3]);
            }
            return area;
        }
      }
      function polygonArea(coords) {
        var area = 0;
        if (coords && coords.length > 0) {
          area += Math.abs(ringArea(coords[0]));
          for (var i3 = 1; i3 < coords.length; i3++) {
            area -= Math.abs(ringArea(coords[i3]));
          }
        }
        return area;
      }
      function ringArea(coords) {
        var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i3, area = 0, coordsLength = coords.length;
        if (coordsLength > 2) {
          for (i3 = 0; i3 < coordsLength; i3++) {
            if (i3 === coordsLength - 2) {
              lowerIndex = coordsLength - 2;
              middleIndex = coordsLength - 1;
              upperIndex = 0;
            } else if (i3 === coordsLength - 1) {
              lowerIndex = coordsLength - 1;
              middleIndex = 0;
              upperIndex = 1;
            } else {
              lowerIndex = i3;
              middleIndex = i3 + 1;
              upperIndex = i3 + 2;
            }
            p1 = coords[lowerIndex];
            p2 = coords[middleIndex];
            p3 = coords[upperIndex];
            area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
          }
          area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
        }
        return area;
      }
      function rad(_2) {
        return _2 * Math.PI / 180;
      }
    }
  });

  // node_modules/circle-to-polygon/input-validation/validateCenter.js
  var require_validateCenter = __commonJS({
    "node_modules/circle-to-polygon/input-validation/validateCenter.js"(exports2) {
      exports2.validateCenter = function validateCenter(center) {
        var validCenterLengths = [2, 3];
        if (!Array.isArray(center) || !validCenterLengths.includes(center.length)) {
          throw new Error("ERROR! Center has to be an array of length two or three");
        }
        var [lng, lat] = center;
        if (typeof lng !== "number" || typeof lat !== "number") {
          throw new Error(
            "ERROR! Longitude and Latitude has to be numbers but where ".concat(typeof lng, " and ").concat(typeof lat)
          );
        }
        if (lng > 180 || lng < -180) {
          throw new Error("ERROR! Longitude has to be between -180 and 180 but was ".concat(lng));
        }
        if (lat > 90 || lat < -90) {
          throw new Error("ERROR! Latitude has to be between -90 and 90 but was ".concat(lat));
        }
      };
    }
  });

  // node_modules/circle-to-polygon/input-validation/validateRadius.js
  var require_validateRadius = __commonJS({
    "node_modules/circle-to-polygon/input-validation/validateRadius.js"(exports2) {
      exports2.validateRadius = function validateRadius(radius) {
        if (typeof radius !== "number") {
          throw new Error("ERROR! Radius has to be a positive number but was: ".concat(typeof radius));
        }
        if (radius <= 0) {
          throw new Error("ERROR! Radius has to be a positive number but was: ".concat(radius));
        }
      };
    }
  });

  // node_modules/circle-to-polygon/input-validation/validateNumberOfEdges.js
  var require_validateNumberOfEdges = __commonJS({
    "node_modules/circle-to-polygon/input-validation/validateNumberOfEdges.js"(exports2) {
      exports2.validateNumberOfEdges = function validateNumberOfEdges(numberOfEdges) {
        if (typeof numberOfEdges !== "number") {
          const ARGUMENT_TYPE = Array.isArray(numberOfEdges) ? "array" : typeof numberOfEdges;
          throw new Error("ERROR! Number of edges has to be a number but was: ".concat(ARGUMENT_TYPE));
        }
        if (numberOfEdges < 3) {
          throw new Error("ERROR! Number of edges has to be at least 3 but was: ".concat(numberOfEdges));
        }
      };
    }
  });

  // node_modules/circle-to-polygon/input-validation/validateEarthRadius.js
  var require_validateEarthRadius = __commonJS({
    "node_modules/circle-to-polygon/input-validation/validateEarthRadius.js"(exports2) {
      exports2.validateEarthRadius = function validateEarthRadius(earthRadius2) {
        if (typeof earthRadius2 !== "number") {
          const ARGUMENT_TYPE = Array.isArray(earthRadius2) ? "array" : typeof earthRadius2;
          throw new Error("ERROR! Earth radius has to be a number but was: ".concat(ARGUMENT_TYPE));
        }
        if (earthRadius2 <= 0) {
          throw new Error("ERROR! Earth radius has to be a positive number but was: ".concat(earthRadius2));
        }
      };
    }
  });

  // node_modules/circle-to-polygon/input-validation/validateBearing.js
  var require_validateBearing = __commonJS({
    "node_modules/circle-to-polygon/input-validation/validateBearing.js"(exports2) {
      exports2.validateBearing = function validateBearing(bearing) {
        if (typeof bearing !== "number") {
          const ARGUMENT_TYPE = Array.isArray(bearing) ? "array" : typeof bearing;
          throw new Error("ERROR! Bearing has to be a number but was: ".concat(ARGUMENT_TYPE));
        }
      };
    }
  });

  // node_modules/circle-to-polygon/input-validation/index.js
  var require_input_validation = __commonJS({
    "node_modules/circle-to-polygon/input-validation/index.js"(exports2) {
      var validateCenter = require_validateCenter().validateCenter;
      var validateRadius = require_validateRadius().validateRadius;
      var validateNumberOfEdges = require_validateNumberOfEdges().validateNumberOfEdges;
      var validateEarthRadius = require_validateEarthRadius().validateEarthRadius;
      var validateBearing = require_validateBearing().validateBearing;
      function validateInput({ center, radius, numberOfEdges, earthRadius: earthRadius2, bearing }) {
        validateCenter(center);
        validateRadius(radius);
        validateNumberOfEdges(numberOfEdges);
        validateEarthRadius(earthRadius2);
        validateBearing(bearing);
      }
      exports2.validateCenter = validateCenter;
      exports2.validateRadius = validateRadius;
      exports2.validateNumberOfEdges = validateNumberOfEdges;
      exports2.validateEarthRadius = validateEarthRadius;
      exports2.validateBearing = validateBearing;
      exports2.validateInput = validateInput;
    }
  });

  // node_modules/circle-to-polygon/index.js
  var require_circle_to_polygon = __commonJS({
    "node_modules/circle-to-polygon/index.js"(exports2, module2) {
      "use strict";
      var { validateInput } = require_input_validation();
      var defaultEarthRadius = 6378137;
      function toRadians(angleInDegrees) {
        return angleInDegrees * Math.PI / 180;
      }
      function toDegrees(angleInRadians) {
        return angleInRadians * 180 / Math.PI;
      }
      function offset(c1, distance, earthRadius2, bearing) {
        var lat1 = toRadians(c1[1]);
        var lon1 = toRadians(c1[0]);
        var dByR = distance / earthRadius2;
        var lat = Math.asin(
          Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)
        );
        var lon = lon1 + Math.atan2(
          Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),
          Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)
        );
        return [toDegrees(lon), toDegrees(lat)];
      }
      module2.exports = function circleToPolygon2(center, radius, options2) {
        var n3 = getNumberOfEdges(options2);
        var earthRadius2 = getEarthRadius(options2);
        var bearing = getBearing(options2);
        var direction = getDirection(options2);
        validateInput({ center, radius, numberOfEdges: n3, earthRadius: earthRadius2, bearing });
        var start2 = toRadians(bearing);
        var coordinates = [];
        for (var i3 = 0; i3 < n3; ++i3) {
          coordinates.push(
            offset(
              center,
              radius,
              earthRadius2,
              start2 + direction * 2 * Math.PI * -i3 / n3
            )
          );
        }
        coordinates.push(coordinates[0]);
        return {
          type: "Polygon",
          coordinates: [coordinates]
        };
      };
      function getNumberOfEdges(options2) {
        if (isUndefinedOrNull(options2)) {
          return 32;
        } else if (isObjectNotArray(options2)) {
          var numberOfEdges = options2.numberOfEdges;
          return numberOfEdges === void 0 ? 32 : numberOfEdges;
        }
        return options2;
      }
      function getEarthRadius(options2) {
        if (isUndefinedOrNull(options2)) {
          return defaultEarthRadius;
        } else if (isObjectNotArray(options2)) {
          var earthRadius2 = options2.earthRadius;
          return earthRadius2 === void 0 ? defaultEarthRadius : earthRadius2;
        }
        return defaultEarthRadius;
      }
      function getDirection(options2) {
        if (isObjectNotArray(options2) && options2.rightHandRule) {
          return -1;
        }
        return 1;
      }
      function getBearing(options2) {
        if (isUndefinedOrNull(options2)) {
          return 0;
        } else if (isObjectNotArray(options2)) {
          var bearing = options2.bearing;
          return bearing === void 0 ? 0 : bearing;
        }
        return 0;
      }
      function isObjectNotArray(argument) {
        return argument !== null && typeof argument === "object" && !Array.isArray(argument);
      }
      function isUndefinedOrNull(argument) {
        return argument === null || argument === void 0;
      }
    }
  });

  // node_modules/geojson-precision/index.js
  var require_geojson_precision = __commonJS({
    "node_modules/geojson-precision/index.js"(exports2, module2) {
      (function() {
        function parse(t2, coordinatePrecision, extrasPrecision) {
          function point2(p2) {
            return p2.map(function(e3, index) {
              if (index < 2) {
                return 1 * e3.toFixed(coordinatePrecision);
              } else {
                return 1 * e3.toFixed(extrasPrecision);
              }
            });
          }
          function multi(l2) {
            return l2.map(point2);
          }
          function poly(p2) {
            return p2.map(multi);
          }
          function multiPoly(m2) {
            return m2.map(poly);
          }
          function geometry(obj) {
            if (!obj) {
              return {};
            }
            switch (obj.type) {
              case "Point":
                obj.coordinates = point2(obj.coordinates);
                return obj;
              case "LineString":
              case "MultiPoint":
                obj.coordinates = multi(obj.coordinates);
                return obj;
              case "Polygon":
              case "MultiLineString":
                obj.coordinates = poly(obj.coordinates);
                return obj;
              case "MultiPolygon":
                obj.coordinates = multiPoly(obj.coordinates);
                return obj;
              case "GeometryCollection":
                obj.geometries = obj.geometries.map(geometry);
                return obj;
              default:
                return {};
            }
          }
          function feature3(obj) {
            obj.geometry = geometry(obj.geometry);
            return obj;
          }
          function featureCollection(f2) {
            f2.features = f2.features.map(feature3);
            return f2;
          }
          function geometryCollection(g3) {
            g3.geometries = g3.geometries.map(geometry);
            return g3;
          }
          if (!t2) {
            return t2;
          }
          switch (t2.type) {
            case "Feature":
              return feature3(t2);
            case "GeometryCollection":
              return geometryCollection(t2);
            case "FeatureCollection":
              return featureCollection(t2);
            case "Point":
            case "LineString":
            case "Polygon":
            case "MultiPoint":
            case "MultiPolygon":
            case "MultiLineString":
              return geometry(t2);
            default:
              return t2;
          }
        }
        module2.exports = parse;
        module2.exports.parse = parse;
      })();
    }
  });

  // node_modules/@aitodotai/json-stringify-pretty-compact/index.js
  var require_json_stringify_pretty_compact = __commonJS({
    "node_modules/@aitodotai/json-stringify-pretty-compact/index.js"(exports2, module2) {
      function isObject3(obj) {
        return typeof obj === "object" && obj !== null;
      }
      function forEach(obj, cb) {
        if (Array.isArray(obj)) {
          obj.forEach(cb);
        } else if (isObject3(obj)) {
          Object.keys(obj).forEach(function(key) {
            var val = obj[key];
            cb(val, key);
          });
        }
      }
      function getTreeDepth(obj) {
        var depth = 0;
        if (Array.isArray(obj) || isObject3(obj)) {
          forEach(obj, function(val) {
            if (Array.isArray(val) || isObject3(val)) {
              var tmpDepth = getTreeDepth(val);
              if (tmpDepth > depth) {
                depth = tmpDepth;
              }
            }
          });
          return depth + 1;
        }
        return depth;
      }
      function stringify3(obj, options2) {
        options2 = options2 || {};
        var indent = JSON.stringify([1], null, get4(options2, "indent", 2)).slice(2, -3);
        var addMargin = get4(options2, "margins", false);
        var addArrayMargin = get4(options2, "arrayMargins", false);
        var addObjectMargin = get4(options2, "objectMargins", false);
        var maxLength = indent === "" ? Infinity : get4(options2, "maxLength", 80);
        var maxNesting = get4(options2, "maxNesting", Infinity);
        return function _stringify(obj2, currentIndent, reserved) {
          if (obj2 && typeof obj2.toJSON === "function") {
            obj2 = obj2.toJSON();
          }
          var string = JSON.stringify(obj2);
          if (string === void 0) {
            return string;
          }
          var length2 = maxLength - currentIndent.length - reserved;
          var treeDepth = getTreeDepth(obj2);
          if (treeDepth <= maxNesting && string.length <= length2) {
            var prettified = prettify(string, {
              addMargin,
              addArrayMargin,
              addObjectMargin
            });
            if (prettified.length <= length2) {
              return prettified;
            }
          }
          if (isObject3(obj2)) {
            var nextIndent = currentIndent + indent;
            var items = [];
            var delimiters;
            var comma = function(array2, index2) {
              return index2 === array2.length - 1 ? 0 : 1;
            };
            if (Array.isArray(obj2)) {
              for (var index = 0; index < obj2.length; index++) {
                items.push(
                  _stringify(obj2[index], nextIndent, comma(obj2, index)) || "null"
                );
              }
              delimiters = "[]";
            } else {
              Object.keys(obj2).forEach(function(key, index2, array2) {
                var keyPart = JSON.stringify(key) + ": ";
                var value = _stringify(
                  obj2[key],
                  nextIndent,
                  keyPart.length + comma(array2, index2)
                );
                if (value !== void 0) {
                  items.push(keyPart + value);
                }
              });
              delimiters = "{}";
            }
            if (items.length > 0) {
              return [
                delimiters[0],
                indent + items.join(",\n" + nextIndent),
                delimiters[1]
              ].join("\n" + currentIndent);
            }
          }
          return string;
        }(obj, "", 0);
      }
      var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,\][}{]/g;
      function prettify(string, options2) {
        options2 = options2 || {};
        var tokens = {
          "{": "{",
          "}": "}",
          "[": "[",
          "]": "]",
          ",": ", ",
          ":": ": "
        };
        if (options2.addMargin || options2.addObjectMargin) {
          tokens["{"] = "{ ";
          tokens["}"] = " }";
        }
        if (options2.addMargin || options2.addArrayMargin) {
          tokens["["] = "[ ";
          tokens["]"] = " ]";
        }
        return string.replace(stringOrChar, function(match, string2) {
          return string2 ? match : tokens[match];
        });
      }
      function get4(options2, name, defaultValue) {
        return name in options2 ? options2[name] : defaultValue;
      }
      module2.exports = stringify3;
    }
  });

  // node_modules/aes-js/index.js
  var require_aes_js = __commonJS({
    "node_modules/aes-js/index.js"(exports2, module2) {
      (function(root3) {
        "use strict";
        function checkInt(value) {
          return parseInt(value) === value;
        }
        function checkInts(arrayish) {
          if (!checkInt(arrayish.length)) {
            return false;
          }
          for (var i3 = 0; i3 < arrayish.length; i3++) {
            if (!checkInt(arrayish[i3]) || arrayish[i3] < 0 || arrayish[i3] > 255) {
              return false;
            }
          }
          return true;
        }
        function coerceArray(arg, copy2) {
          if (arg.buffer && arg.name === "Uint8Array") {
            if (copy2) {
              if (arg.slice) {
                arg = arg.slice();
              } else {
                arg = Array.prototype.slice.call(arg);
              }
            }
            return arg;
          }
          if (Array.isArray(arg)) {
            if (!checkInts(arg)) {
              throw new Error("Array contains invalid value: " + arg);
            }
            return new Uint8Array(arg);
          }
          if (checkInt(arg.length) && checkInts(arg)) {
            return new Uint8Array(arg);
          }
          throw new Error("unsupported array-like object");
        }
        function createArray(length2) {
          return new Uint8Array(length2);
        }
        function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
          if (sourceStart != null || sourceEnd != null) {
            if (sourceArray.slice) {
              sourceArray = sourceArray.slice(sourceStart, sourceEnd);
            } else {
              sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
            }
          }
          targetArray.set(sourceArray, targetStart);
        }
        var convertUtf8 = /* @__PURE__ */ function() {
          function toBytes(text) {
            var result = [], i3 = 0;
            text = encodeURI(text);
            while (i3 < text.length) {
              var c2 = text.charCodeAt(i3++);
              if (c2 === 37) {
                result.push(parseInt(text.substr(i3, 2), 16));
                i3 += 2;
              } else {
                result.push(c2);
              }
            }
            return coerceArray(result);
          }
          function fromBytes(bytes) {
            var result = [], i3 = 0;
            while (i3 < bytes.length) {
              var c2 = bytes[i3];
              if (c2 < 128) {
                result.push(String.fromCharCode(c2));
                i3++;
              } else if (c2 > 191 && c2 < 224) {
                result.push(String.fromCharCode((c2 & 31) << 6 | bytes[i3 + 1] & 63));
                i3 += 2;
              } else {
                result.push(String.fromCharCode((c2 & 15) << 12 | (bytes[i3 + 1] & 63) << 6 | bytes[i3 + 2] & 63));
                i3 += 3;
              }
            }
            return result.join("");
          }
          return {
            toBytes,
            fromBytes
          };
        }();
        var convertHex = /* @__PURE__ */ function() {
          function toBytes(text) {
            var result = [];
            for (var i3 = 0; i3 < text.length; i3 += 2) {
              result.push(parseInt(text.substr(i3, 2), 16));
            }
            return result;
          }
          var Hex = "0123456789abcdef";
          function fromBytes(bytes) {
            var result = [];
            for (var i3 = 0; i3 < bytes.length; i3++) {
              var v2 = bytes[i3];
              result.push(Hex[(v2 & 240) >> 4] + Hex[v2 & 15]);
            }
            return result.join("");
          }
          return {
            toBytes,
            fromBytes
          };
        }();
        var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
        var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
        var S2 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
        var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
        var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
        var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
        var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
        var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
        var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
        var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
        var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
        var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
        var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
        var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
        var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
        var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
        function convertToInt32(bytes) {
          var result = [];
          for (var i3 = 0; i3 < bytes.length; i3 += 4) {
            result.push(
              bytes[i3] << 24 | bytes[i3 + 1] << 16 | bytes[i3 + 2] << 8 | bytes[i3 + 3]
            );
          }
          return result;
        }
        var AES = function(key) {
          if (!(this instanceof AES)) {
            throw Error("AES must be instanitated with `new`");
          }
          Object.defineProperty(this, "key", {
            value: coerceArray(key, true)
          });
          this._prepare();
        };
        AES.prototype._prepare = function() {
          var rounds = numberOfRounds[this.key.length];
          if (rounds == null) {
            throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
          }
          this._Ke = [];
          this._Kd = [];
          for (var i3 = 0; i3 <= rounds; i3++) {
            this._Ke.push([0, 0, 0, 0]);
            this._Kd.push([0, 0, 0, 0]);
          }
          var roundKeyCount = (rounds + 1) * 4;
          var KC = this.key.length / 4;
          var tk = convertToInt32(this.key);
          var index;
          for (var i3 = 0; i3 < KC; i3++) {
            index = i3 >> 2;
            this._Ke[index][i3 % 4] = tk[i3];
            this._Kd[rounds - index][i3 % 4] = tk[i3];
          }
          var rconpointer = 0;
          var t2 = KC, tt2;
          while (t2 < roundKeyCount) {
            tt2 = tk[KC - 1];
            tk[0] ^= S2[tt2 >> 16 & 255] << 24 ^ S2[tt2 >> 8 & 255] << 16 ^ S2[tt2 & 255] << 8 ^ S2[tt2 >> 24 & 255] ^ rcon[rconpointer] << 24;
            rconpointer += 1;
            if (KC != 8) {
              for (var i3 = 1; i3 < KC; i3++) {
                tk[i3] ^= tk[i3 - 1];
              }
            } else {
              for (var i3 = 1; i3 < KC / 2; i3++) {
                tk[i3] ^= tk[i3 - 1];
              }
              tt2 = tk[KC / 2 - 1];
              tk[KC / 2] ^= S2[tt2 & 255] ^ S2[tt2 >> 8 & 255] << 8 ^ S2[tt2 >> 16 & 255] << 16 ^ S2[tt2 >> 24 & 255] << 24;
              for (var i3 = KC / 2 + 1; i3 < KC; i3++) {
                tk[i3] ^= tk[i3 - 1];
              }
            }
            var i3 = 0, r2, c2;
            while (i3 < KC && t2 < roundKeyCount) {
              r2 = t2 >> 2;
              c2 = t2 % 4;
              this._Ke[r2][c2] = tk[i3];
              this._Kd[rounds - r2][c2] = tk[i3++];
              t2++;
            }
          }
          for (var r2 = 1; r2 < rounds; r2++) {
            for (var c2 = 0; c2 < 4; c2++) {
              tt2 = this._Kd[r2][c2];
              this._Kd[r2][c2] = U1[tt2 >> 24 & 255] ^ U2[tt2 >> 16 & 255] ^ U3[tt2 >> 8 & 255] ^ U4[tt2 & 255];
            }
          }
        };
        AES.prototype.encrypt = function(plaintext) {
          if (plaintext.length != 16) {
            throw new Error("invalid plaintext size (must be 16 bytes)");
          }
          var rounds = this._Ke.length - 1;
          var a2 = [0, 0, 0, 0];
          var t2 = convertToInt32(plaintext);
          for (var i3 = 0; i3 < 4; i3++) {
            t2[i3] ^= this._Ke[0][i3];
          }
          for (var r2 = 1; r2 < rounds; r2++) {
            for (var i3 = 0; i3 < 4; i3++) {
              a2[i3] = T1[t2[i3] >> 24 & 255] ^ T2[t2[(i3 + 1) % 4] >> 16 & 255] ^ T3[t2[(i3 + 2) % 4] >> 8 & 255] ^ T4[t2[(i3 + 3) % 4] & 255] ^ this._Ke[r2][i3];
            }
            t2 = a2.slice();
          }
          var result = createArray(16), tt2;
          for (var i3 = 0; i3 < 4; i3++) {
            tt2 = this._Ke[rounds][i3];
            result[4 * i3] = (S2[t2[i3] >> 24 & 255] ^ tt2 >> 24) & 255;
            result[4 * i3 + 1] = (S2[t2[(i3 + 1) % 4] >> 16 & 255] ^ tt2 >> 16) & 255;
            result[4 * i3 + 2] = (S2[t2[(i3 + 2) % 4] >> 8 & 255] ^ tt2 >> 8) & 255;
            result[4 * i3 + 3] = (S2[t2[(i3 + 3) % 4] & 255] ^ tt2) & 255;
          }
          return result;
        };
        AES.prototype.decrypt = function(ciphertext) {
          if (ciphertext.length != 16) {
            throw new Error("invalid ciphertext size (must be 16 bytes)");
          }
          var rounds = this._Kd.length - 1;
          var a2 = [0, 0, 0, 0];
          var t2 = convertToInt32(ciphertext);
          for (var i3 = 0; i3 < 4; i3++) {
            t2[i3] ^= this._Kd[0][i3];
          }
          for (var r2 = 1; r2 < rounds; r2++) {
            for (var i3 = 0; i3 < 4; i3++) {
              a2[i3] = T5[t2[i3] >> 24 & 255] ^ T6[t2[(i3 + 3) % 4] >> 16 & 255] ^ T7[t2[(i3 + 2) % 4] >> 8 & 255] ^ T8[t2[(i3 + 1) % 4] & 255] ^ this._Kd[r2][i3];
            }
            t2 = a2.slice();
          }
          var result = createArray(16), tt2;
          for (var i3 = 0; i3 < 4; i3++) {
            tt2 = this._Kd[rounds][i3];
            result[4 * i3] = (Si[t2[i3] >> 24 & 255] ^ tt2 >> 24) & 255;
            result[4 * i3 + 1] = (Si[t2[(i3 + 3) % 4] >> 16 & 255] ^ tt2 >> 16) & 255;
            result[4 * i3 + 2] = (Si[t2[(i3 + 2) % 4] >> 8 & 255] ^ tt2 >> 8) & 255;
            result[4 * i3 + 3] = (Si[t2[(i3 + 1) % 4] & 255] ^ tt2) & 255;
          }
          return result;
        };
        var ModeOfOperationECB = function(key) {
          if (!(this instanceof ModeOfOperationECB)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Electronic Code Block";
          this.name = "ecb";
          this._aes = new AES(key);
        };
        ModeOfOperationECB.prototype.encrypt = function(plaintext) {
          plaintext = coerceArray(plaintext);
          if (plaintext.length % 16 !== 0) {
            throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
          }
          var ciphertext = createArray(plaintext.length);
          var block2 = createArray(16);
          for (var i3 = 0; i3 < plaintext.length; i3 += 16) {
            copyArray(plaintext, block2, 0, i3, i3 + 16);
            block2 = this._aes.encrypt(block2);
            copyArray(block2, ciphertext, i3);
          }
          return ciphertext;
        };
        ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
          ciphertext = coerceArray(ciphertext);
          if (ciphertext.length % 16 !== 0) {
            throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
          }
          var plaintext = createArray(ciphertext.length);
          var block2 = createArray(16);
          for (var i3 = 0; i3 < ciphertext.length; i3 += 16) {
            copyArray(ciphertext, block2, 0, i3, i3 + 16);
            block2 = this._aes.decrypt(block2);
            copyArray(block2, plaintext, i3);
          }
          return plaintext;
        };
        var ModeOfOperationCBC = function(key, iv) {
          if (!(this instanceof ModeOfOperationCBC)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Cipher Block Chaining";
          this.name = "cbc";
          if (!iv) {
            iv = createArray(16);
          } else if (iv.length != 16) {
            throw new Error("invalid initialation vector size (must be 16 bytes)");
          }
          this._lastCipherblock = coerceArray(iv, true);
          this._aes = new AES(key);
        };
        ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
          plaintext = coerceArray(plaintext);
          if (plaintext.length % 16 !== 0) {
            throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
          }
          var ciphertext = createArray(plaintext.length);
          var block2 = createArray(16);
          for (var i3 = 0; i3 < plaintext.length; i3 += 16) {
            copyArray(plaintext, block2, 0, i3, i3 + 16);
            for (var j2 = 0; j2 < 16; j2++) {
              block2[j2] ^= this._lastCipherblock[j2];
            }
            this._lastCipherblock = this._aes.encrypt(block2);
            copyArray(this._lastCipherblock, ciphertext, i3);
          }
          return ciphertext;
        };
        ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
          ciphertext = coerceArray(ciphertext);
          if (ciphertext.length % 16 !== 0) {
            throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
          }
          var plaintext = createArray(ciphertext.length);
          var block2 = createArray(16);
          for (var i3 = 0; i3 < ciphertext.length; i3 += 16) {
            copyArray(ciphertext, block2, 0, i3, i3 + 16);
            block2 = this._aes.decrypt(block2);
            for (var j2 = 0; j2 < 16; j2++) {
              plaintext[i3 + j2] = block2[j2] ^ this._lastCipherblock[j2];
            }
            copyArray(ciphertext, this._lastCipherblock, 0, i3, i3 + 16);
          }
          return plaintext;
        };
        var ModeOfOperationCFB = function(key, iv, segmentSize) {
          if (!(this instanceof ModeOfOperationCFB)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Cipher Feedback";
          this.name = "cfb";
          if (!iv) {
            iv = createArray(16);
          } else if (iv.length != 16) {
            throw new Error("invalid initialation vector size (must be 16 size)");
          }
          if (!segmentSize) {
            segmentSize = 1;
          }
          this.segmentSize = segmentSize;
          this._shiftRegister = coerceArray(iv, true);
          this._aes = new AES(key);
        };
        ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
          if (plaintext.length % this.segmentSize != 0) {
            throw new Error("invalid plaintext size (must be segmentSize bytes)");
          }
          var encrypted = coerceArray(plaintext, true);
          var xorSegment;
          for (var i3 = 0; i3 < encrypted.length; i3 += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for (var j2 = 0; j2 < this.segmentSize; j2++) {
              encrypted[i3 + j2] ^= xorSegment[j2];
            }
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i3, i3 + this.segmentSize);
          }
          return encrypted;
        };
        ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
          if (ciphertext.length % this.segmentSize != 0) {
            throw new Error("invalid ciphertext size (must be segmentSize bytes)");
          }
          var plaintext = coerceArray(ciphertext, true);
          var xorSegment;
          for (var i3 = 0; i3 < plaintext.length; i3 += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for (var j2 = 0; j2 < this.segmentSize; j2++) {
              plaintext[i3 + j2] ^= xorSegment[j2];
            }
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i3, i3 + this.segmentSize);
          }
          return plaintext;
        };
        var ModeOfOperationOFB = function(key, iv) {
          if (!(this instanceof ModeOfOperationOFB)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Output Feedback";
          this.name = "ofb";
          if (!iv) {
            iv = createArray(16);
          } else if (iv.length != 16) {
            throw new Error("invalid initialation vector size (must be 16 bytes)");
          }
          this._lastPrecipher = coerceArray(iv, true);
          this._lastPrecipherIndex = 16;
          this._aes = new AES(key);
        };
        ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
          var encrypted = coerceArray(plaintext, true);
          for (var i3 = 0; i3 < encrypted.length; i3++) {
            if (this._lastPrecipherIndex === 16) {
              this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
              this._lastPrecipherIndex = 0;
            }
            encrypted[i3] ^= this._lastPrecipher[this._lastPrecipherIndex++];
          }
          return encrypted;
        };
        ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
        var Counter = function(initialValue) {
          if (!(this instanceof Counter)) {
            throw Error("Counter must be instanitated with `new`");
          }
          if (initialValue !== 0 && !initialValue) {
            initialValue = 1;
          }
          if (typeof initialValue === "number") {
            this._counter = createArray(16);
            this.setValue(initialValue);
          } else {
            this.setBytes(initialValue);
          }
        };
        Counter.prototype.setValue = function(value) {
          if (typeof value !== "number" || parseInt(value) != value) {
            throw new Error("invalid counter value (must be an integer)");
          }
          if (value > Number.MAX_SAFE_INTEGER) {
            throw new Error("integer value out of safe range");
          }
          for (var index = 15; index >= 0; --index) {
            this._counter[index] = value % 256;
            value = parseInt(value / 256);
          }
        };
        Counter.prototype.setBytes = function(bytes) {
          bytes = coerceArray(bytes, true);
          if (bytes.length != 16) {
            throw new Error("invalid counter bytes size (must be 16 bytes)");
          }
          this._counter = bytes;
        };
        Counter.prototype.increment = function() {
          for (var i3 = 15; i3 >= 0; i3--) {
            if (this._counter[i3] === 255) {
              this._counter[i3] = 0;
            } else {
              this._counter[i3]++;
              break;
            }
          }
        };
        var ModeOfOperationCTR = function(key, counter) {
          if (!(this instanceof ModeOfOperationCTR)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Counter";
          this.name = "ctr";
          if (!(counter instanceof Counter)) {
            counter = new Counter(counter);
          }
          this._counter = counter;
          this._remainingCounter = null;
          this._remainingCounterIndex = 16;
          this._aes = new AES(key);
        };
        ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
          var encrypted = coerceArray(plaintext, true);
          for (var i3 = 0; i3 < encrypted.length; i3++) {
            if (this._remainingCounterIndex === 16) {
              this._remainingCounter = this._aes.encrypt(this._counter._counter);
              this._remainingCounterIndex = 0;
              this._counter.increment();
            }
            encrypted[i3] ^= this._remainingCounter[this._remainingCounterIndex++];
          }
          return encrypted;
        };
        ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
        function pkcs7pad(data) {
          data = coerceArray(data, true);
          var padder = 16 - data.length % 16;
          var result = createArray(data.length + padder);
          copyArray(data, result);
          for (var i3 = data.length; i3 < result.length; i3++) {
            result[i3] = padder;
          }
          return result;
        }
        function pkcs7strip(data) {
          data = coerceArray(data, true);
          if (data.length < 16) {
            throw new Error("PKCS#7 invalid length");
          }
          var padder = data[data.length - 1];
          if (padder > 16) {
            throw new Error("PKCS#7 padding byte out of range");
          }
          var length2 = data.length - padder;
          for (var i3 = 0; i3 < padder; i3++) {
            if (data[length2 + i3] !== padder) {
              throw new Error("PKCS#7 invalid padding byte");
            }
          }
          var result = createArray(length2);
          copyArray(data, result, 0, 0, length2);
          return result;
        }
        var aesjs2 = {
          AES,
          Counter,
          ModeOfOperation: {
            ecb: ModeOfOperationECB,
            cbc: ModeOfOperationCBC,
            cfb: ModeOfOperationCFB,
            ofb: ModeOfOperationOFB,
            ctr: ModeOfOperationCTR
          },
          utils: {
            hex: convertHex,
            utf8: convertUtf8
          },
          padding: {
            pkcs7: {
              pad: pkcs7pad,
              strip: pkcs7strip
            }
          },
          _arrayTest: {
            coerceArray,
            createArray,
            copyArray
          }
        };
        if (typeof exports2 !== "undefined") {
          module2.exports = aesjs2;
        } else if (typeof define === "function" && define.amd) {
          define([], function() {
            return aesjs2;
          });
        } else {
          if (root3.aesjs) {
            aesjs2._aesjs = root3.aesjs;
          }
          root3.aesjs = aesjs2;
        }
      })(exports2);
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports2, module2) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE2 = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT3 = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED4 = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG5 = 1, COMPARE_UNORDERED_FLAG3 = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER4 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN2 = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag4 = "[object Arguments]", arrayTag3 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag3 = "[object Boolean]", dateTag3 = "[object Date]", domExcTag = "[object DOMException]", errorTag3 = "[object Error]", funcTag3 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag4 = "[object Map]", numberTag4 = "[object Number]", nullTag2 = "[object Null]", objectTag4 = "[object Object]", promiseTag2 = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag3 = "[object RegExp]", setTag4 = "[object Set]", stringTag3 = "[object String]", symbolTag3 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag3 = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag3 = "[object ArrayBuffer]", dataViewTag4 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml2 = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml2 = /[&<>"']/g, reHasEscapedHtml2 = RegExp(reEscapedHtml2.source), reHasUnescapedHtml2 = RegExp(reUnescapedHtml2.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar2.source);
        var reTrimStart2 = /^\s+/;
        var reWhitespace2 = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex2 = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary2 = /^0b[01]+$/i;
        var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
        var reIsOctal2 = /^0o[0-7]+$/i;
        var reIsUint2 = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags2 = {};
        typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
        typedArrayTags2[argsTag4] = typedArrayTags2[arrayTag3] = typedArrayTags2[arrayBufferTag3] = typedArrayTags2[boolTag3] = typedArrayTags2[dataViewTag4] = typedArrayTags2[dateTag3] = typedArrayTags2[errorTag3] = typedArrayTags2[funcTag3] = typedArrayTags2[mapTag4] = typedArrayTags2[numberTag4] = typedArrayTags2[objectTag4] = typedArrayTags2[regexpTag3] = typedArrayTags2[setTag4] = typedArrayTags2[stringTag3] = typedArrayTags2[weakMapTag3] = false;
        var cloneableTags = {};
        cloneableTags[argsTag4] = cloneableTags[arrayTag3] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag2] = cloneableTags[float64Tag2] = cloneableTags[int8Tag2] = cloneableTags[int16Tag2] = cloneableTags[int32Tag2] = cloneableTags[mapTag4] = cloneableTags[numberTag4] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag4] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag2] = cloneableTags[uint8ClampedTag2] = cloneableTags[uint16Tag2] = cloneableTags[uint32Tag2] = true;
        cloneableTags[errorTag3] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes2 = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes2 = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt2 = parseInt;
        var freeGlobal2 = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
        var root3 = freeGlobal2 || freeSelf2 || Function("return this")();
        var freeExports3 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
        var freeModule3 = freeExports3 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
        var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
        var freeProcess2 = moduleExports3 && freeGlobal2.process;
        var nodeUtil2 = function() {
          try {
            var types = freeModule3 && freeModule3.require && freeModule3.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
          } catch (e3) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil2 && nodeUtil2.isArrayBuffer, nodeIsDate = nodeUtil2 && nodeUtil2.isDate, nodeIsMap = nodeUtil2 && nodeUtil2.isMap, nodeIsRegExp = nodeUtil2 && nodeUtil2.isRegExp, nodeIsSet = nodeUtil2 && nodeUtil2.isSet, nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array2, setter, iteratee, accumulator) {
          var index = -1, length2 = array2 == null ? 0 : array2.length;
          while (++index < length2) {
            var value = array2[index];
            setter(accumulator, value, iteratee(value), array2);
          }
          return accumulator;
        }
        function arrayEach(array2, iteratee) {
          var index = -1, length2 = array2 == null ? 0 : array2.length;
          while (++index < length2) {
            if (iteratee(array2[index], index, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function arrayEachRight(array2, iteratee) {
          var length2 = array2 == null ? 0 : array2.length;
          while (length2--) {
            if (iteratee(array2[length2], length2, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function arrayEvery(array2, predicate) {
          var index = -1, length2 = array2 == null ? 0 : array2.length;
          while (++index < length2) {
            if (!predicate(array2[index], index, array2)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter2(array2, predicate) {
          var index = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
          while (++index < length2) {
            var value = array2[index];
            if (predicate(value, index, array2)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array2, value) {
          var length2 = array2 == null ? 0 : array2.length;
          return !!length2 && baseIndexOf(array2, value, 0) > -1;
        }
        function arrayIncludesWith(array2, value, comparator) {
          var index = -1, length2 = array2 == null ? 0 : array2.length;
          while (++index < length2) {
            if (comparator(value, array2[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap2(array2, iteratee) {
          var index = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
          while (++index < length2) {
            result[index] = iteratee(array2[index], index, array2);
          }
          return result;
        }
        function arrayPush2(array2, values) {
          var index = -1, length2 = values.length, offset = array2.length;
          while (++index < length2) {
            array2[offset + index] = values[index];
          }
          return array2;
        }
        function arrayReduce(array2, iteratee, accumulator, initAccum) {
          var index = -1, length2 = array2 == null ? 0 : array2.length;
          if (initAccum && length2) {
            accumulator = array2[++index];
          }
          while (++index < length2) {
            accumulator = iteratee(accumulator, array2[index], index, array2);
          }
          return accumulator;
        }
        function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
          var length2 = array2 == null ? 0 : array2.length;
          if (initAccum && length2) {
            accumulator = array2[--length2];
          }
          while (length2--) {
            accumulator = iteratee(accumulator, array2[length2], length2, array2);
          }
          return accumulator;
        }
        function arraySome2(array2, predicate) {
          var index = -1, length2 = array2 == null ? 0 : array2.length;
          while (++index < length2) {
            if (predicate(array2[index], index, array2)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array2, predicate, fromIndex, fromRight) {
          var length2 = array2.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length2) {
            if (predicate(array2[index], index, array2)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array2, value, fromIndex) {
          return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array2, value, fromIndex, comparator) {
          var index = fromIndex - 1, length2 = array2.length;
          while (++index < length2) {
            if (comparator(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array2, iteratee) {
          var length2 = array2 == null ? 0 : array2.length;
          return length2 ? baseSum(array2, iteratee) / length2 : NAN2;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf2(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array2, comparer) {
          var length2 = array2.length;
          array2.sort(comparer);
          while (length2--) {
            array2[length2] = array2[length2].value;
          }
          return array2;
        }
        function baseSum(array2, iteratee) {
          var result, index = -1, length2 = array2.length;
          while (++index < length2) {
            var current = iteratee(array2[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes2(n3, iteratee) {
          var index = -1, result = Array(n3);
          while (++index < n3) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap2(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim2(string) {
          return string ? string.slice(0, trimmedEndIndex2(string) + 1).replace(reTrimStart2, "") : string;
        }
        function baseUnary2(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap2(props, function(key) {
            return object[key];
          });
        }
        function cacheHas2(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length2 = strSymbols.length;
          while (++index < length2 && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array2, placeholder) {
          var length2 = array2.length, result = 0;
          while (length2--) {
            if (array2[length2] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf2(deburredLetters);
        var escapeHtmlChar2 = basePropertyOf2(htmlEscapes2);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue2(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray2(map2) {
          var index = -1, result = Array(map2.size);
          map2.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg2(func, transform2) {
          return function(arg) {
            return func(transform2(arg));
          };
        }
        function replaceHolders(array2, placeholder) {
          var index = -1, length2 = array2.length, resIndex = 0, result = [];
          while (++index < length2) {
            var value = array2[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array2[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray2(set4) {
          var index = -1, result = Array(set4.size);
          set4.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set4) {
          var index = -1, result = Array(set4.size);
          set4.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array2, value, fromIndex) {
          var index = fromIndex - 1, length2 = array2.length;
          while (++index < length2) {
            if (array2[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array2, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array2[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex2(string) {
          var index = string.length;
          while (index-- && reWhitespace2.test(string.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar2 = basePropertyOf2(htmlUnescapes2);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root3 : _2.defaults(root3.Object(), context, _2.pick(root3, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto2 = Array2.prototype, funcProto3 = Function2.prototype, objectProto13 = Object2.prototype;
          var coreJsData2 = context["__core-js_shared__"];
          var funcToString3 = funcProto3.toString;
          var hasOwnProperty10 = objectProto13.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey2 = function() {
            var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString3 = objectProto13.toString;
          var objectCtorString = funcToString3.call(Object2);
          var oldDash = root3._;
          var reIsNative2 = RegExp2(
            "^" + funcToString3.call(hasOwnProperty10).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer3 = moduleExports3 ? context.Buffer : undefined2, Symbol3 = context.Symbol, Uint8Array3 = context.Uint8Array, allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : undefined2, getPrototype = overArg2(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable3 = objectProto13.propertyIsEnumerable, splice2 = arrayProto2.splice, spreadableSymbol = Symbol3 ? Symbol3.isConcatSpreadable : undefined2, symIterator = Symbol3 ? Symbol3.iterator : undefined2, symToStringTag3 = Symbol3 ? Symbol3.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative2(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e3) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root3.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root3.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root3.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols2 = Object2.getOwnPropertySymbols, nativeIsBuffer2 = Buffer3 ? Buffer3.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto2.join, nativeKeys2 = overArg2(Object2.keys, Object2), nativeMax2 = Math2.max, nativeMin2 = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
          var DataView3 = getNative2(context, "DataView"), Map3 = getNative2(context, "Map"), Promise3 = getNative2(context, "Promise"), Set3 = getNative2(context, "Set"), WeakMap2 = getNative2(context, "WeakMap"), nativeCreate2 = getNative2(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString2 = toSource2(DataView3), mapCtorString2 = toSource2(Map3), promiseCtorString2 = toSource2(Promise3), setCtorString2 = toSource2(Set3), weakMapCtorString2 = toSource2(WeakMap2);
          var symbolProto3 = Symbol3 ? Symbol3.prototype : undefined2, symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : undefined2, symbolToString2 = symbolProto3 ? symbolProto3.toString : undefined2;
          function lodash(value) {
            if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty10.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = /* @__PURE__ */ function() {
            function object() {
            }
            return function(proto) {
              if (!isObject3(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length2 = end - start2, index = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin2(length2, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
              return baseWrapperValue(array2, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length2-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array2[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
                  if (type2 == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type2 == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash2(entries) {
            var index = -1, length2 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length2) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear2() {
            this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
            this.size = 0;
          }
          function hashDelete2(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet2(key) {
            var data = this.__data__;
            if (nativeCreate2) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED4 ? undefined2 : result2;
            }
            return hasOwnProperty10.call(data, key) ? data[key] : undefined2;
          }
          function hashHas2(key) {
            var data = this.__data__;
            return nativeCreate2 ? data[key] !== undefined2 : hasOwnProperty10.call(data, key);
          }
          function hashSet2(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate2 && value === undefined2 ? HASH_UNDEFINED4 : value;
            return this;
          }
          Hash2.prototype.clear = hashClear2;
          Hash2.prototype["delete"] = hashDelete2;
          Hash2.prototype.get = hashGet2;
          Hash2.prototype.has = hashHas2;
          Hash2.prototype.set = hashSet2;
          function ListCache2(entries) {
            var index = -1, length2 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length2) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear2() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete2(key) {
            var data = this.__data__, index = assocIndexOf2(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice2.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet2(key) {
            var data = this.__data__, index = assocIndexOf2(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas2(key) {
            return assocIndexOf2(this.__data__, key) > -1;
          }
          function listCacheSet2(key, value) {
            var data = this.__data__, index = assocIndexOf2(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache2.prototype.clear = listCacheClear2;
          ListCache2.prototype["delete"] = listCacheDelete2;
          ListCache2.prototype.get = listCacheGet2;
          ListCache2.prototype.has = listCacheHas2;
          ListCache2.prototype.set = listCacheSet2;
          function MapCache2(entries) {
            var index = -1, length2 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length2) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear2() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash2(),
              "map": new (Map3 || ListCache2)(),
              "string": new Hash2()
            };
          }
          function mapCacheDelete2(key) {
            var result2 = getMapData2(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet2(key) {
            return getMapData2(this, key).get(key);
          }
          function mapCacheHas2(key) {
            return getMapData2(this, key).has(key);
          }
          function mapCacheSet2(key, value) {
            var data = getMapData2(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache2.prototype.clear = mapCacheClear2;
          MapCache2.prototype["delete"] = mapCacheDelete2;
          MapCache2.prototype.get = mapCacheGet2;
          MapCache2.prototype.has = mapCacheHas2;
          MapCache2.prototype.set = mapCacheSet2;
          function SetCache2(values2) {
            var index = -1, length2 = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache2();
            while (++index < length2) {
              this.add(values2[index]);
            }
          }
          function setCacheAdd2(value) {
            this.__data__.set(value, HASH_UNDEFINED4);
            return this;
          }
          function setCacheHas2(value) {
            return this.__data__.has(value);
          }
          SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
          SetCache2.prototype.has = setCacheHas2;
          function Stack2(entries) {
            var data = this.__data__ = new ListCache2(entries);
            this.size = data.size;
          }
          function stackClear2() {
            this.__data__ = new ListCache2();
            this.size = 0;
          }
          function stackDelete2(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet2(key) {
            return this.__data__.get(key);
          }
          function stackHas2(key) {
            return this.__data__.has(key);
          }
          function stackSet2(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache2) {
              var pairs2 = data.__data__;
              if (!Map3 || pairs2.length < LARGE_ARRAY_SIZE2 - 1) {
                pairs2.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache2(pairs2);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack2.prototype.clear = stackClear2;
          Stack2.prototype["delete"] = stackDelete2;
          Stack2.prototype.get = stackGet2;
          Stack2.prototype.has = stackHas2;
          Stack2.prototype.set = stackSet2;
          function arrayLikeKeys2(value, inherited) {
            var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes2(value.length, String2) : [], length2 = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty10.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex2(key, length2)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array2) {
            var length2 = array2.length;
            return length2 ? array2[baseRandom(0, length2 - 1)] : undefined2;
          }
          function arraySampleSize(array2, n3) {
            return shuffleSelf(copyArray(array2), baseClamp(n3, 0, array2.length));
          }
          function arrayShuffle(array2) {
            return shuffleSelf(copyArray(array2));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq2(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty10.call(object, key) && eq2(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf2(array2, key) {
            var length2 = array2.length;
            while (length2--) {
              if (eq2(array2[length2][0], key)) {
                return length2;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys2(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index = -1, length2 = paths.length, result2 = Array2(length2), skip = object == null;
            while (++index < length2) {
              result2[index] = skip ? undefined2 : get4(object, paths[index]);
            }
            return result2;
          }
          function baseClamp(number3, lower2, upper) {
            if (number3 === number3) {
              if (upper !== undefined2) {
                number3 = number3 <= upper ? number3 : upper;
              }
              if (lower2 !== undefined2) {
                number3 = number3 >= lower2 ? number3 : lower2;
              }
            }
            return number3;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject3(value)) {
              return value;
            }
            var isArr = isArray2(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag2 = getTag2(value), isFunc = tag2 == funcTag3 || tag2 == genTag2;
              if (isBuffer2(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag2 == objectTag4 || tag2 == argsTag4 || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag2]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag2, isDeep);
              }
            }
            stack || (stack = new Stack2());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys2 : isFlat ? keysIn : keys2;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys2(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length2 = props.length;
            if (object == null) {
              return !length2;
            }
            object = Object2(object);
            while (length2--) {
              var key = props[length2], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array2, values2, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, isCommon = true, length2 = array2.length, result2 = [], valuesLength = values2.length;
            if (!length2) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap2(values2, baseUnary2(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE2) {
              includes2 = cacheHas2;
              isCommon = false;
              values2 = new SetCache2(values2);
            }
            outer:
              while (++index < length2) {
                var value = array2[index], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array2, iteratee2, comparator) {
            var index = -1, length2 = array2.length;
            while (++index < length2) {
              var value = array2[index], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol2(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array2, value, start2, end) {
            var length2 = array2.length;
            start2 = toInteger(start2);
            if (start2 < 0) {
              start2 = -start2 > length2 ? 0 : length2 + start2;
            }
            end = end === undefined2 || end > length2 ? length2 : toInteger(end);
            if (end < 0) {
              end += length2;
            }
            end = start2 > end ? 0 : toLength(end);
            while (start2 < end) {
              array2[start2++] = value;
            }
            return array2;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array2, depth, predicate, isStrict, result2) {
            var index = -1, length2 = array2.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index < length2) {
              var value = array2[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush2(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys2);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys2);
          }
          function baseFunctions(object, props) {
            return arrayFilter2(props, function(key) {
              return isFunction2(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length2 = path.length;
            while (object != null && index < length2) {
              object = object[toKey(path[index++])];
            }
            return index && index == length2 ? object : undefined2;
          }
          function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray2(object) ? result2 : arrayPush2(result2, symbolsFunc(object));
          }
          function baseGetTag2(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag2 : nullTag2;
            }
            return symToStringTag3 && symToStringTag3 in Object2(value) ? getRawTag2(value) : objectToString2(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty10.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number3, start2, end) {
            return number3 >= nativeMin2(start2, end) && number3 < nativeMax2(start2, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array2 = arrays[othIndex];
              if (othIndex && iteratee2) {
                array2 = arrayMap2(array2, baseUnary2(iteratee2));
              }
              maxLength = nativeMin2(array2.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array2.length >= 120) ? new SetCache2(othIndex && array2) : undefined2;
            }
            array2 = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length2 && result2.length < maxLength) {
                var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas2(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas2(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments2(value) {
            return isObjectLike2(value) && baseGetTag2(value) == argsTag4;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag3;
          }
          function baseIsDate(value) {
            return isObjectLike2(value) && baseGetTag2(value) == dateTag3;
          }
          function baseIsEqual2(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep2(value, other, bitmask, customizer, baseIsEqual2, stack);
          }
          function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag3 : getTag2(object), othTag = othIsArr ? arrayTag3 : getTag2(other);
            objTag = objTag == argsTag4 ? objectTag4 : objTag;
            othTag = othTag == argsTag4 ? objectTag4 : othTag;
            var objIsObj = objTag == objectTag4, othIsObj = othTag == objectTag4, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer2(object)) {
              if (!isBuffer2(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack2());
              return objIsArr || isTypedArray2(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG5)) {
              var objIsWrapped = objIsObj && hasOwnProperty10.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty10.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack2());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack2());
            return equalObjects2(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike2(value) && getTag2(value) == mapTag4;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length2 = index, noCustomizer = !customizer;
            if (object == null) {
              return !length2;
            }
            object = Object2(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length2) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack2();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative2(value) {
            if (!isObject3(value) || isMasked2(value)) {
              return false;
            }
            var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
            return pattern.test(toSource2(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike2(value) && baseGetTag2(value) == regexpTag3;
          }
          function baseIsSet(value) {
            return isObjectLike2(value) && getTag2(value) == setTag4;
          }
          function baseIsTypedArray2(value) {
            return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity4;
            }
            if (typeof value == "object") {
              return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys2(object) {
            if (!isPrototype2(object)) {
              return nativeKeys2(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty10.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject3(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype2(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty10.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get4(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack2());
              if (isObject3(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray2(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments2(srcValue)) {
                newValue = objValue;
                if (isArguments2(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject3(objValue) || isFunction2(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array2, n3) {
            var length2 = array2.length;
            if (!length2) {
              return;
            }
            n3 += n3 < 0 ? length2 : 0;
            return isIndex2(n3, length2) ? array2[n3] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap2(iteratees, function(iteratee2) {
                if (isArray2(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity4];
            }
            var index = -1;
            iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap2(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length2 = paths.length, result2 = {};
            while (++index < length2) {
              var path = paths[index], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array2, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length2 = values2.length, seen = array2;
            if (array2 === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap2(array2, baseUnary2(iteratee2));
            }
            while (++index < length2) {
              var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array2) {
                  splice2.call(seen, fromIndex, 1);
                }
                splice2.call(array2, fromIndex, 1);
              }
            }
            return array2;
          }
          function basePullAt(array2, indexes) {
            var length2 = array2 ? indexes.length : 0, lastIndex = length2 - 1;
            while (length2--) {
              var index = indexes[length2];
              if (length2 == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex2(index)) {
                  splice2.call(array2, index, 1);
                } else {
                  baseUnset(array2, index);
                }
              }
            }
            return array2;
          }
          function baseRandom(lower2, upper) {
            return lower2 + nativeFloor(nativeRandom() * (upper - lower2 + 1));
          }
          function baseRange(start2, end, step, fromRight) {
            var index = -1, length2 = nativeMax2(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length2);
            while (length2--) {
              result2[fromRight ? length2 : ++index] = start2;
              start2 += step;
            }
            return result2;
          }
          function baseRepeat(string, n3) {
            var result2 = "";
            if (!string || n3 < 1 || n3 > MAX_SAFE_INTEGER4) {
              return result2;
            }
            do {
              if (n3 % 2) {
                result2 += string;
              }
              n3 = nativeFloor(n3 / 2);
              if (n3) {
                string += string;
              }
            } while (n3);
            return result2;
          }
          function baseRest(func, start2) {
            return setToString(overRest(func, start2, identity4), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n3) {
            var array2 = values(collection);
            return shuffleSelf(array2, baseClamp(n3, 0, array2.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject3(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
            while (nested != null && ++index < length2) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject3(objValue) ? objValue : isIndex2(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity4 : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity4 : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array2, start2, end) {
            var index = -1, length2 = array2.length;
            if (start2 < 0) {
              start2 = -start2 > length2 ? 0 : length2 + start2;
            }
            end = end > length2 ? length2 : end;
            if (end < 0) {
              end += length2;
            }
            length2 = start2 > end ? 0 : end - start2 >>> 0;
            start2 >>>= 0;
            var result2 = Array2(length2);
            while (++index < length2) {
              result2[index] = array2[index + start2];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array2, value, retHighest) {
            var low = 0, high = array2 == null ? low : array2.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array2[mid];
                if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array2, value, identity4, retHighest);
          }
          function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
            var low = 0, high = array2 == null ? 0 : array2.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin2(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array2, iteratee2) {
            var index = -1, length2 = array2.length, resIndex = 0, result2 = [];
            while (++index < length2) {
              var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq2(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol2(value)) {
              return NAN2;
            }
            return +value;
          }
          function baseToString2(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray2(value)) {
              return arrayMap2(value, baseToString2) + "";
            }
            if (isSymbol2(value)) {
              return symbolToString2 ? symbolToString2.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
          }
          function baseUniq(array2, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, length2 = array2.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length2 >= LARGE_ARRAY_SIZE2) {
              var set5 = iteratee2 ? null : createSet(array2);
              if (set5) {
                return setToArray2(set5);
              }
              isCommon = false;
              includes2 = cacheHas2;
              seen = new SetCache2();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length2) {
                var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array2, predicate, isDrop, fromRight) {
            var length2 = array2.length, index = fromRight ? length2 : -1;
            while ((fromRight ? index-- : ++index < length2) && predicate(array2[index], index, array2)) {
            }
            return isDrop ? baseSlice(array2, fromRight ? 0 : index, fromRight ? index + 1 : length2) : baseSlice(array2, fromRight ? index + 1 : 0, fromRight ? length2 : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush2([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length2 = arrays.length;
            if (length2 < 2) {
              return length2 ? baseUniq(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length2);
            while (++index < length2) {
              var array2 = arrays[index], othIndex = -1;
              while (++othIndex < length2) {
                if (othIndex != index) {
                  result2[index] = baseDifference(result2[index] || array2, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index = -1, length2 = props.length, valsLength = values2.length, result2 = {};
            while (++index < length2) {
              var value = index < valsLength ? values2[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity4;
          }
          function castPath(value, object) {
            if (isArray2(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString2(value));
          }
          var castRest = baseRest;
          function castSlice(array2, start2, end) {
            var length2 = array2.length;
            end = end === undefined2 ? length2 : end;
            return !start2 && end >= length2 ? array2 : baseSlice(array2, start2, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id2) {
            return root3.clearTimeout(id2);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array3(result2).set(new Uint8Array3(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf2 ? Object2(symbolValueOf2.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
            while (++index < length2) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order = orders[index];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array2) {
            var index = -1, length2 = source.length;
            array2 || (array2 = Array2(length2));
            while (++index < length2) {
              array2[index] = source[index];
            }
            return array2;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length2 = props.length;
            while (++index < length2) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols2(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined2, guard = length2 > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length2 < 3 ? undefined2 : customizer;
                length2 = 1;
              }
              object = Object2(object);
              while (++index < length2) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike2(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length2 = collection.length, index = fromRight ? length2 : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length2) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object), props = keysFunc(object), length2 = props.length;
              while (length2--) {
                var key = props[fromRight ? length2 : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root3 && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString2(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject3(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length2 = arguments.length, args = Array2(length2), index = length2, placeholder = getHolder(wrapper);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length2 -= holders.length;
              if (length2 < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length2
                );
              }
              var fn = this && this !== root3 && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike2(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys2(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length2 = funcs.length, index = length2, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT3);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? index : length2;
              while (++index < length2) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray2(value)) {
                  return wrapper.plant(value).value();
                }
                var index2 = 0, result2 = length2 ? funcs[index2].apply(this, args) : value;
                while (++index2 < length2) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length2 = arguments.length, args = Array2(length2), index = length2;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length2 -= holdersCount;
              if (isCurried && length2 < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length2
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length2 = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length2 > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length2) {
                args.length = ary2;
              }
              if (this && this !== root3 && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString2(value);
                  other = baseToString2(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length2, chars) {
            chars = chars === undefined2 ? " " : baseToString2(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length2) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root3 && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start2, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
                end = step = undefined2;
              }
              start2 = toFinite(start2);
              if (end === undefined2) {
                end = start2;
                start2 = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start2 < end ? 1 : -1 : toFinite(step);
              return baseRange(start2, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber3(value);
                other = toNumber3(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number3, precision3) {
              number3 = toNumber3(number3);
              precision3 = precision3 == null ? 0 : nativeMin2(toInteger(precision3), 292);
              if (precision3 && nativeIsFinite(number3)) {
                var pair3 = (toString2(number3) + "e").split("e"), value = func(pair3[0] + "e" + (+pair3[1] + precision3));
                pair3 = (toString2(value) + "e").split("e");
                return +(pair3[0] + "e" + (+pair3[1] - precision3));
              }
              return func(number3);
            };
          }
          var createSet = !(Set3 && 1 / setToArray2(new Set3([, -0]))[1] == INFINITY2) ? noop3 : function(values2) {
            return new Set3(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag2 = getTag2(object);
              if (tag2 == mapTag4) {
                return mapToArray2(object);
              }
              if (tag2 == setTag4) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            var length2 = partials ? partials.length : 0;
            if (!length2) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax2(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length2 -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax2(newData[9] - length2, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq2(objValue, objectProto13[key]) && !hasOwnProperty10.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject3(objValue) && isObject3(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays2(array2, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG5, arrLength = array2.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array2);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array2;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG3 ? new SetCache2() : undefined2;
            stack.set(array2, other);
            stack.set(other, array2);
            while (++index < arrLength) {
              var arrValue = array2[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome2(other, function(othValue2, othIndex) {
                  if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array2);
            stack["delete"](other);
            return result2;
          }
          function equalByTag2(object, other, tag2, bitmask, customizer, equalFunc, stack) {
            switch (tag2) {
              case dataViewTag4:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag3:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object), new Uint8Array3(other))) {
                  return false;
                }
                return true;
              case boolTag3:
              case dateTag3:
              case numberTag4:
                return eq2(+object, +other);
              case errorTag3:
                return object.name == other.name && object.message == other.message;
              case regexpTag3:
              case stringTag3:
                return object == other + "";
              case mapTag4:
                var convert = mapToArray2;
              case setTag4:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG5;
                convert || (convert = setToArray2);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG3;
                stack.set(object, other);
                var result2 = equalArrays2(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag3:
                if (symbolValueOf2) {
                  return symbolValueOf2.call(object) == symbolValueOf2.call(other);
                }
            }
            return false;
          }
          function equalObjects2(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG5, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty10.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten2), func + "");
          }
          function getAllKeys2(object) {
            return baseGetAllKeys2(object, keys2, getSymbols2);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys2(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop3 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array2 = realNames[result2], length2 = hasOwnProperty10.call(realNames, result2) ? array2.length : 0;
            while (length2--) {
              var data = array2[length2], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty10.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData2(map3, key) {
            var data = map3.__data__;
            return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys2(object), length2 = result2.length;
            while (length2--) {
              var key = result2[length2], value = object[key];
              result2[length2] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative2(object, key) {
            var value = getValue2(object, key);
            return baseIsNative2(value) ? value : undefined2;
          }
          function getRawTag2(value) {
            var isOwn = hasOwnProperty10.call(value, symToStringTag3), tag2 = value[symToStringTag3];
            try {
              value[symToStringTag3] = undefined2;
              var unmasked = true;
            } catch (e3) {
            }
            var result2 = nativeObjectToString3.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag3] = tag2;
              } else {
                delete value[symToStringTag3];
              }
            }
            return result2;
          }
          var getSymbols2 = !nativeGetSymbols2 ? stubArray2 : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter2(nativeGetSymbols2(object), function(symbol) {
              return propertyIsEnumerable3.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols2 ? stubArray2 : function(object) {
            var result2 = [];
            while (object) {
              arrayPush2(result2, getSymbols2(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag2 = baseGetTag2;
          if (DataView3 && getTag2(new DataView3(new ArrayBuffer(1))) != dataViewTag4 || Map3 && getTag2(new Map3()) != mapTag4 || Promise3 && getTag2(Promise3.resolve()) != promiseTag2 || Set3 && getTag2(new Set3()) != setTag4 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag3) {
            getTag2 = function(value) {
              var result2 = baseGetTag2(value), Ctor = result2 == objectTag4 ? value.constructor : undefined2, ctorString = Ctor ? toSource2(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString2:
                    return dataViewTag4;
                  case mapCtorString2:
                    return mapTag4;
                  case promiseCtorString2:
                    return promiseTag2;
                  case setCtorString2:
                    return setTag4;
                  case weakMapCtorString2:
                    return weakMapTag3;
                }
              }
              return result2;
            };
          }
          function getView(start2, end, transforms) {
            var index = -1, length2 = transforms.length;
            while (++index < length2) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start2 += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin2(end, start2 + size2);
                  break;
                case "takeRight":
                  start2 = nativeMax2(start2, end - size2);
                  break;
              }
            }
            return { "start": start2, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length2 = path.length, result2 = false;
            while (++index < length2) {
              var key = toKey(path[index]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index != length2) {
              return result2;
            }
            length2 = object == null ? 0 : object.length;
            return !!length2 && isLength2(length2) && isIndex2(key, length2) && (isArray2(object) || isArguments2(object));
          }
          function initCloneArray(array2) {
            var length2 = array2.length, result2 = new array2.constructor(length2);
            if (length2 && typeof array2[0] == "string" && hasOwnProperty10.call(array2, "index")) {
              result2.index = array2.index;
              result2.input = array2.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag2, isDeep) {
            var Ctor = object.constructor;
            switch (tag2) {
              case arrayBufferTag3:
                return cloneArrayBuffer(object);
              case boolTag3:
              case dateTag3:
                return new Ctor(+object);
              case dataViewTag4:
                return cloneDataView(object, isDeep);
              case float32Tag2:
              case float64Tag2:
              case int8Tag2:
              case int16Tag2:
              case int32Tag2:
              case uint8Tag2:
              case uint8ClampedTag2:
              case uint16Tag2:
              case uint32Tag2:
                return cloneTypedArray(object, isDeep);
              case mapTag4:
                return new Ctor();
              case numberTag4:
              case stringTag3:
                return new Ctor(object);
              case regexpTag3:
                return cloneRegExp(object);
              case setTag4:
                return new Ctor();
              case symbolTag3:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length2 = details.length;
            if (!length2) {
              return source;
            }
            var lastIndex = length2 - 1;
            details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length2 > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray2(value) || isArguments2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex2(value, length2) {
            var type2 = typeof value;
            length2 = length2 == null ? MAX_SAFE_INTEGER4 : length2;
            return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
          }
          function isIterateeCall(value, index, object) {
            if (!isObject3(object)) {
              return false;
            }
            var type2 = typeof index;
            if (type2 == "number" ? isArrayLike2(object) && isIndex2(index, object.length) : type2 == "string" && index in object) {
              return eq2(object[index], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray2(value)) {
              return false;
            }
            var type2 = typeof value;
            if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol2(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable2(value) {
            var type2 = typeof value;
            return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked2(func) {
            return !!maskSrcKey2 && maskSrcKey2 in func;
          }
          var isMaskable = coreJsData2 ? isFunction2 : stubFalse2;
          function isPrototype2(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto13;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject3(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin2(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString2(value) {
            return nativeObjectToString3.call(value);
          }
          function overRest(func, start2, transform3) {
            start2 = nativeMax2(start2 === undefined2 ? func.length - 1 : start2, 0);
            return function() {
              var args = arguments, index = -1, length2 = nativeMax2(args.length - start2, 0), array2 = Array2(length2);
              while (++index < length2) {
                array2[index] = args[start2 + index];
              }
              index = -1;
              var otherArgs = Array2(start2 + 1);
              while (++index < start2) {
                otherArgs[index] = args[index];
              }
              otherArgs[start2] = transform3(array2);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array2, indexes) {
            var arrLength = array2.length, length2 = nativeMin2(indexes.length, arrLength), oldArray = copyArray(array2);
            while (length2--) {
              var index = indexes[length2];
              array2[length2] = isIndex2(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array2;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root3.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array2, size2) {
            var index = -1, length2 = array2.length, lastIndex = length2 - 1;
            size2 = size2 === undefined2 ? length2 : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array2[rand];
              array2[rand] = array2[index];
              array2[index] = value;
            }
            array2.length = size2;
            return array2;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match, number3, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol2(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
          }
          function toSource2(func) {
            if (func != null) {
              try {
                return funcToString3.call(func);
              } catch (e3) {
              }
              try {
                return func + "";
              } catch (e3) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair3) {
              var value = "_." + pair3[0];
              if (bitmask & pair3[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array2, size2, guard) {
            if (guard ? isIterateeCall(array2, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax2(toInteger(size2), 0);
            }
            var length2 = array2 == null ? 0 : array2.length;
            if (!length2 || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size2));
            while (index < length2) {
              result2[resIndex++] = baseSlice(array2, index, index += size2);
            }
            return result2;
          }
          function compact(array2) {
            var index = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
            while (++index < length2) {
              var value = array2[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length2 = arguments.length;
            if (!length2) {
              return [];
            }
            var args = Array2(length2 - 1), array2 = arguments[0], index = length2;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush2(isArray2(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
          }
          var difference2 = baseRest(function(array2, values2) {
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array2, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array2, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array2, n3, guard) {
            var length2 = array2 == null ? 0 : array2.length;
            if (!length2) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            return baseSlice(array2, n3 < 0 ? 0 : n3, length2);
          }
          function dropRight(array2, n3, guard) {
            var length2 = array2 == null ? 0 : array2.length;
            if (!length2) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            n3 = length2 - n3;
            return baseSlice(array2, 0, n3 < 0 ? 0 : n3);
          }
          function dropRightWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
          }
          function fill(array2, value, start2, end) {
            var length2 = array2 == null ? 0 : array2.length;
            if (!length2) {
              return [];
            }
            if (start2 && typeof start2 != "number" && isIterateeCall(array2, value, start2)) {
              start2 = 0;
              end = length2;
            }
            return baseFill(array2, value, start2, end);
          }
          function findIndex(array2, predicate, fromIndex) {
            var length2 = array2 == null ? 0 : array2.length;
            if (!length2) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax2(length2 + index, 0);
            }
            return baseFindIndex(array2, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array2, predicate, fromIndex) {
            var length2 = array2 == null ? 0 : array2.length;
            if (!length2) {
              return -1;
            }
            var index = length2 - 1;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax2(length2 + index, 0) : nativeMin2(index, length2 - 1);
            }
            return baseFindIndex(array2, getIteratee(predicate, 3), index, true);
          }
          function flatten2(array2) {
            var length2 = array2 == null ? 0 : array2.length;
            return length2 ? baseFlatten(array2, 1) : [];
          }
          function flattenDeep(array2) {
            var length2 = array2 == null ? 0 : array2.length;
            return length2 ? baseFlatten(array2, INFINITY2) : [];
          }
          function flattenDepth(array2, depth) {
            var length2 = array2 == null ? 0 : array2.length;
            if (!length2) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array2, depth);
          }
          function fromPairs(pairs2) {
            var index = -1, length2 = pairs2 == null ? 0 : pairs2.length, result2 = {};
            while (++index < length2) {
              var pair3 = pairs2[index];
              result2[pair3[0]] = pair3[1];
            }
            return result2;
          }
          function head(array2) {
            return array2 && array2.length ? array2[0] : undefined2;
          }
          function indexOf(array2, value, fromIndex) {
            var length2 = array2 == null ? 0 : array2.length;
            if (!length2) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax2(length2 + index, 0);
            }
            return baseIndexOf(array2, value, index);
          }
          function initial(array2) {
            var length2 = array2 == null ? 0 : array2.length;
            return length2 ? baseSlice(array2, 0, -1) : [];
          }
          var intersection2 = baseRest(function(arrays) {
            var mapped = arrayMap2(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array2, separator) {
            return array2 == null ? "" : nativeJoin.call(array2, separator);
          }
          function last(array2) {
            var length2 = array2 == null ? 0 : array2.length;
            return length2 ? array2[length2 - 1] : undefined2;
          }
          function lastIndexOf(array2, value, fromIndex) {
            var length2 = array2 == null ? 0 : array2.length;
            if (!length2) {
              return -1;
            }
            var index = length2;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax2(length2 + index, 0) : nativeMin2(index, length2 - 1);
            }
            return value === value ? strictLastIndexOf(array2, value, index) : baseFindIndex(array2, baseIsNaN, index, true);
          }
          function nth(array2, n3) {
            return array2 && array2.length ? baseNth(array2, toInteger(n3)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array2, values2) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2) : array2;
          }
          function pullAllBy(array2, values2, iteratee2) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, getIteratee(iteratee2, 2)) : array2;
          }
          function pullAllWith(array2, values2, comparator) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, undefined2, comparator) : array2;
          }
          var pullAt = flatRest(function(array2, indexes) {
            var length2 = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
            basePullAt(array2, arrayMap2(indexes, function(index) {
              return isIndex2(index, length2) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove2(array2, predicate) {
            var result2 = [];
            if (!(array2 && array2.length)) {
              return result2;
            }
            var index = -1, indexes = [], length2 = array2.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length2) {
              var value = array2[index];
              if (predicate(value, index, array2)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array2, indexes);
            return result2;
          }
          function reverse(array2) {
            return array2 == null ? array2 : nativeReverse.call(array2);
          }
          function slice(array2, start2, end) {
            var length2 = array2 == null ? 0 : array2.length;
            if (!length2) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array2, start2, end)) {
              start2 = 0;
              end = length2;
            } else {
              start2 = start2 == null ? 0 : toInteger(start2);
              end = end === undefined2 ? length2 : toInteger(end);
            }
            return baseSlice(array2, start2, end);
          }
          function sortedIndex(array2, value) {
            return baseSortedIndex(array2, value);
          }
          function sortedIndexBy(array2, value, iteratee2) {
            return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array2, value) {
            var length2 = array2 == null ? 0 : array2.length;
            if (length2) {
              var index = baseSortedIndex(array2, value);
              if (index < length2 && eq2(array2[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array2, value) {
            return baseSortedIndex(array2, value, true);
          }
          function sortedLastIndexBy(array2, value, iteratee2) {
            return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array2, value) {
            var length2 = array2 == null ? 0 : array2.length;
            if (length2) {
              var index = baseSortedIndex(array2, value, true) - 1;
              if (eq2(array2[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array2) {
            return array2 && array2.length ? baseSortedUniq(array2) : [];
          }
          function sortedUniqBy(array2, iteratee2) {
            return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array2) {
            var length2 = array2 == null ? 0 : array2.length;
            return length2 ? baseSlice(array2, 1, length2) : [];
          }
          function take(array2, n3, guard) {
            if (!(array2 && array2.length)) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            return baseSlice(array2, 0, n3 < 0 ? 0 : n3);
          }
          function takeRight(array2, n3, guard) {
            var length2 = array2 == null ? 0 : array2.length;
            if (!length2) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            n3 = length2 - n3;
            return baseSlice(array2, n3 < 0 ? 0 : n3, length2);
          }
          function takeRightWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
          }
          var union2 = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array2) {
            return array2 && array2.length ? baseUniq(array2) : [];
          }
          function uniqBy(array2, iteratee2) {
            return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array2, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array2 && array2.length ? baseUniq(array2, undefined2, comparator) : [];
          }
          function unzip(array2) {
            if (!(array2 && array2.length)) {
              return [];
            }
            var length2 = 0;
            array2 = arrayFilter2(array2, function(group) {
              if (isArrayLikeObject(group)) {
                length2 = nativeMax2(group.length, length2);
                return true;
              }
            });
            return baseTimes2(length2, function(index) {
              return arrayMap2(array2, baseProperty(index));
            });
          }
          function unzipWith(array2, iteratee2) {
            if (!(array2 && array2.length)) {
              return [];
            }
            var result2 = unzip(array2);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap2(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array2, values2) {
            return isArrayLikeObject(array2) ? baseDifference(array2, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter2(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter2(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter2(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length2 = paths.length, start2 = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start2)) {
              return this.thru(interceptor);
            }
            value = value.slice(start2, +start2 + (length2 ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array2) {
              if (length2 && !array2.length) {
                array2.push(undefined2);
              }
              return array2;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone3 = wrapperClone(parent2);
              clone3.__index__ = 0;
              clone3.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone3;
              } else {
                result2 = clone3;
              }
              var previous = clone3;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty10.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray2(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter2(collection, predicate) {
            var func = isArray2(collection) ? arrayFilter2 : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find2 = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map2(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map2(collection, iteratee2), INFINITY2);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map2(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray2(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray2(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty10.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike2(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length2 = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax2(length2 + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map2(collection, iteratee2) {
            var func = isArray2(collection) ? arrayMap2 : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray2(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray2(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray2(collection) ? arrayFilter2 : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray2(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n3, guard) {
            if (guard ? isIterateeCall(collection, n3, guard) : n3 === undefined2) {
              n3 = 1;
            } else {
              n3 = toInteger(n3);
            }
            var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n3);
          }
          function shuffle(collection) {
            var func = isArray2(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike2(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag2 = getTag2(collection);
            if (tag2 == mapTag4 || tag2 == setTag4) {
              return collection.size;
            }
            return baseKeys2(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray2(collection) ? arraySome2 : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length2 = iteratees.length;
            if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now3 = ctxNow || function() {
            return root3.Date.now();
          };
          function after(n3, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            n3 = toInteger(n3);
            return function() {
              if (--n3 < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n3, guard) {
            n3 = guard ? undefined2 : n3;
            n3 = func && n3 == null ? func.length : n3;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n3);
          }
          function before(n3, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            n3 = toInteger(n3);
            return function() {
              if (--n3 > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n3 <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey2 = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey2));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce2(func, wait, options2) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            wait = toNumber3(wait) || 0;
            if (isObject3(options2)) {
              leading = !!options2.leading;
              maxing = "maxWait" in options2;
              maxWait = maxing ? nativeMax2(toNumber3(options2.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options2 ? !!options2.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin2(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now3();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now3());
            }
            function debounced() {
              var time = now3(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber3(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache2)();
            return memoized;
          }
          memoize.Cache = MapCache2;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap2(transforms[0], baseUnary2(getIteratee())) : arrayMap2(baseFlatten(transforms, 1), baseUnary2(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length2 = nativeMin2(args.length, funcsLength);
              while (++index < length2) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start2) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            start2 = start2 === undefined2 ? start2 : toInteger(start2);
            return baseRest(func, start2);
          }
          function spread(func, start2) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            start2 = start2 == null ? 0 : nativeMax2(toInteger(start2), 0);
            return baseRest(function(args) {
              var array2 = args[start2], otherArgs = castSlice(args, 0, start2);
              if (array2) {
                arrayPush2(otherArgs, array2);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle2(func, wait, options2) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            if (isObject3(options2)) {
              leading = "leading" in options2 ? !!options2.leading : leading;
              trailing = "trailing" in options2 ? !!options2.trailing : trailing;
            }
            return debounce2(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap2(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray2(value) ? value : [value];
          }
          function clone2(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys2(source));
          }
          function eq2(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt2 = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments2 = baseIsArguments2(/* @__PURE__ */ function() {
            return arguments;
          }()) ? baseIsArguments2 : function(value) {
            return isObjectLike2(value) && hasOwnProperty10.call(value, "callee") && !propertyIsEnumerable3.call(value, "callee");
          };
          var isArray2 = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary2(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike2(value) {
            return value != null && isLength2(value.length) && !isFunction2(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike2(value) && isArrayLike2(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag3;
          }
          var isBuffer2 = nativeIsBuffer2 || stubFalse2;
          var isDate = nodeIsDate ? baseUnary2(nodeIsDate) : baseIsDate;
          function isElement2(value) {
            return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments2(value))) {
              return !value.length;
            }
            var tag2 = getTag2(value);
            if (tag2 == mapTag4 || tag2 == setTag4) {
              return !value.size;
            }
            if (isPrototype2(value)) {
              return !baseKeys2(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty10.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual4(value, other) {
            return baseIsEqual2(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual2(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike2(value)) {
              return false;
            }
            var tag2 = baseGetTag2(value);
            return tag2 == errorTag3 || tag2 == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction2(value) {
            if (!isObject3(value)) {
              return false;
            }
            var tag2 = baseGetTag2(value);
            return tag2 == funcTag3 || tag2 == genTag2 || tag2 == asyncTag2 || tag2 == proxyTag2;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength2(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER4;
          }
          function isObject3(value) {
            var type2 = typeof value;
            return value != null && (type2 == "object" || type2 == "function");
          }
          function isObjectLike2(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary2(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber3(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative2(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber3(value) {
            return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag4;
          }
          function isPlainObject(value) {
            if (!isObjectLike2(value) || baseGetTag2(value) != objectTag4) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty10.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary2(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER4 && value <= MAX_SAFE_INTEGER4;
          }
          var isSet = nodeIsSet ? baseUnary2(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag3;
          }
          function isSymbol2(value) {
            return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag3;
          }
          var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike2(value) && getTag2(value) == weakMapTag3;
          }
          function isWeakSet(value) {
            return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
          }
          var lt2 = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike2(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag2 = getTag2(value), func = tag2 == mapTag4 ? mapToArray2 : tag2 == setTag4 ? setToArray2 : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber3(value);
            if (value === INFINITY2 || value === -INFINITY2) {
              var sign2 = value < 0 ? -1 : 1;
              return sign2 * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber3(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol2(value)) {
              return NAN2;
            }
            if (isObject3(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject3(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim2(value);
            var isBinary = reIsBinary2.test(value);
            return isBinary || reIsOctal2.test(value) ? freeParseInt2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex2.test(value) ? NAN2 : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER4, MAX_SAFE_INTEGER4) : value === 0 ? value : 0;
          }
          function toString2(value) {
            return value == null ? "" : baseToString2(value);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype2(source) || isArrayLike2(source)) {
              copyObject(source, keys2(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty10.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys2(source), object, customizer);
          });
          var at2 = flatRest(baseAt);
          function create2(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object2(object);
            var index = -1;
            var length2 = sources.length;
            var guard = length2 > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length2 = 1;
            }
            while (++index < length2) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq2(value, objectProto13[key]) && !hasOwnProperty10.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys2(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get4(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString3.call(value);
            }
            result2[value] = key;
          }, constant(identity4));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString3.call(value);
            }
            if (hasOwnProperty10.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys2(object) {
            return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
          }
          function keysIn(object) {
            return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge2 = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap2(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length2 = paths.length;
            while (length2--) {
              baseUnset(result2, paths[length2]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap2(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length2 = path.length;
            if (!length2) {
              length2 = 1;
              object = undefined2;
            }
            while (++index < length2) {
              var value = object == null ? undefined2 : object[toKey(path[index])];
              if (value === undefined2) {
                index = length2;
                value = defaultValue;
              }
              object = isFunction2(value) ? value.call(object) : value;
            }
            return object;
          }
          function set4(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys2);
          var toPairsIn = createToPairs(keysIn);
          function transform2(object, iteratee2, accumulator) {
            var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject3(object)) {
                accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys2(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp3(number3, lower2, upper) {
            if (upper === undefined2) {
              upper = lower2;
              lower2 = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber3(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower2 !== undefined2) {
              lower2 = toNumber3(lower2);
              lower2 = lower2 === lower2 ? lower2 : 0;
            }
            return baseClamp(toNumber3(number3), lower2, upper);
          }
          function inRange(number3, start2, end) {
            start2 = toFinite(start2);
            if (end === undefined2) {
              end = start2;
              start2 = 0;
            } else {
              end = toFinite(end);
            }
            number3 = toNumber3(number3);
            return baseInRange(number3, start2, end);
          }
          function random(lower2, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower2, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower2 == "boolean") {
                floating = lower2;
                lower2 = undefined2;
              }
            }
            if (lower2 === undefined2 && upper === undefined2) {
              lower2 = 0;
              upper = 1;
            } else {
              lower2 = toFinite(lower2);
              if (upper === undefined2) {
                upper = lower2;
                lower2 = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower2 > upper) {
              var temp = lower2;
              lower2 = upper;
              upper = temp;
            }
            if (floating || lower2 % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin2(lower2 + rand * (upper - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower2, upper);
          }
          var camelCase = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString2(string).toLowerCase());
          }
          function deburr(string) {
            string = toString2(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString2(string);
            target = baseToString2(target);
            var length2 = string.length;
            position = position === undefined2 ? length2 : baseClamp(toInteger(position), 0, length2);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape6(string) {
            string = toString2(string);
            return string && reHasUnescapedHtml2.test(string) ? string.replace(reUnescapedHtml2, escapeHtmlChar2) : string;
          }
          function escapeRegExp(string) {
            string = toString2(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad2(string, length2, chars) {
            string = toString2(string);
            length2 = toInteger(length2);
            var strLength = length2 ? stringSize(string) : 0;
            if (!length2 || strLength >= length2) {
              return string;
            }
            var mid = (length2 - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length2, chars) {
            string = toString2(string);
            length2 = toInteger(length2);
            var strLength = length2 ? stringSize(string) : 0;
            return length2 && strLength < length2 ? string + createPadding(length2 - strLength, chars) : string;
          }
          function padStart(string, length2, chars) {
            string = toString2(string);
            length2 = toInteger(length2);
            var strLength = length2 ? stringSize(string) : 0;
            return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString2(string).replace(reTrimStart2, ""), radix || 0);
          }
          function repeat(string, n3, guard) {
            if (guard ? isIterateeCall(string, n3, guard) : n3 === undefined2) {
              n3 = 1;
            } else {
              n3 = toInteger(n3);
            }
            return baseRepeat(toString2(string), n3);
          }
          function replace() {
            var args = arguments, string = toString2(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString2(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString2(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString2(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString2(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options2, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options2, guard)) {
              options2 = undefined2;
            }
            string = toString2(string);
            options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty10.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty10.call(options2, "variable") && options2.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString2(value).toLowerCase();
          }
          function toUpper(value) {
            return toString2(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim2(string);
            }
            if (!string || !(chars = baseToString2(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start2, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex2(string) + 1);
            }
            if (!string || !(chars = baseToString2(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart2, "");
            }
            if (!string || !(chars = baseToString2(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start2).join("");
          }
          function truncate(string, options2) {
            var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject3(options2)) {
              var separator = "separator" in options2 ? options2.separator : separator;
              length2 = "length" in options2 ? toInteger(options2.length) : length2;
              omission = "omission" in options2 ? baseToString2(options2.omission) : omission;
            }
            string = toString2(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length2 >= strLength) {
              return string;
            }
            var end = length2 - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString2(separator), end) != end) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape3(string) {
            string = toString2(string);
            return string && reHasEscapedHtml2.test(string) ? string.replace(reEscapedHtml2, unescapeHtmlChar2) : string;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString2(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e3) {
              return isError(e3) ? e3 : new Error2(e3);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs2) {
            var length2 = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
            pairs2 = !length2 ? [] : arrayMap2(pairs2, function(pair3) {
              if (typeof pair3[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT3);
              }
              return [toIteratee(pair3[0]), pair3[1]];
            });
            return baseRest(function(args) {
              var index = -1;
              while (++index < length2) {
                var pair3 = pairs2[index];
                if (apply(pair3[0], this, args)) {
                  return apply(pair3[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity4(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options2) {
            var props = keys2(source), methodNames = baseFunctions(source, props);
            if (options2 == null && !(isObject3(source) && (methodNames.length || !props.length))) {
              options2 = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys2(source));
            }
            var chain2 = !(isObject3(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction2(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush2([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root3._ === this) {
              root3._ = oldDash;
            }
            return this;
          }
          function noop3() {
          }
          function nthArg(n3) {
            n3 = toInteger(n3);
            return baseRest(function(args) {
              return baseNth(args, n3);
            });
          }
          var over = createOver(arrayMap2);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome2);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range3 = createRange();
          var rangeRight = createRange(true);
          function stubArray2() {
            return [];
          }
          function stubFalse2() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n3, iteratee2) {
            n3 = toInteger(n3);
            if (n3 < 1 || n3 > MAX_SAFE_INTEGER4) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length2 = nativeMin2(n3, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n3 -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes2(length2, iteratee2);
            while (++index < n3) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray2(value)) {
              return arrayMap2(value, toKey);
            }
            return isSymbol2(value) ? [value] : copyArray(stringToPath(toString2(value)));
          }
          function uniqueId(prefix) {
            var id2 = ++idCounter;
            return toString2(prefix) + id2;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max3(array2) {
            return array2 && array2.length ? baseExtremum(array2, identity4, baseGt) : undefined2;
          }
          function maxBy(array2, iteratee2) {
            return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array2) {
            return baseMean(array2, identity4);
          }
          function meanBy(array2, iteratee2) {
            return baseMean(array2, getIteratee(iteratee2, 2));
          }
          function min3(array2) {
            return array2 && array2.length ? baseExtremum(array2, identity4, baseLt) : undefined2;
          }
          function minBy(array2, iteratee2) {
            return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array2) {
            return array2 && array2.length ? baseSum(array2, identity4) : 0;
          }
          function sumBy(array2, iteratee2) {
            return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at2;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey2;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create2;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce2;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference2;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter2;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten2;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection2;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys2;
          lodash.keysIn = keysIn;
          lodash.map = map2;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge2;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range3;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove2;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set4;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle2;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform2;
          lodash.unary = unary;
          lodash.union = union2;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap2;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp3;
          lodash.clone = clone2;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq2;
          lodash.escape = escape6;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find2;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get4;
          lodash.gt = gt2;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity4;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments2;
          lodash.isArray = isArray2;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike2;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer2;
          lodash.isDate = isDate;
          lodash.isElement = isElement2;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual4;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction2;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength2;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber3;
          lodash.isObject = isObject3;
          lodash.isObjectLike = isObjectLike2;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol2;
          lodash.isTypedArray = isTypedArray2;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt2;
          lodash.lte = lte;
          lodash.max = max3;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min3;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray2;
          lodash.stubFalse = stubFalse2;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop3;
          lodash.now = now3;
          lodash.pad = pad2;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber3;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString2;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape3;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty10.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n3) {
              n3 = n3 === undefined2 ? 1 : nativeMax2(toInteger(n3), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin2(n3, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin2(n3, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n3) {
              return this.reverse()[methodName](n3).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type2
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity4);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start2, end) {
            start2 = toInteger(start2);
            var result2 = this;
            if (result2.__filtered__ && (start2 > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start2 < 0) {
              result2 = result2.takeRight(-start2);
            } else if (start2) {
              result2 = result2.drop(start2);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush2([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray2(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray2(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty10.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _2 = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root3._ = _2;
          define(function() {
            return _2;
          });
        } else if (freeModule3) {
          (freeModule3.exports = _2)._ = _2;
          freeExports3._ = _2;
        } else {
          root3._ = _2;
        }
      }).call(exports2);
    }
  });

  // node_modules/fast-deep-equal/index.js
  var require_fast_deep_equal = __commonJS({
    "node_modules/fast-deep-equal/index.js"(exports2, module2) {
      "use strict";
      module2.exports = function equal(a2, b2) {
        if (a2 === b2)
          return true;
        if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
          if (a2.constructor !== b2.constructor)
            return false;
          var length2, i3, keys2;
          if (Array.isArray(a2)) {
            length2 = a2.length;
            if (length2 != b2.length)
              return false;
            for (i3 = length2; i3-- !== 0; )
              if (!equal(a2[i3], b2[i3]))
                return false;
            return true;
          }
          if (a2.constructor === RegExp)
            return a2.source === b2.source && a2.flags === b2.flags;
          if (a2.valueOf !== Object.prototype.valueOf)
            return a2.valueOf() === b2.valueOf();
          if (a2.toString !== Object.prototype.toString)
            return a2.toString() === b2.toString();
          keys2 = Object.keys(a2);
          length2 = keys2.length;
          if (length2 !== Object.keys(b2).length)
            return false;
          for (i3 = length2; i3-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b2, keys2[i3]))
              return false;
          for (i3 = length2; i3-- !== 0; ) {
            var key = keys2[i3];
            if (!equal(a2[key], b2[key]))
              return false;
          }
          return true;
        }
        return a2 !== a2 && b2 !== b2;
      };
    }
  });

  // node_modules/rbush/rbush.min.js
  var require_rbush_min = __commonJS({
    "node_modules/rbush/rbush.min.js"(exports2, module2) {
      !function(t2, i3) {
        "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = i3() : "function" == typeof define && define.amd ? define(i3) : (t2 = t2 || self).RBush = i3();
      }(exports2, function() {
        "use strict";
        function t2(t3, r3, e4, a3, h3) {
          !function t4(n4, r4, e6, a4, h4) {
            for (; a4 > e6; ) {
              if (a4 - e6 > 600) {
                var o3 = a4 - e6 + 1, s3 = r4 - e6 + 1, l3 = Math.log(o3), f3 = 0.5 * Math.exp(2 * l3 / 3), u3 = 0.5 * Math.sqrt(l3 * f3 * (o3 - f3) / o3) * (s3 - o3 / 2 < 0 ? -1 : 1), m3 = Math.max(e6, Math.floor(r4 - s3 * f3 / o3 + u3)), c3 = Math.min(a4, Math.floor(r4 + (o3 - s3) * f3 / o3 + u3));
                t4(n4, r4, m3, c3, h4);
              }
              var p3 = n4[r4], d4 = e6, x2 = a4;
              for (i3(n4, e6, r4), h4(n4[a4], p3) > 0 && i3(n4, e6, a4); d4 < x2; ) {
                for (i3(n4, d4, x2), d4++, x2--; h4(n4[d4], p3) < 0; )
                  d4++;
                for (; h4(n4[x2], p3) > 0; )
                  x2--;
              }
              0 === h4(n4[e6], p3) ? i3(n4, e6, x2) : i3(n4, ++x2, a4), x2 <= r4 && (e6 = x2 + 1), r4 <= x2 && (a4 = x2 - 1);
            }
          }(t3, r3, e4 || 0, a3 || t3.length - 1, h3 || n3);
        }
        function i3(t3, i4, n4) {
          var r3 = t3[i4];
          t3[i4] = t3[n4], t3[n4] = r3;
        }
        function n3(t3, i4) {
          return t3 < i4 ? -1 : t3 > i4 ? 1 : 0;
        }
        var r2 = function(t3) {
          void 0 === t3 && (t3 = 9), this._maxEntries = Math.max(4, t3), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
        };
        function e3(t3, i4, n4) {
          if (!n4)
            return i4.indexOf(t3);
          for (var r3 = 0; r3 < i4.length; r3++)
            if (n4(t3, i4[r3]))
              return r3;
          return -1;
        }
        function a2(t3, i4) {
          h2(t3, 0, t3.children.length, i4, t3);
        }
        function h2(t3, i4, n4, r3, e4) {
          e4 || (e4 = p2(null)), e4.minX = 1 / 0, e4.minY = 1 / 0, e4.maxX = -1 / 0, e4.maxY = -1 / 0;
          for (var a3 = i4; a3 < n4; a3++) {
            var h3 = t3.children[a3];
            o2(e4, t3.leaf ? r3(h3) : h3);
          }
          return e4;
        }
        function o2(t3, i4) {
          return t3.minX = Math.min(t3.minX, i4.minX), t3.minY = Math.min(t3.minY, i4.minY), t3.maxX = Math.max(t3.maxX, i4.maxX), t3.maxY = Math.max(t3.maxY, i4.maxY), t3;
        }
        function s2(t3, i4) {
          return t3.minX - i4.minX;
        }
        function l2(t3, i4) {
          return t3.minY - i4.minY;
        }
        function f2(t3) {
          return (t3.maxX - t3.minX) * (t3.maxY - t3.minY);
        }
        function u2(t3) {
          return t3.maxX - t3.minX + (t3.maxY - t3.minY);
        }
        function m2(t3, i4) {
          return t3.minX <= i4.minX && t3.minY <= i4.minY && i4.maxX <= t3.maxX && i4.maxY <= t3.maxY;
        }
        function c2(t3, i4) {
          return i4.minX <= t3.maxX && i4.minY <= t3.maxY && i4.maxX >= t3.minX && i4.maxY >= t3.minY;
        }
        function p2(t3) {
          return { children: t3, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        }
        function d2(i4, n4, r3, e4, a3) {
          for (var h3 = [n4, r3]; h3.length; )
            if (!((r3 = h3.pop()) - (n4 = h3.pop()) <= e4)) {
              var o3 = n4 + Math.ceil((r3 - n4) / e4 / 2) * e4;
              t2(i4, o3, n4, r3, a3), h3.push(n4, o3, o3, r3);
            }
        }
        return r2.prototype.all = function() {
          return this._all(this.data, []);
        }, r2.prototype.search = function(t3) {
          var i4 = this.data, n4 = [];
          if (!c2(t3, i4))
            return n4;
          for (var r3 = this.toBBox, e4 = []; i4; ) {
            for (var a3 = 0; a3 < i4.children.length; a3++) {
              var h3 = i4.children[a3], o3 = i4.leaf ? r3(h3) : h3;
              c2(t3, o3) && (i4.leaf ? n4.push(h3) : m2(t3, o3) ? this._all(h3, n4) : e4.push(h3));
            }
            i4 = e4.pop();
          }
          return n4;
        }, r2.prototype.collides = function(t3) {
          var i4 = this.data;
          if (!c2(t3, i4))
            return false;
          for (var n4 = []; i4; ) {
            for (var r3 = 0; r3 < i4.children.length; r3++) {
              var e4 = i4.children[r3], a3 = i4.leaf ? this.toBBox(e4) : e4;
              if (c2(t3, a3)) {
                if (i4.leaf || m2(t3, a3))
                  return true;
                n4.push(e4);
              }
            }
            i4 = n4.pop();
          }
          return false;
        }, r2.prototype.load = function(t3) {
          if (!t3 || !t3.length)
            return this;
          if (t3.length < this._minEntries) {
            for (var i4 = 0; i4 < t3.length; i4++)
              this.insert(t3[i4]);
            return this;
          }
          var n4 = this._build(t3.slice(), 0, t3.length - 1, 0);
          if (this.data.children.length)
            if (this.data.height === n4.height)
              this._splitRoot(this.data, n4);
            else {
              if (this.data.height < n4.height) {
                var r3 = this.data;
                this.data = n4, n4 = r3;
              }
              this._insert(n4, this.data.height - n4.height - 1, true);
            }
          else
            this.data = n4;
          return this;
        }, r2.prototype.insert = function(t3) {
          return t3 && this._insert(t3, this.data.height - 1), this;
        }, r2.prototype.clear = function() {
          return this.data = p2([]), this;
        }, r2.prototype.remove = function(t3, i4) {
          if (!t3)
            return this;
          for (var n4, r3, a3, h3 = this.data, o3 = this.toBBox(t3), s3 = [], l3 = []; h3 || s3.length; ) {
            if (h3 || (h3 = s3.pop(), r3 = s3[s3.length - 1], n4 = l3.pop(), a3 = true), h3.leaf) {
              var f3 = e3(t3, h3.children, i4);
              if (-1 !== f3)
                return h3.children.splice(f3, 1), s3.push(h3), this._condense(s3), this;
            }
            a3 || h3.leaf || !m2(h3, o3) ? r3 ? (n4++, h3 = r3.children[n4], a3 = false) : h3 = null : (s3.push(h3), l3.push(n4), n4 = 0, r3 = h3, h3 = h3.children[0]);
          }
          return this;
        }, r2.prototype.toBBox = function(t3) {
          return t3;
        }, r2.prototype.compareMinX = function(t3, i4) {
          return t3.minX - i4.minX;
        }, r2.prototype.compareMinY = function(t3, i4) {
          return t3.minY - i4.minY;
        }, r2.prototype.toJSON = function() {
          return this.data;
        }, r2.prototype.fromJSON = function(t3) {
          return this.data = t3, this;
        }, r2.prototype._all = function(t3, i4) {
          for (var n4 = []; t3; )
            t3.leaf ? i4.push.apply(i4, t3.children) : n4.push.apply(n4, t3.children), t3 = n4.pop();
          return i4;
        }, r2.prototype._build = function(t3, i4, n4, r3) {
          var e4, h3 = n4 - i4 + 1, o3 = this._maxEntries;
          if (h3 <= o3)
            return a2(e4 = p2(t3.slice(i4, n4 + 1)), this.toBBox), e4;
          r3 || (r3 = Math.ceil(Math.log(h3) / Math.log(o3)), o3 = Math.ceil(h3 / Math.pow(o3, r3 - 1))), (e4 = p2([])).leaf = false, e4.height = r3;
          var s3 = Math.ceil(h3 / o3), l3 = s3 * Math.ceil(Math.sqrt(o3));
          d2(t3, i4, n4, l3, this.compareMinX);
          for (var f3 = i4; f3 <= n4; f3 += l3) {
            var u3 = Math.min(f3 + l3 - 1, n4);
            d2(t3, f3, u3, s3, this.compareMinY);
            for (var m3 = f3; m3 <= u3; m3 += s3) {
              var c3 = Math.min(m3 + s3 - 1, u3);
              e4.children.push(this._build(t3, m3, c3, r3 - 1));
            }
          }
          return a2(e4, this.toBBox), e4;
        }, r2.prototype._chooseSubtree = function(t3, i4, n4, r3) {
          for (; r3.push(i4), !i4.leaf && r3.length - 1 !== n4; ) {
            for (var e4 = 1 / 0, a3 = 1 / 0, h3 = void 0, o3 = 0; o3 < i4.children.length; o3++) {
              var s3 = i4.children[o3], l3 = f2(s3), u3 = (m3 = t3, c3 = s3, (Math.max(c3.maxX, m3.maxX) - Math.min(c3.minX, m3.minX)) * (Math.max(c3.maxY, m3.maxY) - Math.min(c3.minY, m3.minY)) - l3);
              u3 < a3 ? (a3 = u3, e4 = l3 < e4 ? l3 : e4, h3 = s3) : u3 === a3 && l3 < e4 && (e4 = l3, h3 = s3);
            }
            i4 = h3 || i4.children[0];
          }
          var m3, c3;
          return i4;
        }, r2.prototype._insert = function(t3, i4, n4) {
          var r3 = n4 ? t3 : this.toBBox(t3), e4 = [], a3 = this._chooseSubtree(r3, this.data, i4, e4);
          for (a3.children.push(t3), o2(a3, r3); i4 >= 0 && e4[i4].children.length > this._maxEntries; )
            this._split(e4, i4), i4--;
          this._adjustParentBBoxes(r3, e4, i4);
        }, r2.prototype._split = function(t3, i4) {
          var n4 = t3[i4], r3 = n4.children.length, e4 = this._minEntries;
          this._chooseSplitAxis(n4, e4, r3);
          var h3 = this._chooseSplitIndex(n4, e4, r3), o3 = p2(n4.children.splice(h3, n4.children.length - h3));
          o3.height = n4.height, o3.leaf = n4.leaf, a2(n4, this.toBBox), a2(o3, this.toBBox), i4 ? t3[i4 - 1].children.push(o3) : this._splitRoot(n4, o3);
        }, r2.prototype._splitRoot = function(t3, i4) {
          this.data = p2([t3, i4]), this.data.height = t3.height + 1, this.data.leaf = false, a2(this.data, this.toBBox);
        }, r2.prototype._chooseSplitIndex = function(t3, i4, n4) {
          for (var r3, e4, a3, o3, s3, l3, u3, m3 = 1 / 0, c3 = 1 / 0, p3 = i4; p3 <= n4 - i4; p3++) {
            var d4 = h2(t3, 0, p3, this.toBBox), x2 = h2(t3, p3, n4, this.toBBox), v2 = (e4 = d4, a3 = x2, o3 = void 0, s3 = void 0, l3 = void 0, u3 = void 0, o3 = Math.max(e4.minX, a3.minX), s3 = Math.max(e4.minY, a3.minY), l3 = Math.min(e4.maxX, a3.maxX), u3 = Math.min(e4.maxY, a3.maxY), Math.max(0, l3 - o3) * Math.max(0, u3 - s3)), M2 = f2(d4) + f2(x2);
            v2 < m3 ? (m3 = v2, r3 = p3, c3 = M2 < c3 ? M2 : c3) : v2 === m3 && M2 < c3 && (c3 = M2, r3 = p3);
          }
          return r3 || n4 - i4;
        }, r2.prototype._chooseSplitAxis = function(t3, i4, n4) {
          var r3 = t3.leaf ? this.compareMinX : s2, e4 = t3.leaf ? this.compareMinY : l2;
          this._allDistMargin(t3, i4, n4, r3) < this._allDistMargin(t3, i4, n4, e4) && t3.children.sort(r3);
        }, r2.prototype._allDistMargin = function(t3, i4, n4, r3) {
          t3.children.sort(r3);
          for (var e4 = this.toBBox, a3 = h2(t3, 0, i4, e4), s3 = h2(t3, n4 - i4, n4, e4), l3 = u2(a3) + u2(s3), f3 = i4; f3 < n4 - i4; f3++) {
            var m3 = t3.children[f3];
            o2(a3, t3.leaf ? e4(m3) : m3), l3 += u2(a3);
          }
          for (var c3 = n4 - i4 - 1; c3 >= i4; c3--) {
            var p3 = t3.children[c3];
            o2(s3, t3.leaf ? e4(p3) : p3), l3 += u2(s3);
          }
          return l3;
        }, r2.prototype._adjustParentBBoxes = function(t3, i4, n4) {
          for (var r3 = n4; r3 >= 0; r3--)
            o2(i4[r3], t3);
        }, r2.prototype._condense = function(t3) {
          for (var i4 = t3.length - 1, n4 = void 0; i4 >= 0; i4--)
            0 === t3[i4].children.length ? i4 > 0 ? (n4 = t3[i4 - 1].children).splice(n4.indexOf(t3[i4]), 1) : this.clear() : a2(t3[i4], this.toBBox);
        }, r2;
      });
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports2) {
      exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e3, m2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i3 = isLE ? nBytes - 1 : 0;
        var d2 = isLE ? -1 : 1;
        var s2 = buffer[offset + i3];
        i3 += d2;
        e3 = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e3 = e3 * 256 + buffer[offset + i3], i3 += d2, nBits -= 8) {
        }
        m2 = e3 & (1 << -nBits) - 1;
        e3 >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i3], i3 += d2, nBits -= 8) {
        }
        if (e3 === 0) {
          e3 = 1 - eBias;
        } else if (e3 === eMax) {
          return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m2 = m2 + Math.pow(2, mLen);
          e3 = e3 - eBias;
        }
        return (s2 ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
      };
      exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e3, m2, c2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i3 = isLE ? 0 : nBytes - 1;
        var d2 = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m2 = isNaN(value) ? 1 : 0;
          e3 = eMax;
        } else {
          e3 = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c2 = Math.pow(2, -e3)) < 1) {
            e3--;
            c2 *= 2;
          }
          if (e3 + eBias >= 1) {
            value += rt / c2;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c2 >= 2) {
            e3++;
            c2 /= 2;
          }
          if (e3 + eBias >= eMax) {
            m2 = 0;
            e3 = eMax;
          } else if (e3 + eBias >= 1) {
            m2 = (value * c2 - 1) * Math.pow(2, mLen);
            e3 = e3 + eBias;
          } else {
            m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e3 = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i3] = m2 & 255, i3 += d2, m2 /= 256, mLen -= 8) {
        }
        e3 = e3 << mLen | m2;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i3] = e3 & 255, i3 += d2, e3 /= 256, eLen -= 8) {
        }
        buffer[offset + i3 - d2] |= s2 * 128;
      };
    }
  });

  // node_modules/pbf/index.js
  var require_pbf = __commonJS({
    "node_modules/pbf/index.js"(exports2, module2) {
      "use strict";
      module2.exports = Pbf;
      var ieee754 = require_ieee754();
      function Pbf(buf) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
        this.pos = 0;
        this.type = 0;
        this.length = this.buf.length;
      }
      Pbf.Varint = 0;
      Pbf.Fixed64 = 1;
      Pbf.Bytes = 2;
      Pbf.Fixed32 = 5;
      var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
      var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
      var TEXT_DECODER_MIN_LENGTH = 12;
      var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
      Pbf.prototype = {
        destroy: function() {
          this.buf = null;
        },
        // === READING =================================================================
        readFields: function(readField, result, end) {
          end = end || this.length;
          while (this.pos < end) {
            var val = this.readVarint(), tag2 = val >> 3, startPos = this.pos;
            this.type = val & 7;
            readField(tag2, result, this);
            if (this.pos === startPos)
              this.skip(val);
          }
          return result;
        },
        readMessage: function(readField, result) {
          return this.readFields(readField, result, this.readVarint() + this.pos);
        },
        readFixed32: function() {
          var val = readUInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
        },
        readSFixed32: function() {
          var val = readInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
        },
        // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
        readFixed64: function() {
          var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
        },
        readSFixed64: function() {
          var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
        },
        readFloat: function() {
          var val = ieee754.read(this.buf, this.pos, true, 23, 4);
          this.pos += 4;
          return val;
        },
        readDouble: function() {
          var val = ieee754.read(this.buf, this.pos, true, 52, 8);
          this.pos += 8;
          return val;
        },
        readVarint: function(isSigned) {
          var buf = this.buf, val, b2;
          b2 = buf[this.pos++];
          val = b2 & 127;
          if (b2 < 128)
            return val;
          b2 = buf[this.pos++];
          val |= (b2 & 127) << 7;
          if (b2 < 128)
            return val;
          b2 = buf[this.pos++];
          val |= (b2 & 127) << 14;
          if (b2 < 128)
            return val;
          b2 = buf[this.pos++];
          val |= (b2 & 127) << 21;
          if (b2 < 128)
            return val;
          b2 = buf[this.pos];
          val |= (b2 & 15) << 28;
          return readVarintRemainder(val, isSigned, this);
        },
        readVarint64: function() {
          return this.readVarint(true);
        },
        readSVarint: function() {
          var num = this.readVarint();
          return num % 2 === 1 ? (num + 1) / -2 : num / 2;
        },
        readBoolean: function() {
          return Boolean(this.readVarint());
        },
        readString: function() {
          var end = this.readVarint() + this.pos;
          var pos = this.pos;
          this.pos = end;
          if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            return readUtf8TextDecoder(this.buf, pos, end);
          }
          return readUtf8(this.buf, pos, end);
        },
        readBytes: function() {
          var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
          this.pos = end;
          return buffer;
        },
        // verbose for performance reasons; doesn't affect gzipped size
        readPackedVarint: function(arr, isSigned) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readVarint(isSigned));
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readVarint(isSigned));
          return arr;
        },
        readPackedSVarint: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSVarint());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSVarint());
          return arr;
        },
        readPackedBoolean: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readBoolean());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readBoolean());
          return arr;
        },
        readPackedFloat: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFloat());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFloat());
          return arr;
        },
        readPackedDouble: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readDouble());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readDouble());
          return arr;
        },
        readPackedFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed32());
          return arr;
        },
        readPackedSFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed32());
          return arr;
        },
        readPackedFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed64());
          return arr;
        },
        readPackedSFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed64());
          return arr;
        },
        skip: function(val) {
          var type2 = val & 7;
          if (type2 === Pbf.Varint)
            while (this.buf[this.pos++] > 127) {
            }
          else if (type2 === Pbf.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (type2 === Pbf.Fixed32)
            this.pos += 4;
          else if (type2 === Pbf.Fixed64)
            this.pos += 8;
          else
            throw new Error("Unimplemented type: " + type2);
        },
        // === WRITING =================================================================
        writeTag: function(tag2, type2) {
          this.writeVarint(tag2 << 3 | type2);
        },
        realloc: function(min3) {
          var length2 = this.length || 16;
          while (length2 < this.pos + min3)
            length2 *= 2;
          if (length2 !== this.length) {
            var buf = new Uint8Array(length2);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length2;
          }
        },
        finish: function() {
          this.length = this.pos;
          this.pos = 0;
          return this.buf.subarray(0, this.length);
        },
        writeFixed32: function(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
        },
        writeSFixed32: function(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
        },
        writeFixed64: function(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeSFixed64: function(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeVarint: function(val) {
          val = +val || 0;
          if (val > 268435455 || val < 0) {
            writeBigVarint(val, this);
            return;
          }
          this.realloc(4);
          this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = val >>> 7 & 127;
        },
        writeSVarint: function(val) {
          this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
        },
        writeBoolean: function(val) {
          this.writeVarint(Boolean(val));
        },
        writeString: function(str) {
          str = String(str);
          this.realloc(str.length * 4);
          this.pos++;
          var startPos = this.pos;
          this.pos = writeUtf8(this.buf, str, this.pos);
          var len = this.pos - startPos;
          if (len >= 128)
            makeRoomForExtraLength(startPos, len, this);
          this.pos = startPos - 1;
          this.writeVarint(len);
          this.pos += len;
        },
        writeFloat: function(val) {
          this.realloc(4);
          ieee754.write(this.buf, val, this.pos, true, 23, 4);
          this.pos += 4;
        },
        writeDouble: function(val) {
          this.realloc(8);
          ieee754.write(this.buf, val, this.pos, true, 52, 8);
          this.pos += 8;
        },
        writeBytes: function(buffer) {
          var len = buffer.length;
          this.writeVarint(len);
          this.realloc(len);
          for (var i3 = 0; i3 < len; i3++)
            this.buf[this.pos++] = buffer[i3];
        },
        writeRawMessage: function(fn, obj) {
          this.pos++;
          var startPos = this.pos;
          fn(obj, this);
          var len = this.pos - startPos;
          if (len >= 128)
            makeRoomForExtraLength(startPos, len, this);
          this.pos = startPos - 1;
          this.writeVarint(len);
          this.pos += len;
        },
        writeMessage: function(tag2, fn, obj) {
          this.writeTag(tag2, Pbf.Bytes);
          this.writeRawMessage(fn, obj);
        },
        writePackedVarint: function(tag2, arr) {
          if (arr.length)
            this.writeMessage(tag2, writePackedVarint, arr);
        },
        writePackedSVarint: function(tag2, arr) {
          if (arr.length)
            this.writeMessage(tag2, writePackedSVarint, arr);
        },
        writePackedBoolean: function(tag2, arr) {
          if (arr.length)
            this.writeMessage(tag2, writePackedBoolean, arr);
        },
        writePackedFloat: function(tag2, arr) {
          if (arr.length)
            this.writeMessage(tag2, writePackedFloat, arr);
        },
        writePackedDouble: function(tag2, arr) {
          if (arr.length)
            this.writeMessage(tag2, writePackedDouble, arr);
        },
        writePackedFixed32: function(tag2, arr) {
          if (arr.length)
            this.writeMessage(tag2, writePackedFixed32, arr);
        },
        writePackedSFixed32: function(tag2, arr) {
          if (arr.length)
            this.writeMessage(tag2, writePackedSFixed32, arr);
        },
        writePackedFixed64: function(tag2, arr) {
          if (arr.length)
            this.writeMessage(tag2, writePackedFixed64, arr);
        },
        writePackedSFixed64: function(tag2, arr) {
          if (arr.length)
            this.writeMessage(tag2, writePackedSFixed64, arr);
        },
        writeBytesField: function(tag2, buffer) {
          this.writeTag(tag2, Pbf.Bytes);
          this.writeBytes(buffer);
        },
        writeFixed32Field: function(tag2, val) {
          this.writeTag(tag2, Pbf.Fixed32);
          this.writeFixed32(val);
        },
        writeSFixed32Field: function(tag2, val) {
          this.writeTag(tag2, Pbf.Fixed32);
          this.writeSFixed32(val);
        },
        writeFixed64Field: function(tag2, val) {
          this.writeTag(tag2, Pbf.Fixed64);
          this.writeFixed64(val);
        },
        writeSFixed64Field: function(tag2, val) {
          this.writeTag(tag2, Pbf.Fixed64);
          this.writeSFixed64(val);
        },
        writeVarintField: function(tag2, val) {
          this.writeTag(tag2, Pbf.Varint);
          this.writeVarint(val);
        },
        writeSVarintField: function(tag2, val) {
          this.writeTag(tag2, Pbf.Varint);
          this.writeSVarint(val);
        },
        writeStringField: function(tag2, str) {
          this.writeTag(tag2, Pbf.Bytes);
          this.writeString(str);
        },
        writeFloatField: function(tag2, val) {
          this.writeTag(tag2, Pbf.Fixed32);
          this.writeFloat(val);
        },
        writeDoubleField: function(tag2, val) {
          this.writeTag(tag2, Pbf.Fixed64);
          this.writeDouble(val);
        },
        writeBooleanField: function(tag2, val) {
          this.writeVarintField(tag2, Boolean(val));
        }
      };
      function readVarintRemainder(l2, s2, p2) {
        var buf = p2.buf, h2, b2;
        b2 = buf[p2.pos++];
        h2 = (b2 & 112) >> 4;
        if (b2 < 128)
          return toNum(l2, h2, s2);
        b2 = buf[p2.pos++];
        h2 |= (b2 & 127) << 3;
        if (b2 < 128)
          return toNum(l2, h2, s2);
        b2 = buf[p2.pos++];
        h2 |= (b2 & 127) << 10;
        if (b2 < 128)
          return toNum(l2, h2, s2);
        b2 = buf[p2.pos++];
        h2 |= (b2 & 127) << 17;
        if (b2 < 128)
          return toNum(l2, h2, s2);
        b2 = buf[p2.pos++];
        h2 |= (b2 & 127) << 24;
        if (b2 < 128)
          return toNum(l2, h2, s2);
        b2 = buf[p2.pos++];
        h2 |= (b2 & 1) << 31;
        if (b2 < 128)
          return toNum(l2, h2, s2);
        throw new Error("Expected varint not more than 10 bytes");
      }
      function readPackedEnd(pbf) {
        return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
      }
      function toNum(low, high, isSigned) {
        if (isSigned) {
          return high * 4294967296 + (low >>> 0);
        }
        return (high >>> 0) * 4294967296 + (low >>> 0);
      }
      function writeBigVarint(val, pbf) {
        var low, high;
        if (val >= 0) {
          low = val % 4294967296 | 0;
          high = val / 4294967296 | 0;
        } else {
          low = ~(-val % 4294967296);
          high = ~(-val / 4294967296);
          if (low ^ 4294967295) {
            low = low + 1 | 0;
          } else {
            low = 0;
            high = high + 1 | 0;
          }
        }
        if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
          throw new Error("Given varint doesn't fit into 10 bytes");
        }
        pbf.realloc(10);
        writeBigVarintLow(low, high, pbf);
        writeBigVarintHigh(high, pbf);
      }
      function writeBigVarintLow(low, high, pbf) {
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos] = low & 127;
      }
      function writeBigVarintHigh(high, pbf) {
        var lsb = (high & 7) << 4;
        pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127;
      }
      function makeRoomForExtraLength(startPos, len, pbf) {
        var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
        pbf.realloc(extraLen);
        for (var i3 = pbf.pos - 1; i3 >= startPos; i3--)
          pbf.buf[i3 + extraLen] = pbf.buf[i3];
      }
      function writePackedVarint(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeVarint(arr[i3]);
      }
      function writePackedSVarint(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeSVarint(arr[i3]);
      }
      function writePackedFloat(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeFloat(arr[i3]);
      }
      function writePackedDouble(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeDouble(arr[i3]);
      }
      function writePackedBoolean(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeBoolean(arr[i3]);
      }
      function writePackedFixed32(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeFixed32(arr[i3]);
      }
      function writePackedSFixed32(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeSFixed32(arr[i3]);
      }
      function writePackedFixed64(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeFixed64(arr[i3]);
      }
      function writePackedSFixed64(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeSFixed64(arr[i3]);
      }
      function readUInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
      }
      function writeInt32(buf, val, pos) {
        buf[pos] = val;
        buf[pos + 1] = val >>> 8;
        buf[pos + 2] = val >>> 16;
        buf[pos + 3] = val >>> 24;
      }
      function readInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
      }
      function readUtf8(buf, pos, end) {
        var str = "";
        var i3 = pos;
        while (i3 < end) {
          var b0 = buf[i3];
          var c2 = null;
          var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
          if (i3 + bytesPerSequence > end)
            break;
          var b1, b2, b3;
          if (bytesPerSequence === 1) {
            if (b0 < 128) {
              c2 = b0;
            }
          } else if (bytesPerSequence === 2) {
            b1 = buf[i3 + 1];
            if ((b1 & 192) === 128) {
              c2 = (b0 & 31) << 6 | b1 & 63;
              if (c2 <= 127) {
                c2 = null;
              }
            }
          } else if (bytesPerSequence === 3) {
            b1 = buf[i3 + 1];
            b2 = buf[i3 + 2];
            if ((b1 & 192) === 128 && (b2 & 192) === 128) {
              c2 = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
              if (c2 <= 2047 || c2 >= 55296 && c2 <= 57343) {
                c2 = null;
              }
            }
          } else if (bytesPerSequence === 4) {
            b1 = buf[i3 + 1];
            b2 = buf[i3 + 2];
            b3 = buf[i3 + 3];
            if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
              c2 = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
              if (c2 <= 65535 || c2 >= 1114112) {
                c2 = null;
              }
            }
          }
          if (c2 === null) {
            c2 = 65533;
            bytesPerSequence = 1;
          } else if (c2 > 65535) {
            c2 -= 65536;
            str += String.fromCharCode(c2 >>> 10 & 1023 | 55296);
            c2 = 56320 | c2 & 1023;
          }
          str += String.fromCharCode(c2);
          i3 += bytesPerSequence;
        }
        return str;
      }
      function readUtf8TextDecoder(buf, pos, end) {
        return utf8TextDecoder.decode(buf.subarray(pos, end));
      }
      function writeUtf8(buf, str, pos) {
        for (var i3 = 0, c2, lead; i3 < str.length; i3++) {
          c2 = str.charCodeAt(i3);
          if (c2 > 55295 && c2 < 57344) {
            if (lead) {
              if (c2 < 56320) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
                lead = c2;
                continue;
              } else {
                c2 = lead - 55296 << 10 | c2 - 56320 | 65536;
                lead = null;
              }
            } else {
              if (c2 > 56319 || i3 + 1 === str.length) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
              } else {
                lead = c2;
              }
              continue;
            }
          } else if (lead) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
            lead = null;
          }
          if (c2 < 128) {
            buf[pos++] = c2;
          } else {
            if (c2 < 2048) {
              buf[pos++] = c2 >> 6 | 192;
            } else {
              if (c2 < 65536) {
                buf[pos++] = c2 >> 12 | 224;
              } else {
                buf[pos++] = c2 >> 18 | 240;
                buf[pos++] = c2 >> 12 & 63 | 128;
              }
              buf[pos++] = c2 >> 6 & 63 | 128;
            }
            buf[pos++] = c2 & 63 | 128;
          }
        }
        return pos;
      }
    }
  });

  // node_modules/@mapbox/point-geometry/index.js
  var require_point_geometry = __commonJS({
    "node_modules/@mapbox/point-geometry/index.js"(exports2, module2) {
      "use strict";
      module2.exports = Point;
      function Point(x2, y2) {
        this.x = x2;
        this.y = y2;
      }
      Point.prototype = {
        /**
         * Clone this point, returning a new point that can be modified
         * without affecting the old one.
         * @return {Point} the clone
         */
        clone: function() {
          return new Point(this.x, this.y);
        },
        /**
         * Add this point's x & y coordinates to another point,
         * yielding a new point.
         * @param {Point} p the other point
         * @return {Point} output point
         */
        add: function(p2) {
          return this.clone()._add(p2);
        },
        /**
         * Subtract this point's x & y coordinates to from point,
         * yielding a new point.
         * @param {Point} p the other point
         * @return {Point} output point
         */
        sub: function(p2) {
          return this.clone()._sub(p2);
        },
        /**
         * Multiply this point's x & y coordinates by point,
         * yielding a new point.
         * @param {Point} p the other point
         * @return {Point} output point
         */
        multByPoint: function(p2) {
          return this.clone()._multByPoint(p2);
        },
        /**
         * Divide this point's x & y coordinates by point,
         * yielding a new point.
         * @param {Point} p the other point
         * @return {Point} output point
         */
        divByPoint: function(p2) {
          return this.clone()._divByPoint(p2);
        },
        /**
         * Multiply this point's x & y coordinates by a factor,
         * yielding a new point.
         * @param {Point} k factor
         * @return {Point} output point
         */
        mult: function(k2) {
          return this.clone()._mult(k2);
        },
        /**
         * Divide this point's x & y coordinates by a factor,
         * yielding a new point.
         * @param {Point} k factor
         * @return {Point} output point
         */
        div: function(k2) {
          return this.clone()._div(k2);
        },
        /**
         * Rotate this point around the 0, 0 origin by an angle a,
         * given in radians
         * @param {Number} a angle to rotate around, in radians
         * @return {Point} output point
         */
        rotate: function(a2) {
          return this.clone()._rotate(a2);
        },
        /**
         * Rotate this point around p point by an angle a,
         * given in radians
         * @param {Number} a angle to rotate around, in radians
         * @param {Point} p Point to rotate around
         * @return {Point} output point
         */
        rotateAround: function(a2, p2) {
          return this.clone()._rotateAround(a2, p2);
        },
        /**
         * Multiply this point by a 4x1 transformation matrix
         * @param {Array<Number>} m transformation matrix
         * @return {Point} output point
         */
        matMult: function(m2) {
          return this.clone()._matMult(m2);
        },
        /**
         * Calculate this point but as a unit vector from 0, 0, meaning
         * that the distance from the resulting point to the 0, 0
         * coordinate will be equal to 1 and the angle from the resulting
         * point to the 0, 0 coordinate will be the same as before.
         * @return {Point} unit vector point
         */
        unit: function() {
          return this.clone()._unit();
        },
        /**
         * Compute a perpendicular point, where the new y coordinate
         * is the old x coordinate and the new x coordinate is the old y
         * coordinate multiplied by -1
         * @return {Point} perpendicular point
         */
        perp: function() {
          return this.clone()._perp();
        },
        /**
         * Return a version of this point with the x & y coordinates
         * rounded to integers.
         * @return {Point} rounded point
         */
        round: function() {
          return this.clone()._round();
        },
        /**
         * Return the magitude of this point: this is the Euclidean
         * distance from the 0, 0 coordinate to this point's x and y
         * coordinates.
         * @return {Number} magnitude
         */
        mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        /**
         * Judge whether this point is equal to another point, returning
         * true or false.
         * @param {Point} other the other point
         * @return {boolean} whether the points are equal
         */
        equals: function(other) {
          return this.x === other.x && this.y === other.y;
        },
        /**
         * Calculate the distance from this point to another point
         * @param {Point} p the other point
         * @return {Number} distance
         */
        dist: function(p2) {
          return Math.sqrt(this.distSqr(p2));
        },
        /**
         * Calculate the distance from this point to another point,
         * without the square root step. Useful if you're comparing
         * relative distances.
         * @param {Point} p the other point
         * @return {Number} distance
         */
        distSqr: function(p2) {
          var dx = p2.x - this.x, dy = p2.y - this.y;
          return dx * dx + dy * dy;
        },
        /**
         * Get the angle from the 0, 0 coordinate to this point, in radians
         * coordinates.
         * @return {Number} angle
         */
        angle: function() {
          return Math.atan2(this.y, this.x);
        },
        /**
         * Get the angle from this point to another point, in radians
         * @param {Point} b the other point
         * @return {Number} angle
         */
        angleTo: function(b2) {
          return Math.atan2(this.y - b2.y, this.x - b2.x);
        },
        /**
         * Get the angle between this point and another point, in radians
         * @param {Point} b the other point
         * @return {Number} angle
         */
        angleWith: function(b2) {
          return this.angleWithSep(b2.x, b2.y);
        },
        /*
         * Find the angle of the two vectors, solving the formula for
         * the cross product a x b = |a||b|sin(θ) for θ.
         * @param {Number} x the x-coordinate
         * @param {Number} y the y-coordinate
         * @return {Number} the angle in radians
         */
        angleWithSep: function(x2, y2) {
          return Math.atan2(
            this.x * y2 - this.y * x2,
            this.x * x2 + this.y * y2
          );
        },
        _matMult: function(m2) {
          var x2 = m2[0] * this.x + m2[1] * this.y, y2 = m2[2] * this.x + m2[3] * this.y;
          this.x = x2;
          this.y = y2;
          return this;
        },
        _add: function(p2) {
          this.x += p2.x;
          this.y += p2.y;
          return this;
        },
        _sub: function(p2) {
          this.x -= p2.x;
          this.y -= p2.y;
          return this;
        },
        _mult: function(k2) {
          this.x *= k2;
          this.y *= k2;
          return this;
        },
        _div: function(k2) {
          this.x /= k2;
          this.y /= k2;
          return this;
        },
        _multByPoint: function(p2) {
          this.x *= p2.x;
          this.y *= p2.y;
          return this;
        },
        _divByPoint: function(p2) {
          this.x /= p2.x;
          this.y /= p2.y;
          return this;
        },
        _unit: function() {
          this._div(this.mag());
          return this;
        },
        _perp: function() {
          var y2 = this.y;
          this.y = this.x;
          this.x = -y2;
          return this;
        },
        _rotate: function(angle2) {
          var cos2 = Math.cos(angle2), sin2 = Math.sin(angle2), x2 = cos2 * this.x - sin2 * this.y, y2 = sin2 * this.x + cos2 * this.y;
          this.x = x2;
          this.y = y2;
          return this;
        },
        _rotateAround: function(angle2, p2) {
          var cos2 = Math.cos(angle2), sin2 = Math.sin(angle2), x2 = p2.x + cos2 * (this.x - p2.x) - sin2 * (this.y - p2.y), y2 = p2.y + sin2 * (this.x - p2.x) + cos2 * (this.y - p2.y);
          this.x = x2;
          this.y = y2;
          return this;
        },
        _round: function() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        }
      };
      Point.convert = function(a2) {
        if (a2 instanceof Point) {
          return a2;
        }
        if (Array.isArray(a2)) {
          return new Point(a2[0], a2[1]);
        }
        return a2;
      };
    }
  });

  // node_modules/@mapbox/vector-tile/lib/vectortilefeature.js
  var require_vectortilefeature = __commonJS({
    "node_modules/@mapbox/vector-tile/lib/vectortilefeature.js"(exports2, module2) {
      "use strict";
      var Point = require_point_geometry();
      module2.exports = VectorTileFeature;
      function VectorTileFeature(pbf, end, extent, keys2, values) {
        this.properties = {};
        this.extent = extent;
        this.type = 0;
        this._pbf = pbf;
        this._geometry = -1;
        this._keys = keys2;
        this._values = values;
        pbf.readFields(readFeature, this, end);
      }
      function readFeature(tag2, feature3, pbf) {
        if (tag2 == 1)
          feature3.id = pbf.readVarint();
        else if (tag2 == 2)
          readTag(pbf, feature3);
        else if (tag2 == 3)
          feature3.type = pbf.readVarint();
        else if (tag2 == 4)
          feature3._geometry = pbf.pos;
      }
      function readTag(pbf, feature3) {
        var end = pbf.readVarint() + pbf.pos;
        while (pbf.pos < end) {
          var key = feature3._keys[pbf.readVarint()], value = feature3._values[pbf.readVarint()];
          feature3.properties[key] = value;
        }
      }
      VectorTileFeature.types = ["Unknown", "Point", "LineString", "Polygon"];
      VectorTileFeature.prototype.loadGeometry = function() {
        var pbf = this._pbf;
        pbf.pos = this._geometry;
        var end = pbf.readVarint() + pbf.pos, cmd = 1, length2 = 0, x2 = 0, y2 = 0, lines = [], line;
        while (pbf.pos < end) {
          if (length2 <= 0) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 7;
            length2 = cmdLen >> 3;
          }
          length2--;
          if (cmd === 1 || cmd === 2) {
            x2 += pbf.readSVarint();
            y2 += pbf.readSVarint();
            if (cmd === 1) {
              if (line)
                lines.push(line);
              line = [];
            }
            line.push(new Point(x2, y2));
          } else if (cmd === 7) {
            if (line) {
              line.push(line[0].clone());
            }
          } else {
            throw new Error("unknown command " + cmd);
          }
        }
        if (line)
          lines.push(line);
        return lines;
      };
      VectorTileFeature.prototype.bbox = function() {
        var pbf = this._pbf;
        pbf.pos = this._geometry;
        var end = pbf.readVarint() + pbf.pos, cmd = 1, length2 = 0, x2 = 0, y2 = 0, x12 = Infinity, x22 = -Infinity, y12 = Infinity, y22 = -Infinity;
        while (pbf.pos < end) {
          if (length2 <= 0) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 7;
            length2 = cmdLen >> 3;
          }
          length2--;
          if (cmd === 1 || cmd === 2) {
            x2 += pbf.readSVarint();
            y2 += pbf.readSVarint();
            if (x2 < x12)
              x12 = x2;
            if (x2 > x22)
              x22 = x2;
            if (y2 < y12)
              y12 = y2;
            if (y2 > y22)
              y22 = y2;
          } else if (cmd !== 7) {
            throw new Error("unknown command " + cmd);
          }
        }
        return [x12, y12, x22, y22];
      };
      VectorTileFeature.prototype.toGeoJSON = function(x2, y2, z2) {
        var size = this.extent * Math.pow(2, z2), x05 = this.extent * x2, y05 = this.extent * y2, coords = this.loadGeometry(), type2 = VectorTileFeature.types[this.type], i3, j2;
        function project(line) {
          for (var j3 = 0; j3 < line.length; j3++) {
            var p2 = line[j3], y22 = 180 - (p2.y + y05) * 360 / size;
            line[j3] = [
              (p2.x + x05) * 360 / size - 180,
              360 / Math.PI * Math.atan(Math.exp(y22 * Math.PI / 180)) - 90
            ];
          }
        }
        switch (this.type) {
          case 1:
            var points = [];
            for (i3 = 0; i3 < coords.length; i3++) {
              points[i3] = coords[i3][0];
            }
            coords = points;
            project(coords);
            break;
          case 2:
            for (i3 = 0; i3 < coords.length; i3++) {
              project(coords[i3]);
            }
            break;
          case 3:
            coords = classifyRings(coords);
            for (i3 = 0; i3 < coords.length; i3++) {
              for (j2 = 0; j2 < coords[i3].length; j2++) {
                project(coords[i3][j2]);
              }
            }
            break;
        }
        if (coords.length === 1) {
          coords = coords[0];
        } else {
          type2 = "Multi" + type2;
        }
        var result = {
          type: "Feature",
          geometry: {
            type: type2,
            coordinates: coords
          },
          properties: this.properties
        };
        if ("id" in this) {
          result.id = this.id;
        }
        return result;
      };
      function classifyRings(rings) {
        var len = rings.length;
        if (len <= 1)
          return [rings];
        var polygons = [], polygon2, ccw;
        for (var i3 = 0; i3 < len; i3++) {
          var area = signedArea(rings[i3]);
          if (area === 0)
            continue;
          if (ccw === void 0)
            ccw = area < 0;
          if (ccw === area < 0) {
            if (polygon2)
              polygons.push(polygon2);
            polygon2 = [rings[i3]];
          } else {
            polygon2.push(rings[i3]);
          }
        }
        if (polygon2)
          polygons.push(polygon2);
        return polygons;
      }
      function signedArea(ring) {
        var sum = 0;
        for (var i3 = 0, len = ring.length, j2 = len - 1, p1, p2; i3 < len; j2 = i3++) {
          p1 = ring[i3];
          p2 = ring[j2];
          sum += (p2.x - p1.x) * (p1.y + p2.y);
        }
        return sum;
      }
    }
  });

  // node_modules/@mapbox/vector-tile/lib/vectortilelayer.js
  var require_vectortilelayer = __commonJS({
    "node_modules/@mapbox/vector-tile/lib/vectortilelayer.js"(exports2, module2) {
      "use strict";
      var VectorTileFeature = require_vectortilefeature();
      module2.exports = VectorTileLayer;
      function VectorTileLayer(pbf, end) {
        this.version = 1;
        this.name = null;
        this.extent = 4096;
        this.length = 0;
        this._pbf = pbf;
        this._keys = [];
        this._values = [];
        this._features = [];
        pbf.readFields(readLayer, this, end);
        this.length = this._features.length;
      }
      function readLayer(tag2, layer, pbf) {
        if (tag2 === 15)
          layer.version = pbf.readVarint();
        else if (tag2 === 1)
          layer.name = pbf.readString();
        else if (tag2 === 5)
          layer.extent = pbf.readVarint();
        else if (tag2 === 2)
          layer._features.push(pbf.pos);
        else if (tag2 === 3)
          layer._keys.push(pbf.readString());
        else if (tag2 === 4)
          layer._values.push(readValueMessage(pbf));
      }
      function readValueMessage(pbf) {
        var value = null, end = pbf.readVarint() + pbf.pos;
        while (pbf.pos < end) {
          var tag2 = pbf.readVarint() >> 3;
          value = tag2 === 1 ? pbf.readString() : tag2 === 2 ? pbf.readFloat() : tag2 === 3 ? pbf.readDouble() : tag2 === 4 ? pbf.readVarint64() : tag2 === 5 ? pbf.readVarint() : tag2 === 6 ? pbf.readSVarint() : tag2 === 7 ? pbf.readBoolean() : null;
        }
        return value;
      }
      VectorTileLayer.prototype.feature = function(i3) {
        if (i3 < 0 || i3 >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[i3];
        var end = this._pbf.readVarint() + this._pbf.pos;
        return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
      };
    }
  });

  // node_modules/@mapbox/vector-tile/lib/vectortile.js
  var require_vectortile = __commonJS({
    "node_modules/@mapbox/vector-tile/lib/vectortile.js"(exports2, module2) {
      "use strict";
      var VectorTileLayer = require_vectortilelayer();
      module2.exports = VectorTile3;
      function VectorTile3(pbf, end) {
        this.layers = pbf.readFields(readTile, {}, end);
      }
      function readTile(tag2, layers, pbf) {
        if (tag2 === 3) {
          var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
          if (layer.length)
            layers[layer.name] = layer;
        }
      }
    }
  });

  // node_modules/@mapbox/vector-tile/index.js
  var require_vector_tile = __commonJS({
    "node_modules/@mapbox/vector-tile/index.js"(exports2, module2) {
      module2.exports.VectorTile = require_vectortile();
      module2.exports.VectorTileFeature = require_vectortilefeature();
      module2.exports.VectorTileLayer = require_vectortilelayer();
    }
  });

  // node_modules/fast-json-stable-stringify/index.js
  var require_fast_json_stable_stringify = __commonJS({
    "node_modules/fast-json-stable-stringify/index.js"(exports2, module2) {
      "use strict";
      module2.exports = function(data, opts) {
        if (!opts)
          opts = {};
        if (typeof opts === "function")
          opts = { cmp: opts };
        var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
        var cmp = opts.cmp && /* @__PURE__ */ function(f2) {
          return function(node) {
            return function(a2, b2) {
              var aobj = { key: a2, value: node[a2] };
              var bobj = { key: b2, value: node[b2] };
              return f2(aobj, bobj);
            };
          };
        }(opts.cmp);
        var seen = [];
        return function stringify3(node) {
          if (node && node.toJSON && typeof node.toJSON === "function") {
            node = node.toJSON();
          }
          if (node === void 0)
            return;
          if (typeof node == "number")
            return isFinite(node) ? "" + node : "null";
          if (typeof node !== "object")
            return JSON.stringify(node);
          var i3, out;
          if (Array.isArray(node)) {
            out = "[";
            for (i3 = 0; i3 < node.length; i3++) {
              if (i3)
                out += ",";
              out += stringify3(node[i3]) || "null";
            }
            return out + "]";
          }
          if (node === null)
            return "null";
          if (seen.indexOf(node) !== -1) {
            if (cycles)
              return JSON.stringify("__cycle__");
            throw new TypeError("Converting circular structure to JSON");
          }
          var seenIndex = seen.push(node) - 1;
          var keys2 = Object.keys(node).sort(cmp && cmp(node));
          out = "";
          for (i3 = 0; i3 < keys2.length; i3++) {
            var key = keys2[i3];
            var value = stringify3(node[key]);
            if (!value)
              continue;
            if (out)
              out += ",";
            out += JSON.stringify(key) + ":" + value;
          }
          seen.splice(seenIndex, 1);
          return "{" + out + "}";
        }(data);
      };
    }
  });

  // node_modules/@mapbox/sexagesimal/index.js
  var require_sexagesimal = __commonJS({
    "node_modules/@mapbox/sexagesimal/index.js"(exports2, module2) {
      module2.exports = element;
      module2.exports.pair = pair3;
      module2.exports.format = format2;
      module2.exports.formatPair = formatPair;
      module2.exports.coordToDMS = coordToDMS;
      function element(input, dims) {
        var result = search(input, dims);
        return result === null ? null : result.val;
      }
      function formatPair(input) {
        return format2(input.lat, "lat") + " " + format2(input.lon, "lon");
      }
      function format2(input, dim) {
        var dms = coordToDMS(input, dim);
        return dms.whole + "\xB0 " + (dms.minutes ? dms.minutes + "' " : "") + (dms.seconds ? dms.seconds + '" ' : "") + dms.dir;
      }
      function coordToDMS(input, dim) {
        var dirs = { lat: ["N", "S"], lon: ["E", "W"] }[dim] || "";
        var dir = dirs[input >= 0 ? 0 : 1];
        var abs3 = Math.abs(input);
        var whole = Math.floor(abs3);
        var fraction = abs3 - whole;
        var fractionMinutes = fraction * 60;
        var minutes = Math.floor(fractionMinutes);
        var seconds = Math.floor((fractionMinutes - minutes) * 60);
        return {
          whole,
          minutes,
          seconds,
          dir
        };
      }
      function search(input, dims) {
        if (!dims)
          dims = "NSEW";
        if (typeof input !== "string")
          return null;
        input = input.toUpperCase();
        var regex = /^[\s\,]*([NSEW])?\s*([\-|\—|\―]?[0-9.]+)[°º˚]?\s*(?:([0-9.]+)['’′‘]\s*)?(?:([0-9.]+)(?:''|"|”|″)\s*)?([NSEW])?/;
        var m2 = input.match(regex);
        if (!m2)
          return null;
        var matched = m2[0];
        var dim;
        if (m2[1] && m2[5]) {
          dim = m2[1];
          matched = matched.slice(0, -1);
        } else {
          dim = m2[1] || m2[5];
        }
        if (dim && dims.indexOf(dim) === -1)
          return null;
        var deg = m2[2] ? parseFloat(m2[2]) : 0;
        var min3 = m2[3] ? parseFloat(m2[3]) / 60 : 0;
        var sec = m2[4] ? parseFloat(m2[4]) / 3600 : 0;
        var sign2 = deg < 0 ? -1 : 1;
        if (dim === "S" || dim === "W")
          sign2 *= -1;
        return {
          val: (Math.abs(deg) + min3 + sec) * sign2,
          dim,
          matched,
          remain: input.slice(matched.length)
        };
      }
      function pair3(input, dims) {
        input = input.trim();
        var one2 = search(input, dims);
        if (!one2)
          return null;
        input = one2.remain.trim();
        var two = search(input, dims);
        if (!two || two.remain)
          return null;
        if (one2.dim) {
          return swapdim(one2.val, two.val, one2.dim);
        } else {
          return [one2.val, two.val];
        }
      }
      function swapdim(a2, b2, dim) {
        if (dim === "N" || dim === "S")
          return [a2, b2];
        if (dim === "W" || dim === "E")
          return [b2, a2];
      }
    }
  });

  // node_modules/polygon-clipping/dist/polygon-clipping.umd.js
  var require_polygon_clipping_umd = __commonJS({
    "node_modules/polygon-clipping/dist/polygon-clipping.umd.js"(exports2, module2) {
      (function(global2, factory) {
        typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.polygonClipping = factory());
      })(exports2, function() {
        "use strict";
        function __generator(thisArg, body) {
          var _2 = {
            label: 0,
            sent: function() {
              if (t2[0] & 1)
                throw t2[1];
              return t2[1];
            },
            trys: [],
            ops: []
          }, f2, y2, t2, g3;
          return g3 = {
            next: verb(0),
            "throw": verb(1),
            "return": verb(2)
          }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
            return this;
          }), g3;
          function verb(n3) {
            return function(v2) {
              return step([n3, v2]);
            };
          }
          function step(op) {
            if (f2)
              throw new TypeError("Generator is already executing.");
            while (_2)
              try {
                if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                  return t2;
                if (y2 = 0, t2)
                  op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _2.label++;
                    return {
                      value: op[1],
                      done: false
                    };
                  case 5:
                    _2.label++;
                    y2 = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _2.ops.pop();
                    _2.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _2 = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _2.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _2.label < t2[1]) {
                      _2.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _2.label < t2[2]) {
                      _2.label = t2[2];
                      _2.ops.push(op);
                      break;
                    }
                    if (t2[2])
                      _2.ops.pop();
                    _2.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _2);
              } catch (e3) {
                op = [6, e3];
                y2 = 0;
              } finally {
                f2 = t2 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return {
              value: op[0] ? op[1] : void 0,
              done: true
            };
          }
        }
        var Node = (
          /** @class */
          /* @__PURE__ */ function() {
            function Node2(key, data) {
              this.next = null;
              this.key = key;
              this.data = data;
              this.left = null;
              this.right = null;
            }
            return Node2;
          }()
        );
        function DEFAULT_COMPARE(a2, b2) {
          return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
        }
        function splay(i3, t2, comparator) {
          var N2 = new Node(null, null);
          var l2 = N2;
          var r2 = N2;
          while (true) {
            var cmp2 = comparator(i3, t2.key);
            if (cmp2 < 0) {
              if (t2.left === null)
                break;
              if (comparator(i3, t2.left.key) < 0) {
                var y2 = t2.left;
                t2.left = y2.right;
                y2.right = t2;
                t2 = y2;
                if (t2.left === null)
                  break;
              }
              r2.left = t2;
              r2 = t2;
              t2 = t2.left;
            } else if (cmp2 > 0) {
              if (t2.right === null)
                break;
              if (comparator(i3, t2.right.key) > 0) {
                var y2 = t2.right;
                t2.right = y2.left;
                y2.left = t2;
                t2 = y2;
                if (t2.right === null)
                  break;
              }
              l2.right = t2;
              l2 = t2;
              t2 = t2.right;
            } else
              break;
          }
          l2.right = t2.left;
          r2.left = t2.right;
          t2.left = N2.right;
          t2.right = N2.left;
          return t2;
        }
        function insert(i3, data, t2, comparator) {
          var node = new Node(i3, data);
          if (t2 === null) {
            node.left = node.right = null;
            return node;
          }
          t2 = splay(i3, t2, comparator);
          var cmp2 = comparator(i3, t2.key);
          if (cmp2 < 0) {
            node.left = t2.left;
            node.right = t2;
            t2.left = null;
          } else if (cmp2 >= 0) {
            node.right = t2.right;
            node.left = t2;
            t2.right = null;
          }
          return node;
        }
        function split(key, v2, comparator) {
          var left = null;
          var right = null;
          if (v2) {
            v2 = splay(key, v2, comparator);
            var cmp2 = comparator(v2.key, key);
            if (cmp2 === 0) {
              left = v2.left;
              right = v2.right;
            } else if (cmp2 < 0) {
              right = v2.right;
              v2.right = null;
              left = v2;
            } else {
              left = v2.left;
              v2.left = null;
              right = v2;
            }
          }
          return {
            left,
            right
          };
        }
        function merge2(left, right, comparator) {
          if (right === null)
            return left;
          if (left === null)
            return right;
          right = splay(left.key, right, comparator);
          right.left = left;
          return right;
        }
        function printRow(root3, prefix, isTail, out, printNode) {
          if (root3) {
            out("" + prefix + (isTail ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ") + printNode(root3) + "\n");
            var indent = prefix + (isTail ? "    " : "\u2502   ");
            if (root3.left)
              printRow(root3.left, indent, false, out, printNode);
            if (root3.right)
              printRow(root3.right, indent, true, out, printNode);
          }
        }
        var Tree = (
          /** @class */
          function() {
            function Tree2(comparator) {
              if (comparator === void 0) {
                comparator = DEFAULT_COMPARE;
              }
              this._root = null;
              this._size = 0;
              this._comparator = comparator;
            }
            Tree2.prototype.insert = function(key, data) {
              this._size++;
              return this._root = insert(key, data, this._root, this._comparator);
            };
            Tree2.prototype.add = function(key, data) {
              var node = new Node(key, data);
              if (this._root === null) {
                node.left = node.right = null;
                this._size++;
                this._root = node;
              }
              var comparator = this._comparator;
              var t2 = splay(key, this._root, comparator);
              var cmp2 = comparator(key, t2.key);
              if (cmp2 === 0)
                this._root = t2;
              else {
                if (cmp2 < 0) {
                  node.left = t2.left;
                  node.right = t2;
                  t2.left = null;
                } else if (cmp2 > 0) {
                  node.right = t2.right;
                  node.left = t2;
                  t2.right = null;
                }
                this._size++;
                this._root = node;
              }
              return this._root;
            };
            Tree2.prototype.remove = function(key) {
              this._root = this._remove(key, this._root, this._comparator);
            };
            Tree2.prototype._remove = function(i3, t2, comparator) {
              var x2;
              if (t2 === null)
                return null;
              t2 = splay(i3, t2, comparator);
              var cmp2 = comparator(i3, t2.key);
              if (cmp2 === 0) {
                if (t2.left === null) {
                  x2 = t2.right;
                } else {
                  x2 = splay(i3, t2.left, comparator);
                  x2.right = t2.right;
                }
                this._size--;
                return x2;
              }
              return t2;
            };
            Tree2.prototype.pop = function() {
              var node = this._root;
              if (node) {
                while (node.left)
                  node = node.left;
                this._root = splay(node.key, this._root, this._comparator);
                this._root = this._remove(node.key, this._root, this._comparator);
                return {
                  key: node.key,
                  data: node.data
                };
              }
              return null;
            };
            Tree2.prototype.findStatic = function(key) {
              var current = this._root;
              var compare2 = this._comparator;
              while (current) {
                var cmp2 = compare2(key, current.key);
                if (cmp2 === 0)
                  return current;
                else if (cmp2 < 0)
                  current = current.left;
                else
                  current = current.right;
              }
              return null;
            };
            Tree2.prototype.find = function(key) {
              if (this._root) {
                this._root = splay(key, this._root, this._comparator);
                if (this._comparator(key, this._root.key) !== 0)
                  return null;
              }
              return this._root;
            };
            Tree2.prototype.contains = function(key) {
              var current = this._root;
              var compare2 = this._comparator;
              while (current) {
                var cmp2 = compare2(key, current.key);
                if (cmp2 === 0)
                  return true;
                else if (cmp2 < 0)
                  current = current.left;
                else
                  current = current.right;
              }
              return false;
            };
            Tree2.prototype.forEach = function(visitor, ctx) {
              var current = this._root;
              var Q2 = [];
              var done = false;
              while (!done) {
                if (current !== null) {
                  Q2.push(current);
                  current = current.left;
                } else {
                  if (Q2.length !== 0) {
                    current = Q2.pop();
                    visitor.call(ctx, current);
                    current = current.right;
                  } else
                    done = true;
                }
              }
              return this;
            };
            Tree2.prototype.range = function(low, high, fn, ctx) {
              var Q2 = [];
              var compare2 = this._comparator;
              var node = this._root;
              var cmp2;
              while (Q2.length !== 0 || node) {
                if (node) {
                  Q2.push(node);
                  node = node.left;
                } else {
                  node = Q2.pop();
                  cmp2 = compare2(node.key, high);
                  if (cmp2 > 0) {
                    break;
                  } else if (compare2(node.key, low) >= 0) {
                    if (fn.call(ctx, node))
                      return this;
                  }
                  node = node.right;
                }
              }
              return this;
            };
            Tree2.prototype.keys = function() {
              var keys2 = [];
              this.forEach(function(_a2) {
                var key = _a2.key;
                return keys2.push(key);
              });
              return keys2;
            };
            Tree2.prototype.values = function() {
              var values = [];
              this.forEach(function(_a2) {
                var data = _a2.data;
                return values.push(data);
              });
              return values;
            };
            Tree2.prototype.min = function() {
              if (this._root)
                return this.minNode(this._root).key;
              return null;
            };
            Tree2.prototype.max = function() {
              if (this._root)
                return this.maxNode(this._root).key;
              return null;
            };
            Tree2.prototype.minNode = function(t2) {
              if (t2 === void 0) {
                t2 = this._root;
              }
              if (t2)
                while (t2.left)
                  t2 = t2.left;
              return t2;
            };
            Tree2.prototype.maxNode = function(t2) {
              if (t2 === void 0) {
                t2 = this._root;
              }
              if (t2)
                while (t2.right)
                  t2 = t2.right;
              return t2;
            };
            Tree2.prototype.at = function(index2) {
              var current = this._root;
              var done = false;
              var i3 = 0;
              var Q2 = [];
              while (!done) {
                if (current) {
                  Q2.push(current);
                  current = current.left;
                } else {
                  if (Q2.length > 0) {
                    current = Q2.pop();
                    if (i3 === index2)
                      return current;
                    i3++;
                    current = current.right;
                  } else
                    done = true;
                }
              }
              return null;
            };
            Tree2.prototype.next = function(d2) {
              var root3 = this._root;
              var successor = null;
              if (d2.right) {
                successor = d2.right;
                while (successor.left)
                  successor = successor.left;
                return successor;
              }
              var comparator = this._comparator;
              while (root3) {
                var cmp2 = comparator(d2.key, root3.key);
                if (cmp2 === 0)
                  break;
                else if (cmp2 < 0) {
                  successor = root3;
                  root3 = root3.left;
                } else
                  root3 = root3.right;
              }
              return successor;
            };
            Tree2.prototype.prev = function(d2) {
              var root3 = this._root;
              var predecessor = null;
              if (d2.left !== null) {
                predecessor = d2.left;
                while (predecessor.right)
                  predecessor = predecessor.right;
                return predecessor;
              }
              var comparator = this._comparator;
              while (root3) {
                var cmp2 = comparator(d2.key, root3.key);
                if (cmp2 === 0)
                  break;
                else if (cmp2 < 0)
                  root3 = root3.left;
                else {
                  predecessor = root3;
                  root3 = root3.right;
                }
              }
              return predecessor;
            };
            Tree2.prototype.clear = function() {
              this._root = null;
              this._size = 0;
              return this;
            };
            Tree2.prototype.toList = function() {
              return toList(this._root);
            };
            Tree2.prototype.load = function(keys2, values, presort) {
              if (values === void 0) {
                values = [];
              }
              if (presort === void 0) {
                presort = false;
              }
              var size = keys2.length;
              var comparator = this._comparator;
              if (presort)
                sort(keys2, values, 0, size - 1, comparator);
              if (this._root === null) {
                this._root = loadRecursive(keys2, values, 0, size);
                this._size = size;
              } else {
                var mergedList = mergeLists(this.toList(), createList(keys2, values), comparator);
                size = this._size + size;
                this._root = sortedListToBST({
                  head: mergedList
                }, 0, size);
              }
              return this;
            };
            Tree2.prototype.isEmpty = function() {
              return this._root === null;
            };
            Object.defineProperty(Tree2.prototype, "size", {
              get: function() {
                return this._size;
              },
              enumerable: true,
              configurable: true
            });
            Object.defineProperty(Tree2.prototype, "root", {
              get: function() {
                return this._root;
              },
              enumerable: true,
              configurable: true
            });
            Tree2.prototype.toString = function(printNode) {
              if (printNode === void 0) {
                printNode = function(n3) {
                  return String(n3.key);
                };
              }
              var out = [];
              printRow(this._root, "", true, function(v2) {
                return out.push(v2);
              }, printNode);
              return out.join("");
            };
            Tree2.prototype.update = function(key, newKey, newData) {
              var comparator = this._comparator;
              var _a2 = split(key, this._root, comparator), left = _a2.left, right = _a2.right;
              if (comparator(key, newKey) < 0) {
                right = insert(newKey, newData, right, comparator);
              } else {
                left = insert(newKey, newData, left, comparator);
              }
              this._root = merge2(left, right, comparator);
            };
            Tree2.prototype.split = function(key) {
              return split(key, this._root, this._comparator);
            };
            Tree2.prototype[Symbol.iterator] = function() {
              var current, Q2, done;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    current = this._root;
                    Q2 = [];
                    done = false;
                    _a2.label = 1;
                  case 1:
                    if (!!done)
                      return [3, 6];
                    if (!(current !== null))
                      return [3, 2];
                    Q2.push(current);
                    current = current.left;
                    return [3, 5];
                  case 2:
                    if (!(Q2.length !== 0))
                      return [3, 4];
                    current = Q2.pop();
                    return [4, current];
                  case 3:
                    _a2.sent();
                    current = current.right;
                    return [3, 5];
                  case 4:
                    done = true;
                    _a2.label = 5;
                  case 5:
                    return [3, 1];
                  case 6:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            return Tree2;
          }()
        );
        function loadRecursive(keys2, values, start2, end) {
          var size = end - start2;
          if (size > 0) {
            var middle = start2 + Math.floor(size / 2);
            var key = keys2[middle];
            var data = values[middle];
            var node = new Node(key, data);
            node.left = loadRecursive(keys2, values, start2, middle);
            node.right = loadRecursive(keys2, values, middle + 1, end);
            return node;
          }
          return null;
        }
        function createList(keys2, values) {
          var head = new Node(null, null);
          var p2 = head;
          for (var i3 = 0; i3 < keys2.length; i3++) {
            p2 = p2.next = new Node(keys2[i3], values[i3]);
          }
          p2.next = null;
          return head.next;
        }
        function toList(root3) {
          var current = root3;
          var Q2 = [];
          var done = false;
          var head = new Node(null, null);
          var p2 = head;
          while (!done) {
            if (current) {
              Q2.push(current);
              current = current.left;
            } else {
              if (Q2.length > 0) {
                current = p2 = p2.next = Q2.pop();
                current = current.right;
              } else
                done = true;
            }
          }
          p2.next = null;
          return head.next;
        }
        function sortedListToBST(list2, start2, end) {
          var size = end - start2;
          if (size > 0) {
            var middle = start2 + Math.floor(size / 2);
            var left = sortedListToBST(list2, start2, middle);
            var root3 = list2.head;
            root3.left = left;
            list2.head = list2.head.next;
            root3.right = sortedListToBST(list2, middle + 1, end);
            return root3;
          }
          return null;
        }
        function mergeLists(l1, l2, compare2) {
          var head = new Node(null, null);
          var p2 = head;
          var p1 = l1;
          var p22 = l2;
          while (p1 !== null && p22 !== null) {
            if (compare2(p1.key, p22.key) < 0) {
              p2.next = p1;
              p1 = p1.next;
            } else {
              p2.next = p22;
              p22 = p22.next;
            }
            p2 = p2.next;
          }
          if (p1 !== null) {
            p2.next = p1;
          } else if (p22 !== null) {
            p2.next = p22;
          }
          return head.next;
        }
        function sort(keys2, values, left, right, compare2) {
          if (left >= right)
            return;
          var pivot = keys2[left + right >> 1];
          var i3 = left - 1;
          var j2 = right + 1;
          while (true) {
            do
              i3++;
            while (compare2(keys2[i3], pivot) < 0);
            do
              j2--;
            while (compare2(keys2[j2], pivot) > 0);
            if (i3 >= j2)
              break;
            var tmp = keys2[i3];
            keys2[i3] = keys2[j2];
            keys2[j2] = tmp;
            tmp = values[i3];
            values[i3] = values[j2];
            values[j2] = tmp;
          }
          sort(keys2, values, left, j2, compare2);
          sort(keys2, values, j2 + 1, right, compare2);
        }
        const isInBbox2 = (bbox2, point2) => {
          return bbox2.ll.x <= point2.x && point2.x <= bbox2.ur.x && bbox2.ll.y <= point2.y && point2.y <= bbox2.ur.y;
        };
        const getBboxOverlap2 = (b1, b2) => {
          if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y)
            return null;
          const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
          const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
          const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
          const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
          return {
            ll: {
              x: lowerX,
              y: lowerY
            },
            ur: {
              x: upperX,
              y: upperY
            }
          };
        };
        let epsilon$1 = Number.EPSILON;
        if (epsilon$1 === void 0)
          epsilon$1 = Math.pow(2, -52);
        const EPSILON_SQ = epsilon$1 * epsilon$1;
        const cmp = (a2, b2) => {
          if (-epsilon$1 < a2 && a2 < epsilon$1) {
            if (-epsilon$1 < b2 && b2 < epsilon$1) {
              return 0;
            }
          }
          const ab = a2 - b2;
          if (ab * ab < EPSILON_SQ * a2 * b2) {
            return 0;
          }
          return a2 < b2 ? -1 : 1;
        };
        class PtRounder {
          constructor() {
            this.reset();
          }
          reset() {
            this.xRounder = new CoordRounder();
            this.yRounder = new CoordRounder();
          }
          round(x2, y2) {
            return {
              x: this.xRounder.round(x2),
              y: this.yRounder.round(y2)
            };
          }
        }
        class CoordRounder {
          constructor() {
            this.tree = new Tree();
            this.round(0);
          }
          // Note: this can rounds input values backwards or forwards.
          //       You might ask, why not restrict this to just rounding
          //       forwards? Wouldn't that allow left endpoints to always
          //       remain left endpoints during splitting (never change to
          //       right). No - it wouldn't, because we snap intersections
          //       to endpoints (to establish independence from the segment
          //       angle for t-intersections).
          round(coord2) {
            const node = this.tree.add(coord2);
            const prevNode = this.tree.prev(node);
            if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
              this.tree.remove(coord2);
              return prevNode.key;
            }
            const nextNode = this.tree.next(node);
            if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
              this.tree.remove(coord2);
              return nextNode.key;
            }
            return coord2;
          }
        }
        const rounder = new PtRounder();
        const epsilon3 = 11102230246251565e-32;
        const splitter = 134217729;
        const resulterrbound = (3 + 8 * epsilon3) * epsilon3;
        function sum(elen, e3, flen, f2, h2) {
          let Q2, Qnew, hh, bvirt;
          let enow = e3[0];
          let fnow = f2[0];
          let eindex = 0;
          let findex = 0;
          if (fnow > enow === fnow > -enow) {
            Q2 = enow;
            enow = e3[++eindex];
          } else {
            Q2 = fnow;
            fnow = f2[++findex];
          }
          let hindex = 0;
          if (eindex < elen && findex < flen) {
            if (fnow > enow === fnow > -enow) {
              Qnew = enow + Q2;
              hh = Q2 - (Qnew - enow);
              enow = e3[++eindex];
            } else {
              Qnew = fnow + Q2;
              hh = Q2 - (Qnew - fnow);
              fnow = f2[++findex];
            }
            Q2 = Qnew;
            if (hh !== 0) {
              h2[hindex++] = hh;
            }
            while (eindex < elen && findex < flen) {
              if (fnow > enow === fnow > -enow) {
                Qnew = Q2 + enow;
                bvirt = Qnew - Q2;
                hh = Q2 - (Qnew - bvirt) + (enow - bvirt);
                enow = e3[++eindex];
              } else {
                Qnew = Q2 + fnow;
                bvirt = Qnew - Q2;
                hh = Q2 - (Qnew - bvirt) + (fnow - bvirt);
                fnow = f2[++findex];
              }
              Q2 = Qnew;
              if (hh !== 0) {
                h2[hindex++] = hh;
              }
            }
          }
          while (eindex < elen) {
            Qnew = Q2 + enow;
            bvirt = Qnew - Q2;
            hh = Q2 - (Qnew - bvirt) + (enow - bvirt);
            enow = e3[++eindex];
            Q2 = Qnew;
            if (hh !== 0) {
              h2[hindex++] = hh;
            }
          }
          while (findex < flen) {
            Qnew = Q2 + fnow;
            bvirt = Qnew - Q2;
            hh = Q2 - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f2[++findex];
            Q2 = Qnew;
            if (hh !== 0) {
              h2[hindex++] = hh;
            }
          }
          if (Q2 !== 0 || hindex === 0) {
            h2[hindex++] = Q2;
          }
          return hindex;
        }
        function estimate(elen, e3) {
          let Q2 = e3[0];
          for (let i3 = 1; i3 < elen; i3++)
            Q2 += e3[i3];
          return Q2;
        }
        function vec(n3) {
          return new Float64Array(n3);
        }
        const ccwerrboundA = (3 + 16 * epsilon3) * epsilon3;
        const ccwerrboundB = (2 + 12 * epsilon3) * epsilon3;
        const ccwerrboundC = (9 + 64 * epsilon3) * epsilon3 * epsilon3;
        const B2 = vec(4);
        const C1 = vec(8);
        const C2 = vec(12);
        const D2 = vec(16);
        const u2 = vec(4);
        function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
          let acxtail, acytail, bcxtail, bcytail;
          let bvirt, c2, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;
          const acx = ax - cx;
          const bcx = bx - cx;
          const acy = ay - cy;
          const bcy = by - cy;
          s1 = acx * bcy;
          c2 = splitter * acx;
          ahi = c2 - (c2 - acx);
          alo = acx - ahi;
          c2 = splitter * bcy;
          bhi = c2 - (c2 - bcy);
          blo = bcy - bhi;
          s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
          t1 = acy * bcx;
          c2 = splitter * acy;
          ahi = c2 - (c2 - acy);
          alo = acy - ahi;
          c2 = splitter * bcx;
          bhi = c2 - (c2 - bcx);
          blo = bcx - bhi;
          t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
          _i = s0 - t0;
          bvirt = s0 - _i;
          B2[0] = s0 - (_i + bvirt) + (bvirt - t0);
          _j = s1 + _i;
          bvirt = _j - s1;
          _0 = s1 - (_j - bvirt) + (_i - bvirt);
          _i = _0 - t1;
          bvirt = _0 - _i;
          B2[1] = _0 - (_i + bvirt) + (bvirt - t1);
          u3 = _j + _i;
          bvirt = u3 - _j;
          B2[2] = _j - (u3 - bvirt) + (_i - bvirt);
          B2[3] = u3;
          let det = estimate(4, B2);
          let errbound = ccwerrboundB * detsum;
          if (det >= errbound || -det >= errbound) {
            return det;
          }
          bvirt = ax - acx;
          acxtail = ax - (acx + bvirt) + (bvirt - cx);
          bvirt = bx - bcx;
          bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
          bvirt = ay - acy;
          acytail = ay - (acy + bvirt) + (bvirt - cy);
          bvirt = by - bcy;
          bcytail = by - (bcy + bvirt) + (bvirt - cy);
          if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
            return det;
          }
          errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
          det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
          if (det >= errbound || -det >= errbound)
            return det;
          s1 = acxtail * bcy;
          c2 = splitter * acxtail;
          ahi = c2 - (c2 - acxtail);
          alo = acxtail - ahi;
          c2 = splitter * bcy;
          bhi = c2 - (c2 - bcy);
          blo = bcy - bhi;
          s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
          t1 = acytail * bcx;
          c2 = splitter * acytail;
          ahi = c2 - (c2 - acytail);
          alo = acytail - ahi;
          c2 = splitter * bcx;
          bhi = c2 - (c2 - bcx);
          blo = bcx - bhi;
          t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
          _i = s0 - t0;
          bvirt = s0 - _i;
          u2[0] = s0 - (_i + bvirt) + (bvirt - t0);
          _j = s1 + _i;
          bvirt = _j - s1;
          _0 = s1 - (_j - bvirt) + (_i - bvirt);
          _i = _0 - t1;
          bvirt = _0 - _i;
          u2[1] = _0 - (_i + bvirt) + (bvirt - t1);
          u3 = _j + _i;
          bvirt = u3 - _j;
          u2[2] = _j - (u3 - bvirt) + (_i - bvirt);
          u2[3] = u3;
          const C1len = sum(4, B2, 4, u2, C1);
          s1 = acx * bcytail;
          c2 = splitter * acx;
          ahi = c2 - (c2 - acx);
          alo = acx - ahi;
          c2 = splitter * bcytail;
          bhi = c2 - (c2 - bcytail);
          blo = bcytail - bhi;
          s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
          t1 = acy * bcxtail;
          c2 = splitter * acy;
          ahi = c2 - (c2 - acy);
          alo = acy - ahi;
          c2 = splitter * bcxtail;
          bhi = c2 - (c2 - bcxtail);
          blo = bcxtail - bhi;
          t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
          _i = s0 - t0;
          bvirt = s0 - _i;
          u2[0] = s0 - (_i + bvirt) + (bvirt - t0);
          _j = s1 + _i;
          bvirt = _j - s1;
          _0 = s1 - (_j - bvirt) + (_i - bvirt);
          _i = _0 - t1;
          bvirt = _0 - _i;
          u2[1] = _0 - (_i + bvirt) + (bvirt - t1);
          u3 = _j + _i;
          bvirt = u3 - _j;
          u2[2] = _j - (u3 - bvirt) + (_i - bvirt);
          u2[3] = u3;
          const C2len = sum(C1len, C1, 4, u2, C2);
          s1 = acxtail * bcytail;
          c2 = splitter * acxtail;
          ahi = c2 - (c2 - acxtail);
          alo = acxtail - ahi;
          c2 = splitter * bcytail;
          bhi = c2 - (c2 - bcytail);
          blo = bcytail - bhi;
          s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
          t1 = acytail * bcxtail;
          c2 = splitter * acytail;
          ahi = c2 - (c2 - acytail);
          alo = acytail - ahi;
          c2 = splitter * bcxtail;
          bhi = c2 - (c2 - bcxtail);
          blo = bcxtail - bhi;
          t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
          _i = s0 - t0;
          bvirt = s0 - _i;
          u2[0] = s0 - (_i + bvirt) + (bvirt - t0);
          _j = s1 + _i;
          bvirt = _j - s1;
          _0 = s1 - (_j - bvirt) + (_i - bvirt);
          _i = _0 - t1;
          bvirt = _0 - _i;
          u2[1] = _0 - (_i + bvirt) + (bvirt - t1);
          u3 = _j + _i;
          bvirt = u3 - _j;
          u2[2] = _j - (u3 - bvirt) + (_i - bvirt);
          u2[3] = u3;
          const Dlen = sum(C2len, C2, 4, u2, D2);
          return D2[Dlen - 1];
        }
        function orient2d(ax, ay, bx, by, cx, cy) {
          const detleft = (ay - cy) * (bx - cx);
          const detright = (ax - cx) * (by - cy);
          const det = detleft - detright;
          const detsum = Math.abs(detleft + detright);
          if (Math.abs(det) >= ccwerrboundA * detsum)
            return det;
          return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
        }
        const crossProduct2 = (a2, b2) => a2.x * b2.y - a2.y * b2.x;
        const dotProduct2 = (a2, b2) => a2.x * b2.x + a2.y * b2.y;
        const compareVectorAngles = (basePt, endPt1, endPt2) => {
          const res = orient2d(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);
          if (res > 0)
            return -1;
          if (res < 0)
            return 1;
          return 0;
        };
        const length2 = (v2) => Math.sqrt(dotProduct2(v2, v2));
        const sineOfAngle2 = (pShared, pBase, pAngle) => {
          const vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
          };
          const vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
          };
          return crossProduct2(vAngle, vBase) / length2(vAngle) / length2(vBase);
        };
        const cosineOfAngle2 = (pShared, pBase, pAngle) => {
          const vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
          };
          const vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
          };
          return dotProduct2(vAngle, vBase) / length2(vAngle) / length2(vBase);
        };
        const horizontalIntersection2 = (pt2, v2, y2) => {
          if (v2.y === 0)
            return null;
          return {
            x: pt2.x + v2.x / v2.y * (y2 - pt2.y),
            y: y2
          };
        };
        const verticalIntersection2 = (pt2, v2, x2) => {
          if (v2.x === 0)
            return null;
          return {
            x: x2,
            y: pt2.y + v2.y / v2.x * (x2 - pt2.x)
          };
        };
        const intersection$1 = (pt1, v1, pt2, v2) => {
          if (v1.x === 0)
            return verticalIntersection2(pt2, v2, pt1.x);
          if (v2.x === 0)
            return verticalIntersection2(pt1, v1, pt2.x);
          if (v1.y === 0)
            return horizontalIntersection2(pt2, v2, pt1.y);
          if (v2.y === 0)
            return horizontalIntersection2(pt1, v1, pt2.y);
          const kross = crossProduct2(v1, v2);
          if (kross == 0)
            return null;
          const ve2 = {
            x: pt2.x - pt1.x,
            y: pt2.y - pt1.y
          };
          const d1 = crossProduct2(ve2, v1) / kross;
          const d2 = crossProduct2(ve2, v2) / kross;
          const x12 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x;
          const y12 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y;
          const x3 = (x12 + x2) / 2;
          const y3 = (y12 + y2) / 2;
          return {
            x: x3,
            y: y3
          };
        };
        class SweepEvent2 {
          // for ordering sweep events in the sweep event queue
          static compare(a2, b2) {
            const ptCmp = SweepEvent2.comparePoints(a2.point, b2.point);
            if (ptCmp !== 0)
              return ptCmp;
            if (a2.point !== b2.point)
              a2.link(b2);
            if (a2.isLeft !== b2.isLeft)
              return a2.isLeft ? 1 : -1;
            return Segment2.compare(a2.segment, b2.segment);
          }
          // for ordering points in sweep line order
          static comparePoints(aPt, bPt) {
            if (aPt.x < bPt.x)
              return -1;
            if (aPt.x > bPt.x)
              return 1;
            if (aPt.y < bPt.y)
              return -1;
            if (aPt.y > bPt.y)
              return 1;
            return 0;
          }
          // Warning: 'point' input will be modified and re-used (for performance)
          constructor(point2, isLeft) {
            if (point2.events === void 0)
              point2.events = [this];
            else
              point2.events.push(this);
            this.point = point2;
            this.isLeft = isLeft;
          }
          link(other) {
            if (other.point === this.point) {
              throw new Error("Tried to link already linked events");
            }
            const otherEvents = other.point.events;
            for (let i3 = 0, iMax = otherEvents.length; i3 < iMax; i3++) {
              const evt = otherEvents[i3];
              this.point.events.push(evt);
              evt.point = this.point;
            }
            this.checkForConsuming();
          }
          /* Do a pass over our linked events and check to see if any pair
           * of segments match, and should be consumed. */
          checkForConsuming() {
            const numEvents = this.point.events.length;
            for (let i3 = 0; i3 < numEvents; i3++) {
              const evt1 = this.point.events[i3];
              if (evt1.segment.consumedBy !== void 0)
                continue;
              for (let j2 = i3 + 1; j2 < numEvents; j2++) {
                const evt2 = this.point.events[j2];
                if (evt2.consumedBy !== void 0)
                  continue;
                if (evt1.otherSE.point.events !== evt2.otherSE.point.events)
                  continue;
                evt1.segment.consume(evt2.segment);
              }
            }
          }
          getAvailableLinkedEvents() {
            const events = [];
            for (let i3 = 0, iMax = this.point.events.length; i3 < iMax; i3++) {
              const evt = this.point.events[i3];
              if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
                events.push(evt);
              }
            }
            return events;
          }
          /**
           * Returns a comparator function for sorting linked events that will
           * favor the event that will give us the smallest left-side angle.
           * All ring construction starts as low as possible heading to the right,
           * so by always turning left as sharp as possible we'll get polygons
           * without uncessary loops & holes.
           *
           * The comparator function has a compute cache such that it avoids
           * re-computing already-computed values.
           */
          getLeftmostComparator(baseEvent) {
            const cache = /* @__PURE__ */ new Map();
            const fillCache = (linkedEvent) => {
              const nextEvent = linkedEvent.otherSE;
              cache.set(linkedEvent, {
                sine: sineOfAngle2(this.point, baseEvent.point, nextEvent.point),
                cosine: cosineOfAngle2(this.point, baseEvent.point, nextEvent.point)
              });
            };
            return (a2, b2) => {
              if (!cache.has(a2))
                fillCache(a2);
              if (!cache.has(b2))
                fillCache(b2);
              const {
                sine: asine,
                cosine: acosine
              } = cache.get(a2);
              const {
                sine: bsine,
                cosine: bcosine
              } = cache.get(b2);
              if (asine >= 0 && bsine >= 0) {
                if (acosine < bcosine)
                  return 1;
                if (acosine > bcosine)
                  return -1;
                return 0;
              }
              if (asine < 0 && bsine < 0) {
                if (acosine < bcosine)
                  return -1;
                if (acosine > bcosine)
                  return 1;
                return 0;
              }
              if (bsine < asine)
                return -1;
              if (bsine > asine)
                return 1;
              return 0;
            };
          }
        }
        let segmentId2 = 0;
        class Segment2 {
          /* This compare() function is for ordering segments in the sweep
           * line tree, and does so according to the following criteria:
           *
           * Consider the vertical line that lies an infinestimal step to the
           * right of the right-more of the two left endpoints of the input
           * segments. Imagine slowly moving a point up from negative infinity
           * in the increasing y direction. Which of the two segments will that
           * point intersect first? That segment comes 'before' the other one.
           *
           * If neither segment would be intersected by such a line, (if one
           * or more of the segments are vertical) then the line to be considered
           * is directly on the right-more of the two left inputs.
           */
          static compare(a2, b2) {
            const alx = a2.leftSE.point.x;
            const blx = b2.leftSE.point.x;
            const arx = a2.rightSE.point.x;
            const brx = b2.rightSE.point.x;
            if (brx < alx)
              return 1;
            if (arx < blx)
              return -1;
            const aly = a2.leftSE.point.y;
            const bly = b2.leftSE.point.y;
            const ary = a2.rightSE.point.y;
            const bry = b2.rightSE.point.y;
            if (alx < blx) {
              if (bly < aly && bly < ary)
                return 1;
              if (bly > aly && bly > ary)
                return -1;
              const aCmpBLeft = a2.comparePoint(b2.leftSE.point);
              if (aCmpBLeft < 0)
                return 1;
              if (aCmpBLeft > 0)
                return -1;
              const bCmpARight = b2.comparePoint(a2.rightSE.point);
              if (bCmpARight !== 0)
                return bCmpARight;
              return -1;
            }
            if (alx > blx) {
              if (aly < bly && aly < bry)
                return -1;
              if (aly > bly && aly > bry)
                return 1;
              const bCmpALeft = b2.comparePoint(a2.leftSE.point);
              if (bCmpALeft !== 0)
                return bCmpALeft;
              const aCmpBRight = a2.comparePoint(b2.rightSE.point);
              if (aCmpBRight < 0)
                return 1;
              if (aCmpBRight > 0)
                return -1;
              return 1;
            }
            if (aly < bly)
              return -1;
            if (aly > bly)
              return 1;
            if (arx < brx) {
              const bCmpARight = b2.comparePoint(a2.rightSE.point);
              if (bCmpARight !== 0)
                return bCmpARight;
            }
            if (arx > brx) {
              const aCmpBRight = a2.comparePoint(b2.rightSE.point);
              if (aCmpBRight < 0)
                return 1;
              if (aCmpBRight > 0)
                return -1;
            }
            if (arx !== brx) {
              const ay = ary - aly;
              const ax = arx - alx;
              const by = bry - bly;
              const bx = brx - blx;
              if (ay > ax && by < bx)
                return 1;
              if (ay < ax && by > bx)
                return -1;
            }
            if (arx > brx)
              return 1;
            if (arx < brx)
              return -1;
            if (ary < bry)
              return -1;
            if (ary > bry)
              return 1;
            if (a2.id < b2.id)
              return -1;
            if (a2.id > b2.id)
              return 1;
            return 0;
          }
          /* Warning: a reference to ringWindings input will be stored,
           *  and possibly will be later modified */
          constructor(leftSE, rightSE, rings, windings) {
            this.id = ++segmentId2;
            this.leftSE = leftSE;
            leftSE.segment = this;
            leftSE.otherSE = rightSE;
            this.rightSE = rightSE;
            rightSE.segment = this;
            rightSE.otherSE = leftSE;
            this.rings = rings;
            this.windings = windings;
          }
          static fromRing(pt1, pt2, ring) {
            let leftPt, rightPt, winding;
            const cmpPts = SweepEvent2.comparePoints(pt1, pt2);
            if (cmpPts < 0) {
              leftPt = pt1;
              rightPt = pt2;
              winding = 1;
            } else if (cmpPts > 0) {
              leftPt = pt2;
              rightPt = pt1;
              winding = -1;
            } else
              throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));
            const leftSE = new SweepEvent2(leftPt, true);
            const rightSE = new SweepEvent2(rightPt, false);
            return new Segment2(leftSE, rightSE, [ring], [winding]);
          }
          /* When a segment is split, the rightSE is replaced with a new sweep event */
          replaceRightSE(newRightSE) {
            this.rightSE = newRightSE;
            this.rightSE.segment = this;
            this.rightSE.otherSE = this.leftSE;
            this.leftSE.otherSE = this.rightSE;
          }
          bbox() {
            const y12 = this.leftSE.point.y;
            const y2 = this.rightSE.point.y;
            return {
              ll: {
                x: this.leftSE.point.x,
                y: y12 < y2 ? y12 : y2
              },
              ur: {
                x: this.rightSE.point.x,
                y: y12 > y2 ? y12 : y2
              }
            };
          }
          /* A vector from the left point to the right */
          vector() {
            return {
              x: this.rightSE.point.x - this.leftSE.point.x,
              y: this.rightSE.point.y - this.leftSE.point.y
            };
          }
          isAnEndpoint(pt2) {
            return pt2.x === this.leftSE.point.x && pt2.y === this.leftSE.point.y || pt2.x === this.rightSE.point.x && pt2.y === this.rightSE.point.y;
          }
          /* Compare this segment with a point.
           *
           * A point P is considered to be colinear to a segment if there
           * exists a distance D such that if we travel along the segment
           * from one * endpoint towards the other a distance D, we find
           * ourselves at point P.
           *
           * Return value indicates:
           *
           *   1: point lies above the segment (to the left of vertical)
           *   0: point is colinear to segment
           *  -1: point lies below the segment (to the right of vertical)
           */
          comparePoint(point2) {
            if (this.isAnEndpoint(point2))
              return 0;
            const lPt = this.leftSE.point;
            const rPt = this.rightSE.point;
            const v2 = this.vector();
            if (lPt.x === rPt.x) {
              if (point2.x === lPt.x)
                return 0;
              return point2.x < lPt.x ? 1 : -1;
            }
            const yDist = (point2.y - lPt.y) / v2.y;
            const xFromYDist = lPt.x + yDist * v2.x;
            if (point2.x === xFromYDist)
              return 0;
            const xDist = (point2.x - lPt.x) / v2.x;
            const yFromXDist = lPt.y + xDist * v2.y;
            if (point2.y === yFromXDist)
              return 0;
            return point2.y < yFromXDist ? -1 : 1;
          }
          /**
           * Given another segment, returns the first non-trivial intersection
           * between the two segments (in terms of sweep line ordering), if it exists.
           *
           * A 'non-trivial' intersection is one that will cause one or both of the
           * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
           *
           *   * endpoint of segA with endpoint of segB --> trivial
           *   * endpoint of segA with point along segB --> non-trivial
           *   * endpoint of segB with point along segA --> non-trivial
           *   * point along segA with point along segB --> non-trivial
           *
           * If no non-trivial intersection exists, return null
           * Else, return null.
           */
          getIntersection(other) {
            const tBbox = this.bbox();
            const oBbox = other.bbox();
            const bboxOverlap = getBboxOverlap2(tBbox, oBbox);
            if (bboxOverlap === null)
              return null;
            const tlp = this.leftSE.point;
            const trp = this.rightSE.point;
            const olp = other.leftSE.point;
            const orp = other.rightSE.point;
            const touchesOtherLSE = isInBbox2(tBbox, olp) && this.comparePoint(olp) === 0;
            const touchesThisLSE = isInBbox2(oBbox, tlp) && other.comparePoint(tlp) === 0;
            const touchesOtherRSE = isInBbox2(tBbox, orp) && this.comparePoint(orp) === 0;
            const touchesThisRSE = isInBbox2(oBbox, trp) && other.comparePoint(trp) === 0;
            if (touchesThisLSE && touchesOtherLSE) {
              if (touchesThisRSE && !touchesOtherRSE)
                return trp;
              if (!touchesThisRSE && touchesOtherRSE)
                return orp;
              return null;
            }
            if (touchesThisLSE) {
              if (touchesOtherRSE) {
                if (tlp.x === orp.x && tlp.y === orp.y)
                  return null;
              }
              return tlp;
            }
            if (touchesOtherLSE) {
              if (touchesThisRSE) {
                if (trp.x === olp.x && trp.y === olp.y)
                  return null;
              }
              return olp;
            }
            if (touchesThisRSE && touchesOtherRSE)
              return null;
            if (touchesThisRSE)
              return trp;
            if (touchesOtherRSE)
              return orp;
            const pt2 = intersection$1(tlp, this.vector(), olp, other.vector());
            if (pt2 === null)
              return null;
            if (!isInBbox2(bboxOverlap, pt2))
              return null;
            return rounder.round(pt2.x, pt2.y);
          }
          /**
           * Split the given segment into multiple segments on the given points.
           *  * Each existing segment will retain its leftSE and a new rightSE will be
           *    generated for it.
           *  * A new segment will be generated which will adopt the original segment's
           *    rightSE, and a new leftSE will be generated for it.
           *  * If there are more than two points given to split on, new segments
           *    in the middle will be generated with new leftSE and rightSE's.
           *  * An array of the newly generated SweepEvents will be returned.
           *
           * Warning: input array of points is modified
           */
          split(point2) {
            const newEvents = [];
            const alreadyLinked = point2.events !== void 0;
            const newLeftSE = new SweepEvent2(point2, true);
            const newRightSE = new SweepEvent2(point2, false);
            const oldRightSE = this.rightSE;
            this.replaceRightSE(newRightSE);
            newEvents.push(newRightSE);
            newEvents.push(newLeftSE);
            const newSeg = new Segment2(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
            if (SweepEvent2.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
              newSeg.swapEvents();
            }
            if (SweepEvent2.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
              this.swapEvents();
            }
            if (alreadyLinked) {
              newLeftSE.checkForConsuming();
              newRightSE.checkForConsuming();
            }
            return newEvents;
          }
          /* Swap which event is left and right */
          swapEvents() {
            const tmpEvt = this.rightSE;
            this.rightSE = this.leftSE;
            this.leftSE = tmpEvt;
            this.leftSE.isLeft = true;
            this.rightSE.isLeft = false;
            for (let i3 = 0, iMax = this.windings.length; i3 < iMax; i3++) {
              this.windings[i3] *= -1;
            }
          }
          /* Consume another segment. We take their rings under our wing
           * and mark them as consumed. Use for perfectly overlapping segments */
          consume(other) {
            let consumer = this;
            let consumee = other;
            while (consumer.consumedBy)
              consumer = consumer.consumedBy;
            while (consumee.consumedBy)
              consumee = consumee.consumedBy;
            const cmp2 = Segment2.compare(consumer, consumee);
            if (cmp2 === 0)
              return;
            if (cmp2 > 0) {
              const tmp = consumer;
              consumer = consumee;
              consumee = tmp;
            }
            if (consumer.prev === consumee) {
              const tmp = consumer;
              consumer = consumee;
              consumee = tmp;
            }
            for (let i3 = 0, iMax = consumee.rings.length; i3 < iMax; i3++) {
              const ring = consumee.rings[i3];
              const winding = consumee.windings[i3];
              const index2 = consumer.rings.indexOf(ring);
              if (index2 === -1) {
                consumer.rings.push(ring);
                consumer.windings.push(winding);
              } else
                consumer.windings[index2] += winding;
            }
            consumee.rings = null;
            consumee.windings = null;
            consumee.consumedBy = consumer;
            consumee.leftSE.consumedBy = consumer.leftSE;
            consumee.rightSE.consumedBy = consumer.rightSE;
          }
          /* The first segment previous segment chain that is in the result */
          prevInResult() {
            if (this._prevInResult !== void 0)
              return this._prevInResult;
            if (!this.prev)
              this._prevInResult = null;
            else if (this.prev.isInResult())
              this._prevInResult = this.prev;
            else
              this._prevInResult = this.prev.prevInResult();
            return this._prevInResult;
          }
          beforeState() {
            if (this._beforeState !== void 0)
              return this._beforeState;
            if (!this.prev)
              this._beforeState = {
                rings: [],
                windings: [],
                multiPolys: []
              };
            else {
              const seg = this.prev.consumedBy || this.prev;
              this._beforeState = seg.afterState();
            }
            return this._beforeState;
          }
          afterState() {
            if (this._afterState !== void 0)
              return this._afterState;
            const beforeState = this.beforeState();
            this._afterState = {
              rings: beforeState.rings.slice(0),
              windings: beforeState.windings.slice(0),
              multiPolys: []
            };
            const ringsAfter = this._afterState.rings;
            const windingsAfter = this._afterState.windings;
            const mpsAfter = this._afterState.multiPolys;
            for (let i3 = 0, iMax = this.rings.length; i3 < iMax; i3++) {
              const ring = this.rings[i3];
              const winding = this.windings[i3];
              const index2 = ringsAfter.indexOf(ring);
              if (index2 === -1) {
                ringsAfter.push(ring);
                windingsAfter.push(winding);
              } else
                windingsAfter[index2] += winding;
            }
            const polysAfter = [];
            const polysExclude = [];
            for (let i3 = 0, iMax = ringsAfter.length; i3 < iMax; i3++) {
              if (windingsAfter[i3] === 0)
                continue;
              const ring = ringsAfter[i3];
              const poly = ring.poly;
              if (polysExclude.indexOf(poly) !== -1)
                continue;
              if (ring.isExterior)
                polysAfter.push(poly);
              else {
                if (polysExclude.indexOf(poly) === -1)
                  polysExclude.push(poly);
                const index2 = polysAfter.indexOf(ring.poly);
                if (index2 !== -1)
                  polysAfter.splice(index2, 1);
              }
            }
            for (let i3 = 0, iMax = polysAfter.length; i3 < iMax; i3++) {
              const mp = polysAfter[i3].multiPoly;
              if (mpsAfter.indexOf(mp) === -1)
                mpsAfter.push(mp);
            }
            return this._afterState;
          }
          /* Is this segment part of the final result? */
          isInResult() {
            if (this.consumedBy)
              return false;
            if (this._isInResult !== void 0)
              return this._isInResult;
            const mpsBefore = this.beforeState().multiPolys;
            const mpsAfter = this.afterState().multiPolys;
            switch (operation2.type) {
              case "union": {
                const noBefores = mpsBefore.length === 0;
                const noAfters = mpsAfter.length === 0;
                this._isInResult = noBefores !== noAfters;
                break;
              }
              case "intersection": {
                let least;
                let most;
                if (mpsBefore.length < mpsAfter.length) {
                  least = mpsBefore.length;
                  most = mpsAfter.length;
                } else {
                  least = mpsAfter.length;
                  most = mpsBefore.length;
                }
                this._isInResult = most === operation2.numMultiPolys && least < most;
                break;
              }
              case "xor": {
                const diff = Math.abs(mpsBefore.length - mpsAfter.length);
                this._isInResult = diff % 2 === 1;
                break;
              }
              case "difference": {
                const isJustSubject = (mps) => mps.length === 1 && mps[0].isSubject;
                this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
                break;
              }
              default:
                throw new Error("Unrecognized operation type found ".concat(operation2.type));
            }
            return this._isInResult;
          }
        }
        class RingIn2 {
          constructor(geomRing, poly, isExterior) {
            if (!Array.isArray(geomRing) || geomRing.length === 0) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            this.poly = poly;
            this.isExterior = isExterior;
            this.segments = [];
            if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
            this.bbox = {
              ll: {
                x: firstPoint.x,
                y: firstPoint.y
              },
              ur: {
                x: firstPoint.x,
                y: firstPoint.y
              }
            };
            let prevPoint = firstPoint;
            for (let i3 = 1, iMax = geomRing.length; i3 < iMax; i3++) {
              if (typeof geomRing[i3][0] !== "number" || typeof geomRing[i3][1] !== "number") {
                throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
              }
              let point2 = rounder.round(geomRing[i3][0], geomRing[i3][1]);
              if (point2.x === prevPoint.x && point2.y === prevPoint.y)
                continue;
              this.segments.push(Segment2.fromRing(prevPoint, point2, this));
              if (point2.x < this.bbox.ll.x)
                this.bbox.ll.x = point2.x;
              if (point2.y < this.bbox.ll.y)
                this.bbox.ll.y = point2.y;
              if (point2.x > this.bbox.ur.x)
                this.bbox.ur.x = point2.x;
              if (point2.y > this.bbox.ur.y)
                this.bbox.ur.y = point2.y;
              prevPoint = point2;
            }
            if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
              this.segments.push(Segment2.fromRing(prevPoint, firstPoint, this));
            }
          }
          getSweepEvents() {
            const sweepEvents = [];
            for (let i3 = 0, iMax = this.segments.length; i3 < iMax; i3++) {
              const segment = this.segments[i3];
              sweepEvents.push(segment.leftSE);
              sweepEvents.push(segment.rightSE);
            }
            return sweepEvents;
          }
        }
        class PolyIn2 {
          constructor(geomPoly, multiPoly) {
            if (!Array.isArray(geomPoly)) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            this.exteriorRing = new RingIn2(geomPoly[0], this, true);
            this.bbox = {
              ll: {
                x: this.exteriorRing.bbox.ll.x,
                y: this.exteriorRing.bbox.ll.y
              },
              ur: {
                x: this.exteriorRing.bbox.ur.x,
                y: this.exteriorRing.bbox.ur.y
              }
            };
            this.interiorRings = [];
            for (let i3 = 1, iMax = geomPoly.length; i3 < iMax; i3++) {
              const ring = new RingIn2(geomPoly[i3], this, false);
              if (ring.bbox.ll.x < this.bbox.ll.x)
                this.bbox.ll.x = ring.bbox.ll.x;
              if (ring.bbox.ll.y < this.bbox.ll.y)
                this.bbox.ll.y = ring.bbox.ll.y;
              if (ring.bbox.ur.x > this.bbox.ur.x)
                this.bbox.ur.x = ring.bbox.ur.x;
              if (ring.bbox.ur.y > this.bbox.ur.y)
                this.bbox.ur.y = ring.bbox.ur.y;
              this.interiorRings.push(ring);
            }
            this.multiPoly = multiPoly;
          }
          getSweepEvents() {
            const sweepEvents = this.exteriorRing.getSweepEvents();
            for (let i3 = 0, iMax = this.interiorRings.length; i3 < iMax; i3++) {
              const ringSweepEvents = this.interiorRings[i3].getSweepEvents();
              for (let j2 = 0, jMax = ringSweepEvents.length; j2 < jMax; j2++) {
                sweepEvents.push(ringSweepEvents[j2]);
              }
            }
            return sweepEvents;
          }
        }
        class MultiPolyIn2 {
          constructor(geom, isSubject) {
            if (!Array.isArray(geom)) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            try {
              if (typeof geom[0][0][0] === "number")
                geom = [geom];
            } catch (ex) {
            }
            this.polys = [];
            this.bbox = {
              ll: {
                x: Number.POSITIVE_INFINITY,
                y: Number.POSITIVE_INFINITY
              },
              ur: {
                x: Number.NEGATIVE_INFINITY,
                y: Number.NEGATIVE_INFINITY
              }
            };
            for (let i3 = 0, iMax = geom.length; i3 < iMax; i3++) {
              const poly = new PolyIn2(geom[i3], this);
              if (poly.bbox.ll.x < this.bbox.ll.x)
                this.bbox.ll.x = poly.bbox.ll.x;
              if (poly.bbox.ll.y < this.bbox.ll.y)
                this.bbox.ll.y = poly.bbox.ll.y;
              if (poly.bbox.ur.x > this.bbox.ur.x)
                this.bbox.ur.x = poly.bbox.ur.x;
              if (poly.bbox.ur.y > this.bbox.ur.y)
                this.bbox.ur.y = poly.bbox.ur.y;
              this.polys.push(poly);
            }
            this.isSubject = isSubject;
          }
          getSweepEvents() {
            const sweepEvents = [];
            for (let i3 = 0, iMax = this.polys.length; i3 < iMax; i3++) {
              const polySweepEvents = this.polys[i3].getSweepEvents();
              for (let j2 = 0, jMax = polySweepEvents.length; j2 < jMax; j2++) {
                sweepEvents.push(polySweepEvents[j2]);
              }
            }
            return sweepEvents;
          }
        }
        class RingOut2 {
          /* Given the segments from the sweep line pass, compute & return a series
           * of closed rings from all the segments marked to be part of the result */
          static factory(allSegments) {
            const ringsOut = [];
            for (let i3 = 0, iMax = allSegments.length; i3 < iMax; i3++) {
              const segment = allSegments[i3];
              if (!segment.isInResult() || segment.ringOut)
                continue;
              let prevEvent = null;
              let event = segment.leftSE;
              let nextEvent = segment.rightSE;
              const events = [event];
              const startingPoint = event.point;
              const intersectionLEs = [];
              while (true) {
                prevEvent = event;
                event = nextEvent;
                events.push(event);
                if (event.point === startingPoint)
                  break;
                while (true) {
                  const availableLEs = event.getAvailableLinkedEvents();
                  if (availableLEs.length === 0) {
                    const firstPt = events[0].point;
                    const lastPt = events[events.length - 1].point;
                    throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
                  }
                  if (availableLEs.length === 1) {
                    nextEvent = availableLEs[0].otherSE;
                    break;
                  }
                  let indexLE = null;
                  for (let j2 = 0, jMax = intersectionLEs.length; j2 < jMax; j2++) {
                    if (intersectionLEs[j2].point === event.point) {
                      indexLE = j2;
                      break;
                    }
                  }
                  if (indexLE !== null) {
                    const intersectionLE = intersectionLEs.splice(indexLE)[0];
                    const ringEvents = events.splice(intersectionLE.index);
                    ringEvents.unshift(ringEvents[0].otherSE);
                    ringsOut.push(new RingOut2(ringEvents.reverse()));
                    continue;
                  }
                  intersectionLEs.push({
                    index: events.length,
                    point: event.point
                  });
                  const comparator = event.getLeftmostComparator(prevEvent);
                  nextEvent = availableLEs.sort(comparator)[0].otherSE;
                  break;
                }
              }
              ringsOut.push(new RingOut2(events));
            }
            return ringsOut;
          }
          constructor(events) {
            this.events = events;
            for (let i3 = 0, iMax = events.length; i3 < iMax; i3++) {
              events[i3].segment.ringOut = this;
            }
            this.poly = null;
          }
          getGeom() {
            let prevPt = this.events[0].point;
            const points = [prevPt];
            for (let i3 = 1, iMax = this.events.length - 1; i3 < iMax; i3++) {
              const pt3 = this.events[i3].point;
              const nextPt2 = this.events[i3 + 1].point;
              if (compareVectorAngles(pt3, prevPt, nextPt2) === 0)
                continue;
              points.push(pt3);
              prevPt = pt3;
            }
            if (points.length === 1)
              return null;
            const pt2 = points[0];
            const nextPt = points[1];
            if (compareVectorAngles(pt2, prevPt, nextPt) === 0)
              points.shift();
            points.push(points[0]);
            const step = this.isExteriorRing() ? 1 : -1;
            const iStart = this.isExteriorRing() ? 0 : points.length - 1;
            const iEnd = this.isExteriorRing() ? points.length : -1;
            const orderedPoints = [];
            for (let i3 = iStart; i3 != iEnd; i3 += step)
              orderedPoints.push([points[i3].x, points[i3].y]);
            return orderedPoints;
          }
          isExteriorRing() {
            if (this._isExteriorRing === void 0) {
              const enclosing = this.enclosingRing();
              this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
            }
            return this._isExteriorRing;
          }
          enclosingRing() {
            if (this._enclosingRing === void 0) {
              this._enclosingRing = this._calcEnclosingRing();
            }
            return this._enclosingRing;
          }
          /* Returns the ring that encloses this one, if any */
          _calcEnclosingRing() {
            let leftMostEvt = this.events[0];
            for (let i3 = 1, iMax = this.events.length; i3 < iMax; i3++) {
              const evt = this.events[i3];
              if (SweepEvent2.compare(leftMostEvt, evt) > 0)
                leftMostEvt = evt;
            }
            let prevSeg = leftMostEvt.segment.prevInResult();
            let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
            while (true) {
              if (!prevSeg)
                return null;
              if (!prevPrevSeg)
                return prevSeg.ringOut;
              if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
                if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
                  return prevSeg.ringOut;
                } else
                  return prevSeg.ringOut.enclosingRing();
              }
              prevSeg = prevPrevSeg.prevInResult();
              prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
            }
          }
        }
        class PolyOut2 {
          constructor(exteriorRing) {
            this.exteriorRing = exteriorRing;
            exteriorRing.poly = this;
            this.interiorRings = [];
          }
          addInterior(ring) {
            this.interiorRings.push(ring);
            ring.poly = this;
          }
          getGeom() {
            const geom = [this.exteriorRing.getGeom()];
            if (geom[0] === null)
              return null;
            for (let i3 = 0, iMax = this.interiorRings.length; i3 < iMax; i3++) {
              const ringGeom = this.interiorRings[i3].getGeom();
              if (ringGeom === null)
                continue;
              geom.push(ringGeom);
            }
            return geom;
          }
        }
        class MultiPolyOut2 {
          constructor(rings) {
            this.rings = rings;
            this.polys = this._composePolys(rings);
          }
          getGeom() {
            const geom = [];
            for (let i3 = 0, iMax = this.polys.length; i3 < iMax; i3++) {
              const polyGeom = this.polys[i3].getGeom();
              if (polyGeom === null)
                continue;
              geom.push(polyGeom);
            }
            return geom;
          }
          _composePolys(rings) {
            const polys = [];
            for (let i3 = 0, iMax = rings.length; i3 < iMax; i3++) {
              const ring = rings[i3];
              if (ring.poly)
                continue;
              if (ring.isExteriorRing())
                polys.push(new PolyOut2(ring));
              else {
                const enclosingRing = ring.enclosingRing();
                if (!enclosingRing.poly)
                  polys.push(new PolyOut2(enclosingRing));
                enclosingRing.poly.addInterior(ring);
              }
            }
            return polys;
          }
        }
        class SweepLine2 {
          constructor(queue) {
            let comparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Segment2.compare;
            this.queue = queue;
            this.tree = new Tree(comparator);
            this.segments = [];
          }
          process(event) {
            const segment = event.segment;
            const newEvents = [];
            if (event.consumedBy) {
              if (event.isLeft)
                this.queue.remove(event.otherSE);
              else
                this.tree.remove(segment);
              return newEvents;
            }
            const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);
            if (!node)
              throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + "in SweepLine tree.");
            let prevNode = node;
            let nextNode = node;
            let prevSeg = void 0;
            let nextSeg = void 0;
            while (prevSeg === void 0) {
              prevNode = this.tree.prev(prevNode);
              if (prevNode === null)
                prevSeg = null;
              else if (prevNode.key.consumedBy === void 0)
                prevSeg = prevNode.key;
            }
            while (nextSeg === void 0) {
              nextNode = this.tree.next(nextNode);
              if (nextNode === null)
                nextSeg = null;
              else if (nextNode.key.consumedBy === void 0)
                nextSeg = nextNode.key;
            }
            if (event.isLeft) {
              let prevMySplitter = null;
              if (prevSeg) {
                const prevInter = prevSeg.getIntersection(segment);
                if (prevInter !== null) {
                  if (!segment.isAnEndpoint(prevInter))
                    prevMySplitter = prevInter;
                  if (!prevSeg.isAnEndpoint(prevInter)) {
                    const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
                    for (let i3 = 0, iMax = newEventsFromSplit.length; i3 < iMax; i3++) {
                      newEvents.push(newEventsFromSplit[i3]);
                    }
                  }
                }
              }
              let nextMySplitter = null;
              if (nextSeg) {
                const nextInter = nextSeg.getIntersection(segment);
                if (nextInter !== null) {
                  if (!segment.isAnEndpoint(nextInter))
                    nextMySplitter = nextInter;
                  if (!nextSeg.isAnEndpoint(nextInter)) {
                    const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
                    for (let i3 = 0, iMax = newEventsFromSplit.length; i3 < iMax; i3++) {
                      newEvents.push(newEventsFromSplit[i3]);
                    }
                  }
                }
              }
              if (prevMySplitter !== null || nextMySplitter !== null) {
                let mySplitter = null;
                if (prevMySplitter === null)
                  mySplitter = nextMySplitter;
                else if (nextMySplitter === null)
                  mySplitter = prevMySplitter;
                else {
                  const cmpSplitters = SweepEvent2.comparePoints(prevMySplitter, nextMySplitter);
                  mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
                }
                this.queue.remove(segment.rightSE);
                newEvents.push(segment.rightSE);
                const newEventsFromSplit = segment.split(mySplitter);
                for (let i3 = 0, iMax = newEventsFromSplit.length; i3 < iMax; i3++) {
                  newEvents.push(newEventsFromSplit[i3]);
                }
              }
              if (newEvents.length > 0) {
                this.tree.remove(segment);
                newEvents.push(event);
              } else {
                this.segments.push(segment);
                segment.prev = prevSeg;
              }
            } else {
              if (prevSeg && nextSeg) {
                const inter = prevSeg.getIntersection(nextSeg);
                if (inter !== null) {
                  if (!prevSeg.isAnEndpoint(inter)) {
                    const newEventsFromSplit = this._splitSafely(prevSeg, inter);
                    for (let i3 = 0, iMax = newEventsFromSplit.length; i3 < iMax; i3++) {
                      newEvents.push(newEventsFromSplit[i3]);
                    }
                  }
                  if (!nextSeg.isAnEndpoint(inter)) {
                    const newEventsFromSplit = this._splitSafely(nextSeg, inter);
                    for (let i3 = 0, iMax = newEventsFromSplit.length; i3 < iMax; i3++) {
                      newEvents.push(newEventsFromSplit[i3]);
                    }
                  }
                }
              }
              this.tree.remove(segment);
            }
            return newEvents;
          }
          /* Safely split a segment that is currently in the datastructures
           * IE - a segment other than the one that is currently being processed. */
          _splitSafely(seg, pt2) {
            this.tree.remove(seg);
            const rightSE = seg.rightSE;
            this.queue.remove(rightSE);
            const newEvents = seg.split(pt2);
            newEvents.push(rightSE);
            if (seg.consumedBy === void 0)
              this.tree.add(seg);
            return newEvents;
          }
        }
        const POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6;
        const POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
        class Operation2 {
          run(type2, geom, moreGeoms) {
            operation2.type = type2;
            rounder.reset();
            const multipolys = [new MultiPolyIn2(geom, true)];
            for (let i3 = 0, iMax = moreGeoms.length; i3 < iMax; i3++) {
              multipolys.push(new MultiPolyIn2(moreGeoms[i3], false));
            }
            operation2.numMultiPolys = multipolys.length;
            if (operation2.type === "difference") {
              const subject = multipolys[0];
              let i3 = 1;
              while (i3 < multipolys.length) {
                if (getBboxOverlap2(multipolys[i3].bbox, subject.bbox) !== null)
                  i3++;
                else
                  multipolys.splice(i3, 1);
              }
            }
            if (operation2.type === "intersection") {
              for (let i3 = 0, iMax = multipolys.length; i3 < iMax; i3++) {
                const mpA = multipolys[i3];
                for (let j2 = i3 + 1, jMax = multipolys.length; j2 < jMax; j2++) {
                  if (getBboxOverlap2(mpA.bbox, multipolys[j2].bbox) === null)
                    return [];
                }
              }
            }
            const queue = new Tree(SweepEvent2.compare);
            for (let i3 = 0, iMax = multipolys.length; i3 < iMax; i3++) {
              const sweepEvents = multipolys[i3].getSweepEvents();
              for (let j2 = 0, jMax = sweepEvents.length; j2 < jMax; j2++) {
                queue.insert(sweepEvents[j2]);
                if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                  throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).");
                }
              }
            }
            const sweepLine = new SweepLine2(queue);
            let prevQueueSize = queue.size;
            let node = queue.pop();
            while (node) {
              const evt = node.key;
              if (queue.size === prevQueueSize) {
                const seg = evt.segment;
                throw new Error("Unable to pop() ".concat(evt.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue."));
              }
              if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");
              }
              if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
                throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");
              }
              const newEvents = sweepLine.process(evt);
              for (let i3 = 0, iMax = newEvents.length; i3 < iMax; i3++) {
                const evt2 = newEvents[i3];
                if (evt2.consumedBy === void 0)
                  queue.insert(evt2);
              }
              prevQueueSize = queue.size;
              node = queue.pop();
            }
            rounder.reset();
            const ringsOut = RingOut2.factory(sweepLine.segments);
            const result = new MultiPolyOut2(ringsOut);
            return result.getGeom();
          }
        }
        const operation2 = new Operation2();
        const union2 = function(geom) {
          for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            moreGeoms[_key - 1] = arguments[_key];
          }
          return operation2.run("union", geom, moreGeoms);
        };
        const intersection2 = function(geom) {
          for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            moreGeoms[_key2 - 1] = arguments[_key2];
          }
          return operation2.run("intersection", geom, moreGeoms);
        };
        const xor = function(geom) {
          for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            moreGeoms[_key3 - 1] = arguments[_key3];
          }
          return operation2.run("xor", geom, moreGeoms);
        };
        const difference2 = function(subjectGeom) {
          for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            clippingGeoms[_key4 - 1] = arguments[_key4];
          }
          return operation2.run("difference", subjectGeom, clippingGeoms);
        };
        var index = {
          union: union2,
          intersection: intersection2,
          xor,
          difference: difference2
        };
        return index;
      });
    }
  });

  // node_modules/whatwg-fetch/fetch.js
  var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
  typeof global !== "undefined" && global || {};
  var support = {
    searchParams: "URLSearchParams" in g,
    iterable: "Symbol" in g && "iterator" in Symbol,
    blob: "FileReader" in g && "Blob" in g && function() {
      try {
        new Blob();
        return true;
      } catch (e3) {
        return false;
      }
    }(),
    formData: "FormData" in g,
    arrayBuffer: "ArrayBuffer" in g
  };
  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj);
  }
  if (support.arrayBuffer) {
    viewClasses = [
      "[object Int8Array]",
      "[object Uint8Array]",
      "[object Uint8ClampedArray]",
      "[object Int16Array]",
      "[object Uint16Array]",
      "[object Int32Array]",
      "[object Uint32Array]",
      "[object Float32Array]",
      "[object Float64Array]"
    ];
    isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
    };
  }
  var viewClasses;
  var isArrayBufferView;
  function normalizeName(name) {
    if (typeof name !== "string") {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
      throw new TypeError('Invalid character in header field name: "' + name + '"');
    }
    return name.toLowerCase();
  }
  function normalizeValue(value) {
    if (typeof value !== "string") {
      value = String(value);
    }
    return value;
  }
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return { done: value === void 0, value };
      }
    };
    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator;
      };
    }
    return iterator;
  }
  function Headers(headers) {
    this.map = {};
    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        if (header.length != 2) {
          throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
        }
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }
  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ", " + value : value;
  };
  Headers.prototype["delete"] = function(name) {
    delete this.map[normalizeName(name)];
  };
  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null;
  };
  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name));
  };
  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };
  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };
  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items);
  };
  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items);
  };
  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items);
  };
  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }
  function consumed(body) {
    if (body._noBody)
      return;
    if (body.bodyUsed) {
      return Promise.reject(new TypeError("Already read"));
    }
    body.bodyUsed = true;
  }
  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    });
  }
  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise;
  }
  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
    var encoding = match ? match[1] : "utf-8";
    reader.readAsText(blob, encoding);
    return promise;
  }
  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);
    for (var i3 = 0; i3 < view.length; i3++) {
      chars[i3] = String.fromCharCode(view[i3]);
    }
    return chars.join("");
  }
  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0);
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer;
    }
  }
  function Body() {
    this.bodyUsed = false;
    this._initBody = function(body) {
      this.bodyUsed = this.bodyUsed;
      this._bodyInit = body;
      if (!body) {
        this._noBody = true;
        this._bodyText = "";
      } else if (typeof body === "string") {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }
      if (!this.headers.get("content-type")) {
        if (typeof body === "string") {
          this.headers.set("content-type", "text/plain;charset=UTF-8");
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set("content-type", this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
        }
      }
    };
    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected;
        }
        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]));
        } else if (this._bodyFormData) {
          throw new Error("could not read FormData body as blob");
        } else {
          return Promise.resolve(new Blob([this._bodyText]));
        }
      };
    }
    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        var isConsumed = consumed(this);
        if (isConsumed) {
          return isConsumed;
        } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
          return Promise.resolve(
            this._bodyArrayBuffer.buffer.slice(
              this._bodyArrayBuffer.byteOffset,
              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
            )
          );
        } else {
          return Promise.resolve(this._bodyArrayBuffer);
        }
      } else if (support.blob) {
        return this.blob().then(readBlobAsArrayBuffer);
      } else {
        throw new Error("could not read as ArrayBuffer");
      }
    };
    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as text");
      } else {
        return Promise.resolve(this._bodyText);
      }
    };
    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode);
      };
    }
    this.json = function() {
      return this.text().then(JSON.parse);
    };
    return this;
  }
  var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method;
  }
  function Request(input, options2) {
    if (!(this instanceof Request)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    }
    options2 = options2 || {};
    var body = options2.body;
    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError("Already read");
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options2.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }
    this.credentials = options2.credentials || this.credentials || "same-origin";
    if (options2.headers || !this.headers) {
      this.headers = new Headers(options2.headers);
    }
    this.method = normalizeMethod(options2.method || this.method || "GET");
    this.mode = options2.mode || this.mode || null;
    this.signal = options2.signal || this.signal || function() {
      if ("AbortController" in g) {
        var ctrl = new AbortController();
        return ctrl.signal;
      }
    }();
    this.referrer = null;
    if ((this.method === "GET" || this.method === "HEAD") && body) {
      throw new TypeError("Body not allowed for GET or HEAD requests");
    }
    this._initBody(body);
    if (this.method === "GET" || this.method === "HEAD") {
      if (options2.cache === "no-store" || options2.cache === "no-cache") {
        var reParamSearch = /([?&])_=[^&]*/;
        if (reParamSearch.test(this.url)) {
          this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
        } else {
          var reQueryString = /\?/;
          this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
        }
      }
    }
  }
  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit });
  };
  function decode(body) {
    var form = new FormData();
    body.trim().split("&").forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split("=");
        var name = split.shift().replace(/\+/g, " ");
        var value = split.join("=").replace(/\+/g, " ");
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form;
  }
  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
    preProcessedHeaders.split("\r").map(function(header) {
      return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
    }).forEach(function(line) {
      var parts = line.split(":");
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(":").trim();
        try {
          headers.append(key, value);
        } catch (error) {
          console.warn("Response " + error.message);
        }
      }
    });
    return headers;
  }
  Body.call(Request.prototype);
  function Response(bodyInit, options2) {
    if (!(this instanceof Response)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    }
    if (!options2) {
      options2 = {};
    }
    this.type = "default";
    this.status = options2.status === void 0 ? 200 : options2.status;
    if (this.status < 200 || this.status > 599) {
      throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
    }
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options2.statusText === void 0 ? "" : "" + options2.statusText;
    this.headers = new Headers(options2.headers);
    this.url = options2.url || "";
    this._initBody(bodyInit);
  }
  Body.call(Response.prototype);
  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    });
  };
  Response.error = function() {
    var response = new Response(null, { status: 200, statusText: "" });
    response.ok = false;
    response.status = 0;
    response.type = "error";
    return response;
  };
  var redirectStatuses = [301, 302, 303, 307, 308];
  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError("Invalid status code");
    }
    return new Response(null, { status, headers: { location: url } });
  };
  var DOMException2 = g.DOMException;
  try {
    new DOMException2();
  } catch (err) {
    DOMException2 = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    DOMException2.prototype = Object.create(Error.prototype);
    DOMException2.prototype.constructor = DOMException2;
  }
  function fetch2(input, init2) {
    return new Promise(function(resolve, reject) {
      var request3 = new Request(input, init2);
      if (request3.signal && request3.signal.aborted) {
        return reject(new DOMException2("Aborted", "AbortError"));
      }
      var xhr = new XMLHttpRequest();
      function abortXhr() {
        xhr.abort();
      }
      xhr.onload = function() {
        var options2 = {
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || "")
        };
        if (request3.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
          options2.status = 200;
        } else {
          options2.status = xhr.status;
        }
        options2.url = "responseURL" in xhr ? xhr.responseURL : options2.headers.get("X-Request-URL");
        var body = "response" in xhr ? xhr.response : xhr.responseText;
        setTimeout(function() {
          resolve(new Response(body, options2));
        }, 0);
      };
      xhr.onerror = function() {
        setTimeout(function() {
          reject(new TypeError("Network request failed"));
        }, 0);
      };
      xhr.ontimeout = function() {
        setTimeout(function() {
          reject(new TypeError("Network request timed out"));
        }, 0);
      };
      xhr.onabort = function() {
        setTimeout(function() {
          reject(new DOMException2("Aborted", "AbortError"));
        }, 0);
      };
      function fixUrl(url) {
        try {
          return url === "" && g.location.href ? g.location.href : url;
        } catch (e3) {
          return url;
        }
      }
      xhr.open(request3.method, fixUrl(request3.url), true);
      if (request3.credentials === "include") {
        xhr.withCredentials = true;
      } else if (request3.credentials === "omit") {
        xhr.withCredentials = false;
      }
      if ("responseType" in xhr) {
        if (support.blob) {
          xhr.responseType = "blob";
        } else if (support.arrayBuffer) {
          xhr.responseType = "arraybuffer";
        }
      }
      if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers || g.Headers && init2.headers instanceof g.Headers)) {
        var names = [];
        Object.getOwnPropertyNames(init2.headers).forEach(function(name) {
          names.push(normalizeName(name));
          xhr.setRequestHeader(name, normalizeValue(init2.headers[name]));
        });
        request3.headers.forEach(function(value, name) {
          if (names.indexOf(name) === -1) {
            xhr.setRequestHeader(name, value);
          }
        });
      } else {
        request3.headers.forEach(function(value, name) {
          xhr.setRequestHeader(name, value);
        });
      }
      if (request3.signal) {
        request3.signal.addEventListener("abort", abortXhr);
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            request3.signal.removeEventListener("abort", abortXhr);
          }
        };
      }
      xhr.send(typeof request3._bodyInit === "undefined" ? null : request3._bodyInit);
    });
  }
  fetch2.polyfill = true;
  if (!g.fetch) {
    g.fetch = fetch2;
    g.Headers = Headers;
    g.Request = Request;
    g.Response = Response;
  }

  // node_modules/abortcontroller-polyfill/dist/polyfill-patch-fetch.js
  (function(factory) {
    typeof define === "function" && define.amd ? define(factory) : factory();
  })(function() {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf(o2);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e3) {
        return false;
      }
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _get() {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get.bind();
      } else {
        _get = function _get2(target, property, receiver) {
          var base = _superPropBase(target, property);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }
          return desc.value;
        };
      }
      return _get.apply(this, arguments);
    }
    var Emitter = /* @__PURE__ */ function() {
      function Emitter2() {
        _classCallCheck(this, Emitter2);
        Object.defineProperty(this, "listeners", {
          value: {},
          writable: true,
          configurable: true
        });
      }
      _createClass(Emitter2, [{
        key: "addEventListener",
        value: function addEventListener(type2, callback, options2) {
          if (!(type2 in this.listeners)) {
            this.listeners[type2] = [];
          }
          this.listeners[type2].push({
            callback,
            options: options2
          });
        }
      }, {
        key: "removeEventListener",
        value: function removeEventListener(type2, callback) {
          if (!(type2 in this.listeners)) {
            return;
          }
          var stack = this.listeners[type2];
          for (var i3 = 0, l2 = stack.length; i3 < l2; i3++) {
            if (stack[i3].callback === callback) {
              stack.splice(i3, 1);
              return;
            }
          }
        }
      }, {
        key: "dispatchEvent",
        value: function dispatchEvent2(event) {
          if (!(event.type in this.listeners)) {
            return;
          }
          var stack = this.listeners[event.type];
          var stackToCall = stack.slice();
          for (var i3 = 0, l2 = stackToCall.length; i3 < l2; i3++) {
            var listener = stackToCall[i3];
            try {
              listener.callback.call(this, event);
            } catch (e3) {
              Promise.resolve().then(function() {
                throw e3;
              });
            }
            if (listener.options && listener.options.once) {
              this.removeEventListener(event.type, listener.callback);
            }
          }
          return !event.defaultPrevented;
        }
      }]);
      return Emitter2;
    }();
    var AbortSignal = /* @__PURE__ */ function(_Emitter) {
      _inherits(AbortSignal2, _Emitter);
      var _super = _createSuper(AbortSignal2);
      function AbortSignal2() {
        var _this;
        _classCallCheck(this, AbortSignal2);
        _this = _super.call(this);
        if (!_this.listeners) {
          Emitter.call(_assertThisInitialized(_this));
        }
        Object.defineProperty(_assertThisInitialized(_this), "aborted", {
          value: false,
          writable: true,
          configurable: true
        });
        Object.defineProperty(_assertThisInitialized(_this), "onabort", {
          value: null,
          writable: true,
          configurable: true
        });
        Object.defineProperty(_assertThisInitialized(_this), "reason", {
          value: void 0,
          writable: true,
          configurable: true
        });
        return _this;
      }
      _createClass(AbortSignal2, [{
        key: "toString",
        value: function toString2() {
          return "[object AbortSignal]";
        }
      }, {
        key: "dispatchEvent",
        value: function dispatchEvent2(event) {
          if (event.type === "abort") {
            this.aborted = true;
            if (typeof this.onabort === "function") {
              this.onabort.call(this, event);
            }
          }
          _get(_getPrototypeOf(AbortSignal2.prototype), "dispatchEvent", this).call(this, event);
        }
      }]);
      return AbortSignal2;
    }(Emitter);
    var AbortController2 = /* @__PURE__ */ function() {
      function AbortController3() {
        _classCallCheck(this, AbortController3);
        Object.defineProperty(this, "signal", {
          value: new AbortSignal(),
          writable: true,
          configurable: true
        });
      }
      _createClass(AbortController3, [{
        key: "abort",
        value: function abort(reason) {
          var event;
          try {
            event = new Event("abort");
          } catch (e3) {
            if (typeof document !== "undefined") {
              if (!document.createEvent) {
                event = document.createEventObject();
                event.type = "abort";
              } else {
                event = document.createEvent("Event");
                event.initEvent("abort", false, false);
              }
            } else {
              event = {
                type: "abort",
                bubbles: false,
                cancelable: false
              };
            }
          }
          var signalReason = reason;
          if (signalReason === void 0) {
            if (typeof document === "undefined") {
              signalReason = new Error("This operation was aborted");
              signalReason.name = "AbortError";
            } else {
              try {
                signalReason = new DOMException("signal is aborted without reason");
              } catch (err) {
                signalReason = new Error("This operation was aborted");
                signalReason.name = "AbortError";
              }
            }
          }
          this.signal.reason = signalReason;
          this.signal.dispatchEvent(event);
        }
      }, {
        key: "toString",
        value: function toString2() {
          return "[object AbortController]";
        }
      }]);
      return AbortController3;
    }();
    if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      AbortController2.prototype[Symbol.toStringTag] = "AbortController";
      AbortSignal.prototype[Symbol.toStringTag] = "AbortSignal";
    }
    function polyfillNeeded(self2) {
      if (self2.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
        console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill");
        return true;
      }
      return typeof self2.Request === "function" && !self2.Request.prototype.hasOwnProperty("signal") || !self2.AbortController;
    }
    function abortableFetchDecorator(patchTargets) {
      if ("function" === typeof patchTargets) {
        patchTargets = {
          fetch: patchTargets
        };
      }
      var _patchTargets = patchTargets, fetch3 = _patchTargets.fetch, _patchTargets$Request = _patchTargets.Request, NativeRequest = _patchTargets$Request === void 0 ? fetch3.Request : _patchTargets$Request, NativeAbortController = _patchTargets.AbortController, _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL, __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;
      if (!polyfillNeeded({
        fetch: fetch3,
        Request: NativeRequest,
        AbortController: NativeAbortController,
        __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL
      })) {
        return {
          fetch: fetch3,
          Request: Request2
        };
      }
      var Request2 = NativeRequest;
      if (Request2 && !Request2.prototype.hasOwnProperty("signal") || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
        Request2 = function Request3(input, init2) {
          var signal;
          if (init2 && init2.signal) {
            signal = init2.signal;
            delete init2.signal;
          }
          var request3 = new NativeRequest(input, init2);
          if (signal) {
            Object.defineProperty(request3, "signal", {
              writable: false,
              enumerable: false,
              configurable: true,
              value: signal
            });
          }
          return request3;
        };
        Request2.prototype = NativeRequest.prototype;
      }
      var realFetch = fetch3;
      var abortableFetch = function abortableFetch2(input, init2) {
        var signal = Request2 && Request2.prototype.isPrototypeOf(input) ? input.signal : init2 ? init2.signal : void 0;
        if (signal) {
          var abortError;
          try {
            abortError = new DOMException("Aborted", "AbortError");
          } catch (err) {
            abortError = new Error("Aborted");
            abortError.name = "AbortError";
          }
          if (signal.aborted) {
            return Promise.reject(abortError);
          }
          var cancellation = new Promise(function(_2, reject) {
            signal.addEventListener("abort", function() {
              return reject(abortError);
            }, {
              once: true
            });
          });
          if (init2 && init2.signal) {
            delete init2.signal;
          }
          return Promise.race([cancellation, realFetch(input, init2)]);
        }
        return realFetch(input, init2);
      };
      return {
        fetch: abortableFetch,
        Request: Request2
      };
    }
    (function(self2) {
      if (!polyfillNeeded(self2)) {
        return;
      }
      if (!self2.fetch) {
        console.warn("fetch() is not available, cannot install abortcontroller-polyfill");
        return;
      }
      var _abortableFetch = abortableFetchDecorator(self2), fetch3 = _abortableFetch.fetch, Request2 = _abortableFetch.Request;
      self2.fetch = fetch3;
      self2.Request = Request2;
      Object.defineProperty(self2, "AbortController", {
        writable: true,
        enumerable: false,
        configurable: true,
        value: AbortController2
      });
      Object.defineProperty(self2, "AbortSignal", {
        writable: true,
        enumerable: false,
        configurable: true,
        value: AbortSignal
      });
    })(typeof self !== "undefined" ? self : global);
  });

  // modules/index.js
  var modules_exports = {};
  __export(modules_exports, {
    LocationManager: () => LocationManager,
    QAItem: () => QAItem,
    actionAddEntity: () => actionAddEntity,
    actionAddMember: () => actionAddMember,
    actionAddMidpoint: () => actionAddMidpoint,
    actionAddVertex: () => actionAddVertex,
    actionChangeMember: () => actionChangeMember,
    actionChangePreset: () => actionChangePreset,
    actionChangeTags: () => actionChangeTags,
    actionCircularize: () => actionCircularize,
    actionConnect: () => actionConnect,
    actionCopyEntities: () => actionCopyEntities,
    actionDeleteMember: () => actionDeleteMember,
    actionDeleteMultiple: () => actionDeleteMultiple,
    actionDeleteNode: () => actionDeleteNode,
    actionDeleteRelation: () => actionDeleteRelation,
    actionDeleteWay: () => actionDeleteWay,
    actionDiscardTags: () => actionDiscardTags,
    actionDisconnect: () => actionDisconnect,
    actionExtract: () => actionExtract,
    actionJoin: () => actionJoin,
    actionMerge: () => actionMerge,
    actionMergeNodes: () => actionMergeNodes,
    actionMergePolygon: () => actionMergePolygon,
    actionMergeRemoteChanges: () => actionMergeRemoteChanges,
    actionMove: () => actionMove,
    actionMoveMember: () => actionMoveMember,
    actionMoveNode: () => actionMoveNode,
    actionNoop: () => actionNoop,
    actionOrthogonalize: () => actionOrthogonalize,
    actionReflect: () => actionReflect,
    actionRestrictTurn: () => actionRestrictTurn,
    actionReverse: () => actionReverse,
    actionRevert: () => actionRevert,
    actionRotate: () => actionRotate,
    actionScale: () => actionScale,
    actionSplit: () => actionSplit,
    actionStraightenNodes: () => actionStraightenNodes,
    actionStraightenWay: () => actionStraightenWay,
    actionUnrestrictTurn: () => actionUnrestrictTurn,
    actionUpgradeTags: () => actionUpgradeTags,
    behaviorAddWay: () => behaviorAddWay,
    behaviorBreathe: () => behaviorBreathe,
    behaviorDrag: () => behaviorDrag,
    behaviorDraw: () => behaviorDraw,
    behaviorDrawWay: () => behaviorDrawWay,
    behaviorEdit: () => behaviorEdit,
    behaviorHash: () => behaviorHash,
    behaviorHover: () => behaviorHover,
    behaviorLasso: () => behaviorLasso,
    behaviorOperation: () => behaviorOperation,
    behaviorPaste: () => behaviorPaste,
    behaviorSelect: () => behaviorSelect,
    coreContext: () => coreContext,
    coreDifference: () => coreDifference,
    coreFileFetcher: () => coreFileFetcher,
    coreGraph: () => coreGraph,
    coreHistory: () => coreHistory,
    coreLocalizer: () => coreLocalizer,
    coreTree: () => coreTree,
    coreUploader: () => coreUploader,
    coreValidator: () => coreValidator,
    d3: () => d3,
    debug: () => debug,
    dmsCoordinatePair: () => dmsCoordinatePair,
    dmsMatcher: () => dmsMatcher,
    fileFetcher: () => _mainFileFetcher,
    geoAngle: () => geoAngle,
    geoChooseEdge: () => geoChooseEdge,
    geoEdgeEqual: () => geoEdgeEqual,
    geoExtent: () => geoExtent,
    geoGetSmallestSurroundingRectangle: () => geoGetSmallestSurroundingRectangle,
    geoHasLineIntersections: () => geoHasLineIntersections,
    geoHasSelfIntersections: () => geoHasSelfIntersections,
    geoLatToMeters: () => geoLatToMeters,
    geoLineIntersection: () => geoLineIntersection,
    geoLonToMeters: () => geoLonToMeters,
    geoMetersToLat: () => geoMetersToLat,
    geoMetersToLon: () => geoMetersToLon,
    geoMetersToOffset: () => geoMetersToOffset,
    geoOffsetToMeters: () => geoOffsetToMeters,
    geoOrthoCalcScore: () => geoOrthoCalcScore,
    geoOrthoCanOrthogonalize: () => geoOrthoCanOrthogonalize,
    geoOrthoMaxOffsetAngle: () => geoOrthoMaxOffsetAngle,
    geoOrthoNormalizedDotProduct: () => geoOrthoNormalizedDotProduct,
    geoPathHasIntersections: () => geoPathHasIntersections,
    geoPathIntersections: () => geoPathIntersections,
    geoPathLength: () => geoPathLength,
    geoPointInPolygon: () => geoPointInPolygon,
    geoPolygonContainsPolygon: () => geoPolygonContainsPolygon,
    geoPolygonIntersectsPolygon: () => geoPolygonIntersectsPolygon,
    geoRawMercator: () => geoRawMercator,
    geoRotate: () => geoRotate,
    geoScaleToZoom: () => geoScaleToZoom,
    geoSphericalClosestNode: () => geoSphericalClosestNode,
    geoSphericalDistance: () => geoSphericalDistance,
    geoVecAdd: () => geoVecAdd,
    geoVecAngle: () => geoVecAngle,
    geoVecCross: () => geoVecCross,
    geoVecDot: () => geoVecDot,
    geoVecEqual: () => geoVecEqual,
    geoVecFloor: () => geoVecFloor,
    geoVecInterp: () => geoVecInterp,
    geoVecLength: () => geoVecLength,
    geoVecLengthSquare: () => geoVecLengthSquare,
    geoVecNormalize: () => geoVecNormalize,
    geoVecNormalizedDot: () => geoVecNormalizedDot,
    geoVecProject: () => geoVecProject,
    geoVecScale: () => geoVecScale,
    geoVecSubtract: () => geoVecSubtract,
    geoViewportEdge: () => geoViewportEdge,
    geoZoomToScale: () => geoZoomToScale,
    likelyRawNumberFormat: () => likelyRawNumberFormat,
    localizer: () => _mainLocalizer,
    locationManager: () => _sharedLocationManager,
    modeAddArea: () => modeAddArea,
    modeAddLine: () => modeAddLine,
    modeAddNote: () => modeAddNote,
    modeAddPoint: () => modeAddPoint,
    modeBrowse: () => modeBrowse,
    modeDragNode: () => modeDragNode,
    modeDragNote: () => modeDragNote,
    modeDrawArea: () => modeDrawArea,
    modeDrawLine: () => modeDrawLine,
    modeMove: () => modeMove,
    modeRotate: () => modeRotate,
    modeSave: () => modeSave,
    modeSelect: () => modeSelect,
    modeSelectData: () => modeSelectData,
    modeSelectError: () => modeSelectError,
    modeSelectNote: () => modeSelectNote,
    operationCircularize: () => operationCircularize,
    operationContinue: () => operationContinue,
    operationCopy: () => operationCopy,
    operationDelete: () => operationDelete,
    operationDisconnect: () => operationDisconnect,
    operationDowngrade: () => operationDowngrade,
    operationExtract: () => operationExtract,
    operationMerge: () => operationMerge,
    operationMove: () => operationMove,
    operationOrthogonalize: () => operationOrthogonalize,
    operationPaste: () => operationPaste,
    operationReflectLong: () => operationReflectLong,
    operationReflectShort: () => operationReflectShort,
    operationReverse: () => operationReverse,
    operationRotate: () => operationRotate,
    operationSplit: () => operationSplit,
    operationStraighten: () => operationStraighten,
    osmAreaKeys: () => osmAreaKeys,
    osmChangeset: () => osmChangeset,
    osmEntity: () => osmEntity,
    osmFlowingWaterwayTagValues: () => osmFlowingWaterwayTagValues,
    osmInferRestriction: () => osmInferRestriction,
    osmIntersection: () => osmIntersection,
    osmIsInterestingTag: () => osmIsInterestingTag,
    osmJoinWays: () => osmJoinWays,
    osmLanes: () => osmLanes,
    osmLifecyclePrefixes: () => osmLifecyclePrefixes,
    osmNode: () => osmNode,
    osmNodeGeometriesForTags: () => osmNodeGeometriesForTags,
    osmNote: () => osmNote,
    osmOneWayTags: () => osmOneWayTags,
    osmPavedTags: () => osmPavedTags,
    osmPointTags: () => osmPointTags,
    osmRailwayTrackTagValues: () => osmRailwayTrackTagValues,
    osmRelation: () => osmRelation,
    osmRemoveLifecyclePrefix: () => osmRemoveLifecyclePrefix,
    osmRoutableHighwayTagValues: () => osmRoutableHighwayTagValues,
    osmSetAreaKeys: () => osmSetAreaKeys,
    osmSetPointTags: () => osmSetPointTags,
    osmSetVertexTags: () => osmSetVertexTags,
    osmTagSuggestingArea: () => osmTagSuggestingArea,
    osmTurn: () => osmTurn,
    osmVertexTags: () => osmVertexTags,
    osmWay: () => osmWay,
    prefs: () => corePreferences,
    presetCategory: () => presetCategory,
    presetCollection: () => presetCollection,
    presetField: () => presetField,
    presetIndex: () => presetIndex,
    presetManager: () => _mainPresetIndex,
    presetPreset: () => presetPreset,
    rendererBackground: () => rendererBackground,
    rendererBackgroundSource: () => rendererBackgroundSource,
    rendererFeatures: () => rendererFeatures,
    rendererMap: () => rendererMap,
    rendererPhotos: () => rendererPhotos,
    rendererTileLayer: () => rendererTileLayer,
    serviceImproveOSM: () => improveOSM_default,
    serviceKartaview: () => kartaview_default,
    serviceKeepRight: () => keepRight_default,
    serviceMapRules: () => maprules_default,
    serviceMapilio: () => mapilio_default,
    serviceMapillary: () => mapillary_default,
    serviceNominatim: () => nominatim_default,
    serviceNsi: () => nsi_default,
    serviceOsm: () => osm_default,
    serviceOsmWikibase: () => osm_wikibase_default,
    serviceOsmose: () => osmose_default,
    serviceStreetside: () => streetside_default,
    serviceTaginfo: () => taginfo_default,
    serviceVectorTile: () => vector_tile_default,
    serviceVegbilder: () => vegbilder_default,
    serviceWikidata: () => wikidata_default,
    serviceWikipedia: () => wikipedia_default,
    services: () => services,
    svgAreas: () => svgAreas,
    svgData: () => svgData,
    svgDebug: () => svgDebug,
    svgDefs: () => svgDefs,
    svgGeolocate: () => svgGeolocate,
    svgIcon: () => svgIcon,
    svgKartaviewImages: () => svgKartaviewImages,
    svgKeepRight: () => svgKeepRight,
    svgLabels: () => svgLabels,
    svgLayers: () => svgLayers,
    svgLines: () => svgLines,
    svgMapilioImages: () => svgMapilioImages,
    svgMapillaryImages: () => svgMapillaryImages,
    svgMapillarySigns: () => svgMapillarySigns,
    svgMarkerSegments: () => svgMarkerSegments,
    svgMidpoints: () => svgMidpoints,
    svgNotes: () => svgNotes,
    svgOsm: () => svgOsm,
    svgPassiveVertex: () => svgPassiveVertex,
    svgPath: () => svgPath,
    svgPointTransform: () => svgPointTransform,
    svgPoints: () => svgPoints,
    svgRelationMemberTags: () => svgRelationMemberTags,
    svgSegmentWay: () => svgSegmentWay,
    svgStreetside: () => svgStreetside,
    svgTagClasses: () => svgTagClasses,
    svgTagPattern: () => svgTagPattern,
    svgTouch: () => svgTouch,
    svgTurns: () => svgTurns,
    svgVegbilder: () => svgVegbilder,
    svgVertices: () => svgVertices,
    t: () => _t,
    uiAccount: () => uiAccount,
    uiAttribution: () => uiAttribution,
    uiChangesetEditor: () => uiChangesetEditor,
    uiCmd: () => uiCmd,
    uiCombobox: () => uiCombobox,
    uiCommit: () => uiCommit,
    uiCommitWarnings: () => uiCommitWarnings,
    uiConfirm: () => uiConfirm,
    uiConflicts: () => uiConflicts,
    uiContributors: () => uiContributors,
    uiCurtain: () => uiCurtain,
    uiDataEditor: () => uiDataEditor,
    uiDataHeader: () => uiDataHeader,
    uiDisclosure: () => uiDisclosure,
    uiEditMenu: () => uiEditMenu,
    uiEntityEditor: () => uiEntityEditor,
    uiFeatureInfo: () => uiFeatureInfo,
    uiFeatureList: () => uiFeatureList,
    uiField: () => uiField,
    uiFieldAccess: () => uiFieldAccess,
    uiFieldAddress: () => uiFieldAddress,
    uiFieldCheck: () => uiFieldCheck,
    uiFieldColour: () => uiFieldText,
    uiFieldCombo: () => uiFieldCombo,
    uiFieldDefaultCheck: () => uiFieldCheck,
    uiFieldDirectionalCombo: () => uiFieldDirectionalCombo,
    uiFieldEmail: () => uiFieldText,
    uiFieldHelp: () => uiFieldHelp,
    uiFieldIdentifier: () => uiFieldText,
    uiFieldLanes: () => uiFieldLanes,
    uiFieldLocalized: () => uiFieldLocalized,
    uiFieldManyCombo: () => uiFieldCombo,
    uiFieldMultiCombo: () => uiFieldCombo,
    uiFieldNetworkCombo: () => uiFieldCombo,
    uiFieldNumber: () => uiFieldText,
    uiFieldOnewayCheck: () => uiFieldCheck,
    uiFieldRadio: () => uiFieldRadio,
    uiFieldRestrictions: () => uiFieldRestrictions,
    uiFieldRoadheight: () => uiFieldRoadheight,
    uiFieldRoadspeed: () => uiFieldRoadspeed,
    uiFieldSemiCombo: () => uiFieldCombo,
    uiFieldStructureRadio: () => uiFieldRadio,
    uiFieldTel: () => uiFieldText,
    uiFieldText: () => uiFieldText,
    uiFieldTextarea: () => uiFieldTextarea,
    uiFieldTypeCombo: () => uiFieldCombo,
    uiFieldUrl: () => uiFieldText,
    uiFieldWikidata: () => uiFieldWikidata,
    uiFieldWikipedia: () => uiFieldWikipedia,
    uiFields: () => uiFields,
    uiFlash: () => uiFlash,
    uiFormFields: () => uiFormFields,
    uiFullScreen: () => uiFullScreen,
    uiGeolocate: () => uiGeolocate,
    uiImproveOsmComments: () => uiImproveOsmComments,
    uiImproveOsmDetails: () => uiImproveOsmDetails,
    uiImproveOsmEditor: () => uiImproveOsmEditor,
    uiImproveOsmHeader: () => uiImproveOsmHeader,
    uiInfo: () => uiInfo,
    uiInfoPanels: () => uiInfoPanels,
    uiInit: () => uiInit,
    uiInspector: () => uiInspector,
    uiIntro: () => uiIntro,
    uiIssuesInfo: () => uiIssuesInfo,
    uiKeepRightDetails: () => uiKeepRightDetails,
    uiKeepRightEditor: () => uiKeepRightEditor,
    uiKeepRightHeader: () => uiKeepRightHeader,
    uiLasso: () => uiLasso,
    uiLengthIndicator: () => uiLengthIndicator,
    uiLoading: () => uiLoading,
    uiMapInMap: () => uiMapInMap,
    uiModal: () => uiModal,
    uiNoteComments: () => uiNoteComments,
    uiNoteEditor: () => uiNoteEditor,
    uiNoteHeader: () => uiNoteHeader,
    uiNoteReport: () => uiNoteReport,
    uiNotice: () => uiNotice,
    uiPaneBackground: () => uiPaneBackground,
    uiPaneHelp: () => uiPaneHelp,
    uiPaneIssues: () => uiPaneIssues,
    uiPaneMapData: () => uiPaneMapData,
    uiPanePreferences: () => uiPanePreferences,
    uiPanelBackground: () => uiPanelBackground,
    uiPanelHistory: () => uiPanelHistory,
    uiPanelLocation: () => uiPanelLocation,
    uiPanelMeasurement: () => uiPanelMeasurement,
    uiPopover: () => uiPopover,
    uiPresetIcon: () => uiPresetIcon,
    uiPresetList: () => uiPresetList,
    uiRestore: () => uiRestore,
    uiScale: () => uiScale,
    uiSectionBackgroundDisplayOptions: () => uiSectionBackgroundDisplayOptions,
    uiSectionBackgroundList: () => uiSectionBackgroundList,
    uiSectionBackgroundOffset: () => uiSectionBackgroundOffset,
    uiSectionChanges: () => uiSectionChanges,
    uiSectionDataLayers: () => uiSectionDataLayers,
    uiSectionEntityIssues: () => uiSectionEntityIssues,
    uiSectionFeatureType: () => uiSectionFeatureType,
    uiSectionMapFeatures: () => uiSectionMapFeatures,
    uiSectionMapStyleOptions: () => uiSectionMapStyleOptions,
    uiSectionOverlayList: () => uiSectionOverlayList,
    uiSectionPhotoOverlays: () => uiSectionPhotoOverlays,
    uiSectionPresetFields: () => uiSectionPresetFields,
    uiSectionPrivacy: () => uiSectionPrivacy,
    uiSectionRawMemberEditor: () => uiSectionRawMemberEditor,
    uiSectionRawMembershipEditor: () => uiSectionRawMembershipEditor,
    uiSectionRawTagEditor: () => uiSectionRawTagEditor,
    uiSectionSelectionList: () => uiSectionSelectionList,
    uiSectionValidationIssues: () => uiSectionValidationIssues,
    uiSectionValidationOptions: () => uiSectionValidationOptions,
    uiSectionValidationRules: () => uiSectionValidationRules,
    uiSectionValidationStatus: () => uiSectionValidationStatus,
    uiSettingsCustomBackground: () => uiSettingsCustomBackground,
    uiSettingsCustomData: () => uiSettingsCustomData,
    uiSidebar: () => uiSidebar,
    uiSourceSwitch: () => uiSourceSwitch,
    uiSpinner: () => uiSpinner,
    uiSplash: () => uiSplash,
    uiStatus: () => uiStatus,
    uiSuccess: () => uiSuccess,
    uiTagReference: () => uiTagReference,
    uiToggle: () => uiToggle,
    uiTooltip: () => uiTooltip,
    uiVersion: () => uiVersion,
    uiViewOnKeepRight: () => uiViewOnKeepRight,
    uiViewOnOSM: () => uiViewOnOSM,
    uiZoom: () => uiZoom,
    utilAesDecrypt: () => utilAesDecrypt,
    utilAesEncrypt: () => utilAesEncrypt,
    utilArrayChunk: () => utilArrayChunk,
    utilArrayDifference: () => utilArrayDifference,
    utilArrayFlatten: () => utilArrayFlatten,
    utilArrayGroupBy: () => utilArrayGroupBy,
    utilArrayIdentical: () => utilArrayIdentical,
    utilArrayIntersection: () => utilArrayIntersection,
    utilArrayUnion: () => utilArrayUnion,
    utilArrayUniq: () => utilArrayUniq,
    utilArrayUniqBy: () => utilArrayUniqBy,
    utilAsyncMap: () => utilAsyncMap,
    utilCleanOsmString: () => utilCleanOsmString,
    utilCleanTags: () => utilCleanTags,
    utilCombinedTags: () => utilCombinedTags,
    utilCompareIDs: () => utilCompareIDs,
    utilDeepMemberSelector: () => utilDeepMemberSelector,
    utilDetect: () => utilDetect,
    utilDisplayLabel: () => utilDisplayLabel,
    utilDisplayName: () => utilDisplayName,
    utilDisplayNameForPath: () => utilDisplayNameForPath,
    utilDisplayType: () => utilDisplayType,
    utilEditDistance: () => utilEditDistance,
    utilEntityAndDeepMemberIDs: () => utilEntityAndDeepMemberIDs,
    utilEntityOrDeepMemberSelector: () => utilEntityOrDeepMemberSelector,
    utilEntityOrMemberSelector: () => utilEntityOrMemberSelector,
    utilEntityRoot: () => utilEntityRoot,
    utilEntitySelector: () => utilEntitySelector,
    utilFastMouse: () => utilFastMouse,
    utilFunctor: () => utilFunctor,
    utilGetAllNodes: () => utilGetAllNodes,
    utilGetSetValue: () => utilGetSetValue,
    utilHashcode: () => utilHashcode,
    utilHighlightEntities: () => utilHighlightEntities,
    utilKeybinding: () => utilKeybinding,
    utilNoAuto: () => utilNoAuto,
    utilObjectOmit: () => utilObjectOmit,
    utilOldestID: () => utilOldestID,
    utilPrefixCSSProperty: () => utilPrefixCSSProperty,
    utilPrefixDOMProperty: () => utilPrefixDOMProperty,
    utilQsString: () => utilQsString,
    utilRebind: () => utilRebind,
    utilSafeClassName: () => utilSafeClassName,
    utilSessionMutex: () => utilSessionMutex,
    utilSetTransform: () => utilSetTransform,
    utilStringQs: () => utilStringQs,
    utilTagDiff: () => utilTagDiff,
    utilTagText: () => utilTagText,
    utilTiler: () => utilTiler,
    utilTotalExtent: () => utilTotalExtent,
    utilTriggerEvent: () => utilTriggerEvent,
    utilUnicodeCharsCount: () => utilUnicodeCharsCount,
    utilUnicodeCharsTruncated: () => utilUnicodeCharsTruncated,
    utilUniqueDomId: () => utilUniqueDomId,
    utilWrap: () => utilWrap,
    validationAlmostJunction: () => validationAlmostJunction,
    validationCloseNodes: () => validationCloseNodes,
    validationCrossingWays: () => validationCrossingWays,
    validationDisconnectedWay: () => validationDisconnectedWay,
    validationFormatting: () => validationFormatting,
    validationHelpRequest: () => validationHelpRequest,
    validationImpossibleOneway: () => validationImpossibleOneway,
    validationIncompatibleSource: () => validationIncompatibleSource,
    validationMaprules: () => validationMaprules,
    validationMismatchedGeometry: () => validationMismatchedGeometry,
    validationMissingRole: () => validationMissingRole,
    validationMissingTag: () => validationMissingTag,
    validationMutuallyExclusiveTags: () => validationMutuallyExclusiveTags,
    validationOutdatedTags: () => validationOutdatedTags,
    validationPrivateData: () => validationPrivateData,
    validationSuspiciousName: () => validationSuspiciousName,
    validationUnsquareWay: () => validationUnsquareWay
  });

  // modules/actions/add_entity.js
  function actionAddEntity(way) {
    return function(graph) {
      return graph.replace(way);
    };
  }

  // modules/actions/reverse.js
  function actionReverse(entityID, options2) {
    var ignoreKey = /^.*(_|:)?(description|name|note|website|ref|source|comment|watch|attribution)(_|:)?/;
    var numeric = /^([+\-]?)(?=[\d.])/;
    var directionKey = /direction$/;
    var turn_lanes = /^turn:lanes:?/;
    var keyReplacements = [
      [/:right$/, ":left"],
      [/:left$/, ":right"],
      [/:forward$/, ":backward"],
      [/:backward$/, ":forward"],
      [/:right:/, ":left:"],
      [/:left:/, ":right:"],
      [/:forward:/, ":backward:"],
      [/:backward:/, ":forward:"]
    ];
    var valueReplacements = {
      left: "right",
      right: "left",
      up: "down",
      down: "up",
      forward: "backward",
      backward: "forward",
      forwards: "backward",
      backwards: "forward"
    };
    const valueReplacementsExceptions = {
      "side": [
        { highway: "cyclist_waiting_aid" }
      ]
    };
    var roleReplacements = {
      forward: "backward",
      backward: "forward",
      forwards: "backward",
      backwards: "forward"
    };
    var onewayReplacements = {
      yes: "-1",
      "1": "-1",
      "-1": "yes"
    };
    var compassReplacements = {
      N: "S",
      NNE: "SSW",
      NE: "SW",
      ENE: "WSW",
      E: "W",
      ESE: "WNW",
      SE: "NW",
      SSE: "NNW",
      S: "N",
      SSW: "NNE",
      SW: "NE",
      WSW: "ENE",
      W: "E",
      WNW: "ESE",
      NW: "SE",
      NNW: "SSE"
    };
    function reverseKey(key) {
      for (var i3 = 0; i3 < keyReplacements.length; ++i3) {
        var replacement = keyReplacements[i3];
        if (replacement[0].test(key)) {
          return key.replace(replacement[0], replacement[1]);
        }
      }
      return key;
    }
    function reverseValue(key, value, includeAbsolute, allTags) {
      if (ignoreKey.test(key))
        return value;
      if (turn_lanes.test(key)) {
        return value;
      } else if (key === "incline" && numeric.test(value)) {
        return value.replace(numeric, function(_2, sign2) {
          return sign2 === "-" ? "" : "-";
        });
      } else if (options2 && options2.reverseOneway && key === "oneway") {
        return onewayReplacements[value] || value;
      } else if (includeAbsolute && directionKey.test(key)) {
        return value.split(";").map((value2) => {
          if (compassReplacements[value2])
            return compassReplacements[value2];
          var degrees3 = Number(value2);
          if (isFinite(degrees3)) {
            if (degrees3 < 180) {
              degrees3 += 180;
            } else {
              degrees3 -= 180;
            }
            return degrees3.toString();
          } else {
            return valueReplacements[value2] || value2;
          }
        }).join(";");
      }
      if (valueReplacementsExceptions[key] && valueReplacementsExceptions[key].some(
        (exceptionTags) => Object.keys(exceptionTags).every((k2) => {
          const v2 = exceptionTags[k2];
          return allTags[k2] && (v2 === "*" || allTags[k2] === v2);
        })
      )) {
        return value;
      }
      return valueReplacements[value] || value;
    }
    function reverseNodeTags(graph, nodeIDs) {
      for (var i3 = 0; i3 < nodeIDs.length; i3++) {
        var node = graph.hasEntity(nodeIDs[i3]);
        if (!node || !Object.keys(node.tags).length)
          continue;
        var tags = {};
        for (var key in node.tags) {
          tags[reverseKey(key)] = reverseValue(key, node.tags[key], node.id === entityID, node.tags);
        }
        graph = graph.replace(node.update({ tags }));
      }
      return graph;
    }
    function reverseWay(graph, way) {
      var nodes = way.nodes.slice().reverse();
      var tags = {};
      var role;
      for (var key in way.tags) {
        tags[reverseKey(key)] = reverseValue(key, way.tags[key], false, way.tags);
      }
      graph.parentRelations(way).forEach(function(relation) {
        relation.members.forEach(function(member, index) {
          if (member.id === way.id && (role = roleReplacements[member.role])) {
            relation = relation.updateMember({ role }, index);
            graph = graph.replace(relation);
          }
        });
      });
      return reverseNodeTags(graph, nodes).replace(way.update({ nodes, tags }));
    }
    var action = function(graph) {
      var entity = graph.entity(entityID);
      if (entity.type === "way") {
        return reverseWay(graph, entity);
      }
      return reverseNodeTags(graph, [entityID]);
    };
    action.disabled = function(graph) {
      var entity = graph.hasEntity(entityID);
      if (!entity || entity.type === "way")
        return false;
      for (var key in entity.tags) {
        var value = entity.tags[key];
        if (reverseKey(key) !== key || reverseValue(key, value, true, entity.tags) !== value) {
          return false;
        }
      }
      return "nondirectional_node";
    };
    action.entityID = function() {
      return entityID;
    };
    return action;
  }

  // node_modules/d3-array/src/ascending.js
  function ascending(a2, b2) {
    return a2 == null || b2 == null ? NaN : a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
  }

  // node_modules/d3-array/src/descending.js
  function descending(a2, b2) {
    return a2 == null || b2 == null ? NaN : b2 < a2 ? -1 : b2 > a2 ? 1 : b2 >= a2 ? 0 : NaN;
  }

  // node_modules/d3-array/src/bisector.js
  function bisector(f2) {
    let compare1, compare2, delta;
    if (f2.length !== 2) {
      compare1 = ascending;
      compare2 = (d2, x2) => ascending(f2(d2), x2);
      delta = (d2, x2) => f2(d2) - x2;
    } else {
      compare1 = f2 === ascending || f2 === descending ? f2 : zero;
      compare2 = f2;
      delta = f2;
    }
    function left(a2, x2, lo = 0, hi = a2.length) {
      if (lo < hi) {
        if (compare1(x2, x2) !== 0)
          return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a2[mid], x2) < 0)
            lo = mid + 1;
          else
            hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function right(a2, x2, lo = 0, hi = a2.length) {
      if (lo < hi) {
        if (compare1(x2, x2) !== 0)
          return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a2[mid], x2) <= 0)
            lo = mid + 1;
          else
            hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function center(a2, x2, lo = 0, hi = a2.length) {
      const i3 = left(a2, x2, lo, hi - 1);
      return i3 > lo && delta(a2[i3 - 1], x2) > -delta(a2[i3], x2) ? i3 - 1 : i3;
    }
    return { left, center, right };
  }
  function zero() {
    return 0;
  }

  // node_modules/d3-array/src/number.js
  function number(x2) {
    return x2 === null ? NaN : +x2;
  }
  function* numbers(values, valueof) {
    if (valueof === void 0) {
      for (let value of values) {
        if (value != null && (value = +value) >= value) {
          yield value;
        }
      }
    } else {
      let index = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
          yield value;
        }
      }
    }
  }

  // node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;
  var bisectCenter = bisector(number).center;
  var bisect_default = bisectRight;

  // node_modules/d3-array/src/fsum.js
  var Adder = class {
    constructor() {
      this._partials = new Float64Array(32);
      this._n = 0;
    }
    add(x2) {
      const p2 = this._partials;
      let i3 = 0;
      for (let j2 = 0; j2 < this._n && j2 < 32; j2++) {
        const y2 = p2[j2], hi = x2 + y2, lo = Math.abs(x2) < Math.abs(y2) ? x2 - (hi - y2) : y2 - (hi - x2);
        if (lo)
          p2[i3++] = lo;
        x2 = hi;
      }
      p2[i3] = x2;
      this._n = i3 + 1;
      return this;
    }
    valueOf() {
      const p2 = this._partials;
      let n3 = this._n, x2, y2, lo, hi = 0;
      if (n3 > 0) {
        hi = p2[--n3];
        while (n3 > 0) {
          x2 = hi;
          y2 = p2[--n3];
          hi = x2 + y2;
          lo = y2 - (hi - x2);
          if (lo)
            break;
        }
        if (n3 > 0 && (lo < 0 && p2[n3 - 1] < 0 || lo > 0 && p2[n3 - 1] > 0)) {
          y2 = lo * 2;
          x2 = hi + y2;
          if (y2 == x2 - hi)
            hi = x2;
        }
      }
      return hi;
    }
  };

  // node_modules/d3-array/src/sort.js
  function compareDefined(compare2 = ascending) {
    if (compare2 === ascending)
      return ascendingDefined;
    if (typeof compare2 !== "function")
      throw new TypeError("compare is not a function");
    return (a2, b2) => {
      const x2 = compare2(a2, b2);
      if (x2 || x2 === 0)
        return x2;
      return (compare2(b2, b2) === 0) - (compare2(a2, a2) === 0);
    };
  }
  function ascendingDefined(a2, b2) {
    return (a2 == null || !(a2 >= a2)) - (b2 == null || !(b2 >= b2)) || (a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
  }

  // node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function ticks(start2, stop, count) {
    var reverse, i3 = -1, n3, ticks2, step;
    stop = +stop, start2 = +start2, count = +count;
    if (start2 === stop && count > 0)
      return [start2];
    if (reverse = stop < start2)
      n3 = start2, start2 = stop, stop = n3;
    if ((step = tickIncrement(start2, stop, count)) === 0 || !isFinite(step))
      return [];
    if (step > 0) {
      let r0 = Math.round(start2 / step), r1 = Math.round(stop / step);
      if (r0 * step < start2)
        ++r0;
      if (r1 * step > stop)
        --r1;
      ticks2 = new Array(n3 = r1 - r0 + 1);
      while (++i3 < n3)
        ticks2[i3] = (r0 + i3) * step;
    } else {
      step = -step;
      let r0 = Math.round(start2 * step), r1 = Math.round(stop * step);
      if (r0 / step < start2)
        ++r0;
      if (r1 / step > stop)
        --r1;
      ticks2 = new Array(n3 = r1 - r0 + 1);
      while (++i3 < n3)
        ticks2[i3] = (r0 + i3) / step;
    }
    if (reverse)
      ticks2.reverse();
    return ticks2;
  }
  function tickIncrement(start2, stop, count) {
    var step = (stop - start2) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
    return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
  }
  function tickStep(start2, stop, count) {
    var step0 = Math.abs(stop - start2) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
    if (error >= e10)
      step1 *= 10;
    else if (error >= e5)
      step1 *= 5;
    else if (error >= e2)
      step1 *= 2;
    return stop < start2 ? -step1 : step1;
  }

  // node_modules/d3-array/src/max.js
  function max(values, valueof) {
    let max3;
    if (valueof === void 0) {
      for (const value of values) {
        if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
          max3 = value;
        }
      }
    } else {
      let index = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index, values)) != null && (max3 < value || max3 === void 0 && value >= value)) {
          max3 = value;
        }
      }
    }
    return max3;
  }

  // node_modules/d3-array/src/min.js
  function min(values, valueof) {
    let min3;
    if (valueof === void 0) {
      for (const value of values) {
        if (value != null && (min3 > value || min3 === void 0 && value >= value)) {
          min3 = value;
        }
      }
    } else {
      let index = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index, values)) != null && (min3 > value || min3 === void 0 && value >= value)) {
          min3 = value;
        }
      }
    }
    return min3;
  }

  // node_modules/d3-array/src/quickselect.js
  function quickselect(array2, k2, left = 0, right = array2.length - 1, compare2) {
    compare2 = compare2 === void 0 ? ascendingDefined : compareDefined(compare2);
    while (right > left) {
      if (right - left > 600) {
        const n3 = right - left + 1;
        const m2 = k2 - left + 1;
        const z2 = Math.log(n3);
        const s2 = 0.5 * Math.exp(2 * z2 / 3);
        const sd = 0.5 * Math.sqrt(z2 * s2 * (n3 - s2) / n3) * (m2 - n3 / 2 < 0 ? -1 : 1);
        const newLeft = Math.max(left, Math.floor(k2 - m2 * s2 / n3 + sd));
        const newRight = Math.min(right, Math.floor(k2 + (n3 - m2) * s2 / n3 + sd));
        quickselect(array2, k2, newLeft, newRight, compare2);
      }
      const t2 = array2[k2];
      let i3 = left;
      let j2 = right;
      swap(array2, left, k2);
      if (compare2(array2[right], t2) > 0)
        swap(array2, left, right);
      while (i3 < j2) {
        swap(array2, i3, j2), ++i3, --j2;
        while (compare2(array2[i3], t2) < 0)
          ++i3;
        while (compare2(array2[j2], t2) > 0)
          --j2;
      }
      if (compare2(array2[left], t2) === 0)
        swap(array2, left, j2);
      else
        ++j2, swap(array2, j2, right);
      if (j2 <= k2)
        left = j2 + 1;
      if (k2 <= j2)
        right = j2 - 1;
    }
    return array2;
  }
  function swap(array2, i3, j2) {
    const t2 = array2[i3];
    array2[i3] = array2[j2];
    array2[j2] = t2;
  }

  // node_modules/d3-array/src/quantile.js
  function quantile(values, p2, valueof) {
    values = Float64Array.from(numbers(values, valueof));
    if (!(n3 = values.length))
      return;
    if ((p2 = +p2) <= 0 || n3 < 2)
      return min(values);
    if (p2 >= 1)
      return max(values);
    var n3, i3 = (n3 - 1) * p2, i0 = Math.floor(i3), value0 = max(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min(values.subarray(i0 + 1));
    return value0 + (value1 - value0) * (i3 - i0);
  }

  // node_modules/d3-array/src/median.js
  function median(values, valueof) {
    return quantile(values, 0.5, valueof);
  }

  // node_modules/d3-array/src/merge.js
  function* flatten(arrays) {
    for (const array2 of arrays) {
      yield* array2;
    }
  }
  function merge(arrays) {
    return Array.from(flatten(arrays));
  }

  // node_modules/d3-array/src/pairs.js
  function pairs(values, pairof = pair) {
    const pairs2 = [];
    let previous;
    let first = false;
    for (const value of values) {
      if (first)
        pairs2.push(pairof(previous, value));
      previous = value;
      first = true;
    }
    return pairs2;
  }
  function pair(a2, b2) {
    return [a2, b2];
  }

  // node_modules/d3-array/src/range.js
  function range(start2, stop, step) {
    start2 = +start2, stop = +stop, step = (n3 = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n3 < 3 ? 1 : +step;
    var i3 = -1, n3 = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range3 = new Array(n3);
    while (++i3 < n3) {
      range3[i3] = start2 + i3 * step;
    }
    return range3;
  }

  // node_modules/d3-geo/src/math.js
  var epsilon = 1e-6;
  var epsilon2 = 1e-12;
  var pi = Math.PI;
  var halfPi = pi / 2;
  var quarterPi = pi / 4;
  var tau = pi * 2;
  var degrees = 180 / pi;
  var radians = pi / 180;
  var abs = Math.abs;
  var atan = Math.atan;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var exp = Math.exp;
  var log = Math.log;
  var sin = Math.sin;
  var sign = Math.sign || function(x2) {
    return x2 > 0 ? 1 : x2 < 0 ? -1 : 0;
  };
  var sqrt = Math.sqrt;
  var tan = Math.tan;
  function acos(x2) {
    return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
  }
  function asin(x2) {
    return x2 > 1 ? halfPi : x2 < -1 ? -halfPi : Math.asin(x2);
  }

  // node_modules/d3-geo/src/noop.js
  function noop() {
  }

  // node_modules/d3-geo/src/stream.js
  function streamGeometry(geometry, stream) {
    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
      streamGeometryType[geometry.type](geometry, stream);
    }
  }
  var streamObjectType = {
    Feature: function(object, stream) {
      streamGeometry(object.geometry, stream);
    },
    FeatureCollection: function(object, stream) {
      var features = object.features, i3 = -1, n3 = features.length;
      while (++i3 < n3)
        streamGeometry(features[i3].geometry, stream);
    }
  };
  var streamGeometryType = {
    Sphere: function(object, stream) {
      stream.sphere();
    },
    Point: function(object, stream) {
      object = object.coordinates;
      stream.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, stream) {
      var coordinates = object.coordinates, i3 = -1, n3 = coordinates.length;
      while (++i3 < n3)
        object = coordinates[i3], stream.point(object[0], object[1], object[2]);
    },
    LineString: function(object, stream) {
      streamLine(object.coordinates, stream, 0);
    },
    MultiLineString: function(object, stream) {
      var coordinates = object.coordinates, i3 = -1, n3 = coordinates.length;
      while (++i3 < n3)
        streamLine(coordinates[i3], stream, 0);
    },
    Polygon: function(object, stream) {
      streamPolygon(object.coordinates, stream);
    },
    MultiPolygon: function(object, stream) {
      var coordinates = object.coordinates, i3 = -1, n3 = coordinates.length;
      while (++i3 < n3)
        streamPolygon(coordinates[i3], stream);
    },
    GeometryCollection: function(object, stream) {
      var geometries = object.geometries, i3 = -1, n3 = geometries.length;
      while (++i3 < n3)
        streamGeometry(geometries[i3], stream);
    }
  };
  function streamLine(coordinates, stream, closed) {
    var i3 = -1, n3 = coordinates.length - closed, coordinate;
    stream.lineStart();
    while (++i3 < n3)
      coordinate = coordinates[i3], stream.point(coordinate[0], coordinate[1], coordinate[2]);
    stream.lineEnd();
  }
  function streamPolygon(coordinates, stream) {
    var i3 = -1, n3 = coordinates.length;
    stream.polygonStart();
    while (++i3 < n3)
      streamLine(coordinates[i3], stream, 1);
    stream.polygonEnd();
  }
  function stream_default(object, stream) {
    if (object && streamObjectType.hasOwnProperty(object.type)) {
      streamObjectType[object.type](object, stream);
    } else {
      streamGeometry(object, stream);
    }
  }

  // node_modules/d3-geo/src/area.js
  var areaRingSum = new Adder();
  var areaSum = new Adder();
  var lambda00;
  var phi00;
  var lambda0;
  var cosPhi0;
  var sinPhi0;
  var areaStream = {
    point: noop,
    lineStart: noop,
    lineEnd: noop,
    polygonStart: function() {
      areaRingSum = new Adder();
      areaStream.lineStart = areaRingStart;
      areaStream.lineEnd = areaRingEnd;
    },
    polygonEnd: function() {
      var areaRing = +areaRingSum;
      areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
      this.lineStart = this.lineEnd = this.point = noop;
    },
    sphere: function() {
      areaSum.add(tau);
    }
  };
  function areaRingStart() {
    areaStream.point = areaPointFirst;
  }
  function areaRingEnd() {
    areaPoint(lambda00, phi00);
  }
  function areaPointFirst(lambda, phi) {
    areaStream.point = areaPoint;
    lambda00 = lambda, phi00 = phi;
    lambda *= radians, phi *= radians;
    lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
  }
  function areaPoint(lambda, phi) {
    lambda *= radians, phi *= radians;
    phi = phi / 2 + quarterPi;
    var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi), sinPhi = sin(phi), k2 = sinPhi0 * sinPhi, u2 = cosPhi0 * cosPhi + k2 * cos(adLambda), v2 = k2 * sdLambda * sin(adLambda);
    areaRingSum.add(atan2(v2, u2));
    lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
  }
  function area_default(object) {
    areaSum = new Adder();
    stream_default(object, areaStream);
    return areaSum * 2;
  }

  // node_modules/d3-geo/src/cartesian.js
  function spherical(cartesian2) {
    return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
  }
  function cartesian(spherical2) {
    var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
    return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
  }
  function cartesianDot(a2, b2) {
    return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2];
  }
  function cartesianCross(a2, b2) {
    return [a2[1] * b2[2] - a2[2] * b2[1], a2[2] * b2[0] - a2[0] * b2[2], a2[0] * b2[1] - a2[1] * b2[0]];
  }
  function cartesianAddInPlace(a2, b2) {
    a2[0] += b2[0], a2[1] += b2[1], a2[2] += b2[2];
  }
  function cartesianScale(vector, k2) {
    return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
  }
  function cartesianNormalizeInPlace(d2) {
    var l2 = sqrt(d2[0] * d2[0] + d2[1] * d2[1] + d2[2] * d2[2]);
    d2[0] /= l2, d2[1] /= l2, d2[2] /= l2;
  }

  // node_modules/d3-geo/src/bounds.js
  var lambda02;
  var phi0;
  var lambda1;
  var phi1;
  var lambda2;
  var lambda002;
  var phi002;
  var p0;
  var deltaSum;
  var ranges;
  var range2;
  var boundsStream = {
    point: boundsPoint,
    lineStart: boundsLineStart,
    lineEnd: boundsLineEnd,
    polygonStart: function() {
      boundsStream.point = boundsRingPoint;
      boundsStream.lineStart = boundsRingStart;
      boundsStream.lineEnd = boundsRingEnd;
      deltaSum = new Adder();
      areaStream.polygonStart();
    },
    polygonEnd: function() {
      areaStream.polygonEnd();
      boundsStream.point = boundsPoint;
      boundsStream.lineStart = boundsLineStart;
      boundsStream.lineEnd = boundsLineEnd;
      if (areaRingSum < 0)
        lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      else if (deltaSum > epsilon)
        phi1 = 90;
      else if (deltaSum < -epsilon)
        phi0 = -90;
      range2[0] = lambda02, range2[1] = lambda1;
    },
    sphere: function() {
      lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    }
  };
  function boundsPoint(lambda, phi) {
    ranges.push(range2 = [lambda02 = lambda, lambda1 = lambda]);
    if (phi < phi0)
      phi0 = phi;
    if (phi > phi1)
      phi1 = phi;
  }
  function linePoint(lambda, phi) {
    var p2 = cartesian([lambda * radians, phi * radians]);
    if (p0) {
      var normal = cartesianCross(p0, p2), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
      cartesianNormalizeInPlace(inflection);
      inflection = spherical(inflection);
      var delta = lambda - lambda2, sign2 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign2, phii, antimeridian = abs(delta) > 180;
      if (antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
        phii = inflection[1] * degrees;
        if (phii > phi1)
          phi1 = phii;
      } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
        phii = -inflection[1] * degrees;
        if (phii < phi0)
          phi0 = phii;
      } else {
        if (phi < phi0)
          phi0 = phi;
        if (phi > phi1)
          phi1 = phi;
      }
      if (antimeridian) {
        if (lambda < lambda2) {
          if (angle(lambda02, lambda) > angle(lambda02, lambda1))
            lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda02, lambda1))
            lambda02 = lambda;
        }
      } else {
        if (lambda1 >= lambda02) {
          if (lambda < lambda02)
            lambda02 = lambda;
          if (lambda > lambda1)
            lambda1 = lambda;
        } else {
          if (lambda > lambda2) {
            if (angle(lambda02, lambda) > angle(lambda02, lambda1))
              lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda02, lambda1))
              lambda02 = lambda;
          }
        }
      }
    } else {
      ranges.push(range2 = [lambda02 = lambda, lambda1 = lambda]);
    }
    if (phi < phi0)
      phi0 = phi;
    if (phi > phi1)
      phi1 = phi;
    p0 = p2, lambda2 = lambda;
  }
  function boundsLineStart() {
    boundsStream.point = linePoint;
  }
  function boundsLineEnd() {
    range2[0] = lambda02, range2[1] = lambda1;
    boundsStream.point = boundsPoint;
    p0 = null;
  }
  function boundsRingPoint(lambda, phi) {
    if (p0) {
      var delta = lambda - lambda2;
      deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
    } else {
      lambda002 = lambda, phi002 = phi;
    }
    areaStream.point(lambda, phi);
    linePoint(lambda, phi);
  }
  function boundsRingStart() {
    areaStream.lineStart();
  }
  function boundsRingEnd() {
    boundsRingPoint(lambda002, phi002);
    areaStream.lineEnd();
    if (abs(deltaSum) > epsilon)
      lambda02 = -(lambda1 = 180);
    range2[0] = lambda02, range2[1] = lambda1;
    p0 = null;
  }
  function angle(lambda04, lambda12) {
    return (lambda12 -= lambda04) < 0 ? lambda12 + 360 : lambda12;
  }
  function rangeCompare(a2, b2) {
    return a2[0] - b2[0];
  }
  function rangeContains(range3, x2) {
    return range3[0] <= range3[1] ? range3[0] <= x2 && x2 <= range3[1] : x2 < range3[0] || range3[1] < x2;
  }
  function bounds_default(feature3) {
    var i3, n3, a2, b2, merged, deltaMax, delta;
    phi1 = lambda1 = -(lambda02 = phi0 = Infinity);
    ranges = [];
    stream_default(feature3, boundsStream);
    if (n3 = ranges.length) {
      ranges.sort(rangeCompare);
      for (i3 = 1, a2 = ranges[0], merged = [a2]; i3 < n3; ++i3) {
        b2 = ranges[i3];
        if (rangeContains(a2, b2[0]) || rangeContains(a2, b2[1])) {
          if (angle(a2[0], b2[1]) > angle(a2[0], a2[1]))
            a2[1] = b2[1];
          if (angle(b2[0], a2[1]) > angle(a2[0], a2[1]))
            a2[0] = b2[0];
        } else {
          merged.push(a2 = b2);
        }
      }
      for (deltaMax = -Infinity, n3 = merged.length - 1, i3 = 0, a2 = merged[n3]; i3 <= n3; a2 = b2, ++i3) {
        b2 = merged[i3];
        if ((delta = angle(a2[1], b2[0])) > deltaMax)
          deltaMax = delta, lambda02 = b2[0], lambda1 = a2[1];
      }
    }
    ranges = range2 = null;
    return lambda02 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda02, phi0], [lambda1, phi1]];
  }

  // node_modules/d3-geo/src/compose.js
  function compose_default(a2, b2) {
    function compose(x2, y2) {
      return x2 = a2(x2, y2), b2(x2[0], x2[1]);
    }
    if (a2.invert && b2.invert)
      compose.invert = function(x2, y2) {
        return x2 = b2.invert(x2, y2), x2 && a2.invert(x2[0], x2[1]);
      };
    return compose;
  }

  // node_modules/d3-geo/src/rotation.js
  function rotationIdentity(lambda, phi) {
    return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];
  }
  rotationIdentity.invert = rotationIdentity;
  function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
    return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
  }
  function forwardRotationLambda(deltaLambda) {
    return function(lambda, phi) {
      return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
    };
  }
  function rotationLambda(deltaLambda) {
    var rotation = forwardRotationLambda(deltaLambda);
    rotation.invert = forwardRotationLambda(-deltaLambda);
    return rotation;
  }
  function rotationPhiGamma(deltaPhi, deltaGamma) {
    var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
    function rotation(lambda, phi) {
      var cosPhi = cos(phi), x2 = cos(lambda) * cosPhi, y2 = sin(lambda) * cosPhi, z2 = sin(phi), k2 = z2 * cosDeltaPhi + x2 * sinDeltaPhi;
      return [
        atan2(y2 * cosDeltaGamma - k2 * sinDeltaGamma, x2 * cosDeltaPhi - z2 * sinDeltaPhi),
        asin(k2 * cosDeltaGamma + y2 * sinDeltaGamma)
      ];
    }
    rotation.invert = function(lambda, phi) {
      var cosPhi = cos(phi), x2 = cos(lambda) * cosPhi, y2 = sin(lambda) * cosPhi, z2 = sin(phi), k2 = z2 * cosDeltaGamma - y2 * sinDeltaGamma;
      return [
        atan2(y2 * cosDeltaGamma + z2 * sinDeltaGamma, x2 * cosDeltaPhi + k2 * sinDeltaPhi),
        asin(k2 * cosDeltaPhi - x2 * sinDeltaPhi)
      ];
    };
    return rotation;
  }
  function rotation_default(rotate) {
    rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
      return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
      return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
    };
    return forward;
  }

  // node_modules/d3-geo/src/circle.js
  function circleStream(stream, radius, delta, direction, t0, t1) {
    if (!delta)
      return;
    var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;
    if (t0 == null) {
      t0 = radius + direction * tau;
      t1 = radius - step / 2;
    } else {
      t0 = circleRadius(cosRadius, t0);
      t1 = circleRadius(cosRadius, t1);
      if (direction > 0 ? t0 < t1 : t0 > t1)
        t0 += direction * tau;
    }
    for (var point2, t2 = t0; direction > 0 ? t2 > t1 : t2 < t1; t2 -= step) {
      point2 = spherical([cosRadius, -sinRadius * cos(t2), -sinRadius * sin(t2)]);
      stream.point(point2[0], point2[1]);
    }
  }
  function circleRadius(cosRadius, point2) {
    point2 = cartesian(point2), point2[0] -= cosRadius;
    cartesianNormalizeInPlace(point2);
    var radius = acos(-point2[1]);
    return ((-point2[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
  }

  // node_modules/d3-geo/src/clip/buffer.js
  function buffer_default() {
    var lines = [], line;
    return {
      point: function(x2, y2, m2) {
        line.push([x2, y2, m2]);
      },
      lineStart: function() {
        lines.push(line = []);
      },
      lineEnd: noop,
      rejoin: function() {
        if (lines.length > 1)
          lines.push(lines.pop().concat(lines.shift()));
      },
      result: function() {
        var result = lines;
        lines = [];
        line = null;
        return result;
      }
    };
  }

  // node_modules/d3-geo/src/pointEqual.js
  function pointEqual_default(a2, b2) {
    return abs(a2[0] - b2[0]) < epsilon && abs(a2[1] - b2[1]) < epsilon;
  }

  // node_modules/d3-geo/src/clip/rejoin.js
  function Intersection(point2, points, other, entry) {
    this.x = point2;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
    var subject = [], clip = [], i3, n3;
    segments.forEach(function(segment) {
      if ((n4 = segment.length - 1) <= 0)
        return;
      var n4, p02 = segment[0], p1 = segment[n4], x2;
      if (pointEqual_default(p02, p1)) {
        if (!p02[2] && !p1[2]) {
          stream.lineStart();
          for (i3 = 0; i3 < n4; ++i3)
            stream.point((p02 = segment[i3])[0], p02[1]);
          stream.lineEnd();
          return;
        }
        p1[0] += 2 * epsilon;
      }
      subject.push(x2 = new Intersection(p02, segment, null, true));
      clip.push(x2.o = new Intersection(p02, null, x2, false));
      subject.push(x2 = new Intersection(p1, segment, null, false));
      clip.push(x2.o = new Intersection(p1, null, x2, true));
    });
    if (!subject.length)
      return;
    clip.sort(compareIntersection2);
    link(subject);
    link(clip);
    for (i3 = 0, n3 = clip.length; i3 < n3; ++i3) {
      clip[i3].e = startInside = !startInside;
    }
    var start2 = subject[0], points, point2;
    while (1) {
      var current = start2, isSubject = true;
      while (current.v)
        if ((current = current.n) === start2)
          return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i3 = 0, n3 = points.length; i3 < n3; ++i3)
              stream.point((point2 = points[i3])[0], point2[1]);
          } else {
            interpolate(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i3 = points.length - 1; i3 >= 0; --i3)
              stream.point((point2 = points[i3])[0], point2[1]);
          } else {
            interpolate(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  }
  function link(array2) {
    if (!(n3 = array2.length))
      return;
    var n3, i3 = 0, a2 = array2[0], b2;
    while (++i3 < n3) {
      a2.n = b2 = array2[i3];
      b2.p = a2;
      a2 = b2;
    }
    a2.n = b2 = array2[0];
    b2.p = a2;
  }

  // node_modules/d3-geo/src/polygonContains.js
  function longitude(point2) {
    return abs(point2[0]) <= pi ? point2[0] : sign(point2[0]) * ((abs(point2[0]) + pi) % tau - pi);
  }
  function polygonContains_default(polygon2, point2) {
    var lambda = longitude(point2), phi = point2[1], sinPhi = sin(phi), normal = [sin(lambda), -cos(lambda), 0], angle2 = 0, winding = 0;
    var sum = new Adder();
    if (sinPhi === 1)
      phi = halfPi + epsilon;
    else if (sinPhi === -1)
      phi = -halfPi - epsilon;
    for (var i3 = 0, n3 = polygon2.length; i3 < n3; ++i3) {
      if (!(m2 = (ring = polygon2[i3]).length))
        continue;
      var ring, m2, point0 = ring[m2 - 1], lambda04 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi03 = sin(phi02), cosPhi03 = cos(phi02);
      for (var j2 = 0; j2 < m2; ++j2, lambda04 = lambda12, sinPhi03 = sinPhi1, cosPhi03 = cosPhi1, point0 = point1) {
        var point1 = ring[j2], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi12), cosPhi1 = cos(phi12), delta = lambda12 - lambda04, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi, k2 = sinPhi03 * sinPhi1;
        sum.add(atan2(k2 * sign2 * sin(absDelta), cosPhi03 * cosPhi1 + k2 * cos(absDelta)));
        angle2 += antimeridian ? delta + sign2 * tau : delta;
        if (antimeridian ^ lambda04 >= lambda ^ lambda12 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection2 = cartesianCross(normal, arc);
          cartesianNormalizeInPlace(intersection2);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection2[2]);
          if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }
    return (angle2 < -epsilon || angle2 < epsilon && sum < -epsilon2) ^ winding & 1;
  }

  // node_modules/d3-geo/src/clip/index.js
  function clip_default(pointVisible, clipLine, interpolate, start2) {
    return function(sink) {
      var line = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon2, segments, ring;
      var clip = {
        point: point2,
        lineStart,
        lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon2 = [];
        },
        polygonEnd: function() {
          clip.point = point2;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = merge(segments);
          var startInside = polygonContains_default(polygon2, start2);
          if (segments.length) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
          } else if (startInside) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted)
            sink.polygonEnd(), polygonStarted = false;
          segments = polygon2 = null;
        },
        sphere: function() {
          sink.polygonStart();
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };
      function point2(lambda, phi) {
        if (pointVisible(lambda, phi))
          sink.point(lambda, phi);
      }
      function pointLine(lambda, phi) {
        line.point(lambda, phi);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point2;
        line.lineEnd();
      }
      function pointRing(lambda, phi) {
        ring.push([lambda, phi]);
        ringSink.point(lambda, phi);
      }
      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();
        var clean2 = ringSink.clean(), ringSegments = ringBuffer.result(), i3, n3 = ringSegments.length, m2, segment, point3;
        ring.pop();
        polygon2.push(ring);
        ring = null;
        if (!n3)
          return;
        if (clean2 & 1) {
          segment = ringSegments[0];
          if ((m2 = segment.length - 1) > 0) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i3 = 0; i3 < m2; ++i3)
              sink.point((point3 = segment[i3])[0], point3[1]);
            sink.lineEnd();
          }
          return;
        }
        if (n3 > 1 && clean2 & 2)
          ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(validSegment));
      }
      return clip;
    };
  }
  function validSegment(segment) {
    return segment.length > 1;
  }
  function compareIntersection(a2, b2) {
    return ((a2 = a2.x)[0] < 0 ? a2[1] - halfPi - epsilon : halfPi - a2[1]) - ((b2 = b2.x)[0] < 0 ? b2[1] - halfPi - epsilon : halfPi - b2[1]);
  }

  // node_modules/d3-geo/src/clip/antimeridian.js
  var antimeridian_default = clip_default(
    function() {
      return true;
    },
    clipAntimeridianLine,
    clipAntimeridianInterpolate,
    [-pi, -halfPi]
  );
  function clipAntimeridianLine(stream) {
    var lambda04 = NaN, phi02 = NaN, sign0 = NaN, clean2;
    return {
      lineStart: function() {
        stream.lineStart();
        clean2 = 1;
      },
      point: function(lambda12, phi12) {
        var sign1 = lambda12 > 0 ? pi : -pi, delta = abs(lambda12 - lambda04);
        if (abs(delta - pi) < epsilon) {
          stream.point(lambda04, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi : -halfPi);
          stream.point(sign0, phi02);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi02);
          stream.point(lambda12, phi02);
          clean2 = 0;
        } else if (sign0 !== sign1 && delta >= pi) {
          if (abs(lambda04 - sign0) < epsilon)
            lambda04 -= sign0 * epsilon;
          if (abs(lambda12 - sign1) < epsilon)
            lambda12 -= sign1 * epsilon;
          phi02 = clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12);
          stream.point(sign0, phi02);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi02);
          clean2 = 0;
        }
        stream.point(lambda04 = lambda12, phi02 = phi12);
        sign0 = sign1;
      },
      lineEnd: function() {
        stream.lineEnd();
        lambda04 = phi02 = NaN;
      },
      clean: function() {
        return 2 - clean2;
      }
    };
  }
  function clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12) {
    var cosPhi03, cosPhi1, sinLambda0Lambda1 = sin(lambda04 - lambda12);
    return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi02) * (cosPhi1 = cos(phi12)) * sin(lambda12) - sin(phi12) * (cosPhi03 = cos(phi02)) * sin(lambda04)) / (cosPhi03 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
  }
  function clipAntimeridianInterpolate(from, to, direction, stream) {
    var phi;
    if (from == null) {
      phi = direction * halfPi;
      stream.point(-pi, phi);
      stream.point(0, phi);
      stream.point(pi, phi);
      stream.point(pi, 0);
      stream.point(pi, -phi);
      stream.point(0, -phi);
      stream.point(-pi, -phi);
      stream.point(-pi, 0);
      stream.point(-pi, phi);
    } else if (abs(from[0] - to[0]) > epsilon) {
      var lambda = from[0] < to[0] ? pi : -pi;
      phi = direction * lambda / 2;
      stream.point(-lambda, phi);
      stream.point(0, phi);
      stream.point(lambda, phi);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  // node_modules/d3-geo/src/clip/circle.js
  function circle_default(radius) {
    var cr = cos(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;
    function interpolate(from, to, direction, stream) {
      circleStream(stream, radius, delta, direction, from, to);
    }
    function visible(lambda, phi) {
      return cos(lambda) * cos(phi) > cr;
    }
    function clipLine(stream) {
      var point0, c0, v0, v00, clean2;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean2 = 1;
        },
        point: function(lambda, phi) {
          var point1 = [lambda, phi], point2, v2 = visible(lambda, phi), c2 = smallRadius ? v2 ? 0 : code(lambda, phi) : v2 ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
          if (!point0 && (v00 = v0 = v2))
            stream.lineStart();
          if (v2 !== v0) {
            point2 = intersect2(point0, point1);
            if (!point2 || pointEqual_default(point0, point2) || pointEqual_default(point1, point2))
              point1[2] = 1;
          }
          if (v2 !== v0) {
            clean2 = 0;
            if (v2) {
              stream.lineStart();
              point2 = intersect2(point1, point0);
              stream.point(point2[0], point2[1]);
            } else {
              point2 = intersect2(point0, point1);
              stream.point(point2[0], point2[1], 2);
              stream.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v2) {
            var t2;
            if (!(c2 & c0) && (t2 = intersect2(point1, point0, true))) {
              clean2 = 0;
              if (smallRadius) {
                stream.lineStart();
                stream.point(t2[0][0], t2[0][1]);
                stream.point(t2[1][0], t2[1][1]);
                stream.lineEnd();
              } else {
                stream.point(t2[1][0], t2[1][1]);
                stream.lineEnd();
                stream.lineStart();
                stream.point(t2[0][0], t2[0][1], 3);
              }
            }
          }
          if (v2 && (!point0 || !pointEqual_default(point0, point1))) {
            stream.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v2, c0 = c2;
        },
        lineEnd: function() {
          if (v0)
            stream.lineEnd();
          point0 = null;
        },
        // Rejoin first and last segments if there were intersections and the first
        // and last points were visible.
        clean: function() {
          return clean2 | (v00 && v0) << 1;
        }
      };
    }
    function intersect2(a2, b2, two) {
      var pa = cartesian(a2), pb = cartesian(b2);
      var n1 = [1, 0, 0], n22 = cartesianCross(pa, pb), n2n2 = cartesianDot(n22, n22), n1n2 = n22[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant)
        return !two && a2;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n22), A2 = cartesianScale(n1, c1), B2 = cartesianScale(n22, c2);
      cartesianAddInPlace(A2, B2);
      var u2 = n1xn2, w2 = cartesianDot(A2, u2), uu = cartesianDot(u2, u2), t2 = w2 * w2 - uu * (cartesianDot(A2, A2) - 1);
      if (t2 < 0)
        return;
      var t3 = sqrt(t2), q2 = cartesianScale(u2, (-w2 - t3) / uu);
      cartesianAddInPlace(q2, A2);
      q2 = spherical(q2);
      if (!two)
        return q2;
      var lambda04 = a2[0], lambda12 = b2[0], phi02 = a2[1], phi12 = b2[1], z2;
      if (lambda12 < lambda04)
        z2 = lambda04, lambda04 = lambda12, lambda12 = z2;
      var delta2 = lambda12 - lambda04, polar = abs(delta2 - pi) < epsilon, meridian = polar || delta2 < epsilon;
      if (!polar && phi12 < phi02)
        z2 = phi02, phi02 = phi12, phi12 = z2;
      if (meridian ? polar ? phi02 + phi12 > 0 ^ q2[1] < (abs(q2[0] - lambda04) < epsilon ? phi02 : phi12) : phi02 <= q2[1] && q2[1] <= phi12 : delta2 > pi ^ (lambda04 <= q2[0] && q2[0] <= lambda12)) {
        var q1 = cartesianScale(u2, (-w2 + t3) / uu);
        cartesianAddInPlace(q1, A2);
        return [q2, spherical(q1)];
      }
    }
    function code(lambda, phi) {
      var r2 = smallRadius ? radius : pi - radius, code2 = 0;
      if (lambda < -r2)
        code2 |= 1;
      else if (lambda > r2)
        code2 |= 2;
      if (phi < -r2)
        code2 |= 4;
      else if (phi > r2)
        code2 |= 8;
      return code2;
    }
    return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
  }

  // node_modules/d3-geo/src/clip/line.js
  function line_default(a2, b2, x05, y05, x12, y12) {
    var ax = a2[0], ay = a2[1], bx = b2[0], by = b2[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r2;
    r2 = x05 - ax;
    if (!dx && r2 > 0)
      return;
    r2 /= dx;
    if (dx < 0) {
      if (r2 < t0)
        return;
      if (r2 < t1)
        t1 = r2;
    } else if (dx > 0) {
      if (r2 > t1)
        return;
      if (r2 > t0)
        t0 = r2;
    }
    r2 = x12 - ax;
    if (!dx && r2 < 0)
      return;
    r2 /= dx;
    if (dx < 0) {
      if (r2 > t1)
        return;
      if (r2 > t0)
        t0 = r2;
    } else if (dx > 0) {
      if (r2 < t0)
        return;
      if (r2 < t1)
        t1 = r2;
    }
    r2 = y05 - ay;
    if (!dy && r2 > 0)
      return;
    r2 /= dy;
    if (dy < 0) {
      if (r2 < t0)
        return;
      if (r2 < t1)
        t1 = r2;
    } else if (dy > 0) {
      if (r2 > t1)
        return;
      if (r2 > t0)
        t0 = r2;
    }
    r2 = y12 - ay;
    if (!dy && r2 < 0)
      return;
    r2 /= dy;
    if (dy < 0) {
      if (r2 > t1)
        return;
      if (r2 > t0)
        t0 = r2;
    } else if (dy > 0) {
      if (r2 < t0)
        return;
      if (r2 < t1)
        t1 = r2;
    }
    if (t0 > 0)
      a2[0] = ax + t0 * dx, a2[1] = ay + t0 * dy;
    if (t1 < 1)
      b2[0] = ax + t1 * dx, b2[1] = ay + t1 * dy;
    return true;
  }

  // node_modules/d3-geo/src/clip/rectangle.js
  var clipMax = 1e9;
  var clipMin = -clipMax;
  function clipRectangle(x05, y05, x12, y12) {
    function visible(x2, y2) {
      return x05 <= x2 && x2 <= x12 && y05 <= y2 && y2 <= y12;
    }
    function interpolate(from, to, direction, stream) {
      var a2 = 0, a1 = 0;
      if (from == null || (a2 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
        do
          stream.point(a2 === 0 || a2 === 3 ? x05 : x12, a2 > 1 ? y12 : y05);
        while ((a2 = (a2 + direction + 4) % 4) !== a1);
      } else {
        stream.point(to[0], to[1]);
      }
    }
    function corner(p2, direction) {
      return abs(p2[0] - x05) < epsilon ? direction > 0 ? 0 : 3 : abs(p2[0] - x12) < epsilon ? direction > 0 ? 2 : 1 : abs(p2[1] - y05) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compareIntersection2(a2, b2) {
      return comparePoint(a2.x, b2.x);
    }
    function comparePoint(a2, b2) {
      var ca = corner(a2, 1), cb = corner(b2, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b2[1] - a2[1] : ca === 1 ? a2[0] - b2[0] : ca === 2 ? a2[1] - b2[1] : b2[0] - a2[0];
    }
    return function(stream) {
      var activeStream = stream, bufferStream = buffer_default(), segments, polygon2, ring, x__, y__, v__, x_, y_, v_, first, clean2;
      var clipStream = {
        point: point2,
        lineStart,
        lineEnd,
        polygonStart,
        polygonEnd
      };
      function point2(x2, y2) {
        if (visible(x2, y2))
          activeStream.point(x2, y2);
      }
      function polygonInside() {
        var winding = 0;
        for (var i3 = 0, n3 = polygon2.length; i3 < n3; ++i3) {
          for (var ring2 = polygon2[i3], j2 = 1, m2 = ring2.length, point3 = ring2[0], a0, a1, b0 = point3[0], b1 = point3[1]; j2 < m2; ++j2) {
            a0 = b0, a1 = b1, point3 = ring2[j2], b0 = point3[0], b1 = point3[1];
            if (a1 <= y12) {
              if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x05 - a0))
                ++winding;
            } else {
              if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x05 - a0))
                --winding;
            }
          }
        }
        return winding;
      }
      function polygonStart() {
        activeStream = bufferStream, segments = [], polygon2 = [], clean2 = true;
      }
      function polygonEnd() {
        var startInside = polygonInside(), cleanInside = clean2 && startInside, visible2 = (segments = merge(segments)).length;
        if (cleanInside || visible2) {
          stream.polygonStart();
          if (cleanInside) {
            stream.lineStart();
            interpolate(null, null, 1, stream);
            stream.lineEnd();
          }
          if (visible2) {
            rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);
          }
          stream.polygonEnd();
        }
        activeStream = stream, segments = polygon2 = ring = null;
      }
      function lineStart() {
        clipStream.point = linePoint2;
        if (polygon2)
          polygon2.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint2(x__, y__);
          if (v__ && v_)
            bufferStream.rejoin();
          segments.push(bufferStream.result());
        }
        clipStream.point = point2;
        if (v_)
          activeStream.lineEnd();
      }
      function linePoint2(x2, y2) {
        var v2 = visible(x2, y2);
        if (polygon2)
          ring.push([x2, y2]);
        if (first) {
          x__ = x2, y__ = y2, v__ = v2;
          first = false;
          if (v2) {
            activeStream.lineStart();
            activeStream.point(x2, y2);
          }
        } else {
          if (v2 && v_)
            activeStream.point(x2, y2);
          else {
            var a2 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b2 = [x2 = Math.max(clipMin, Math.min(clipMax, x2)), y2 = Math.max(clipMin, Math.min(clipMax, y2))];
            if (line_default(a2, b2, x05, y05, x12, y12)) {
              if (!v_) {
                activeStream.lineStart();
                activeStream.point(a2[0], a2[1]);
              }
              activeStream.point(b2[0], b2[1]);
              if (!v2)
                activeStream.lineEnd();
              clean2 = false;
            } else if (v2) {
              activeStream.lineStart();
              activeStream.point(x2, y2);
              clean2 = false;
            }
          }
        }
        x_ = x2, y_ = y2, v_ = v2;
      }
      return clipStream;
    };
  }

  // node_modules/d3-geo/src/length.js
  var lengthSum;
  var lambda03;
  var sinPhi02;
  var cosPhi02;
  var lengthStream = {
    sphere: noop,
    point: noop,
    lineStart: lengthLineStart,
    lineEnd: noop,
    polygonStart: noop,
    polygonEnd: noop
  };
  function lengthLineStart() {
    lengthStream.point = lengthPointFirst;
    lengthStream.lineEnd = lengthLineEnd;
  }
  function lengthLineEnd() {
    lengthStream.point = lengthStream.lineEnd = noop;
  }
  function lengthPointFirst(lambda, phi) {
    lambda *= radians, phi *= radians;
    lambda03 = lambda, sinPhi02 = sin(phi), cosPhi02 = cos(phi);
    lengthStream.point = lengthPoint;
  }
  function lengthPoint(lambda, phi) {
    lambda *= radians, phi *= radians;
    var sinPhi = sin(phi), cosPhi = cos(phi), delta = abs(lambda - lambda03), cosDelta = cos(delta), sinDelta = sin(delta), x2 = cosPhi * sinDelta, y2 = cosPhi02 * sinPhi - sinPhi02 * cosPhi * cosDelta, z2 = sinPhi02 * sinPhi + cosPhi02 * cosPhi * cosDelta;
    lengthSum.add(atan2(sqrt(x2 * x2 + y2 * y2), z2));
    lambda03 = lambda, sinPhi02 = sinPhi, cosPhi02 = cosPhi;
  }
  function length_default(object) {
    lengthSum = new Adder();
    stream_default(object, lengthStream);
    return +lengthSum;
  }

  // node_modules/d3-geo/src/identity.js
  var identity_default = (x2) => x2;

  // node_modules/d3-geo/src/path/area.js
  var areaSum2 = new Adder();
  var areaRingSum2 = new Adder();
  var x00;
  var y00;
  var x0;
  var y0;
  var areaStream2 = {
    point: noop,
    lineStart: noop,
    lineEnd: noop,
    polygonStart: function() {
      areaStream2.lineStart = areaRingStart2;
      areaStream2.lineEnd = areaRingEnd2;
    },
    polygonEnd: function() {
      areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop;
      areaSum2.add(abs(areaRingSum2));
      areaRingSum2 = new Adder();
    },
    result: function() {
      var area = areaSum2 / 2;
      areaSum2 = new Adder();
      return area;
    }
  };
  function areaRingStart2() {
    areaStream2.point = areaPointFirst2;
  }
  function areaPointFirst2(x2, y2) {
    areaStream2.point = areaPoint2;
    x00 = x0 = x2, y00 = y0 = y2;
  }
  function areaPoint2(x2, y2) {
    areaRingSum2.add(y0 * x2 - x0 * y2);
    x0 = x2, y0 = y2;
  }
  function areaRingEnd2() {
    areaPoint2(x00, y00);
  }
  var area_default2 = areaStream2;

  // node_modules/d3-geo/src/path/bounds.js
  var x02 = Infinity;
  var y02 = x02;
  var x1 = -x02;
  var y1 = x1;
  var boundsStream2 = {
    point: boundsPoint2,
    lineStart: noop,
    lineEnd: noop,
    polygonStart: noop,
    polygonEnd: noop,
    result: function() {
      var bounds = [[x02, y02], [x1, y1]];
      x1 = y1 = -(y02 = x02 = Infinity);
      return bounds;
    }
  };
  function boundsPoint2(x2, y2) {
    if (x2 < x02)
      x02 = x2;
    if (x2 > x1)
      x1 = x2;
    if (y2 < y02)
      y02 = y2;
    if (y2 > y1)
      y1 = y2;
  }
  var bounds_default2 = boundsStream2;

  // node_modules/d3-geo/src/path/centroid.js
  var X0 = 0;
  var Y0 = 0;
  var Z0 = 0;
  var X1 = 0;
  var Y1 = 0;
  var Z1 = 0;
  var X2 = 0;
  var Y2 = 0;
  var Z2 = 0;
  var x002;
  var y002;
  var x03;
  var y03;
  var centroidStream = {
    point: centroidPoint,
    lineStart: centroidLineStart,
    lineEnd: centroidLineEnd,
    polygonStart: function() {
      centroidStream.lineStart = centroidRingStart;
      centroidStream.lineEnd = centroidRingEnd;
    },
    polygonEnd: function() {
      centroidStream.point = centroidPoint;
      centroidStream.lineStart = centroidLineStart;
      centroidStream.lineEnd = centroidLineEnd;
    },
    result: function() {
      var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
      X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
      return centroid;
    }
  };
  function centroidPoint(x2, y2) {
    X0 += x2;
    Y0 += y2;
    ++Z0;
  }
  function centroidLineStart() {
    centroidStream.point = centroidPointFirstLine;
  }
  function centroidPointFirstLine(x2, y2) {
    centroidStream.point = centroidPointLine;
    centroidPoint(x03 = x2, y03 = y2);
  }
  function centroidPointLine(x2, y2) {
    var dx = x2 - x03, dy = y2 - y03, z2 = sqrt(dx * dx + dy * dy);
    X1 += z2 * (x03 + x2) / 2;
    Y1 += z2 * (y03 + y2) / 2;
    Z1 += z2;
    centroidPoint(x03 = x2, y03 = y2);
  }
  function centroidLineEnd() {
    centroidStream.point = centroidPoint;
  }
  function centroidRingStart() {
    centroidStream.point = centroidPointFirstRing;
  }
  function centroidRingEnd() {
    centroidPointRing(x002, y002);
  }
  function centroidPointFirstRing(x2, y2) {
    centroidStream.point = centroidPointRing;
    centroidPoint(x002 = x03 = x2, y002 = y03 = y2);
  }
  function centroidPointRing(x2, y2) {
    var dx = x2 - x03, dy = y2 - y03, z2 = sqrt(dx * dx + dy * dy);
    X1 += z2 * (x03 + x2) / 2;
    Y1 += z2 * (y03 + y2) / 2;
    Z1 += z2;
    z2 = y03 * x2 - x03 * y2;
    X2 += z2 * (x03 + x2);
    Y2 += z2 * (y03 + y2);
    Z2 += z2 * 3;
    centroidPoint(x03 = x2, y03 = y2);
  }
  var centroid_default = centroidStream;

  // node_modules/d3-geo/src/path/context.js
  function PathContext(context) {
    this._context = context;
  }
  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_2) {
      return this._radius = _2, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0)
        this._context.closePath();
      this._point = NaN;
    },
    point: function(x2, y2) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x2, y2);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x2, y2);
          break;
        }
        default: {
          this._context.moveTo(x2 + this._radius, y2);
          this._context.arc(x2, y2, this._radius, 0, tau);
          break;
        }
      }
    },
    result: noop
  };

  // node_modules/d3-geo/src/path/measure.js
  var lengthSum2 = new Adder();
  var lengthRing;
  var x003;
  var y003;
  var x04;
  var y04;
  var lengthStream2 = {
    point: noop,
    lineStart: function() {
      lengthStream2.point = lengthPointFirst2;
    },
    lineEnd: function() {
      if (lengthRing)
        lengthPoint2(x003, y003);
      lengthStream2.point = noop;
    },
    polygonStart: function() {
      lengthRing = true;
    },
    polygonEnd: function() {
      lengthRing = null;
    },
    result: function() {
      var length2 = +lengthSum2;
      lengthSum2 = new Adder();
      return length2;
    }
  };
  function lengthPointFirst2(x2, y2) {
    lengthStream2.point = lengthPoint2;
    x003 = x04 = x2, y003 = y04 = y2;
  }
  function lengthPoint2(x2, y2) {
    x04 -= x2, y04 -= y2;
    lengthSum2.add(sqrt(x04 * x04 + y04 * y04));
    x04 = x2, y04 = y2;
  }
  var measure_default = lengthStream2;

  // node_modules/d3-geo/src/path/string.js
  function PathString() {
    this._string = [];
  }
  PathString.prototype = {
    _radius: 4.5,
    _circle: circle(4.5),
    pointRadius: function(_2) {
      if ((_2 = +_2) !== this._radius)
        this._radius = _2, this._circle = null;
      return this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0)
        this._string.push("Z");
      this._point = NaN;
    },
    point: function(x2, y2) {
      switch (this._point) {
        case 0: {
          this._string.push("M", x2, ",", y2);
          this._point = 1;
          break;
        }
        case 1: {
          this._string.push("L", x2, ",", y2);
          break;
        }
        default: {
          if (this._circle == null)
            this._circle = circle(this._radius);
          this._string.push("M", x2, ",", y2, this._circle);
          break;
        }
      }
    },
    result: function() {
      if (this._string.length) {
        var result = this._string.join("");
        this._string = [];
        return result;
      } else {
        return null;
      }
    }
  };
  function circle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }

  // node_modules/d3-geo/src/path/index.js
  function path_default(projection2, context) {
    var pointRadius = 4.5, projectionStream, contextStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function")
          contextStream.pointRadius(+pointRadius.apply(this, arguments));
        stream_default(object, projectionStream(contextStream));
      }
      return contextStream.result();
    }
    path.area = function(object) {
      stream_default(object, projectionStream(area_default2));
      return area_default2.result();
    };
    path.measure = function(object) {
      stream_default(object, projectionStream(measure_default));
      return measure_default.result();
    };
    path.bounds = function(object) {
      stream_default(object, projectionStream(bounds_default2));
      return bounds_default2.result();
    };
    path.centroid = function(object) {
      stream_default(object, projectionStream(centroid_default));
      return centroid_default.result();
    };
    path.projection = function(_2) {
      return arguments.length ? (projectionStream = _2 == null ? (projection2 = null, identity_default) : (projection2 = _2).stream, path) : projection2;
    };
    path.context = function(_2) {
      if (!arguments.length)
        return context;
      contextStream = _2 == null ? (context = null, new PathString()) : new PathContext(context = _2);
      if (typeof pointRadius !== "function")
        contextStream.pointRadius(pointRadius);
      return path;
    };
    path.pointRadius = function(_2) {
      if (!arguments.length)
        return pointRadius;
      pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
      return path;
    };
    return path.projection(projection2).context(context);
  }

  // node_modules/d3-geo/src/transform.js
  function transform_default(methods2) {
    return {
      stream: transformer(methods2)
    };
  }
  function transformer(methods2) {
    return function(stream) {
      var s2 = new TransformStream();
      for (var key in methods2)
        s2[key] = methods2[key];
      s2.stream = stream;
      return s2;
    };
  }
  function TransformStream() {
  }
  TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x2, y2) {
      this.stream.point(x2, y2);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };

  // node_modules/d3-geo/src/projection/fit.js
  function fit(projection2, fitBounds, object) {
    var clip = projection2.clipExtent && projection2.clipExtent();
    projection2.scale(150).translate([0, 0]);
    if (clip != null)
      projection2.clipExtent(null);
    stream_default(object, projection2.stream(bounds_default2));
    fitBounds(bounds_default2.result());
    if (clip != null)
      projection2.clipExtent(clip);
    return projection2;
  }
  function fitExtent(projection2, extent, object) {
    return fit(projection2, function(b2) {
      var w2 = extent[1][0] - extent[0][0], h2 = extent[1][1] - extent[0][1], k2 = Math.min(w2 / (b2[1][0] - b2[0][0]), h2 / (b2[1][1] - b2[0][1])), x2 = +extent[0][0] + (w2 - k2 * (b2[1][0] + b2[0][0])) / 2, y2 = +extent[0][1] + (h2 - k2 * (b2[1][1] + b2[0][1])) / 2;
      projection2.scale(150 * k2).translate([x2, y2]);
    }, object);
  }
  function fitSize(projection2, size, object) {
    return fitExtent(projection2, [[0, 0], size], object);
  }
  function fitWidth(projection2, width, object) {
    return fit(projection2, function(b2) {
      var w2 = +width, k2 = w2 / (b2[1][0] - b2[0][0]), x2 = (w2 - k2 * (b2[1][0] + b2[0][0])) / 2, y2 = -k2 * b2[0][1];
      projection2.scale(150 * k2).translate([x2, y2]);
    }, object);
  }
  function fitHeight(projection2, height, object) {
    return fit(projection2, function(b2) {
      var h2 = +height, k2 = h2 / (b2[1][1] - b2[0][1]), x2 = -k2 * b2[0][0], y2 = (h2 - k2 * (b2[1][1] + b2[0][1])) / 2;
      projection2.scale(150 * k2).translate([x2, y2]);
    }, object);
  }

  // node_modules/d3-geo/src/projection/resample.js
  var maxDepth = 16;
  var cosMinDistance = cos(30 * radians);
  function resample_default(project, delta2) {
    return +delta2 ? resample(project, delta2) : resampleNone(project);
  }
  function resampleNone(project) {
    return transformer({
      point: function(x2, y2) {
        x2 = project(x2, y2);
        this.stream.point(x2[0], x2[1]);
      }
    });
  }
  function resample(project, delta2) {
    function resampleLineTo(x05, y05, lambda04, a0, b0, c0, x12, y12, lambda12, a1, b1, c1, depth, stream) {
      var dx = x12 - x05, dy = y12 - y05, d2 = dx * dx + dy * dy;
      if (d2 > 4 * delta2 && depth--) {
        var a2 = a0 + a1, b2 = b0 + b1, c2 = c0 + c1, m2 = sqrt(a2 * a2 + b2 * b2 + c2 * c2), phi2 = asin(c2 /= m2), lambda22 = abs(abs(c2) - 1) < epsilon || abs(lambda04 - lambda12) < epsilon ? (lambda04 + lambda12) / 2 : atan2(b2, a2), p2 = project(lambda22, phi2), x2 = p2[0], y2 = p2[1], dx2 = x2 - x05, dy2 = y2 - y05, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x05, y05, lambda04, a0, b0, c0, x2, y2, lambda22, a2 /= m2, b2 /= m2, c2, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, lambda22, a2, b2, c2, x12, y12, lambda12, a1, b1, c1, depth, stream);
        }
      }
    }
    return function(stream) {
      var lambda003, x004, y004, a00, b00, c00, lambda04, x05, y05, a0, b0, c0;
      var resampleStream = {
        point: point2,
        lineStart,
        lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resampleStream.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resampleStream.lineStart = lineStart;
        }
      };
      function point2(x2, y2) {
        x2 = project(x2, y2);
        stream.point(x2[0], x2[1]);
      }
      function lineStart() {
        x05 = NaN;
        resampleStream.point = linePoint2;
        stream.lineStart();
      }
      function linePoint2(lambda, phi) {
        var c2 = cartesian([lambda, phi]), p2 = project(lambda, phi);
        resampleLineTo(x05, y05, lambda04, a0, b0, c0, x05 = p2[0], y05 = p2[1], lambda04 = lambda, a0 = c2[0], b0 = c2[1], c0 = c2[2], maxDepth, stream);
        stream.point(x05, y05);
      }
      function lineEnd() {
        resampleStream.point = point2;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resampleStream.point = ringPoint;
        resampleStream.lineEnd = ringEnd;
      }
      function ringPoint(lambda, phi) {
        linePoint2(lambda003 = lambda, phi), x004 = x05, y004 = y05, a00 = a0, b00 = b0, c00 = c0;
        resampleStream.point = linePoint2;
      }
      function ringEnd() {
        resampleLineTo(x05, y05, lambda04, a0, b0, c0, x004, y004, lambda003, a00, b00, c00, maxDepth, stream);
        resampleStream.lineEnd = lineEnd;
        lineEnd();
      }
      return resampleStream;
    };
  }

  // node_modules/d3-geo/src/projection/index.js
  var transformRadians = transformer({
    point: function(x2, y2) {
      this.stream.point(x2 * radians, y2 * radians);
    }
  });
  function transformRotate(rotate) {
    return transformer({
      point: function(x2, y2) {
        var r2 = rotate(x2, y2);
        return this.stream.point(r2[0], r2[1]);
      }
    });
  }
  function scaleTranslate(k2, dx, dy, sx, sy) {
    function transform2(x2, y2) {
      x2 *= sx;
      y2 *= sy;
      return [dx + k2 * x2, dy - k2 * y2];
    }
    transform2.invert = function(x2, y2) {
      return [(x2 - dx) / k2 * sx, (dy - y2) / k2 * sy];
    };
    return transform2;
  }
  function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
    if (!alpha)
      return scaleTranslate(k2, dx, dy, sx, sy);
    var cosAlpha = cos(alpha), sinAlpha = sin(alpha), a2 = cosAlpha * k2, b2 = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
    function transform2(x2, y2) {
      x2 *= sx;
      y2 *= sy;
      return [a2 * x2 - b2 * y2 + dx, dy - b2 * x2 - a2 * y2];
    }
    transform2.invert = function(x2, y2) {
      return [sx * (ai * x2 - bi * y2 + ci), sy * (fi - bi * x2 - ai * y2)];
    };
    return transform2;
  }
  function projection(project) {
    return projectionMutator(function() {
      return project;
    })();
  }
  function projectionMutator(projectAt) {
    var project, k2 = 150, x2 = 480, y2 = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x05 = null, y05, x12, y12, postclip = identity_default, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
    function projection2(point2) {
      return projectRotateTransform(point2[0] * radians, point2[1] * radians);
    }
    function invert(point2) {
      point2 = projectRotateTransform.invert(point2[0], point2[1]);
      return point2 && [point2[0] * degrees, point2[1] * degrees];
    }
    projection2.stream = function(stream) {
      return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
    };
    projection2.preclip = function(_2) {
      return arguments.length ? (preclip = _2, theta = void 0, reset()) : preclip;
    };
    projection2.postclip = function(_2) {
      return arguments.length ? (postclip = _2, x05 = y05 = x12 = y12 = null, reset()) : postclip;
    };
    projection2.clipAngle = function(_2) {
      return arguments.length ? (preclip = +_2 ? circle_default(theta = _2 * radians) : (theta = null, antimeridian_default), reset()) : theta * degrees;
    };
    projection2.clipExtent = function(_2) {
      return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x12 = y12 = null, identity_default) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
    };
    projection2.scale = function(_2) {
      return arguments.length ? (k2 = +_2, recenter()) : k2;
    };
    projection2.translate = function(_2) {
      return arguments.length ? (x2 = +_2[0], y2 = +_2[1], recenter()) : [x2, y2];
    };
    projection2.center = function(_2) {
      return arguments.length ? (lambda = _2[0] % 360 * radians, phi = _2[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
    };
    projection2.rotate = function(_2) {
      return arguments.length ? (deltaLambda = _2[0] % 360 * radians, deltaPhi = _2[1] % 360 * radians, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
    };
    projection2.angle = function(_2) {
      return arguments.length ? (alpha = _2 % 360 * radians, recenter()) : alpha * degrees;
    };
    projection2.reflectX = function(_2) {
      return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
    };
    projection2.reflectY = function(_2) {
      return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
    };
    projection2.precision = function(_2) {
      return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _2 * _2), reset()) : sqrt(delta2);
    };
    projection2.fitExtent = function(extent, object) {
      return fitExtent(projection2, extent, object);
    };
    projection2.fitSize = function(size, object) {
      return fitSize(projection2, size, object);
    };
    projection2.fitWidth = function(width, object) {
      return fitWidth(projection2, width, object);
    };
    projection2.fitHeight = function(height, object) {
      return fitHeight(projection2, height, object);
    };
    function recenter() {
      var center = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)), transform2 = scaleTranslateRotate(k2, x2 - center[0], y2 - center[1], sx, sy, alpha);
      rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
      projectTransform = compose_default(project, transform2);
      projectRotateTransform = compose_default(rotate, projectTransform);
      projectResample = resample_default(projectTransform, delta2);
      return reset();
    }
    function reset() {
      cache = cacheStream = null;
      return projection2;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection2.invert = project.invert && invert;
      return recenter();
    };
  }

  // node_modules/d3-geo/src/projection/mercator.js
  function mercatorRaw(lambda, phi) {
    return [lambda, log(tan((halfPi + phi) / 2))];
  }
  mercatorRaw.invert = function(x2, y2) {
    return [x2, 2 * atan(exp(y2)) - halfPi];
  };
  function mercator_default() {
    return mercatorProjection(mercatorRaw).scale(961 / tau);
  }
  function mercatorProjection(project) {
    var m2 = projection(project), center = m2.center, scale = m2.scale, translate = m2.translate, clipExtent = m2.clipExtent, x05 = null, y05, x12, y12;
    m2.scale = function(_2) {
      return arguments.length ? (scale(_2), reclip()) : scale();
    };
    m2.translate = function(_2) {
      return arguments.length ? (translate(_2), reclip()) : translate();
    };
    m2.center = function(_2) {
      return arguments.length ? (center(_2), reclip()) : center();
    };
    m2.clipExtent = function(_2) {
      return arguments.length ? (_2 == null ? x05 = y05 = x12 = y12 = null : (x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reclip()) : x05 == null ? null : [[x05, y05], [x12, y12]];
    };
    function reclip() {
      var k2 = pi * scale(), t2 = m2(rotation_default(m2.rotate()).invert([0, 0]));
      return clipExtent(x05 == null ? [[t2[0] - k2, t2[1] - k2], [t2[0] + k2, t2[1] + k2]] : project === mercatorRaw ? [[Math.max(t2[0] - k2, x05), y05], [Math.min(t2[0] + k2, x12), y12]] : [[x05, Math.max(t2[1] - k2, y05)], [x12, Math.min(t2[1] + k2, y12)]]);
    }
    return reclip();
  }

  // node_modules/d3-geo/src/projection/identity.js
  function identity_default2() {
    var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x05 = null, y05, x12, y12, kx = 1, ky = 1, transform2 = transformer({
      point: function(x2, y2) {
        var p2 = projection2([x2, y2]);
        this.stream.point(p2[0], p2[1]);
      }
    }), postclip = identity_default, cache, cacheStream;
    function reset() {
      kx = k2 * sx;
      ky = k2 * sy;
      cache = cacheStream = null;
      return projection2;
    }
    function projection2(p2) {
      var x2 = p2[0] * kx, y2 = p2[1] * ky;
      if (alpha) {
        var t2 = y2 * ca - x2 * sa;
        x2 = x2 * ca + y2 * sa;
        y2 = t2;
      }
      return [x2 + tx, y2 + ty];
    }
    projection2.invert = function(p2) {
      var x2 = p2[0] - tx, y2 = p2[1] - ty;
      if (alpha) {
        var t2 = y2 * ca + x2 * sa;
        x2 = x2 * ca - y2 * sa;
        y2 = t2;
      }
      return [x2 / kx, y2 / ky];
    };
    projection2.stream = function(stream) {
      return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));
    };
    projection2.postclip = function(_2) {
      return arguments.length ? (postclip = _2, x05 = y05 = x12 = y12 = null, reset()) : postclip;
    };
    projection2.clipExtent = function(_2) {
      return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x12 = y12 = null, identity_default) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
    };
    projection2.scale = function(_2) {
      return arguments.length ? (k2 = +_2, reset()) : k2;
    };
    projection2.translate = function(_2) {
      return arguments.length ? (tx = +_2[0], ty = +_2[1], reset()) : [tx, ty];
    };
    projection2.angle = function(_2) {
      return arguments.length ? (alpha = _2 % 360 * radians, sa = sin(alpha), ca = cos(alpha), reset()) : alpha * degrees;
    };
    projection2.reflectX = function(_2) {
      return arguments.length ? (sx = _2 ? -1 : 1, reset()) : sx < 0;
    };
    projection2.reflectY = function(_2) {
      return arguments.length ? (sy = _2 ? -1 : 1, reset()) : sy < 0;
    };
    projection2.fitExtent = function(extent, object) {
      return fitExtent(projection2, extent, object);
    };
    projection2.fitSize = function(size, object) {
      return fitSize(projection2, size, object);
    };
    projection2.fitWidth = function(width, object) {
      return fitWidth(projection2, width, object);
    };
    projection2.fitHeight = function(height, object) {
      return fitHeight(projection2, height, object);
    };
    return projection2;
  }

  // modules/geo/geo.js
  var TAU = 2 * Math.PI;
  var EQUATORIAL_RADIUS = 6378137;
  var POLAR_RADIUS = 63567523e-1;
  function geoLatToMeters(dLat) {
    return dLat * (TAU * POLAR_RADIUS / 360);
  }
  function geoLonToMeters(dLon, atLat) {
    return Math.abs(atLat) >= 90 ? 0 : dLon * (TAU * EQUATORIAL_RADIUS / 360) * Math.abs(Math.cos(atLat * (Math.PI / 180)));
  }
  function geoMetersToLat(m2) {
    return m2 / (TAU * POLAR_RADIUS / 360);
  }
  function geoMetersToLon(m2, atLat) {
    return Math.abs(atLat) >= 90 ? 0 : m2 / (TAU * EQUATORIAL_RADIUS / 360) / Math.abs(Math.cos(atLat * (Math.PI / 180)));
  }
  function geoMetersToOffset(meters, tileSize) {
    tileSize = tileSize || 256;
    return [
      meters[0] * tileSize / (TAU * EQUATORIAL_RADIUS),
      -meters[1] * tileSize / (TAU * POLAR_RADIUS)
    ];
  }
  function geoOffsetToMeters(offset, tileSize) {
    tileSize = tileSize || 256;
    return [
      offset[0] * TAU * EQUATORIAL_RADIUS / tileSize,
      -offset[1] * TAU * POLAR_RADIUS / tileSize
    ];
  }
  function geoSphericalDistance(a2, b2) {
    var x2 = geoLonToMeters(a2[0] - b2[0], (a2[1] + b2[1]) / 2);
    var y2 = geoLatToMeters(a2[1] - b2[1]);
    return Math.sqrt(x2 * x2 + y2 * y2);
  }
  function geoScaleToZoom(k2, tileSize) {
    tileSize = tileSize || 256;
    var log2ts = Math.log(tileSize) * Math.LOG2E;
    return Math.log(k2 * TAU) / Math.LN2 - log2ts;
  }
  function geoZoomToScale(z2, tileSize) {
    tileSize = tileSize || 256;
    return tileSize * Math.pow(2, z2) / TAU;
  }
  function geoSphericalClosestNode(nodes, point2) {
    var minDistance = Infinity, distance;
    var indexOfMin;
    for (var i3 in nodes) {
      distance = geoSphericalDistance(nodes[i3].loc, point2);
      if (distance < minDistance) {
        minDistance = distance;
        indexOfMin = i3;
      }
    }
    if (indexOfMin !== void 0) {
      return { index: indexOfMin, distance: minDistance, node: nodes[indexOfMin] };
    } else {
      return null;
    }
  }

  // modules/geo/extent.js
  function geoExtent(min3, max3) {
    if (!(this instanceof geoExtent)) {
      return new geoExtent(min3, max3);
    } else if (min3 instanceof geoExtent) {
      return min3;
    } else if (min3 && min3.length === 2 && min3[0].length === 2 && min3[1].length === 2) {
      this[0] = min3[0];
      this[1] = min3[1];
    } else {
      this[0] = min3 || [Infinity, Infinity];
      this[1] = max3 || min3 || [-Infinity, -Infinity];
    }
  }
  geoExtent.prototype = new Array(2);
  Object.assign(geoExtent.prototype, {
    equals: function(obj) {
      return this[0][0] === obj[0][0] && this[0][1] === obj[0][1] && this[1][0] === obj[1][0] && this[1][1] === obj[1][1];
    },
    extend: function(obj) {
      if (!(obj instanceof geoExtent))
        obj = new geoExtent(obj);
      return geoExtent(
        [Math.min(obj[0][0], this[0][0]), Math.min(obj[0][1], this[0][1])],
        [Math.max(obj[1][0], this[1][0]), Math.max(obj[1][1], this[1][1])]
      );
    },
    _extend: function(extent) {
      this[0][0] = Math.min(extent[0][0], this[0][0]);
      this[0][1] = Math.min(extent[0][1], this[0][1]);
      this[1][0] = Math.max(extent[1][0], this[1][0]);
      this[1][1] = Math.max(extent[1][1], this[1][1]);
    },
    area: function() {
      return Math.abs((this[1][0] - this[0][0]) * (this[1][1] - this[0][1]));
    },
    center: function() {
      return [(this[0][0] + this[1][0]) / 2, (this[0][1] + this[1][1]) / 2];
    },
    rectangle: function() {
      return [this[0][0], this[0][1], this[1][0], this[1][1]];
    },
    bbox: function() {
      return { minX: this[0][0], minY: this[0][1], maxX: this[1][0], maxY: this[1][1] };
    },
    polygon: function() {
      return [
        [this[0][0], this[0][1]],
        [this[0][0], this[1][1]],
        [this[1][0], this[1][1]],
        [this[1][0], this[0][1]],
        [this[0][0], this[0][1]]
      ];
    },
    contains: function(obj) {
      if (!(obj instanceof geoExtent))
        obj = new geoExtent(obj);
      return obj[0][0] >= this[0][0] && obj[0][1] >= this[0][1] && obj[1][0] <= this[1][0] && obj[1][1] <= this[1][1];
    },
    intersects: function(obj) {
      if (!(obj instanceof geoExtent))
        obj = new geoExtent(obj);
      return obj[0][0] <= this[1][0] && obj[0][1] <= this[1][1] && obj[1][0] >= this[0][0] && obj[1][1] >= this[0][1];
    },
    intersection: function(obj) {
      if (!this.intersects(obj))
        return new geoExtent();
      return new geoExtent(
        [Math.max(obj[0][0], this[0][0]), Math.max(obj[0][1], this[0][1])],
        [Math.min(obj[1][0], this[1][0]), Math.min(obj[1][1], this[1][1])]
      );
    },
    percentContainedIn: function(obj) {
      if (!(obj instanceof geoExtent))
        obj = new geoExtent(obj);
      var a1 = this.intersection(obj).area();
      var a2 = this.area();
      if (a1 === Infinity || a2 === Infinity) {
        return 0;
      } else if (a1 === 0 || a2 === 0) {
        if (obj.contains(this)) {
          return 1;
        }
        return 0;
      } else {
        return a1 / a2;
      }
    },
    padByMeters: function(meters) {
      var dLat = geoMetersToLat(meters);
      var dLon = geoMetersToLon(meters, this.center()[1]);
      return geoExtent(
        [this[0][0] - dLon, this[0][1] - dLat],
        [this[1][0] + dLon, this[1][1] + dLat]
      );
    },
    toParam: function() {
      return this.rectangle().join(",");
    },
    split: function() {
      const center = this.center();
      return [
        geoExtent(this[0], center),
        geoExtent([center[0], this[0][1]], [this[1][0], center[1]]),
        geoExtent(center, this[1]),
        geoExtent([this[0][0], center[1]], [center[0], this[1][1]])
      ];
    }
  });

  // node_modules/d3-polygon/src/area.js
  function area_default3(polygon2) {
    var i3 = -1, n3 = polygon2.length, a2, b2 = polygon2[n3 - 1], area = 0;
    while (++i3 < n3) {
      a2 = b2;
      b2 = polygon2[i3];
      area += a2[1] * b2[0] - a2[0] * b2[1];
    }
    return area / 2;
  }

  // node_modules/d3-polygon/src/centroid.js
  function centroid_default2(polygon2) {
    var i3 = -1, n3 = polygon2.length, x2 = 0, y2 = 0, a2, b2 = polygon2[n3 - 1], c2, k2 = 0;
    while (++i3 < n3) {
      a2 = b2;
      b2 = polygon2[i3];
      k2 += c2 = a2[0] * b2[1] - b2[0] * a2[1];
      x2 += (a2[0] + b2[0]) * c2;
      y2 += (a2[1] + b2[1]) * c2;
    }
    return k2 *= 3, [x2 / k2, y2 / k2];
  }

  // node_modules/d3-polygon/src/cross.js
  function cross_default(a2, b2, c2) {
    return (b2[0] - a2[0]) * (c2[1] - a2[1]) - (b2[1] - a2[1]) * (c2[0] - a2[0]);
  }

  // node_modules/d3-polygon/src/hull.js
  function lexicographicOrder(a2, b2) {
    return a2[0] - b2[0] || a2[1] - b2[1];
  }
  function computeUpperHullIndexes(points) {
    const n3 = points.length, indexes = [0, 1];
    let size = 2, i3;
    for (i3 = 2; i3 < n3; ++i3) {
      while (size > 1 && cross_default(points[indexes[size - 2]], points[indexes[size - 1]], points[i3]) <= 0)
        --size;
      indexes[size++] = i3;
    }
    return indexes.slice(0, size);
  }
  function hull_default(points) {
    if ((n3 = points.length) < 3)
      return null;
    var i3, n3, sortedPoints = new Array(n3), flippedPoints = new Array(n3);
    for (i3 = 0; i3 < n3; ++i3)
      sortedPoints[i3] = [+points[i3][0], +points[i3][1], i3];
    sortedPoints.sort(lexicographicOrder);
    for (i3 = 0; i3 < n3; ++i3)
      flippedPoints[i3] = [sortedPoints[i3][0], -sortedPoints[i3][1]];
    var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);
    var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull = [];
    for (i3 = upperIndexes.length - 1; i3 >= 0; --i3)
      hull.push(points[sortedPoints[upperIndexes[i3]][2]]);
    for (i3 = +skipLeft; i3 < lowerIndexes.length - skipRight; ++i3)
      hull.push(points[sortedPoints[lowerIndexes[i3]][2]]);
    return hull;
  }

  // modules/geo/vector.js
  function geoVecEqual(a2, b2, epsilon3) {
    if (epsilon3) {
      return Math.abs(a2[0] - b2[0]) <= epsilon3 && Math.abs(a2[1] - b2[1]) <= epsilon3;
    } else {
      return a2[0] === b2[0] && a2[1] === b2[1];
    }
  }
  function geoVecAdd(a2, b2) {
    return [a2[0] + b2[0], a2[1] + b2[1]];
  }
  function geoVecSubtract(a2, b2) {
    return [a2[0] - b2[0], a2[1] - b2[1]];
  }
  function geoVecScale(a2, mag) {
    return [a2[0] * mag, a2[1] * mag];
  }
  function geoVecFloor(a2) {
    return [Math.floor(a2[0]), Math.floor(a2[1])];
  }
  function geoVecInterp(a2, b2, t2) {
    return [
      a2[0] + (b2[0] - a2[0]) * t2,
      a2[1] + (b2[1] - a2[1]) * t2
    ];
  }
  function geoVecLength(a2, b2) {
    return Math.sqrt(geoVecLengthSquare(a2, b2));
  }
  function geoVecLengthSquare(a2, b2) {
    b2 = b2 || [0, 0];
    var x2 = a2[0] - b2[0];
    var y2 = a2[1] - b2[1];
    return x2 * x2 + y2 * y2;
  }
  function geoVecNormalize(a2) {
    var length2 = Math.sqrt(a2[0] * a2[0] + a2[1] * a2[1]);
    if (length2 !== 0) {
      return geoVecScale(a2, 1 / length2);
    }
    return [0, 0];
  }
  function geoVecAngle(a2, b2) {
    return Math.atan2(b2[1] - a2[1], b2[0] - a2[0]);
  }
  function geoVecDot(a2, b2, origin) {
    origin = origin || [0, 0];
    var p2 = geoVecSubtract(a2, origin);
    var q2 = geoVecSubtract(b2, origin);
    return p2[0] * q2[0] + p2[1] * q2[1];
  }
  function geoVecNormalizedDot(a2, b2, origin) {
    origin = origin || [0, 0];
    var p2 = geoVecNormalize(geoVecSubtract(a2, origin));
    var q2 = geoVecNormalize(geoVecSubtract(b2, origin));
    return geoVecDot(p2, q2);
  }
  function geoVecCross(a2, b2, origin) {
    origin = origin || [0, 0];
    var p2 = geoVecSubtract(a2, origin);
    var q2 = geoVecSubtract(b2, origin);
    return p2[0] * q2[1] - p2[1] * q2[0];
  }
  function geoVecProject(a2, points) {
    var min3 = Infinity;
    var idx;
    var target;
    for (var i3 = 0; i3 < points.length - 1; i3++) {
      var o2 = points[i3];
      var s2 = geoVecSubtract(points[i3 + 1], o2);
      var v2 = geoVecSubtract(a2, o2);
      var proj = geoVecDot(v2, s2) / geoVecDot(s2, s2);
      var p2;
      if (proj < 0) {
        p2 = o2;
      } else if (proj > 1) {
        p2 = points[i3 + 1];
      } else {
        p2 = [o2[0] + proj * s2[0], o2[1] + proj * s2[1]];
      }
      var dist = geoVecLength(p2, a2);
      if (dist < min3) {
        min3 = dist;
        idx = i3 + 1;
        target = p2;
      }
    }
    if (idx !== void 0) {
      return { index: idx, distance: min3, target };
    } else {
      return null;
    }
  }

  // modules/geo/geom.js
  function geoAngle(a2, b2, projection2) {
    return geoVecAngle(projection2(a2.loc), projection2(b2.loc));
  }
  function geoEdgeEqual(a2, b2) {
    return a2[0] === b2[0] && a2[1] === b2[1] || a2[0] === b2[1] && a2[1] === b2[0];
  }
  function geoRotate(points, angle2, around) {
    return points.map(function(point2) {
      var radial = geoVecSubtract(point2, around);
      return [
        radial[0] * Math.cos(angle2) - radial[1] * Math.sin(angle2) + around[0],
        radial[0] * Math.sin(angle2) + radial[1] * Math.cos(angle2) + around[1]
      ];
    });
  }
  function geoChooseEdge(nodes, point2, projection2, activeID) {
    var dist = geoVecLength;
    var points = nodes.map(function(n3) {
      return projection2(n3.loc);
    });
    var ids = nodes.map(function(n3) {
      return n3.id;
    });
    var min3 = Infinity;
    var idx;
    var loc;
    for (var i3 = 0; i3 < points.length - 1; i3++) {
      if (ids[i3] === activeID || ids[i3 + 1] === activeID)
        continue;
      var o2 = points[i3];
      var s2 = geoVecSubtract(points[i3 + 1], o2);
      var v2 = geoVecSubtract(point2, o2);
      var proj = geoVecDot(v2, s2) / geoVecDot(s2, s2);
      var p2;
      if (proj < 0) {
        p2 = o2;
      } else if (proj > 1) {
        p2 = points[i3 + 1];
      } else {
        p2 = [o2[0] + proj * s2[0], o2[1] + proj * s2[1]];
      }
      var d2 = dist(p2, point2);
      if (d2 < min3) {
        min3 = d2;
        idx = i3 + 1;
        loc = projection2.invert(p2);
      }
    }
    if (idx !== void 0) {
      return { index: idx, distance: min3, loc };
    } else {
      return null;
    }
  }
  function geoHasLineIntersections(activeNodes, inactiveNodes, activeID) {
    var actives = [];
    var inactives = [];
    var j2, k2, n1, n22, segment;
    for (j2 = 0; j2 < activeNodes.length - 1; j2++) {
      n1 = activeNodes[j2];
      n22 = activeNodes[j2 + 1];
      segment = [n1.loc, n22.loc];
      if (n1.id === activeID || n22.id === activeID) {
        actives.push(segment);
      }
    }
    for (j2 = 0; j2 < inactiveNodes.length - 1; j2++) {
      n1 = inactiveNodes[j2];
      n22 = inactiveNodes[j2 + 1];
      segment = [n1.loc, n22.loc];
      inactives.push(segment);
    }
    for (j2 = 0; j2 < actives.length; j2++) {
      for (k2 = 0; k2 < inactives.length; k2++) {
        var p2 = actives[j2];
        var q2 = inactives[k2];
        var hit = geoLineIntersection(p2, q2);
        if (hit) {
          return true;
        }
      }
    }
    return false;
  }
  function geoHasSelfIntersections(nodes, activeID) {
    var actives = [];
    var inactives = [];
    var j2, k2;
    for (j2 = 0; j2 < nodes.length - 1; j2++) {
      var n1 = nodes[j2];
      var n22 = nodes[j2 + 1];
      var segment = [n1.loc, n22.loc];
      if (n1.id === activeID || n22.id === activeID) {
        actives.push(segment);
      } else {
        inactives.push(segment);
      }
    }
    for (j2 = 0; j2 < actives.length; j2++) {
      for (k2 = 0; k2 < inactives.length; k2++) {
        var p2 = actives[j2];
        var q2 = inactives[k2];
        if (geoVecEqual(p2[1], q2[0]) || geoVecEqual(p2[0], q2[1]) || geoVecEqual(p2[0], q2[0]) || geoVecEqual(p2[1], q2[1])) {
          continue;
        }
        var hit = geoLineIntersection(p2, q2);
        if (hit) {
          var epsilon3 = 1e-8;
          if (geoVecEqual(p2[1], hit, epsilon3) || geoVecEqual(p2[0], hit, epsilon3) || geoVecEqual(q2[1], hit, epsilon3) || geoVecEqual(q2[0], hit, epsilon3)) {
            continue;
          } else {
            return true;
          }
        }
      }
    }
    return false;
  }
  function geoLineIntersection(a2, b2) {
    var p2 = [a2[0][0], a2[0][1]];
    var p22 = [a2[1][0], a2[1][1]];
    var q2 = [b2[0][0], b2[0][1]];
    var q22 = [b2[1][0], b2[1][1]];
    var r2 = geoVecSubtract(p22, p2);
    var s2 = geoVecSubtract(q22, q2);
    var uNumerator = geoVecCross(geoVecSubtract(q2, p2), r2);
    var denominator = geoVecCross(r2, s2);
    if (uNumerator && denominator) {
      var u2 = uNumerator / denominator;
      var t2 = geoVecCross(geoVecSubtract(q2, p2), s2) / denominator;
      if (t2 >= 0 && t2 <= 1 && u2 >= 0 && u2 <= 1) {
        return geoVecInterp(p2, p22, t2);
      }
    }
    return null;
  }
  function geoPathIntersections(path1, path2) {
    var intersections = [];
    for (var i3 = 0; i3 < path1.length - 1; i3++) {
      for (var j2 = 0; j2 < path2.length - 1; j2++) {
        var a2 = [path1[i3], path1[i3 + 1]];
        var b2 = [path2[j2], path2[j2 + 1]];
        var hit = geoLineIntersection(a2, b2);
        if (hit) {
          intersections.push(hit);
        }
      }
    }
    return intersections;
  }
  function geoPathHasIntersections(path1, path2) {
    for (var i3 = 0; i3 < path1.length - 1; i3++) {
      for (var j2 = 0; j2 < path2.length - 1; j2++) {
        var a2 = [path1[i3], path1[i3 + 1]];
        var b2 = [path2[j2], path2[j2 + 1]];
        var hit = geoLineIntersection(a2, b2);
        if (hit) {
          return true;
        }
      }
    }
    return false;
  }
  function geoPointInPolygon(point2, polygon2) {
    var x2 = point2[0];
    var y2 = point2[1];
    var inside = false;
    for (var i3 = 0, j2 = polygon2.length - 1; i3 < polygon2.length; j2 = i3++) {
      var xi = polygon2[i3][0];
      var yi = polygon2[i3][1];
      var xj = polygon2[j2][0];
      var yj = polygon2[j2][1];
      var intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
      if (intersect2)
        inside = !inside;
    }
    return inside;
  }
  function geoPolygonContainsPolygon(outer, inner) {
    return inner.every(function(point2) {
      return geoPointInPolygon(point2, outer);
    });
  }
  function geoPolygonIntersectsPolygon(outer, inner, checkSegments) {
    function testPoints(outer2, inner2) {
      return inner2.some(function(point2) {
        return geoPointInPolygon(point2, outer2);
      });
    }
    return testPoints(outer, inner) || !!checkSegments && geoPathHasIntersections(outer, inner);
  }
  function geoGetSmallestSurroundingRectangle(points) {
    var hull = hull_default(points);
    var centroid = centroid_default2(hull);
    var minArea = Infinity;
    var ssrExtent = [];
    var ssrAngle = 0;
    var c1 = hull[0];
    for (var i3 = 0; i3 <= hull.length - 1; i3++) {
      var c2 = i3 === hull.length - 1 ? hull[0] : hull[i3 + 1];
      var angle2 = Math.atan2(c2[1] - c1[1], c2[0] - c1[0]);
      var poly = geoRotate(hull, -angle2, centroid);
      var extent = poly.reduce(function(extent2, point2) {
        return extent2.extend(geoExtent(point2));
      }, geoExtent());
      var area = extent.area();
      if (area < minArea) {
        minArea = area;
        ssrExtent = extent;
        ssrAngle = angle2;
      }
      c1 = c2;
    }
    return {
      poly: geoRotate(ssrExtent.polygon(), ssrAngle, centroid),
      angle: ssrAngle
    };
  }
  function geoPathLength(path) {
    var length2 = 0;
    for (var i3 = 0; i3 < path.length - 1; i3++) {
      length2 += geoVecLength(path[i3], path[i3 + 1]);
    }
    return length2;
  }
  function geoViewportEdge(point2, dimensions) {
    var pad2 = [80, 20, 50, 20];
    var x2 = 0;
    var y2 = 0;
    if (point2[0] > dimensions[0] - pad2[1]) {
      x2 = -10;
    }
    if (point2[0] < pad2[3]) {
      x2 = 10;
    }
    if (point2[1] > dimensions[1] - pad2[2]) {
      y2 = -10;
    }
    if (point2[1] < pad2[0]) {
      y2 = 10;
    }
    if (x2 || y2) {
      return [x2, y2];
    } else {
      return null;
    }
  }

  // node_modules/d3-dispatch/src/dispatch.js
  var noop2 = { value: () => {
  } };
  function dispatch() {
    for (var i3 = 0, n3 = arguments.length, _2 = {}, t2; i3 < n3; ++i3) {
      if (!(t2 = arguments[i3] + "") || t2 in _2 || /[\s.]/.test(t2))
        throw new Error("illegal type: " + t2);
      _2[t2] = [];
    }
    return new Dispatch(_2);
  }
  function Dispatch(_2) {
    this._ = _2;
  }
  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t2) {
      var name = "", i3 = t2.indexOf(".");
      if (i3 >= 0)
        name = t2.slice(i3 + 1), t2 = t2.slice(0, i3);
      if (t2 && !types.hasOwnProperty(t2))
        throw new Error("unknown type: " + t2);
      return { type: t2, name };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _2 = this._, T2 = parseTypenames(typename + "", _2), t2, i3 = -1, n3 = T2.length;
      if (arguments.length < 2) {
        while (++i3 < n3)
          if ((t2 = (typename = T2[i3]).type) && (t2 = get(_2[t2], typename.name)))
            return t2;
        return;
      }
      if (callback != null && typeof callback !== "function")
        throw new Error("invalid callback: " + callback);
      while (++i3 < n3) {
        if (t2 = (typename = T2[i3]).type)
          _2[t2] = set(_2[t2], typename.name, callback);
        else if (callback == null)
          for (t2 in _2)
            _2[t2] = set(_2[t2], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy2 = {}, _2 = this._;
      for (var t2 in _2)
        copy2[t2] = _2[t2].slice();
      return new Dispatch(copy2);
    },
    call: function(type2, that) {
      if ((n3 = arguments.length - 2) > 0)
        for (var args = new Array(n3), i3 = 0, n3, t2; i3 < n3; ++i3)
          args[i3] = arguments[i3 + 2];
      if (!this._.hasOwnProperty(type2))
        throw new Error("unknown type: " + type2);
      for (t2 = this._[type2], i3 = 0, n3 = t2.length; i3 < n3; ++i3)
        t2[i3].value.apply(that, args);
    },
    apply: function(type2, that, args) {
      if (!this._.hasOwnProperty(type2))
        throw new Error("unknown type: " + type2);
      for (var t2 = this._[type2], i3 = 0, n3 = t2.length; i3 < n3; ++i3)
        t2[i3].value.apply(that, args);
    }
  };
  function get(type2, name) {
    for (var i3 = 0, n3 = type2.length, c2; i3 < n3; ++i3) {
      if ((c2 = type2[i3]).name === name) {
        return c2.value;
      }
    }
  }
  function set(type2, name, callback) {
    for (var i3 = 0, n3 = type2.length; i3 < n3; ++i3) {
      if (type2[i3].name === name) {
        type2[i3] = noop2, type2 = type2.slice(0, i3).concat(type2.slice(i3 + 1));
        break;
      }
    }
    if (callback != null)
      type2.push({ name, value: callback });
    return type2;
  }
  var dispatch_default = dispatch;

  // node_modules/d3-selection/src/namespaces.js
  var xhtml = "http://www.w3.org/1999/xhtml";
  var namespaces_default = {
    svg: "http://www.w3.org/2000/svg",
    xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  // node_modules/d3-selection/src/namespace.js
  function namespace_default(name) {
    var prefix = name += "", i3 = prefix.indexOf(":");
    if (i3 >= 0 && (prefix = name.slice(0, i3)) !== "xmlns")
      name = name.slice(i3 + 1);
    return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
  }

  // node_modules/d3-selection/src/creator.js
  function creatorInherit(name) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
    };
  }
  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator_default(name) {
    var fullname = namespace_default(name);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  }

  // node_modules/d3-selection/src/selector.js
  function none() {
  }
  function selector_default(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  // node_modules/d3-selection/src/selection/select.js
  function select_default(select) {
    if (typeof select !== "function")
      select = selector_default(select);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n3 = group.length, subgroup = subgroups[j2] = new Array(n3), node, subnode, i3 = 0; i3 < n3; ++i3) {
        if ((node = group[i3]) && (subnode = select.call(node, node.__data__, i3, group))) {
          if ("__data__" in node)
            subnode.__data__ = node.__data__;
          subgroup[i3] = subnode;
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/array.js
  function array(x2) {
    return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
  }

  // node_modules/d3-selection/src/selectorAll.js
  function empty() {
    return [];
  }
  function selectorAll_default(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }

  // node_modules/d3-selection/src/selection/selectAll.js
  function arrayAll(select) {
    return function() {
      return array(select.apply(this, arguments));
    };
  }
  function selectAll_default(select) {
    if (typeof select === "function")
      select = arrayAll(select);
    else
      select = selectorAll_default(select);
    for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n3 = group.length, node, i3 = 0; i3 < n3; ++i3) {
        if (node = group[i3]) {
          subgroups.push(select.call(node, node.__data__, i3, group));
          parents.push(node);
        }
      }
    }
    return new Selection(subgroups, parents);
  }

  // node_modules/d3-selection/src/matcher.js
  function matcher_default(selector) {
    return function() {
      return this.matches(selector);
    };
  }
  function childMatcher(selector) {
    return function(node) {
      return node.matches(selector);
    };
  }

  // node_modules/d3-selection/src/selection/selectChild.js
  var find = Array.prototype.find;
  function childFind(match) {
    return function() {
      return find.call(this.children, match);
    };
  }
  function childFirst() {
    return this.firstElementChild;
  }
  function selectChild_default(match) {
    return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
  }

  // node_modules/d3-selection/src/selection/selectChildren.js
  var filter = Array.prototype.filter;
  function children() {
    return Array.from(this.children);
  }
  function childrenFilter(match) {
    return function() {
      return filter.call(this.children, match);
    };
  }
  function selectChildren_default(match) {
    return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
  }

  // node_modules/d3-selection/src/selection/filter.js
  function filter_default(match) {
    if (typeof match !== "function")
      match = matcher_default(match);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n3 = group.length, subgroup = subgroups[j2] = [], node, i3 = 0; i3 < n3; ++i3) {
        if ((node = group[i3]) && match.call(node, node.__data__, i3, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/selection/sparse.js
  function sparse_default(update) {
    return new Array(update.length);
  }

  // node_modules/d3-selection/src/selection/enter.js
  function enter_default() {
    return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
  }
  function EnterNode(parent, datum2) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum2;
  }
  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) {
      return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next) {
      return this._parent.insertBefore(child, next);
    },
    querySelector: function(selector) {
      return this._parent.querySelector(selector);
    },
    querySelectorAll: function(selector) {
      return this._parent.querySelectorAll(selector);
    }
  };

  // node_modules/d3-selection/src/constant.js
  function constant_default(x2) {
    return function() {
      return x2;
    };
  }

  // node_modules/d3-selection/src/selection/data.js
  function bindIndex(parent, group, enter, update, exit, data) {
    var i3 = 0, node, groupLength = group.length, dataLength = data.length;
    for (; i3 < dataLength; ++i3) {
      if (node = group[i3]) {
        node.__data__ = data[i3];
        update[i3] = node;
      } else {
        enter[i3] = new EnterNode(parent, data[i3]);
      }
    }
    for (; i3 < groupLength; ++i3) {
      if (node = group[i3]) {
        exit[i3] = node;
      }
    }
  }
  function bindKey(parent, group, enter, update, exit, data, key) {
    var i3, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
    for (i3 = 0; i3 < groupLength; ++i3) {
      if (node = group[i3]) {
        keyValues[i3] = keyValue = key.call(node, node.__data__, i3, group) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i3] = node;
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
      }
    }
    for (i3 = 0; i3 < dataLength; ++i3) {
      keyValue = key.call(parent, data[i3], i3, data) + "";
      if (node = nodeByKeyValue.get(keyValue)) {
        update[i3] = node;
        node.__data__ = data[i3];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i3] = new EnterNode(parent, data[i3]);
      }
    }
    for (i3 = 0; i3 < groupLength; ++i3) {
      if ((node = group[i3]) && nodeByKeyValue.get(keyValues[i3]) === node) {
        exit[i3] = node;
      }
    }
  }
  function datum(node) {
    return node.__data__;
  }
  function data_default(value, key) {
    if (!arguments.length)
      return Array.from(this, datum);
    var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
    if (typeof value !== "function")
      value = constant_default(value);
    for (var m2 = groups.length, update = new Array(m2), enter = new Array(m2), exit = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      var parent = parents[j2], group = groups[j2], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j2, parents)), dataLength = data.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1)
            i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength)
            ;
          previous._next = next || null;
        }
      }
    }
    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }
  function arraylike(data) {
    return typeof data === "object" && "length" in data ? data : Array.from(data);
  }

  // node_modules/d3-selection/src/selection/exit.js
  function exit_default() {
    return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
  }

  // node_modules/d3-selection/src/selection/join.js
  function join_default(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    if (typeof onenter === "function") {
      enter = onenter(enter);
      if (enter)
        enter = enter.selection();
    } else {
      enter = enter.append(onenter + "");
    }
    if (onupdate != null) {
      update = onupdate(update);
      if (update)
        update = update.selection();
    }
    if (onexit == null)
      exit.remove();
    else
      onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }

  // node_modules/d3-selection/src/selection/merge.js
  function merge_default(context) {
    var selection2 = context.selection ? context.selection() : context;
    for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2) {
      for (var group0 = groups0[j2], group1 = groups1[j2], n3 = group0.length, merge2 = merges[j2] = new Array(n3), node, i3 = 0; i3 < n3; ++i3) {
        if (node = group0[i3] || group1[i3]) {
          merge2[i3] = node;
        }
      }
    }
    for (; j2 < m0; ++j2) {
      merges[j2] = groups0[j2];
    }
    return new Selection(merges, this._parents);
  }

  // node_modules/d3-selection/src/selection/order.js
  function order_default() {
    for (var groups = this._groups, j2 = -1, m2 = groups.length; ++j2 < m2; ) {
      for (var group = groups[j2], i3 = group.length - 1, next = group[i3], node; --i3 >= 0; ) {
        if (node = group[i3]) {
          if (next && node.compareDocumentPosition(next) ^ 4)
            next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/sort.js
  function sort_default(compare2) {
    if (!compare2)
      compare2 = ascending2;
    function compareNode(a2, b2) {
      return a2 && b2 ? compare2(a2.__data__, b2.__data__) : !a2 - !b2;
    }
    for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n3 = group.length, sortgroup = sortgroups[j2] = new Array(n3), node, i3 = 0; i3 < n3; ++i3) {
        if (node = group[i3]) {
          sortgroup[i3] = node;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection(sortgroups, this._parents).order();
  }
  function ascending2(a2, b2) {
    return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
  }

  // node_modules/d3-selection/src/selection/call.js
  function call_default() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  // node_modules/d3-selection/src/selection/nodes.js
  function nodes_default() {
    return Array.from(this);
  }

  // node_modules/d3-selection/src/selection/node.js
  function node_default() {
    for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
      for (var group = groups[j2], i3 = 0, n3 = group.length; i3 < n3; ++i3) {
        var node = group[i3];
        if (node)
          return node;
      }
    }
    return null;
  }

  // node_modules/d3-selection/src/selection/size.js
  function size_default() {
    let size = 0;
    for (const node of this)
      ++size;
    return size;
  }

  // node_modules/d3-selection/src/selection/empty.js
  function empty_default() {
    return !this.node();
  }

  // node_modules/d3-selection/src/selection/each.js
  function each_default(callback) {
    for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
      for (var group = groups[j2], i3 = 0, n3 = group.length, node; i3 < n3; ++i3) {
        if (node = group[i3])
          callback.call(node, node.__data__, i3, group);
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/attr.js
  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }
  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }
  function attrFunction(name, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null)
        this.removeAttribute(name);
      else
        this.setAttribute(name, v2);
    };
  }
  function attrFunctionNS(fullname, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null)
        this.removeAttributeNS(fullname.space, fullname.local);
      else
        this.setAttributeNS(fullname.space, fullname.local, v2);
    };
  }
  function attr_default(name, value) {
    var fullname = namespace_default(name);
    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
  }

  // node_modules/d3-selection/src/window.js
  function window_default(node) {
    return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
  }

  // node_modules/d3-selection/src/selection/style.js
  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }
  function styleFunction(name, value, priority) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null)
        this.style.removeProperty(name);
      else
        this.style.setProperty(name, v2, priority);
    };
  }
  function style_default(name, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
  }
  function styleValue(node, name) {
    return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  // node_modules/d3-selection/src/selection/property.js
  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }
  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }
  function propertyFunction(name, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null)
        delete this[name];
      else
        this[name] = v2;
    };
  }
  function property_default(name, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
  }

  // node_modules/d3-selection/src/selection/classed.js
  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }
  function classList(node) {
    return node.classList || new ClassList(node);
  }
  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }
  ClassList.prototype = {
    add: function(name) {
      var i3 = this._names.indexOf(name);
      if (i3 < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i3 = this._names.indexOf(name);
      if (i3 >= 0) {
        this._names.splice(i3, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };
  function classedAdd(node, names) {
    var list2 = classList(node), i3 = -1, n3 = names.length;
    while (++i3 < n3)
      list2.add(names[i3]);
  }
  function classedRemove(node, names) {
    var list2 = classList(node), i3 = -1, n3 = names.length;
    while (++i3 < n3)
      list2.remove(names[i3]);
  }
  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }
  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }
  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }
  function classed_default(name, value) {
    var names = classArray(name + "");
    if (arguments.length < 2) {
      var list2 = classList(this.node()), i3 = -1, n3 = names.length;
      while (++i3 < n3)
        if (!list2.contains(names[i3]))
          return false;
      return true;
    }
    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
  }

  // node_modules/d3-selection/src/selection/text.js
  function textRemove() {
    this.textContent = "";
  }
  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction(value) {
    return function() {
      var v2 = value.apply(this, arguments);
      this.textContent = v2 == null ? "" : v2;
    };
  }
  function text_default(value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
  }

  // node_modules/d3-selection/src/selection/html.js
  function htmlRemove() {
    this.innerHTML = "";
  }
  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }
  function htmlFunction(value) {
    return function() {
      var v2 = value.apply(this, arguments);
      this.innerHTML = v2 == null ? "" : v2;
    };
  }
  function html_default(value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
  }

  // node_modules/d3-selection/src/selection/raise.js
  function raise() {
    if (this.nextSibling)
      this.parentNode.appendChild(this);
  }
  function raise_default() {
    return this.each(raise);
  }

  // node_modules/d3-selection/src/selection/lower.js
  function lower() {
    if (this.previousSibling)
      this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function lower_default() {
    return this.each(lower);
  }

  // node_modules/d3-selection/src/selection/append.js
  function append_default(name) {
    var create2 = typeof name === "function" ? name : creator_default(name);
    return this.select(function() {
      return this.appendChild(create2.apply(this, arguments));
    });
  }

  // node_modules/d3-selection/src/selection/insert.js
  function constantNull() {
    return null;
  }
  function insert_default(name, before) {
    var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
    return this.select(function() {
      return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  // node_modules/d3-selection/src/selection/remove.js
  function remove() {
    var parent = this.parentNode;
    if (parent)
      parent.removeChild(this);
  }
  function remove_default() {
    return this.each(remove);
  }

  // node_modules/d3-selection/src/selection/clone.js
  function selection_cloneShallow() {
    var clone2 = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
  }
  function selection_cloneDeep() {
    var clone2 = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
  }
  function clone_default(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  // node_modules/d3-selection/src/selection/datum.js
  function datum_default(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  }

  // node_modules/d3-selection/src/selection/on.js
  function contextListener(listener) {
    return function(event) {
      listener.call(this, event, this.__data__);
    };
  }
  function parseTypenames2(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t2) {
      var name = "", i3 = t2.indexOf(".");
      if (i3 >= 0)
        name = t2.slice(i3 + 1), t2 = t2.slice(0, i3);
      return { type: t2, name };
    });
  }
  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on)
        return;
      for (var j2 = 0, i3 = -1, m2 = on.length, o2; j2 < m2; ++j2) {
        if (o2 = on[j2], (!typename.type || o2.type === typename.type) && o2.name === typename.name) {
          this.removeEventListener(o2.type, o2.listener, o2.options);
        } else {
          on[++i3] = o2;
        }
      }
      if (++i3)
        on.length = i3;
      else
        delete this.__on;
    };
  }
  function onAdd(typename, value, options2) {
    return function() {
      var on = this.__on, o2, listener = contextListener(value);
      if (on)
        for (var j2 = 0, m2 = on.length; j2 < m2; ++j2) {
          if ((o2 = on[j2]).type === typename.type && o2.name === typename.name) {
            this.removeEventListener(o2.type, o2.listener, o2.options);
            this.addEventListener(o2.type, o2.listener = listener, o2.options = options2);
            o2.value = value;
            return;
          }
        }
      this.addEventListener(typename.type, listener, options2);
      o2 = { type: typename.type, name: typename.name, value, listener, options: options2 };
      if (!on)
        this.__on = [o2];
      else
        on.push(o2);
    };
  }
  function on_default(typename, value, options2) {
    var typenames = parseTypenames2(typename + ""), i3, n3 = typenames.length, t2;
    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on)
        for (var j2 = 0, m2 = on.length, o2; j2 < m2; ++j2) {
          for (i3 = 0, o2 = on[j2]; i3 < n3; ++i3) {
            if ((t2 = typenames[i3]).type === o2.type && t2.name === o2.name) {
              return o2.value;
            }
          }
        }
      return;
    }
    on = value ? onAdd : onRemove;
    for (i3 = 0; i3 < n3; ++i3)
      this.each(on(typenames[i3], value, options2));
    return this;
  }

  // node_modules/d3-selection/src/selection/dispatch.js
  function dispatchEvent(node, type2, params) {
    var window2 = window_default(node), event = window2.CustomEvent;
    if (typeof event === "function") {
      event = new event(type2, params);
    } else {
      event = window2.document.createEvent("Event");
      if (params)
        event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
      else
        event.initEvent(type2, false, false);
    }
    node.dispatchEvent(event);
  }
  function dispatchConstant(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params);
    };
  }
  function dispatchFunction(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params.apply(this, arguments));
    };
  }
  function dispatch_default2(type2, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
  }

  // node_modules/d3-selection/src/selection/iterator.js
  function* iterator_default() {
    for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
      for (var group = groups[j2], i3 = 0, n3 = group.length, node; i3 < n3; ++i3) {
        if (node = group[i3])
          yield node;
      }
    }
  }

  // node_modules/d3-selection/src/selection/index.js
  var root = [null];
  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }
  function selection() {
    return new Selection([[document.documentElement]], root);
  }
  function selection_selection() {
    return this;
  }
  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: select_default,
    selectAll: selectAll_default,
    selectChild: selectChild_default,
    selectChildren: selectChildren_default,
    filter: filter_default,
    data: data_default,
    enter: enter_default,
    exit: exit_default,
    join: join_default,
    merge: merge_default,
    selection: selection_selection,
    order: order_default,
    sort: sort_default,
    call: call_default,
    nodes: nodes_default,
    node: node_default,
    size: size_default,
    empty: empty_default,
    each: each_default,
    attr: attr_default,
    style: style_default,
    property: property_default,
    classed: classed_default,
    text: text_default,
    html: html_default,
    raise: raise_default,
    lower: lower_default,
    append: append_default,
    insert: insert_default,
    remove: remove_default,
    clone: clone_default,
    datum: datum_default,
    on: on_default,
    dispatch: dispatch_default2,
    [Symbol.iterator]: iterator_default
  };
  var selection_default = selection;

  // node_modules/d3-selection/src/select.js
  function select_default2(selector) {
    return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
  }

  // node_modules/d3-selection/src/sourceEvent.js
  function sourceEvent_default(event) {
    let sourceEvent;
    while (sourceEvent = event.sourceEvent)
      event = sourceEvent;
    return event;
  }

  // node_modules/d3-selection/src/pointer.js
  function pointer_default(event, node) {
    event = sourceEvent_default(event);
    if (node === void 0)
      node = event.currentTarget;
    if (node) {
      var svg2 = node.ownerSVGElement || node;
      if (svg2.createSVGPoint) {
        var point2 = svg2.createSVGPoint();
        point2.x = event.clientX, point2.y = event.clientY;
        point2 = point2.matrixTransform(node.getScreenCTM().inverse());
        return [point2.x, point2.y];
      }
      if (node.getBoundingClientRect) {
        var rect = node.getBoundingClientRect();
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
      }
    }
    return [event.pageX, event.pageY];
  }

  // node_modules/d3-selection/src/selectAll.js
  function selectAll_default2(selector) {
    return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([array(selector)], root);
  }

  // node_modules/d3-drag/src/noevent.js
  var nonpassive = { passive: false };
  var nonpassivecapture = { capture: true, passive: false };
  function nopropagation(event) {
    event.stopImmediatePropagation();
  }
  function noevent_default(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }

  // node_modules/d3-drag/src/nodrag.js
  function nodrag_default(view) {
    var root3 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
    if ("onselectstart" in root3) {
      selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
    } else {
      root3.__noselect = root3.style.MozUserSelect;
      root3.style.MozUserSelect = "none";
    }
  }
  function yesdrag(view, noclick) {
    var root3 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
    if (noclick) {
      selection2.on("click.drag", noevent_default, nonpassivecapture);
      setTimeout(function() {
        selection2.on("click.drag", null);
      }, 0);
    }
    if ("onselectstart" in root3) {
      selection2.on("selectstart.drag", null);
    } else {
      root3.style.MozUserSelect = root3.__noselect;
      delete root3.__noselect;
    }
  }

  // node_modules/d3-drag/src/constant.js
  var constant_default2 = (x2) => () => x2;

  // node_modules/d3-drag/src/event.js
  function DragEvent(type2, {
    sourceEvent,
    subject,
    target,
    identifier,
    active,
    x: x2,
    y: y2,
    dx,
    dy,
    dispatch: dispatch14
  }) {
    Object.defineProperties(this, {
      type: { value: type2, enumerable: true, configurable: true },
      sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
      subject: { value: subject, enumerable: true, configurable: true },
      target: { value: target, enumerable: true, configurable: true },
      identifier: { value: identifier, enumerable: true, configurable: true },
      active: { value: active, enumerable: true, configurable: true },
      x: { value: x2, enumerable: true, configurable: true },
      y: { value: y2, enumerable: true, configurable: true },
      dx: { value: dx, enumerable: true, configurable: true },
      dy: { value: dy, enumerable: true, configurable: true },
      _: { value: dispatch14 }
    });
  }
  DragEvent.prototype.on = function() {
    var value = this._.on.apply(this._, arguments);
    return value === this._ ? this : value;
  };

  // node_modules/d3-drag/src/drag.js
  function defaultFilter(event) {
    return !event.ctrlKey && !event.button;
  }
  function defaultContainer() {
    return this.parentNode;
  }
  function defaultSubject(event, d2) {
    return d2 == null ? { x: event.x, y: event.y } : d2;
  }
  function defaultTouchable() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function drag_default() {
    var filter2 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
    function drag(selection2) {
      selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    function mousedowned(event, d2) {
      if (touchending || !filter2.call(this, event, d2))
        return;
      var gesture = beforestart(this, container.call(this, event, d2), event, d2, "mouse");
      if (!gesture)
        return;
      select_default2(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
      nodrag_default(event.view);
      nopropagation(event);
      mousemoving = false;
      mousedownx = event.clientX;
      mousedowny = event.clientY;
      gesture("start", event);
    }
    function mousemoved(event) {
      noevent_default(event);
      if (!mousemoving) {
        var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
        mousemoving = dx * dx + dy * dy > clickDistance2;
      }
      gestures.mouse("drag", event);
    }
    function mouseupped(event) {
      select_default2(event.view).on("mousemove.drag mouseup.drag", null);
      yesdrag(event.view, mousemoving);
      noevent_default(event);
      gestures.mouse("end", event);
    }
    function touchstarted(event, d2) {
      if (!filter2.call(this, event, d2))
        return;
      var touches = event.changedTouches, c2 = container.call(this, event, d2), n3 = touches.length, i3, gesture;
      for (i3 = 0; i3 < n3; ++i3) {
        if (gesture = beforestart(this, c2, event, d2, touches[i3].identifier, touches[i3])) {
          nopropagation(event);
          gesture("start", event, touches[i3]);
        }
      }
    }
    function touchmoved(event) {
      var touches = event.changedTouches, n3 = touches.length, i3, gesture;
      for (i3 = 0; i3 < n3; ++i3) {
        if (gesture = gestures[touches[i3].identifier]) {
          noevent_default(event);
          gesture("drag", event, touches[i3]);
        }
      }
    }
    function touchended(event) {
      var touches = event.changedTouches, n3 = touches.length, i3, gesture;
      if (touchending)
        clearTimeout(touchending);
      touchending = setTimeout(function() {
        touchending = null;
      }, 500);
      for (i3 = 0; i3 < n3; ++i3) {
        if (gesture = gestures[touches[i3].identifier]) {
          nopropagation(event);
          gesture("end", event, touches[i3]);
        }
      }
    }
    function beforestart(that, container2, event, d2, identifier, touch) {
      var dispatch14 = listeners.copy(), p2 = pointer_default(touch || event, container2), dx, dy, s2;
      if ((s2 = subject.call(that, new DragEvent("beforestart", {
        sourceEvent: event,
        target: drag,
        identifier,
        active,
        x: p2[0],
        y: p2[1],
        dx: 0,
        dy: 0,
        dispatch: dispatch14
      }), d2)) == null)
        return;
      dx = s2.x - p2[0] || 0;
      dy = s2.y - p2[1] || 0;
      return function gesture(type2, event2, touch2) {
        var p02 = p2, n3;
        switch (type2) {
          case "start":
            gestures[identifier] = gesture, n3 = active++;
            break;
          case "end":
            delete gestures[identifier], --active;
          case "drag":
            p2 = pointer_default(touch2 || event2, container2), n3 = active;
            break;
        }
        dispatch14.call(
          type2,
          that,
          new DragEvent(type2, {
            sourceEvent: event2,
            subject: s2,
            target: drag,
            identifier,
            active: n3,
            x: p2[0] + dx,
            y: p2[1] + dy,
            dx: p2[0] - p02[0],
            dy: p2[1] - p02[1],
            dispatch: dispatch14
          }),
          d2
        );
      };
    }
    drag.filter = function(_2) {
      return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant_default2(!!_2), drag) : filter2;
    };
    drag.container = function(_2) {
      return arguments.length ? (container = typeof _2 === "function" ? _2 : constant_default2(_2), drag) : container;
    };
    drag.subject = function(_2) {
      return arguments.length ? (subject = typeof _2 === "function" ? _2 : constant_default2(_2), drag) : subject;
    };
    drag.touchable = function(_2) {
      return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant_default2(!!_2), drag) : touchable;
    };
    drag.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? drag : value;
    };
    drag.clickDistance = function(_2) {
      return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, drag) : Math.sqrt(clickDistance2);
    };
    return drag;
  }

  // node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition)
      prototype[key] = definition[key];
    return prototype;
  }

  // node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp("^rgb\\(".concat(reI, ",").concat(reI, ",").concat(reI, "\\)$"));
  var reRgbPercent = new RegExp("^rgb\\(".concat(reP, ",").concat(reP, ",").concat(reP, "\\)$"));
  var reRgbaInteger = new RegExp("^rgba\\(".concat(reI, ",").concat(reI, ",").concat(reI, ",").concat(reN, "\\)$"));
  var reRgbaPercent = new RegExp("^rgba\\(".concat(reP, ",").concat(reP, ",").concat(reP, ",").concat(reN, "\\)$"));
  var reHslPercent = new RegExp("^hsl\\(".concat(reN, ",").concat(reP, ",").concat(reP, "\\)$"));
  var reHslaPercent = new RegExp("^hsla\\(".concat(reN, ",").concat(reP, ",").concat(reP, ",").concat(reN, "\\)$"));
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format2) {
    var m2, l2;
    format2 = (format2 + "").trim().toLowerCase();
    return (m2 = reHex.exec(format2)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n3) {
    return new Rgb(n3 >> 16 & 255, n3 >> 8 & 255, n3 & 255, 1);
  }
  function rgba(r2, g3, b2, a2) {
    if (a2 <= 0)
      r2 = g3 = b2 = NaN;
    return new Rgb(r2, g3, b2, a2);
  }
  function rgbConvert(o2) {
    if (!(o2 instanceof Color))
      o2 = color(o2);
    if (!o2)
      return new Rgb();
    o2 = o2.rgb();
    return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
  }
  function rgb(r2, g3, b2, opacity) {
    return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g3, b2, opacity == null ? 1 : opacity);
  }
  function Rgb(r2, g3, b2, opacity) {
    this.r = +r2;
    this.g = +g3;
    this.b = +b2;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend(Color, {
    brighter(k2) {
      k2 = k2 == null ? brighter : Math.pow(brighter, k2);
      return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
    },
    darker(k2) {
      k2 = k2 == null ? darker : Math.pow(darker, k2);
      return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return "#".concat(hex(this.r)).concat(hex(this.g)).concat(hex(this.b));
  }
  function rgb_formatHex8() {
    return "#".concat(hex(this.r)).concat(hex(this.g)).concat(hex(this.b)).concat(hex((isNaN(this.opacity) ? 1 : this.opacity) * 255));
  }
  function rgb_formatRgb() {
    const a2 = clampa(this.opacity);
    return "".concat(a2 === 1 ? "rgb(" : "rgba(").concat(clampi(this.r), ", ").concat(clampi(this.g), ", ").concat(clampi(this.b)).concat(a2 === 1 ? ")" : ", ".concat(a2, ")"));
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h2, s2, l2, a2) {
    if (a2 <= 0)
      h2 = s2 = l2 = NaN;
    else if (l2 <= 0 || l2 >= 1)
      h2 = s2 = NaN;
    else if (s2 <= 0)
      h2 = NaN;
    return new Hsl(h2, s2, l2, a2);
  }
  function hslConvert(o2) {
    if (o2 instanceof Hsl)
      return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
    if (!(o2 instanceof Color))
      o2 = color(o2);
    if (!o2)
      return new Hsl();
    if (o2 instanceof Hsl)
      return o2;
    o2 = o2.rgb();
    var r2 = o2.r / 255, g3 = o2.g / 255, b2 = o2.b / 255, min3 = Math.min(r2, g3, b2), max3 = Math.max(r2, g3, b2), h2 = NaN, s2 = max3 - min3, l2 = (max3 + min3) / 2;
    if (s2) {
      if (r2 === max3)
        h2 = (g3 - b2) / s2 + (g3 < b2) * 6;
      else if (g3 === max3)
        h2 = (b2 - r2) / s2 + 2;
      else
        h2 = (r2 - g3) / s2 + 4;
      s2 /= l2 < 0.5 ? max3 + min3 : 2 - max3 - min3;
      h2 *= 60;
    } else {
      s2 = l2 > 0 && l2 < 1 ? 0 : h2;
    }
    return new Hsl(h2, s2, l2, o2.opacity);
  }
  function hsl(h2, s2, l2, opacity) {
    return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
  }
  function Hsl(h2, s2, l2, opacity) {
    this.h = +h2;
    this.s = +s2;
    this.l = +l2;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend(Color, {
    brighter(k2) {
      k2 = k2 == null ? brighter : Math.pow(brighter, k2);
      return new Hsl(this.h, this.s, this.l * k2, this.opacity);
    },
    darker(k2) {
      k2 = k2 == null ? darker : Math.pow(darker, k2);
      return new Hsl(this.h, this.s, this.l * k2, this.opacity);
    },
    rgb() {
      var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
      return new Rgb(
        hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
        hsl2rgb(h2, m1, m2),
        hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a2 = clampa(this.opacity);
      return "".concat(a2 === 1 ? "hsl(" : "hsla(").concat(clamph(this.h), ", ").concat(clampt(this.s) * 100, "%, ").concat(clampt(this.l) * 100, "%").concat(a2 === 1 ? ")" : ", ".concat(a2, ")"));
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h2, m1, m2) {
    return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
  }

  // node_modules/d3-interpolate/src/basis.js
  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  function basis_default(values) {
    var n3 = values.length - 1;
    return function(t2) {
      var i3 = t2 <= 0 ? t2 = 0 : t2 >= 1 ? (t2 = 1, n3 - 1) : Math.floor(t2 * n3), v1 = values[i3], v2 = values[i3 + 1], v0 = i3 > 0 ? values[i3 - 1] : 2 * v1 - v2, v3 = i3 < n3 - 1 ? values[i3 + 2] : 2 * v2 - v1;
      return basis((t2 - i3 / n3) * n3, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values) {
    var n3 = values.length;
    return function(t2) {
      var i3 = Math.floor(((t2 %= 1) < 0 ? ++t2 : t2) * n3), v0 = values[(i3 + n3 - 1) % n3], v1 = values[i3 % n3], v2 = values[(i3 + 1) % n3], v3 = values[(i3 + 2) % n3];
      return basis((t2 - i3 / n3) * n3, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/constant.js
  var constant_default3 = (x2) => () => x2;

  // node_modules/d3-interpolate/src/color.js
  function linear(a2, d2) {
    return function(t2) {
      return a2 + t2 * d2;
    };
  }
  function exponential(a2, b2, y2) {
    return a2 = Math.pow(a2, y2), b2 = Math.pow(b2, y2) - a2, y2 = 1 / y2, function(t2) {
      return Math.pow(a2 + t2 * b2, y2);
    };
  }
  function gamma(y2) {
    return (y2 = +y2) === 1 ? nogamma : function(a2, b2) {
      return b2 - a2 ? exponential(a2, b2, y2) : constant_default3(isNaN(a2) ? b2 : a2);
    };
  }
  function nogamma(a2, b2) {
    var d2 = b2 - a2;
    return d2 ? linear(a2, d2) : constant_default3(isNaN(a2) ? b2 : a2);
  }

  // node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y2) {
    var color2 = gamma(y2);
    function rgb2(start2, end) {
      var r2 = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g3 = color2(start2.g, end.g), b2 = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
      return function(t2) {
        start2.r = r2(t2);
        start2.g = g3(t2);
        start2.b = b2(t2);
        start2.opacity = opacity(t2);
        return start2 + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n3 = colors.length, r2 = new Array(n3), g3 = new Array(n3), b2 = new Array(n3), i3, color2;
      for (i3 = 0; i3 < n3; ++i3) {
        color2 = rgb(colors[i3]);
        r2[i3] = color2.r || 0;
        g3[i3] = color2.g || 0;
        b2[i3] = color2.b || 0;
      }
      r2 = spline(r2);
      g3 = spline(g3);
      b2 = spline(b2);
      color2.opacity = 1;
      return function(t2) {
        color2.r = r2(t2);
        color2.g = g3(t2);
        color2.b = b2(t2);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // node_modules/d3-interpolate/src/numberArray.js
  function numberArray_default(a2, b2) {
    if (!b2)
      b2 = [];
    var n3 = a2 ? Math.min(b2.length, a2.length) : 0, c2 = b2.slice(), i3;
    return function(t2) {
      for (i3 = 0; i3 < n3; ++i3)
        c2[i3] = a2[i3] * (1 - t2) + b2[i3] * t2;
      return c2;
    };
  }
  function isNumberArray(x2) {
    return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
  }

  // node_modules/d3-interpolate/src/array.js
  function genericArray(a2, b2) {
    var nb = b2 ? b2.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i3;
    for (i3 = 0; i3 < na; ++i3)
      x2[i3] = value_default(a2[i3], b2[i3]);
    for (; i3 < nb; ++i3)
      c2[i3] = b2[i3];
    return function(t2) {
      for (i3 = 0; i3 < na; ++i3)
        c2[i3] = x2[i3](t2);
      return c2;
    };
  }

  // node_modules/d3-interpolate/src/date.js
  function date_default(a2, b2) {
    var d2 = /* @__PURE__ */ new Date();
    return a2 = +a2, b2 = +b2, function(t2) {
      return d2.setTime(a2 * (1 - t2) + b2 * t2), d2;
    };
  }

  // node_modules/d3-interpolate/src/number.js
  function number_default(a2, b2) {
    return a2 = +a2, b2 = +b2, function(t2) {
      return a2 * (1 - t2) + b2 * t2;
    };
  }

  // node_modules/d3-interpolate/src/object.js
  function object_default(a2, b2) {
    var i3 = {}, c2 = {}, k2;
    if (a2 === null || typeof a2 !== "object")
      a2 = {};
    if (b2 === null || typeof b2 !== "object")
      b2 = {};
    for (k2 in b2) {
      if (k2 in a2) {
        i3[k2] = value_default(a2[k2], b2[k2]);
      } else {
        c2[k2] = b2[k2];
      }
    }
    return function(t2) {
      for (k2 in i3)
        c2[k2] = i3[k2](t2);
      return c2;
    };
  }

  // node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero2(b2) {
    return function() {
      return b2;
    };
  }
  function one(b2) {
    return function(t2) {
      return b2(t2) + "";
    };
  }
  function string_default(a2, b2) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i3 = -1, s2 = [], q2 = [];
    a2 = a2 + "", b2 = b2 + "";
    while ((am = reA.exec(a2)) && (bm = reB.exec(b2))) {
      if ((bs = bm.index) > bi) {
        bs = b2.slice(bi, bs);
        if (s2[i3])
          s2[i3] += bs;
        else
          s2[++i3] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s2[i3])
          s2[i3] += bm;
        else
          s2[++i3] = bm;
      } else {
        s2[++i3] = null;
        q2.push({ i: i3, x: number_default(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b2.length) {
      bs = b2.slice(bi);
      if (s2[i3])
        s2[i3] += bs;
      else
        s2[++i3] = bs;
    }
    return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero2(b2) : (b2 = q2.length, function(t2) {
      for (var i4 = 0, o2; i4 < b2; ++i4)
        s2[(o2 = q2[i4]).i] = o2.x(t2);
      return s2.join("");
    });
  }

  // node_modules/d3-interpolate/src/value.js
  function value_default(a2, b2) {
    var t2 = typeof b2, c2;
    return b2 == null || t2 === "boolean" ? constant_default3(b2) : (t2 === "number" ? number_default : t2 === "string" ? (c2 = color(b2)) ? (b2 = c2, rgb_default) : string_default : b2 instanceof color ? rgb_default : b2 instanceof Date ? date_default : isNumberArray(b2) ? numberArray_default : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object_default : number_default)(a2, b2);
  }

  // node_modules/d3-interpolate/src/round.js
  function round_default(a2, b2) {
    return a2 = +a2, b2 = +b2, function(t2) {
      return Math.round(a2 * (1 - t2) + b2 * t2);
    };
  }

  // node_modules/d3-interpolate/src/transform/decompose.js
  var degrees2 = 180 / Math.PI;
  var identity = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function decompose_default(a2, b2, c2, d2, e3, f2) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a2 * a2 + b2 * b2))
      a2 /= scaleX, b2 /= scaleX;
    if (skewX = a2 * c2 + b2 * d2)
      c2 -= a2 * skewX, d2 -= b2 * skewX;
    if (scaleY = Math.sqrt(c2 * c2 + d2 * d2))
      c2 /= scaleY, d2 /= scaleY, skewX /= scaleY;
    if (a2 * d2 < b2 * c2)
      a2 = -a2, b2 = -b2, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e3,
      translateY: f2,
      rotate: Math.atan2(b2, a2) * degrees2,
      skewX: Math.atan(skewX) * degrees2,
      scaleX,
      scaleY
    };
  }

  // node_modules/d3-interpolate/src/transform/parse.js
  var svgNode;
  function parseCss(value) {
    const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
    return m2.isIdentity ? identity : decompose_default(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
  }
  function parseSvg(value) {
    if (value == null)
      return identity;
    if (!svgNode)
      svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate()))
      return identity;
    value = value.matrix;
    return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
  }

  // node_modules/d3-interpolate/src/transform/index.js
  function interpolateTransform(parse, pxComma, pxParen, degParen) {
    function pop(s2) {
      return s2.length ? s2.pop() + " " : "";
    }
    function translate(xa, ya, xb, yb, s2, q2) {
      if (xa !== xb || ya !== yb) {
        var i3 = s2.push("translate(", null, pxComma, null, pxParen);
        q2.push({ i: i3 - 4, x: number_default(xa, xb) }, { i: i3 - 2, x: number_default(ya, yb) });
      } else if (xb || yb) {
        s2.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }
    function rotate(a2, b2, s2, q2) {
      if (a2 !== b2) {
        if (a2 - b2 > 180)
          b2 += 360;
        else if (b2 - a2 > 180)
          a2 += 360;
        q2.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default(a2, b2) });
      } else if (b2) {
        s2.push(pop(s2) + "rotate(" + b2 + degParen);
      }
    }
    function skewX(a2, b2, s2, q2) {
      if (a2 !== b2) {
        q2.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default(a2, b2) });
      } else if (b2) {
        s2.push(pop(s2) + "skewX(" + b2 + degParen);
      }
    }
    function scale(xa, ya, xb, yb, s2, q2) {
      if (xa !== xb || ya !== yb) {
        var i3 = s2.push(pop(s2) + "scale(", null, ",", null, ")");
        q2.push({ i: i3 - 4, x: number_default(xa, xb) }, { i: i3 - 2, x: number_default(ya, yb) });
      } else if (xb !== 1 || yb !== 1) {
        s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
      }
    }
    return function(a2, b2) {
      var s2 = [], q2 = [];
      a2 = parse(a2), b2 = parse(b2);
      translate(a2.translateX, a2.translateY, b2.translateX, b2.translateY, s2, q2);
      rotate(a2.rotate, b2.rotate, s2, q2);
      skewX(a2.skewX, b2.skewX, s2, q2);
      scale(a2.scaleX, a2.scaleY, b2.scaleX, b2.scaleY, s2, q2);
      a2 = b2 = null;
      return function(t2) {
        var i3 = -1, n3 = q2.length, o2;
        while (++i3 < n3)
          s2[(o2 = q2[i3]).i] = o2.x(t2);
        return s2.join("");
      };
    };
  }
  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

  // node_modules/d3-interpolate/src/zoom.js
  var epsilon22 = 1e-12;
  function cosh(x2) {
    return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
  }
  function sinh(x2) {
    return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
  }
  function tanh(x2) {
    return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
  }
  var zoom_default = function zoomRho(rho, rho2, rho4) {
    function zoom(p02, p1) {
      var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i3, S2;
      if (d2 < epsilon22) {
        S2 = Math.log(w1 / w0) / rho;
        i3 = function(t2) {
          return [
            ux0 + t2 * dx,
            uy0 + t2 * dy,
            w0 * Math.exp(rho * t2 * S2)
          ];
        };
      } else {
        var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
        S2 = (r1 - r0) / rho;
        i3 = function(t2) {
          var s2 = t2 * S2, coshr0 = cosh(r0), u2 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
          return [
            ux0 + u2 * dx,
            uy0 + u2 * dy,
            w0 * coshr0 / cosh(rho * s2 + r0)
          ];
        };
      }
      i3.duration = S2 * 1e3 * rho / Math.SQRT2;
      return i3;
    }
    zoom.rho = function(_2) {
      var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
      return zoomRho(_1, _22, _4);
    };
    return zoom;
  }(Math.SQRT2, 2, 4);

  // node_modules/d3-interpolate/src/quantize.js
  function quantize_default(interpolator, n3) {
    var samples = new Array(n3);
    for (var i3 = 0; i3 < n3; ++i3)
      samples[i3] = interpolator(i3 / (n3 - 1));
    return samples;
  }

  // node_modules/d3-timer/src/timer.js
  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
    setTimeout(f2, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function")
        throw new TypeError("callback is not a function");
      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail)
          taskTail._next = this;
        else
          taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    var t2 = new Timer();
    t2.restart(callback, delay, time);
    return t2;
  }
  function timerFlush() {
    now();
    ++frame;
    var t2 = taskHead, e3;
    while (t2) {
      if ((e3 = clockNow - t2._time) >= 0)
        t2._call.call(void 0, e3);
      t2 = t2._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now3 = clock.now(), delay = now3 - clockLast;
    if (delay > pokeDelay)
      clockSkew -= delay, clockLast = now3;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time)
          time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame)
      return;
    if (timeout)
      timeout = clearTimeout(timeout);
    var delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity)
        timeout = setTimeout(wake, time - clock.now() - clockSkew);
      if (interval)
        interval = clearInterval(interval);
    } else {
      if (!interval)
        clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  // node_modules/d3-timer/src/timeout.js
  function timeout_default(callback, delay, time) {
    var t2 = new Timer();
    delay = delay == null ? 0 : +delay;
    t2.restart((elapsed) => {
      t2.stop();
      callback(elapsed + delay);
    }, delay, time);
    return t2;
  }

  // node_modules/d3-transition/src/transition/schedule.js
  var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
  var emptyTween = [];
  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;
  function schedule_default(node, name, id2, index, group, timing) {
    var schedules = node.__transition;
    if (!schedules)
      node.__transition = {};
    else if (id2 in schedules)
      return;
    create(node, id2, {
      name,
      index,
      // For context during callback.
      group,
      // For context during callback.
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }
  function init(node, id2) {
    var schedule = get2(node, id2);
    if (schedule.state > CREATED)
      throw new Error("too late; already scheduled");
    return schedule;
  }
  function set2(node, id2) {
    var schedule = get2(node, id2);
    if (schedule.state > STARTED)
      throw new Error("too late; already running");
    return schedule;
  }
  function get2(node, id2) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id2]))
      throw new Error("transition not found");
    return schedule;
  }
  function create(node, id2, self2) {
    var schedules = node.__transition, tween;
    schedules[id2] = self2;
    self2.timer = timer(schedule, 0, self2.time);
    function schedule(elapsed) {
      self2.state = SCHEDULED;
      self2.timer.restart(start2, self2.delay, self2.time);
      if (self2.delay <= elapsed)
        start2(elapsed - self2.delay);
    }
    function start2(elapsed) {
      var i3, j2, n3, o2;
      if (self2.state !== SCHEDULED)
        return stop();
      for (i3 in schedules) {
        o2 = schedules[i3];
        if (o2.name !== self2.name)
          continue;
        if (o2.state === STARTED)
          return timeout_default(start2);
        if (o2.state === RUNNING) {
          o2.state = ENDED;
          o2.timer.stop();
          o2.on.call("interrupt", node, node.__data__, o2.index, o2.group);
          delete schedules[i3];
        } else if (+i3 < id2) {
          o2.state = ENDED;
          o2.timer.stop();
          o2.on.call("cancel", node, node.__data__, o2.index, o2.group);
          delete schedules[i3];
        }
      }
      timeout_default(function() {
        if (self2.state === STARTED) {
          self2.state = RUNNING;
          self2.timer.restart(tick, self2.delay, self2.time);
          tick(elapsed);
        }
      });
      self2.state = STARTING;
      self2.on.call("start", node, node.__data__, self2.index, self2.group);
      if (self2.state !== STARTING)
        return;
      self2.state = STARTED;
      tween = new Array(n3 = self2.tween.length);
      for (i3 = 0, j2 = -1; i3 < n3; ++i3) {
        if (o2 = self2.tween[i3].value.call(node, node.__data__, self2.index, self2.group)) {
          tween[++j2] = o2;
        }
      }
      tween.length = j2 + 1;
    }
    function tick(elapsed) {
      var t2 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i3 = -1, n3 = tween.length;
      while (++i3 < n3) {
        tween[i3].call(node, t2);
      }
      if (self2.state === ENDING) {
        self2.on.call("end", node, node.__data__, self2.index, self2.group);
        stop();
      }
    }
    function stop() {
      self2.state = ENDED;
      self2.timer.stop();
      delete schedules[id2];
      for (var i3 in schedules)
        return;
      delete node.__transition;
    }
  }

  // node_modules/d3-transition/src/interrupt.js
  function interrupt_default(node, name) {
    var schedules = node.__transition, schedule, active, empty2 = true, i3;
    if (!schedules)
      return;
    name = name == null ? null : name + "";
    for (i3 in schedules) {
      if ((schedule = schedules[i3]).name !== name) {
        empty2 = false;
        continue;
      }
      active = schedule.state > STARTING && schedule.state < ENDING;
      schedule.state = ENDED;
      schedule.timer.stop();
      schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
      delete schedules[i3];
    }
    if (empty2)
      delete node.__transition;
  }

  // node_modules/d3-transition/src/selection/interrupt.js
  function interrupt_default2(name) {
    return this.each(function() {
      interrupt_default(this, name);
    });
  }

  // node_modules/d3-transition/src/transition/tween.js
  function tweenRemove(id2, name) {
    var tween0, tween1;
    return function() {
      var schedule = set2(this, id2), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i3 = 0, n3 = tween1.length; i3 < n3; ++i3) {
          if (tween1[i3].name === name) {
            tween1 = tween1.slice();
            tween1.splice(i3, 1);
            break;
          }
        }
      }
      schedule.tween = tween1;
    };
  }
  function tweenFunction(id2, name, value) {
    var tween0, tween1;
    if (typeof value !== "function")
      throw new Error();
    return function() {
      var schedule = set2(this, id2), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t2 = { name, value }, i3 = 0, n3 = tween1.length; i3 < n3; ++i3) {
          if (tween1[i3].name === name) {
            tween1[i3] = t2;
            break;
          }
        }
        if (i3 === n3)
          tween1.push(t2);
      }
      schedule.tween = tween1;
    };
  }
  function tween_default(name, value) {
    var id2 = this._id;
    name += "";
    if (arguments.length < 2) {
      var tween = get2(this.node(), id2).tween;
      for (var i3 = 0, n3 = tween.length, t2; i3 < n3; ++i3) {
        if ((t2 = tween[i3]).name === name) {
          return t2.value;
        }
      }
      return null;
    }
    return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
  }
  function tweenValue(transition2, name, value) {
    var id2 = transition2._id;
    transition2.each(function() {
      var schedule = set2(this, id2);
      (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
    });
    return function(node) {
      return get2(node, id2).value[name];
    };
  }

  // node_modules/d3-transition/src/transition/interpolate.js
  function interpolate_default(a2, b2) {
    var c2;
    return (typeof b2 === "number" ? number_default : b2 instanceof color ? rgb_default : (c2 = color(b2)) ? (b2 = c2, rgb_default) : string_default)(a2, b2);
  }

  // node_modules/d3-transition/src/transition/attr.js
  function attrRemove2(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS2(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant2(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttribute(name);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrConstantNS2(fullname, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrFunction2(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null)
        return void this.removeAttribute(name);
      string0 = this.getAttribute(name);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attrFunctionNS2(fullname, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null)
        return void this.removeAttributeNS(fullname.space, fullname.local);
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attr_default2(name, value) {
    var fullname = namespace_default(name), i3 = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
    return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i3, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i3, value));
  }

  // node_modules/d3-transition/src/transition/attrTween.js
  function attrInterpolate(name, i3) {
    return function(t2) {
      this.setAttribute(name, i3.call(this, t2));
    };
  }
  function attrInterpolateNS(fullname, i3) {
    return function(t2) {
      this.setAttributeNS(fullname.space, fullname.local, i3.call(this, t2));
    };
  }
  function attrTweenNS(fullname, value) {
    var t0, i0;
    function tween() {
      var i3 = value.apply(this, arguments);
      if (i3 !== i0)
        t0 = (i0 = i3) && attrInterpolateNS(fullname, i3);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween(name, value) {
    var t0, i0;
    function tween() {
      var i3 = value.apply(this, arguments);
      if (i3 !== i0)
        t0 = (i0 = i3) && attrInterpolate(name, i3);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween_default(name, value) {
    var key = "attr." + name;
    if (arguments.length < 2)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    var fullname = namespace_default(name);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }

  // node_modules/d3-transition/src/transition/delay.js
  function delayFunction(id2, value) {
    return function() {
      init(this, id2).delay = +value.apply(this, arguments);
    };
  }
  function delayConstant(id2, value) {
    return value = +value, function() {
      init(this, id2).delay = value;
    };
  }
  function delay_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
  }

  // node_modules/d3-transition/src/transition/duration.js
  function durationFunction(id2, value) {
    return function() {
      set2(this, id2).duration = +value.apply(this, arguments);
    };
  }
  function durationConstant(id2, value) {
    return value = +value, function() {
      set2(this, id2).duration = value;
    };
  }
  function duration_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
  }

  // node_modules/d3-transition/src/transition/ease.js
  function easeConstant(id2, value) {
    if (typeof value !== "function")
      throw new Error();
    return function() {
      set2(this, id2).ease = value;
    };
  }
  function ease_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
  }

  // node_modules/d3-transition/src/transition/easeVarying.js
  function easeVarying(id2, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (typeof v2 !== "function")
        throw new Error();
      set2(this, id2).ease = v2;
    };
  }
  function easeVarying_default(value) {
    if (typeof value !== "function")
      throw new Error();
    return this.each(easeVarying(this._id, value));
  }

  // node_modules/d3-transition/src/transition/filter.js
  function filter_default2(match) {
    if (typeof match !== "function")
      match = matcher_default(match);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n3 = group.length, subgroup = subgroups[j2] = [], node, i3 = 0; i3 < n3; ++i3) {
        if ((node = group[i3]) && match.call(node, node.__data__, i3, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Transition(subgroups, this._parents, this._name, this._id);
  }

  // node_modules/d3-transition/src/transition/merge.js
  function merge_default2(transition2) {
    if (transition2._id !== this._id)
      throw new Error();
    for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2) {
      for (var group0 = groups0[j2], group1 = groups1[j2], n3 = group0.length, merge2 = merges[j2] = new Array(n3), node, i3 = 0; i3 < n3; ++i3) {
        if (node = group0[i3] || group1[i3]) {
          merge2[i3] = node;
        }
      }
    }
    for (; j2 < m0; ++j2) {
      merges[j2] = groups0[j2];
    }
    return new Transition(merges, this._parents, this._name, this._id);
  }

  // node_modules/d3-transition/src/transition/on.js
  function start(name) {
    return (name + "").trim().split(/^|\s+/).every(function(t2) {
      var i3 = t2.indexOf(".");
      if (i3 >= 0)
        t2 = t2.slice(0, i3);
      return !t2 || t2 === "start";
    });
  }
  function onFunction(id2, name, listener) {
    var on0, on1, sit = start(name) ? init : set2;
    return function() {
      var schedule = sit(this, id2), on = schedule.on;
      if (on !== on0)
        (on1 = (on0 = on).copy()).on(name, listener);
      schedule.on = on1;
    };
  }
  function on_default2(name, listener) {
    var id2 = this._id;
    return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
  }

  // node_modules/d3-transition/src/transition/remove.js
  function removeFunction(id2) {
    return function() {
      var parent = this.parentNode;
      for (var i3 in this.__transition)
        if (+i3 !== id2)
          return;
      if (parent)
        parent.removeChild(this);
    };
  }
  function remove_default2() {
    return this.on("end.remove", removeFunction(this._id));
  }

  // node_modules/d3-transition/src/transition/select.js
  function select_default3(select) {
    var name = this._name, id2 = this._id;
    if (typeof select !== "function")
      select = selector_default(select);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n3 = group.length, subgroup = subgroups[j2] = new Array(n3), node, subnode, i3 = 0; i3 < n3; ++i3) {
        if ((node = group[i3]) && (subnode = select.call(node, node.__data__, i3, group))) {
          if ("__data__" in node)
            subnode.__data__ = node.__data__;
          subgroup[i3] = subnode;
          schedule_default(subgroup[i3], name, id2, i3, subgroup, get2(node, id2));
        }
      }
    }
    return new Transition(subgroups, this._parents, name, id2);
  }

  // node_modules/d3-transition/src/transition/selectAll.js
  function selectAll_default3(select) {
    var name = this._name, id2 = this._id;
    if (typeof select !== "function")
      select = selectorAll_default(select);
    for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n3 = group.length, node, i3 = 0; i3 < n3; ++i3) {
        if (node = group[i3]) {
          for (var children2 = select.call(node, node.__data__, i3, group), child, inherit2 = get2(node, id2), k2 = 0, l2 = children2.length; k2 < l2; ++k2) {
            if (child = children2[k2]) {
              schedule_default(child, name, id2, k2, children2, inherit2);
            }
          }
          subgroups.push(children2);
          parents.push(node);
        }
      }
    }
    return new Transition(subgroups, parents, name, id2);
  }

  // node_modules/d3-transition/src/transition/selection.js
  var Selection2 = selection_default.prototype.constructor;
  function selection_default2() {
    return new Selection2(this._groups, this._parents);
  }

  // node_modules/d3-transition/src/transition/style.js
  function styleNull(name, interpolate) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
    };
  }
  function styleRemove2(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant2(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = styleValue(this, name);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function styleFunction2(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
      if (value1 == null)
        string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function styleMaybeRemove(id2, name) {
    var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
    return function() {
      var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
      if (on !== on0 || listener0 !== listener)
        (on1 = (on0 = on).copy()).on(event, listener0 = listener);
      schedule.on = on1;
    };
  }
  function style_default2(name, value, priority) {
    var i3 = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
    return value == null ? this.styleTween(name, styleNull(name, i3)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i3, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i3, value), priority).on("end.style." + name, null);
  }

  // node_modules/d3-transition/src/transition/styleTween.js
  function styleInterpolate(name, i3, priority) {
    return function(t2) {
      this.style.setProperty(name, i3.call(this, t2), priority);
    };
  }
  function styleTween(name, value, priority) {
    var t2, i0;
    function tween() {
      var i3 = value.apply(this, arguments);
      if (i3 !== i0)
        t2 = (i0 = i3) && styleInterpolate(name, i3, priority);
      return t2;
    }
    tween._value = value;
    return tween;
  }
  function styleTween_default(name, value, priority) {
    var key = "style." + (name += "");
    if (arguments.length < 2)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
  }

  // node_modules/d3-transition/src/transition/text.js
  function textConstant2(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction2(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }
  function text_default2(value) {
    return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
  }

  // node_modules/d3-transition/src/transition/textTween.js
  function textInterpolate(i3) {
    return function(t2) {
      this.textContent = i3.call(this, t2);
    };
  }
  function textTween(value) {
    var t0, i0;
    function tween() {
      var i3 = value.apply(this, arguments);
      if (i3 !== i0)
        t0 = (i0 = i3) && textInterpolate(i3);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function textTween_default(value) {
    var key = "text";
    if (arguments.length < 1)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    return this.tween(key, textTween(value));
  }

  // node_modules/d3-transition/src/transition/transition.js
  function transition_default() {
    var name = this._name, id0 = this._id, id1 = newId();
    for (var groups = this._groups, m2 = groups.length, j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n3 = group.length, node, i3 = 0; i3 < n3; ++i3) {
        if (node = group[i3]) {
          var inherit2 = get2(node, id0);
          schedule_default(node, name, id1, i3, group, {
            time: inherit2.time + inherit2.delay + inherit2.duration,
            delay: 0,
            duration: inherit2.duration,
            ease: inherit2.ease
          });
        }
      }
    }
    return new Transition(groups, this._parents, name, id1);
  }

  // node_modules/d3-transition/src/transition/end.js
  function end_default() {
    var on0, on1, that = this, id2 = that._id, size = that.size();
    return new Promise(function(resolve, reject) {
      var cancel = { value: reject }, end = { value: function() {
        if (--size === 0)
          resolve();
      } };
      that.each(function() {
        var schedule = set2(this, id2), on = schedule.on;
        if (on !== on0) {
          on1 = (on0 = on).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end);
        }
        schedule.on = on1;
      });
      if (size === 0)
        resolve();
    });
  }

  // node_modules/d3-transition/src/transition/index.js
  var id = 0;
  function Transition(groups, parents, name, id2) {
    this._groups = groups;
    this._parents = parents;
    this._name = name;
    this._id = id2;
  }
  function transition(name) {
    return selection_default().transition(name);
  }
  function newId() {
    return ++id;
  }
  var selection_prototype = selection_default.prototype;
  Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: select_default3,
    selectAll: selectAll_default3,
    selectChild: selection_prototype.selectChild,
    selectChildren: selection_prototype.selectChildren,
    filter: filter_default2,
    merge: merge_default2,
    selection: selection_default2,
    transition: transition_default,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: on_default2,
    attr: attr_default2,
    attrTween: attrTween_default,
    style: style_default2,
    styleTween: styleTween_default,
    text: text_default2,
    textTween: textTween_default,
    remove: remove_default2,
    tween: tween_default,
    delay: delay_default,
    duration: duration_default,
    ease: ease_default,
    easeVarying: easeVarying_default,
    end: end_default,
    [Symbol.iterator]: selection_prototype[Symbol.iterator]
  };

  // node_modules/d3-ease/src/linear.js
  var linear2 = (t2) => +t2;

  // node_modules/d3-ease/src/cubic.js
  function cubicInOut(t2) {
    return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
  }

  // node_modules/d3-transition/src/selection/transition.js
  var defaultTiming = {
    time: null,
    // Set on use.
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };
  function inherit(node, id2) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id2])) {
      if (!(node = node.parentNode)) {
        throw new Error("transition ".concat(id2, " not found"));
      }
    }
    return timing;
  }
  function transition_default2(name) {
    var id2, timing;
    if (name instanceof Transition) {
      id2 = name._id, name = name._name;
    } else {
      id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
    }
    for (var groups = this._groups, m2 = groups.length, j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n3 = group.length, node, i3 = 0; i3 < n3; ++i3) {
        if (node = group[i3]) {
          schedule_default(node, name, id2, i3, group, timing || inherit(node, id2));
        }
      }
    }
    return new Transition(groups, this._parents, name, id2);
  }

  // node_modules/d3-transition/src/selection/index.js
  selection_default.prototype.interrupt = interrupt_default2;
  selection_default.prototype.transition = transition_default2;

  // node_modules/d3-zoom/src/constant.js
  var constant_default4 = (x2) => () => x2;

  // node_modules/d3-zoom/src/event.js
  function ZoomEvent(type2, {
    sourceEvent,
    target,
    transform: transform2,
    dispatch: dispatch14
  }) {
    Object.defineProperties(this, {
      type: { value: type2, enumerable: true, configurable: true },
      sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
      target: { value: target, enumerable: true, configurable: true },
      transform: { value: transform2, enumerable: true, configurable: true },
      _: { value: dispatch14 }
    });
  }

  // node_modules/d3-zoom/src/transform.js
  function Transform(k2, x2, y2) {
    this.k = k2;
    this.x = x2;
    this.y = y2;
  }
  Transform.prototype = {
    constructor: Transform,
    scale: function(k2) {
      return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
    },
    translate: function(x2, y2) {
      return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
    },
    apply: function(point2) {
      return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
    },
    applyX: function(x2) {
      return x2 * this.k + this.x;
    },
    applyY: function(y2) {
      return y2 * this.k + this.y;
    },
    invert: function(location) {
      return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
    },
    invertX: function(x2) {
      return (x2 - this.x) / this.k;
    },
    invertY: function(y2) {
      return (y2 - this.y) / this.k;
    },
    rescaleX: function(x2) {
      return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
    },
    rescaleY: function(y2) {
      return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  var identity2 = new Transform(1, 0, 0);
  transform.prototype = Transform.prototype;
  function transform(node) {
    while (!node.__zoom)
      if (!(node = node.parentNode))
        return identity2;
    return node.__zoom;
  }

  // node_modules/d3-zoom/src/noevent.js
  function nopropagation2(event) {
    event.stopImmediatePropagation();
  }
  function noevent_default2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }

  // node_modules/d3-zoom/src/zoom.js
  function defaultFilter2(event) {
    return (!event.ctrlKey || event.type === "wheel") && !event.button;
  }
  function defaultExtent() {
    var e3 = this;
    if (e3 instanceof SVGElement) {
      e3 = e3.ownerSVGElement || e3;
      if (e3.hasAttribute("viewBox")) {
        e3 = e3.viewBox.baseVal;
        return [[e3.x, e3.y], [e3.x + e3.width, e3.y + e3.height]];
      }
      return [[0, 0], [e3.width.baseVal.value, e3.height.baseVal.value]];
    }
    return [[0, 0], [e3.clientWidth, e3.clientHeight]];
  }
  function defaultTransform() {
    return this.__zoom || identity2;
  }
  function defaultWheelDelta(event) {
    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
  }
  function defaultTouchable2() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function defaultConstrain(transform2, extent, translateExtent) {
    var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
    return transform2.translate(
      dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
      dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
    );
  }
  function zoom_default2() {
    var filter2 = defaultFilter2, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable2, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
    function zoom(selection2) {
      selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    zoom.transform = function(collection, transform2, point2, event) {
      var selection2 = collection.selection ? collection.selection() : collection;
      selection2.property("__zoom", defaultTransform);
      if (collection !== selection2) {
        schedule(collection, transform2, point2, event);
      } else {
        selection2.interrupt().each(function() {
          gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
        });
      }
    };
    zoom.scaleBy = function(selection2, k2, p2, event) {
      zoom.scaleTo(selection2, function() {
        var k0 = this.__zoom.k, k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
        return k0 * k1;
      }, p2, event);
    };
    zoom.scaleTo = function(selection2, k2, p2, event) {
      zoom.transform(selection2, function() {
        var e3 = extent.apply(this, arguments), t0 = this.__zoom, p02 = p2 == null ? centroid(e3) : typeof p2 === "function" ? p2.apply(this, arguments) : p2, p1 = t0.invert(p02), k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
        return constrain(translate(scale(t0, k1), p02, p1), e3, translateExtent);
      }, p2, event);
    };
    zoom.translateBy = function(selection2, x2, y2, event) {
      zoom.transform(selection2, function() {
        return constrain(this.__zoom.translate(
          typeof x2 === "function" ? x2.apply(this, arguments) : x2,
          typeof y2 === "function" ? y2.apply(this, arguments) : y2
        ), extent.apply(this, arguments), translateExtent);
      }, null, event);
    };
    zoom.translateTo = function(selection2, x2, y2, p2, event) {
      zoom.transform(selection2, function() {
        var e3 = extent.apply(this, arguments), t2 = this.__zoom, p02 = p2 == null ? centroid(e3) : typeof p2 === "function" ? p2.apply(this, arguments) : p2;
        return constrain(identity2.translate(p02[0], p02[1]).scale(t2.k).translate(
          typeof x2 === "function" ? -x2.apply(this, arguments) : -x2,
          typeof y2 === "function" ? -y2.apply(this, arguments) : -y2
        ), e3, translateExtent);
      }, p2, event);
    };
    function scale(transform2, k2) {
      k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));
      return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);
    }
    function translate(transform2, p02, p1) {
      var x2 = p02[0] - p1[0] * transform2.k, y2 = p02[1] - p1[1] * transform2.k;
      return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
    }
    function centroid(extent2) {
      return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
    }
    function schedule(transition2, transform2, point2, event) {
      transition2.on("start.zoom", function() {
        gesture(this, arguments).event(event).start();
      }).on("interrupt.zoom end.zoom", function() {
        gesture(this, arguments).event(event).end();
      }).tween("zoom", function() {
        var that = this, args = arguments, g3 = gesture(that, args).event(event), e3 = extent.apply(that, args), p2 = point2 == null ? centroid(e3) : typeof point2 === "function" ? point2.apply(that, args) : point2, w2 = Math.max(e3[1][0] - e3[0][0], e3[1][1] - e3[0][1]), a2 = that.__zoom, b2 = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i3 = interpolate(a2.invert(p2).concat(w2 / a2.k), b2.invert(p2).concat(w2 / b2.k));
        return function(t2) {
          if (t2 === 1)
            t2 = b2;
          else {
            var l2 = i3(t2), k2 = w2 / l2[2];
            t2 = new Transform(k2, p2[0] - l2[0] * k2, p2[1] - l2[1] * k2);
          }
          g3.zoom(null, t2);
        };
      });
    }
    function gesture(that, args, clean2) {
      return !clean2 && that.__zooming || new Gesture(that, args);
    }
    function Gesture(that, args) {
      this.that = that;
      this.args = args;
      this.active = 0;
      this.sourceEvent = null;
      this.extent = extent.apply(that, args);
      this.taps = 0;
    }
    Gesture.prototype = {
      event: function(event) {
        if (event)
          this.sourceEvent = event;
        return this;
      },
      start: function() {
        if (++this.active === 1) {
          this.that.__zooming = this;
          this.emit("start");
        }
        return this;
      },
      zoom: function(key, transform2) {
        if (this.mouse && key !== "mouse")
          this.mouse[1] = transform2.invert(this.mouse[0]);
        if (this.touch0 && key !== "touch")
          this.touch0[1] = transform2.invert(this.touch0[0]);
        if (this.touch1 && key !== "touch")
          this.touch1[1] = transform2.invert(this.touch1[0]);
        this.that.__zoom = transform2;
        this.emit("zoom");
        return this;
      },
      end: function() {
        if (--this.active === 0) {
          delete this.that.__zooming;
          this.emit("end");
        }
        return this;
      },
      emit: function(type2) {
        var d2 = select_default2(this.that).datum();
        listeners.call(
          type2,
          this.that,
          new ZoomEvent(type2, {
            sourceEvent: this.sourceEvent,
            target: zoom,
            type: type2,
            transform: this.that.__zoom,
            dispatch: listeners
          }),
          d2
        );
      }
    };
    function wheeled(event, ...args) {
      if (!filter2.apply(this, arguments))
        return;
      var g3 = gesture(this, args).event(event), t2 = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t2.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p2 = pointer_default(event);
      if (g3.wheel) {
        if (g3.mouse[0][0] !== p2[0] || g3.mouse[0][1] !== p2[1]) {
          g3.mouse[1] = t2.invert(g3.mouse[0] = p2);
        }
        clearTimeout(g3.wheel);
      } else if (t2.k === k2)
        return;
      else {
        g3.mouse = [p2, t2.invert(p2)];
        interrupt_default(this);
        g3.start();
      }
      noevent_default2(event);
      g3.wheel = setTimeout(wheelidled, wheelDelay);
      g3.zoom("mouse", constrain(translate(scale(t2, k2), g3.mouse[0], g3.mouse[1]), g3.extent, translateExtent));
      function wheelidled() {
        g3.wheel = null;
        g3.end();
      }
    }
    function mousedowned(event, ...args) {
      if (touchending || !filter2.apply(this, arguments))
        return;
      var currentTarget = event.currentTarget, g3 = gesture(this, args, true).event(event), v2 = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p2 = pointer_default(event, currentTarget), x05 = event.clientX, y05 = event.clientY;
      nodrag_default(event.view);
      nopropagation2(event);
      g3.mouse = [p2, this.__zoom.invert(p2)];
      interrupt_default(this);
      g3.start();
      function mousemoved(event2) {
        noevent_default2(event2);
        if (!g3.moved) {
          var dx = event2.clientX - x05, dy = event2.clientY - y05;
          g3.moved = dx * dx + dy * dy > clickDistance2;
        }
        g3.event(event2).zoom("mouse", constrain(translate(g3.that.__zoom, g3.mouse[0] = pointer_default(event2, currentTarget), g3.mouse[1]), g3.extent, translateExtent));
      }
      function mouseupped(event2) {
        v2.on("mousemove.zoom mouseup.zoom", null);
        yesdrag(event2.view, g3.moved);
        noevent_default2(event2);
        g3.event(event2).end();
      }
    }
    function dblclicked(event, ...args) {
      if (!filter2.apply(this, arguments))
        return;
      var t0 = this.__zoom, p02 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p02), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p02, p1), extent.apply(this, args), translateExtent);
      noevent_default2(event);
      if (duration > 0)
        select_default2(this).transition().duration(duration).call(schedule, t1, p02, event);
      else
        select_default2(this).call(zoom.transform, t1, p02, event);
    }
    function touchstarted(event, ...args) {
      if (!filter2.apply(this, arguments))
        return;
      var touches = event.touches, n3 = touches.length, g3 = gesture(this, args, event.changedTouches.length === n3).event(event), started, i3, t2, p2;
      nopropagation2(event);
      for (i3 = 0; i3 < n3; ++i3) {
        t2 = touches[i3], p2 = pointer_default(t2, this);
        p2 = [p2, this.__zoom.invert(p2), t2.identifier];
        if (!g3.touch0)
          g3.touch0 = p2, started = true, g3.taps = 1 + !!touchstarting;
        else if (!g3.touch1 && g3.touch0[2] !== p2[2])
          g3.touch1 = p2, g3.taps = 0;
      }
      if (touchstarting)
        touchstarting = clearTimeout(touchstarting);
      if (started) {
        if (g3.taps < 2)
          touchfirst = p2[0], touchstarting = setTimeout(function() {
            touchstarting = null;
          }, touchDelay);
        interrupt_default(this);
        g3.start();
      }
    }
    function touchmoved(event, ...args) {
      if (!this.__zooming)
        return;
      var g3 = gesture(this, args).event(event), touches = event.changedTouches, n3 = touches.length, i3, t2, p2, l2;
      noevent_default2(event);
      for (i3 = 0; i3 < n3; ++i3) {
        t2 = touches[i3], p2 = pointer_default(t2, this);
        if (g3.touch0 && g3.touch0[2] === t2.identifier)
          g3.touch0[0] = p2;
        else if (g3.touch1 && g3.touch1[2] === t2.identifier)
          g3.touch1[0] = p2;
      }
      t2 = g3.that.__zoom;
      if (g3.touch1) {
        var p02 = g3.touch0[0], l0 = g3.touch0[1], p1 = g3.touch1[0], l1 = g3.touch1[1], dp = (dp = p1[0] - p02[0]) * dp + (dp = p1[1] - p02[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
        t2 = scale(t2, Math.sqrt(dp / dl));
        p2 = [(p02[0] + p1[0]) / 2, (p02[1] + p1[1]) / 2];
        l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      } else if (g3.touch0)
        p2 = g3.touch0[0], l2 = g3.touch0[1];
      else
        return;
      g3.zoom("touch", constrain(translate(t2, p2, l2), g3.extent, translateExtent));
    }
    function touchended(event, ...args) {
      if (!this.__zooming)
        return;
      var g3 = gesture(this, args).event(event), touches = event.changedTouches, n3 = touches.length, i3, t2;
      nopropagation2(event);
      if (touchending)
        clearTimeout(touchending);
      touchending = setTimeout(function() {
        touchending = null;
      }, touchDelay);
      for (i3 = 0; i3 < n3; ++i3) {
        t2 = touches[i3];
        if (g3.touch0 && g3.touch0[2] === t2.identifier)
          delete g3.touch0;
        else if (g3.touch1 && g3.touch1[2] === t2.identifier)
          delete g3.touch1;
      }
      if (g3.touch1 && !g3.touch0)
        g3.touch0 = g3.touch1, delete g3.touch1;
      if (g3.touch0)
        g3.touch0[1] = this.__zoom.invert(g3.touch0[0]);
      else {
        g3.end();
        if (g3.taps === 2) {
          t2 = pointer_default(t2, this);
          if (Math.hypot(touchfirst[0] - t2[0], touchfirst[1] - t2[1]) < tapDistance) {
            var p2 = select_default2(this).on("dblclick.zoom");
            if (p2)
              p2.apply(this, arguments);
          }
        }
      }
    }
    zoom.wheelDelta = function(_2) {
      return arguments.length ? (wheelDelta = typeof _2 === "function" ? _2 : constant_default4(+_2), zoom) : wheelDelta;
    };
    zoom.filter = function(_2) {
      return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant_default4(!!_2), zoom) : filter2;
    };
    zoom.touchable = function(_2) {
      return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant_default4(!!_2), zoom) : touchable;
    };
    zoom.extent = function(_2) {
      return arguments.length ? (extent = typeof _2 === "function" ? _2 : constant_default4([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom) : extent;
    };
    zoom.scaleExtent = function(_2) {
      return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom) : [scaleExtent[0], scaleExtent[1]];
    };
    zoom.translateExtent = function(_2) {
      return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
    };
    zoom.constrain = function(_2) {
      return arguments.length ? (constrain = _2, zoom) : constrain;
    };
    zoom.duration = function(_2) {
      return arguments.length ? (duration = +_2, zoom) : duration;
    };
    zoom.interpolate = function(_2) {
      return arguments.length ? (interpolate = _2, zoom) : interpolate;
    };
    zoom.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? zoom : value;
    };
    zoom.clickDistance = function(_2) {
      return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, zoom) : Math.sqrt(clickDistance2);
    };
    zoom.tapDistance = function(_2) {
      return arguments.length ? (tapDistance = +_2, zoom) : tapDistance;
    };
    return zoom;
  }

  // modules/geo/raw_mercator.js
  function geoRawMercator() {
    var project = mercatorRaw;
    var k2 = 512 / Math.PI;
    var x2 = 0;
    var y2 = 0;
    var clipExtent = [[0, 0], [0, 0]];
    function projection2(point2) {
      point2 = project(point2[0] * Math.PI / 180, point2[1] * Math.PI / 180);
      return [point2[0] * k2 + x2, y2 - point2[1] * k2];
    }
    projection2.invert = function(point2) {
      point2 = project.invert((point2[0] - x2) / k2, (y2 - point2[1]) / k2);
      return point2 && [point2[0] * 180 / Math.PI, point2[1] * 180 / Math.PI];
    };
    projection2.scale = function(_2) {
      if (!arguments.length)
        return k2;
      k2 = +_2;
      return projection2;
    };
    projection2.translate = function(_2) {
      if (!arguments.length)
        return [x2, y2];
      x2 = +_2[0];
      y2 = +_2[1];
      return projection2;
    };
    projection2.clipExtent = function(_2) {
      if (!arguments.length)
        return clipExtent;
      clipExtent = _2;
      return projection2;
    };
    projection2.transform = function(obj) {
      if (!arguments.length)
        return identity2.translate(x2, y2).scale(k2);
      x2 = +obj.x;
      y2 = +obj.y;
      k2 = +obj.k;
      return projection2;
    };
    projection2.stream = transform_default({
      point: function(x3, y3) {
        var vec = projection2([x3, y3]);
        this.stream.point(vec[0], vec[1]);
      }
    }).stream;
    return projection2;
  }

  // modules/geo/ortho.js
  function geoOrthoNormalizedDotProduct(a2, b2, origin) {
    if (geoVecEqual(origin, a2) || geoVecEqual(origin, b2)) {
      return 1;
    }
    return geoVecNormalizedDot(a2, b2, origin);
  }
  function geoOrthoFilterDotProduct(dotp, epsilon3, lowerThreshold, upperThreshold, allowStraightAngles) {
    var val = Math.abs(dotp);
    if (val < epsilon3) {
      return 0;
    } else if (allowStraightAngles && Math.abs(val - 1) < epsilon3) {
      return 0;
    } else if (val < lowerThreshold || val > upperThreshold) {
      return dotp;
    } else {
      return null;
    }
  }
  function geoOrthoCalcScore(points, isClosed, epsilon3, threshold) {
    var score = 0;
    var first = isClosed ? 0 : 1;
    var last = isClosed ? points.length : points.length - 1;
    var coords = points.map(function(p2) {
      return p2.coord;
    });
    var lowerThreshold = Math.cos((90 - threshold) * Math.PI / 180);
    var upperThreshold = Math.cos(threshold * Math.PI / 180);
    for (var i3 = first; i3 < last; i3++) {
      var a2 = coords[(i3 - 1 + coords.length) % coords.length];
      var origin = coords[i3];
      var b2 = coords[(i3 + 1) % coords.length];
      var dotp = geoOrthoFilterDotProduct(geoOrthoNormalizedDotProduct(a2, b2, origin), epsilon3, lowerThreshold, upperThreshold);
      if (dotp === null)
        continue;
      score = score + 2 * Math.min(Math.abs(dotp - 1), Math.min(Math.abs(dotp), Math.abs(dotp + 1)));
    }
    return score;
  }
  function geoOrthoMaxOffsetAngle(coords, isClosed, lessThan) {
    var max3 = -Infinity;
    var first = isClosed ? 0 : 1;
    var last = isClosed ? coords.length : coords.length - 1;
    for (var i3 = first; i3 < last; i3++) {
      var a2 = coords[(i3 - 1 + coords.length) % coords.length];
      var origin = coords[i3];
      var b2 = coords[(i3 + 1) % coords.length];
      var normalizedDotP = geoOrthoNormalizedDotProduct(a2, b2, origin);
      var angle2 = Math.acos(Math.abs(normalizedDotP)) * 180 / Math.PI;
      if (angle2 > 45)
        angle2 = 90 - angle2;
      if (angle2 >= lessThan)
        continue;
      if (angle2 > max3)
        max3 = angle2;
    }
    if (max3 === -Infinity)
      return null;
    return max3;
  }
  function geoOrthoCanOrthogonalize(coords, isClosed, epsilon3, threshold, allowStraightAngles) {
    var score = null;
    var first = isClosed ? 0 : 1;
    var last = isClosed ? coords.length : coords.length - 1;
    var lowerThreshold = Math.cos((90 - threshold) * Math.PI / 180);
    var upperThreshold = Math.cos(threshold * Math.PI / 180);
    for (var i3 = first; i3 < last; i3++) {
      var a2 = coords[(i3 - 1 + coords.length) % coords.length];
      var origin = coords[i3];
      var b2 = coords[(i3 + 1) % coords.length];
      var dotp = geoOrthoFilterDotProduct(geoOrthoNormalizedDotProduct(a2, b2, origin), epsilon3, lowerThreshold, upperThreshold, allowStraightAngles);
      if (dotp === null)
        continue;
      if (Math.abs(dotp) > 0)
        return 1;
      score = 0;
    }
    return score;
  }

  // modules/osm/tags.js
  function osmIsInterestingTag(key) {
    return key !== "attribution" && key !== "created_by" && key !== "source" && key !== "odbl" && key.indexOf("source:") !== 0 && key.indexOf("source_ref") !== 0 && // purposely exclude colon
    key.indexOf("tiger:") !== 0;
  }
  var osmLifecyclePrefixes = {
    // nonexistent, might be built
    proposed: true,
    planned: true,
    // under maintentance or between groundbreaking and opening
    construction: true,
    // existent but not functional
    disused: true,
    // dilapidated to nonexistent
    abandoned: true,
    was: true,
    // nonexistent, still may appear in imagery
    dismantled: true,
    razed: true,
    demolished: true,
    destroyed: true,
    removed: true,
    obliterated: true,
    // existent occasionally, e.g. stormwater drainage basin
    intermittent: true
  };
  function osmRemoveLifecyclePrefix(key) {
    const keySegments = key.split(":");
    if (keySegments.length === 1)
      return key;
    if (keySegments[0] in osmLifecyclePrefixes) {
      return key.slice(keySegments[0].length + 1);
    }
    return key;
  }
  var osmAreaKeys = {};
  function osmSetAreaKeys(value) {
    osmAreaKeys = value;
  }
  var osmAreaKeysExceptions = {
    highway: {
      elevator: true,
      rest_area: true,
      services: true
    },
    public_transport: {
      platform: true
    },
    railway: {
      platform: true,
      roundhouse: true,
      station: true,
      traverser: true,
      turntable: true,
      wash: true
    },
    waterway: {
      dam: true
    },
    amenity: {
      bicycle_parking: true
    }
  };
  function osmTagSuggestingArea(tags) {
    if (tags.area === "yes")
      return { area: "yes" };
    if (tags.area === "no")
      return null;
    var returnTags = {};
    for (var realKey in tags) {
      const key = osmRemoveLifecyclePrefix(realKey);
      if (key in osmAreaKeys && !(tags[realKey] in osmAreaKeys[key])) {
        returnTags[realKey] = tags[realKey];
        return returnTags;
      }
      if (key in osmAreaKeysExceptions && tags[realKey] in osmAreaKeysExceptions[key]) {
        returnTags[realKey] = tags[realKey];
        return returnTags;
      }
    }
    return null;
  }
  var osmLineTags = {};
  function osmSetLineTags(value) {
    osmLineTags = value;
  }
  var osmPointTags = {};
  function osmSetPointTags(value) {
    osmPointTags = value;
  }
  var osmVertexTags = {};
  function osmSetVertexTags(value) {
    osmVertexTags = value;
  }
  function osmNodeGeometriesForTags(nodeTags) {
    var geometries = {};
    for (var key in nodeTags) {
      if (osmPointTags[key] && (osmPointTags[key]["*"] || osmPointTags[key][nodeTags[key]])) {
        geometries.point = true;
      }
      if (osmVertexTags[key] && (osmVertexTags[key]["*"] || osmVertexTags[key][nodeTags[key]])) {
        geometries.vertex = true;
      }
      if (geometries.point && geometries.vertex)
        break;
    }
    return geometries;
  }
  var osmOneWayTags = {
    "aerialway": {
      "chair_lift": true,
      "drag_lift": true,
      "j-bar": true,
      "magic_carpet": true,
      "mixed_lift": true,
      "platter": true,
      "rope_tow": true,
      "t-bar": true,
      "zip_line": true
    },
    "highway": {
      "motorway": true
    },
    "junction": {
      "circular": true,
      "roundabout": true
    },
    "man_made": {
      "goods_conveyor": true,
      "piste:halfpipe": true
    },
    "piste:type": {
      "downhill": true,
      "sled": true,
      "yes": true
    },
    "seamark:type": {
      "two-way_route": true,
      "recommended_traffic_lane": true,
      "separation_lane": true,
      "separation_roundabout": true
    },
    "waterway": {
      "canal": true,
      "ditch": true,
      "drain": true,
      "fish_pass": true,
      "pressurised": true,
      "river": true,
      "spillway": true,
      "stream": true,
      "tidal_channel": true
    }
  };
  var osmPavedTags = {
    "surface": {
      "paved": true,
      "asphalt": true,
      "concrete": true,
      "chipseal": true,
      "concrete:lanes": true,
      "concrete:plates": true
    },
    "tracktype": {
      "grade1": true
    }
  };
  var osmSemipavedTags = {
    "surface": {
      "cobblestone": true,
      "cobblestone:flattened": true,
      "unhewn_cobblestone": true,
      "sett": true,
      "paving_stones": true,
      "metal": true,
      "wood": true
    }
  };
  var osmRightSideIsInsideTags = {
    "natural": {
      "cliff": true,
      "coastline": "coastline"
    },
    "barrier": {
      "retaining_wall": true,
      "kerb": true,
      "guard_rail": true,
      "city_wall": true
    },
    "man_made": {
      "embankment": true,
      "quay": true
    },
    "waterway": {
      "weir": true
    }
  };
  var osmRoutableHighwayTagValues = {
    motorway: true,
    trunk: true,
    primary: true,
    secondary: true,
    tertiary: true,
    residential: true,
    motorway_link: true,
    trunk_link: true,
    primary_link: true,
    secondary_link: true,
    tertiary_link: true,
    unclassified: true,
    road: true,
    service: true,
    track: true,
    living_street: true,
    bus_guideway: true,
    busway: true,
    path: true,
    footway: true,
    cycleway: true,
    bridleway: true,
    pedestrian: true,
    corridor: true,
    steps: true
  };
  var osmPathHighwayTagValues = {
    path: true,
    footway: true,
    cycleway: true,
    bridleway: true,
    pedestrian: true,
    corridor: true,
    steps: true
  };
  var osmRailwayTrackTagValues = {
    rail: true,
    light_rail: true,
    tram: true,
    subway: true,
    monorail: true,
    funicular: true,
    miniature: true,
    narrow_gauge: true,
    disused: true,
    preserved: true
  };
  var osmFlowingWaterwayTagValues = {
    canal: true,
    ditch: true,
    drain: true,
    fish_pass: true,
    river: true,
    stream: true,
    tidal_channel: true
  };
  var allowUpperCaseTagValues = /network|taxon|genus|species|brand|grape_variety|royal_cypher|listed_status|booth|rating|stars|:output|_hours|_times|_ref|manufacturer|country|target|brewery|cai_scale|traffic_sign/;
  function isColourValid(value) {
    if (!value.match(/^(#([0-9a-fA-F]{3}){1,2}|\w+)$/)) {
      return false;
    }
    if (!CSS.supports("color", value) || ["unset", "inherit", "initial", "revert"].includes(value)) {
      return false;
    }
    return true;
  }
  var osmMutuallyExclusiveTagPairs = [
    ["noname", "name"],
    ["noref", "ref"],
    ["nohousenumber", "addr:housenumber"],
    ["noaddress", "addr:housenumber"],
    ["noaddress", "addr:housename"],
    ["noaddress", "addr:unit"],
    ["addr:nostreet", "addr:street"]
  ];

  // modules/util/array.js
  function utilArrayIdentical(a2, b2) {
    if (a2 === b2)
      return true;
    var i3 = a2.length;
    if (i3 !== b2.length)
      return false;
    while (i3--) {
      if (a2[i3] !== b2[i3])
        return false;
    }
    return true;
  }
  function utilArrayDifference(a2, b2) {
    var other = new Set(b2);
    return Array.from(new Set(a2)).filter(function(v2) {
      return !other.has(v2);
    });
  }
  function utilArrayIntersection(a2, b2) {
    var other = new Set(b2);
    return Array.from(new Set(a2)).filter(function(v2) {
      return other.has(v2);
    });
  }
  function utilArrayUnion(a2, b2) {
    var result = new Set(a2);
    b2.forEach(function(v2) {
      result.add(v2);
    });
    return Array.from(result);
  }
  function utilArrayUniq(a2) {
    return Array.from(new Set(a2));
  }
  function utilArrayChunk(a2, chunkSize) {
    if (!chunkSize || chunkSize < 0)
      return [a2.slice()];
    var result = new Array(Math.ceil(a2.length / chunkSize));
    return Array.from(result, function(item, i3) {
      return a2.slice(i3 * chunkSize, i3 * chunkSize + chunkSize);
    });
  }
  function utilArrayFlatten(a2) {
    return a2.reduce(function(acc, val) {
      return acc.concat(val);
    }, []);
  }
  function utilArrayGroupBy(a2, key) {
    return a2.reduce(function(acc, item) {
      var group = typeof key === "function" ? key(item) : item[key];
      (acc[group] = acc[group] || []).push(item);
      return acc;
    }, {});
  }
  function utilArrayUniqBy(a2, key) {
    var seen = /* @__PURE__ */ new Set();
    return a2.reduce(function(acc, item) {
      var val = typeof key === "function" ? key(item) : item[key];
      if (val && !seen.has(val)) {
        seen.add(val);
        acc.push(item);
      }
      return acc;
    }, []);
  }

  // modules/util/util.js
  var import_diacritics = __toESM(require_diacritics());

  // modules/util/svg_paths_rtl_fix.js
  var import_alif_toolkit = __toESM(require_lib());
  var rtlRegex = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u07BF\u08A0–\u08BF]/;
  function fixRTLTextForSvg(inputText) {
    var ret = "", rtlBuffer = [];
    var arabicRegex = /[\u0600-\u06FF]/g;
    var arabicDiacritics = /[\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06ED]/g;
    var arabicMath = /[\u0660-\u066C\u06F0-\u06F9]+/g;
    var thaanaVowel = /[\u07A6-\u07B0]/;
    var hebrewSign = /[\u0591-\u05bd\u05bf\u05c1-\u05c5\u05c7]/;
    if (arabicRegex.test(inputText)) {
      inputText = (0, import_alif_toolkit.WordShaper)(inputText);
    }
    for (var n3 = 0; n3 < inputText.length; n3++) {
      var c2 = inputText[n3];
      if (arabicMath.test(c2)) {
        ret += rtlBuffer.reverse().join("");
        rtlBuffer = [c2];
      } else {
        if (rtlBuffer.length && arabicMath.test(rtlBuffer[rtlBuffer.length - 1])) {
          ret += rtlBuffer.reverse().join("");
          rtlBuffer = [];
        }
        if ((thaanaVowel.test(c2) || hebrewSign.test(c2) || arabicDiacritics.test(c2)) && rtlBuffer.length) {
          rtlBuffer[rtlBuffer.length - 1] += c2;
        } else if (rtlRegex.test(c2) || c2.charCodeAt(0) >= 64336 && c2.charCodeAt(0) <= 65023 || c2.charCodeAt(0) >= 65136 && c2.charCodeAt(0) <= 65279) {
          rtlBuffer.push(c2);
        } else if (c2 === " " && rtlBuffer.length) {
          rtlBuffer = [rtlBuffer.reverse().join("") + " "];
        } else {
          ret += rtlBuffer.reverse().join("") + c2;
          rtlBuffer = [];
        }
      }
    }
    ret += rtlBuffer.reverse().join("");
    return ret;
  }

  // modules/core/preferences.js
  var _storage;
  try {
    _storage = localStorage;
  } catch {
  }
  _storage = _storage || /* @__PURE__ */ (() => {
    let s2 = {};
    return {
      getItem: (k2) => s2[k2],
      setItem: (k2, v2) => s2[k2] = v2,
      removeItem: (k2) => delete s2[k2]
    };
  })();
  var _listeners = {};
  function corePreferences(k2, v2) {
    try {
      if (v2 === void 0)
        return _storage.getItem(k2);
      else if (v2 === null)
        _storage.removeItem(k2);
      else
        _storage.setItem(k2, v2);
      if (_listeners[k2]) {
        _listeners[k2].forEach((handler) => handler(v2));
      }
      return true;
    } catch {
      if (typeof console !== "undefined") {
        console.error("localStorage quota exceeded");
      }
      return false;
    }
  }
  corePreferences.onChange = function(k2, handler) {
    _listeners[k2] = _listeners[k2] || [];
    _listeners[k2].push(handler);
  };

  // modules/core/file_fetcher.js
  var import_vparse = __toESM(require_vparse());

  // config/id.js
  var presetsCdnUrl = "https://cdn.jsdelivr.net/npm/@openstreetmap/id-tagging-schema@{presets_version}/";
  var ociCdnUrl = "https://cdn.jsdelivr.net/npm/osm-community-index@{version}/";
  var wmfSitematrixCdnUrl = "https://cdn.jsdelivr.net/npm/wmf-sitematrix@{version}/";
  var nsiCdnUrl = "https://cdn.jsdelivr.net/npm/name-suggestion-index@{version}/";
  var defaultOsmApiConnections = {
    live: {
      url: "https://www.openstreetmap.org",
      apiUrl: "https://api.openstreetmap.org",
      client_id: "0tmNTmd0Jo1dQp4AUmMBLtGiD9YpMuXzHefitcuVStc",
      client_secret: "BTlNrNxIPitHdL4sP2clHw5KLoee9aKkA7dQbc0Bj7Q"
    },
    dev: {
      url: "https://api06.dev.openstreetmap.org",
      client_id: "Ee1wWJ6UlpERbF6BfTNOpwn0R8k_06mvMXdDUkeHMgw",
      client_secret: "OnfWFC-JkZNHyYdr_viNn_h_RTZXRslKcUxllOXqf5g"
    }
  };
  var osmApiConnections = [];
  if (false) {
    osmApiConnections.push({
      url: null,
      apiUrl: ENV__ID_API_CONNECTION_API_URL,
      client_id: null,
      client_secret: null
    });
  } else if (false) {
    osmApiConnections.push(defaultOsmApiConnections[null]);
  } else {
    osmApiConnections.push(defaultOsmApiConnections.live);
    osmApiConnections.push(defaultOsmApiConnections.dev);
  }
  var taginfoApiUrl = "https://taginfo.openstreetmap.org/api/4/";
  var nominatimApiUrl = "https://nominatim.openstreetmap.org/";
  var showDonationMessage = true;

  // package.json
  var package_default = {
    name: "@hotosm/id",
    version: "2.29.0",
    description: "A friendly editor for OpenStreetMap",
    main: "dist/iD.min.js",
    private: false,
    repository: "github:hotosm/iD",
    homepage: "https://github.com/hotosm/iD",
    bugs: "https://github.com/hotosm/iD/issues",
    keywords: [
      "editor",
      "openstreetmap"
    ],
    license: "ISC",
    scripts: {
      all: "run-s clean build dist",
      build: "run-s build:css build:data build:js",
      "build:css": "node scripts/build_css.js",
      "build:data": "shx mkdir -p dist/data && node scripts/build_data.js",
      "build:stats": "node config/esbuild.config.mjs --stats && esbuild-visualizer --metadata dist/esbuild.json --exclude *.png --filename docs/statistics.html && shx rm dist/esbuild.json",
      "build:js": "node config/esbuild.config.mjs",
      "build:js:watch": "node config/esbuild.config.mjs --watch",
      clean: "shx rm -f dist/esbuild.json dist/*.js dist/*.map dist/*.css dist/img/*.svg",
      dist: "run-p dist:**",
      "dist:mapillary": "shx mkdir -p dist/mapillary-js && shx cp -R node_modules/mapillary-js/dist/* dist/mapillary-js/",
      "dist:pannellum": "shx mkdir -p dist/pannellum && shx cp -R node_modules/pannellum/build/* dist/pannellum/",
      "dist:min": "node config/esbuild.config.min.mjs",
      "dist:svg:iD": 'svg-sprite --symbol --symbol-dest . --shape-id-generator "iD-%s" --symbol-sprite dist/img/iD-sprite.svg "svg/iD-sprite/**/*.svg"',
      "dist:svg:community": 'svg-sprite --symbol --symbol-dest . --shape-id-generator "community-%s" --symbol-sprite dist/img/community-sprite.svg node_modules/osm-community-index/dist/img/*.svg',
      "dist:svg:fa": "svg-sprite --symbol --symbol-dest . --symbol-sprite dist/img/fa-sprite.svg svg/fontawesome/*.svg",
      "dist:svg:maki": 'svg-sprite --symbol --symbol-dest . --shape-id-generator "maki-%s" --symbol-sprite dist/img/maki-sprite.svg node_modules/@mapbox/maki/icons/*.svg',
      "dist:svg:mapillary:signs": "svg-sprite --symbol --symbol-dest . --symbol-sprite dist/img/mapillary-sprite.svg node_modules/@rapideditor/mapillary_sprite_source/package_signs/*.svg",
      "dist:svg:mapillary:objects": "svg-sprite --symbol --symbol-dest . --symbol-sprite dist/img/mapillary-object-sprite.svg node_modules/@rapideditor/mapillary_sprite_source/package_objects/*.svg",
      "dist:svg:roentgen": 'svg-sprite --shape-id-generator "roentgen-%s" --shape-dim-width 16 --shape-dim-height 16 --symbol --symbol-dest . --symbol-sprite dist/img/roentgen-sprite.svg svg/roentgen/*.svg',
      "dist:svg:temaki": 'svg-sprite --symbol --symbol-dest . --shape-id-generator "temaki-%s" --symbol-sprite dist/img/temaki-sprite.svg node_modules/@rapideditor/temaki/icons/*.svg',
      imagery: "node scripts/update_imagery.js",
      lint: "eslint config scripts test/spec modules -c config/eslint.config.mjs",
      "lint:fix": "eslint scripts test/spec modules -c config/eslint.config.mjs --fix",
      start: "run-s start:watch",
      "start:single-build": "run-p build:js start:server",
      "start:watch": "run-p build:js:watch start:server",
      "start:server": "node scripts/server.js",
      test: "npm-run-all -s lint build test:spec",
      "test:spec": "karma start config/karma.conf.js",
      translations: "node scripts/update_locales.js"
    },
    dependencies: {
      "@mapbox/geojson-area": "^0.2.2",
      "@mapbox/sexagesimal": "1.2.0",
      "@mapbox/vector-tile": "^1.3.1",
      "@rapideditor/country-coder": "~5.2.2",
      "@rapideditor/location-conflation": "~1.3.0",
      "@tmcw/togeojson": "^5.8.1",
      "@turf/bbox": "^6.0.0",
      "@turf/bbox-clip": "^6.0.0",
      "abortcontroller-polyfill": "^1.7.5",
      "aes-js": "^3.1.2",
      "alif-toolkit": "^1.2.9",
      "core-js-bundle": "^3.37.0",
      diacritics: "1.3.0",
      exifr: "^7.1.3",
      "fast-deep-equal": "~3.1.1",
      "fast-json-stable-stringify": "2.1.0",
      "lodash-es": "~4.17.15",
      marked: "~12.0.2",
      "node-diff3": "~3.1.0",
      "osm-auth": "~2.4.0",
      pannellum: "2.5.6",
      pbf: "^3.2.1",
      "polygon-clipping": "~0.15.7",
      rbush: "3.0.1",
      "whatwg-fetch": "^3.6.20",
      "which-polygon": "2.2.1"
    },
    devDependencies: {
      "@fortawesome/fontawesome-svg-core": "~6.5.2",
      "@fortawesome/free-brands-svg-icons": "~6.5.2",
      "@fortawesome/free-regular-svg-icons": "~6.5.2",
      "@fortawesome/free-solid-svg-icons": "~6.5.2",
      "@mapbox/maki": "^8.0.1",
      "@openstreetmap/id-tagging-schema": "^6.7.3",
      "@rapideditor/mapillary_sprite_source": "^1.8.0",
      "@rapideditor/temaki": "^5.8.0",
      "@transifex/api": "^7.1.0",
      autoprefixer: "^10.4.19",
      browserslist: "^4.23.0",
      "browserslist-to-esbuild": "^2.1.1",
      chai: "^4.4.1",
      chalk: "^4.1.2",
      "cldr-core": "^45.0.0",
      "cldr-localenames-full": "^45.0.0",
      "concat-files": "^0.1.1",
      d3: "~7.9.0",
      dotenv: "^16.4.5",
      "editor-layer-index": "github:osmlab/editor-layer-index#gh-pages",
      esbuild: "^0.20.2",
      "esbuild-visualizer": "^0.6.0",
      eslint: "^9.1.1",
      "fetch-mock": "^9.11.0",
      gaze: "^1.1.3",
      glob: "^10.3.12",
      happen: "^0.3.2",
      "js-yaml": "^4.0.0",
      "json-stringify-pretty-compact": "^3.0.0",
      karma: "^6.4.3",
      "karma-chrome-launcher": "^3.2.0",
      "karma-coverage": "2.1.1",
      "karma-mocha": "^2.0.1",
      "karma-remap-istanbul": "^0.6.0",
      "mapillary-js": "4.1.2",
      minimist: "^1.2.8",
      mocha: "^10.4.0",
      "name-suggestion-index": "~6.0",
      "npm-run-all": "^4.0.0",
      "osm-community-index": "~5.6.2",
      postcss: "^8.4.38",
      "postcss-selector-prepend": "^0.5.0",
      shelljs: "^0.8.0",
      shx: "^0.3.0",
      sinon: "^11.1.2",
      "sinon-chai": "^3.7.0",
      smash: "0.0",
      "static-server": "^2.2.1",
      "svg-sprite": "2.0.4",
      vparse: "~1.1.0"
    },
    engines: {
      node: ">=18"
    },
    browserslist: [
      "> 0.3%, last 6 major versions, not dead, Firefox ESR, maintained node versions"
    ]
  };

  // modules/core/file_fetcher.js
  var _mainFileFetcher = coreFileFetcher();
  function coreFileFetcher() {
    const ociVersion = package_default.dependencies["osm-community-index"] || package_default.devDependencies["osm-community-index"];
    const v2 = (0, import_vparse.default)(ociVersion);
    const ociVersionMinor = "".concat(v2.major, ".").concat(v2.minor);
    const presetsVersion = package_default.devDependencies["@openstreetmap/id-tagging-schema"];
    let _this = {};
    let _inflight4 = {};
    let _fileMap = {
      "address_formats": "data/address_formats.min.json",
      "imagery": "data/imagery.min.json",
      "intro_graph": "data/intro_graph.min.json",
      "keepRight": "data/keepRight.min.json",
      "languages": "data/languages.min.json",
      "locales": "locales/index.min.json",
      "phone_formats": "data/phone_formats.min.json",
      "qa_data": "data/qa_data.min.json",
      "shortcuts": "data/shortcuts.min.json",
      "territory_languages": "data/territory_languages.min.json",
      "oci_defaults": ociCdnUrl.replace("{version}", ociVersionMinor) + "dist/defaults.min.json",
      "oci_features": ociCdnUrl.replace("{version}", ociVersionMinor) + "dist/featureCollection.min.json",
      "oci_resources": ociCdnUrl.replace("{version}", ociVersionMinor) + "dist/resources.min.json",
      "presets_package": presetsCdnUrl.replace("{presets_version}", presetsVersion) + "package.json",
      "deprecated": presetsCdnUrl + "dist/deprecated.min.json",
      "discarded": presetsCdnUrl + "dist/discarded.min.json",
      "preset_categories": presetsCdnUrl + "dist/preset_categories.min.json",
      "preset_defaults": presetsCdnUrl + "dist/preset_defaults.min.json",
      "preset_fields": presetsCdnUrl + "dist/fields.min.json",
      "preset_presets": presetsCdnUrl + "dist/presets.min.json",
      "wmf_sitematrix": wmfSitematrixCdnUrl.replace("{version}", "0.1") + "wikipedia.min.json"
    };
    let _cachedData = {};
    _this.cache = () => _cachedData;
    _this.get = (which) => {
      if (_cachedData[which]) {
        return Promise.resolve(_cachedData[which]);
      }
      const file = _fileMap[which];
      const url = file && _this.asset(file);
      if (!url) {
        return Promise.reject('Unknown data file for "'.concat(which, '"'));
      }
      if (url.includes("{presets_version}")) {
        return _this.get("presets_package").then((result) => {
          const presetsVersion2 = result.version;
          return getUrl(url.replace("{presets_version}", presetsVersion2), which);
        });
      } else {
        return getUrl(url);
      }
    };
    function getUrl(url, which) {
      let prom = _inflight4[url];
      if (!prom) {
        _inflight4[url] = prom = fetch(url).then((response) => {
          if (!response.ok || !response.json) {
            throw new Error(response.status + " " + response.statusText);
          }
          if (response.status === 204 || response.status === 205)
            return;
          return response.json();
        }).then((result) => {
          delete _inflight4[url];
          if (!result) {
            throw new Error('No data loaded for "'.concat(which, '"'));
          }
          _cachedData[which] = result;
          return result;
        }).catch((err) => {
          delete _inflight4[url];
          throw err;
        });
      }
      return prom;
    }
    _this.fileMap = function(val) {
      if (!arguments.length)
        return _fileMap;
      _fileMap = val;
      return _this;
    };
    let _assetPath = "";
    _this.assetPath = function(val) {
      if (!arguments.length)
        return _assetPath;
      _assetPath = val;
      return _this;
    };
    let _assetMap = {};
    _this.assetMap = function(val) {
      if (!arguments.length)
        return _assetMap;
      _assetMap = val;
      return _this;
    };
    _this.asset = (val) => {
      if (/^http(s)?:\/\//i.test(val))
        return val;
      const filename = _assetPath + val;
      return _assetMap[filename] || filename;
    };
    return _this;
  }

  // node_modules/@rapideditor/country-coder/dist/country-coder.mjs
  var import_which_polygon = __toESM(require_which_polygon(), 1);
  var borders_default = { type: "FeatureCollection", features: [
    { type: "Feature", properties: { wikidata: "Q21", nameEn: "England", aliases: ["GB-ENG"], country: "GB", groups: ["Q23666", "Q3336843", "154", "150", "UN"], driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["44"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-6.03913, 51.13217], [-7.74976, 48.64773], [1.17405, 50.74239], [2.18458, 51.52087], [2.56575, 51.85301], [0.792, 57.56437], [-2.30613, 55.62698], [-2.17058, 55.45916], [-2.6095, 55.28488], [-2.63532, 55.19452], [-3.02906, 55.04606], [-3.09361, 54.94924], [-3.38407, 54.94278], [-4.1819, 54.57861], [-3.5082, 53.54318], [-3.08228, 53.25526], [-3.03675, 53.25092], [-2.92329, 53.19383], [-2.92022, 53.17685], [-2.98598, 53.15589], [-2.90649, 53.10964], [-2.87469, 53.12337], [-2.89131, 53.09374], [-2.83133, 52.99184], [-2.7251, 52.98389], [-2.72221, 52.92969], [-2.80549, 52.89428], [-2.85897, 52.94487], [-2.92401, 52.93836], [-2.97243, 52.9651], [-3.13576, 52.895], [-3.15744, 52.84947], [-3.16105, 52.79599], [-3.08734, 52.77504], [-3.01001, 52.76636], [-2.95581, 52.71794], [-3.01724, 52.72083], [-3.04398, 52.65435], [-3.13648, 52.58208], [-3.12926, 52.5286], [-3.09746, 52.53077], [-3.08662, 52.54811], [-3.00929, 52.57774], [-2.99701, 52.551], [-3.03603, 52.49969], [-3.13359, 52.49174], [-3.22971, 52.45344], [-3.22754, 52.42526], [-3.04687, 52.34504], [-2.95364, 52.3501], [-2.99701, 52.323], [-3.00785, 52.2753], [-3.09289, 52.20546], [-3.12638, 52.08114], [-2.97111, 51.90456], [-2.8818, 51.93196], [-2.78742, 51.88833], [-2.74277, 51.84367], [-2.66234, 51.83555], [-2.66336, 51.59504], [-3.20563, 51.31615], [-6.03913, 51.13217]]]] } },
    { type: "Feature", properties: { wikidata: "Q22", nameEn: "Scotland", aliases: ["GB-SCT"], country: "GB", groups: ["Q23666", "Q3336843", "154", "150", "UN"], driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["44"] }, geometry: { type: "MultiPolygon", coordinates: [[[[0.792, 57.56437], [-0.3751, 61.32236], [-14.78497, 57.60709], [-6.82333, 55.83103], [-4.69044, 54.3629], [-3.38407, 54.94278], [-3.09361, 54.94924], [-3.02906, 55.04606], [-2.63532, 55.19452], [-2.6095, 55.28488], [-2.17058, 55.45916], [-2.30613, 55.62698], [0.792, 57.56437]]]] } },
    { type: "Feature", properties: { wikidata: "Q25", nameEn: "Wales", aliases: ["GB-WLS"], country: "GB", groups: ["Q23666", "Q3336843", "154", "150", "UN"], driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["44"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-3.5082, 53.54318], [-5.37267, 53.63269], [-6.03913, 51.13217], [-3.20563, 51.31615], [-2.66336, 51.59504], [-2.66234, 51.83555], [-2.74277, 51.84367], [-2.78742, 51.88833], [-2.8818, 51.93196], [-2.97111, 51.90456], [-3.12638, 52.08114], [-3.09289, 52.20546], [-3.00785, 52.2753], [-2.99701, 52.323], [-2.95364, 52.3501], [-3.04687, 52.34504], [-3.22754, 52.42526], [-3.22971, 52.45344], [-3.13359, 52.49174], [-3.03603, 52.49969], [-2.99701, 52.551], [-3.00929, 52.57774], [-3.08662, 52.54811], [-3.09746, 52.53077], [-3.12926, 52.5286], [-3.13648, 52.58208], [-3.04398, 52.65435], [-3.01724, 52.72083], [-2.95581, 52.71794], [-3.01001, 52.76636], [-3.08734, 52.77504], [-3.16105, 52.79599], [-3.15744, 52.84947], [-3.13576, 52.895], [-2.97243, 52.9651], [-2.92401, 52.93836], [-2.85897, 52.94487], [-2.80549, 52.89428], [-2.72221, 52.92969], [-2.7251, 52.98389], [-2.83133, 52.99184], [-2.89131, 53.09374], [-2.87469, 53.12337], [-2.90649, 53.10964], [-2.98598, 53.15589], [-2.92022, 53.17685], [-2.92329, 53.19383], [-3.03675, 53.25092], [-3.08228, 53.25526], [-3.5082, 53.54318]]]] } },
    { type: "Feature", properties: { wikidata: "Q26", nameEn: "Northern Ireland", aliases: ["GB-NIR"], country: "GB", groups: ["Q22890", "Q3336843", "154", "150", "UN"], driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["44"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-6.34755, 55.49206], [-7.2471, 55.06933], [-7.34464, 55.04688], [-7.4033, 55.00391], [-7.40004, 54.94498], [-7.44404, 54.9403], [-7.4473, 54.87003], [-7.47626, 54.83084], [-7.54508, 54.79401], [-7.54671, 54.74606], [-7.64449, 54.75265], [-7.75041, 54.7103], [-7.83352, 54.73854], [-7.93293, 54.66603], [-7.70315, 54.62077], [-7.8596, 54.53671], [-7.99812, 54.54427], [-8.04538, 54.48941], [-8.179, 54.46763], [-8.04555, 54.36292], [-7.87101, 54.29299], [-7.8596, 54.21779], [-7.81397, 54.20159], [-7.69501, 54.20731], [-7.55812, 54.12239], [-7.4799, 54.12239], [-7.44567, 54.1539], [-7.32834, 54.11475], [-7.30553, 54.11869], [-7.34005, 54.14698], [-7.29157, 54.17191], [-7.28017, 54.16714], [-7.29687, 54.1354], [-7.29493, 54.12013], [-7.26316, 54.13863], [-7.25012, 54.20063], [-7.14908, 54.22732], [-7.19145, 54.31296], [-7.02034, 54.4212], [-6.87775, 54.34682], [-6.85179, 54.29176], [-6.81583, 54.22791], [-6.74575, 54.18788], [-6.70175, 54.20218], [-6.6382, 54.17071], [-6.66264, 54.0666], [-6.62842, 54.03503], [-6.47849, 54.06947], [-6.36605, 54.07234], [-6.36279, 54.11248], [-6.32694, 54.09337], [-6.29003, 54.11278], [-6.26218, 54.09785], [-5.83481, 53.87749], [-4.69044, 54.3629], [-6.34755, 55.49206]]]] } },
    { type: "Feature", properties: { wikidata: "Q35", nameEn: "Denmark", country: "DK", groups: ["EU", "154", "150", "UN"], callingCodes: ["45"] }, geometry: { type: "MultiPolygon", coordinates: [[[[12.16597, 56.60205], [10.40861, 58.38489], [7.28637, 57.35913], [8.02459, 55.09613], [8.45719, 55.06747], [8.55769, 54.91837], [8.63979, 54.91069], [8.76387, 54.8948], [8.81178, 54.90518], [8.92795, 54.90452], [9.04629, 54.87249], [9.14275, 54.87421], [9.20571, 54.85841], [9.24631, 54.84726], [9.23445, 54.83432], [9.2474, 54.8112], [9.32771, 54.80602], [9.33849, 54.80233], [9.36496, 54.81749], [9.38532, 54.83968], [9.41213, 54.84254], [9.43155, 54.82586], [9.4659, 54.83131], [9.58937, 54.88785], [9.62734, 54.88057], [9.61187, 54.85548], [9.73563, 54.8247], [9.89314, 54.84171], [10.16755, 54.73883], [10.31111, 54.65968], [11.00303, 54.63689], [11.90309, 54.38543], [12.85844, 54.82438], [13.93395, 54.84044], [15.36991, 54.73263], [15.79951, 55.54655], [14.89259, 55.5623], [14.28399, 55.1553], [12.84405, 55.13257], [12.60345, 55.42675], [12.88472, 55.63369], [12.6372, 55.91371], [12.65312, 56.04345], [12.07466, 56.29488], [12.16597, 56.60205]]]] } },
    { type: "Feature", properties: { wikidata: "Q55", nameEn: "Netherlands", country: "NL", groups: ["EU", "155", "150", "UN"], callingCodes: ["31"] }, geometry: { type: "MultiPolygon", coordinates: [[[[5.45168, 54.20039], [2.56575, 51.85301], [3.36263, 51.37112], [3.38696, 51.33436], [3.35847, 51.31572], [3.38289, 51.27331], [3.41704, 51.25933], [3.43488, 51.24135], [3.52698, 51.2458], [3.51502, 51.28697], [3.58939, 51.30064], [3.78999, 51.25766], [3.78783, 51.2151], [3.90125, 51.20371], [3.97889, 51.22537], [4.01957, 51.24504], [4.05165, 51.24171], [4.16721, 51.29348], [4.24024, 51.35371], [4.21923, 51.37443], [4.33265, 51.37687], [4.34086, 51.35738], [4.39292, 51.35547], [4.43777, 51.36989], [4.38064, 51.41965], [4.39747, 51.43316], [4.38122, 51.44905], [4.47736, 51.4778], [4.5388, 51.48184], [4.54675, 51.47265], [4.52846, 51.45002], [4.53521, 51.4243], [4.57489, 51.4324], [4.65442, 51.42352], [4.72935, 51.48424], [4.74578, 51.48937], [4.77321, 51.50529], [4.78803, 51.50284], [4.84139, 51.4799], [4.82409, 51.44736], [4.82946, 51.4213], [4.78314, 51.43319], [4.76577, 51.43046], [4.77229, 51.41337], [4.78941, 51.41102], [4.84988, 51.41502], [4.90016, 51.41404], [4.92152, 51.39487], [5.00393, 51.44406], [5.0106, 51.47167], [5.03281, 51.48679], [5.04774, 51.47022], [5.07891, 51.4715], [5.10456, 51.43163], [5.07102, 51.39469], [5.13105, 51.34791], [5.13377, 51.31592], [5.16222, 51.31035], [5.2002, 51.32243], [5.24244, 51.30495], [5.22542, 51.26888], [5.23814, 51.26064], [5.26461, 51.26693], [5.29716, 51.26104], [5.33886, 51.26314], [5.347, 51.27502], [5.41672, 51.26248], [5.4407, 51.28169], [5.46519, 51.2849], [5.48476, 51.30053], [5.515, 51.29462], [5.5569, 51.26544], [5.5603, 51.22249], [5.65145, 51.19788], [5.65528, 51.18736], [5.70344, 51.1829], [5.74617, 51.18928], [5.77735, 51.17845], [5.77697, 51.1522], [5.82564, 51.16753], [5.85508, 51.14445], [5.80798, 51.11661], [5.8109, 51.10861], [5.83226, 51.10585], [5.82921, 51.09328], [5.79903, 51.09371], [5.79835, 51.05834], [5.77258, 51.06196], [5.75961, 51.03113], [5.77688, 51.02483], [5.76242, 50.99703], [5.71864, 50.96092], [5.72875, 50.95428], [5.74752, 50.96202], [5.75927, 50.95601], [5.74644, 50.94723], [5.72545, 50.92312], [5.72644, 50.91167], [5.71626, 50.90796], [5.69858, 50.91046], [5.67886, 50.88142], [5.64504, 50.87107], [5.64009, 50.84742], [5.65259, 50.82309], [5.70118, 50.80764], [5.68995, 50.79641], [5.70107, 50.7827], [5.68091, 50.75804], [5.69469, 50.75529], [5.72216, 50.76398], [5.73904, 50.75674], [5.74356, 50.7691], [5.76533, 50.78159], [5.77513, 50.78308], [5.80673, 50.7558], [5.84548, 50.76542], [5.84888, 50.75448], [5.88734, 50.77092], [5.89129, 50.75125], [5.89132, 50.75124], [5.95942, 50.7622], [5.97545, 50.75441], [6.01976, 50.75398], [6.02624, 50.77453], [5.97497, 50.79992], [5.98404, 50.80988], [6.00462, 50.80065], [6.02328, 50.81694], [6.01921, 50.84435], [6.05623, 50.8572], [6.05702, 50.85179], [6.07431, 50.84674], [6.07693, 50.86025], [6.08805, 50.87223], [6.07486, 50.89307], [6.09297, 50.92066], [6.01615, 50.93367], [6.02697, 50.98303], [5.95282, 50.98728], [5.90296, 50.97356], [5.90493, 51.00198], [5.87849, 51.01969], [5.86735, 51.05182], [5.9134, 51.06736], [5.9541, 51.03496], [5.98292, 51.07469], [6.16706, 51.15677], [6.17384, 51.19589], [6.07889, 51.17038], [6.07889, 51.24432], [6.16977, 51.33169], [6.22674, 51.36135], [6.22641, 51.39948], [6.20654, 51.40049], [6.21724, 51.48568], [6.18017, 51.54096], [6.09055, 51.60564], [6.11759, 51.65609], [6.02767, 51.6742], [6.04091, 51.71821], [5.95003, 51.7493], [5.98665, 51.76944], [5.94568, 51.82786], [5.99848, 51.83195], [6.06705, 51.86136], [6.10337, 51.84829], [6.16902, 51.84094], [6.11551, 51.89769], [6.15349, 51.90439], [6.21443, 51.86801], [6.29872, 51.86801], [6.30593, 51.84998], [6.40704, 51.82771], [6.38815, 51.87257], [6.47179, 51.85395], [6.50231, 51.86313], [6.58556, 51.89386], [6.68386, 51.91861], [6.72319, 51.89518], [6.82357, 51.96711], [6.83035, 51.9905], [6.68128, 52.05052], [6.76117, 52.11895], [6.83984, 52.11728], [6.97189, 52.20329], [6.9897, 52.2271], [7.03729, 52.22695], [7.06365, 52.23789], [7.02703, 52.27941], [7.07044, 52.37805], [7.03417, 52.40237], [6.99041, 52.47235], [6.94293, 52.43597], [6.69507, 52.488], [6.71641, 52.62905], [6.77307, 52.65375], [7.04557, 52.63318], [7.07253, 52.81083], [7.21694, 53.00742], [7.17898, 53.13817], [7.22681, 53.18165], [7.21679, 53.20058], [7.19052, 53.31866], [7.00198, 53.32672], [6.91025, 53.44221], [5.45168, 54.20039]], [[4.93295, 51.44945], [4.95244, 51.45207], [4.9524, 51.45014], [4.93909, 51.44632], [4.93295, 51.44945]], [[4.91493, 51.4353], [4.91935, 51.43634], [4.92227, 51.44252], [4.91811, 51.44621], [4.92287, 51.44741], [4.92811, 51.4437], [4.92566, 51.44273], [4.92815, 51.43856], [4.92879, 51.44161], [4.93544, 51.44634], [4.94025, 51.44193], [4.93416, 51.44185], [4.93471, 51.43861], [4.94265, 51.44003], [4.93986, 51.43064], [4.92952, 51.42984], [4.92652, 51.43329], [4.91493, 51.4353]]]] } },
    { type: "Feature", properties: { wikidata: "Q782", nameEn: "Hawaii", aliases: ["US-HI"], country: "US", groups: ["Q35657", "061", "009", "UN"], roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["1"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-177.8563, 29.18961], [-179.49839, 27.86265], [-151.6784, 9.55515], [-154.05867, 45.51124], [-177.5224, 27.7635], [-177.8563, 29.18961]]]] } },
    { type: "Feature", properties: { wikidata: "Q797", nameEn: "Alaska", aliases: ["US-AK"], country: "US", groups: ["Q35657", "021", "003", "019", "UN"], roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["1"] }, geometry: { type: "MultiPolygon", coordinates: [[[[169.34848, 52.47228], [180, 51.0171], [179.84401, 55.10087], [169.34848, 52.47228]]], [[[-168.95635, 65.98512], [-169.03888, 65.48473], [-172.76104, 63.77445], [-179.55295, 57.62081], [-179.55295, 50.81807], [-133.92876, 54.62289], [-130.61931, 54.70835], [-130.64499, 54.76912], [-130.44184, 54.85377], [-130.27203, 54.97174], [-130.18765, 55.07744], [-130.08035, 55.21556], [-129.97513, 55.28029], [-130.15373, 55.74895], [-130.00857, 55.91344], [-130.00093, 56.00325], [-130.10173, 56.12178], [-130.33965, 56.10849], [-130.77769, 56.36185], [-131.8271, 56.62247], [-133.38523, 58.42773], [-133.84645, 58.73543], [-134.27175, 58.8634], [-134.48059, 59.13231], [-134.55699, 59.1297], [-134.7047, 59.2458], [-135.00267, 59.28745], [-135.03069, 59.56208], [-135.48007, 59.79937], [-136.31566, 59.59083], [-136.22381, 59.55526], [-136.33727, 59.44466], [-136.47323, 59.46617], [-136.52365, 59.16752], [-136.82619, 59.16198], [-137.4925, 58.89415], [-137.60623, 59.24465], [-138.62145, 59.76431], [-138.71149, 59.90728], [-139.05365, 59.99655], [-139.20603, 60.08896], [-139.05831, 60.35205], [-139.68991, 60.33693], [-139.98024, 60.18027], [-140.45648, 60.30919], [-140.5227, 60.22077], [-141.00116, 60.30648], [-140.97446, 84.39275], [-168.25765, 71.99091], [-168.95635, 65.98512]]]] } },
    { type: "Feature", properties: { wikidata: "Q3492", nameEn: "Sumatra", aliases: ["ID-SM"], country: "ID", groups: ["035", "142", "UN"], driveSide: "left", callingCodes: ["62"] }, geometry: { type: "MultiPolygon", coordinates: [[[[109.82788, 2.86812], [110.90339, 7.52694], [105.01437, 3.24936], [104.56723, 1.44271], [104.34728, 1.33529], [104.12282, 1.27714], [104.03085, 1.26954], [103.74084, 1.12902], [103.66049, 1.18825], [103.56591, 1.19719], [103.03657, 1.30383], [96.11174, 6.69841], [74.28481, -3.17525], [102.92489, -8.17146], [106.32259, -5.50116], [106.38511, -5.16715], [109.17017, -4.07401], [109.3962, -2.07276], [108.50935, -2.01066], [107.94791, 1.06924], [109.82788, 2.86812]]]] } },
    { type: "Feature", properties: { wikidata: "Q3757", nameEn: "Java", aliases: ["ID-JW"], country: "ID", groups: ["035", "142", "UN"], driveSide: "left", callingCodes: ["62"] }, geometry: { type: "MultiPolygon", coordinates: [[[[109.17017, -4.07401], [106.38511, -5.16715], [106.32259, -5.50116], [102.92489, -8.17146], [116.22542, -10.49172], [114.39575, -8.2889], [114.42235, -8.09762], [114.92859, -7.49253], [116.33992, -7.56171], [116.58433, -5.30385], [109.17017, -4.07401]]]] } },
    { type: "Feature", properties: { wikidata: "Q3795", nameEn: "Kalimantan", aliases: ["ID-KA"], country: "ID", groups: ["Q36117", "035", "142", "UN"], driveSide: "left", callingCodes: ["62"] }, geometry: { type: "MultiPolygon", coordinates: [[[[120.02464, 2.83703], [118.06469, 4.16638], [117.67641, 4.16535], [117.47313, 4.18857], [117.25801, 4.35108], [115.90217, 4.37708], [115.58276, 3.93499], [115.53713, 3.14776], [115.11343, 2.82879], [115.1721, 2.49671], [114.80706, 2.21665], [114.80706, 1.92351], [114.57892, 1.5], [114.03788, 1.44787], [113.64677, 1.23933], [113.01448, 1.42832], [113.021, 1.57819], [112.48648, 1.56516], [112.2127, 1.44135], [112.15679, 1.17004], [111.94553, 1.12016], [111.82846, 0.99349], [111.55434, 0.97864], [111.22979, 1.08326], [110.62374, 0.873], [110.49182, 0.88088], [110.35354, 0.98869], [109.66397, 1.60425], [109.66397, 1.79972], [109.57923, 1.80624], [109.53794, 1.91771], [109.62558, 1.99182], [109.82788, 2.86812], [107.94791, 1.06924], [108.50935, -2.01066], [109.3962, -2.07276], [109.17017, -4.07401], [116.58433, -5.30385], [120.02464, 2.83703]]]] } },
    { type: "Feature", properties: { wikidata: "Q3803", nameEn: "Lesser Sunda Islands", aliases: ["ID-NU"], country: "ID", groups: ["035", "142", "UN"], driveSide: "left", callingCodes: ["62"] }, geometry: { type: "MultiPolygon", coordinates: [[[[116.96967, -8.01483], [114.92859, -7.49253], [114.42235, -8.09762], [114.39575, -8.2889], [116.22542, -10.49172], [122.14954, -11.52517], [125.68138, -9.85176], [125.09025, -9.46406], [124.97892, -9.19281], [125.04044, -9.17093], [125.09434, -9.19669], [125.18907, -9.16434], [125.18632, -9.03142], [125.11764, -8.96359], [124.97742, -9.08128], [124.94011, -8.85617], [124.46701, -9.13002], [124.45971, -9.30263], [124.38554, -9.3582], [124.35258, -9.43002], [124.3535, -9.48493], [124.28115, -9.50453], [124.28115, -9.42189], [124.21247, -9.36904], [124.14517, -9.42324], [124.10539, -9.41206], [124.04286, -9.34243], [124.04628, -9.22671], [124.33472, -9.11416], [124.92337, -8.75859], [125.87688, -7.49892], [116.96967, -8.01483]]]] } },
    { type: "Feature", properties: { wikidata: "Q3812", nameEn: "Sulawesi", aliases: ["ID-SL"], country: "ID", groups: ["035", "142", "UN"], driveSide: "left", callingCodes: ["62"] }, geometry: { type: "MultiPolygon", coordinates: [[[[128.34321, 3.90322], [126.69413, 6.02692], [119.56457, 0.90759], [116.58433, -5.30385], [116.33992, -7.56171], [116.96967, -8.01483], [125.87688, -7.49892], [123.78965, -0.86805], [128.34321, 3.90322]]]] } },
    { type: "Feature", properties: { wikidata: "Q3827", nameEn: "Maluku Islands", aliases: ["ID-ML"], country: "ID", groups: ["035", "142", "UN"], driveSide: "left", callingCodes: ["62"] }, geometry: { type: "MultiPolygon", coordinates: [[[[129.63187, 2.21409], [128.34321, 3.90322], [123.78965, -0.86805], [125.87688, -7.49892], [125.58506, -7.95311], [125.87691, -8.31789], [127.42116, -8.22471], [127.55165, -9.05052], [135.49042, -9.2276], [135.35517, -5.01442], [132.8312, -4.70282], [130.8468, -2.61103], [128.40647, -2.30349], [129.71519, -0.24692], [129.63187, 2.21409]]]] } },
    { type: "Feature", properties: { wikidata: "Q3845", nameEn: "Western New Guinea", aliases: ["ID-PP"], country: "ID", groups: ["035", "142", "UN"], driveSide: "left", callingCodes: ["62"] }, geometry: { type: "MultiPolygon", coordinates: [[[[135.49042, -9.2276], [141.01842, -9.35091], [141.01763, -6.90181], [140.90448, -6.85033], [140.85295, -6.72996], [140.99813, -6.3233], [141.02352, 0.08993], [129.63187, 2.21409], [129.71519, -0.24692], [128.40647, -2.30349], [130.8468, -2.61103], [132.8312, -4.70282], [135.35517, -5.01442], [135.49042, -9.2276]]]] } },
    { type: "Feature", properties: { wikidata: "Q5765", nameEn: "Balearic Islands", aliases: ["ES-IB"], country: "ES", groups: ["EU", "039", "150", "UN"], callingCodes: ["34 971"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-2.27707, 35.35051], [5.10072, 39.89531], [3.75438, 42.33445], [-2.27707, 35.35051]]]] } },
    { type: "Feature", properties: { wikidata: "Q5823", nameEn: "Ceuta", aliases: ["ES-CE"], country: "ES", groups: ["EA", "EU", "015", "002", "UN"], level: "subterritory", callingCodes: ["34"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-5.38491, 35.92591], [-5.37338, 35.88417], [-5.35844, 35.87375], [-5.34379, 35.8711], [-5.21179, 35.90091], [-5.38491, 35.92591]]]] } },
    { type: "Feature", properties: { wikidata: "Q5831", nameEn: "Melilla", aliases: ["ES-ML"], country: "ES", groups: ["EA", "EU", "015", "002", "UN"], level: "subterritory", callingCodes: ["34"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-2.91909, 35.33927], [-2.96038, 35.31609], [-2.96648, 35.30475], [-2.96978, 35.29459], [-2.97035, 35.28852], [-2.96507, 35.28801], [-2.96826, 35.28296], [-2.96516, 35.27967], [-2.95431, 35.2728], [-2.95065, 35.26576], [-2.93893, 35.26737], [-2.92272, 35.27509], [-2.91909, 35.33927]]]] } },
    { type: "Feature", properties: { wikidata: "Q7835", nameEn: "Crimea", country: "RU", groups: ["151", "150", "UN"], level: "subterritory", callingCodes: ["7"] }, geometry: { type: "MultiPolygon", coordinates: [[[[33.5, 44], [36.4883, 45.0488], [36.475, 45.2411], [36.5049, 45.3136], [36.6545, 45.3417], [36.6645, 45.4514], [35.0498, 45.7683], [34.9601, 45.7563], [34.7991, 45.8101], [34.8015, 45.9005], [34.7548, 45.907], [34.6668, 45.9714], [34.6086, 45.9935], [34.5589, 45.9935], [34.5201, 45.951], [34.4873, 45.9427], [34.4415, 45.9599], [34.4122, 46.0025], [34.3391, 46.0611], [34.2511, 46.0532], [34.181, 46.068], [34.1293, 46.1049], [34.0731, 46.1177], [34.0527, 46.1084], [33.9155, 46.1594], [33.8523, 46.1986], [33.7972, 46.2048], [33.7405, 46.1855], [33.646, 46.2303], [33.6152, 46.2261], [33.6385, 46.1415], [33.6147, 46.1356], [33.5732, 46.1032], [33.5909, 46.0601], [33.5597, 46.0307], [31.5, 45.5], [33.5, 44]]]] } },
    { type: "Feature", properties: { wikidata: "Q12837", nameEn: "Iberia", level: "sharedLandform" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q14056", nameEn: "Jan Mayen", aliases: ["NO-22"], country: "NO", groups: ["SJ", "154", "150", "UN"], level: "subterritory" }, geometry: { type: "MultiPolygon", coordinates: [[[[-9.18243, 72.23144], [-10.71459, 70.09565], [-5.93364, 70.76368], [-9.18243, 72.23144]]]] } },
    { type: "Feature", properties: { wikidata: "Q19188", nameEn: "Mainland China", country: "CN", groups: ["030", "142", "UN"], callingCodes: ["86"] }, geometry: { type: "MultiPolygon", coordinates: [[[[125.6131, 53.07229], [125.17522, 53.20225], [124.46078, 53.21881], [123.86158, 53.49391], [123.26989, 53.54843], [122.85966, 53.47395], [122.35063, 53.49565], [121.39213, 53.31888], [120.85633, 53.28499], [120.0451, 52.7359], [120.04049, 52.58773], [120.46454, 52.63811], [120.71673, 52.54099], [120.61346, 52.32447], [120.77337, 52.20805], [120.65907, 51.93544], [120.10963, 51.671], [119.13553, 50.37412], [119.38598, 50.35162], [119.27996, 50.13348], [119.11003, 50.00276], [118.61623, 49.93809], [117.82343, 49.52696], [117.48208, 49.62324], [117.27597, 49.62544], [116.71193, 49.83813], [116.03781, 48.87014], [116.06565, 48.81716], [115.78876, 48.51781], [115.811, 48.25699], [115.52082, 48.15367], [115.57128, 47.91988], [115.94296, 47.67741], [116.21879, 47.88505], [116.4465, 47.83662], [116.67405, 47.89039], [116.9723, 47.87285], [117.37875, 47.63627], [117.50181, 47.77216], [117.80196, 48.01661], [118.03676, 48.00982], [118.11009, 48.04], [118.22677, 48.03853], [118.29654, 48.00246], [118.55766, 47.99277], [118.7564, 47.76947], [119.12343, 47.66458], [119.13995, 47.53997], [119.35892, 47.48104], [119.31964, 47.42617], [119.54918, 47.29505], [119.56019, 47.24874], [119.62403, 47.24575], [119.71209, 47.19192], [119.85518, 46.92196], [119.91242, 46.90091], [119.89261, 46.66423], [119.80455, 46.67631], [119.77373, 46.62947], [119.68127, 46.59015], [119.65265, 46.62342], [119.42827, 46.63783], [119.32827, 46.61433], [119.24978, 46.64761], [119.10448, 46.65516], [119.00541, 46.74273], [118.92616, 46.72765], [118.89974, 46.77139], [118.8337, 46.77742], [118.78747, 46.68689], [118.30534, 46.73519], [117.69554, 46.50991], [117.60748, 46.59771], [117.41782, 46.57862], [117.36609, 46.36335], [116.83166, 46.38637], [116.75551, 46.33083], [116.58612, 46.30211], [116.26678, 45.96479], [116.24012, 45.8778], [116.27366, 45.78637], [116.16989, 45.68603], [115.60329, 45.44717], [114.94546, 45.37377], [114.74612, 45.43585], [114.54801, 45.38337], [114.5166, 45.27189], [113.70918, 44.72891], [112.74662, 44.86297], [112.4164, 45.06858], [111.98695, 45.09074], [111.76275, 44.98032], [111.40498, 44.3461], [111.96289, 43.81596], [111.93776, 43.68709], [111.79758, 43.6637], [111.59087, 43.51207], [111.0149, 43.3289], [110.4327, 42.78293], [110.08401, 42.6411], [109.89402, 42.63111], [109.452, 42.44842], [109.00679, 42.45302], [108.84489, 42.40246], [107.57258, 42.40898], [107.49681, 42.46221], [107.29755, 42.41395], [107.24774, 42.36107], [106.76517, 42.28741], [105.0123, 41.63188], [104.51667, 41.66113], [104.52258, 41.8706], [103.92804, 41.78246], [102.72403, 42.14675], [102.07645, 42.22519], [101.80515, 42.50074], [100.84979, 42.67087], [100.33297, 42.68231], [99.50671, 42.56535], [97.1777, 42.7964], [96.37926, 42.72055], [96.35658, 42.90363], [95.89543, 43.2528], [95.52594, 43.99353], [95.32891, 44.02407], [95.39772, 44.2805], [95.01191, 44.25274], [94.71959, 44.35284], [94.10003, 44.71016], [93.51161, 44.95964], [91.64048, 45.07408], [90.89169, 45.19667], [90.65114, 45.49314], [90.70907, 45.73437], [91.03026, 46.04194], [90.99672, 46.14207], [90.89639, 46.30711], [91.07696, 46.57315], [91.0147, 46.58171], [91.03649, 46.72916], [90.84035, 46.99525], [90.76108, 46.99399], [90.48542, 47.30438], [90.48854, 47.41826], [90.33598, 47.68303], [90.10871, 47.7375], [90.06512, 47.88177], [89.76624, 47.82745], [89.55453, 48.0423], [89.0711, 47.98528], [88.93186, 48.10263], [88.8011, 48.11302], [88.58316, 48.21893], [88.58939, 48.34531], [87.96361, 48.58478], [88.0788, 48.71436], [87.73822, 48.89582], [87.88171, 48.95853], [87.81333, 49.17354], [87.48983, 49.13794], [87.478, 49.07403], [87.28386, 49.11626], [86.87238, 49.12432], [86.73568, 48.99918], [86.75343, 48.70331], [86.38069, 48.46064], [85.73581, 48.3939], [85.5169, 48.05493], [85.61067, 47.49753], [85.69696, 47.2898], [85.54294, 47.06171], [85.22443, 47.04816], [84.93995, 46.87399], [84.73077, 47.01394], [83.92184, 46.98912], [83.04622, 47.19053], [82.21792, 45.56619], [82.58474, 45.40027], [82.51374, 45.1755], [81.73278, 45.3504], [80.11169, 45.03352], [79.8987, 44.89957], [80.38384, 44.63073], [80.40229, 44.23319], [80.40031, 44.10986], [80.75156, 43.44948], [80.69718, 43.32589], [80.77771, 43.30065], [80.78817, 43.14235], [80.62913, 43.141], [80.3735, 43.01557], [80.58999, 42.9011], [80.38169, 42.83142], [80.26886, 42.8366], [80.16892, 42.61137], [80.26841, 42.23797], [80.17807, 42.21166], [80.17842, 42.03211], [79.92977, 42.04113], [78.3732, 41.39603], [78.15757, 41.38565], [78.12873, 41.23091], [77.81287, 41.14307], [77.76206, 41.01574], [77.52723, 41.00227], [77.3693, 41.0375], [77.28004, 41.0033], [76.99302, 41.0696], [76.75681, 40.95354], [76.5261, 40.46114], [76.33659, 40.3482], [75.96168, 40.38064], [75.91361, 40.2948], [75.69663, 40.28642], [75.5854, 40.66874], [75.22834, 40.45382], [75.08243, 40.43945], [74.82013, 40.52197], [74.78168, 40.44886], [74.85996, 40.32857], [74.69875, 40.34668], [74.35063, 40.09742], [74.25533, 40.13191], [73.97049, 40.04378], [73.83006, 39.76136], [73.9051, 39.75073], [73.92354, 39.69565], [73.94683, 39.60733], [73.87018, 39.47879], [73.59831, 39.46425], [73.59241, 39.40843], [73.5004, 39.38402], [73.55396, 39.3543], [73.54572, 39.27567], [73.60638, 39.24534], [73.75823, 39.023], [73.81728, 39.04007], [73.82964, 38.91517], [73.7445, 38.93867], [73.7033, 38.84782], [73.80656, 38.66449], [73.79806, 38.61106], [73.97933, 38.52945], [74.17022, 38.65504], [74.51217, 38.47034], [74.69619, 38.42947], [74.69894, 38.22155], [74.80331, 38.19889], [74.82665, 38.07359], [74.9063, 38.03033], [74.92416, 37.83428], [75.00935, 37.77486], [74.8912, 37.67576], [74.94338, 37.55501], [75.06011, 37.52779], [75.15899, 37.41443], [75.09719, 37.37297], [75.12328, 37.31839], [74.88887, 37.23275], [74.80605, 37.21565], [74.49981, 37.24518], [74.56453, 37.03023], [75.13839, 37.02622], [75.40481, 36.95382], [75.45562, 36.71971], [75.72737, 36.7529], [75.92391, 36.56986], [76.0324, 36.41198], [76.00906, 36.17511], [75.93028, 36.13136], [76.15325, 35.9264], [76.14913, 35.82848], [76.33453, 35.84296], [76.50961, 35.8908], [76.77323, 35.66062], [76.84539, 35.67356], [76.96624, 35.5932], [77.44277, 35.46132], [77.70232, 35.46244], [77.80532, 35.52058], [78.11664, 35.48022], [78.03466, 35.3785], [78.00033, 35.23954], [78.22692, 34.88771], [78.18435, 34.7998], [78.27781, 34.61484], [78.54964, 34.57283], [78.56475, 34.50835], [78.74465, 34.45174], [79.05364, 34.32482], [78.99802, 34.3027], [78.91769, 34.15452], [78.66225, 34.08858], [78.65657, 34.03195], [78.73367, 34.01121], [78.77349, 33.73871], [78.67599, 33.66445], [78.73636, 33.56521], [79.15252, 33.17156], [79.14016, 33.02545], [79.46562, 32.69668], [79.26768, 32.53277], [79.13174, 32.47766], [79.0979, 32.38051], [78.99322, 32.37948], [78.96713, 32.33655], [78.7831, 32.46873], [78.73916, 32.69438], [78.38897, 32.53938], [78.4645, 32.45367], [78.49609, 32.2762], [78.68754, 32.10256], [78.74404, 32.00384], [78.78036, 31.99478], [78.69933, 31.78723], [78.84516, 31.60631], [78.71032, 31.50197], [78.77898, 31.31209], [78.89344, 31.30481], [79.01931, 31.42817], [79.14016, 31.43403], [79.30694, 31.17357], [79.59884, 30.93943], [79.93255, 30.88288], [80.20721, 30.58541], [80.54504, 30.44936], [80.83343, 30.32023], [81.03953, 30.20059], [81.12842, 30.01395], [81.24362, 30.0126], [81.29032, 30.08806], [81.2623, 30.14596], [81.33355, 30.15303], [81.39928, 30.21862], [81.41018, 30.42153], [81.5459, 30.37688], [81.62033, 30.44703], [81.99082, 30.33423], [82.10135, 30.35439], [82.10757, 30.23745], [82.19475, 30.16884], [82.16984, 30.0692], [82.38622, 30.02608], [82.5341, 29.9735], [82.73024, 29.81695], [83.07116, 29.61957], [83.28131, 29.56813], [83.44787, 29.30513], [83.63156, 29.16249], [83.82303, 29.30513], [83.97559, 29.33091], [84.18107, 29.23451], [84.24801, 29.02783], [84.2231, 28.89571], [84.47528, 28.74023], [84.62317, 28.73887], [84.85511, 28.58041], [85.06059, 28.68562], [85.19135, 28.62825], [85.18668, 28.54076], [85.10729, 28.34092], [85.38127, 28.28336], [85.4233, 28.32996], [85.59765, 28.30529], [85.60854, 28.25045], [85.69105, 28.38475], [85.71907, 28.38064], [85.74864, 28.23126], [85.84672, 28.18187], [85.90743, 28.05144], [85.97813, 27.99023], [85.94946, 27.9401], [86.06309, 27.90021], [86.12069, 27.93047], [86.08333, 28.02121], [86.088, 28.09264], [86.18607, 28.17364], [86.22966, 27.9786], [86.42736, 27.91122], [86.51609, 27.96623], [86.56265, 28.09569], [86.74181, 28.10638], [86.75582, 28.04182], [87.03757, 27.94835], [87.11696, 27.84104], [87.56996, 27.84517], [87.72718, 27.80938], [87.82681, 27.95248], [88.13378, 27.88015], [88.1278, 27.95417], [88.25332, 27.9478], [88.54858, 28.06057], [88.63235, 28.12356], [88.83559, 28.01936], [88.88091, 27.85192], [88.77517, 27.45415], [88.82981, 27.38814], [88.91901, 27.32483], [88.93678, 27.33777], [88.96947, 27.30319], [89.00216, 27.32532], [88.95355, 27.4106], [88.97213, 27.51671], [89.0582, 27.60985], [89.12825, 27.62502], [89.59525, 28.16433], [89.79762, 28.23979], [90.13387, 28.19178], [90.58842, 28.02838], [90.69894, 28.07784], [91.20019, 27.98715], [91.25779, 28.07509], [91.46327, 28.0064], [91.48973, 27.93903], [91.5629, 27.84823], [91.6469, 27.76358], [91.84722, 27.76325], [91.87057, 27.7195], [92.27432, 27.89077], [92.32101, 27.79363], [92.42538, 27.80092], [92.7275, 27.98662], [92.73025, 28.05814], [92.65472, 28.07632], [92.67486, 28.15018], [92.93075, 28.25671], [93.14635, 28.37035], [93.18069, 28.50319], [93.44621, 28.67189], [93.72797, 28.68821], [94.35897, 29.01965], [94.2752, 29.11687], [94.69318, 29.31739], [94.81353, 29.17804], [95.0978, 29.14446], [95.11291, 29.09527], [95.2214, 29.10727], [95.26122, 29.07727], [95.3038, 29.13847], [95.41091, 29.13007], [95.50842, 29.13487], [95.72086, 29.20797], [95.75149, 29.32063], [95.84899, 29.31464], [96.05361, 29.38167], [96.31316, 29.18643], [96.18682, 29.11087], [96.20467, 29.02325], [96.3626, 29.10607], [96.61391, 28.72742], [96.40929, 28.51526], [96.48895, 28.42955], [96.6455, 28.61657], [96.85561, 28.4875], [96.88445, 28.39452], [96.98882, 28.32564], [97.1289, 28.3619], [97.34547, 28.21385], [97.41729, 28.29783], [97.47085, 28.2688], [97.50518, 28.49716], [97.56835, 28.55628], [97.70705, 28.5056], [97.79632, 28.33168], [97.90069, 28.3776], [98.15337, 28.12114], [98.13964, 27.9478], [98.32641, 27.51385], [98.42529, 27.55404], [98.43353, 27.67086], [98.69582, 27.56499], [98.7333, 26.85615], [98.77547, 26.61994], [98.72741, 26.36183], [98.67797, 26.24487], [98.7329, 26.17218], [98.66884, 26.09165], [98.63128, 26.15492], [98.57085, 26.11547], [98.60763, 26.01512], [98.70818, 25.86241], [98.63128, 25.79937], [98.54064, 25.85129], [98.40606, 25.61129], [98.31268, 25.55307], [98.25774, 25.6051], [98.16848, 25.62739], [98.18084, 25.56298], [98.12591, 25.50722], [98.14925, 25.41547], [97.92541, 25.20815], [97.83614, 25.2715], [97.77023, 25.11492], [97.72216, 25.08508], [97.72903, 24.91332], [97.79949, 24.85655], [97.76481, 24.8289], [97.73127, 24.83015], [97.70181, 24.84557], [97.64354, 24.79171], [97.56648, 24.76475], [97.56383, 24.75535], [97.5542, 24.74943], [97.54675, 24.74202], [97.56525, 24.72838], [97.56286, 24.54535], [97.52757, 24.43748], [97.60029, 24.4401], [97.66998, 24.45288], [97.7098, 24.35658], [97.65624, 24.33781], [97.66723, 24.30027], [97.71941, 24.29652], [97.76799, 24.26365], [97.72998, 24.2302], [97.72799, 24.18883], [97.75305, 24.16902], [97.72903, 24.12606], [97.62363, 24.00506], [97.5247, 23.94032], [97.64667, 23.84574], [97.72302, 23.89288], [97.79456, 23.94836], [97.79416, 23.95663], [97.84328, 23.97603], [97.86545, 23.97723], [97.88811, 23.97446], [97.8955, 23.97758], [97.89676, 23.97931], [97.89683, 23.98389], [97.88814, 23.98605], [97.88414, 23.99405], [97.88616, 24.00463], [97.90998, 24.02094], [97.93951, 24.01953], [97.98691, 24.03897], [97.99583, 24.04932], [98.04709, 24.07616], [98.05302, 24.07408], [98.05671, 24.07961], [98.0607, 24.07812], [98.06703, 24.08028], [98.07806, 24.07988], [98.20666, 24.11406], [98.54476, 24.13119], [98.59256, 24.08371], [98.85319, 24.13042], [98.87998, 24.15624], [98.89632, 24.10612], [98.67797, 23.9644], [98.68209, 23.80492], [98.79607, 23.77947], [98.82933, 23.72921], [98.81775, 23.694], [98.88396, 23.59555], [98.80294, 23.5345], [98.82877, 23.47908], [98.87683, 23.48995], [98.92104, 23.36946], [98.87573, 23.33038], [98.93958, 23.31414], [98.92515, 23.29535], [98.88597, 23.18656], [99.05975, 23.16382], [99.04601, 23.12215], [99.25741, 23.09025], [99.34127, 23.13099], [99.52214, 23.08218], [99.54218, 22.90014], [99.43537, 22.94086], [99.45654, 22.85726], [99.31243, 22.73893], [99.38247, 22.57544], [99.37972, 22.50188], [99.28771, 22.4105], [99.17318, 22.18025], [99.19176, 22.16983], [99.1552, 22.15874], [99.33166, 22.09656], [99.47585, 22.13345], [99.85351, 22.04183], [99.96612, 22.05965], [99.99084, 21.97053], [99.94003, 21.82782], [99.98654, 21.71064], [100.04956, 21.66843], [100.12679, 21.70539], [100.17486, 21.65306], [100.10757, 21.59945], [100.12542, 21.50365], [100.1625, 21.48704], [100.18447, 21.51898], [100.25863, 21.47043], [100.35201, 21.53176], [100.42892, 21.54325], [100.4811, 21.46148], [100.57861, 21.45637], [100.72143, 21.51898], [100.87265, 21.67396], [101.11744, 21.77659], [101.15156, 21.56129], [101.2124, 21.56422], [101.19349, 21.41959], [101.26912, 21.36482], [101.2229, 21.23271], [101.29326, 21.17254], [101.54563, 21.25668], [101.6068, 21.23329], [101.59491, 21.18621], [101.60886, 21.17947], [101.66977, 21.20004], [101.70548, 21.14911], [101.7622, 21.14813], [101.79266, 21.19025], [101.76745, 21.21571], [101.83887, 21.20983], [101.84412, 21.25291], [101.74014, 21.30967], [101.74224, 21.48276], [101.7727, 21.51794], [101.7475, 21.5873], [101.80001, 21.57461], [101.83257, 21.61562], [101.74555, 21.72852], [101.7791, 21.83019], [101.62566, 21.96574], [101.57525, 22.13026], [101.60675, 22.13513], [101.53638, 22.24794], [101.56789, 22.28876], [101.61306, 22.27515], [101.68973, 22.46843], [101.7685, 22.50337], [101.86828, 22.38397], [101.90714, 22.38688], [101.91344, 22.44417], [101.98487, 22.42766], [102.03633, 22.46164], [102.1245, 22.43372], [102.14099, 22.40092], [102.16621, 22.43336], [102.26428, 22.41321], [102.25339, 22.4607], [102.41061, 22.64184], [102.38415, 22.67919], [102.42618, 22.69212], [102.46665, 22.77108], [102.51802, 22.77969], [102.57095, 22.7036], [102.60675, 22.73376], [102.8636, 22.60735], [102.9321, 22.48659], [103.0722, 22.44775], [103.07843, 22.50097], [103.17961, 22.55705], [103.15782, 22.59873], [103.18895, 22.64471], [103.28079, 22.68063], [103.32282, 22.8127], [103.43179, 22.75816], [103.43646, 22.70648], [103.52675, 22.59155], [103.57812, 22.65764], [103.56255, 22.69499], [103.64506, 22.79979], [103.87904, 22.56683], [103.93286, 22.52703], [103.94513, 22.52553], [103.95191, 22.5134], [103.96352, 22.50584], [103.96783, 22.51173], [103.97384, 22.50634], [103.99247, 22.51958], [104.01088, 22.51823], [104.03734, 22.72945], [104.11384, 22.80363], [104.27084, 22.8457], [104.25683, 22.76534], [104.35593, 22.69353], [104.47225, 22.75813], [104.58122, 22.85571], [104.60457, 22.81841], [104.65283, 22.83419], [104.72755, 22.81984], [104.77114, 22.90017], [104.84942, 22.93631], [104.86765, 22.95178], [104.8334, 23.01484], [104.79478, 23.12934], [104.87382, 23.12854], [104.87992, 23.17141], [104.91435, 23.18666], [104.9486, 23.17235], [104.96532, 23.20463], [104.98712, 23.19176], [105.07002, 23.26248], [105.11672, 23.25247], [105.17276, 23.28679], [105.22569, 23.27249], [105.32376, 23.39684], [105.40782, 23.28107], [105.42805, 23.30824], [105.49966, 23.20669], [105.56037, 23.16806], [105.57594, 23.075], [105.72382, 23.06641], [105.8726, 22.92756], [105.90119, 22.94168], [105.99568, 22.94178], [106.00179, 22.99049], [106.19705, 22.98475], [106.27022, 22.87722], [106.34961, 22.86718], [106.49749, 22.91164], [106.51306, 22.94891], [106.55976, 22.92311], [106.60179, 22.92884], [106.6516, 22.86862], [106.6734, 22.89587], [106.71387, 22.88296], [106.71128, 22.85982], [106.78422, 22.81532], [106.81271, 22.8226], [106.83685, 22.8098], [106.82404, 22.7881], [106.76293, 22.73491], [106.72321, 22.63606], [106.71698, 22.58432], [106.65316, 22.5757], [106.61269, 22.60301], [106.58395, 22.474], [106.55665, 22.46498], [106.57221, 22.37], [106.55976, 22.34841], [106.6516, 22.33977], [106.69986, 22.22309], [106.67495, 22.1885], [106.6983, 22.15102], [106.70142, 22.02409], [106.68274, 21.99811], [106.69276, 21.96013], [106.72551, 21.97923], [106.74345, 22.00965], [106.81038, 21.97934], [106.9178, 21.97357], [106.92714, 21.93459], [106.97228, 21.92592], [106.99252, 21.95191], [107.05634, 21.92303], [107.06101, 21.88982], [107.00964, 21.85948], [107.02615, 21.81981], [107.10771, 21.79879], [107.20734, 21.71493], [107.24625, 21.7077], [107.29296, 21.74674], [107.35834, 21.6672], [107.35989, 21.60063], [107.38636, 21.59774], [107.41593, 21.64839], [107.47197, 21.6672], [107.49532, 21.62958], [107.49065, 21.59774], [107.54047, 21.5934], [107.56537, 21.61945], [107.66967, 21.60787], [107.80355, 21.66141], [107.86114, 21.65128], [107.90006, 21.5905], [107.92652, 21.58906], [107.95232, 21.5388], [107.96774, 21.53601], [107.97074, 21.54072], [107.97383, 21.53961], [107.97932, 21.54503], [108.02926, 21.54997], [108.0569, 21.53604], [108.10003, 21.47338], [108.00365, 17.98159], [111.60491, 13.57105], [118.41371, 24.06775], [118.11703, 24.39734], [118.28244, 24.51231], [118.35291, 24.51645], [118.42453, 24.54644], [118.6333, 24.46259], [119.42295, 25.0886], [119.98511, 25.37624], [119.78816, 26.2348], [120.0693, 26.3959], [120.5128, 26.536], [121.03532, 26.8787], [123.5458, 31.01942], [122.29378, 31.76513], [122.80525, 33.30571], [123.85601, 37.49093], [123.90497, 38.79949], [124.17532, 39.8232], [124.23201, 39.9248], [124.35029, 39.95639], [124.37089, 40.03004], [124.3322, 40.05573], [124.38556, 40.11047], [124.40719, 40.13655], [124.86913, 40.45387], [125.71172, 40.85223], [125.76869, 40.87908], [126.00335, 40.92835], [126.242, 41.15454], [126.53189, 41.35206], [126.60631, 41.65565], [126.90729, 41.79955], [127.17841, 41.59714], [127.29712, 41.49473], [127.92943, 41.44291], [128.02633, 41.42103], [128.03311, 41.39232], [128.12967, 41.37931], [128.18546, 41.41279], [128.20061, 41.40895], [128.30716, 41.60322], [128.15119, 41.74568], [128.04487, 42.01769], [128.94007, 42.03537], [128.96068, 42.06657], [129.15178, 42.17224], [129.22285, 42.26491], [129.22423, 42.3553], [129.28541, 42.41574], [129.42882, 42.44702], [129.54701, 42.37254], [129.60482, 42.44461], [129.72541, 42.43739], [129.75294, 42.59409], [129.77183, 42.69435], [129.7835, 42.76521], [129.80719, 42.79218], [129.83277, 42.86746], [129.85261, 42.96494], [129.8865, 43.00395], [129.95082, 43.01051], [129.96409, 42.97306], [130.12957, 42.98361], [130.09764, 42.91425], [130.26095, 42.9027], [130.23068, 42.80125], [130.2385, 42.71127], [130.41826, 42.6011], [130.44361, 42.54849], [130.50123, 42.61636], [130.55143, 42.52158], [130.62107, 42.58413], [130.56576, 42.68925], [130.40213, 42.70788], [130.44361, 42.76205], [130.66524, 42.84753], [131.02438, 42.86518], [131.02668, 42.91246], [131.135, 42.94114], [131.10274, 43.04734], [131.20414, 43.13654], [131.19031, 43.21385], [131.30324, 43.39498], [131.29402, 43.46695], [131.19492, 43.53047], [131.21105, 43.82383], [131.26176, 43.94011], [131.23583, 43.96085], [131.25484, 44.03131], [131.30365, 44.04262], [131.1108, 44.70266], [130.95639, 44.85154], [131.48415, 44.99513], [131.68466, 45.12374], [131.66852, 45.2196], [131.76532, 45.22609], [131.86903, 45.33636], [131.99417, 45.2567], [132.83978, 45.05916], [132.96373, 45.0212], [133.12293, 45.1332], [133.09279, 45.25693], [133.19419, 45.51913], [133.41083, 45.57723], [133.48457, 45.86203], [133.60442, 45.90053], [133.67569, 45.9759], [133.72695, 46.05576], [133.68047, 46.14697], [133.88097, 46.25066], [133.91496, 46.4274], [133.84104, 46.46681], [134.03538, 46.75668], [134.20016, 47.33458], [134.50898, 47.4812], [134.7671, 47.72051], [134.55508, 47.98651], [134.67098, 48.1564], [134.75328, 48.36763], [134.49516, 48.42884], [132.66989, 47.96491], [132.57309, 47.71741], [131.90448, 47.68011], [131.2635, 47.73325], [131.09871, 47.6852], [130.95985, 47.6957], [130.90915, 47.90623], [130.65103, 48.10052], [130.84462, 48.30942], [130.52147, 48.61745], [130.66946, 48.88251], [130.43232, 48.90844], [130.2355, 48.86741], [129.85416, 49.11067], [129.67598, 49.29596], [129.50685, 49.42398], [129.40398, 49.44194], [129.35317, 49.3481], [129.23232, 49.40353], [129.11153, 49.36813], [128.72896, 49.58676], [127.83476, 49.5748], [127.53516, 49.84306], [127.49299, 50.01251], [127.60515, 50.23503], [127.37384, 50.28393], [127.36009, 50.43787], [127.28765, 50.46585], [127.36335, 50.58306], [127.28165, 50.72075], [127.14586, 50.91152], [126.93135, 51.0841], [126.90369, 51.3238], [126.68349, 51.70607], [126.44606, 51.98254], [126.558, 52.13738], [125.6131, 53.07229]], [[113.56865, 22.20973], [113.57123, 22.20416], [113.60504, 22.20464], [113.63011, 22.10782], [113.57191, 22.07696], [113.54839, 22.10909], [113.54942, 22.14519], [113.54093, 22.15497], [113.52659, 22.18271], [113.53552, 22.20607], [113.53301, 22.21235], [113.53591, 22.21369], [113.54093, 22.21314], [113.54333, 22.21688], [113.5508, 22.21672], [113.56865, 22.20973]], [[114.50148, 22.15017], [113.92195, 22.13873], [113.83338, 22.1826], [113.81621, 22.2163], [113.86771, 22.42972], [114.03113, 22.5065], [114.05438, 22.5026], [114.05729, 22.51104], [114.06272, 22.51617], [114.07267, 22.51855], [114.07817, 22.52997], [114.08606, 22.53276], [114.09048, 22.53716], [114.09692, 22.53435], [114.1034, 22.5352], [114.11181, 22.52878], [114.11656, 22.53415], [114.12665, 22.54003], [114.13823, 22.54319], [114.1482, 22.54091], [114.15123, 22.55163], [114.1597, 22.56041], [114.17247, 22.55944], [114.18338, 22.55444], [114.20655, 22.55706], [114.22185, 22.55343], [114.22888, 22.5436], [114.25154, 22.55977], [114.44998, 22.55977], [114.50148, 22.15017]]]] } },
    { type: "Feature", properties: { wikidata: "Q22890", nameEn: "Ireland", level: "sharedLandform" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q23666", nameEn: "Great Britain", country: "GB", level: "sharedLandform" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q23681", nameEn: "Northern Cyprus", groups: ["Q644636", "145", "142"], driveSide: "left", callingCodes: ["90 392"] }, geometry: { type: "MultiPolygon", coordinates: [[[[33.67678, 35.03866], [33.67742, 35.05963], [33.68474, 35.06602], [33.69095, 35.06237], [33.70861, 35.07644], [33.7161, 35.07279], [33.70209, 35.04882], [33.71482, 35.03722], [33.73824, 35.05321], [33.76106, 35.04253], [33.78581, 35.05104], [33.82067, 35.07826], [33.84168, 35.06823], [33.8541, 35.07201], [33.87479, 35.08881], [33.87097, 35.09389], [33.87622, 35.10457], [33.87224, 35.12293], [33.88561, 35.12449], [33.88943, 35.12007], [33.88737, 35.11408], [33.89853, 35.11377], [33.91789, 35.08688], [33.91299, 35.07579], [33.90247, 35.07686], [33.89485, 35.06873], [33.88367, 35.07877], [33.85261, 35.0574], [33.8355, 35.05777], [33.82051, 35.0667], [33.8012, 35.04786], [33.81524, 35.04192], [33.83055, 35.02865], [33.82875, 35.01685], [33.84045, 35.00616], [33.85216, 35.00579], [33.85891, 35.001], [33.85621, 34.98956], [33.83505, 34.98108], [33.84811, 34.97075], [33.86432, 34.97592], [33.90075, 34.96623], [33.98684, 34.76642], [35.48515, 34.70851], [35.51152, 36.10954], [32.82353, 35.70297], [32.46489, 35.48584], [32.60361, 35.16647], [32.64864, 35.19967], [32.70947, 35.18328], [32.70779, 35.14127], [32.85733, 35.07742], [32.86406, 35.1043], [32.94471, 35.09422], [33.01192, 35.15639], [33.08249, 35.17319], [33.11105, 35.15639], [33.15138, 35.19504], [33.27068, 35.16815], [33.3072, 35.16816], [33.31955, 35.18096], [33.35056, 35.18328], [33.34964, 35.17803], [33.35596, 35.17942], [33.35612, 35.17402], [33.36569, 35.17479], [33.3717, 35.1788], [33.37248, 35.18698], [33.38575, 35.2018], [33.4076, 35.20062], [33.41675, 35.16325], [33.46813, 35.10564], [33.48136, 35.0636], [33.47825, 35.04103], [33.45178, 35.02078], [33.45256, 35.00288], [33.47666, 35.00701], [33.48915, 35.06594], [33.53975, 35.08151], [33.57478, 35.06049], [33.567, 35.04803], [33.59658, 35.03635], [33.61215, 35.0527], [33.63765, 35.03869], [33.67678, 35.03866]]]] } },
    { type: "Feature", properties: { wikidata: "Q25231", nameEn: "Svalbard", aliases: ["NO-21"], country: "NO", groups: ["SJ", "154", "150", "UN"], level: "subterritory", callingCodes: ["47 79"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-7.49892, 77.24208], [32.07813, 72.01005], [36.85549, 84.09565], [-7.49892, 77.24208]]]] } },
    { type: "Feature", properties: { wikidata: "Q25263", nameEn: "Azores", aliases: ["PT-20"], country: "PT", groups: ["Q3320166", "Q2914565", "Q105472", "EU", "039", "150", "UN"], callingCodes: ["351"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-23.12984, 40.26428], [-36.43765, 41.39418], [-22.54767, 33.34416], [-23.12984, 40.26428]]]] } },
    { type: "Feature", properties: { wikidata: "Q25359", nameEn: "Navassa Island", aliases: ["UM-76"], country: "US", groups: ["UM", "Q1352230", "029", "003", "419", "019", "UN"], level: "subterritory", roadSpeedUnit: "mph", roadHeightUnit: "ft" }, geometry: { type: "MultiPolygon", coordinates: [[[[-74.7289, 18.71009], [-75.71816, 18.46438], [-74.76465, 18.06252], [-74.7289, 18.71009]]]] } },
    { type: "Feature", properties: { wikidata: "Q25396", nameEn: "Bonaire", aliases: ["BQ-BO", "NL-BQ1"], country: "NL", groups: ["Q1451600", "BQ", "029", "003", "419", "019", "UN"], level: "subterritory", callingCodes: ["599 7"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-67.89186, 12.4116], [-68.90012, 12.62309], [-68.33524, 11.78151], [-68.01417, 11.77722], [-67.89186, 12.4116]]]] } },
    { type: "Feature", properties: { wikidata: "Q25528", nameEn: "Saba", aliases: ["BQ-SA", "NL-BQ2"], country: "NL", groups: ["Q1451600", "BQ", "029", "003", "419", "019", "UN"], level: "subterritory", callingCodes: ["599 4"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-63.07669, 17.79659], [-63.81314, 17.95045], [-63.22932, 17.32592], [-63.07669, 17.79659]]]] } },
    { type: "Feature", properties: { wikidata: "Q26180", nameEn: "Sint Eustatius", aliases: ["BQ-SE", "NL-BQ3"], country: "NL", groups: ["Q1451600", "BQ", "029", "003", "419", "019", "UN"], level: "subterritory", callingCodes: ["599 3"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-63.07669, 17.79659], [-63.34999, 16.94218], [-62.76692, 17.64353], [-63.07669, 17.79659]]]] } },
    { type: "Feature", properties: { wikidata: "Q26253", nameEn: "Madeira", aliases: ["PT-30"], country: "PT", groups: ["Q3320166", "Q2914565", "Q105472", "EU", "039", "150", "UN"], callingCodes: ["351"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-19.30302, 33.65304], [-16.04789, 29.65076], [-11.68307, 33.12333], [-19.30302, 33.65304]]]] } },
    { type: "Feature", properties: { wikidata: "Q26927", nameEn: "Lakshadweep", aliases: ["IN-LD"], country: "IN", groups: ["034", "142", "UN"], driveSide: "left", callingCodes: ["91"] }, geometry: { type: "MultiPolygon", coordinates: [[[[67.64074, 11.57295], [76.59015, 5.591], [72.67494, 13.58102], [67.64074, 11.57295]]]] } },
    { type: "Feature", properties: { wikidata: "Q27329", nameEn: "Asian Russia", country: "RU", groups: ["142", "UN"], callingCodes: ["7"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-179.99933, 64.74703], [-172.76104, 63.77445], [-169.03888, 65.48473], [-168.95635, 65.98512], [-168.25765, 71.99091], [-179.9843, 71.90735], [-179.99933, 64.74703]]], [[[59.99809, 51.98263], [60.19925, 51.99173], [60.48915, 52.15175], [60.72581, 52.15538], [60.78201, 52.22067], [61.05417, 52.35096], [60.98021, 52.50068], [60.84709, 52.52228], [60.84118, 52.63912], [60.71693, 52.66245], [60.71989, 52.75923], [61.05842, 52.92217], [61.23462, 53.03227], [62.0422, 52.96105], [62.12799, 52.99133], [62.14574, 53.09626], [61.19024, 53.30536], [61.14291, 53.41481], [61.29082, 53.50992], [61.37957, 53.45887], [61.57185, 53.50112], [61.55706, 53.57144], [60.90626, 53.62937], [61.22574, 53.80268], [61.14283, 53.90063], [60.99796, 53.93699], [61.26863, 53.92797], [61.3706, 54.08464], [61.47603, 54.08048], [61.56941, 53.95703], [61.65318, 54.02445], [62.03913, 53.94768], [62.00966, 54.04134], [62.38535, 54.03961], [62.45931, 53.90737], [62.56876, 53.94047], [62.58651, 54.05871], [63.80604, 54.27079], [63.91224, 54.20013], [64.02715, 54.22679], [63.97686, 54.29763], [64.97216, 54.4212], [65.11033, 54.33028], [65.24663, 54.35721], [65.20174, 54.55216], [68.21308, 54.98645], [68.26661, 55.09226], [68.19206, 55.18823], [68.90865, 55.38148], [69.34224, 55.36344], [69.74917, 55.35545], [70.19179, 55.1476], [70.76493, 55.3027], [70.96009, 55.10558], [71.08288, 54.71253], [71.24185, 54.64965], [71.08706, 54.33376], [71.10379, 54.13326], [71.96141, 54.17736], [72.17477, 54.36303], [72.43415, 53.92685], [72.71026, 54.1161], [73.37963, 53.96132], [73.74778, 54.07194], [73.68921, 53.86522], [73.25412, 53.61532], [73.39218, 53.44623], [75.07405, 53.80831], [75.43398, 53.98652], [75.3668, 54.07439], [76.91052, 54.4677], [76.82266, 54.1798], [76.44076, 54.16017], [76.54243, 53.99329], [77.90383, 53.29807], [79.11255, 52.01171], [80.08138, 50.77658], [80.4127, 50.95581], [80.44819, 51.20855], [80.80318, 51.28262], [81.16999, 51.15662], [81.06091, 50.94833], [81.41248, 50.97524], [81.46581, 50.77658], [81.94999, 50.79307], [82.55443, 50.75412], [83.14607, 51.00796], [83.8442, 50.87375], [84.29385, 50.27257], [84.99198, 50.06793], [85.24047, 49.60239], [86.18709, 49.50259], [86.63674, 49.80136], [86.79056, 49.74787], [86.61307, 49.60239], [86.82606, 49.51796], [87.03071, 49.25142], [87.31465, 49.23603], [87.28386, 49.11626], [87.478, 49.07403], [87.48983, 49.13794], [87.81333, 49.17354], [87.98977, 49.18147], [88.15543, 49.30314], [88.17223, 49.46934], [88.42449, 49.48821], [88.82499, 49.44808], [89.70687, 49.72535], [89.59711, 49.90851], [91.86048, 50.73734], [92.07173, 50.69585], [92.44714, 50.78762], [93.01109, 50.79001], [92.99595, 50.63183], [94.30823, 50.57498], [94.39258, 50.22193], [94.49477, 50.17832], [94.6121, 50.04239], [94.97166, 50.04725], [95.02465, 49.96941], [95.74757, 49.97915], [95.80056, 50.04239], [96.97388, 49.88413], [97.24639, 49.74737], [97.56811, 49.84265], [97.56432, 49.92801], [97.76871, 49.99861], [97.85197, 49.91339], [98.29481, 50.33561], [98.31373, 50.4996], [98.06393, 50.61262], [97.9693, 50.78044], [98.01472, 50.86652], [97.83305, 51.00248], [98.05257, 51.46696], [98.22053, 51.46579], [98.33222, 51.71832], [98.74142, 51.8637], [98.87768, 52.14563], [99.27888, 51.96876], [99.75578, 51.90108], [99.89203, 51.74903], [100.61116, 51.73028], [101.39085, 51.45753], [101.5044, 51.50467], [102.14032, 51.35566], [102.32194, 50.67982], [102.71178, 50.38873], [103.70343, 50.13952], [105.32528, 50.4648], [106.05562, 50.40582], [106.07865, 50.33474], [106.47156, 50.31909], [106.49628, 50.32436], [106.51122, 50.34408], [106.58373, 50.34044], [106.80326, 50.30177], [107.00007, 50.1977], [107.1174, 50.04239], [107.36407, 49.97612], [107.96116, 49.93191], [107.95387, 49.66659], [108.27937, 49.53167], [108.53969, 49.32325], [109.18017, 49.34709], [109.51325, 49.22859], [110.24373, 49.16676], [110.39891, 49.25083], [110.64493, 49.1816], [113.02647, 49.60772], [113.20216, 49.83356], [114.325, 50.28098], [114.9703, 50.19254], [115.26068, 49.97367], [115.73602, 49.87688], [116.22402, 50.04477], [116.62502, 49.92919], [116.71193, 49.83813], [117.27597, 49.62544], [117.48208, 49.62324], [117.82343, 49.52696], [118.61623, 49.93809], [119.11003, 50.00276], [119.27996, 50.13348], [119.38598, 50.35162], [119.13553, 50.37412], [120.10963, 51.671], [120.65907, 51.93544], [120.77337, 52.20805], [120.61346, 52.32447], [120.71673, 52.54099], [120.46454, 52.63811], [120.04049, 52.58773], [120.0451, 52.7359], [120.85633, 53.28499], [121.39213, 53.31888], [122.35063, 53.49565], [122.85966, 53.47395], [123.26989, 53.54843], [123.86158, 53.49391], [124.46078, 53.21881], [125.17522, 53.20225], [125.6131, 53.07229], [126.558, 52.13738], [126.44606, 51.98254], [126.68349, 51.70607], [126.90369, 51.3238], [126.93135, 51.0841], [127.14586, 50.91152], [127.28165, 50.72075], [127.36335, 50.58306], [127.28765, 50.46585], [127.36009, 50.43787], [127.37384, 50.28393], [127.60515, 50.23503], [127.49299, 50.01251], [127.53516, 49.84306], [127.83476, 49.5748], [128.72896, 49.58676], [129.11153, 49.36813], [129.23232, 49.40353], [129.35317, 49.3481], [129.40398, 49.44194], [129.50685, 49.42398], [129.67598, 49.29596], [129.85416, 49.11067], [130.2355, 48.86741], [130.43232, 48.90844], [130.66946, 48.88251], [130.52147, 48.61745], [130.84462, 48.30942], [130.65103, 48.10052], [130.90915, 47.90623], [130.95985, 47.6957], [131.09871, 47.6852], [131.2635, 47.73325], [131.90448, 47.68011], [132.57309, 47.71741], [132.66989, 47.96491], [134.49516, 48.42884], [134.75328, 48.36763], [134.67098, 48.1564], [134.55508, 47.98651], [134.7671, 47.72051], [134.50898, 47.4812], [134.20016, 47.33458], [134.03538, 46.75668], [133.84104, 46.46681], [133.91496, 46.4274], [133.88097, 46.25066], [133.68047, 46.14697], [133.72695, 46.05576], [133.67569, 45.9759], [133.60442, 45.90053], [133.48457, 45.86203], [133.41083, 45.57723], [133.19419, 45.51913], [133.09279, 45.25693], [133.12293, 45.1332], [132.96373, 45.0212], [132.83978, 45.05916], [131.99417, 45.2567], [131.86903, 45.33636], [131.76532, 45.22609], [131.66852, 45.2196], [131.68466, 45.12374], [131.48415, 44.99513], [130.95639, 44.85154], [131.1108, 44.70266], [131.30365, 44.04262], [131.25484, 44.03131], [131.23583, 43.96085], [131.26176, 43.94011], [131.21105, 43.82383], [131.19492, 43.53047], [131.29402, 43.46695], [131.30324, 43.39498], [131.19031, 43.21385], [131.20414, 43.13654], [131.10274, 43.04734], [131.135, 42.94114], [131.02668, 42.91246], [131.02438, 42.86518], [130.66524, 42.84753], [130.44361, 42.76205], [130.40213, 42.70788], [130.56576, 42.68925], [130.62107, 42.58413], [130.55143, 42.52158], [130.56835, 42.43281], [130.60805, 42.4317], [130.64181, 42.41422], [130.66367, 42.38024], [130.65022, 42.32281], [131.95041, 41.5445], [140.9182, 45.92937], [145.82343, 44.571], [145.23667, 43.76813], [153.94307, 38.42848], [180, 62.52334], [180, 71.53642], [155.31937, 81.93282], [76.13964, 83.37843], [64.18965, 69.94255], [66.1708, 67.61252], [61.98014, 65.72191], [60.74386, 64.95767], [59.63945, 64.78384], [59.80579, 64.13948], [59.24834, 63.01859], [59.61398, 62.44915], [59.36223, 61.3882], [59.50685, 60.91162], [58.3853, 59.487], [59.15636, 59.14682], [59.40376, 58.45822], [58.71104, 58.07475], [58.81412, 57.71602], [58.13789, 57.68097], [58.07604, 57.08308], [57.28024, 56.87898], [57.51527, 56.08729], [59.28419, 56.15739], [59.49035, 55.60486], [58.81825, 55.03378], [57.25137, 55.26262], [57.14829, 54.84204], [57.95234, 54.39672], [59.95217, 54.85853], [59.70487, 54.14846], [58.94336, 53.953], [58.79644, 52.43392], [59.22409, 52.28437], [59.25033, 52.46803], [60.17516, 52.39457], [60.17253, 52.25814], [59.91279, 52.06924], [59.99809, 51.98263]]]] } },
    { type: "Feature", properties: { wikidata: "Q34366", nameEn: "Tasmania", aliases: ["AU-TAS"], country: "AU", groups: ["053", "009", "UN"], driveSide: "left", callingCodes: ["61"] }, geometry: { type: "MultiPolygon", coordinates: [[[[123.64533, -39.13605], [159.69067, -56.28945], [159.74028, -39.1978], [123.64533, -39.13605]]]] } },
    { type: "Feature", properties: { wikidata: "Q34497", nameEn: "Saint Helena", aliases: ["SH-HL"], country: "GB", groups: ["SH", "BOTS", "011", "202", "002", "UN"], level: "subterritory", driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["290"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-8.3824, -13.9131], [-6.17428, -19.07236], [-3.29308, -15.22647], [-8.3824, -13.9131]]]] } },
    { type: "Feature", properties: { wikidata: "Q35657", nameEn: "US States", country: "US", level: "subcountryGroup" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q36117", nameEn: "Borneo", level: "sharedLandform" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q36678", nameEn: "West Bank", country: "PS", groups: ["145", "142"], callingCodes: ["970"] }, geometry: { type: "MultiPolygon", coordinates: [[[[35.47672, 31.49578], [35.55941, 31.76535], [35.52758, 31.9131], [35.54375, 31.96587], [35.52012, 32.04076], [35.57111, 32.21877], [35.55807, 32.38674], [35.42078, 32.41562], [35.41048, 32.43706], [35.41598, 32.45593], [35.42034, 32.46009], [35.40224, 32.50136], [35.35212, 32.52047], [35.30685, 32.51024], [35.29306, 32.50947], [35.25049, 32.52453], [35.2244, 32.55289], [35.15937, 32.50466], [35.10882, 32.4757], [35.10024, 32.47856], [35.09236, 32.47614], [35.08564, 32.46948], [35.07059, 32.4585], [35.05423, 32.41754], [35.05311, 32.4024], [35.0421, 32.38242], [35.05142, 32.3667], [35.04243, 32.35008], [35.01772, 32.33863], [35.01119, 32.28684], [35.02939, 32.2671], [35.01841, 32.23981], [34.98885, 32.20758], [34.95703, 32.19522], [34.96009, 32.17503], [34.99039, 32.14626], [34.98507, 32.12606], [34.99437, 32.10962], [34.9863, 32.09551], [35.00261, 32.027], [34.98682, 31.96935], [35.00124, 31.93264], [35.03489, 31.92448], [35.03978, 31.89276], [35.03489, 31.85919], [34.99712, 31.85569], [34.9724, 31.83352], [35.01978, 31.82944], [35.05617, 31.85685], [35.07677, 31.85627], [35.14174, 31.81325], [35.18603, 31.80901], [35.18169, 31.82542], [35.19461, 31.82687], [35.21469, 31.81835], [35.216, 31.83894], [35.21128, 31.863], [35.20381, 31.86716], [35.20673, 31.88151], [35.20791, 31.8821], [35.20945, 31.8815], [35.21016, 31.88237], [35.21276, 31.88153], [35.2136, 31.88241], [35.22014, 31.88264], [35.22294, 31.87889], [35.22567, 31.86745], [35.22817, 31.8638], [35.2249, 31.85433], [35.2304, 31.84222], [35.24816, 31.8458], [35.25753, 31.8387], [35.251, 31.83085], [35.26404, 31.82567], [35.25573, 31.81362], [35.26058, 31.79064], [35.25225, 31.7678], [35.26319, 31.74846], [35.25182, 31.73945], [35.24981, 31.72543], [35.2438, 31.7201], [35.24315, 31.71244], [35.23972, 31.70896], [35.22392, 31.71899], [35.21937, 31.71578], [35.20538, 31.72388], [35.18023, 31.72067], [35.16478, 31.73242], [35.15474, 31.73352], [35.15119, 31.73634], [35.13931, 31.73012], [35.12933, 31.7325], [35.11895, 31.71454], [35.10782, 31.71594], [35.08226, 31.69107], [35.00879, 31.65426], [34.95249, 31.59813], [34.9415, 31.55601], [34.94356, 31.50743], [34.93258, 31.47816], [34.89756, 31.43891], [34.87833, 31.39321], [34.88932, 31.37093], [34.92571, 31.34337], [35.02459, 31.35979], [35.13033, 31.3551], [35.22921, 31.37445], [35.39675, 31.49572], [35.47672, 31.49578]]]] } },
    { type: "Feature", properties: { wikidata: "Q37362", nameEn: "Akrotiri and Dhekelia", aliases: ["SBA"], country: "GB" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q38095", nameEn: "Gal\xE1pagos Islands", aliases: ["EC-W"], country: "EC", groups: ["005", "419", "019", "UN"], callingCodes: ["593"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-93.12365, 2.64343], [-92.46744, -2.52874], [-87.07749, -0.8849], [-93.12365, 2.64343]]]] } },
    { type: "Feature", properties: { wikidata: "Q39760", nameEn: "Gaza Strip", country: "PS", groups: ["145", "142"], callingCodes: ["970"] }, geometry: { type: "MultiPolygon", coordinates: [[[[34.052, 31.46619], [34.21853, 31.32363], [34.23572, 31.2966], [34.24012, 31.29591], [34.26742, 31.21998], [34.29417, 31.24194], [34.36523, 31.28963], [34.37381, 31.30598], [34.36505, 31.36404], [34.40077, 31.40926], [34.48892, 31.48365], [34.56797, 31.54197], [34.48681, 31.59711], [34.29262, 31.70393], [34.052, 31.46619]]]] } },
    { type: "Feature", properties: { wikidata: "Q40888", nameEn: "Andaman and Nicobar Islands", aliases: ["IN-AN"], country: "IN", groups: ["034", "142", "UN"], driveSide: "left", callingCodes: ["91"] }, geometry: { type: "MultiPolygon", coordinates: [[[[94.42132, 5.96581], [94.6371, 13.81803], [86.7822, 13.41052], [94.42132, 5.96581]]]] } },
    { type: "Feature", properties: { wikidata: "Q41684", nameEn: "Stewart Island", country: "NZ", groups: ["053", "009", "UN"], driveSide: "left", callingCodes: ["64"] }, geometry: { type: "MultiPolygon", coordinates: [[[[166.59185, -47.61313], [169.70504, -47.56021], [167.52103, -46.41337], [166.59185, -47.61313]]]] } },
    { type: "Feature", properties: { wikidata: "Q43296", nameEn: "Wake Island", aliases: ["WK", "WAK", "WKUM", "872", "UM-79"], country: "US", groups: ["UM", "Q1352230", "057", "009", "UN"], level: "subterritory", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["1"] }, geometry: { type: "MultiPolygon", coordinates: [[[[167.34779, 18.97692], [166.67967, 20.14834], [165.82549, 18.97692], [167.34779, 18.97692]]]] } },
    { type: "Feature", properties: { wikidata: "Q46275", nameEn: "New Zealand Subantarctic Islands", country: "NZ", groups: ["Q851132", "053", "009", "UN"], driveSide: "left" }, geometry: { type: "MultiPolygon", coordinates: [[[[164.30551, -47.88072], [161.96603, -56.07661], [179.49541, -50.04657], [179.49541, -47.2902], [169.91032, -47.66283], [164.30551, -47.88072]]]] } },
    { type: "Feature", properties: { wikidata: "Q46395", nameEn: "British Overseas Territories", aliases: ["BOTS", "UKOTS"], country: "GB", level: "subcountryGroup" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q46772", nameEn: "Kerguelen Islands", country: "FR", groups: ["EU", "TF", "Q1451600", "014", "202", "002", "UN"], level: "subterritory" }, geometry: { type: "MultiPolygon", coordinates: [[[[61.9216, -49.39746], [70.67507, -51.14192], [74.25129, -45.45074], [61.9216, -49.39746]]]] } },
    { type: "Feature", properties: { wikidata: "Q46879", nameEn: "Baker Island", aliases: ["UM-81"], country: "US", groups: ["UM", "Q1352230", "061", "009", "UN"], level: "subterritory", roadSpeedUnit: "mph", roadHeightUnit: "ft" }, geometry: { type: "MultiPolygon", coordinates: [[[[-175.33482, -1.40631], [-175.31323, 0.5442], [-177.91421, 0.39582], [-175.33482, -1.40631]]]] } },
    { type: "Feature", properties: { wikidata: "Q47863", nameEn: "Midway Atoll", aliases: ["MI", "MID", "MIUM", "488", "UM-71"], country: "US", groups: ["UM", "Q1352230", "061", "009", "UN"], level: "subterritory", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["1"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-176.29741, 29.09786], [-177.77531, 29.29793], [-177.5224, 27.7635], [-176.29741, 29.09786]]]] } },
    { type: "Feature", properties: { wikidata: "Q62218", nameEn: "Jarvis Island", aliases: ["UM-86"], country: "US", groups: ["UM", "Q1352230", "061", "009", "UN"], level: "subterritory", roadSpeedUnit: "mph", roadHeightUnit: "ft" }, geometry: { type: "MultiPolygon", coordinates: [[[[-160.42921, -1.4364], [-159.12443, 0.19975], [-160.38779, 0.30331], [-160.42921, -1.4364]]]] } },
    { type: "Feature", properties: { wikidata: "Q105472", nameEn: "Macaronesia", level: "sharedLandform" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q114935", nameEn: "Kermadec Islands", country: "NZ", groups: ["Q851132", "053", "009", "UN"], driveSide: "left", callingCodes: ["64"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-174.40891, -29.09438], [-180, -24.21376], [-179.96512, -35.00791], [-174.40891, -29.09438]]]] } },
    { type: "Feature", properties: { wikidata: "Q115459", nameEn: "Chatham Islands", aliases: ["NZ-CIT"], country: "NZ", groups: ["Q851132", "053", "009", "UN"], driveSide: "left", callingCodes: ["64"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-179.93224, -45.18423], [-172.47015, -45.17912], [-176.30998, -41.38382], [-179.93224, -45.18423]]]] } },
    { type: "Feature", properties: { wikidata: "Q118863", nameEn: "North Island", country: "NZ", groups: ["053", "009", "UN"], driveSide: "left", callingCodes: ["64"] }, geometry: { type: "MultiPolygon", coordinates: [[[[179.49541, -47.2902], [179.49541, -36.79303], [174.17679, -32.62487], [170.27492, -36.38133], [174.58663, -40.80446], [174.46634, -41.55028], [179.49541, -47.2902]]]] } },
    { type: "Feature", properties: { wikidata: "Q120755", nameEn: "South Island", country: "NZ", groups: ["053", "009", "UN"], driveSide: "left", callingCodes: ["64"] }, geometry: { type: "MultiPolygon", coordinates: [[[[169.70504, -47.56021], [179.49541, -47.2902], [174.46634, -41.55028], [174.58663, -40.80446], [170.27492, -36.38133], [166.56976, -39.94841], [164.8365, -46.0205], [167.52103, -46.41337], [169.70504, -47.56021]]]] } },
    { type: "Feature", properties: { wikidata: "Q123076", nameEn: "Palmyra Atoll", aliases: ["UM-95"], country: "US", groups: ["UM", "Q1352230", "061", "009", "UN"], level: "subterritory", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["1"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-161.06795, 5.2462], [-161.0731, 7.1291], [-163.24478, 5.24198], [-161.06795, 5.2462]]]] } },
    { type: "Feature", properties: { wikidata: "Q130574", nameEn: "Chafarinas Islands", country: "ES", groups: ["EU", "Q191011", "015", "002", "UN"], level: "subterritory" }, geometry: { type: "MultiPolygon", coordinates: [[[[-2.40316, 35.16893], [-2.43262, 35.20652], [-2.45965, 35.16527], [-2.40316, 35.16893]]]] } },
    { type: "Feature", properties: { wikidata: "Q130895", nameEn: "Kingman Reef", aliases: ["UM-89"], country: "US", groups: ["UM", "Q1352230", "061", "009", "UN"], level: "subterritory", roadSpeedUnit: "mph", roadHeightUnit: "ft" }, geometry: { type: "MultiPolygon", coordinates: [[[[-161.0731, 7.1291], [-163.16627, 7.15036], [-163.24478, 5.24198], [-161.0731, 7.1291]]]] } },
    { type: "Feature", properties: { wikidata: "Q131008", nameEn: "Johnston Atoll", aliases: ["JT", "JTN", "JTUM", "396", "UM-67"], country: "US", groups: ["UM", "Q1352230", "061", "009", "UN"], level: "subterritory", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["1"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-170.65691, 16.57199], [-168.87689, 16.01159], [-169.2329, 17.4933], [-170.65691, 16.57199]]]] } },
    { type: "Feature", properties: { wikidata: "Q131305", nameEn: "Howland Island", aliases: ["UM-84"], country: "US", groups: ["UM", "Q1352230", "061", "009", "UN"], level: "subterritory", roadSpeedUnit: "mph", roadHeightUnit: "ft" }, geometry: { type: "MultiPolygon", coordinates: [[[[-177.91421, 0.39582], [-175.31323, 0.5442], [-176.74464, 2.28109], [-177.91421, 0.39582]]]] } },
    { type: "Feature", properties: { wikidata: "Q133888", nameEn: "Ashmore and Cartier Islands", country: "AU", groups: ["053", "009", "UN"], driveSide: "left", callingCodes: ["61"] }, geometry: { type: "MultiPolygon", coordinates: [[[[123.7463, -11.1783], [120.6877, -13.59408], [125.29076, -12.33139], [123.7463, -11.1783]]]] } },
    { type: "Feature", properties: { wikidata: "Q153732", nameEn: "Mariana Islands", level: "sharedLandform" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q172216", nameEn: "Coral Sea Islands", country: "AU", groups: ["053", "009", "UN"], driveSide: "left", callingCodes: ["61"] }, geometry: { type: "MultiPolygon", coordinates: [[[[159.77159, -28.41151], [156.73836, -14.50464], [145.2855, -9.62524], [147.69992, -17.5933], [152.93188, -20.92631], [154.02855, -24.43238], [159.77159, -28.41151]]]] } },
    { type: "Feature", properties: { wikidata: "Q179313", nameEn: "Alderney", country: "GB", groups: ["GG", "830", "Q185086", "154", "150", "UN"], level: "subterritory", driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["44 01481"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-2.36485, 49.48223], [-2.09454, 49.46288], [-2.02963, 49.91866], [-2.49556, 49.79012], [-2.36485, 49.48223]]]] } },
    { type: "Feature", properties: { wikidata: "Q185086", nameEn: "Crown Dependencies", country: "GB", level: "subcountryGroup" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q190571", nameEn: "Scattered Islands", country: "FR", groups: ["EU", "TF", "Q1451600", "014", "202", "002", "UN"], level: "subterritory" }, geometry: { type: "MultiPolygon", coordinates: [[[[53.53458, -16.36909], [54.96649, -16.28353], [54.61476, -15.02273], [53.53458, -16.36909]]], [[[38.55969, -20.75596], [40.68027, -23.38889], [43.52893, -15.62903], [38.55969, -20.75596]]], [[[47.03092, -11.05648], [47.11593, -12.08552], [47.96702, -11.46447], [47.03092, -11.05648]]]] } },
    { type: "Feature", properties: { wikidata: "Q191011", nameEn: "Plazas de soberan\xEDa", country: "ES" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q191146", nameEn: "Pe\xF1\xF3n de V\xE9lez de la Gomera", country: "ES", groups: ["EU", "Q191011", "015", "002", "UN"], level: "subterritory" }, geometry: { type: "MultiPolygon", coordinates: [[[[-4.30191, 35.17419], [-4.30112, 35.17058], [-4.29436, 35.17149], [-4.30191, 35.17419]]]] } },
    { type: "Feature", properties: { wikidata: "Q201698", nameEn: "Crozet Islands", country: "FR", groups: ["EU", "TF", "Q1451600", "014", "202", "002", "UN"], level: "subterritory" }, geometry: { type: "MultiPolygon", coordinates: [[[[55.03425, -43.65017], [46.31615, -46.28749], [54.5587, -47.93013], [55.03425, -43.65017]]]] } },
    { type: "Feature", properties: { wikidata: "Q578170", nameEn: "Contiguous United States", aliases: ["CONUS"], country: "US", groups: ["Q35657", "021", "003", "019", "UN"], roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["1"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-97.13927, 25.96583], [-96.92418, 25.97377], [-80.57035, 24.0565], [-78.91214, 27.76553], [-61.98255, 37.34815], [-67.16117, 44.20069], [-66.93432, 44.82597], [-66.96824, 44.83078], [-66.98249, 44.87071], [-66.96824, 44.90965], [-67.0216, 44.95333], [-67.11316, 45.11176], [-67.15965, 45.16179], [-67.19603, 45.16771], [-67.20349, 45.1722], [-67.22751, 45.16344], [-67.27039, 45.1934], [-67.29748, 45.18173], [-67.29754, 45.14865], [-67.34927, 45.122], [-67.48201, 45.27351], [-67.42394, 45.37969], [-67.50578, 45.48971], [-67.42144, 45.50584], [-67.43815, 45.59162], [-67.6049, 45.60725], [-67.80705, 45.69528], [-67.80653, 45.80022], [-67.75654, 45.82324], [-67.80961, 45.87531], [-67.75196, 45.91814], [-67.78111, 45.9392], [-67.78578, 47.06473], [-67.87993, 47.10377], [-67.94843, 47.1925], [-68.23244, 47.35712], [-68.37458, 47.35851], [-68.38332, 47.28723], [-68.57914, 47.28431], [-68.60575, 47.24659], [-68.70125, 47.24399], [-68.89222, 47.1807], [-69.05039, 47.2456], [-69.05073, 47.30076], [-69.05148, 47.42012], [-69.22119, 47.46461], [-69.99966, 46.69543], [-70.05812, 46.41768], [-70.18547, 46.35357], [-70.29078, 46.18832], [-70.23855, 46.1453], [-70.31025, 45.96424], [-70.24694, 45.95138], [-70.25976, 45.89675], [-70.41523, 45.79497], [-70.38934, 45.73215], [-70.54019, 45.67291], [-70.68516, 45.56964], [-70.72651, 45.49771], [-70.62518, 45.42286], [-70.65383, 45.37592], [-70.78372, 45.43269], [-70.82638, 45.39828], [-70.80236, 45.37444], [-70.84816, 45.22698], [-70.89864, 45.2398], [-70.91169, 45.29849], [-70.95193, 45.33895], [-71.0107, 45.34819], [-71.01866, 45.31573], [-71.08364, 45.30623], [-71.14568, 45.24128], [-71.19723, 45.25438], [-71.22338, 45.25184], [-71.29371, 45.29996], [-71.37133, 45.24624], [-71.44252, 45.2361], [-71.40364, 45.21382], [-71.42778, 45.12624], [-71.48735, 45.07784], [-71.50067, 45.01357], [-73.35025, 45.00942], [-74.32699, 44.99029], [-74.66689, 45.00646], [-74.8447, 45.00606], [-74.99101, 44.98051], [-75.01363, 44.95608], [-75.2193, 44.87821], [-75.41441, 44.76614], [-75.76813, 44.51537], [-75.8217, 44.43176], [-75.95947, 44.34463], [-76.00018, 44.34896], [-76.16285, 44.28262], [-76.1664, 44.23051], [-76.244, 44.19643], [-76.31222, 44.19894], [-76.35324, 44.13493], [-76.43859, 44.09393], [-76.79706, 43.63099], [-79.25796, 43.54052], [-79.06921, 43.26183], [-79.05512, 43.25375], [-79.05544, 43.21224], [-79.05002, 43.20133], [-79.05384, 43.17418], [-79.04652, 43.16396], [-79.0427, 43.13934], [-79.06881, 43.12029], [-79.05671, 43.10937], [-79.07486, 43.07845], [-79.01055, 43.06659], [-78.99941, 43.05612], [-79.02424, 43.01983], [-79.02074, 42.98444], [-78.98126, 42.97], [-78.96312, 42.95509], [-78.93224, 42.95229], [-78.90905, 42.93022], [-78.90712, 42.89733], [-78.93684, 42.82887], [-82.67862, 41.67615], [-83.11184, 41.95671], [-83.14962, 42.04089], [-83.12724, 42.2376], [-83.09837, 42.28877], [-83.07837, 42.30978], [-83.02253, 42.33045], [-82.82964, 42.37355], [-82.64242, 42.55594], [-82.58873, 42.54984], [-82.57583, 42.5718], [-82.51858, 42.611], [-82.51063, 42.66025], [-82.46613, 42.76615], [-82.4826, 42.8068], [-82.45331, 42.93139], [-82.4253, 42.95423], [-82.4146, 42.97626], [-82.42469, 42.992], [-82.48419, 45.30225], [-83.59589, 45.82131], [-83.43746, 45.99749], [-83.57017, 46.105], [-83.83329, 46.12169], [-83.90453, 46.05922], [-83.95399, 46.05634], [-84.1096, 46.23987], [-84.09756, 46.25512], [-84.11615, 46.2681], [-84.11254, 46.32329], [-84.13451, 46.39218], [-84.11196, 46.50248], [-84.12885, 46.53068], [-84.17723, 46.52753], [-84.1945, 46.54061], [-84.2264, 46.53337], [-84.26351, 46.49508], [-84.29893, 46.49127], [-84.34174, 46.50683], [-84.42101, 46.49853], [-84.4481, 46.48972], [-84.47607, 46.45225], [-84.55635, 46.45974], [-84.85871, 46.88881], [-88.37033, 48.30586], [-89.48837, 48.01412], [-89.57972, 48.00023], [-89.77248, 48.02607], [-89.89974, 47.98109], [-90.07418, 48.11043], [-90.56312, 48.09488], [-90.56444, 48.12184], [-90.75045, 48.09143], [-90.87588, 48.2484], [-91.08016, 48.18096], [-91.25025, 48.08522], [-91.43248, 48.04912], [-91.45829, 48.07454], [-91.58025, 48.04339], [-91.55649, 48.10611], [-91.70451, 48.11805], [-91.71231, 48.19875], [-91.86125, 48.21278], [-91.98929, 48.25409], [-92.05339, 48.35958], [-92.14732, 48.36578], [-92.202, 48.35252], [-92.26662, 48.35651], [-92.30939, 48.31251], [-92.27167, 48.25046], [-92.37185, 48.22259], [-92.48147, 48.36609], [-92.45588, 48.40624], [-92.50712, 48.44921], [-92.65606, 48.43471], [-92.71323, 48.46081], [-92.69927, 48.49573], [-92.62747, 48.50278], [-92.6342, 48.54133], [-92.7287, 48.54005], [-92.94973, 48.60866], [-93.25391, 48.64266], [-93.33946, 48.62787], [-93.3712, 48.60599], [-93.39758, 48.60364], [-93.40693, 48.60948], [-93.44472, 48.59147], [-93.47022, 48.54357], [-93.66382, 48.51845], [-93.79267, 48.51631], [-93.80939, 48.52439], [-93.80676, 48.58232], [-93.83288, 48.62745], [-93.85769, 48.63284], [-94.23215, 48.65202], [-94.25104, 48.65729], [-94.25172, 48.68404], [-94.27153, 48.70232], [-94.4174, 48.71049], [-94.44258, 48.69223], [-94.53826, 48.70216], [-94.54885, 48.71543], [-94.58903, 48.71803], [-94.69335, 48.77883], [-94.69669, 48.80918], [-94.70486, 48.82365], [-94.70087, 48.8339], [-94.687, 48.84077], [-94.75017, 49.09931], [-94.77355, 49.11998], [-94.82487, 49.29483], [-94.8159, 49.32299], [-94.85381, 49.32492], [-94.95681, 49.37035], [-94.99532, 49.36579], [-95.01419, 49.35647], [-95.05825, 49.35311], [-95.12903, 49.37056], [-95.15357, 49.384], [-95.15355, 48.9996], [-123.32163, 49.00419], [-123.0093, 48.83186], [-123.0093, 48.76586], [-123.26565, 48.6959], [-123.15614, 48.35395], [-123.50039, 48.21223], [-125.03842, 48.53282], [-133.98258, 38.06389], [-118.48109, 32.5991], [-117.1243, 32.53427], [-115.88053, 32.63624], [-114.71871, 32.71894], [-114.76736, 32.64094], [-114.80584, 32.62028], [-114.81141, 32.55543], [-114.79524, 32.55731], [-114.82011, 32.49609], [-111.07523, 31.33232], [-108.20979, 31.33316], [-108.20899, 31.78534], [-106.529, 31.784], [-106.52266, 31.77509], [-106.51251, 31.76922], [-106.50962, 31.76155], [-106.50111, 31.75714], [-106.48815, 31.74769], [-106.47298, 31.75054], [-106.46726, 31.75998], [-106.45244, 31.76523], [-106.43419, 31.75478], [-106.41773, 31.75196], [-106.38003, 31.73151], [-106.3718, 31.71165], [-106.34864, 31.69663], [-106.33419, 31.66303], [-106.30305, 31.62154], [-106.28084, 31.56173], [-106.24612, 31.54193], [-106.23711, 31.51262], [-106.20346, 31.46305], [-106.09025, 31.40569], [-106.00363, 31.39181], [-104.77674, 30.4236], [-104.5171, 29.64671], [-104.3969, 29.57105], [-104.39363, 29.55396], [-104.37752, 29.54255], [-103.15787, 28.93865], [-102.60596, 29.8192], [-101.47277, 29.7744], [-101.05686, 29.44738], [-101.01128, 29.36947], [-100.96725, 29.3477], [-100.94579, 29.34523], [-100.94056, 29.33371], [-100.87982, 29.296], [-100.79696, 29.24688], [-100.67294, 29.09744], [-100.63689, 28.90812], [-100.59809, 28.88197], [-100.52313, 28.75598], [-100.5075, 28.74066], [-100.51222, 28.70679], [-100.50029, 28.66117], [-99.55409, 27.61314], [-99.51478, 27.55836], [-99.52955, 27.49747], [-99.50208, 27.50021], [-99.48045, 27.49016], [-99.482, 27.47128], [-99.49744, 27.43746], [-99.53573, 27.30926], [-99.08477, 26.39849], [-99.03053, 26.41249], [-99.00546, 26.3925], [-98.35126, 26.15129], [-98.30491, 26.10475], [-98.27075, 26.09457], [-98.24603, 26.07191], [-97.97017, 26.05232], [-97.95155, 26.0625], [-97.66511, 26.01708], [-97.52025, 25.88518], [-97.49828, 25.89877], [-97.45669, 25.86874], [-97.42511, 25.83969], [-97.37332, 25.83854], [-97.35946, 25.92189], [-97.13927, 25.96583]]]] } },
    { type: "Feature", properties: { wikidata: "Q620634", nameEn: "Bir Tawil", groups: ["015", "002"], level: "territory" }, geometry: { type: "MultiPolygon", coordinates: [[[[33.17563, 22.00405], [33.57251, 21.72406], [33.99686, 21.76784], [34.0765, 22.00501], [33.17563, 22.00405]]]] } },
    { type: "Feature", properties: { wikidata: "Q639185", nameEn: "Peros Banhos", country: "GB", groups: ["IO", "BOTS", "014", "202", "002", "UN"], level: "subterritory" }, geometry: { type: "MultiPolygon", coordinates: [[[[72.12587, -4.02588], [70.1848, -6.37445], [72.09518, -5.61768], [72.12587, -4.02588]]]] } },
    { type: "Feature", properties: { wikidata: "Q644636", nameEn: "Cyprus", level: "sharedLandform" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q851132", nameEn: "New Zealand Outlying Islands", country: "NZ", level: "subcountryGroup" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q875134", nameEn: "European Russia", country: "RU", groups: ["151", "150", "UN"], callingCodes: ["7"] }, geometry: { type: "MultiPolygon", coordinates: [[[[18.57853, 55.25302], [19.64312, 54.45423], [19.8038, 54.44203], [20.63871, 54.3706], [21.41123, 54.32395], [22.79705, 54.36264], [22.7253, 54.41732], [22.70208, 54.45312], [22.67788, 54.532], [22.71293, 54.56454], [22.68021, 54.58486], [22.7522, 54.63525], [22.74225, 54.64339], [22.75467, 54.6483], [22.73397, 54.66604], [22.73631, 54.72952], [22.87317, 54.79492], [22.85083, 54.88711], [22.76422, 54.92521], [22.68723, 54.9811], [22.65451, 54.97037], [22.60075, 55.01863], [22.58907, 55.07085], [22.47688, 55.04408], [22.31562, 55.0655], [22.14267, 55.05345], [22.11697, 55.02131], [22.06087, 55.02935], [22.02582, 55.05078], [22.03984, 55.07888], [21.99543, 55.08691], [21.96505, 55.07353], [21.85521, 55.09493], [21.64954, 55.1791], [21.55605, 55.20311], [21.51095, 55.18507], [21.46766, 55.21115], [21.38446, 55.29348], [21.35465, 55.28427], [21.26425, 55.24456], [20.95181, 55.27994], [20.60454, 55.40986], [18.57853, 55.25302]]], [[[26.32936, 60.00121], [26.90044, 59.63819], [27.85643, 59.58538], [28.04187, 59.47017], [28.19061, 59.39962], [28.21137, 59.38058], [28.20537, 59.36491], [28.19284, 59.35791], [28.14215, 59.28934], [28.00689, 59.28351], [27.90911, 59.24353], [27.87978, 59.18097], [27.80482, 59.1116], [27.74429, 58.98351], [27.36366, 58.78381], [27.55489, 58.39525], [27.48541, 58.22615], [27.62393, 58.09462], [27.67282, 57.92627], [27.81841, 57.89244], [27.78526, 57.83963], [27.56689, 57.83356], [27.50171, 57.78842], [27.52615, 57.72843], [27.3746, 57.66834], [27.40393, 57.62125], [27.31919, 57.57672], [27.34698, 57.52242], [27.56832, 57.53728], [27.52453, 57.42826], [27.86101, 57.29402], [27.66511, 56.83921], [27.86101, 56.88204], [28.04768, 56.59004], [28.13526, 56.57989], [28.10069, 56.524], [28.19057, 56.44637], [28.16599, 56.37806], [28.23716, 56.27588], [28.15217, 56.16964], [28.30571, 56.06035], [28.36888, 56.05805], [28.37987, 56.11399], [28.43068, 56.09407], [28.5529, 56.11705], [28.68337, 56.10173], [28.63668, 56.07262], [28.73418, 55.97131], [29.08299, 56.03427], [29.21717, 55.98971], [29.44692, 55.95978], [29.3604, 55.75862], [29.51283, 55.70294], [29.61446, 55.77716], [29.80672, 55.79569], [29.97975, 55.87281], [30.12136, 55.8358], [30.27776, 55.86819], [30.30987, 55.83592], [30.48257, 55.81066], [30.51346, 55.78982], [30.51037, 55.76568], [30.63344, 55.73079], [30.67464, 55.64176], [30.72957, 55.66268], [30.7845, 55.58514], [30.86003, 55.63169], [30.93419, 55.6185], [30.95204, 55.50667], [30.90123, 55.46621], [30.93144, 55.3914], [30.8257, 55.3313], [30.81946, 55.27931], [30.87944, 55.28223], [30.97369, 55.17134], [31.02071, 55.06167], [31.00972, 55.02783], [30.94243, 55.03964], [30.9081, 55.02232], [30.95754, 54.98609], [30.93144, 54.9585], [30.81759, 54.94064], [30.8264, 54.90062], [30.75165, 54.80699], [30.95479, 54.74346], [30.97127, 54.71967], [31.0262, 54.70698], [30.98226, 54.68872], [30.99187, 54.67046], [31.19339, 54.66947], [31.21399, 54.63113], [31.08543, 54.50361], [31.22945, 54.46585], [31.3177, 54.34067], [31.30791, 54.25315], [31.57002, 54.14535], [31.89599, 54.0837], [31.88744, 54.03653], [31.85019, 53.91801], [31.77028, 53.80015], [31.89137, 53.78099], [32.12621, 53.81586], [32.36663, 53.7166], [32.45717, 53.74039], [32.50112, 53.68594], [32.40499, 53.6656], [32.47777, 53.5548], [32.74968, 53.45597], [32.73257, 53.33494], [32.51725, 53.28431], [32.40773, 53.18856], [32.15368, 53.07594], [31.82373, 53.10042], [31.787, 53.18033], [31.62496, 53.22886], [31.56316, 53.19432], [31.40523, 53.21406], [31.36403, 53.13504], [31.3915, 53.09712], [31.33519, 53.08805], [31.32283, 53.04101], [31.24147, 53.031], [31.35667, 52.97854], [31.592, 52.79011], [31.57277, 52.71613], [31.50406, 52.69707], [31.63869, 52.55361], [31.56316, 52.51518], [31.61397, 52.48843], [31.62084, 52.33849], [31.57971, 52.32146], [31.70735, 52.26711], [31.6895, 52.1973], [31.77877, 52.18636], [31.7822, 52.11406], [31.81722, 52.09955], [31.85018, 52.11305], [31.96141, 52.08015], [31.92159, 52.05144], [32.08813, 52.03319], [32.23331, 52.08085], [32.2777, 52.10266], [32.34044, 52.1434], [32.33083, 52.23685], [32.38988, 52.24946], [32.3528, 52.32842], [32.54781, 52.32423], [32.69475, 52.25535], [32.85405, 52.27888], [32.89937, 52.2461], [33.18913, 52.3754], [33.51323, 52.35779], [33.48027, 52.31499], [33.55718, 52.30324], [33.78789, 52.37204], [34.05239, 52.20132], [34.11199, 52.14087], [34.09413, 52.00835], [34.41136, 51.82793], [34.42922, 51.72852], [34.07765, 51.67065], [34.17599, 51.63253], [34.30562, 51.5205], [34.22048, 51.4187], [34.33446, 51.363], [34.23009, 51.26429], [34.31661, 51.23936], [34.38802, 51.2746], [34.6613, 51.25053], [34.6874, 51.18], [34.82472, 51.17483], [34.97304, 51.2342], [35.14058, 51.23162], [35.12685, 51.16191], [35.20375, 51.04723], [35.31774, 51.08434], [35.40837, 51.04119], [35.32598, 50.94524], [35.39307, 50.92145], [35.41367, 50.80227], [35.47704, 50.77274], [35.48116, 50.66405], [35.39464, 50.64751], [35.47463, 50.49247], [35.58003, 50.45117], [35.61711, 50.35707], [35.73659, 50.35489], [35.80388, 50.41356], [35.8926, 50.43829], [36.06893, 50.45205], [36.20763, 50.3943], [36.30101, 50.29088], [36.47817, 50.31457], [36.58371, 50.28563], [36.56655, 50.2413], [36.64571, 50.218], [36.69377, 50.26982], [36.91762, 50.34963], [37.08468, 50.34935], [37.48204, 50.46079], [37.47243, 50.36277], [37.62486, 50.29966], [37.62879, 50.24481], [37.61113, 50.21976], [37.75807, 50.07896], [37.79515, 50.08425], [37.90776, 50.04194], [38.02999, 49.94482], [38.02999, 49.90592], [38.21675, 49.98104], [38.18517, 50.08161], [38.32524, 50.08866], [38.35408, 50.00664], [38.65688, 49.97176], [38.68677, 50.00904], [38.73311, 49.90238], [38.90477, 49.86787], [38.9391, 49.79524], [39.1808, 49.88911], [39.27968, 49.75976], [39.44496, 49.76067], [39.59142, 49.73758], [39.65047, 49.61761], [39.84548, 49.56064], [40.13249, 49.61672], [40.16683, 49.56865], [40.03636, 49.52321], [40.03087, 49.45452], [40.1141, 49.38798], [40.14912, 49.37681], [40.18331, 49.34996], [40.22176, 49.25683], [40.01988, 49.1761], [39.93437, 49.05709], [39.6836, 49.05121], [39.6683, 48.99454], [39.71353, 48.98959], [39.72649, 48.9754], [39.74874, 48.98675], [39.78368, 48.91596], [39.98967, 48.86901], [40.03636, 48.91957], [40.08168, 48.87443], [39.97182, 48.79398], [39.79466, 48.83739], [39.73104, 48.7325], [39.71765, 48.68673], [39.67226, 48.59368], [39.79764, 48.58668], [39.84548, 48.57821], [39.86196, 48.46633], [39.88794, 48.44226], [39.94847, 48.35055], [39.84136, 48.33321], [39.84273, 48.30947], [39.90041, 48.3049], [39.91465, 48.26743], [39.95248, 48.29972], [39.9693, 48.29904], [39.97325, 48.31399], [39.99241, 48.31768], [40.00752, 48.22445], [39.94847, 48.22811], [39.83724, 48.06501], [39.88256, 48.04482], [39.77544, 48.04206], [39.82213, 47.96396], [39.73935, 47.82876], [38.87979, 47.87719], [38.79628, 47.81109], [38.76379, 47.69346], [38.35062, 47.61631], [38.28679, 47.53552], [38.28954, 47.39255], [38.22225, 47.30788], [38.33074, 47.30508], [38.32112, 47.2585], [38.23049, 47.2324], [38.22955, 47.12069], [38.3384, 46.98085], [38.12112, 46.86078], [37.62608, 46.82615], [35.23066, 45.79231], [35.04991, 45.76827], [36.6645, 45.4514], [36.6545, 45.3417], [36.5049, 45.3136], [36.475, 45.2411], [36.4883, 45.0488], [33.5943, 44.03313], [39.81147, 43.06294], [40.0078, 43.38551], [40.00853, 43.40578], [40.01552, 43.42025], [40.01007, 43.42411], [40.03312, 43.44262], [40.04445, 43.47776], [40.10657, 43.57344], [40.65957, 43.56212], [41.64935, 43.22331], [42.40563, 43.23226], [42.66667, 43.13917], [42.75889, 43.19651], [43.03322, 43.08883], [43.0419, 43.02413], [43.81453, 42.74297], [43.73119, 42.62043], [43.95517, 42.55396], [44.54202, 42.75699], [44.70002, 42.74679], [44.80941, 42.61277], [44.88754, 42.74934], [45.15318, 42.70598], [45.36501, 42.55268], [45.78692, 42.48358], [45.61676, 42.20768], [46.42738, 41.91323], [46.5332, 41.87389], [46.58924, 41.80547], [46.75269, 41.8623], [46.8134, 41.76252], [47.00955, 41.63583], [46.99554, 41.59743], [47.03757, 41.55434], [47.10762, 41.59044], [47.34579, 41.27884], [47.49004, 41.26366], [47.54504, 41.20275], [47.62288, 41.22969], [47.75831, 41.19455], [47.87973, 41.21798], [48.07587, 41.49957], [48.22064, 41.51472], [48.2878, 41.56221], [48.40277, 41.60441], [48.42301, 41.65444], [48.55078, 41.77917], [48.5867, 41.84306], [48.80971, 41.95365], [49.2134, 44.84989], [49.88945, 46.04554], [49.32259, 46.26944], [49.16518, 46.38542], [48.54988, 46.56267], [48.51142, 46.69268], [49.01136, 46.72716], [48.52326, 47.4102], [48.45173, 47.40818], [48.15348, 47.74545], [47.64973, 47.76559], [47.41689, 47.83687], [47.38731, 47.68176], [47.12107, 47.83687], [47.11516, 48.27188], [46.49011, 48.43019], [46.78392, 48.95352], [47.00857, 49.04921], [47.04658, 49.19834], [46.78398, 49.34026], [46.9078, 49.86707], [47.18319, 49.93721], [47.34589, 50.09308], [47.30448, 50.30894], [47.58551, 50.47867], [48.10044, 50.09242], [48.24519, 49.86099], [48.42564, 49.82283], [48.68352, 49.89546], [48.90782, 50.02281], [48.57946, 50.63278], [48.86936, 50.61589], [49.12673, 50.78639], [49.41959, 50.85927], [49.39001, 51.09396], [49.76866, 51.11067], [49.97277, 51.2405], [50.26859, 51.28677], [50.59695, 51.61859], [51.26254, 51.68466], [51.301, 51.48799], [51.77431, 51.49536], [51.8246, 51.67916], [52.36119, 51.74161], [52.54329, 51.48444], [53.46165, 51.49445], [53.69299, 51.23466], [54.12248, 51.11542], [54.46331, 50.85554], [54.41894, 50.61214], [54.55797, 50.52006], [54.71476, 50.61214], [54.56685, 51.01958], [54.72067, 51.03261], [55.67774, 50.54508], [56.11398, 50.7471], [56.17906, 50.93204], [57.17302, 51.11253], [57.44221, 50.88354], [57.74986, 50.93017], [57.75578, 51.13852], [58.3208, 51.15151], [58.87974, 50.70852], [59.48928, 50.64216], [59.51886, 50.49937], [59.81172, 50.54451], [60.01288, 50.8163], [60.17262, 50.83312], [60.31914, 50.67705], [60.81833, 50.6629], [61.4431, 50.80679], [61.56889, 51.23679], [61.6813, 51.25716], [61.55114, 51.32746], [61.50677, 51.40687], [60.95655, 51.48615], [60.92401, 51.61124], [60.5424, 51.61675], [60.36787, 51.66815], [60.50986, 51.7964], [60.09867, 51.87135], [59.99809, 51.98263], [59.91279, 52.06924], [60.17253, 52.25814], [60.17516, 52.39457], [59.25033, 52.46803], [59.22409, 52.28437], [58.79644, 52.43392], [58.94336, 53.953], [59.70487, 54.14846], [59.95217, 54.85853], [57.95234, 54.39672], [57.14829, 54.84204], [57.25137, 55.26262], [58.81825, 55.03378], [59.49035, 55.60486], [59.28419, 56.15739], [57.51527, 56.08729], [57.28024, 56.87898], [58.07604, 57.08308], [58.13789, 57.68097], [58.81412, 57.71602], [58.71104, 58.07475], [59.40376, 58.45822], [59.15636, 59.14682], [58.3853, 59.487], [59.50685, 60.91162], [59.36223, 61.3882], [59.61398, 62.44915], [59.24834, 63.01859], [59.80579, 64.13948], [59.63945, 64.78384], [60.74386, 64.95767], [61.98014, 65.72191], [66.1708, 67.61252], [64.18965, 69.94255], [76.13964, 83.37843], [36.85549, 84.09565], [32.07813, 72.01005], [31.59909, 70.16571], [30.84095, 69.80584], [30.95011, 69.54699], [30.52662, 69.54699], [30.16363, 69.65244], [29.97205, 69.41623], [29.27631, 69.2811], [29.26623, 69.13794], [29.0444, 69.0119], [28.91738, 69.04774], [28.45957, 68.91417], [28.78224, 68.86696], [28.43941, 68.53366], [28.62982, 68.19816], [29.34179, 68.06655], [29.66955, 67.79872], [30.02041, 67.67523], [29.91155, 67.51507], [28.9839, 66.94139], [29.91155, 66.13863], [30.16363, 65.66935], [29.97205, 65.70256], [29.74013, 65.64025], [29.84096, 65.56945], [29.68972, 65.31803], [29.61914, 65.23791], [29.8813, 65.22101], [29.84096, 65.1109], [29.61914, 65.05993], [29.68972, 64.80789], [30.05271, 64.79072], [30.12329, 64.64862], [30.01238, 64.57513], [30.06279, 64.35782], [30.4762, 64.25728], [30.55687, 64.09036], [30.25437, 63.83364], [29.98213, 63.75795], [30.49637, 63.46666], [31.23244, 63.22239], [31.29294, 63.09035], [31.58535, 62.91642], [31.38369, 62.66284], [31.10136, 62.43042], [29.01829, 61.17448], [28.82816, 61.1233], [28.47974, 60.93365], [27.77352, 60.52722], [27.71177, 60.3893], [27.44953, 60.22766], [26.32936, 60.00121]]]] } },
    { type: "Feature", properties: { wikidata: "Q1083368", nameEn: "Mainland Finland", country: "FI", groups: ["EU", "154", "150", "UN"], callingCodes: ["358"] }, geometry: { type: "MultiPolygon", coordinates: [[[[29.12697, 69.69193], [28.36883, 69.81658], [28.32849, 69.88605], [27.97558, 69.99671], [27.95542, 70.0965], [27.57226, 70.06215], [27.05802, 69.92069], [26.64461, 69.96565], [26.40261, 69.91377], [25.96904, 69.68397], [25.69679, 69.27039], [25.75729, 68.99383], [25.61613, 68.89602], [25.42455, 68.90328], [25.12206, 68.78684], [25.10189, 68.63307], [24.93048, 68.61102], [24.90023, 68.55579], [24.74898, 68.65143], [24.18432, 68.73936], [24.02299, 68.81601], [23.781, 68.84514], [23.68017, 68.70276], [23.13064, 68.64684], [22.53321, 68.74393], [22.38367, 68.71561], [22.27276, 68.89514], [21.63833, 69.27485], [21.27827, 69.31281], [21.00732, 69.22755], [20.98641, 69.18809], [21.11099, 69.10291], [21.05775, 69.0356], [20.72171, 69.11874], [20.55258, 69.06069], [20.78802, 69.03087], [20.91658, 68.96764], [20.85104, 68.93142], [20.90649, 68.89696], [21.03001, 68.88969], [22.00429, 68.50692], [22.73028, 68.40881], [23.10336, 68.26551], [23.15377, 68.14759], [23.26469, 68.15134], [23.40081, 68.05545], [23.65793, 67.9497], [23.45627, 67.85297], [23.54701, 67.59306], [23.39577, 67.46974], [23.75372, 67.43688], [23.75372, 67.29914], [23.54701, 67.25435], [23.58735, 67.20752], [23.56214, 67.17038], [23.98563, 66.84149], [23.98059, 66.79585], [23.89488, 66.772], [23.85959, 66.56434], [23.63776, 66.43568], [23.67591, 66.3862], [23.64982, 66.30603], [23.71339, 66.21299], [23.90497, 66.15802], [24.15791, 65.85385], [24.14798, 65.83466], [24.15107, 65.81427], [24.14112, 65.39731], [20.15877, 63.06556], [19.23413, 60.61414], [20.96741, 60.71528], [21.15143, 60.54555], [21.08159, 60.20167], [21.02509, 60.12142], [21.35468, 59.67511], [20.5104, 59.15546], [26.32936, 60.00121], [27.44953, 60.22766], [27.71177, 60.3893], [27.77352, 60.52722], [28.47974, 60.93365], [28.82816, 61.1233], [29.01829, 61.17448], [31.10136, 62.43042], [31.38369, 62.66284], [31.58535, 62.91642], [31.29294, 63.09035], [31.23244, 63.22239], [30.49637, 63.46666], [29.98213, 63.75795], [30.25437, 63.83364], [30.55687, 64.09036], [30.4762, 64.25728], [30.06279, 64.35782], [30.01238, 64.57513], [30.12329, 64.64862], [30.05271, 64.79072], [29.68972, 64.80789], [29.61914, 65.05993], [29.84096, 65.1109], [29.8813, 65.22101], [29.61914, 65.23791], [29.68972, 65.31803], [29.84096, 65.56945], [29.74013, 65.64025], [29.97205, 65.70256], [30.16363, 65.66935], [29.91155, 66.13863], [28.9839, 66.94139], [29.91155, 67.51507], [30.02041, 67.67523], [29.66955, 67.79872], [29.34179, 68.06655], [28.62982, 68.19816], [28.43941, 68.53366], [28.78224, 68.86696], [28.45957, 68.91417], [28.91738, 69.04774], [28.81248, 69.11997], [28.8629, 69.22395], [29.31664, 69.47994], [29.12697, 69.69193]]]] } },
    { type: "Feature", properties: { wikidata: "Q1184963", nameEn: "Alhucemas Islands", country: "ES", groups: ["EU", "Q191011", "015", "002", "UN"], level: "subterritory" }, geometry: { type: "MultiPolygon", coordinates: [[[[-3.90602, 35.21494], [-3.88372, 35.20767], [-3.89343, 35.22728], [-3.90602, 35.21494]]]] } },
    { type: "Feature", properties: { wikidata: "Q1298289", nameEn: "Egmont Islands", country: "GB", groups: ["IO", "BOTS", "014", "202", "002", "UN"], level: "subterritory" }, geometry: { type: "MultiPolygon", coordinates: [[[[70.1848, -6.37445], [70.67958, -8.2663], [72.17991, -6.68509], [70.1848, -6.37445]]]] } },
    { type: "Feature", properties: { wikidata: "Q1352230", nameEn: "US Territories", country: "US", level: "subcountryGroup" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q1451600", nameEn: "Overseas Countries and Territories of the EU", aliases: ["OCT"], level: "subunion" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q1544253", nameEn: "Great Chagos Bank", country: "GB", groups: ["IO", "BOTS", "014", "202", "002", "UN"], level: "subterritory" }, geometry: { type: "MultiPolygon", coordinates: [[[[70.1848, -6.37445], [72.17991, -6.68509], [73.20573, -5.20727], [70.1848, -6.37445]]]] } },
    { type: "Feature", properties: { wikidata: "Q1585511", nameEn: "Salomon Atoll", country: "GB", groups: ["IO", "BOTS", "014", "202", "002", "UN"], level: "subterritory" }, geometry: { type: "MultiPolygon", coordinates: [[[[72.09518, -5.61768], [73.20573, -5.20727], [72.12587, -4.02588], [72.09518, -5.61768]]]] } },
    { type: "Feature", properties: { wikidata: "Q1681727", nameEn: "Saint-Paul and Amsterdam", country: "FR", groups: ["EU", "TF", "Q1451600", "014", "202", "002", "UN"], level: "subterritory" }, geometry: { type: "MultiPolygon", coordinates: [[[[76.31747, -42.16264], [80.15867, -36.04977], [71.22311, -38.75287], [76.31747, -42.16264]]]] } },
    { type: "Feature", properties: { wikidata: "Q1901211", nameEn: "East Malaysia", country: "MY", groups: ["Q36117", "035", "142", "UN"], driveSide: "left", callingCodes: ["60"] }, geometry: { type: "MultiPolygon", coordinates: [[[[110.90339, 7.52694], [109.82788, 2.86812], [109.62558, 1.99182], [109.53794, 1.91771], [109.57923, 1.80624], [109.66397, 1.79972], [109.66397, 1.60425], [110.35354, 0.98869], [110.49182, 0.88088], [110.62374, 0.873], [111.22979, 1.08326], [111.55434, 0.97864], [111.82846, 0.99349], [111.94553, 1.12016], [112.15679, 1.17004], [112.2127, 1.44135], [112.48648, 1.56516], [113.021, 1.57819], [113.01448, 1.42832], [113.64677, 1.23933], [114.03788, 1.44787], [114.57892, 1.5], [114.80706, 1.92351], [114.80706, 2.21665], [115.1721, 2.49671], [115.11343, 2.82879], [115.53713, 3.14776], [115.58276, 3.93499], [115.90217, 4.37708], [117.25801, 4.35108], [117.47313, 4.18857], [117.67641, 4.16535], [118.06469, 4.16638], [118.93936, 4.09009], [119.52945, 5.35672], [117.98544, 6.27477], [117.93857, 6.89845], [117.17735, 7.52841], [116.79524, 7.43869], [115.02521, 5.35005], [115.16236, 5.01011], [115.15092, 4.87604], [115.20737, 4.8256], [115.27819, 4.63661], [115.2851, 4.42295], [115.36346, 4.33563], [115.31275, 4.30806], [115.09978, 4.39123], [115.07737, 4.53418], [115.04064, 4.63706], [115.02278, 4.74137], [115.02955, 4.82087], [115.05038, 4.90275], [114.99417, 4.88201], [114.96982, 4.81146], [114.88841, 4.81905], [114.8266, 4.75062], [114.77303, 4.72871], [114.83189, 4.42387], [114.88039, 4.4257], [114.78539, 4.12205], [114.64211, 4.00694], [114.49922, 4.13108], [114.4416, 4.27588], [114.32176, 4.2552], [114.32176, 4.34942], [114.26876, 4.49878], [114.15813, 4.57], [114.07448, 4.58441], [114.10166, 4.76112], [110.90339, 7.52694]]]] } },
    { type: "Feature", properties: { wikidata: "Q1973345", nameEn: "Peninsular Malaysia", country: "MY", groups: ["035", "142", "UN"], driveSide: "left", callingCodes: ["60"] }, geometry: { type: "MultiPolygon", coordinates: [[[[102.46318, 7.22462], [102.09086, 6.23546], [102.08127, 6.22679], [102.07732, 6.193], [102.09182, 6.14161], [102.01835, 6.05407], [101.99209, 6.04075], [101.97114, 6.01992], [101.9714, 6.00575], [101.94712, 5.98421], [101.92819, 5.85511], [101.91776, 5.84269], [101.89188, 5.8386], [101.80144, 5.74505], [101.75074, 5.79091], [101.69773, 5.75881], [101.58019, 5.93534], [101.25524, 5.78633], [101.25755, 5.71065], [101.14062, 5.61613], [100.98815, 5.79464], [101.02708, 5.91013], [101.087, 5.9193], [101.12388, 6.11411], [101.06165, 6.14161], [101.12618, 6.19431], [101.10313, 6.25617], [100.85884, 6.24929], [100.81045, 6.45086], [100.74822, 6.46231], [100.74361, 6.50811], [100.66986, 6.45086], [100.43027, 6.52389], [100.42351, 6.51762], [100.41791, 6.5189], [100.41152, 6.52299], [100.35413, 6.54932], [100.31929, 6.65413], [100.32607, 6.65933], [100.32671, 6.66526], [100.31884, 6.66423], [100.31618, 6.66781], [100.30828, 6.66462], [100.29651, 6.68439], [100.19511, 6.72559], [100.12, 6.42105], [100.0756, 6.4045], [99.91873, 6.50233], [99.50117, 6.44501], [99.31854, 5.99868], [99.75778, 3.86466], [103.03657, 1.30383], [103.56591, 1.19719], [103.62738, 1.35255], [103.67468, 1.43166], [103.7219, 1.46108], [103.74161, 1.4502], [103.76395, 1.45183], [103.81181, 1.47953], [103.86383, 1.46288], [103.89565, 1.42841], [103.93384, 1.42926], [104.00131, 1.42405], [104.02277, 1.4438], [104.04622, 1.44691], [104.07348, 1.43322], [104.08871, 1.42015], [104.09162, 1.39694], [104.08072, 1.35998], [104.12282, 1.27714], [104.34728, 1.33529], [104.56723, 1.44271], [105.01437, 3.24936], [102.46318, 7.22462]]]] } },
    { type: "Feature", properties: { wikidata: "Q2093907", nameEn: "Three Kings Islands", country: "NZ", groups: ["Q851132", "053", "009", "UN"], driveSide: "left" }, geometry: { type: "MultiPolygon", coordinates: [[[[174.17679, -32.62487], [170.93268, -32.97889], [171.97383, -34.64644], [174.17679, -32.62487]]]] } },
    { type: "Feature", properties: { wikidata: "Q2298216", nameEn: "Solander Islands", country: "NZ", groups: ["Q851132", "053", "009", "UN"], driveSide: "left" }, geometry: { type: "MultiPolygon", coordinates: [[[[167.39068, -46.49187], [166.5534, -46.39484], [166.84561, -46.84889], [167.39068, -46.49187]]]] } },
    { type: "Feature", properties: { wikidata: "Q2872203", nameEn: "Mainland Australia", country: "AU", groups: ["053", "009", "UN"], level: "subcountryGroup", driveSide: "left", callingCodes: ["61"] }, geometry: { type: "MultiPolygon", coordinates: [[[[88.16419, -23.49578], [123.64533, -39.13605], [159.74028, -39.1978], [159.76765, -29.76946], [154.02855, -24.43238], [152.93188, -20.92631], [147.69992, -17.5933], [145.2855, -9.62524], [143.87386, -9.02382], [143.29772, -9.33993], [142.48658, -9.36754], [142.19246, -9.15378], [141.88934, -9.36111], [141.01842, -9.35091], [135.49042, -9.2276], [127.55165, -9.05052], [125.29076, -12.33139], [88.16419, -23.49578]]]] } },
    { type: "Feature", properties: { wikidata: "Q2914565", nameEn: "Autonomous Regions of Portugal", country: "PT", level: "subcountryGroup" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q2915956", nameEn: "Mainland Portugal", country: "PT", groups: ["Q12837", "EU", "039", "150", "UN"], level: "subcountryGroup", callingCodes: ["351"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-10.39881, 36.12218], [-7.37282, 36.96896], [-7.39769, 37.16868], [-7.41133, 37.20314], [-7.41854, 37.23813], [-7.43227, 37.25152], [-7.43974, 37.38913], [-7.46878, 37.47127], [-7.51759, 37.56119], [-7.41981, 37.75729], [-7.33441, 37.81193], [-7.27314, 37.90145], [-7.24544, 37.98884], [-7.12648, 38.00296], [-7.10366, 38.04404], [-7.05966, 38.01966], [-7.00375, 38.01914], [-6.93418, 38.21454], [-7.09389, 38.17227], [-7.15581, 38.27597], [-7.32529, 38.44336], [-7.265, 38.61674], [-7.26174, 38.72107], [-7.03848, 38.87221], [-7.051, 38.907], [-6.95211, 39.0243], [-6.97004, 39.07619], [-7.04011, 39.11919], [-7.10692, 39.10275], [-7.14929, 39.11287], [-7.12811, 39.17101], [-7.23566, 39.20132], [-7.23403, 39.27579], [-7.3149, 39.34857], [-7.2927, 39.45847], [-7.49477, 39.58794], [-7.54121, 39.66717], [-7.33507, 39.64569], [-7.24707, 39.66576], [-7.01613, 39.66877], [-6.97492, 39.81488], [-6.91463, 39.86618], [-6.86737, 40.01986], [-6.94233, 40.10716], [-7.00589, 40.12087], [-7.02544, 40.18564], [-7.00426, 40.23169], [-6.86085, 40.26776], [-6.86085, 40.2976], [-6.80218, 40.33239], [-6.78426, 40.36468], [-6.84618, 40.42177], [-6.84944, 40.46394], [-6.7973, 40.51723], [-6.80218, 40.55067], [-6.84292, 40.56801], [-6.79567, 40.65955], [-6.82826, 40.74603], [-6.82337, 40.84472], [-6.79892, 40.84842], [-6.80707, 40.88047], [-6.84292, 40.89771], [-6.8527, 40.93958], [-6.9357, 41.02888], [-6.913, 41.03922], [-6.88843, 41.03027], [-6.84781, 41.02692], [-6.80942, 41.03629], [-6.79241, 41.05397], [-6.75655, 41.10187], [-6.77319, 41.13049], [-6.69711, 41.1858], [-6.68286, 41.21641], [-6.65046, 41.24725], [-6.55937, 41.24417], [-6.38551, 41.35274], [-6.38553, 41.38655], [-6.3306, 41.37677], [-6.26777, 41.48796], [-6.19128, 41.57638], [-6.29863, 41.66432], [-6.44204, 41.68258], [-6.49907, 41.65823], [-6.54633, 41.68623], [-6.56426, 41.74219], [-6.51374, 41.8758], [-6.56752, 41.88429], [-6.5447, 41.94371], [-6.58544, 41.96674], [-6.61967, 41.94008], [-6.75004, 41.94129], [-6.76959, 41.98734], [-6.81196, 41.99097], [-6.82174, 41.94493], [-6.94396, 41.94403], [-6.95537, 41.96553], [-6.98144, 41.9728], [-7.01078, 41.94977], [-7.07596, 41.94977], [-7.08574, 41.97401], [-7.14115, 41.98855], [-7.18549, 41.97515], [-7.18677, 41.88793], [-7.32366, 41.8406], [-7.37092, 41.85031], [-7.42864, 41.80589], [-7.42854, 41.83262], [-7.44759, 41.84451], [-7.45566, 41.86488], [-7.49803, 41.87095], [-7.52737, 41.83939], [-7.62188, 41.83089], [-7.58603, 41.87944], [-7.65774, 41.88308], [-7.69848, 41.90977], [-7.84188, 41.88065], [-7.88055, 41.84571], [-7.88751, 41.92553], [-7.90707, 41.92432], [-7.92336, 41.8758], [-7.9804, 41.87337], [-8.01136, 41.83453], [-8.0961, 41.81024], [-8.16455, 41.81753], [-8.16944, 41.87944], [-8.19551, 41.87459], [-8.2185, 41.91237], [-8.16232, 41.9828], [-8.08796, 42.01398], [-8.08847, 42.05767], [-8.11729, 42.08537], [-8.18178, 42.06436], [-8.19406, 42.12141], [-8.18947, 42.13853], [-8.1986, 42.15402], [-8.22406, 42.1328], [-8.24681, 42.13993], [-8.2732, 42.12396], [-8.29809, 42.106], [-8.32161, 42.10218], [-8.33912, 42.08358], [-8.36353, 42.09065], [-8.38323, 42.07683], [-8.40143, 42.08052], [-8.42512, 42.07199], [-8.44123, 42.08218], [-8.48185, 42.0811], [-8.52837, 42.07658], [-8.5252, 42.06264], [-8.54563, 42.0537], [-8.58086, 42.05147], [-8.59493, 42.05708], [-8.63791, 42.04691], [-8.64626, 42.03668], [-8.65832, 42.02972], [-8.6681, 41.99703], [-8.69071, 41.98862], [-8.7478, 41.96282], [-8.74606, 41.9469], [-8.75712, 41.92833], [-8.81794, 41.90375], [-8.87157, 41.86488], [-11.19304, 41.83075], [-10.39881, 36.12218]]]] } },
    { type: "Feature", properties: { wikidata: "Q3311985", nameEn: "Guernsey", country: "GB", groups: ["GG", "830", "Q185086", "154", "150", "UN"], level: "subterritory", driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["44 01481"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-2.49556, 49.79012], [-3.28154, 49.57329], [-2.65349, 49.15373], [-2.36485, 49.48223], [-2.49556, 49.79012]]]] } },
    { type: "Feature", properties: { wikidata: "Q3320166", nameEn: "Outermost Regions of the EU", aliases: ["OMR"], level: "subunion" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q3336843", nameEn: "Countries of the United Kingdom", aliases: ["GB-UKM"], country: "GB", level: "subcountryGroup" }, geometry: null },
    { type: "Feature", properties: { wikidata: "Q6736667", nameEn: "Mainland India", country: "IN", groups: ["034", "142", "UN"], driveSide: "left", callingCodes: ["91"] }, geometry: { type: "MultiPolygon", coordinates: [[[[89.08044, 21.41871], [89.07114, 22.15335], [88.9367, 22.58527], [88.94614, 22.66941], [88.9151, 22.75228], [88.96713, 22.83346], [88.87063, 22.95235], [88.88327, 23.03885], [88.86377, 23.08759], [88.99148, 23.21134], [88.71133, 23.2492], [88.79254, 23.46028], [88.79351, 23.50535], [88.74841, 23.47361], [88.56507, 23.64044], [88.58087, 23.87105], [88.66189, 23.87607], [88.73743, 23.91751], [88.6976, 24.14703], [88.74841, 24.1959], [88.68801, 24.31464], [88.50934, 24.32474], [88.12296, 24.51301], [88.08786, 24.63232], [88.00683, 24.66477], [88.15515, 24.85806], [88.14004, 24.93529], [88.21832, 24.96642], [88.27325, 24.88796], [88.33917, 24.86803], [88.46277, 25.07468], [88.44766, 25.20149], [88.94067, 25.18534], [89.00463, 25.26583], [89.01105, 25.30303], [88.85278, 25.34679], [88.81296, 25.51546], [88.677, 25.46959], [88.4559, 25.59227], [88.45103, 25.66245], [88.242, 25.80811], [88.13138, 25.78773], [88.08804, 25.91334], [88.16581, 26.0238], [88.1844, 26.14417], [88.34757, 26.22216], [88.35153, 26.29123], [88.51649, 26.35923], [88.48749, 26.45855], [88.36938, 26.48683], [88.35153, 26.45241], [88.33093, 26.48929], [88.41196, 26.63837], [88.4298, 26.54489], [88.62144, 26.46783], [88.69485, 26.38353], [88.67837, 26.26291], [88.78961, 26.31093], [88.85004, 26.23211], [89.05328, 26.2469], [88.91321, 26.37984], [88.92357, 26.40711], [88.95612, 26.4564], [89.08899, 26.38845], [89.15869, 26.13708], [89.35953, 26.0077], [89.53515, 26.00382], [89.57101, 25.9682], [89.63968, 26.22595], [89.70201, 26.15138], [89.73581, 26.15818], [89.77865, 26.08387], [89.77728, 26.04254], [89.86592, 25.93115], [89.80585, 25.82489], [89.84388, 25.70042], [89.86129, 25.61714], [89.81208, 25.37244], [89.84086, 25.31854], [89.83371, 25.29548], [89.87629, 25.28337], [89.90478, 25.31038], [90.1155, 25.22686], [90.40034, 25.1534], [90.65042, 25.17788], [90.87427, 25.15799], [91.25517, 25.20677], [91.63648, 25.12846], [92.0316, 25.1834], [92.33957, 25.07593], [92.39147, 25.01471], [92.49887, 24.88796], [92.38626, 24.86055], [92.25854, 24.9191], [92.15796, 24.54435], [92.11662, 24.38997], [91.96603, 24.3799], [91.89258, 24.14674], [91.82596, 24.22345], [91.76004, 24.23848], [91.73257, 24.14703], [91.65292, 24.22095], [91.63782, 24.1132], [91.55542, 24.08687], [91.37414, 24.10693], [91.35741, 23.99072], [91.29587, 24.0041], [91.22308, 23.89616], [91.25192, 23.83463], [91.15579, 23.6599], [91.28293, 23.37538], [91.36453, 23.06612], [91.40848, 23.07117], [91.4035, 23.27522], [91.46615, 23.2328], [91.54993, 23.01051], [91.61571, 22.93929], [91.7324, 23.00043], [91.81634, 23.08001], [91.76417, 23.26619], [91.84789, 23.42235], [91.95642, 23.47361], [91.95093, 23.73284], [92.04706, 23.64229], [92.15417, 23.73409], [92.26541, 23.70392], [92.38214, 23.28705], [92.37665, 22.9435], [92.5181, 22.71441], [92.60029, 22.1522], [92.56616, 22.13554], [92.60949, 21.97638], [92.67532, 22.03547], [92.70416, 22.16017], [92.86208, 22.05456], [92.89504, 21.95143], [92.93899, 22.02656], [92.99804, 21.98964], [92.99255, 22.05965], [93.04885, 22.20595], [93.15734, 22.18687], [93.14224, 22.24535], [93.19991, 22.25425], [93.18206, 22.43716], [93.13537, 22.45873], [93.11477, 22.54374], [93.134, 22.59573], [93.09417, 22.69459], [93.134, 22.92498], [93.12988, 23.05772], [93.2878, 23.00464], [93.38478, 23.13698], [93.36862, 23.35426], [93.38781, 23.36139], [93.39981, 23.38828], [93.38805, 23.4728], [93.43475, 23.68299], [93.3908, 23.7622], [93.3908, 23.92925], [93.36059, 23.93176], [93.32351, 24.04468], [93.34735, 24.10151], [93.41415, 24.07854], [93.46633, 23.97067], [93.50616, 23.94432], [93.62871, 24.00922], [93.75952, 24.0003], [93.80279, 23.92549], [93.92089, 23.95812], [94.14081, 23.83333], [94.30215, 24.23752], [94.32362, 24.27692], [94.45279, 24.56656], [94.50729, 24.59281], [94.5526, 24.70764], [94.60204, 24.70889], [94.73937, 25.00545], [94.74212, 25.13606], [94.57458, 25.20318], [94.68032, 25.47003], [94.80117, 25.49359], [95.18556, 26.07338], [95.11428, 26.1019], [95.12801, 26.38397], [95.05798, 26.45408], [95.23513, 26.68499], [95.30339, 26.65372], [95.437, 26.7083], [95.81603, 27.01335], [95.93002, 27.04149], [96.04949, 27.19428], [96.15591, 27.24572], [96.40779, 27.29818], [96.55761, 27.29928], [96.73888, 27.36638], [96.88445, 27.25046], [96.85287, 27.2065], [96.89132, 27.17474], [97.14675, 27.09041], [97.17422, 27.14052], [96.91431, 27.45752], [96.90112, 27.62149], [97.29919, 27.92233], [97.35824, 27.87256], [97.38845, 28.01329], [97.35412, 28.06663], [97.31292, 28.06784], [97.34547, 28.21385], [97.1289, 28.3619], [96.98882, 28.32564], [96.88445, 28.39452], [96.85561, 28.4875], [96.6455, 28.61657], [96.48895, 28.42955], [96.40929, 28.51526], [96.61391, 28.72742], [96.3626, 29.10607], [96.20467, 29.02325], [96.18682, 29.11087], [96.31316, 29.18643], [96.05361, 29.38167], [95.84899, 29.31464], [95.75149, 29.32063], [95.72086, 29.20797], [95.50842, 29.13487], [95.41091, 29.13007], [95.3038, 29.13847], [95.26122, 29.07727], [95.2214, 29.10727], [95.11291, 29.09527], [95.0978, 29.14446], [94.81353, 29.17804], [94.69318, 29.31739], [94.2752, 29.11687], [94.35897, 29.01965], [93.72797, 28.68821], [93.44621, 28.67189], [93.18069, 28.50319], [93.14635, 28.37035], [92.93075, 28.25671], [92.67486, 28.15018], [92.65472, 28.07632], [92.73025, 28.05814], [92.7275, 27.98662], [92.42538, 27.80092], [92.32101, 27.79363], [92.27432, 27.89077], [91.87057, 27.7195], [91.84722, 27.76325], [91.6469, 27.76358], [91.55819, 27.6144], [91.65007, 27.48287], [92.01132, 27.47352], [92.12019, 27.27829], [92.04702, 27.26861], [92.03457, 27.07334], [92.11863, 26.893], [92.05523, 26.8692], [91.83181, 26.87318], [91.50067, 26.79223], [90.67715, 26.77215], [90.48504, 26.8594], [90.39271, 26.90704], [90.30402, 26.85098], [90.04535, 26.72422], [89.86124, 26.73307], [89.63369, 26.74402], [89.42349, 26.83727], [89.3901, 26.84225], [89.38319, 26.85963], [89.37913, 26.86224], [89.1926, 26.81329], [89.12825, 26.81661], [89.09554, 26.89089], [88.95807, 26.92668], [88.92301, 26.99286], [88.8714, 26.97488], [88.86984, 27.10937], [88.74219, 27.144], [88.91901, 27.32483], [88.82981, 27.38814], [88.77517, 27.45415], [88.88091, 27.85192], [88.83559, 28.01936], [88.63235, 28.12356], [88.54858, 28.06057], [88.25332, 27.9478], [88.1278, 27.95417], [88.13378, 27.88015], [88.1973, 27.85067], [88.19107, 27.79285], [88.04008, 27.49223], [88.07277, 27.43007], [88.01646, 27.21612], [88.01587, 27.21388], [87.9887, 27.11045], [88.11719, 26.98758], [88.13422, 26.98705], [88.12302, 26.95324], [88.19107, 26.75516], [88.1659, 26.68177], [88.16452, 26.64111], [88.09963, 26.54195], [88.09414, 26.43732], [88.00895, 26.36029], [87.90115, 26.44923], [87.89085, 26.48565], [87.84193, 26.43663], [87.7918, 26.46737], [87.76004, 26.40711], [87.67893, 26.43501], [87.66803, 26.40294], [87.59175, 26.38342], [87.55274, 26.40596], [87.51571, 26.43106], [87.46566, 26.44058], [87.37314, 26.40815], [87.34568, 26.34787], [87.26568, 26.37294], [87.26587, 26.40592], [87.24682, 26.4143], [87.18863, 26.40558], [87.14751, 26.40542], [87.09147, 26.45039], [87.0707, 26.58571], [87.04691, 26.58685], [87.01559, 26.53228], [86.95912, 26.52076], [86.94543, 26.52076], [86.82898, 26.43919], [86.76797, 26.45892], [86.74025, 26.42386], [86.69124, 26.45169], [86.62686, 26.46891], [86.61313, 26.48658], [86.57073, 26.49825], [86.54258, 26.53819], [86.49726, 26.54218], [86.31564, 26.61925], [86.26235, 26.61886], [86.22513, 26.58863], [86.13596, 26.60651], [86.02729, 26.66756], [85.8492, 26.56667], [85.85126, 26.60866], [85.83126, 26.61134], [85.76907, 26.63076], [85.72315, 26.67471], [85.73483, 26.79613], [85.66239, 26.84822], [85.61621, 26.86721], [85.59461, 26.85161], [85.5757, 26.85955], [85.56471, 26.84133], [85.47752, 26.79292], [85.34302, 26.74954], [85.21159, 26.75933], [85.18046, 26.80519], [85.19291, 26.86909], [85.15883, 26.86966], [85.02635, 26.85381], [85.05592, 26.88991], [85.00536, 26.89523], [84.97186, 26.9149], [84.96687, 26.95599], [84.85754, 26.98984], [84.82913, 27.01989], [84.793, 26.9968], [84.64496, 27.04669], [84.69166, 27.21294], [84.62161, 27.33885], [84.29315, 27.39], [84.25735, 27.44941], [84.21376, 27.45218], [84.10791, 27.52399], [84.02229, 27.43836], [83.93306, 27.44939], [83.86182, 27.4241], [83.85595, 27.35797], [83.61288, 27.47013], [83.39495, 27.4798], [83.38872, 27.39276], [83.35136, 27.33885], [83.29999, 27.32778], [83.2673, 27.36235], [83.27197, 27.38309], [83.19413, 27.45632], [82.94938, 27.46036], [82.93261, 27.50328], [82.74119, 27.49838], [82.70378, 27.72122], [82.46405, 27.6716], [82.06554, 27.92222], [81.97214, 27.93322], [81.91223, 27.84995], [81.47867, 28.08303], [81.48179, 28.12148], [81.38683, 28.17638], [81.32923, 28.13521], [81.19847, 28.36284], [81.03471, 28.40054], [80.55142, 28.69182], [80.50575, 28.6706], [80.52443, 28.54897], [80.44504, 28.63098], [80.37188, 28.63371], [80.12125, 28.82346], [80.06957, 28.82763], [80.05743, 28.91479], [80.18085, 29.13649], [80.23178, 29.11626], [80.26602, 29.13938], [80.24112, 29.21414], [80.28626, 29.20327], [80.31428, 29.30784], [80.24322, 29.44299], [80.37939, 29.57098], [80.41858, 29.63581], [80.38428, 29.68513], [80.36803, 29.73865], [80.41554, 29.79451], [80.43458, 29.80466], [80.48997, 29.79566], [80.56247, 29.86661], [80.57179, 29.91422], [80.60226, 29.95732], [80.67076, 29.95732], [80.8778, 30.13384], [80.86673, 30.17321], [80.91143, 30.22173], [80.92547, 30.17193], [81.03953, 30.20059], [80.83343, 30.32023], [80.54504, 30.44936], [80.20721, 30.58541], [79.93255, 30.88288], [79.59884, 30.93943], [79.30694, 31.17357], [79.14016, 31.43403], [79.01931, 31.42817], [78.89344, 31.30481], [78.77898, 31.31209], [78.71032, 31.50197], [78.84516, 31.60631], [78.69933, 31.78723], [78.78036, 31.99478], [78.74404, 32.00384], [78.68754, 32.10256], [78.49609, 32.2762], [78.4645, 32.45367], [78.38897, 32.53938], [78.73916, 32.69438], [78.7831, 32.46873], [78.96713, 32.33655], [78.99322, 32.37948], [79.0979, 32.38051], [79.13174, 32.47766], [79.26768, 32.53277], [79.46562, 32.69668], [79.14016, 33.02545], [79.15252, 33.17156], [78.73636, 33.56521], [78.67599, 33.66445], [78.77349, 33.73871], [78.73367, 34.01121], [78.65657, 34.03195], [78.66225, 34.08858], [78.91769, 34.15452], [78.99802, 34.3027], [79.05364, 34.32482], [78.74465, 34.45174], [78.56475, 34.50835], [78.54964, 34.57283], [78.27781, 34.61484], [78.18435, 34.7998], [78.22692, 34.88771], [78.00033, 35.23954], [78.03466, 35.3785], [78.11664, 35.48022], [77.80532, 35.52058], [77.70232, 35.46244], [77.44277, 35.46132], [76.96624, 35.5932], [76.84539, 35.67356], [76.77323, 35.66062], [76.75475, 35.52617], [76.85088, 35.39754], [76.93465, 35.39866], [77.11796, 35.05419], [76.99251, 34.93349], [76.87193, 34.96906], [76.74514, 34.92488], [76.74377, 34.84039], [76.67648, 34.76371], [76.47186, 34.78965], [76.15463, 34.6429], [76.04614, 34.67566], [75.75438, 34.51827], [75.38009, 34.55021], [75.01479, 34.64629], [74.6663, 34.703], [74.58083, 34.77386], [74.31239, 34.79626], [74.12897, 34.70073], [73.96423, 34.68244], [73.93401, 34.63386], [73.93951, 34.57169], [73.89419, 34.54568], [73.88732, 34.48911], [73.74999, 34.3781], [73.74862, 34.34183], [73.8475, 34.32935], [73.90517, 34.35317], [73.98208, 34.2522], [73.90677, 34.10504], [73.88732, 34.05105], [73.91341, 34.01235], [74.21554, 34.03853], [74.25262, 34.01577], [74.26086, 33.92237], [74.14001, 33.83002], [74.05898, 33.82089], [74.00891, 33.75437], [73.96423, 33.73071], [73.98968, 33.66155], [73.97367, 33.64061], [74.03576, 33.56718], [74.10115, 33.56392], [74.18121, 33.4745], [74.17983, 33.3679], [74.08782, 33.26232], [74.01366, 33.25199], [74.02144, 33.18908], [74.15374, 33.13477], [74.17571, 33.07495], [74.31854, 33.02891], [74.34875, 32.97823], [74.31227, 32.92795], [74.41467, 32.90563], [74.45312, 32.77755], [74.6289, 32.75561], [74.64675, 32.82604], [74.7113, 32.84219], [74.65345, 32.71225], [74.69542, 32.66792], [74.64424, 32.60985], [74.65251, 32.56416], [74.67431, 32.56676], [74.68362, 32.49298], [74.84725, 32.49075], [74.97634, 32.45367], [75.03265, 32.49538], [75.28259, 32.36556], [75.38046, 32.26836], [75.25649, 32.10187], [75.00793, 32.03786], [74.9269, 32.0658], [74.86236, 32.04485], [74.79919, 31.95983], [74.58907, 31.87824], [74.47771, 31.72227], [74.57498, 31.60382], [74.61517, 31.55698], [74.59319, 31.50197], [74.64713, 31.45605], [74.59773, 31.4136], [74.53223, 31.30321], [74.51629, 31.13829], [74.56023, 31.08303], [74.60281, 31.10419], [74.60006, 31.13711], [74.6852, 31.12771], [74.67971, 31.05479], [74.5616, 31.04153], [73.88993, 30.36305], [73.95736, 30.28466], [73.97225, 30.19829], [73.80299, 30.06969], [73.58665, 30.01848], [73.3962, 29.94707], [73.28094, 29.56646], [73.05886, 29.1878], [73.01337, 29.16422], [72.94272, 29.02487], [72.40402, 28.78283], [72.29495, 28.66367], [72.20329, 28.3869], [71.9244, 28.11555], [71.89921, 27.96035], [70.79054, 27.68423], [70.60927, 28.02178], [70.37307, 28.01208], [70.12502, 27.8057], [70.03136, 27.56627], [69.58519, 27.18109], [69.50904, 26.74892], [69.88555, 26.56836], [70.05584, 26.60398], [70.17532, 26.55362], [70.17532, 26.24118], [70.08193, 26.08094], [70.0985, 25.93238], [70.2687, 25.71156], [70.37444, 25.67443], [70.53649, 25.68928], [70.60378, 25.71898], [70.67382, 25.68186], [70.66695, 25.39314], [70.89148, 25.15064], [70.94002, 24.92843], [71.09405, 24.69017], [70.97594, 24.60904], [71.00341, 24.46038], [71.12838, 24.42662], [71.04461, 24.34657], [70.94985, 24.3791], [70.85784, 24.30903], [70.88393, 24.27398], [70.71502, 24.23517], [70.57906, 24.27774], [70.5667, 24.43787], [70.11712, 24.30915], [70.03428, 24.172], [69.73335, 24.17007], [69.59579, 24.29777], [69.29778, 24.28712], [69.19341, 24.25646], [69.07806, 24.29777], [68.97781, 24.26021], [68.90914, 24.33156], [68.7416, 24.31904], [68.74643, 23.97027], [68.39339, 23.96838], [68.20763, 23.85849], [68.11329, 23.53945], [76.59015, 5.591], [79.50447, 8.91876], [79.42124, 9.80115], [80.48418, 10.20786], [89.08044, 21.41871]]]] } },
    { type: "Feature", properties: { wikidata: "Q9143535", nameEn: "Akrotiri", country: "GB", groups: ["Q644636", "Q37362", "BOTS", "145", "142", "UN"], level: "subterritory", driveSide: "left", callingCodes: ["357"] }, geometry: { type: "MultiPolygon", coordinates: [[[[32.86014, 34.70585], [32.82717, 34.70622], [32.79433, 34.67883], [32.76136, 34.68318], [32.75515, 34.64985], [32.74412, 34.43926], [33.26744, 34.49942], [33.0138, 34.64424], [32.96968, 34.64046], [32.96718, 34.63446], [32.95891, 34.62919], [32.95323, 34.64075], [32.95471, 34.64528], [32.94976, 34.65204], [32.94796, 34.6587], [32.95325, 34.66462], [32.97079, 34.66112], [32.97736, 34.65277], [32.99014, 34.65518], [32.98668, 34.67268], [32.99135, 34.68061], [32.95539, 34.68471], [32.94683, 34.67907], [32.94379, 34.67111], [32.93693, 34.67027], [32.93449, 34.66241], [32.92807, 34.66736], [32.93043, 34.67091], [32.91398, 34.67343], [32.9068, 34.66102], [32.86167, 34.68734], [32.86014, 34.70585]]]] } },
    { type: "Feature", properties: { wikidata: "Q9206745", nameEn: "Dhekelia", country: "GB", groups: ["Q644636", "Q37362", "BOTS", "145", "142", "UN"], level: "subterritory", driveSide: "left", callingCodes: ["357"] }, geometry: { type: "MultiPolygon", coordinates: [[[[33.70575, 34.97947], [33.83531, 34.73974], [33.98684, 34.76642], [33.90075, 34.96623], [33.86432, 34.97592], [33.84811, 34.97075], [33.83505, 34.98108], [33.85621, 34.98956], [33.85891, 35.001], [33.85216, 35.00579], [33.84045, 35.00616], [33.82875, 35.01685], [33.83055, 35.02865], [33.81524, 35.04192], [33.8012, 35.04786], [33.82051, 35.0667], [33.8355, 35.05777], [33.85261, 35.0574], [33.88367, 35.07877], [33.89485, 35.06873], [33.90247, 35.07686], [33.91299, 35.07579], [33.91789, 35.08688], [33.89853, 35.11377], [33.88737, 35.11408], [33.88943, 35.12007], [33.88561, 35.12449], [33.87224, 35.12293], [33.87622, 35.10457], [33.87097, 35.09389], [33.87479, 35.08881], [33.8541, 35.07201], [33.84168, 35.06823], [33.82067, 35.07826], [33.78581, 35.05104], [33.76106, 35.04253], [33.73824, 35.05321], [33.71482, 35.03722], [33.70209, 35.04882], [33.7161, 35.07279], [33.70861, 35.07644], [33.69095, 35.06237], [33.68474, 35.06602], [33.67742, 35.05963], [33.67678, 35.03866], [33.69938, 35.03123], [33.69731, 35.01754], [33.71514, 35.00294], [33.70639, 34.99303], [33.70575, 34.97947]], [[33.77312, 34.9976], [33.77553, 34.99518], [33.78516, 34.99582], [33.79191, 34.98914], [33.78917, 34.98854], [33.78571, 34.98951], [33.78318, 34.98699], [33.78149, 34.98854], [33.77843, 34.988], [33.7778, 34.98981], [33.76738, 34.99188], [33.76605, 34.99543], [33.75682, 34.99916], [33.75994, 35.00113], [33.77312, 34.9976]], [[33.74144, 35.01053], [33.7343, 35.01178], [33.73781, 35.02181], [33.74265, 35.02329], [33.74983, 35.02274], [33.7492, 35.01319], [33.74144, 35.01053]]]] } },
    { type: "Feature", properties: { wikidata: "Q16390686", nameEn: "Peninsular Spain", country: "ES", groups: ["Q12837", "EU", "039", "150", "UN"], callingCodes: ["34"] }, geometry: { type: "MultiPolygon", coordinates: [[[[3.75438, 42.33445], [3.17156, 42.43545], [3.11379, 42.43646], [3.10027, 42.42621], [3.08167, 42.42748], [3.03734, 42.47363], [2.96518, 42.46692], [2.94283, 42.48174], [2.92107, 42.4573], [2.88413, 42.45938], [2.86983, 42.46843], [2.85675, 42.45444], [2.84335, 42.45724], [2.77464, 42.41046], [2.75497, 42.42578], [2.72056, 42.42298], [2.65311, 42.38771], [2.6747, 42.33974], [2.57934, 42.35808], [2.55516, 42.35351], [2.54382, 42.33406], [2.48457, 42.33933], [2.43508, 42.37568], [2.43299, 42.39423], [2.38504, 42.39977], [2.25551, 42.43757], [2.20578, 42.41633], [2.16599, 42.42314], [2.12789, 42.41291], [2.11621, 42.38393], [2.06241, 42.35906], [2.00488, 42.35399], [1.96482, 42.37787], [1.9574, 42.42401], [1.94084, 42.43039], [1.94061, 42.43333], [1.94292, 42.44316], [1.93663, 42.45439], [1.88853, 42.4501], [1.83037, 42.48395], [1.76335, 42.48863], [1.72515, 42.50338], [1.70571, 42.48867], [1.66826, 42.50779], [1.65674, 42.47125], [1.58933, 42.46275], [1.57953, 42.44957], [1.55937, 42.45808], [1.55073, 42.43299], [1.5127, 42.42959], [1.44529, 42.43724], [1.43838, 42.47848], [1.41648, 42.48315], [1.46661, 42.50949], [1.44759, 42.54431], [1.41245, 42.53539], [1.4234, 42.55959], [1.44529, 42.56722], [1.42512, 42.58292], [1.44197, 42.60217], [1.35562, 42.71944], [1.15928, 42.71407], [1.0804, 42.78569], [0.98292, 42.78754], [0.96166, 42.80629], [0.93089, 42.79154], [0.711, 42.86372], [0.66121, 42.84021], [0.65421, 42.75872], [0.67873, 42.69458], [0.40214, 42.69779], [0.36251, 42.72282], [0.29407, 42.67431], [0.25336, 42.7174], [0.17569, 42.73424], [-0.02468, 42.68513], [-0.10519, 42.72761], [-0.16141, 42.79535], [-0.17939, 42.78974], [-0.3122, 42.84788], [-0.38833, 42.80132], [-0.41319, 42.80776], [-0.44334, 42.79939], [-0.50863, 42.82713], [-0.55497, 42.77846], [-0.67637, 42.88303], [-0.69837, 42.87945], [-0.72608, 42.89318], [-0.73422, 42.91228], [-0.72037, 42.92541], [-0.75478, 42.96916], [-0.81652, 42.95166], [-0.97133, 42.96239], [-1.00963, 42.99279], [-1.10333, 43.0059], [-1.22881, 43.05534], [-1.25244, 43.04164], [-1.30531, 43.06859], [-1.30052, 43.09581], [-1.27118, 43.11961], [-1.32209, 43.1127], [-1.34419, 43.09665], [-1.35272, 43.02658], [-1.44067, 43.047], [-1.47555, 43.08372], [-1.41562, 43.12815], [-1.3758, 43.24511], [-1.40942, 43.27272], [-1.45289, 43.27049], [-1.50992, 43.29481], [-1.55963, 43.28828], [-1.57674, 43.25269], [-1.61341, 43.25269], [-1.63052, 43.28591], [-1.62481, 43.30726], [-1.69407, 43.31378], [-1.73074, 43.29481], [-1.7397, 43.32979], [-1.75079, 43.3317], [-1.75334, 43.34107], [-1.77068, 43.34396], [-1.78714, 43.35476], [-1.78332, 43.36399], [-1.79319, 43.37497], [-1.77289, 43.38957], [-1.81005, 43.59738], [-10.14298, 44.17365], [-11.19304, 41.83075], [-8.87157, 41.86488], [-8.81794, 41.90375], [-8.75712, 41.92833], [-8.74606, 41.9469], [-8.7478, 41.96282], [-8.69071, 41.98862], [-8.6681, 41.99703], [-8.65832, 42.02972], [-8.64626, 42.03668], [-8.63791, 42.04691], [-8.59493, 42.05708], [-8.58086, 42.05147], [-8.54563, 42.0537], [-8.5252, 42.06264], [-8.52837, 42.07658], [-8.48185, 42.0811], [-8.44123, 42.08218], [-8.42512, 42.07199], [-8.40143, 42.08052], [-8.38323, 42.07683], [-8.36353, 42.09065], [-8.33912, 42.08358], [-8.32161, 42.10218], [-8.29809, 42.106], [-8.2732, 42.12396], [-8.24681, 42.13993], [-8.22406, 42.1328], [-8.1986, 42.15402], [-8.18947, 42.13853], [-8.19406, 42.12141], [-8.18178, 42.06436], [-8.11729, 42.08537], [-8.08847, 42.05767], [-8.08796, 42.01398], [-8.16232, 41.9828], [-8.2185, 41.91237], [-8.19551, 41.87459], [-8.16944, 41.87944], [-8.16455, 41.81753], [-8.0961, 41.81024], [-8.01136, 41.83453], [-7.9804, 41.87337], [-7.92336, 41.8758], [-7.90707, 41.92432], [-7.88751, 41.92553], [-7.88055, 41.84571], [-7.84188, 41.88065], [-7.69848, 41.90977], [-7.65774, 41.88308], [-7.58603, 41.87944], [-7.62188, 41.83089], [-7.52737, 41.83939], [-7.49803, 41.87095], [-7.45566, 41.86488], [-7.44759, 41.84451], [-7.42854, 41.83262], [-7.42864, 41.80589], [-7.37092, 41.85031], [-7.32366, 41.8406], [-7.18677, 41.88793], [-7.18549, 41.97515], [-7.14115, 41.98855], [-7.08574, 41.97401], [-7.07596, 41.94977], [-7.01078, 41.94977], [-6.98144, 41.9728], [-6.95537, 41.96553], [-6.94396, 41.94403], [-6.82174, 41.94493], [-6.81196, 41.99097], [-6.76959, 41.98734], [-6.75004, 41.94129], [-6.61967, 41.94008], [-6.58544, 41.96674], [-6.5447, 41.94371], [-6.56752, 41.88429], [-6.51374, 41.8758], [-6.56426, 41.74219], [-6.54633, 41.68623], [-6.49907, 41.65823], [-6.44204, 41.68258], [-6.29863, 41.66432], [-6.19128, 41.57638], [-6.26777, 41.48796], [-6.3306, 41.37677], [-6.38553, 41.38655], [-6.38551, 41.35274], [-6.55937, 41.24417], [-6.65046, 41.24725], [-6.68286, 41.21641], [-6.69711, 41.1858], [-6.77319, 41.13049], [-6.75655, 41.10187], [-6.79241, 41.05397], [-6.80942, 41.03629], [-6.84781, 41.02692], [-6.88843, 41.03027], [-6.913, 41.03922], [-6.9357, 41.02888], [-6.8527, 40.93958], [-6.84292, 40.89771], [-6.80707, 40.88047], [-6.79892, 40.84842], [-6.82337, 40.84472], [-6.82826, 40.74603], [-6.79567, 40.65955], [-6.84292, 40.56801], [-6.80218, 40.55067], [-6.7973, 40.51723], [-6.84944, 40.46394], [-6.84618, 40.42177], [-6.78426, 40.36468], [-6.80218, 40.33239], [-6.86085, 40.2976], [-6.86085, 40.26776], [-7.00426, 40.23169], [-7.02544, 40.18564], [-7.00589, 40.12087], [-6.94233, 40.10716], [-6.86737, 40.01986], [-6.91463, 39.86618], [-6.97492, 39.81488], [-7.01613, 39.66877], [-7.24707, 39.66576], [-7.33507, 39.64569], [-7.54121, 39.66717], [-7.49477, 39.58794], [-7.2927, 39.45847], [-7.3149, 39.34857], [-7.23403, 39.27579], [-7.23566, 39.20132], [-7.12811, 39.17101], [-7.14929, 39.11287], [-7.10692, 39.10275], [-7.04011, 39.11919], [-6.97004, 39.07619], [-6.95211, 39.0243], [-7.051, 38.907], [-7.03848, 38.87221], [-7.26174, 38.72107], [-7.265, 38.61674], [-7.32529, 38.44336], [-7.15581, 38.27597], [-7.09389, 38.17227], [-6.93418, 38.21454], [-7.00375, 38.01914], [-7.05966, 38.01966], [-7.10366, 38.04404], [-7.12648, 38.00296], [-7.24544, 37.98884], [-7.27314, 37.90145], [-7.33441, 37.81193], [-7.41981, 37.75729], [-7.51759, 37.56119], [-7.46878, 37.47127], [-7.43974, 37.38913], [-7.43227, 37.25152], [-7.41854, 37.23813], [-7.41133, 37.20314], [-7.39769, 37.16868], [-7.37282, 36.96896], [-7.2725, 35.73269], [-5.10878, 36.05227], [-2.27707, 35.35051], [3.75438, 42.33445]], [[-5.27801, 36.14942], [-5.34064, 36.03744], [-5.40526, 36.15488], [-5.34536, 36.15501], [-5.33822, 36.15272], [-5.27801, 36.14942]]], [[[1.99838, 42.44682], [2.01564, 42.45171], [1.99216, 42.46208], [1.98579, 42.47486], [1.99766, 42.4858], [1.98916, 42.49351], [1.98022, 42.49569], [1.97697, 42.48568], [1.97227, 42.48487], [1.97003, 42.48081], [1.96215, 42.47854], [1.95606, 42.45785], [1.96125, 42.45364], [1.98378, 42.44697], [1.99838, 42.44682]]]] } },
    { type: "Feature", properties: { wikidata: "Q98059339", nameEn: "Mainland Norway", country: "NO", groups: ["154", "150", "UN"], callingCodes: ["47"] }, geometry: { type: "MultiPolygon", coordinates: [[[[10.40861, 58.38489], [10.64958, 58.89391], [11.08911, 58.98745], [11.15367, 59.07862], [11.34459, 59.11672], [11.4601, 58.99022], [11.45199, 58.89604], [11.65732, 58.90177], [11.8213, 59.24985], [11.69297, 59.59442], [11.92112, 59.69531], [11.87121, 59.86039], [12.15641, 59.8926], [12.36317, 59.99259], [12.52003, 60.13846], [12.59133, 60.50559], [12.2277, 61.02442], [12.69115, 61.06584], [12.86939, 61.35427], [12.57707, 61.56547], [12.40595, 61.57226], [12.14746, 61.7147], [12.29187, 62.25699], [12.07085, 62.6297], [12.19919, 63.00104], [11.98529, 63.27487], [12.19919, 63.47935], [12.14928, 63.59373], [12.74105, 64.02171], [13.23411, 64.09087], [13.98222, 64.00953], [14.16051, 64.18725], [14.11117, 64.46674], [13.64276, 64.58402], [14.50926, 65.31786], [14.53778, 66.12399], [15.05113, 66.15572], [15.49318, 66.28509], [15.37197, 66.48217], [16.35589, 67.06419], [16.39154, 67.21653], [16.09922, 67.4364], [16.12774, 67.52106], [16.38441, 67.52923], [16.7409, 67.91037], [17.30416, 68.11591], [17.90787, 67.96537], [18.13836, 68.20874], [18.1241, 68.53721], [18.39503, 68.58672], [18.63032, 68.50849], [18.97255, 68.52416], [19.93508, 68.35911], [20.22027, 68.48759], [19.95647, 68.55546], [20.22027, 68.67246], [20.33435, 68.80174], [20.28444, 68.93283], [20.0695, 69.04469], [20.55258, 69.06069], [20.72171, 69.11874], [21.05775, 69.0356], [21.11099, 69.10291], [20.98641, 69.18809], [21.00732, 69.22755], [21.27827, 69.31281], [21.63833, 69.27485], [22.27276, 68.89514], [22.38367, 68.71561], [22.53321, 68.74393], [23.13064, 68.64684], [23.68017, 68.70276], [23.781, 68.84514], [24.02299, 68.81601], [24.18432, 68.73936], [24.74898, 68.65143], [24.90023, 68.55579], [24.93048, 68.61102], [25.10189, 68.63307], [25.12206, 68.78684], [25.42455, 68.90328], [25.61613, 68.89602], [25.75729, 68.99383], [25.69679, 69.27039], [25.96904, 69.68397], [26.40261, 69.91377], [26.64461, 69.96565], [27.05802, 69.92069], [27.57226, 70.06215], [27.95542, 70.0965], [27.97558, 69.99671], [28.32849, 69.88605], [28.36883, 69.81658], [29.12697, 69.69193], [29.31664, 69.47994], [28.8629, 69.22395], [28.81248, 69.11997], [28.91738, 69.04774], [29.0444, 69.0119], [29.26623, 69.13794], [29.27631, 69.2811], [29.97205, 69.41623], [30.16363, 69.65244], [30.52662, 69.54699], [30.95011, 69.54699], [30.84095, 69.80584], [31.59909, 70.16571], [32.07813, 72.01005], [-11.60274, 67.73467], [7.28637, 57.35913], [10.40861, 58.38489]]]] } },
    { type: "Feature", properties: { wikidata: "Q98543636", nameEn: "Mainland Ecuador", country: "EC", groups: ["005", "419", "019", "UN"], callingCodes: ["593"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-84.52388, -3.36941], [-80.30602, -3.39149], [-80.20647, -3.431], [-80.24123, -3.46124], [-80.24586, -3.48677], [-80.23651, -3.48652], [-80.22629, -3.501], [-80.20535, -3.51667], [-80.21642, -3.5888], [-80.19848, -3.59249], [-80.18741, -3.63994], [-80.19926, -3.68894], [-80.13232, -3.90317], [-80.46386, -4.01342], [-80.4822, -4.05477], [-80.45023, -4.20938], [-80.32114, -4.21323], [-80.46386, -4.41516], [-80.39256, -4.48269], [-80.13945, -4.29786], [-79.79722, -4.47558], [-79.59402, -4.46848], [-79.26248, -4.95167], [-79.1162, -4.97774], [-79.01659, -5.01481], [-78.85149, -4.66795], [-78.68394, -4.60754], [-78.34362, -3.38633], [-78.24589, -3.39907], [-78.22642, -3.51113], [-78.14324, -3.47653], [-78.19369, -3.36431], [-77.94147, -3.05454], [-76.6324, -2.58397], [-76.05203, -2.12179], [-75.57429, -1.55961], [-75.3872, -0.9374], [-75.22862, -0.95588], [-75.22862, -0.60048], [-75.53615, -0.19213], [-75.60169, -0.18708], [-75.61997, -0.10012], [-75.40192, -0.17196], [-75.25764, -0.11943], [-75.82927, 0.09578], [-76.23441, 0.42294], [-76.41215, 0.38228], [-76.4094, 0.24015], [-76.89177, 0.24736], [-77.52001, 0.40782], [-77.49984, 0.64476], [-77.67815, 0.73863], [-77.66416, 0.81604], [-77.68613, 0.83029], [-77.7148, 0.85003], [-77.85677, 0.80197], [-78.42749, 1.15389], [-78.87137, 1.47457], [-82.12561, 4.00341], [-84.52388, -3.36941]]]] } },
    { type: "Feature", properties: { m49: "001", wikidata: "Q2", nameEn: "World", aliases: ["Earth", "Planet"], level: "world" }, geometry: null },
    { type: "Feature", properties: { m49: "002", wikidata: "Q15", nameEn: "Africa", level: "region" }, geometry: null },
    { type: "Feature", properties: { m49: "003", wikidata: "Q49", nameEn: "North America", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "005", wikidata: "Q18", nameEn: "South America", level: "intermediateRegion" }, geometry: null },
    { type: "Feature", properties: { m49: "009", wikidata: "Q538", nameEn: "Oceania", level: "region" }, geometry: null },
    { type: "Feature", properties: { m49: "011", wikidata: "Q4412", nameEn: "Western Africa", level: "intermediateRegion" }, geometry: null },
    { type: "Feature", properties: { m49: "013", wikidata: "Q27611", nameEn: "Central America", level: "intermediateRegion" }, geometry: null },
    { type: "Feature", properties: { m49: "014", wikidata: "Q27407", nameEn: "Eastern Africa", level: "intermediateRegion" }, geometry: null },
    { type: "Feature", properties: { m49: "015", wikidata: "Q27381", nameEn: "Northern Africa", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "017", wikidata: "Q27433", nameEn: "Middle Africa", level: "intermediateRegion" }, geometry: null },
    { type: "Feature", properties: { m49: "018", wikidata: "Q27394", nameEn: "Southern Africa", level: "intermediateRegion" }, geometry: null },
    { type: "Feature", properties: { m49: "019", wikidata: "Q828", nameEn: "Americas", level: "region" }, geometry: null },
    { type: "Feature", properties: { m49: "021", wikidata: "Q2017699", nameEn: "Northern America", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "029", wikidata: "Q664609", nameEn: "Caribbean", level: "intermediateRegion" }, geometry: null },
    { type: "Feature", properties: { m49: "030", wikidata: "Q27231", nameEn: "Eastern Asia", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "034", wikidata: "Q771405", nameEn: "Southern Asia", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "035", wikidata: "Q11708", nameEn: "South-eastern Asia", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "039", wikidata: "Q27449", nameEn: "Southern Europe", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "053", wikidata: "Q45256", nameEn: "Australia and New Zealand", aliases: ["Australasia"], level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "054", wikidata: "Q37394", nameEn: "Melanesia", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "057", wikidata: "Q3359409", nameEn: "Micronesia", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "061", wikidata: "Q35942", nameEn: "Polynesia", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "142", wikidata: "Q48", nameEn: "Asia", level: "region" }, geometry: null },
    { type: "Feature", properties: { m49: "143", wikidata: "Q27275", nameEn: "Central Asia", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "145", wikidata: "Q27293", nameEn: "Western Asia", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "150", wikidata: "Q46", nameEn: "Europe", level: "region" }, geometry: null },
    { type: "Feature", properties: { m49: "151", wikidata: "Q27468", nameEn: "Eastern Europe", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "154", wikidata: "Q27479", nameEn: "Northern Europe", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "155", wikidata: "Q27496", nameEn: "Western Europe", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "202", wikidata: "Q132959", nameEn: "Sub-Saharan Africa", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "419", wikidata: "Q72829598", nameEn: "Latin America and the Caribbean", level: "subregion" }, geometry: null },
    { type: "Feature", properties: { m49: "680", wikidata: "Q3405693", nameEn: "Sark", country: "GB", groups: ["GG", "830", "Q185086", "154", "150", "UN"], level: "subterritory", driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["44 01481"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-2.36485, 49.48223], [-2.65349, 49.15373], [-2.09454, 49.46288], [-2.36485, 49.48223]]]] } },
    { type: "Feature", properties: { m49: "830", wikidata: "Q42314", nameEn: "Channel Islands", level: "intermediateRegion" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "AC", iso1A3: "ASC", wikidata: "Q46197", nameEn: "Ascension Island", aliases: ["SH-AC"], country: "GB", groups: ["SH", "BOTS", "011", "202", "002", "UN"], isoStatus: "excRes", driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["247"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-14.82771, -8.70814], [-13.33271, -8.07391], [-14.91926, -6.63386], [-14.82771, -8.70814]]]] } },
    { type: "Feature", properties: { iso1A2: "AD", iso1A3: "AND", iso1N3: "020", wikidata: "Q228", nameEn: "Andorra", groups: ["Q12837", "039", "150", "UN"], callingCodes: ["376"] }, geometry: { type: "MultiPolygon", coordinates: [[[[1.72515, 42.50338], [1.73683, 42.55492], [1.7858, 42.57698], [1.72588, 42.59098], [1.73452, 42.61515], [1.68267, 42.62533], [1.6625, 42.61982], [1.63485, 42.62957], [1.60085, 42.62703], [1.55418, 42.65669], [1.50867, 42.64483], [1.48043, 42.65203], [1.46718, 42.63296], [1.47986, 42.61346], [1.44197, 42.60217], [1.42512, 42.58292], [1.44529, 42.56722], [1.4234, 42.55959], [1.41245, 42.53539], [1.44759, 42.54431], [1.46661, 42.50949], [1.41648, 42.48315], [1.43838, 42.47848], [1.44529, 42.43724], [1.5127, 42.42959], [1.55073, 42.43299], [1.55937, 42.45808], [1.57953, 42.44957], [1.58933, 42.46275], [1.65674, 42.47125], [1.66826, 42.50779], [1.70571, 42.48867], [1.72515, 42.50338]]]] } },
    { type: "Feature", properties: { iso1A2: "AE", iso1A3: "ARE", iso1N3: "784", wikidata: "Q878", nameEn: "United Arab Emirates", groups: ["145", "142", "UN"], callingCodes: ["971"] }, geometry: { type: "MultiPolygon", coordinates: [[[[56.26534, 25.62825], [56.25341, 25.61443], [56.26636, 25.60643], [56.25365, 25.60211], [56.20473, 25.61119], [56.18363, 25.65508], [56.14826, 25.66351], [56.13579, 25.73524], [56.17416, 25.77239], [56.13963, 25.82765], [56.19334, 25.9795], [56.15498, 26.06828], [56.08666, 26.05038], [55.81777, 26.18798], [55.14145, 25.62624], [53.97892, 24.64436], [52.82259, 25.51697], [52.35509, 25.00368], [52.02277, 24.75635], [51.83108, 24.71675], [51.58834, 24.66608], [51.41644, 24.39615], [51.58871, 24.27256], [51.59617, 24.12041], [52.56622, 22.94341], [55.13599, 22.63334], [55.2137, 22.71065], [55.22634, 23.10378], [55.57358, 23.669], [55.48677, 23.94946], [55.73301, 24.05994], [55.8308, 24.01633], [56.01799, 24.07426], [55.95472, 24.2172], [55.83367, 24.20193], [55.77658, 24.23476], [55.76558, 24.23227], [55.75257, 24.23466], [55.75382, 24.2466], [55.75939, 24.26114], [55.76781, 24.26209], [55.79145, 24.27914], [55.80747, 24.31069], [55.83395, 24.32776], [55.83271, 24.41521], [55.76461, 24.5287], [55.83271, 24.68567], [55.83408, 24.77858], [55.81348, 24.80102], [55.81116, 24.9116], [55.85094, 24.96858], [55.90849, 24.96771], [55.96316, 25.00857], [56.05715, 24.95727], [56.05106, 24.87461], [55.97467, 24.89639], [55.97836, 24.87673], [56.03535, 24.81161], [56.06128, 24.74457], [56.13684, 24.73699], [56.20062, 24.78565], [56.20568, 24.85063], [56.30269, 24.88334], [56.34873, 24.93205], [56.3227, 24.97284], [56.86325, 25.03856], [56.82555, 25.7713], [56.26534, 25.62825]], [[56.26062, 25.33108], [56.3005, 25.31815], [56.3111, 25.30107], [56.35172, 25.30681], [56.34438, 25.26653], [56.27628, 25.23404], [56.24341, 25.22867], [56.20872, 25.24104], [56.20838, 25.25668], [56.24465, 25.27505], [56.25008, 25.28843], [56.23362, 25.31253], [56.26062, 25.33108]]], [[[56.28423, 25.26344], [56.29379, 25.2754], [56.28102, 25.28486], [56.2716, 25.27916], [56.27086, 25.26128], [56.28423, 25.26344]]]] } },
    { type: "Feature", properties: { iso1A2: "AF", iso1A3: "AFG", iso1N3: "004", wikidata: "Q889", nameEn: "Afghanistan", groups: ["034", "142", "UN"], callingCodes: ["93"] }, geometry: { type: "MultiPolygon", coordinates: [[[[70.61526, 38.34774], [70.60407, 38.28046], [70.54673, 38.24541], [70.4898, 38.12546], [70.17206, 37.93276], [70.1863, 37.84296], [70.27694, 37.81258], [70.28243, 37.66706], [70.15015, 37.52519], [69.95971, 37.5659], [69.93362, 37.61378], [69.84435, 37.60616], [69.80041, 37.5746], [69.51888, 37.5844], [69.44954, 37.4869], [69.36645, 37.40462], [69.45022, 37.23315], [69.39529, 37.16752], [69.25152, 37.09426], [69.03274, 37.25174], [68.96407, 37.32603], [68.88168, 37.33368], [68.91189, 37.26704], [68.80889, 37.32494], [68.81438, 37.23862], [68.6798, 37.27906], [68.61851, 37.19815], [68.41888, 37.13906], [68.41201, 37.10402], [68.29253, 37.10621], [68.27605, 37.00977], [68.18542, 37.02074], [68.02194, 36.91923], [67.87917, 37.0591], [67.7803, 37.08978], [67.78329, 37.1834], [67.51868, 37.26102], [67.2581, 37.17216], [67.2224, 37.24545], [67.13039, 37.27168], [67.08232, 37.35469], [66.95598, 37.40162], [66.64699, 37.32958], [66.55743, 37.35409], [66.30993, 37.32409], [65.72274, 37.55438], [65.64137, 37.45061], [65.64263, 37.34388], [65.51778, 37.23881], [64.97945, 37.21913], [64.61141, 36.6351], [64.62514, 36.44311], [64.57295, 36.34362], [64.43288, 36.24401], [64.05385, 36.10433], [63.98519, 36.03773], [63.56496, 35.95106], [63.53475, 35.90881], [63.29579, 35.85985], [63.12276, 35.86208], [63.10318, 35.81782], [63.23262, 35.67487], [63.10079, 35.63024], [63.12276, 35.53196], [63.0898, 35.43131], [62.90853, 35.37086], [62.74098, 35.25432], [62.62288, 35.22067], [62.48006, 35.28796], [62.29878, 35.13312], [62.29191, 35.25964], [62.15871, 35.33278], [62.05709, 35.43803], [61.97743, 35.4604], [61.77693, 35.41341], [61.58742, 35.43803], [61.27371, 35.61482], [61.18187, 35.30249], [61.0991, 35.27845], [61.12831, 35.09938], [61.06926, 34.82139], [61.00197, 34.70631], [60.99922, 34.63064], [60.72316, 34.52857], [60.91321, 34.30411], [60.66502, 34.31539], [60.50209, 34.13992], [60.5838, 33.80793], [60.5485, 33.73422], [60.57762, 33.59772], [60.69573, 33.56054], [60.91133, 33.55596], [60.88908, 33.50219], [60.56485, 33.12944], [60.86191, 32.22565], [60.84541, 31.49561], [61.70929, 31.37391], [61.80569, 31.16167], [61.80957, 31.12576], [61.83257, 31.0452], [61.8335, 30.97669], [61.78268, 30.92724], [61.80829, 30.84224], [60.87231, 29.86514], [62.47751, 29.40782], [63.5876, 29.50456], [64.12966, 29.39157], [64.19796, 29.50407], [64.62116, 29.58903], [65.04005, 29.53957], [66.24175, 29.85181], [66.36042, 29.9583], [66.23609, 30.06321], [66.34869, 30.404], [66.28413, 30.57001], [66.39194, 30.9408], [66.42645, 30.95309], [66.58175, 30.97532], [66.68166, 31.07597], [66.72561, 31.20526], [66.83273, 31.26867], [67.04147, 31.31561], [67.03323, 31.24519], [67.29964, 31.19586], [67.78854, 31.33203], [67.7748, 31.4188], [67.62374, 31.40473], [67.58323, 31.52772], [67.72056, 31.52304], [67.86887, 31.63536], [68.00071, 31.6564], [68.1655, 31.82691], [68.25614, 31.80357], [68.27605, 31.75863], [68.44222, 31.76446], [68.57475, 31.83158], [68.6956, 31.75687], [68.79997, 31.61665], [68.91078, 31.59687], [68.95995, 31.64822], [69.00939, 31.62249], [69.11514, 31.70782], [69.20577, 31.85957], [69.3225, 31.93186], [69.27032, 32.14141], [69.27932, 32.29119], [69.23599, 32.45946], [69.2868, 32.53938], [69.38155, 32.56601], [69.44747, 32.6678], [69.43649, 32.7302], [69.38018, 32.76601], [69.47082, 32.85834], [69.5436, 32.8768], [69.49854, 32.88843], [69.49004, 33.01509], [69.57656, 33.09911], [69.71526, 33.09911], [69.79766, 33.13247], [69.85259, 33.09451], [70.02563, 33.14282], [70.07369, 33.22557], [70.13686, 33.21064], [70.32775, 33.34496], [70.17062, 33.53535], [70.20141, 33.64387], [70.14785, 33.6553], [70.14236, 33.71701], [70.00503, 33.73528], [69.85671, 33.93719], [69.87307, 33.9689], [69.90203, 34.04194], [70.54336, 33.9463], [70.88119, 33.97933], [71.07345, 34.06242], [71.06933, 34.10564], [71.09307, 34.11961], [71.09453, 34.13524], [71.13078, 34.16503], [71.12815, 34.26619], [71.17662, 34.36769], [71.02401, 34.44835], [71.0089, 34.54568], [71.11602, 34.63047], [71.08718, 34.69034], [71.28356, 34.80882], [71.29472, 34.87728], [71.50329, 34.97328], [71.49917, 35.00478], [71.55273, 35.02615], [71.52938, 35.09023], [71.67495, 35.21262], [71.5541, 35.28776], [71.54294, 35.31037], [71.65435, 35.4479], [71.49917, 35.6267], [71.55273, 35.71483], [71.37969, 35.95865], [71.19505, 36.04134], [71.60491, 36.39429], [71.80267, 36.49924], [72.18135, 36.71838], [72.6323, 36.84601], [73.82685, 36.91421], [74.04856, 36.82648], [74.43389, 37.00977], [74.53739, 36.96224], [74.56453, 37.03023], [74.49981, 37.24518], [74.80605, 37.21565], [74.88887, 37.23275], [74.8294, 37.3435], [74.68383, 37.3948], [74.56161, 37.37734], [74.41055, 37.3948], [74.23339, 37.41116], [74.20308, 37.34208], [73.8564, 37.26158], [73.82552, 37.22659], [73.64974, 37.23643], [73.61129, 37.27469], [73.76647, 37.33913], [73.77197, 37.4417], [73.29633, 37.46495], [73.06884, 37.31729], [72.79693, 37.22222], [72.66381, 37.02014], [72.54095, 37.00007], [72.31676, 36.98115], [71.83229, 36.68084], [71.67083, 36.67346], [71.57195, 36.74943], [71.51502, 36.89128], [71.48481, 36.93218], [71.46923, 36.99925], [71.45578, 37.03094], [71.43097, 37.05855], [71.44127, 37.11856], [71.4494, 37.18137], [71.4555, 37.21418], [71.47386, 37.2269], [71.48339, 37.23937], [71.4824, 37.24921], [71.48536, 37.26017], [71.50674, 37.31502], [71.49821, 37.31975], [71.4862, 37.33405], [71.47685, 37.40281], [71.49612, 37.4279], [71.5256, 37.47971], [71.50616, 37.50733], [71.49693, 37.53527], [71.5065, 37.60912], [71.51972, 37.61945], [71.54186, 37.69691], [71.55234, 37.73209], [71.53053, 37.76534], [71.54324, 37.77104], [71.55752, 37.78677], [71.59255, 37.79956], [71.58843, 37.92425], [71.51565, 37.95349], [71.32871, 37.88564], [71.296, 37.93403], [71.2809, 37.91995], [71.24969, 37.93031], [71.27278, 37.96496], [71.27622, 37.99946], [71.28922, 38.01272], [71.29878, 38.04429], [71.36444, 38.15358], [71.37803, 38.25641], [71.33869, 38.27335], [71.33114, 38.30339], [71.21291, 38.32797], [71.1451, 38.40106], [71.10957, 38.40671], [71.10592, 38.42077], [71.09542, 38.42517], [71.0556, 38.40176], [71.03545, 38.44779], [70.98693, 38.48862], [70.92728, 38.43021], [70.88719, 38.46826], [70.84376, 38.44688], [70.82538, 38.45394], [70.81697, 38.44507], [70.80521, 38.44447], [70.79766, 38.44944], [70.78702, 38.45031], [70.78581, 38.45502], [70.77132, 38.45548], [70.75455, 38.4252], [70.72485, 38.4131], [70.69807, 38.41861], [70.67438, 38.40597], [70.6761, 38.39144], [70.69189, 38.37031], [70.64966, 38.34999], [70.61526, 38.34774]]]] } },
    { type: "Feature", properties: { iso1A2: "AG", iso1A3: "ATG", iso1N3: "028", wikidata: "Q781", nameEn: "Antigua and Barbuda", groups: ["029", "003", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", callingCodes: ["1 268"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-61.66959, 18.6782], [-62.58307, 16.68909], [-62.1023, 16.97277], [-61.23098, 16.62484], [-61.66959, 18.6782]]]] } },
    { type: "Feature", properties: { iso1A2: "AI", iso1A3: "AIA", iso1N3: "660", wikidata: "Q25228", nameEn: "Anguilla", country: "GB", groups: ["BOTS", "029", "003", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", callingCodes: ["1 264"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-63.79029, 19.11219], [-63.35989, 18.06012], [-62.62718, 18.26185], [-63.79029, 19.11219]]]] } },
    { type: "Feature", properties: { iso1A2: "AL", iso1A3: "ALB", iso1N3: "008", wikidata: "Q222", nameEn: "Albania", groups: ["039", "150", "UN"], callingCodes: ["355"] }, geometry: { type: "MultiPolygon", coordinates: [[[[20.07761, 42.55582], [20.01834, 42.54622], [20.00842, 42.5109], [19.9324, 42.51699], [19.82333, 42.46581], [19.76549, 42.50237], [19.74731, 42.57422], [19.77375, 42.58517], [19.73244, 42.66299], [19.65972, 42.62774], [19.4836, 42.40831], [19.42352, 42.36546], [19.42, 42.33019], [19.28623, 42.17745], [19.40687, 42.10024], [19.37548, 42.06835], [19.36867, 42.02564], [19.37691, 41.96977], [19.34601, 41.95675], [19.33812, 41.90669], [19.37451, 41.8842], [19.37597, 41.84849], [19.26406, 41.74971], [19.0384, 40.35325], [19.95905, 39.82857], [19.97622, 39.78684], [19.92466, 39.69533], [19.98042, 39.6504], [20.00957, 39.69227], [20.05189, 39.69112], [20.12956, 39.65805], [20.15988, 39.652], [20.22376, 39.64532], [20.22707, 39.67459], [20.27412, 39.69884], [20.31961, 39.72799], [20.29152, 39.80421], [20.30804, 39.81563], [20.38572, 39.78516], [20.41475, 39.81437], [20.41546, 39.82832], [20.31135, 39.99438], [20.37911, 39.99058], [20.42373, 40.06777], [20.48487, 40.06271], [20.51297, 40.08168], [20.55593, 40.06524], [20.61081, 40.07866], [20.62566, 40.0897], [20.67162, 40.09433], [20.71789, 40.27739], [20.78234, 40.35803], [20.7906, 40.42726], [20.83688, 40.47882], [20.94925, 40.46625], [20.96908, 40.51526], [21.03932, 40.56299], [21.05833, 40.66586], [20.98134, 40.76046], [20.95752, 40.76982], [20.98396, 40.79109], [20.97887, 40.85475], [20.97693, 40.90103], [20.94305, 40.92399], [20.83671, 40.92752], [20.81567, 40.89662], [20.73504, 40.9081], [20.71634, 40.91781], [20.65558, 41.08009], [20.63454, 41.0889], [20.59832, 41.09066], [20.58546, 41.11179], [20.59715, 41.13644], [20.51068, 41.2323], [20.49432, 41.33679], [20.52119, 41.34381], [20.55976, 41.4087], [20.51301, 41.442], [20.49039, 41.49277], [20.45331, 41.51436], [20.45809, 41.5549], [20.52103, 41.56473], [20.55508, 41.58113], [20.51769, 41.65975], [20.52937, 41.69292], [20.51301, 41.72433], [20.53405, 41.78099], [20.57144, 41.7897], [20.55976, 41.87068], [20.59524, 41.8818], [20.57946, 41.91593], [20.63069, 41.94913], [20.59434, 42.03879], [20.55633, 42.08173], [20.56955, 42.12097], [20.48857, 42.25444], [20.3819, 42.3029], [20.34479, 42.32656], [20.24399, 42.32168], [20.21797, 42.41237], [20.17127, 42.50469], [20.07761, 42.55582]]]] } },
    { type: "Feature", properties: { iso1A2: "AM", iso1A3: "ARM", iso1N3: "051", wikidata: "Q399", nameEn: "Armenia", groups: ["145", "142", "UN"], callingCodes: ["374"] }, geometry: { type: "MultiPolygon", coordinates: [[[[45.0133, 41.29747], [44.93493, 41.25685], [44.81437, 41.30371], [44.80053, 41.25949], [44.81749, 41.23488], [44.84358, 41.23088], [44.89911, 41.21366], [44.87887, 41.20195], [44.82084, 41.21513], [44.72814, 41.20338], [44.61462, 41.24018], [44.59322, 41.1933], [44.46791, 41.18204], [44.34417, 41.2382], [44.34337, 41.20312], [44.32139, 41.2079], [44.18148, 41.24644], [44.16591, 41.19141], [43.84835, 41.16329], [43.74717, 41.1117], [43.67712, 41.13398], [43.4717, 41.12611], [43.44984, 41.0988], [43.47319, 41.02251], [43.58683, 40.98961], [43.67712, 40.93084], [43.67712, 40.84846], [43.74872, 40.7365], [43.7425, 40.66805], [43.63664, 40.54159], [43.54791, 40.47413], [43.60862, 40.43267], [43.59928, 40.34019], [43.71136, 40.16673], [43.65221, 40.14889], [43.65688, 40.11199], [43.92307, 40.01787], [44.1057, 40.03555], [44.1778, 40.02845], [44.26973, 40.04866], [44.46635, 39.97733], [44.61845, 39.8281], [44.75779, 39.7148], [44.88354, 39.74432], [44.92869, 39.72157], [45.06604, 39.79277], [45.18554, 39.67846], [45.17464, 39.58614], [45.21784, 39.58074], [45.23535, 39.61373], [45.30385, 39.61373], [45.29606, 39.57654], [45.46992, 39.49888], [45.70547, 39.60174], [45.80804, 39.56716], [45.83, 39.46487], [45.79225, 39.3695], [45.99774, 39.28931], [46.02303, 39.09978], [46.06973, 39.0744], [46.14785, 38.84206], [46.20601, 38.85262], [46.34059, 38.92076], [46.53497, 38.86548], [46.51805, 38.94982], [46.54296, 39.07078], [46.44022, 39.19636], [46.52584, 39.18912], [46.54141, 39.15895], [46.58032, 39.21204], [46.63481, 39.23013], [46.56476, 39.24942], [46.50093, 39.33736], [46.43244, 39.35181], [46.37795, 39.42039], [46.4013, 39.45405], [46.53051, 39.47809], [46.51027, 39.52373], [46.57721, 39.54414], [46.57098, 39.56694], [46.52117, 39.58734], [46.42465, 39.57534], [46.40286, 39.63651], [46.18493, 39.60533], [45.96543, 39.78859], [45.82533, 39.82925], [45.7833, 39.9475], [45.60895, 39.97733], [45.59806, 40.0131], [45.78642, 40.03218], [45.83779, 39.98925], [45.97944, 40.181], [45.95609, 40.27846], [45.65098, 40.37696], [45.42994, 40.53804], [45.45484, 40.57707], [45.35366, 40.65979], [45.4206, 40.7424], [45.55914, 40.78366], [45.60584, 40.87436], [45.40814, 40.97904], [45.44083, 41.01663], [45.39725, 41.02603], [45.35677, 40.99784], [45.28859, 41.03757], [45.26162, 41.0228], [45.25897, 41.0027], [45.1994, 41.04518], [45.16493, 41.05068], [45.1634, 41.08082], [45.1313, 41.09369], [45.12923, 41.06059], [45.06784, 41.05379], [45.08028, 41.10917], [45.19942, 41.13299], [45.1969, 41.168], [45.11811, 41.19967], [45.05201, 41.19211], [45.02932, 41.2101], [45.05497, 41.2464], [45.0133, 41.29747]], [[45.21324, 40.9817], [45.21219, 40.99001], [45.20518, 40.99348], [45.19312, 40.98998], [45.18382, 41.0066], [45.20625, 41.01484], [45.23487, 41.00226], [45.23095, 40.97828], [45.21324, 40.9817]], [[45.00864, 41.03411], [44.9903, 41.05657], [44.96031, 41.06345], [44.95383, 41.07553], [44.97169, 41.09176], [45.00864, 41.09407], [45.03406, 41.07931], [45.04517, 41.06653], [45.03792, 41.03938], [45.00864, 41.03411]]], [[[45.50279, 40.58424], [45.56071, 40.64765], [45.51825, 40.67382], [45.47927, 40.65023], [45.50279, 40.58424]]]] } },
    { type: "Feature", properties: { iso1A2: "AO", iso1A3: "AGO", iso1N3: "024", wikidata: "Q916", nameEn: "Angola", groups: ["017", "202", "002", "UN"], callingCodes: ["244"] }, geometry: { type: "MultiPolygon", coordinates: [[[[16.55507, -5.85631], [13.04371, -5.87078], [12.42245, -6.07585], [11.95767, -5.94705], [12.20376, -5.76338], [12.26557, -5.74031], [12.52318, -5.74353], [12.52301, -5.17481], [12.53599, -5.1618], [12.53586, -5.14658], [12.51589, -5.1332], [12.49815, -5.14058], [12.46297, -5.09408], [12.60251, -5.01715], [12.63465, -4.94632], [12.70868, -4.95505], [12.8733, -4.74346], [13.11195, -4.67745], [13.09648, -4.63739], [12.91489, -4.47907], [12.87096, -4.40315], [12.76844, -4.38709], [12.64835, -4.55937], [12.40964, -4.60609], [12.32324, -4.78415], [12.25587, -4.79437], [12.20901, -4.75642], [12.16068, -4.90089], [12.00924, -5.02627], [11.50888, -5.33417], [10.5065, -17.25284], [11.75063, -17.25013], [12.07076, -17.15165], [12.52111, -17.24495], [12.97145, -16.98567], [13.36212, -16.98048], [13.95896, -17.43141], [14.28743, -17.38814], [18.39229, -17.38927], [18.84226, -17.80375], [21.14283, -17.94318], [21.42741, -18.02787], [23.47474, -17.62877], [23.20038, -17.47563], [22.17217, -16.50269], [22.00323, -16.18028], [21.97988, -13.00148], [24.03339, -12.99091], [23.90937, -12.844], [24.06672, -12.29058], [23.98804, -12.13149], [24.02603, -11.15368], [24.00027, -10.89356], [23.86868, -11.02856], [23.45631, -10.946], [23.16602, -11.10577], [22.54205, -11.05784], [22.25951, -11.24911], [22.17954, -10.85884], [22.32604, -10.76291], [22.19039, -9.94628], [21.84856, -9.59871], [21.79824, -7.29628], [20.56263, -7.28566], [20.61689, -6.90876], [20.31846, -6.91953], [20.30218, -6.98955], [19.5469, -7.00195], [19.33698, -7.99743], [18.33635, -8.00126], [17.5828, -8.13784], [16.96282, -7.21787], [16.55507, -5.85631]]]] } },
    { type: "Feature", properties: { iso1A2: "AQ", iso1A3: "ATA", iso1N3: "010", wikidata: "Q51", nameEn: "Antarctica", level: "region", callingCodes: ["672"] }, geometry: { type: "MultiPolygon", coordinates: [[[[180, -60], [-180, -60], [-180, -90], [180, -90], [180, -60]]]] } },
    { type: "Feature", properties: { iso1A2: "AR", iso1A3: "ARG", iso1N3: "032", wikidata: "Q414", nameEn: "Argentina", aliases: ["RA"], groups: ["005", "419", "019", "UN"], callingCodes: ["54"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-72.31343, -50.58411], [-72.33873, -51.59954], [-71.99889, -51.98018], [-69.97824, -52.00845], [-68.41683, -52.33516], [-68.60702, -52.65781], [-68.60733, -54.9125], [-68.01394, -54.8753], [-67.46182, -54.92205], [-67.11046, -54.94199], [-66.07313, -55.19618], [-63.67376, -55.11859], [-54.78916, -36.21945], [-57.83001, -34.69099], [-58.34425, -34.15035], [-58.44442, -33.84033], [-58.40475, -33.11777], [-58.1224, -32.98842], [-58.22362, -32.52416], [-58.10036, -32.25338], [-58.20252, -31.86966], [-58.00076, -31.65016], [-58.0023, -31.53084], [-58.07569, -31.44916], [-57.98127, -31.3872], [-57.9908, -31.34924], [-57.86729, -31.06352], [-57.89476, -30.95994], [-57.8024, -30.77193], [-57.89115, -30.49572], [-57.64859, -30.35095], [-57.61478, -30.25165], [-57.65132, -30.19229], [-57.09386, -29.74211], [-56.81251, -29.48154], [-56.62789, -29.18073], [-56.57295, -29.11357], [-56.54171, -29.11447], [-56.05265, -28.62651], [-56.00458, -28.60421], [-56.01729, -28.51223], [-55.65418, -28.18304], [-55.6262, -28.17124], [-55.33303, -27.94661], [-55.16872, -27.86224], [-55.1349, -27.89759], [-54.90805, -27.73149], [-54.90159, -27.63132], [-54.67657, -27.57214], [-54.50416, -27.48232], [-54.41888, -27.40882], [-54.19268, -27.30751], [-54.19062, -27.27639], [-54.15978, -27.2889], [-53.80144, -27.09844], [-53.73372, -26.6131], [-53.68269, -26.33359], [-53.64505, -26.28089], [-53.64186, -26.25976], [-53.64632, -26.24798], [-53.63881, -26.25075], [-53.63739, -26.2496], [-53.65237, -26.23289], [-53.65018, -26.19501], [-53.73968, -26.10012], [-53.73391, -26.07006], [-53.7264, -26.0664], [-53.73086, -26.05842], [-53.73511, -26.04211], [-53.83691, -25.94849], [-53.90831, -25.55513], [-54.52926, -25.62846], [-54.5502, -25.58915], [-54.59398, -25.59224], [-54.62063, -25.91213], [-54.60664, -25.9691], [-54.67359, -25.98607], [-54.69333, -26.37705], [-54.70732, -26.45099], [-54.80868, -26.55669], [-55.00584, -26.78754], [-55.06351, -26.80195], [-55.16948, -26.96068], [-55.25243, -26.93808], [-55.39611, -26.97679], [-55.62322, -27.1941], [-55.59094, -27.32444], [-55.74475, -27.44485], [-55.89195, -27.3467], [-56.18313, -27.29851], [-56.85337, -27.5165], [-58.04205, -27.2387], [-58.59549, -27.29973], [-58.65321, -27.14028], [-58.3198, -26.83443], [-58.1188, -26.16704], [-57.87176, -25.93604], [-57.57431, -25.47269], [-57.80821, -25.13863], [-58.25492, -24.92528], [-58.33055, -24.97099], [-59.33886, -24.49935], [-59.45482, -24.34787], [-60.03367, -24.00701], [-60.28163, -24.04436], [-60.99754, -23.80934], [-61.0782, -23.62932], [-61.9756, -23.0507], [-62.22768, -22.55807], [-62.51761, -22.37684], [-62.64455, -22.25091], [-62.8078, -22.12534], [-62.81124, -21.9987], [-63.66482, -21.99918], [-63.68113, -22.0544], [-63.70963, -21.99934], [-63.93287, -21.99934], [-64.22918, -22.55807], [-64.31489, -22.88824], [-64.35108, -22.73282], [-64.4176, -22.67692], [-64.58888, -22.25035], [-64.67174, -22.18957], [-64.90014, -22.12136], [-64.99524, -22.08255], [-65.47435, -22.08908], [-65.57743, -22.07675], [-65.58694, -22.09794], [-65.61166, -22.09504], [-65.7467, -22.10105], [-65.9261, -21.93335], [-66.04832, -21.9187], [-66.03836, -21.84829], [-66.24077, -21.77837], [-66.29714, -22.08741], [-66.7298, -22.23644], [-67.18382, -22.81525], [-66.99632, -22.99839], [-67.33563, -24.04237], [-68.24825, -24.42596], [-68.56909, -24.69831], [-68.38372, -25.08636], [-68.57622, -25.32505], [-68.38372, -26.15353], [-68.56909, -26.28146], [-68.59048, -26.49861], [-68.27677, -26.90626], [-68.43363, -27.08414], [-68.77586, -27.16029], [-69.22504, -27.95042], [-69.66709, -28.44055], [-69.80969, -29.07185], [-69.99507, -29.28351], [-69.8596, -30.26131], [-70.14479, -30.36595], [-70.55832, -31.51559], [-69.88099, -33.34489], [-69.87386, -34.13344], [-70.49416, -35.24145], [-70.38008, -36.02375], [-70.95047, -36.4321], [-71.24279, -37.20264], [-70.89532, -38.6923], [-71.37826, -38.91474], [-71.92726, -40.72714], [-71.74901, -42.11711], [-72.15541, -42.15941], [-72.14828, -42.85321], [-71.64206, -43.64774], [-71.81318, -44.38097], [-71.16436, -44.46244], [-71.26418, -44.75684], [-72.06985, -44.81756], [-71.35687, -45.22075], [-71.75614, -45.61611], [-71.68577, -46.55385], [-71.94152, -47.13595], [-72.50478, -47.80586], [-72.27662, -48.28727], [-72.54042, -48.52392], [-72.56894, -48.81116], [-73.09655, -49.14342], [-73.45156, -49.79461], [-73.55259, -49.92488], [-73.15765, -50.78337], [-72.31343, -50.58411]]]] } },
    { type: "Feature", properties: { iso1A2: "AS", iso1A3: "ASM", iso1N3: "016", wikidata: "Q16641", nameEn: "American Samoa", aliases: ["US-AS"], country: "US", groups: ["Q1352230", "061", "009", "UN"], roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["1 684"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-171.39864, -10.21587], [-170.99605, -15.1275], [-166.32598, -15.26169], [-171.39864, -10.21587]]]] } },
    { type: "Feature", properties: { iso1A2: "AT", iso1A3: "AUT", iso1N3: "040", wikidata: "Q40", nameEn: "Austria", groups: ["EU", "155", "150", "UN"], callingCodes: ["43"] }, geometry: { type: "MultiPolygon", coordinates: [[[[15.34823, 48.98444], [15.28305, 48.98831], [15.26177, 48.95766], [15.16358, 48.94278], [15.15534, 48.99056], [14.99878, 49.01444], [14.97612, 48.96983], [14.98917, 48.90082], [14.95072, 48.79101], [14.98032, 48.77959], [14.9782, 48.7766], [14.98112, 48.77524], [14.9758, 48.76857], [14.95641, 48.75915], [14.94773, 48.76268], [14.81545, 48.7874], [14.80821, 48.77711], [14.80584, 48.73489], [14.72756, 48.69502], [14.71794, 48.59794], [14.66762, 48.58215], [14.60808, 48.62881], [14.56139, 48.60429], [14.4587, 48.64695], [14.43076, 48.58855], [14.33909, 48.55852], [14.20691, 48.5898], [14.09104, 48.5943], [14.01482, 48.63788], [14.06151, 48.66873], [13.84023, 48.76988], [13.82266, 48.75544], [13.81863, 48.73257], [13.79337, 48.71375], [13.81791, 48.69832], [13.81283, 48.68426], [13.81901, 48.6761], [13.82609, 48.62345], [13.80038, 48.59487], [13.80519, 48.58026], [13.76921, 48.55324], [13.7513, 48.5624], [13.74816, 48.53058], [13.72802, 48.51208], [13.66113, 48.53558], [13.65186, 48.55092], [13.62508, 48.55501], [13.59705, 48.57013], [13.57535, 48.55912], [13.51291, 48.59023], [13.50131, 48.58091], [13.50663, 48.57506], [13.46967, 48.55157], [13.45214, 48.56472], [13.43695, 48.55776], [13.45727, 48.51092], [13.42527, 48.45711], [13.43929, 48.43386], [13.40709, 48.37292], [13.30897, 48.31575], [13.26039, 48.29422], [13.18093, 48.29577], [13.126, 48.27867], [13.0851, 48.27711], [13.02083, 48.25689], [12.95306, 48.20629], [12.87126, 48.20318], [12.84475, 48.16556], [12.836, 48.1647], [12.8362, 48.15876], [12.82673, 48.15245], [12.80676, 48.14979], [12.78595, 48.12445], [12.7617, 48.12796], [12.74973, 48.10885], [12.76141, 48.07373], [12.8549, 48.01122], [12.87476, 47.96195], [12.91683, 47.95647], [12.9211, 47.95135], [12.91985, 47.94069], [12.92668, 47.93879], [12.93419, 47.94063], [12.93642, 47.94436], [12.93886, 47.94046], [12.94163, 47.92927], [13.00588, 47.84374], [12.98543, 47.82896], [12.96311, 47.79957], [12.93202, 47.77302], [12.94371, 47.76281], [12.9353, 47.74788], [12.91711, 47.74026], [12.90274, 47.72513], [12.91333, 47.7178], [12.92969, 47.71094], [12.98578, 47.7078], [13.01382, 47.72116], [13.07692, 47.68814], [13.09562, 47.63304], [13.06407, 47.60075], [13.06641, 47.58577], [13.04537, 47.58183], [13.05355, 47.56291], [13.03252, 47.53373], [13.04537, 47.49426], [12.9998, 47.46267], [12.98344, 47.48716], [12.9624, 47.47452], [12.85256, 47.52741], [12.84672, 47.54556], [12.80699, 47.54477], [12.77427, 47.58025], [12.82101, 47.61493], [12.76492, 47.64485], [12.77777, 47.66689], [12.7357, 47.6787], [12.6071, 47.6741], [12.57438, 47.63238], [12.53816, 47.63553], [12.50076, 47.62293], [12.44117, 47.6741], [12.43883, 47.6977], [12.37222, 47.68433], [12.336, 47.69534], [12.27991, 47.68827], [12.26004, 47.67725], [12.24017, 47.69534], [12.26238, 47.73544], [12.2542, 47.7433], [12.22571, 47.71776], [12.18303, 47.70065], [12.16217, 47.70105], [12.16769, 47.68167], [12.18347, 47.66663], [12.18507, 47.65984], [12.19895, 47.64085], [12.20801, 47.61082], [12.20398, 47.60667], [12.18568, 47.6049], [12.17737, 47.60121], [12.18145, 47.61019], [12.17824, 47.61506], [12.13734, 47.60639], [12.05788, 47.61742], [12.02282, 47.61033], [12.0088, 47.62451], [11.85572, 47.60166], [11.84052, 47.58354], [11.63934, 47.59202], [11.60681, 47.57881], [11.58811, 47.55515], [11.58578, 47.52281], [11.52618, 47.50939], [11.4362, 47.51413], [11.38128, 47.47465], [11.4175, 47.44621], [11.33804, 47.44937], [11.29597, 47.42566], [11.27844, 47.39956], [11.22002, 47.3964], [11.25157, 47.43277], [11.20482, 47.43198], [11.12536, 47.41222], [11.11835, 47.39719], [10.97111, 47.39561], [10.97111, 47.41617], [10.98513, 47.42882], [10.92437, 47.46991], [10.93839, 47.48018], [10.90918, 47.48571], [10.87061, 47.4786], [10.86945, 47.5015], [10.91268, 47.51334], [10.88814, 47.53701], [10.77596, 47.51729], [10.7596, 47.53228], [10.6965, 47.54253], [10.68832, 47.55752], [10.63456, 47.5591], [10.60337, 47.56755], [10.56912, 47.53584], [10.48849, 47.54057], [10.47329, 47.58552], [10.43473, 47.58394], [10.44992, 47.5524], [10.4324, 47.50111], [10.44291, 47.48453], [10.46278, 47.47901], [10.47446, 47.43318], [10.4359, 47.41183], [10.4324, 47.38494], [10.39851, 47.37623], [10.33424, 47.30813], [10.23257, 47.27088], [10.17531, 47.27167], [10.17648, 47.29149], [10.2147, 47.31014], [10.19998, 47.32832], [10.23757, 47.37609], [10.22774, 47.38904], [10.2127, 47.38019], [10.17648, 47.38889], [10.16362, 47.36674], [10.11805, 47.37228], [10.09819, 47.35724], [10.06897, 47.40709], [10.1052, 47.4316], [10.09001, 47.46005], [10.07131, 47.45531], [10.03859, 47.48927], [10.00003, 47.48216], [9.96029, 47.53899], [9.92407, 47.53111], [9.87733, 47.54688], [9.87499, 47.52953], [9.8189, 47.54688], [9.82591, 47.58158], [9.80254, 47.59419], [9.76748, 47.5934], [9.72736, 47.53457], [9.55125, 47.53629], [9.56312, 47.49495], [9.58208, 47.48344], [9.59482, 47.46305], [9.60205, 47.46165], [9.60484, 47.46358], [9.60841, 47.47178], [9.62158, 47.45858], [9.62475, 47.45685], [9.6423, 47.45599], [9.65728, 47.45383], [9.65863, 47.44847], [9.64483, 47.43842], [9.6446, 47.43233], [9.65043, 47.41937], [9.65136, 47.40504], [9.6629, 47.39591], [9.67334, 47.39191], [9.67445, 47.38429], [9.6711, 47.37824], [9.66243, 47.37136], [9.65427, 47.36824], [9.62476, 47.36639], [9.59978, 47.34671], [9.58513, 47.31334], [9.55857, 47.29919], [9.54773, 47.2809], [9.53116, 47.27029], [9.56766, 47.24281], [9.55176, 47.22585], [9.56981, 47.21926], [9.58264, 47.20673], [9.56539, 47.17124], [9.62623, 47.14685], [9.63395, 47.08443], [9.61216, 47.07732], [9.60717, 47.06091], [9.87935, 47.01337], [9.88266, 46.93343], [9.98058, 46.91434], [10.10715, 46.84296], [10.22675, 46.86942], [10.24128, 46.93147], [10.30031, 46.92093], [10.36933, 47.00212], [10.48376, 46.93891], [10.47197, 46.85698], [10.54783, 46.84505], [10.66405, 46.87614], [10.75753, 46.82258], [10.72974, 46.78972], [11.00764, 46.76896], [11.10618, 46.92966], [11.33355, 46.99862], [11.50739, 47.00644], [11.74789, 46.98484], [12.19254, 47.09331], [12.21781, 47.03996], [12.11675, 47.01241], [12.2006, 46.88854], [12.27591, 46.88651], [12.38708, 46.71529], [12.59992, 46.6595], [12.94445, 46.60401], [13.27627, 46.56059], [13.64088, 46.53438], [13.7148, 46.5222], [13.89837, 46.52331], [14.00422, 46.48474], [14.04002, 46.49117], [14.12097, 46.47724], [14.15989, 46.43327], [14.28326, 46.44315], [14.314, 46.43327], [14.42608, 46.44614], [14.45877, 46.41717], [14.52176, 46.42617], [14.56463, 46.37208], [14.5942, 46.43434], [14.66892, 46.44936], [14.72185, 46.49974], [14.81836, 46.51046], [14.83549, 46.56614], [14.86419, 46.59411], [14.87129, 46.61], [14.92283, 46.60848], [14.96002, 46.63459], [14.98024, 46.6009], [15.01451, 46.641], [15.14215, 46.66131], [15.23711, 46.63994], [15.41235, 46.65556], [15.45514, 46.63697], [15.46906, 46.61321], [15.54431, 46.6312], [15.55333, 46.64988], [15.54533, 46.66985], [15.59826, 46.68908], [15.62317, 46.67947], [15.63255, 46.68069], [15.6365, 46.6894], [15.6543, 46.69228], [15.6543, 46.70616], [15.67411, 46.70735], [15.69523, 46.69823], [15.72279, 46.69548], [15.73823, 46.70011], [15.76771, 46.69863], [15.78518, 46.70712], [15.8162, 46.71897], [15.87691, 46.7211], [15.94864, 46.68769], [15.98512, 46.68463], [15.99988, 46.67947], [16.04036, 46.6549], [16.04347, 46.68694], [16.02808, 46.71094], [15.99769, 46.7266], [15.98432, 46.74991], [15.99126, 46.78199], [15.99054, 46.82772], [16.05786, 46.83927], [16.10983, 46.867], [16.19904, 46.94134], [16.22403, 46.939], [16.27594, 46.9643], [16.28202, 47.00159], [16.51369, 47.00084], [16.43936, 47.03548], [16.52176, 47.05747], [16.46134, 47.09395], [16.52863, 47.13974], [16.44932, 47.14418], [16.46442, 47.16845], [16.4523, 47.18812], [16.42801, 47.18422], [16.41739, 47.20649], [16.43663, 47.21127], [16.44142, 47.25079], [16.47782, 47.25918], [16.45104, 47.41181], [16.49908, 47.39416], [16.52414, 47.41007], [16.57152, 47.40868], [16.6718, 47.46139], [16.64821, 47.50155], [16.71059, 47.52692], [16.64193, 47.63114], [16.58699, 47.61772], [16.4222, 47.66537], [16.55129, 47.72268], [16.53514, 47.73837], [16.54779, 47.75074], [16.61183, 47.76171], [16.65679, 47.74197], [16.72089, 47.73469], [16.7511, 47.67878], [16.82938, 47.68432], [16.86509, 47.72268], [16.87538, 47.68895], [17.08893, 47.70928], [17.05048, 47.79377], [17.07039, 47.81129], [17.00997, 47.86245], [17.08275, 47.87719], [17.11022, 47.92461], [17.09786, 47.97336], [17.16001, 48.00636], [17.07039, 48.0317], [17.09168, 48.09366], [17.05735, 48.14179], [17.02919, 48.13996], [16.97701, 48.17385], [16.89461, 48.31332], [16.90903, 48.32519], [16.84243, 48.35258], [16.83317, 48.38138], [16.83588, 48.3844], [16.8497, 48.38321], [16.85204, 48.44968], [16.94611, 48.53614], [16.93955, 48.60371], [16.90354, 48.71541], [16.79779, 48.70998], [16.71883, 48.73806], [16.68518, 48.7281], [16.67008, 48.77699], [16.46134, 48.80865], [16.40915, 48.74576], [16.37345, 48.729], [16.06034, 48.75436], [15.84404, 48.86921], [15.78087, 48.87644], [15.75341, 48.8516], [15.6921, 48.85973], [15.61622, 48.89541], [15.51357, 48.91549], [15.48027, 48.94481], [15.34823, 48.98444]]]] } },
    { type: "Feature", properties: { iso1A2: "AU", iso1A3: "AUS", iso1N3: "036", wikidata: "Q408", nameEn: "Australia" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "AW", iso1A3: "ABW", iso1N3: "533", wikidata: "Q21203", nameEn: "Aruba", aliases: ["NL-AW"], country: "NL", groups: ["Q1451600", "029", "003", "419", "019", "UN"], callingCodes: ["297"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-70.00823, 12.98375], [-70.35625, 12.58277], [-69.60231, 12.17], [-70.00823, 12.98375]]]] } },
    { type: "Feature", properties: { iso1A2: "AX", iso1A3: "ALA", iso1N3: "248", wikidata: "Q5689", nameEn: "\xC5land Islands", country: "FI", groups: ["EU", "154", "150", "UN"], callingCodes: ["358 18", "358 457"] }, geometry: { type: "MultiPolygon", coordinates: [[[[19.08191, 60.19152], [20.5104, 59.15546], [21.35468, 59.67511], [21.02509, 60.12142], [21.08159, 60.20167], [21.15143, 60.54555], [20.96741, 60.71528], [19.23413, 60.61414], [19.08191, 60.19152]]]] } },
    { type: "Feature", properties: { iso1A2: "AZ", iso1A3: "AZE", iso1N3: "031", wikidata: "Q227", nameEn: "Azerbaijan", groups: ["145", "142", "UN"], callingCodes: ["994"] }, geometry: { type: "MultiPolygon", coordinates: [[[[46.42738, 41.91323], [46.3984, 41.84399], [46.30863, 41.79133], [46.23962, 41.75811], [46.20538, 41.77205], [46.17891, 41.72094], [46.19759, 41.62327], [46.24429, 41.59883], [46.26531, 41.63339], [46.28182, 41.60089], [46.3253, 41.60912], [46.34039, 41.5947], [46.34126, 41.57454], [46.29794, 41.5724], [46.33925, 41.4963], [46.40307, 41.48464], [46.4669, 41.43331], [46.63658, 41.37727], [46.72375, 41.28609], [46.66148, 41.20533], [46.63969, 41.09515], [46.55096, 41.1104], [46.48558, 41.0576], [46.456, 41.09984], [46.37661, 41.10805], [46.27698, 41.19011], [46.13221, 41.19479], [45.95786, 41.17956], [45.80842, 41.2229], [45.69946, 41.29545], [45.75705, 41.35157], [45.71035, 41.36208], [45.68389, 41.3539], [45.45973, 41.45898], [45.4006, 41.42402], [45.31352, 41.47168], [45.26285, 41.46433], [45.1797, 41.42231], [45.09867, 41.34065], [45.0133, 41.29747], [45.05497, 41.2464], [45.02932, 41.2101], [45.05201, 41.19211], [45.11811, 41.19967], [45.1969, 41.168], [45.19942, 41.13299], [45.08028, 41.10917], [45.06784, 41.05379], [45.12923, 41.06059], [45.1313, 41.09369], [45.1634, 41.08082], [45.16493, 41.05068], [45.1994, 41.04518], [45.25897, 41.0027], [45.26162, 41.0228], [45.28859, 41.03757], [45.35677, 40.99784], [45.39725, 41.02603], [45.44083, 41.01663], [45.40814, 40.97904], [45.60584, 40.87436], [45.55914, 40.78366], [45.4206, 40.7424], [45.35366, 40.65979], [45.45484, 40.57707], [45.42994, 40.53804], [45.65098, 40.37696], [45.95609, 40.27846], [45.97944, 40.181], [45.83779, 39.98925], [45.78642, 40.03218], [45.59806, 40.0131], [45.60895, 39.97733], [45.7833, 39.9475], [45.82533, 39.82925], [45.96543, 39.78859], [46.18493, 39.60533], [46.40286, 39.63651], [46.42465, 39.57534], [46.52117, 39.58734], [46.57098, 39.56694], [46.57721, 39.54414], [46.51027, 39.52373], [46.53051, 39.47809], [46.4013, 39.45405], [46.37795, 39.42039], [46.43244, 39.35181], [46.50093, 39.33736], [46.56476, 39.24942], [46.63481, 39.23013], [46.58032, 39.21204], [46.54141, 39.15895], [46.52584, 39.18912], [46.44022, 39.19636], [46.54296, 39.07078], [46.51805, 38.94982], [46.53497, 38.86548], [46.75752, 39.03231], [46.83822, 39.13143], [46.92539, 39.16644], [46.95341, 39.13505], [47.05771, 39.20143], [47.05927, 39.24846], [47.31301, 39.37492], [47.38978, 39.45999], [47.50099, 39.49615], [47.84774, 39.66285], [47.98977, 39.70999], [48.34264, 39.42935], [48.37385, 39.37584], [48.15984, 39.30028], [48.12404, 39.25208], [48.15361, 39.19419], [48.31239, 39.09278], [48.33884, 39.03022], [48.28437, 38.97186], [48.08627, 38.94434], [48.07734, 38.91616], [48.01409, 38.90333], [48.02581, 38.82705], [48.24773, 38.71883], [48.3146, 38.59958], [48.45084, 38.61013], [48.58793, 38.45076], [48.62217, 38.40198], [48.70001, 38.40564], [48.78979, 38.45026], [48.81072, 38.44853], [48.84969, 38.45015], [48.88288, 38.43975], [52.39847, 39.43556], [48.80971, 41.95365], [48.5867, 41.84306], [48.55078, 41.77917], [48.42301, 41.65444], [48.40277, 41.60441], [48.2878, 41.56221], [48.22064, 41.51472], [48.07587, 41.49957], [47.87973, 41.21798], [47.75831, 41.19455], [47.62288, 41.22969], [47.54504, 41.20275], [47.49004, 41.26366], [47.34579, 41.27884], [47.10762, 41.59044], [47.03757, 41.55434], [46.99554, 41.59743], [47.00955, 41.63583], [46.8134, 41.76252], [46.75269, 41.8623], [46.58924, 41.80547], [46.5332, 41.87389], [46.42738, 41.91323]], [[45.50279, 40.58424], [45.47927, 40.65023], [45.51825, 40.67382], [45.56071, 40.64765], [45.50279, 40.58424]]], [[[45.00864, 41.03411], [45.03792, 41.03938], [45.04517, 41.06653], [45.03406, 41.07931], [45.00864, 41.09407], [44.97169, 41.09176], [44.95383, 41.07553], [44.96031, 41.06345], [44.9903, 41.05657], [45.00864, 41.03411]]], [[[45.21324, 40.9817], [45.23095, 40.97828], [45.23487, 41.00226], [45.20625, 41.01484], [45.18382, 41.0066], [45.19312, 40.98998], [45.20518, 40.99348], [45.21219, 40.99001], [45.21324, 40.9817]]], [[[45.46992, 39.49888], [45.29606, 39.57654], [45.30385, 39.61373], [45.23535, 39.61373], [45.21784, 39.58074], [45.17464, 39.58614], [45.18554, 39.67846], [45.06604, 39.79277], [44.92869, 39.72157], [44.88354, 39.74432], [44.75779, 39.7148], [44.80977, 39.65768], [44.81043, 39.62677], [44.88916, 39.59653], [44.96746, 39.42998], [45.05932, 39.36435], [45.08751, 39.35052], [45.16168, 39.21952], [45.30489, 39.18333], [45.40148, 39.09007], [45.40452, 39.07224], [45.44811, 39.04927], [45.44966, 38.99243], [45.6131, 38.964], [45.6155, 38.94304], [45.65172, 38.95199], [45.83883, 38.90768], [45.90266, 38.87739], [45.94624, 38.89072], [46.00228, 38.87376], [46.06766, 38.87861], [46.14785, 38.84206], [46.06973, 39.0744], [46.02303, 39.09978], [45.99774, 39.28931], [45.79225, 39.3695], [45.83, 39.46487], [45.80804, 39.56716], [45.70547, 39.60174], [45.46992, 39.49888]]]] } },
    { type: "Feature", properties: { iso1A2: "BA", iso1A3: "BIH", iso1N3: "070", wikidata: "Q225", nameEn: "Bosnia and Herzegovina", groups: ["039", "150", "UN"], callingCodes: ["387"] }, geometry: { type: "MultiPolygon", coordinates: [[[[17.84826, 45.04489], [17.66571, 45.13408], [17.59104, 45.10816], [17.51469, 45.10791], [17.47589, 45.12656], [17.45615, 45.12523], [17.4498, 45.16119], [17.41229, 45.13335], [17.33573, 45.14521], [17.32092, 45.16246], [17.26815, 45.18444], [17.25131, 45.14957], [17.24325, 45.146], [17.18438, 45.14764], [17.0415, 45.20759], [16.9385, 45.22742], [16.92405, 45.27607], [16.83804, 45.18951], [16.81137, 45.18434], [16.78219, 45.19002], [16.74845, 45.20393], [16.64962, 45.20714], [16.60194, 45.23042], [16.56559, 45.22307], [16.5501, 45.2212], [16.52982, 45.22713], [16.49155, 45.21153], [16.4634, 45.14522], [16.40023, 45.1147], [16.38309, 45.05955], [16.38219, 45.05139], [16.3749, 45.05206], [16.35863, 45.03529], [16.35404, 45.00241], [16.29036, 44.99732], [16.12153, 45.09616], [15.98412, 45.23088], [15.83512, 45.22459], [15.76371, 45.16508], [15.78842, 45.11519], [15.74585, 45.0638], [15.78568, 44.97401], [15.74723, 44.96818], [15.76096, 44.87045], [15.79472, 44.8455], [15.72584, 44.82334], [15.8255, 44.71501], [15.89348, 44.74964], [16.05828, 44.61538], [16.00884, 44.58605], [16.03012, 44.55572], [16.10566, 44.52586], [16.16814, 44.40679], [16.12969, 44.38275], [16.21346, 44.35231], [16.18688, 44.27012], [16.36864, 44.08263], [16.43662, 44.07523], [16.43629, 44.02826], [16.50528, 44.0244], [16.55472, 43.95326], [16.70922, 43.84887], [16.75316, 43.77157], [16.80736, 43.76011], [17.00585, 43.58037], [17.15828, 43.49376], [17.24411, 43.49376], [17.29699, 43.44542], [17.25579, 43.40353], [17.286, 43.33065], [17.46986, 43.16559], [17.64268, 43.08595], [17.70879, 42.97223], [17.5392, 42.92787], [17.6444, 42.88641], [17.68151, 42.92725], [17.7948, 42.89556], [17.80854, 42.9182], [17.88201, 42.83668], [18.24318, 42.6112], [18.36197, 42.61423], [18.43735, 42.55921], [18.49778, 42.58409], [18.53751, 42.57376], [18.55504, 42.58409], [18.52232, 42.62279], [18.57373, 42.64429], [18.54841, 42.68328], [18.54603, 42.69171], [18.55221, 42.69045], [18.56789, 42.72074], [18.47324, 42.74992], [18.45921, 42.81682], [18.47633, 42.85829], [18.4935, 42.86433], [18.49661, 42.89306], [18.49076, 42.95553], [18.52232, 43.01451], [18.66254, 43.03928], [18.64735, 43.14766], [18.66605, 43.2056], [18.71747, 43.2286], [18.6976, 43.25243], [18.76538, 43.29838], [18.85342, 43.32426], [18.84794, 43.33735], [18.83912, 43.34795], [18.90911, 43.36383], [18.95819, 43.32899], [18.95001, 43.29327], [19.00844, 43.24988], [19.04233, 43.30008], [19.08206, 43.29668], [19.08673, 43.31453], [19.04071, 43.397], [19.01078, 43.43854], [18.96053, 43.45042], [18.95469, 43.49367], [18.91379, 43.50299], [19.01078, 43.55806], [19.04934, 43.50384], [19.13933, 43.5282], [19.15685, 43.53943], [19.22807, 43.5264], [19.24774, 43.53061], [19.2553, 43.5938], [19.33426, 43.58833], [19.36653, 43.60921], [19.41941, 43.54056], [19.42696, 43.57987], [19.50455, 43.58385], [19.5176, 43.71403], [19.3986, 43.79668], [19.23465, 43.98764], [19.24363, 44.01502], [19.38439, 43.96611], [19.52515, 43.95573], [19.56498, 43.99922], [19.61836, 44.01464], [19.61991, 44.05254], [19.57467, 44.04716], [19.55999, 44.06894], [19.51167, 44.08158], [19.47321, 44.1193], [19.48386, 44.14332], [19.47338, 44.15034], [19.43905, 44.13088], [19.40927, 44.16722], [19.3588, 44.18353], [19.34773, 44.23244], [19.32464, 44.27185], [19.26945, 44.26957], [19.23306, 44.26097], [19.20508, 44.2917], [19.18328, 44.28383], [19.16741, 44.28648], [19.13332, 44.31492], [19.13556, 44.338], [19.11547, 44.34218], [19.1083, 44.3558], [19.11865, 44.36712], [19.10298, 44.36924], [19.10365, 44.37795], [19.10704, 44.38249], [19.10749, 44.39421], [19.11785, 44.40313], [19.14681, 44.41463], [19.14837, 44.45253], [19.12278, 44.50132], [19.13369, 44.52521], [19.16699, 44.52197], [19.26388, 44.65412], [19.32543, 44.74058], [19.36722, 44.88164], [19.18183, 44.92055], [19.01994, 44.85493], [18.8704, 44.85097], [18.76347, 44.90669], [18.76369, 44.93707], [18.80661, 44.93561], [18.78357, 44.97741], [18.65723, 45.07544], [18.47939, 45.05871], [18.41896, 45.11083], [18.32077, 45.1021], [18.24387, 45.13699], [18.1624, 45.07654], [18.03121, 45.12632], [18.01594, 45.15163], [17.99479, 45.14958], [17.97834, 45.13831], [17.97336, 45.12245], [17.93706, 45.08016], [17.87148, 45.04645], [17.84826, 45.04489]]]] } },
    { type: "Feature", properties: { iso1A2: "BB", iso1A3: "BRB", iso1N3: "052", wikidata: "Q244", nameEn: "Barbados", groups: ["029", "003", "419", "019", "UN"], driveSide: "left", callingCodes: ["1 246"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-58.56442, 13.24471], [-59.80731, 13.87556], [-59.82929, 12.70644], [-58.56442, 13.24471]]]] } },
    { type: "Feature", properties: { iso1A2: "BD", iso1A3: "BGD", iso1N3: "050", wikidata: "Q902", nameEn: "Bangladesh", groups: ["034", "142", "UN"], driveSide: "left", callingCodes: ["880"] }, geometry: { type: "MultiPolygon", coordinates: [[[[89.15869, 26.13708], [89.08899, 26.38845], [88.95612, 26.4564], [88.92357, 26.40711], [88.91321, 26.37984], [89.05328, 26.2469], [88.85004, 26.23211], [88.78961, 26.31093], [88.67837, 26.26291], [88.69485, 26.38353], [88.62144, 26.46783], [88.4298, 26.54489], [88.41196, 26.63837], [88.33093, 26.48929], [88.35153, 26.45241], [88.36938, 26.48683], [88.48749, 26.45855], [88.51649, 26.35923], [88.35153, 26.29123], [88.34757, 26.22216], [88.1844, 26.14417], [88.16581, 26.0238], [88.08804, 25.91334], [88.13138, 25.78773], [88.242, 25.80811], [88.45103, 25.66245], [88.4559, 25.59227], [88.677, 25.46959], [88.81296, 25.51546], [88.85278, 25.34679], [89.01105, 25.30303], [89.00463, 25.26583], [88.94067, 25.18534], [88.44766, 25.20149], [88.46277, 25.07468], [88.33917, 24.86803], [88.27325, 24.88796], [88.21832, 24.96642], [88.14004, 24.93529], [88.15515, 24.85806], [88.00683, 24.66477], [88.08786, 24.63232], [88.12296, 24.51301], [88.50934, 24.32474], [88.68801, 24.31464], [88.74841, 24.1959], [88.6976, 24.14703], [88.73743, 23.91751], [88.66189, 23.87607], [88.58087, 23.87105], [88.56507, 23.64044], [88.74841, 23.47361], [88.79351, 23.50535], [88.79254, 23.46028], [88.71133, 23.2492], [88.99148, 23.21134], [88.86377, 23.08759], [88.88327, 23.03885], [88.87063, 22.95235], [88.96713, 22.83346], [88.9151, 22.75228], [88.94614, 22.66941], [88.9367, 22.58527], [89.07114, 22.15335], [89.08044, 21.41871], [92.47409, 20.38654], [92.26071, 21.05697], [92.17752, 21.17445], [92.20087, 21.337], [92.37939, 21.47764], [92.43158, 21.37025], [92.55105, 21.3856], [92.60187, 21.24615], [92.68152, 21.28454], [92.59775, 21.6092], [92.62187, 21.87037], [92.60949, 21.97638], [92.56616, 22.13554], [92.60029, 22.1522], [92.5181, 22.71441], [92.37665, 22.9435], [92.38214, 23.28705], [92.26541, 23.70392], [92.15417, 23.73409], [92.04706, 23.64229], [91.95093, 23.73284], [91.95642, 23.47361], [91.84789, 23.42235], [91.76417, 23.26619], [91.81634, 23.08001], [91.7324, 23.00043], [91.61571, 22.93929], [91.54993, 23.01051], [91.46615, 23.2328], [91.4035, 23.27522], [91.40848, 23.07117], [91.36453, 23.06612], [91.28293, 23.37538], [91.15579, 23.6599], [91.25192, 23.83463], [91.22308, 23.89616], [91.29587, 24.0041], [91.35741, 23.99072], [91.37414, 24.10693], [91.55542, 24.08687], [91.63782, 24.1132], [91.65292, 24.22095], [91.73257, 24.14703], [91.76004, 24.23848], [91.82596, 24.22345], [91.89258, 24.14674], [91.96603, 24.3799], [92.11662, 24.38997], [92.15796, 24.54435], [92.25854, 24.9191], [92.38626, 24.86055], [92.49887, 24.88796], [92.39147, 25.01471], [92.33957, 25.07593], [92.0316, 25.1834], [91.63648, 25.12846], [91.25517, 25.20677], [90.87427, 25.15799], [90.65042, 25.17788], [90.40034, 25.1534], [90.1155, 25.22686], [89.90478, 25.31038], [89.87629, 25.28337], [89.83371, 25.29548], [89.84086, 25.31854], [89.81208, 25.37244], [89.86129, 25.61714], [89.84388, 25.70042], [89.80585, 25.82489], [89.86592, 25.93115], [89.77728, 26.04254], [89.77865, 26.08387], [89.73581, 26.15818], [89.70201, 26.15138], [89.63968, 26.22595], [89.57101, 25.9682], [89.53515, 26.00382], [89.35953, 26.0077], [89.15869, 26.13708]]]] } },
    { type: "Feature", properties: { iso1A2: "BE", iso1A3: "BEL", iso1N3: "056", wikidata: "Q31", nameEn: "Belgium", groups: ["EU", "155", "150", "UN"], callingCodes: ["32"] }, geometry: { type: "MultiPolygon", coordinates: [[[[4.93295, 51.44945], [4.93909, 51.44632], [4.9524, 51.45014], [4.95244, 51.45207], [4.93295, 51.44945]]], [[[4.91493, 51.4353], [4.92652, 51.43329], [4.92952, 51.42984], [4.93986, 51.43064], [4.94265, 51.44003], [4.93471, 51.43861], [4.93416, 51.44185], [4.94025, 51.44193], [4.93544, 51.44634], [4.92879, 51.44161], [4.92815, 51.43856], [4.92566, 51.44273], [4.92811, 51.4437], [4.92287, 51.44741], [4.91811, 51.44621], [4.92227, 51.44252], [4.91935, 51.43634], [4.91493, 51.4353]]], [[[4.82946, 51.4213], [4.82409, 51.44736], [4.84139, 51.4799], [4.78803, 51.50284], [4.77321, 51.50529], [4.74578, 51.48937], [4.72935, 51.48424], [4.65442, 51.42352], [4.57489, 51.4324], [4.53521, 51.4243], [4.52846, 51.45002], [4.54675, 51.47265], [4.5388, 51.48184], [4.47736, 51.4778], [4.38122, 51.44905], [4.39747, 51.43316], [4.38064, 51.41965], [4.43777, 51.36989], [4.39292, 51.35547], [4.34086, 51.35738], [4.33265, 51.37687], [4.21923, 51.37443], [4.24024, 51.35371], [4.16721, 51.29348], [4.05165, 51.24171], [4.01957, 51.24504], [3.97889, 51.22537], [3.90125, 51.20371], [3.78783, 51.2151], [3.78999, 51.25766], [3.58939, 51.30064], [3.51502, 51.28697], [3.52698, 51.2458], [3.43488, 51.24135], [3.41704, 51.25933], [3.38289, 51.27331], [3.35847, 51.31572], [3.38696, 51.33436], [3.36263, 51.37112], [2.56575, 51.85301], [2.18458, 51.52087], [2.55904, 51.07014], [2.57551, 51.00326], [2.63074, 50.94746], [2.59093, 50.91751], [2.63331, 50.81457], [2.71165, 50.81295], [2.81056, 50.71773], [2.8483, 50.72276], [2.86985, 50.7033], [2.87937, 50.70298], [2.88504, 50.70656], [2.90069, 50.69263], [2.91036, 50.6939], [2.90873, 50.702], [2.95019, 50.75138], [2.96778, 50.75242], [3.00537, 50.76588], [3.04314, 50.77674], [3.09163, 50.77717], [3.10614, 50.78303], [3.11206, 50.79416], [3.11987, 50.79188], [3.1257, 50.78603], [3.15017, 50.79031], [3.16476, 50.76843], [3.18339, 50.74981], [3.18811, 50.74025], [3.20064, 50.73547], [3.19017, 50.72569], [3.20845, 50.71662], [3.22042, 50.71019], [3.24593, 50.71389], [3.26063, 50.70086], [3.26141, 50.69151], [3.2536, 50.68977], [3.264, 50.67668], [3.23951, 50.6585], [3.2729, 50.60718], [3.28575, 50.52724], [3.37693, 50.49538], [3.44629, 50.51009], [3.47385, 50.53397], [3.51564, 50.5256], [3.49509, 50.48885], [3.5683, 50.50192], [3.58361, 50.49049], [3.61014, 50.49568], [3.64426, 50.46275], [3.66153, 50.45165], [3.67494, 50.40239], [3.67262, 50.38663], [3.65709, 50.36873], [3.66976, 50.34563], [3.71009, 50.30305], [3.70987, 50.3191], [3.73911, 50.34809], [3.84314, 50.35219], [3.90781, 50.32814], [3.96771, 50.34989], [4.0268, 50.35793], [4.0689, 50.3254], [4.10237, 50.31247], [4.10957, 50.30234], [4.11954, 50.30425], [4.13665, 50.25609], [4.16808, 50.25786], [4.15524, 50.2833], [4.17347, 50.28838], [4.17861, 50.27443], [4.20651, 50.27333], [4.21945, 50.25539], [4.15524, 50.21103], [4.16014, 50.19239], [4.13561, 50.13078], [4.20147, 50.13535], [4.23101, 50.06945], [4.16294, 50.04719], [4.13508, 50.01976], [4.14239, 49.98034], [4.20532, 49.95803], [4.31963, 49.97043], [4.35051, 49.95315], [4.43488, 49.94122], [4.51098, 49.94659], [4.5414, 49.96911], [4.68695, 49.99685], [4.70064, 50.09384], [4.75237, 50.11314], [4.82438, 50.16878], [4.83279, 50.15331], [4.88602, 50.15182], [4.8382, 50.06738], [4.78827, 49.95609], [4.88529, 49.9236], [4.85134, 49.86457], [4.86965, 49.82271], [4.85464, 49.78995], [4.96714, 49.79872], [5.09249, 49.76193], [5.14545, 49.70287], [5.26232, 49.69456], [5.31465, 49.66846], [5.33039, 49.6555], [5.30214, 49.63055], [5.3137, 49.61225], [5.33851, 49.61599], [5.34837, 49.62889], [5.3974, 49.61596], [5.43713, 49.5707], [5.46734, 49.52648], [5.46541, 49.49825], [5.55001, 49.52729], [5.60909, 49.51228], [5.64505, 49.55146], [5.75649, 49.54321], [5.7577, 49.55915], [5.77435, 49.56298], [5.79195, 49.55228], [5.81838, 49.54777], [5.84143, 49.5533], [5.84692, 49.55663], [5.8424, 49.56082], [5.87256, 49.57539], [5.86986, 49.58756], [5.84971, 49.58674], [5.84826, 49.5969], [5.8762, 49.60898], [5.87609, 49.62047], [5.88393, 49.62802], [5.88552, 49.63507], [5.90599, 49.63853], [5.90164, 49.6511], [5.9069, 49.66377], [5.86175, 49.67862], [5.86527, 49.69291], [5.88677, 49.70951], [5.86503, 49.72739], [5.84193, 49.72161], [5.82562, 49.72395], [5.83149, 49.74729], [5.82245, 49.75048], [5.78871, 49.7962], [5.75409, 49.79239], [5.74953, 49.81428], [5.74364, 49.82058], [5.74844, 49.82435], [5.7404, 49.83452], [5.74076, 49.83823], [5.74975, 49.83933], [5.74953, 49.84709], [5.75884, 49.84811], [5.74567, 49.85368], [5.75861, 49.85631], [5.75269, 49.8711], [5.78415, 49.87922], [5.73621, 49.89796], [5.77314, 49.93646], [5.77291, 49.96056], [5.80833, 49.96451], [5.81163, 49.97142], [5.83467, 49.97823], [5.83968, 49.9892], [5.82331, 49.99662], [5.81866, 50.01286], [5.8551, 50.02683], [5.86904, 50.04614], [5.85474, 50.06342], [5.8857, 50.07824], [5.89488, 50.11476], [5.95929, 50.13295], [5.96453, 50.17259], [6.02488, 50.18283], [6.03093, 50.16362], [6.06406, 50.15344], [6.08577, 50.17246], [6.12028, 50.16374], [6.1137, 50.13668], [6.1379, 50.12964], [6.15298, 50.14126], [6.14132, 50.14971], [6.14588, 50.17106], [6.18739, 50.1822], [6.18364, 50.20815], [6.16853, 50.2234], [6.208, 50.25179], [6.28797, 50.27458], [6.29949, 50.30887], [6.32488, 50.32333], [6.35701, 50.31139], [6.40641, 50.32425], [6.40785, 50.33557], [6.3688, 50.35898], [6.34406, 50.37994], [6.36852, 50.40776], [6.37219, 50.45397], [6.34005, 50.46083], [6.3465, 50.48833], [6.30809, 50.50058], [6.26637, 50.50272], [6.22335, 50.49578], [6.20599, 50.52089], [6.19193, 50.5212], [6.18716, 50.52653], [6.19579, 50.5313], [6.19735, 50.53576], [6.17802, 50.54179], [6.17739, 50.55875], [6.20281, 50.56952], [6.22581, 50.5907], [6.24005, 50.58732], [6.24888, 50.59869], [6.2476, 50.60392], [6.26957, 50.62444], [6.17852, 50.6245], [6.11707, 50.72231], [6.04428, 50.72861], [6.0406, 50.71848], [6.0326, 50.72647], [6.03889, 50.74618], [6.01976, 50.75398], [5.97545, 50.75441], [5.95942, 50.7622], [5.89132, 50.75124], [5.89129, 50.75125], [5.88734, 50.77092], [5.84888, 50.75448], [5.84548, 50.76542], [5.80673, 50.7558], [5.77513, 50.78308], [5.76533, 50.78159], [5.74356, 50.7691], [5.73904, 50.75674], [5.72216, 50.76398], [5.69469, 50.75529], [5.68091, 50.75804], [5.70107, 50.7827], [5.68995, 50.79641], [5.70118, 50.80764], [5.65259, 50.82309], [5.64009, 50.84742], [5.64504, 50.87107], [5.67886, 50.88142], [5.69858, 50.91046], [5.71626, 50.90796], [5.72644, 50.91167], [5.72545, 50.92312], [5.74644, 50.94723], [5.75927, 50.95601], [5.74752, 50.96202], [5.72875, 50.95428], [5.71864, 50.96092], [5.76242, 50.99703], [5.77688, 51.02483], [5.75961, 51.03113], [5.77258, 51.06196], [5.79835, 51.05834], [5.79903, 51.09371], [5.82921, 51.09328], [5.83226, 51.10585], [5.8109, 51.10861], [5.80798, 51.11661], [5.85508, 51.14445], [5.82564, 51.16753], [5.77697, 51.1522], [5.77735, 51.17845], [5.74617, 51.18928], [5.70344, 51.1829], [5.65528, 51.18736], [5.65145, 51.19788], [5.5603, 51.22249], [5.5569, 51.26544], [5.515, 51.29462], [5.48476, 51.30053], [5.46519, 51.2849], [5.4407, 51.28169], [5.41672, 51.26248], [5.347, 51.27502], [5.33886, 51.26314], [5.29716, 51.26104], [5.26461, 51.26693], [5.23814, 51.26064], [5.22542, 51.26888], [5.24244, 51.30495], [5.2002, 51.32243], [5.16222, 51.31035], [5.13377, 51.31592], [5.13105, 51.34791], [5.07102, 51.39469], [5.10456, 51.43163], [5.07891, 51.4715], [5.04774, 51.47022], [5.03281, 51.48679], [5.0106, 51.47167], [5.00393, 51.44406], [4.92152, 51.39487], [4.90016, 51.41404], [4.84988, 51.41502], [4.78941, 51.41102], [4.77229, 51.41337], [4.76577, 51.43046], [4.78314, 51.43319], [4.82946, 51.4213]]]] } },
    { type: "Feature", properties: { iso1A2: "BF", iso1A3: "BFA", iso1N3: "854", wikidata: "Q965", nameEn: "Burkina Faso", groups: ["011", "202", "002", "UN"], callingCodes: ["226"] }, geometry: { type: "MultiPolygon", coordinates: [[[[0.23859, 15.00135], [0.06588, 14.96961], [-0.24673, 15.07805], [-0.72004, 15.08655], [-1.05875, 14.7921], [-1.32166, 14.72774], [-1.68083, 14.50023], [-1.97945, 14.47709], [-1.9992, 14.19011], [-2.10223, 14.14878], [-2.47587, 14.29671], [-2.66175, 14.14713], [-2.84667, 14.05532], [-2.90831, 13.81174], [-2.88189, 13.64921], [-3.26407, 13.70699], [-3.28396, 13.5422], [-3.23599, 13.29035], [-3.43507, 13.27272], [-3.4313, 13.1588], [-3.54454, 13.1781], [-3.7911, 13.36665], [-3.96282, 13.38164], [-3.90558, 13.44375], [-3.96501, 13.49778], [-4.34477, 13.12927], [-4.21819, 12.95722], [-4.238, 12.71467], [-4.47356, 12.71252], [-4.41412, 12.31922], [-4.57703, 12.19875], [-4.54841, 12.1385], [-4.62546, 12.13204], [-4.62987, 12.06531], [-4.70692, 12.06746], [-4.72893, 12.01579], [-5.07897, 11.97918], [-5.26389, 11.84778], [-5.40258, 11.8327], [-5.26389, 11.75728], [-5.29251, 11.61715], [-5.22867, 11.60421], [-5.20665, 11.43811], [-5.25509, 11.36905], [-5.25949, 11.24816], [-5.32553, 11.21578], [-5.32994, 11.13371], [-5.49284, 11.07538], [-5.41579, 10.84628], [-5.47083, 10.75329], [-5.46643, 10.56074], [-5.51058, 10.43177], [-5.39602, 10.2929], [-5.12465, 10.29788], [-4.96453, 9.99923], [-4.96621, 9.89132], [-4.6426, 9.70696], [-4.31392, 9.60062], [-4.25999, 9.76012], [-3.69703, 9.94279], [-3.31779, 9.91125], [-3.27228, 9.84981], [-3.19306, 9.93781], [-3.16609, 9.85147], [-3.00765, 9.74019], [-2.93012, 9.57403], [-2.76494, 9.40778], [-2.68802, 9.49343], [-2.76534, 9.56589], [-2.74174, 9.83172], [-2.83108, 10.40252], [-2.94232, 10.64281], [-2.83373, 11.0067], [-0.67143, 10.99811], [-0.61937, 10.91305], [-0.44298, 11.04292], [-0.42391, 11.11661], [-0.38219, 11.12596], [-0.35955, 11.07801], [-0.28566, 11.12713], [-0.27374, 11.17157], [-0.13493, 11.14075], [0.50388, 11.01011], [0.48852, 10.98561], [0.50521, 10.98035], [0.4958, 10.93269], [0.66104, 10.99964], [0.91245, 10.99597], [0.9813, 11.08876], [1.03409, 11.04719], [1.42823, 11.46822], [2.00988, 11.42227], [2.29983, 11.68254], [2.39723, 11.89473], [2.05785, 12.35539], [2.26349, 12.41915], [0.99167, 13.10727], [0.99253, 13.37515], [1.18873, 13.31771], [1.21217, 13.37853], [1.24516, 13.33968], [1.28509, 13.35488], [1.24429, 13.39373], [1.20088, 13.38951], [1.02813, 13.46635], [0.99514, 13.5668], [0.77637, 13.64442], [0.77377, 13.6866], [0.61924, 13.68491], [0.38051, 14.05575], [0.16936, 14.51654], [0.23859, 15.00135]]]] } },
    { type: "Feature", properties: { iso1A2: "BG", iso1A3: "BGR", iso1N3: "100", wikidata: "Q219", nameEn: "Bulgaria", groups: ["EU", "151", "150", "UN"], callingCodes: ["359"] }, geometry: { type: "MultiPolygon", coordinates: [[[[23.05288, 43.79494], [22.85314, 43.84452], [22.83753, 43.88055], [22.87873, 43.9844], [23.01674, 44.01946], [23.04988, 44.07694], [22.67173, 44.21564], [22.61711, 44.16938], [22.61688, 44.06534], [22.41449, 44.00514], [22.35558, 43.81281], [22.41043, 43.69566], [22.47582, 43.6558], [22.53397, 43.47225], [22.82036, 43.33665], [22.89727, 43.22417], [23.00806, 43.19279], [22.98104, 43.11199], [22.89521, 43.03625], [22.78397, 42.98253], [22.74826, 42.88701], [22.54302, 42.87774], [22.43309, 42.82057], [22.4997, 42.74144], [22.43983, 42.56851], [22.55669, 42.50144], [22.51961, 42.3991], [22.47498, 42.3915], [22.45919, 42.33822], [22.34773, 42.31725], [22.38136, 42.30339], [22.47251, 42.20393], [22.50289, 42.19527], [22.51224, 42.15457], [22.67701, 42.06614], [22.86749, 42.02275], [22.90254, 41.87587], [22.96682, 41.77137], [23.01239, 41.76527], [23.03342, 41.71034], [22.95513, 41.63265], [22.96331, 41.35782], [22.93334, 41.34104], [23.1833, 41.31755], [23.21953, 41.33773], [23.22771, 41.37106], [23.31301, 41.40525], [23.33639, 41.36317], [23.40416, 41.39999], [23.52453, 41.40262], [23.63203, 41.37632], [23.67644, 41.41139], [23.76525, 41.40175], [23.80148, 41.43943], [23.89613, 41.45257], [23.91483, 41.47971], [23.96975, 41.44118], [24.06908, 41.46132], [24.06323, 41.53222], [24.10063, 41.54796], [24.18126, 41.51735], [24.27124, 41.57682], [24.30513, 41.51297], [24.52599, 41.56808], [24.61129, 41.42278], [24.71529, 41.41928], [24.8041, 41.34913], [24.82514, 41.4035], [24.86136, 41.39298], [24.90928, 41.40876], [24.942, 41.38685], [25.11611, 41.34212], [25.28322, 41.23411], [25.48187, 41.28506], [25.52394, 41.2798], [25.55082, 41.31667], [25.61042, 41.30614], [25.66183, 41.31316], [25.70507, 41.29209], [25.8266, 41.34563], [25.87919, 41.30526], [26.12926, 41.35878], [26.16548, 41.42278], [26.20288, 41.43943], [26.14796, 41.47533], [26.176, 41.50072], [26.17951, 41.55409], [26.14328, 41.55496], [26.15146, 41.60828], [26.07083, 41.64584], [26.06148, 41.70345], [26.16841, 41.74858], [26.21325, 41.73223], [26.22888, 41.74139], [26.2654, 41.71544], [26.30255, 41.70925], [26.35957, 41.71149], [26.32952, 41.73637], [26.33589, 41.76802], [26.36952, 41.82265], [26.53968, 41.82653], [26.57961, 41.90024], [26.56051, 41.92995], [26.62996, 41.97644], [26.79143, 41.97386], [26.95638, 42.00741], [27.03277, 42.0809], [27.08486, 42.08735], [27.19251, 42.06028], [27.22376, 42.10152], [27.27411, 42.10409], [27.45478, 41.96591], [27.52379, 41.93756], [27.55191, 41.90928], [27.69949, 41.97515], [27.81235, 41.94803], [27.83492, 41.99709], [27.91479, 41.97902], [28.02971, 41.98066], [28.32297, 41.98371], [29.24336, 43.70874], [28.23293, 43.76], [27.99558, 43.84193], [27.92008, 44.00761], [27.73468, 43.95326], [27.64542, 44.04958], [27.60834, 44.01206], [27.39757, 44.0141], [27.26845, 44.12602], [26.95141, 44.13555], [26.62712, 44.05698], [26.38764, 44.04356], [26.10115, 43.96908], [26.05584, 43.90925], [25.94911, 43.85745], [25.72792, 43.69263], [25.39528, 43.61866], [25.17144, 43.70261], [25.10718, 43.6831], [24.96682, 43.72693], [24.73542, 43.68523], [24.62281, 43.74082], [24.50264, 43.76314], [24.35364, 43.70211], [24.18149, 43.68218], [23.73978, 43.80627], [23.61687, 43.79289], [23.4507, 43.84936], [23.26772, 43.84843], [23.05288, 43.79494]]]] } },
    { type: "Feature", properties: { iso1A2: "BH", iso1A3: "BHR", iso1N3: "048", wikidata: "Q398", nameEn: "Bahrain", groups: ["145", "142", "UN"], callingCodes: ["973"] }, geometry: { type: "MultiPolygon", coordinates: [[[[50.93865, 26.30758], [50.71771, 26.73086], [50.38162, 26.53976], [50.26923, 26.08243], [50.302, 25.87592], [50.57069, 25.57887], [50.80824, 25.54641], [50.7801, 25.595], [50.86149, 25.6965], [50.81266, 25.88946], [50.93865, 26.30758]]]] } },
    { type: "Feature", properties: { iso1A2: "BI", iso1A3: "BDI", iso1N3: "108", wikidata: "Q967", nameEn: "Burundi", groups: ["014", "202", "002", "UN"], callingCodes: ["257"] }, geometry: { type: "MultiPolygon", coordinates: [[[[30.54501, -2.41404], [30.42933, -2.31064], [30.14034, -2.43626], [29.95911, -2.33348], [29.88237, -2.75105], [29.36805, -2.82933], [29.32234, -2.6483], [29.0562, -2.58632], [29.04081, -2.7416], [29.00167, -2.78523], [29.00404, -2.81978], [29.0505, -2.81774], [29.09119, -2.87871], [29.09797, -2.91935], [29.16037, -2.95457], [29.17258, -2.99385], [29.25633, -3.05471], [29.21463, -3.3514], [29.23708, -3.75856], [29.43673, -4.44845], [29.63827, -4.44681], [29.75109, -4.45836], [29.77289, -4.41733], [29.82885, -4.36153], [29.88172, -4.35743], [30.03323, -4.26631], [30.22042, -4.01738], [30.45915, -3.56532], [30.84165, -3.25152], [30.83823, -2.97837], [30.6675, -2.98987], [30.57926, -2.89791], [30.4987, -2.9573], [30.40662, -2.86151], [30.52747, -2.65841], [30.41789, -2.66266], [30.54501, -2.41404]]]] } },
    { type: "Feature", properties: { iso1A2: "BJ", iso1A3: "BEN", iso1N3: "204", wikidata: "Q962", nameEn: "Benin", aliases: ["DY"], groups: ["011", "202", "002", "UN"], callingCodes: ["229"] }, geometry: { type: "MultiPolygon", coordinates: [[[[3.59375, 11.70269], [3.48187, 11.86092], [3.31613, 11.88495], [3.25352, 12.01467], [2.83978, 12.40585], [2.6593, 12.30631], [2.37783, 12.24804], [2.39657, 12.10952], [2.45824, 11.98672], [2.39723, 11.89473], [2.29983, 11.68254], [2.00988, 11.42227], [1.42823, 11.46822], [1.03409, 11.04719], [0.9813, 11.08876], [0.91245, 10.99597], [0.8804, 10.803], [0.80358, 10.71459], [0.77666, 10.37665], [1.35507, 9.99525], [1.36624, 9.5951], [1.33675, 9.54765], [1.41746, 9.3226], [1.5649, 9.16941], [1.61838, 9.0527], [1.64249, 6.99562], [1.55877, 6.99737], [1.61812, 6.74843], [1.58105, 6.68619], [1.76906, 6.43189], [1.79826, 6.28221], [1.62913, 6.24075], [1.67336, 6.02702], [2.74181, 6.13349], [2.70566, 6.38038], [2.70464, 6.50831], [2.74334, 6.57291], [2.7325, 6.64057], [2.78204, 6.70514], [2.78823, 6.76356], [2.73405, 6.78508], [2.74024, 6.92802], [2.71702, 6.95722], [2.76965, 7.13543], [2.74489, 7.42565], [2.79442, 7.43486], [2.78668, 7.5116], [2.73405, 7.5423], [2.73095, 7.7755], [2.67523, 7.87825], [2.77907, 9.06924], [3.08017, 9.10006], [3.14147, 9.28375], [3.13928, 9.47167], [3.25093, 9.61632], [3.34726, 9.70696], [3.32099, 9.78032], [3.35383, 9.83641], [3.54429, 9.87739], [3.66908, 10.18136], [3.57275, 10.27185], [3.6844, 10.46351], [3.78292, 10.40538], [3.84243, 10.59316], [3.71505, 11.13015], [3.49175, 11.29765], [3.59375, 11.70269]]]] } },
    { type: "Feature", properties: { iso1A2: "BL", iso1A3: "BLM", iso1N3: "652", wikidata: "Q25362", nameEn: "Saint-Barth\xE9lemy", country: "FR", groups: ["EU", "Q1451600", "029", "003", "419", "019", "UN"], callingCodes: ["590"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-62.62718, 18.26185], [-63.1055, 17.86651], [-62.34423, 17.49165], [-62.62718, 18.26185]]]] } },
    { type: "Feature", properties: { iso1A2: "BM", iso1A3: "BMU", iso1N3: "060", wikidata: "Q23635", nameEn: "Bermuda", country: "GB", groups: ["BOTS", "021", "003", "019", "UN"], driveSide: "left", callingCodes: ["1 441"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-63.20987, 32.6953], [-65.31453, 32.68437], [-65.63955, 31.43417], [-63.20987, 32.6953]]]] } },
    { type: "Feature", properties: { iso1A2: "BN", iso1A3: "BRN", iso1N3: "096", wikidata: "Q921", nameEn: "Brunei", groups: ["Q36117", "035", "142", "UN"], driveSide: "left", callingCodes: ["673"] }, geometry: { type: "MultiPolygon", coordinates: [[[[115.16236, 5.01011], [115.02521, 5.35005], [114.10166, 4.76112], [114.07448, 4.58441], [114.15813, 4.57], [114.26876, 4.49878], [114.32176, 4.34942], [114.32176, 4.2552], [114.4416, 4.27588], [114.49922, 4.13108], [114.64211, 4.00694], [114.78539, 4.12205], [114.88039, 4.4257], [114.83189, 4.42387], [114.77303, 4.72871], [114.8266, 4.75062], [114.88841, 4.81905], [114.96982, 4.81146], [114.99417, 4.88201], [115.05038, 4.90275], [115.02955, 4.82087], [115.02278, 4.74137], [115.04064, 4.63706], [115.07737, 4.53418], [115.09978, 4.39123], [115.31275, 4.30806], [115.36346, 4.33563], [115.2851, 4.42295], [115.27819, 4.63661], [115.20737, 4.8256], [115.15092, 4.87604], [115.16236, 5.01011]]]] } },
    { type: "Feature", properties: { iso1A2: "BO", iso1A3: "BOL", iso1N3: "068", wikidata: "Q750", nameEn: "Bolivia", groups: ["005", "419", "019", "UN"], callingCodes: ["591"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-63.90248, -12.52544], [-64.22539, -12.45267], [-64.30708, -12.46398], [-64.99778, -11.98604], [-65.30027, -11.48749], [-65.28141, -10.86289], [-65.35402, -10.78685], [-65.37923, -10.35141], [-65.29019, -9.86253], [-65.40615, -9.63894], [-65.56244, -9.84266], [-65.68343, -9.75323], [-67.17784, -10.34016], [-68.71533, -11.14749], [-68.7651, -11.0496], [-68.75179, -11.03688], [-68.75265, -11.02383], [-68.74802, -11.00891], [-69.42792, -10.93451], [-69.47839, -10.95254], [-69.57156, -10.94555], [-68.98115, -11.8979], [-68.65044, -12.50689], [-68.85615, -12.87769], [-68.8864, -13.40792], [-69.05265, -13.68546], [-68.88135, -14.18639], [-69.36254, -14.94634], [-69.14856, -15.23478], [-69.40336, -15.61358], [-69.20291, -16.16668], [-69.09986, -16.22693], [-68.96238, -16.194], [-68.79464, -16.33272], [-68.98358, -16.42165], [-69.04027, -16.57214], [-69.00853, -16.66769], [-69.16896, -16.72233], [-69.62883, -17.28142], [-69.46863, -17.37466], [-69.46897, -17.4988], [-69.46623, -17.60518], [-69.34126, -17.72753], [-69.28671, -17.94844], [-69.07496, -18.03715], [-69.14807, -18.16893], [-69.07432, -18.28259], [-68.94987, -18.93302], [-68.87082, -19.06003], [-68.80602, -19.08355], [-68.61989, -19.27584], [-68.41218, -19.40499], [-68.66761, -19.72118], [-68.54611, -19.84651], [-68.57132, -20.03134], [-68.74273, -20.08817], [-68.7276, -20.46178], [-68.44023, -20.62701], [-68.55383, -20.7355], [-68.53957, -20.91542], [-68.40403, -20.94562], [-68.18816, -21.28614], [-67.85114, -22.87076], [-67.54284, -22.89771], [-67.18382, -22.81525], [-66.7298, -22.23644], [-66.29714, -22.08741], [-66.24077, -21.77837], [-66.03836, -21.84829], [-66.04832, -21.9187], [-65.9261, -21.93335], [-65.7467, -22.10105], [-65.61166, -22.09504], [-65.58694, -22.09794], [-65.57743, -22.07675], [-65.47435, -22.08908], [-64.99524, -22.08255], [-64.90014, -22.12136], [-64.67174, -22.18957], [-64.58888, -22.25035], [-64.4176, -22.67692], [-64.35108, -22.73282], [-64.31489, -22.88824], [-64.22918, -22.55807], [-63.93287, -21.99934], [-63.70963, -21.99934], [-63.68113, -22.0544], [-63.66482, -21.99918], [-62.81124, -21.9987], [-62.8078, -22.12534], [-62.64455, -22.25091], [-62.2757, -21.06657], [-62.26883, -20.55311], [-61.93912, -20.10053], [-61.73723, -19.63958], [-60.00638, -19.2981], [-59.06965, -19.29148], [-58.23216, -19.80058], [-58.16225, -20.16193], [-57.8496, -19.98346], [-58.14215, -19.76276], [-57.78463, -19.03259], [-57.71113, -19.03161], [-57.69134, -19.00544], [-57.71995, -18.97546], [-57.71995, -18.89573], [-57.76764, -18.90087], [-57.56807, -18.25655], [-57.48237, -18.24219], [-57.69877, -17.8431], [-57.73949, -17.56095], [-57.90082, -17.44555], [-57.99661, -17.5273], [-58.32935, -17.28195], [-58.5058, -16.80958], [-58.30918, -16.3699], [-58.32431, -16.25861], [-58.41506, -16.32636], [-60.16069, -16.26479], [-60.23797, -15.50267], [-60.58224, -15.09887], [-60.23968, -15.09515], [-60.27887, -14.63021], [-60.46037, -14.22496], [-60.48053, -13.77981], [-61.05527, -13.50054], [-61.81151, -13.49564], [-63.76259, -12.42952], [-63.90248, -12.52544]]]] } },
    { type: "Feature", properties: { iso1A2: "BQ", iso1A3: "BES", iso1N3: "535", wikidata: "Q27561", nameEn: "Caribbean Netherlands", country: "NL" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "BR", iso1A3: "BRA", iso1N3: "076", wikidata: "Q155", nameEn: "Brazil", groups: ["005", "419", "019", "UN"], callingCodes: ["55"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-59.69361, 4.34069], [-59.78878, 4.45637], [-60.15953, 4.53456], [-60.04189, 4.69801], [-59.98129, 5.07097], [-60.20944, 5.28754], [-60.32352, 5.21299], [-60.73204, 5.20931], [-60.5802, 4.94312], [-60.86539, 4.70512], [-60.98303, 4.54167], [-61.15703, 4.49839], [-61.31457, 4.54167], [-61.29675, 4.44216], [-61.48569, 4.43149], [-61.54629, 4.2822], [-62.13094, 4.08309], [-62.44822, 4.18621], [-62.57656, 4.04754], [-62.74411, 4.03331], [-62.7655, 3.73099], [-62.98296, 3.59935], [-63.21111, 3.96219], [-63.4464, 3.9693], [-63.42233, 3.89995], [-63.50611, 3.83592], [-63.67099, 4.01731], [-63.70218, 3.91417], [-63.86082, 3.94796], [-63.99183, 3.90172], [-64.14512, 4.12932], [-64.57648, 4.12576], [-64.72977, 4.28931], [-64.84028, 4.24665], [-64.48379, 3.7879], [-64.02908, 2.79797], [-64.0257, 2.48156], [-63.39114, 2.4317], [-63.39827, 2.16098], [-64.06135, 1.94722], [-64.08274, 1.64792], [-64.34654, 1.35569], [-64.38932, 1.5125], [-65.11657, 1.12046], [-65.57288, 0.62856], [-65.50158, 0.92086], [-65.6727, 1.01353], [-66.28507, 0.74585], [-66.85795, 1.22998], [-67.08222, 1.17441], [-67.15784, 1.80439], [-67.299, 1.87494], [-67.40488, 2.22258], [-67.9292, 1.82455], [-68.18632, 2.00091], [-68.26699, 1.83463], [-68.18128, 1.72881], [-69.38621, 1.70865], [-69.53746, 1.76408], [-69.83491, 1.69353], [-69.82987, 1.07864], [-69.26017, 1.06856], [-69.14422, 0.84172], [-69.20976, 0.57958], [-69.47696, 0.71065], [-70.04162, 0.55437], [-70.03658, -0.19681], [-69.603, -0.51947], [-69.59796, -0.75136], [-69.4215, -1.01853], [-69.43395, -1.42219], [-69.94708, -4.2431], [-70.00888, -4.37833], [-70.11305, -4.27281], [-70.19582, -4.3607], [-70.33236, -4.15214], [-70.77601, -4.15717], [-70.96814, -4.36915], [-71.87003, -4.51661], [-72.64391, -5.0391], [-72.83973, -5.14765], [-73.24579, -6.05764], [-73.12983, -6.43852], [-73.73986, -6.87919], [-73.77011, -7.28944], [-73.96938, -7.58465], [-73.65485, -7.77897], [-73.76576, -7.89884], [-72.92886, -9.04074], [-73.21498, -9.40904], [-72.72216, -9.41397], [-72.31883, -9.5184], [-72.14742, -9.98049], [-71.23394, -9.9668], [-70.53373, -9.42628], [-70.58453, -9.58303], [-70.55429, -9.76692], [-70.62487, -9.80666], [-70.64134, -11.0108], [-70.51395, -10.92249], [-70.38791, -11.07096], [-69.90896, -10.92744], [-69.57835, -10.94051], [-69.57156, -10.94555], [-69.47839, -10.95254], [-69.42792, -10.93451], [-68.74802, -11.00891], [-68.75265, -11.02383], [-68.75179, -11.03688], [-68.7651, -11.0496], [-68.71533, -11.14749], [-67.17784, -10.34016], [-65.68343, -9.75323], [-65.56244, -9.84266], [-65.40615, -9.63894], [-65.29019, -9.86253], [-65.37923, -10.35141], [-65.35402, -10.78685], [-65.28141, -10.86289], [-65.30027, -11.48749], [-64.99778, -11.98604], [-64.30708, -12.46398], [-64.22539, -12.45267], [-63.90248, -12.52544], [-63.76259, -12.42952], [-61.81151, -13.49564], [-61.05527, -13.50054], [-60.48053, -13.77981], [-60.46037, -14.22496], [-60.27887, -14.63021], [-60.23968, -15.09515], [-60.58224, -15.09887], [-60.23797, -15.50267], [-60.16069, -16.26479], [-58.41506, -16.32636], [-58.32431, -16.25861], [-58.30918, -16.3699], [-58.5058, -16.80958], [-58.32935, -17.28195], [-57.99661, -17.5273], [-57.90082, -17.44555], [-57.73949, -17.56095], [-57.69877, -17.8431], [-57.48237, -18.24219], [-57.56807, -18.25655], [-57.76764, -18.90087], [-57.71995, -18.89573], [-57.71995, -18.97546], [-57.69134, -19.00544], [-57.71113, -19.03161], [-57.78463, -19.03259], [-58.14215, -19.76276], [-57.8496, -19.98346], [-58.16225, -20.16193], [-57.84536, -20.93155], [-57.93492, -21.65505], [-57.88239, -21.6868], [-57.94642, -21.73799], [-57.98625, -22.09157], [-56.6508, -22.28387], [-56.5212, -22.11556], [-56.45893, -22.08072], [-56.23206, -22.25347], [-55.8331, -22.29008], [-55.74941, -22.46436], [-55.741, -22.52018], [-55.72366, -22.5519], [-55.6986, -22.56268], [-55.68742, -22.58407], [-55.62493, -22.62765], [-55.63849, -22.95122], [-55.5446, -23.22811], [-55.52288, -23.2595], [-55.5555, -23.28237], [-55.43585, -23.87157], [-55.44117, -23.9185], [-55.41784, -23.9657], [-55.12292, -23.99669], [-55.0518, -23.98666], [-55.02691, -23.97317], [-54.6238, -23.83078], [-54.32807, -24.01865], [-54.28207, -24.07305], [-54.4423, -25.13381], [-54.62033, -25.46026], [-54.60196, -25.48397], [-54.59509, -25.53696], [-54.59398, -25.59224], [-54.5502, -25.58915], [-54.52926, -25.62846], [-53.90831, -25.55513], [-53.83691, -25.94849], [-53.73511, -26.04211], [-53.73086, -26.05842], [-53.7264, -26.0664], [-53.73391, -26.07006], [-53.73968, -26.10012], [-53.65018, -26.19501], [-53.65237, -26.23289], [-53.63739, -26.2496], [-53.63881, -26.25075], [-53.64632, -26.24798], [-53.64186, -26.25976], [-53.64505, -26.28089], [-53.68269, -26.33359], [-53.73372, -26.6131], [-53.80144, -27.09844], [-54.15978, -27.2889], [-54.19062, -27.27639], [-54.19268, -27.30751], [-54.41888, -27.40882], [-54.50416, -27.48232], [-54.67657, -27.57214], [-54.90159, -27.63132], [-54.90805, -27.73149], [-55.1349, -27.89759], [-55.16872, -27.86224], [-55.33303, -27.94661], [-55.6262, -28.17124], [-55.65418, -28.18304], [-56.01729, -28.51223], [-56.00458, -28.60421], [-56.05265, -28.62651], [-56.54171, -29.11447], [-56.57295, -29.11357], [-56.62789, -29.18073], [-56.81251, -29.48154], [-57.09386, -29.74211], [-57.65132, -30.19229], [-57.22502, -30.26121], [-56.90236, -30.02578], [-56.49267, -30.39471], [-56.4795, -30.3899], [-56.4619, -30.38457], [-55.87388, -31.05053], [-55.58866, -30.84117], [-55.5634, -30.8686], [-55.55373, -30.8732], [-55.55218, -30.88193], [-55.54572, -30.89051], [-55.53431, -30.89714], [-55.53276, -30.90218], [-55.52712, -30.89997], [-55.51862, -30.89828], [-55.50841, -30.9027], [-55.50821, -30.91349], [-54.17384, -31.86168], [-53.76024, -32.0751], [-53.39572, -32.58596], [-53.37671, -32.57005], [-53.1111, -32.71147], [-53.53459, -33.16843], [-53.52794, -33.68908], [-53.44031, -33.69344], [-53.39593, -33.75169], [-53.37138, -33.74313], [-52.83257, -34.01481], [-28.34015, -20.99094], [-28.99601, 1.86593], [-51.35485, 4.8383], [-51.63798, 4.51394], [-51.61983, 4.14596], [-51.79599, 3.89336], [-51.82312, 3.85825], [-51.85573, 3.83427], [-52.31787, 3.17896], [-52.6906, 2.37298], [-52.96539, 2.1881], [-53.78743, 2.34412], [-54.16286, 2.10779], [-54.6084, 2.32856], [-55.01919, 2.564], [-55.71493, 2.40342], [-55.96292, 2.53188], [-56.13054, 2.27723], [-55.92159, 2.05236], [-55.89863, 1.89861], [-55.99278, 1.83137], [-56.47045, 1.95135], [-56.7659, 1.89509], [-57.07092, 1.95304], [-57.09109, 2.01854], [-57.23981, 1.95808], [-57.35073, 1.98327], [-57.55743, 1.69605], [-57.77281, 1.73344], [-57.97336, 1.64566], [-58.01873, 1.51966], [-58.33887, 1.58014], [-58.4858, 1.48399], [-58.53571, 1.29154], [-58.84229, 1.17749], [-58.92072, 1.31293], [-59.25583, 1.40559], [-59.74066, 1.87596], [-59.7264, 2.27497], [-59.91177, 2.36759], [-59.99733, 2.92312], [-59.79769, 3.37162], [-59.86899, 3.57089], [-59.51963, 3.91951], [-59.73353, 4.20399], [-59.69361, 4.34069]]]] } },
    { type: "Feature", properties: { iso1A2: "BS", iso1A3: "BHS", iso1N3: "044", wikidata: "Q778", nameEn: "The Bahamas", groups: ["029", "003", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", callingCodes: ["1 242"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-72.98446, 20.4801], [-71.70065, 25.7637], [-78.91214, 27.76553], [-80.65727, 23.71953], [-72.98446, 20.4801]]]] } },
    { type: "Feature", properties: { iso1A2: "BT", iso1A3: "BTN", iso1N3: "064", wikidata: "Q917", nameEn: "Bhutan", groups: ["034", "142", "UN"], driveSide: "left", callingCodes: ["975"] }, geometry: { type: "MultiPolygon", coordinates: [[[[91.6469, 27.76358], [91.5629, 27.84823], [91.48973, 27.93903], [91.46327, 28.0064], [91.25779, 28.07509], [91.20019, 27.98715], [90.69894, 28.07784], [90.58842, 28.02838], [90.13387, 28.19178], [89.79762, 28.23979], [89.59525, 28.16433], [89.12825, 27.62502], [89.0582, 27.60985], [88.97213, 27.51671], [88.95355, 27.4106], [89.00216, 27.32532], [88.96947, 27.30319], [88.93678, 27.33777], [88.91901, 27.32483], [88.74219, 27.144], [88.86984, 27.10937], [88.8714, 26.97488], [88.92301, 26.99286], [88.95807, 26.92668], [89.09554, 26.89089], [89.12825, 26.81661], [89.1926, 26.81329], [89.37913, 26.86224], [89.38319, 26.85963], [89.3901, 26.84225], [89.42349, 26.83727], [89.63369, 26.74402], [89.86124, 26.73307], [90.04535, 26.72422], [90.30402, 26.85098], [90.39271, 26.90704], [90.48504, 26.8594], [90.67715, 26.77215], [91.50067, 26.79223], [91.83181, 26.87318], [92.05523, 26.8692], [92.11863, 26.893], [92.03457, 27.07334], [92.04702, 27.26861], [92.12019, 27.27829], [92.01132, 27.47352], [91.65007, 27.48287], [91.55819, 27.6144], [91.6469, 27.76358]]]] } },
    { type: "Feature", properties: { iso1A2: "BV", iso1A3: "BVT", iso1N3: "074", wikidata: "Q23408", nameEn: "Bouvet Island", country: "NO", groups: ["005", "419", "019", "UN"] }, geometry: { type: "MultiPolygon", coordinates: [[[[4.54042, -54.0949], [2.28941, -54.13089], [3.35353, -55.17558], [4.54042, -54.0949]]]] } },
    { type: "Feature", properties: { iso1A2: "BW", iso1A3: "BWA", iso1N3: "072", wikidata: "Q963", nameEn: "Botswana", groups: ["018", "202", "002", "UN"], driveSide: "left", callingCodes: ["267"] }, geometry: { type: "MultiPolygon", coordinates: [[[[25.26433, -17.79571], [25.16882, -17.78253], [25.05895, -17.84452], [24.95586, -17.79674], [24.73364, -17.89338], [24.71887, -17.9218], [24.6303, -17.9863], [24.57485, -18.07151], [24.40577, -17.95726], [24.19416, -18.01919], [23.61088, -18.4881], [23.29618, -17.99855], [23.0996, -18.00075], [21.45556, -18.31795], [20.99904, -18.31743], [20.99751, -22.00026], [19.99912, -21.99991], [19.99817, -24.76768], [20.02809, -24.78725], [20.03678, -24.81004], [20.29826, -24.94869], [20.64795, -25.47827], [20.86081, -26.14892], [20.61754, -26.4692], [20.63275, -26.78181], [20.68596, -26.9039], [20.87031, -26.80047], [21.13353, -26.86661], [21.37869, -26.82083], [21.69322, -26.86152], [21.7854, -26.79199], [21.77114, -26.69015], [21.83291, -26.65959], [21.90703, -26.66808], [22.06192, -26.61882], [22.21206, -26.3773], [22.41921, -26.23078], [22.56365, -26.19668], [22.70808, -25.99186], [22.86012, -25.50572], [23.03497, -25.29971], [23.47588, -25.29971], [23.9244, -25.64286], [24.18287, -25.62916], [24.36531, -25.773], [24.44703, -25.73021], [24.67319, -25.81749], [24.8946, -25.80723], [25.01718, -25.72507], [25.12266, -25.75931], [25.33076, -25.76616], [25.58543, -25.6343], [25.6643, -25.4491], [25.69661, -25.29284], [25.72702, -25.25503], [25.88571, -24.87802], [25.84295, -24.78661], [25.8515, -24.75727], [26.39409, -24.63468], [26.46346, -24.60358], [26.51667, -24.47219], [26.84165, -24.24885], [26.99749, -23.65486], [27.33768, -23.40917], [27.52393, -23.37952], [27.6066, -23.21894], [27.74154, -23.2137], [27.93539, -23.04941], [27.93729, -22.96194], [28.04752, -22.90243], [28.04562, -22.8394], [28.34874, -22.5694], [28.63287, -22.55887], [28.91889, -22.44299], [29.0151, -22.22907], [29.10881, -22.21202], [29.15268, -22.21399], [29.18974, -22.18599], [29.21955, -22.17771], [29.37703, -22.19581], [29.3533, -22.18363], [29.24648, -22.05967], [29.1974, -22.07472], [29.14501, -22.07275], [29.08495, -22.04867], [29.04108, -22.00563], [29.02191, -21.95665], [29.02191, -21.90647], [29.04023, -21.85864], [29.07763, -21.81877], [28.58114, -21.63455], [28.49942, -21.66634], [28.29416, -21.59037], [28.01669, -21.57624], [27.91407, -21.31621], [27.69171, -21.08409], [27.72972, -20.51735], [27.69361, -20.48531], [27.28865, -20.49873], [27.29831, -20.28935], [27.21278, -20.08244], [26.72246, -19.92707], [26.17227, -19.53709], [25.96226, -19.08152], [25.99837, -19.02943], [25.94326, -18.90362], [25.82353, -18.82808], [25.79217, -18.6355], [25.68859, -18.56165], [25.53465, -18.39041], [25.39972, -18.12691], [25.31799, -18.07091], [25.23909, -17.90832], [25.26433, -17.79571]]]] } },
    { type: "Feature", properties: { iso1A2: "BY", iso1A3: "BLR", iso1N3: "112", wikidata: "Q184", nameEn: "Belarus", groups: ["151", "150", "UN"], callingCodes: ["375"] }, geometry: { type: "MultiPolygon", coordinates: [[[[28.15217, 56.16964], [27.97865, 56.11849], [27.63065, 55.89687], [27.61683, 55.78558], [27.3541, 55.8089], [27.27804, 55.78299], [27.1559, 55.85032], [26.97153, 55.8102], [26.87448, 55.7172], [26.76872, 55.67658], [26.71802, 55.70645], [26.64888, 55.70515], [26.63231, 55.67968], [26.63167, 55.57887], [26.55094, 55.5093], [26.5522, 55.40277], [26.44937, 55.34832], [26.5709, 55.32572], [26.6714, 55.33902], [26.80929, 55.31642], [26.83266, 55.30444], [26.835, 55.28182], [26.73017, 55.24226], [26.72983, 55.21788], [26.68075, 55.19787], [26.69243, 55.16718], [26.54753, 55.14181], [26.51481, 55.16051], [26.46249, 55.12814], [26.35121, 55.1525], [26.30628, 55.12536], [26.23202, 55.10439], [26.26941, 55.08032], [26.20397, 54.99729], [26.13386, 54.98924], [26.05907, 54.94631], [25.99129, 54.95705], [25.89462, 54.93438], [25.74122, 54.80108], [25.75977, 54.57252], [25.68045, 54.5321], [25.64813, 54.48704], [25.62203, 54.4656], [25.63371, 54.42075], [25.5376, 54.33158], [25.55425, 54.31591], [25.68513, 54.31727], [25.78553, 54.23327], [25.78563, 54.15747], [25.71084, 54.16704], [25.64875, 54.1259], [25.54724, 54.14925], [25.51452, 54.17799], [25.56823, 54.25212], [25.509, 54.30267], [25.35559, 54.26544], [25.22705, 54.26271], [25.19199, 54.219], [25.0728, 54.13419], [24.991, 54.14241], [24.96894, 54.17589], [24.77131, 54.11091], [24.85311, 54.02862], [24.74279, 53.96663], [24.69185, 53.96543], [24.69652, 54.01901], [24.62275, 54.00217], [24.44411, 53.90076], [24.34128, 53.90076], [24.19638, 53.96405], [23.98837, 53.92554], [23.95098, 53.9613], [23.81309, 53.94205], [23.80543, 53.89558], [23.71726, 53.93379], [23.61677, 53.92691], [23.51284, 53.95052], [23.62004, 53.60942], [23.81995, 53.24131], [23.85657, 53.22923], [23.91393, 53.16469], [23.87548, 53.0831], [23.92184, 53.02079], [23.94689, 52.95919], [23.91805, 52.94016], [23.93763, 52.71332], [23.73615, 52.6149], [23.58296, 52.59868], [23.45112, 52.53774], [23.34141, 52.44845], [23.18196, 52.28812], [23.20071, 52.22848], [23.47859, 52.18215], [23.54314, 52.12148], [23.61, 52.11264], [23.64066, 52.07626], [23.68733, 51.9906], [23.61523, 51.92066], [23.62691, 51.78208], [23.53198, 51.74298], [23.57053, 51.55938], [23.56236, 51.53673], [23.62751, 51.50512], [23.6736, 51.50255], [23.60906, 51.62122], [23.7766, 51.66809], [23.91118, 51.63316], [23.8741, 51.59734], [23.99907, 51.58369], [24.13075, 51.66979], [24.3163, 51.75063], [24.29021, 51.80841], [24.37123, 51.88222], [24.98784, 51.91273], [25.20228, 51.97143], [25.46163, 51.92205], [25.73673, 51.91973], [25.80574, 51.94556], [25.83217, 51.92587], [26.00408, 51.92967], [26.19084, 51.86781], [26.39367, 51.87315], [26.46962, 51.80501], [26.69759, 51.82284], [26.80043, 51.75777], [26.9489, 51.73788], [26.99422, 51.76933], [27.20602, 51.77291], [27.20948, 51.66713], [27.26613, 51.65957], [27.24828, 51.60161], [27.47212, 51.61184], [27.51058, 51.5854], [27.55727, 51.63486], [27.71932, 51.60672], [27.67125, 51.50854], [27.76052, 51.47604], [27.85253, 51.62293], [27.91844, 51.61952], [27.95827, 51.56065], [28.10658, 51.57857], [28.23452, 51.66988], [28.37592, 51.54505], [28.47051, 51.59734], [28.64429, 51.5664], [28.69161, 51.44695], [28.73143, 51.46236], [28.75615, 51.41442], [28.78224, 51.45294], [28.76027, 51.48802], [28.81795, 51.55552], [28.95528, 51.59222], [28.99098, 51.56833], [29.1187, 51.65872], [29.16402, 51.64679], [29.20659, 51.56918], [29.25603, 51.57089], [29.25191, 51.49828], [29.32881, 51.37843], [29.42357, 51.4187], [29.49773, 51.39814], [29.54372, 51.48372], [29.7408, 51.53417], [29.77376, 51.4461], [30.17888, 51.51025], [30.34642, 51.42555], [30.36153, 51.33984], [30.56203, 51.25655], [30.64992, 51.35014], [30.51946, 51.59649], [30.68804, 51.82806], [30.76443, 51.89739], [30.90897, 52.00699], [30.95589, 52.07775], [31.13332, 52.1004], [31.25142, 52.04131], [31.38326, 52.12991], [31.7822, 52.11406], [31.77877, 52.18636], [31.6895, 52.1973], [31.70735, 52.26711], [31.57971, 52.32146], [31.62084, 52.33849], [31.61397, 52.48843], [31.56316, 52.51518], [31.63869, 52.55361], [31.50406, 52.69707], [31.57277, 52.71613], [31.592, 52.79011], [31.35667, 52.97854], [31.24147, 53.031], [31.32283, 53.04101], [31.33519, 53.08805], [31.3915, 53.09712], [31.36403, 53.13504], [31.40523, 53.21406], [31.56316, 53.19432], [31.62496, 53.22886], [31.787, 53.18033], [31.82373, 53.10042], [32.15368, 53.07594], [32.40773, 53.18856], [32.51725, 53.28431], [32.73257, 53.33494], [32.74968, 53.45597], [32.47777, 53.5548], [32.40499, 53.6656], [32.50112, 53.68594], [32.45717, 53.74039], [32.36663, 53.7166], [32.12621, 53.81586], [31.89137, 53.78099], [31.77028, 53.80015], [31.85019, 53.91801], [31.88744, 54.03653], [31.89599, 54.0837], [31.57002, 54.14535], [31.30791, 54.25315], [31.3177, 54.34067], [31.22945, 54.46585], [31.08543, 54.50361], [31.21399, 54.63113], [31.19339, 54.66947], [30.99187, 54.67046], [30.98226, 54.68872], [31.0262, 54.70698], [30.97127, 54.71967], [30.95479, 54.74346], [30.75165, 54.80699], [30.8264, 54.90062], [30.81759, 54.94064], [30.93144, 54.9585], [30.95754, 54.98609], [30.9081, 55.02232], [30.94243, 55.03964], [31.00972, 55.02783], [31.02071, 55.06167], [30.97369, 55.17134], [30.87944, 55.28223], [30.81946, 55.27931], [30.8257, 55.3313], [30.93144, 55.3914], [30.90123, 55.46621], [30.95204, 55.50667], [30.93419, 55.6185], [30.86003, 55.63169], [30.7845, 55.58514], [30.72957, 55.66268], [30.67464, 55.64176], [30.63344, 55.73079], [30.51037, 55.76568], [30.51346, 55.78982], [30.48257, 55.81066], [30.30987, 55.83592], [30.27776, 55.86819], [30.12136, 55.8358], [29.97975, 55.87281], [29.80672, 55.79569], [29.61446, 55.77716], [29.51283, 55.70294], [29.3604, 55.75862], [29.44692, 55.95978], [29.21717, 55.98971], [29.08299, 56.03427], [28.73418, 55.97131], [28.63668, 56.07262], [28.68337, 56.10173], [28.5529, 56.11705], [28.43068, 56.09407], [28.37987, 56.11399], [28.36888, 56.05805], [28.30571, 56.06035], [28.15217, 56.16964]]]] } },
    { type: "Feature", properties: { iso1A2: "BZ", iso1A3: "BLZ", iso1N3: "084", wikidata: "Q242", nameEn: "Belize", groups: ["013", "003", "419", "019", "UN"], roadSpeedUnit: "mph", callingCodes: ["501"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-88.3268, 18.49048], [-88.48242, 18.49164], [-88.71505, 18.0707], [-88.8716, 17.89535], [-89.03839, 18.0067], [-89.15105, 17.95104], [-89.14985, 17.81563], [-89.15025, 17.04813], [-89.22683, 15.88619], [-89.17418, 15.90898], [-89.02415, 15.9063], [-88.95358, 15.88698], [-88.40779, 16.09624], [-86.92368, 17.61462], [-87.84815, 18.18511], [-87.85693, 18.18266], [-87.86657, 18.19971], [-87.87604, 18.18313], [-87.90671, 18.15213], [-88.03165, 18.16657], [-88.03238, 18.41778], [-88.26593, 18.47617], [-88.29909, 18.47591], [-88.3268, 18.49048]]]] } },
    { type: "Feature", properties: { iso1A2: "CA", iso1A3: "CAN", iso1N3: "124", wikidata: "Q16", nameEn: "Canada", groups: ["021", "003", "019", "UN"], callingCodes: ["1"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-67.20349, 45.1722], [-67.19603, 45.16771], [-67.15965, 45.16179], [-67.11316, 45.11176], [-67.0216, 44.95333], [-66.96824, 44.90965], [-66.98249, 44.87071], [-66.96824, 44.83078], [-66.93432, 44.82597], [-67.16117, 44.20069], [-61.98255, 37.34815], [-56.27503, 47.39728], [-53.12387, 41.40385], [-46.37635, 57.3249], [-77.52957, 77.23408], [-68.21821, 80.48551], [-49.33696, 84.57952], [-140.97446, 84.39275], [-141.00116, 60.30648], [-140.5227, 60.22077], [-140.45648, 60.30919], [-139.98024, 60.18027], [-139.68991, 60.33693], [-139.05831, 60.35205], [-139.20603, 60.08896], [-139.05365, 59.99655], [-138.71149, 59.90728], [-138.62145, 59.76431], [-137.60623, 59.24465], [-137.4925, 58.89415], [-136.82619, 59.16198], [-136.52365, 59.16752], [-136.47323, 59.46617], [-136.33727, 59.44466], [-136.22381, 59.55526], [-136.31566, 59.59083], [-135.48007, 59.79937], [-135.03069, 59.56208], [-135.00267, 59.28745], [-134.7047, 59.2458], [-134.55699, 59.1297], [-134.48059, 59.13231], [-134.27175, 58.8634], [-133.84645, 58.73543], [-133.38523, 58.42773], [-131.8271, 56.62247], [-130.77769, 56.36185], [-130.33965, 56.10849], [-130.10173, 56.12178], [-130.00093, 56.00325], [-130.00857, 55.91344], [-130.15373, 55.74895], [-129.97513, 55.28029], [-130.08035, 55.21556], [-130.18765, 55.07744], [-130.27203, 54.97174], [-130.44184, 54.85377], [-130.64499, 54.76912], [-130.61931, 54.70835], [-133.92876, 54.62289], [-133.36909, 48.51151], [-125.03842, 48.53282], [-123.50039, 48.21223], [-123.15614, 48.35395], [-123.26565, 48.6959], [-123.0093, 48.76586], [-123.0093, 48.83186], [-123.32163, 49.00419], [-95.15355, 48.9996], [-95.15357, 49.384], [-95.12903, 49.37056], [-95.05825, 49.35311], [-95.01419, 49.35647], [-94.99532, 49.36579], [-94.95681, 49.37035], [-94.85381, 49.32492], [-94.8159, 49.32299], [-94.82487, 49.29483], [-94.77355, 49.11998], [-94.75017, 49.09931], [-94.687, 48.84077], [-94.70087, 48.8339], [-94.70486, 48.82365], [-94.69669, 48.80918], [-94.69335, 48.77883], [-94.58903, 48.71803], [-94.54885, 48.71543], [-94.53826, 48.70216], [-94.44258, 48.69223], [-94.4174, 48.71049], [-94.27153, 48.70232], [-94.25172, 48.68404], [-94.25104, 48.65729], [-94.23215, 48.65202], [-93.85769, 48.63284], [-93.83288, 48.62745], [-93.80676, 48.58232], [-93.80939, 48.52439], [-93.79267, 48.51631], [-93.66382, 48.51845], [-93.47022, 48.54357], [-93.44472, 48.59147], [-93.40693, 48.60948], [-93.39758, 48.60364], [-93.3712, 48.60599], [-93.33946, 48.62787], [-93.25391, 48.64266], [-92.94973, 48.60866], [-92.7287, 48.54005], [-92.6342, 48.54133], [-92.62747, 48.50278], [-92.69927, 48.49573], [-92.71323, 48.46081], [-92.65606, 48.43471], [-92.50712, 48.44921], [-92.45588, 48.40624], [-92.48147, 48.36609], [-92.37185, 48.22259], [-92.27167, 48.25046], [-92.30939, 48.31251], [-92.26662, 48.35651], [-92.202, 48.35252], [-92.14732, 48.36578], [-92.05339, 48.35958], [-91.98929, 48.25409], [-91.86125, 48.21278], [-91.71231, 48.19875], [-91.70451, 48.11805], [-91.55649, 48.10611], [-91.58025, 48.04339], [-91.45829, 48.07454], [-91.43248, 48.04912], [-91.25025, 48.08522], [-91.08016, 48.18096], [-90.87588, 48.2484], [-90.75045, 48.09143], [-90.56444, 48.12184], [-90.56312, 48.09488], [-90.07418, 48.11043], [-89.89974, 47.98109], [-89.77248, 48.02607], [-89.57972, 48.00023], [-89.48837, 48.01412], [-88.37033, 48.30586], [-84.85871, 46.88881], [-84.55635, 46.45974], [-84.47607, 46.45225], [-84.4481, 46.48972], [-84.42101, 46.49853], [-84.34174, 46.50683], [-84.29893, 46.49127], [-84.26351, 46.49508], [-84.2264, 46.53337], [-84.1945, 46.54061], [-84.17723, 46.52753], [-84.12885, 46.53068], [-84.11196, 46.50248], [-84.13451, 46.39218], [-84.11254, 46.32329], [-84.11615, 46.2681], [-84.09756, 46.25512], [-84.1096, 46.23987], [-83.95399, 46.05634], [-83.90453, 46.05922], [-83.83329, 46.12169], [-83.57017, 46.105], [-83.43746, 45.99749], [-83.59589, 45.82131], [-82.48419, 45.30225], [-82.42469, 42.992], [-82.4146, 42.97626], [-82.4253, 42.95423], [-82.45331, 42.93139], [-82.4826, 42.8068], [-82.46613, 42.76615], [-82.51063, 42.66025], [-82.51858, 42.611], [-82.57583, 42.5718], [-82.58873, 42.54984], [-82.64242, 42.55594], [-82.82964, 42.37355], [-83.02253, 42.33045], [-83.07837, 42.30978], [-83.09837, 42.28877], [-83.12724, 42.2376], [-83.14962, 42.04089], [-83.11184, 41.95671], [-82.67862, 41.67615], [-78.93684, 42.82887], [-78.90712, 42.89733], [-78.90905, 42.93022], [-78.93224, 42.95229], [-78.96312, 42.95509], [-78.98126, 42.97], [-79.02074, 42.98444], [-79.02424, 43.01983], [-78.99941, 43.05612], [-79.01055, 43.06659], [-79.07486, 43.07845], [-79.05671, 43.10937], [-79.06881, 43.12029], [-79.0427, 43.13934], [-79.04652, 43.16396], [-79.05384, 43.17418], [-79.05002, 43.20133], [-79.05544, 43.21224], [-79.05512, 43.25375], [-79.06921, 43.26183], [-79.25796, 43.54052], [-76.79706, 43.63099], [-76.43859, 44.09393], [-76.35324, 44.13493], [-76.31222, 44.19894], [-76.244, 44.19643], [-76.1664, 44.23051], [-76.16285, 44.28262], [-76.00018, 44.34896], [-75.95947, 44.34463], [-75.8217, 44.43176], [-75.76813, 44.51537], [-75.41441, 44.76614], [-75.2193, 44.87821], [-75.01363, 44.95608], [-74.99101, 44.98051], [-74.8447, 45.00606], [-74.66689, 45.00646], [-74.32699, 44.99029], [-73.35025, 45.00942], [-71.50067, 45.01357], [-71.48735, 45.07784], [-71.42778, 45.12624], [-71.40364, 45.21382], [-71.44252, 45.2361], [-71.37133, 45.24624], [-71.29371, 45.29996], [-71.22338, 45.25184], [-71.19723, 45.25438], [-71.14568, 45.24128], [-71.08364, 45.30623], [-71.01866, 45.31573], [-71.0107, 45.34819], [-70.95193, 45.33895], [-70.91169, 45.29849], [-70.89864, 45.2398], [-70.84816, 45.22698], [-70.80236, 45.37444], [-70.82638, 45.39828], [-70.78372, 45.43269], [-70.65383, 45.37592], [-70.62518, 45.42286], [-70.72651, 45.49771], [-70.68516, 45.56964], [-70.54019, 45.67291], [-70.38934, 45.73215], [-70.41523, 45.79497], [-70.25976, 45.89675], [-70.24694, 45.95138], [-70.31025, 45.96424], [-70.23855, 46.1453], [-70.29078, 46.18832], [-70.18547, 46.35357], [-70.05812, 46.41768], [-69.99966, 46.69543], [-69.22119, 47.46461], [-69.05148, 47.42012], [-69.05073, 47.30076], [-69.05039, 47.2456], [-68.89222, 47.1807], [-68.70125, 47.24399], [-68.60575, 47.24659], [-68.57914, 47.28431], [-68.38332, 47.28723], [-68.37458, 47.35851], [-68.23244, 47.35712], [-67.94843, 47.1925], [-67.87993, 47.10377], [-67.78578, 47.06473], [-67.78111, 45.9392], [-67.75196, 45.91814], [-67.80961, 45.87531], [-67.75654, 45.82324], [-67.80653, 45.80022], [-67.80705, 45.69528], [-67.6049, 45.60725], [-67.43815, 45.59162], [-67.42144, 45.50584], [-67.50578, 45.48971], [-67.42394, 45.37969], [-67.48201, 45.27351], [-67.34927, 45.122], [-67.29754, 45.14865], [-67.29748, 45.18173], [-67.27039, 45.1934], [-67.22751, 45.16344], [-67.20349, 45.1722]]]] } },
    { type: "Feature", properties: { iso1A2: "CC", iso1A3: "CCK", iso1N3: "166", wikidata: "Q36004", nameEn: "Cocos (Keeling) Islands", country: "AU", groups: ["053", "009", "UN"], driveSide: "left", callingCodes: ["61"] }, geometry: { type: "MultiPolygon", coordinates: [[[[96.61846, -10.82438], [96.02343, -12.68334], [97.93979, -12.33309], [96.61846, -10.82438]]]] } },
    { type: "Feature", properties: { iso1A2: "CD", iso1A3: "COD", iso1N3: "180", wikidata: "Q974", nameEn: "Democratic Republic of the Congo", aliases: ["ZR"], groups: ["017", "202", "002", "UN"], callingCodes: ["243"] }, geometry: { type: "MultiPolygon", coordinates: [[[[27.44012, 5.07349], [27.09575, 5.22305], [26.93064, 5.13535], [26.85579, 5.03887], [26.74572, 5.10685], [26.48595, 5.04984], [26.13371, 5.25594], [25.86073, 5.19455], [25.53271, 5.37431], [25.34558, 5.29101], [25.31256, 5.03668], [24.71816, 4.90509], [24.46719, 5.0915], [23.38847, 4.60013], [22.94817, 4.82392], [22.89094, 4.79321], [22.84691, 4.69887], [22.78526, 4.71423], [22.6928, 4.47285], [22.60915, 4.48821], [22.5431, 4.22041], [22.45504, 4.13039], [22.27682, 4.11347], [22.10721, 4.20723], [21.6405, 4.317], [21.55904, 4.25553], [21.25744, 4.33676], [21.21341, 4.29285], [21.11214, 4.33895], [21.08793, 4.39603], [20.90383, 4.44877], [20.60184, 4.42394], [18.62755, 3.47564], [18.63857, 3.19342], [18.10683, 2.26876], [18.08034, 1.58553], [17.85887, 1.04327], [17.86989, 0.58873], [17.95255, 0.48128], [17.93877, 0.32424], [17.81204, 0.23884], [17.66051, -0.26535], [17.72112, -0.52707], [17.32438, -0.99265], [16.97999, -1.12762], [16.70724, -1.45815], [16.50336, -1.8795], [16.16173, -2.16586], [16.22785, -2.59528], [16.1755, -3.25014], [16.21407, -3.2969], [15.89448, -3.9513], [15.53081, -4.042], [15.48121, -4.22062], [15.41785, -4.28381], [15.32693, -4.27282], [15.25411, -4.31121], [15.1978, -4.32388], [14.83101, -4.80838], [14.67948, -4.92093], [14.5059, -4.84956], [14.41499, -4.8825], [14.37366, -4.56125], [14.47284, -4.42941], [14.3957, -4.36623], [14.40672, -4.28381], [13.9108, -4.50906], [13.81162, -4.41842], [13.71794, -4.44864], [13.70417, -4.72601], [13.50305, -4.77818], [13.41764, -4.89897], [13.11182, -4.5942], [13.09648, -4.63739], [13.11195, -4.67745], [12.8733, -4.74346], [12.70868, -4.95505], [12.63465, -4.94632], [12.60251, -5.01715], [12.46297, -5.09408], [12.49815, -5.14058], [12.51589, -5.1332], [12.53586, -5.14658], [12.53599, -5.1618], [12.52301, -5.17481], [12.52318, -5.74353], [12.26557, -5.74031], [12.20376, -5.76338], [11.95767, -5.94705], [12.42245, -6.07585], [13.04371, -5.87078], [16.55507, -5.85631], [16.96282, -7.21787], [17.5828, -8.13784], [18.33635, -8.00126], [19.33698, -7.99743], [19.5469, -7.00195], [20.30218, -6.98955], [20.31846, -6.91953], [20.61689, -6.90876], [20.56263, -7.28566], [21.79824, -7.29628], [21.84856, -9.59871], [22.19039, -9.94628], [22.32604, -10.76291], [22.17954, -10.85884], [22.25951, -11.24911], [22.54205, -11.05784], [23.16602, -11.10577], [23.45631, -10.946], [23.86868, -11.02856], [24.00027, -10.89356], [24.34528, -11.06816], [24.42612, -11.44975], [25.34069, -11.19707], [25.33058, -11.65767], [26.01777, -11.91488], [26.88687, -12.01868], [27.04351, -11.61312], [27.22541, -11.60323], [27.21025, -11.76157], [27.59932, -12.22123], [28.33199, -12.41375], [29.01918, -13.41353], [29.60531, -13.21685], [29.65078, -13.41844], [29.81551, -13.44683], [29.8139, -12.14898], [29.48404, -12.23604], [29.4992, -12.43843], [29.18592, -12.37921], [28.48357, -11.87532], [28.37241, -11.57848], [28.65032, -10.65133], [28.62795, -9.92942], [28.68532, -9.78], [28.56208, -9.49122], [28.51627, -9.44726], [28.52636, -9.35379], [28.36562, -9.30091], [28.38526, -9.23393], [28.9711, -8.66935], [28.88917, -8.4831], [30.79243, -8.27382], [30.2567, -7.14121], [29.52552, -6.2731], [29.43673, -4.44845], [29.23708, -3.75856], [29.21463, -3.3514], [29.25633, -3.05471], [29.17258, -2.99385], [29.16037, -2.95457], [29.09797, -2.91935], [29.09119, -2.87871], [29.0505, -2.81774], [29.00404, -2.81978], [29.00167, -2.78523], [29.04081, -2.7416], [29.00357, -2.70596], [28.94346, -2.69124], [28.89793, -2.66111], [28.90226, -2.62385], [28.89288, -2.55848], [28.87943, -2.55165], [28.86193, -2.53185], [28.86209, -2.5231], [28.87497, -2.50887], [28.88846, -2.50493], [28.89342, -2.49017], [28.89132, -2.47557], [28.86846, -2.44866], [28.86826, -2.41888], [28.89601, -2.37321], [28.95642, -2.37321], [29.00051, -2.29001], [29.105, -2.27043], [29.17562, -2.12278], [29.11847, -1.90576], [29.24458, -1.69663], [29.24323, -1.66826], [29.36322, -1.50887], [29.45038, -1.5054], [29.53062, -1.40499], [29.59061, -1.39016], [29.58388, -0.89821], [29.63006, -0.8997], [29.62708, -0.71055], [29.67176, -0.55714], [29.67474, -0.47969], [29.65091, -0.46777], [29.72687, -0.08051], [29.7224, 0.07291], [29.77454, 0.16675], [29.81922, 0.16824], [29.87284, 0.39166], [29.97413, 0.52124], [29.95477, 0.64486], [29.98307, 0.84295], [30.1484, 0.89805], [30.22139, 0.99635], [30.24671, 1.14974], [30.48503, 1.21675], [31.30127, 2.11006], [31.28042, 2.17853], [31.20148, 2.2217], [31.1985, 2.29462], [31.12104, 2.27676], [31.07934, 2.30207], [31.06593, 2.35862], [30.96911, 2.41071], [30.91102, 2.33332], [30.83059, 2.42559], [30.74271, 2.43601], [30.75612, 2.5863], [30.8857, 2.83923], [30.8574, 2.9508], [30.77101, 3.04897], [30.84251, 3.26908], [30.93486, 3.40737], [30.94081, 3.50847], [30.85153, 3.48867], [30.85997, 3.5743], [30.80713, 3.60506], [30.78512, 3.67097], [30.56277, 3.62703], [30.57378, 3.74567], [30.55396, 3.84451], [30.47691, 3.83353], [30.27658, 3.95653], [30.22374, 3.93896], [30.1621, 4.10586], [30.06964, 4.13221], [29.79666, 4.37809], [29.82087, 4.56246], [29.49726, 4.7007], [29.43341, 4.50101], [29.22207, 4.34297], [29.03054, 4.48784], [28.8126, 4.48784], [28.6651, 4.42638], [28.20719, 4.35614], [27.79551, 4.59976], [27.76469, 4.79284], [27.65462, 4.89375], [27.56656, 4.89375], [27.44012, 5.07349]]]] } },
    { type: "Feature", properties: { iso1A2: "CF", iso1A3: "CAF", iso1N3: "140", wikidata: "Q929", nameEn: "Central African Republic", groups: ["017", "202", "002", "UN"], callingCodes: ["236"] }, geometry: { type: "MultiPolygon", coordinates: [[[[22.87758, 10.91915], [22.45889, 11.00246], [21.72139, 10.64136], [21.71479, 10.29932], [21.63553, 10.217], [21.52766, 10.2105], [21.34934, 9.95907], [21.26348, 9.97642], [20.82979, 9.44696], [20.36748, 9.11019], [19.06421, 9.00367], [18.86388, 8.87971], [19.11044, 8.68172], [18.79783, 8.25929], [18.67455, 8.22226], [18.62612, 8.14163], [18.64153, 8.08714], [18.6085, 8.05009], [18.02731, 8.01085], [17.93926, 7.95853], [17.67288, 7.98905], [16.8143, 7.53971], [16.6668, 7.67281], [16.658, 7.75353], [16.59415, 7.76444], [16.58315, 7.88657], [16.41583, 7.77971], [16.40703, 7.68809], [15.79942, 7.44149], [15.73118, 7.52006], [15.49743, 7.52179], [15.23397, 7.25135], [15.04717, 6.77085], [14.96311, 6.75693], [14.79966, 6.39043], [14.80122, 6.34866], [14.74206, 6.26356], [14.56149, 6.18928], [14.43073, 6.08867], [14.42917, 6.00508], [14.49455, 5.91683], [14.60974, 5.91838], [14.62375, 5.70466], [14.58951, 5.59777], [14.62531, 5.51411], [14.52724, 5.28319], [14.57083, 5.23979], [14.65489, 5.21343], [14.73383, 4.6135], [15.00825, 4.41458], [15.08609, 4.30282], [15.10644, 4.1362], [15.17482, 4.05131], [15.07686, 4.01805], [15.73522, 3.24348], [15.77725, 3.26835], [16.05449, 3.02306], [16.08252, 2.45708], [16.19357, 2.21537], [16.50126, 2.84739], [16.46701, 2.92512], [16.57598, 3.47999], [16.68283, 3.54257], [17.01746, 3.55136], [17.35649, 3.63045], [17.46876, 3.70515], [17.60966, 3.63705], [17.83421, 3.61068], [17.85842, 3.53378], [18.05656, 3.56893], [18.14902, 3.54476], [18.17323, 3.47665], [18.24148, 3.50302], [18.2723, 3.57992], [18.39558, 3.58212], [18.49245, 3.63924], [18.58711, 3.49423], [18.62755, 3.47564], [20.60184, 4.42394], [20.90383, 4.44877], [21.08793, 4.39603], [21.11214, 4.33895], [21.21341, 4.29285], [21.25744, 4.33676], [21.55904, 4.25553], [21.6405, 4.317], [22.10721, 4.20723], [22.27682, 4.11347], [22.45504, 4.13039], [22.5431, 4.22041], [22.60915, 4.48821], [22.6928, 4.47285], [22.78526, 4.71423], [22.84691, 4.69887], [22.89094, 4.79321], [22.94817, 4.82392], [23.38847, 4.60013], [24.46719, 5.0915], [24.71816, 4.90509], [25.31256, 5.03668], [25.34558, 5.29101], [25.53271, 5.37431], [25.86073, 5.19455], [26.13371, 5.25594], [26.48595, 5.04984], [26.74572, 5.10685], [26.85579, 5.03887], [26.93064, 5.13535], [27.09575, 5.22305], [27.44012, 5.07349], [27.26886, 5.25876], [27.23017, 5.37167], [27.28621, 5.56382], [27.22705, 5.62889], [27.22705, 5.71254], [26.51721, 6.09655], [26.58259, 6.1987], [26.32729, 6.36272], [26.38022, 6.63493], [25.90076, 7.09549], [25.37461, 7.33024], [25.35281, 7.42595], [25.20337, 7.50312], [25.20649, 7.61115], [25.29214, 7.66675], [25.25319, 7.8487], [24.98855, 7.96588], [24.85156, 8.16933], [24.35965, 8.26177], [24.13238, 8.36959], [24.25691, 8.69288], [23.51905, 8.71749], [23.59065, 8.99743], [23.44744, 8.99128], [23.4848, 9.16959], [23.56263, 9.19418], [23.64358, 9.28637], [23.64981, 9.44303], [23.62179, 9.53823], [23.69155, 9.67566], [23.67164, 9.86923], [23.3128, 10.45214], [23.02221, 10.69235], [22.87758, 10.91915]]]] } },
    { type: "Feature", properties: { iso1A2: "CG", iso1A3: "COG", iso1N3: "178", wikidata: "Q971", nameEn: "Republic of the Congo", groups: ["017", "202", "002", "UN"], callingCodes: ["242"] }, geometry: { type: "MultiPolygon", coordinates: [[[[18.62755, 3.47564], [18.58711, 3.49423], [18.49245, 3.63924], [18.39558, 3.58212], [18.2723, 3.57992], [18.24148, 3.50302], [18.17323, 3.47665], [18.14902, 3.54476], [18.05656, 3.56893], [17.85842, 3.53378], [17.83421, 3.61068], [17.60966, 3.63705], [17.46876, 3.70515], [17.35649, 3.63045], [17.01746, 3.55136], [16.68283, 3.54257], [16.57598, 3.47999], [16.46701, 2.92512], [16.50126, 2.84739], [16.19357, 2.21537], [16.15568, 2.18955], [16.08563, 2.19733], [16.05294, 1.9811], [16.14634, 1.70259], [16.02647, 1.65591], [16.02959, 1.76483], [15.48942, 1.98265], [15.34776, 1.91264], [15.22634, 2.03243], [15.00996, 1.98887], [14.61145, 2.17866], [13.29457, 2.16106], [13.13461, 1.57238], [13.25447, 1.32339], [13.15519, 1.23368], [13.89582, 1.4261], [14.25186, 1.39842], [14.48179, 0.9152], [14.26066, 0.57255], [14.10909, 0.58563], [13.88648, 0.26652], [13.90632, -0.2287], [14.06862, -0.20826], [14.2165, -0.38261], [14.41887, -0.44799], [14.52569, -0.57818], [14.41838, -1.89412], [14.25932, -1.97624], [14.23518, -2.15671], [14.16202, -2.23916], [14.23829, -2.33715], [14.10442, -2.49268], [13.85846, -2.46935], [13.92073, -2.35581], [13.75884, -2.09293], [13.47977, -2.43224], [13.02759, -2.33098], [12.82172, -1.91091], [12.61312, -1.8129], [12.44656, -1.92025], [12.47925, -2.32626], [12.04895, -2.41704], [11.96866, -2.33559], [11.74605, -2.39936], [11.57637, -2.33379], [11.64487, -2.61865], [11.5359, -2.85654], [11.64798, -2.81146], [11.80365, -3.00424], [11.70558, -3.0773], [11.70227, -3.17465], [11.96554, -3.30267], [11.8318, -3.5812], [11.92719, -3.62768], [11.87083, -3.71571], [11.68608, -3.68942], [11.57949, -3.52798], [11.48764, -3.51089], [11.22301, -3.69888], [11.12647, -3.94169], [10.75913, -4.39519], [11.50888, -5.33417], [12.00924, -5.02627], [12.16068, -4.90089], [12.20901, -4.75642], [12.25587, -4.79437], [12.32324, -4.78415], [12.40964, -4.60609], [12.64835, -4.55937], [12.76844, -4.38709], [12.87096, -4.40315], [12.91489, -4.47907], [13.09648, -4.63739], [13.11182, -4.5942], [13.41764, -4.89897], [13.50305, -4.77818], [13.70417, -4.72601], [13.71794, -4.44864], [13.81162, -4.41842], [13.9108, -4.50906], [14.40672, -4.28381], [14.3957, -4.36623], [14.47284, -4.42941], [14.37366, -4.56125], [14.41499, -4.8825], [14.5059, -4.84956], [14.67948, -4.92093], [14.83101, -4.80838], [15.1978, -4.32388], [15.25411, -4.31121], [15.32693, -4.27282], [15.41785, -4.28381], [15.48121, -4.22062], [15.53081, -4.042], [15.89448, -3.9513], [16.21407, -3.2969], [16.1755, -3.25014], [16.22785, -2.59528], [16.16173, -2.16586], [16.50336, -1.8795], [16.70724, -1.45815], [16.97999, -1.12762], [17.32438, -0.99265], [17.72112, -0.52707], [17.66051, -0.26535], [17.81204, 0.23884], [17.93877, 0.32424], [17.95255, 0.48128], [17.86989, 0.58873], [17.85887, 1.04327], [18.08034, 1.58553], [18.10683, 2.26876], [18.63857, 3.19342], [18.62755, 3.47564]]]] } },
    { type: "Feature", geometry: { type: "MultiPolygon", coordinates: [[[[8.72809, 47.69282], [8.72617, 47.69651], [8.73671, 47.7169], [8.70543, 47.73121], [8.74251, 47.75168], [8.71778, 47.76571], [8.68985, 47.75686], [8.68022, 47.78599], [8.65292, 47.80066], [8.64425, 47.76398], [8.62408, 47.7626], [8.61657, 47.79998], [8.56415, 47.80633], [8.56814, 47.78001], [8.48868, 47.77215], [8.45771, 47.7493], [8.44807, 47.72426], [8.40569, 47.69855], [8.4211, 47.68407], [8.40473, 47.67499], [8.41346, 47.66676], [8.42264, 47.66667], [8.44711, 47.65379], [8.4667, 47.65747], [8.46605, 47.64103], [8.49656, 47.64709], [8.5322, 47.64687], [8.52801, 47.66059], [8.56141, 47.67088], [8.57683, 47.66158], [8.6052, 47.67258], [8.61113, 47.66332], [8.62884, 47.65098], [8.62049, 47.63757], [8.60412, 47.63735], [8.61471, 47.64514], [8.60701, 47.65271], [8.59545, 47.64298], [8.60348, 47.61204], [8.57586, 47.59537], [8.55756, 47.62394], [8.51686, 47.63476], [8.50747, 47.61897], [8.45578, 47.60121], [8.46637, 47.58389], [8.48949, 47.588], [8.49431, 47.58107], [8.43235, 47.56617], [8.39477, 47.57826], [8.38273, 47.56608], [8.35512, 47.57014], [8.32735, 47.57133], [8.30277, 47.58607], [8.29524, 47.5919], [8.29722, 47.60603], [8.2824, 47.61225], [8.26313, 47.6103], [8.25863, 47.61571], [8.23809, 47.61204], [8.22577, 47.60385], [8.22011, 47.6181], [8.20617, 47.62141], [8.19378, 47.61636], [8.1652, 47.5945], [8.14947, 47.59558], [8.13823, 47.59147], [8.13662, 47.58432], [8.11543, 47.5841], [8.10395, 47.57918], [8.10002, 47.56504], [8.08557, 47.55768], [8.06663, 47.56374], [8.04383, 47.55443], [8.02136, 47.55096], [8.00113, 47.55616], [7.97581, 47.55493], [7.95682, 47.55789], [7.94494, 47.54511], [7.91251, 47.55031], [7.90673, 47.57674], [7.88664, 47.58854], [7.84412, 47.5841], [7.81901, 47.58798], [7.79486, 47.55691], [7.75261, 47.54599], [7.71961, 47.54219], [7.69642, 47.53297], [7.68101, 47.53232], [7.6656, 47.53752], [7.66174, 47.54554], [7.65083, 47.54662], [7.63338, 47.56256], [7.67655, 47.56435], [7.68904, 47.57133], [7.67115, 47.5871], [7.68486, 47.59601], [7.69385, 47.60099], [7.68229, 47.59905], [7.67395, 47.59212], [7.64599, 47.59695], [7.64213, 47.5944], [7.64309, 47.59151], [7.61929, 47.57683], [7.60459, 47.57869], [7.60523, 47.58519], [7.58945, 47.59017], [7.58386, 47.57536], [7.56684, 47.57785], [7.56548, 47.57617], [7.55689, 47.57232], [7.55652, 47.56779], [7.53634, 47.55553], [7.52831, 47.55347], [7.51723, 47.54578], [7.50873, 47.54546], [7.49691, 47.53821], [7.50588, 47.52856], [7.51904, 47.53515], [7.53199, 47.5284], [7.5229, 47.51644], [7.49804, 47.51798], [7.51076, 47.49651], [7.47534, 47.47932], [7.43356, 47.49712], [7.42923, 47.48628], [7.4583, 47.47216], [7.4462, 47.46264], [7.43088, 47.45846], [7.40308, 47.43638], [7.35603, 47.43432], [7.33526, 47.44186], [7.24669, 47.4205], [7.17026, 47.44312], [7.19583, 47.49455], [7.16249, 47.49025], [7.12781, 47.50371], [7.07425, 47.48863], [7.0231, 47.50522], [6.98425, 47.49432], [7.0024, 47.45264], [6.93953, 47.43388], [6.93744, 47.40714], [6.88542, 47.37262], [6.87959, 47.35335], [7.03125, 47.36996], [7.0564, 47.35134], [7.05305, 47.33304], [6.94316, 47.28747], [6.95108, 47.26428], [6.9508, 47.24338], [6.8489, 47.15933], [6.76788, 47.1208], [6.68823, 47.06616], [6.71531, 47.0494], [6.43341, 46.92703], [6.46456, 46.88865], [6.43216, 46.80336], [6.45209, 46.77502], [6.38351, 46.73171], [6.27135, 46.68251], [6.11084, 46.57649], [6.1567, 46.54402], [6.07269, 46.46244], [6.08427, 46.44305], [6.06407, 46.41676], [6.09926, 46.40768], [6.15016, 46.3778], [6.15985, 46.37721], [6.16987, 46.36759], [6.15738, 46.3491], [6.13876, 46.33844], [6.1198, 46.31157], [6.11697, 46.29547], [6.1013, 46.28512], [6.11926, 46.2634], [6.12446, 46.25059], [6.10071, 46.23772], [6.08563, 46.24651], [6.07072, 46.24085], [6.0633, 46.24583], [6.05029, 46.23518], [6.04602, 46.23127], [6.03342, 46.2383], [6.02461, 46.23313], [5.97542, 46.21525], [5.96515, 46.19638], [5.99573, 46.18587], [5.98846, 46.17046], [5.98188, 46.17392], [5.97508, 46.15863], [5.9641, 46.14412], [5.95781, 46.12925], [5.97893, 46.13303], [5.9871, 46.14499], [6.01791, 46.14228], [6.03614, 46.13712], [6.04564, 46.14031], [6.05203, 46.15191], [6.07491, 46.14879], [6.09199, 46.15191], [6.09926, 46.14373], [6.13397, 46.1406], [6.15305, 46.15194], [6.18116, 46.16187], [6.18871, 46.16644], [6.18707, 46.17999], [6.19552, 46.18401], [6.19807, 46.18369], [6.20539, 46.19163], [6.21114, 46.1927], [6.21273, 46.19409], [6.21603, 46.19507], [6.21844, 46.19837], [6.22222, 46.19888], [6.22175, 46.20045], [6.23544, 46.20714], [6.23913, 46.20511], [6.24821, 46.20531], [6.26007, 46.21165], [6.27694, 46.21566], [6.29663, 46.22688], [6.31041, 46.24417], [6.29474, 46.26221], [6.26749, 46.24745], [6.24952, 46.26255], [6.23775, 46.27822], [6.25137, 46.29014], [6.24826, 46.30175], [6.21981, 46.31304], [6.25432, 46.3632], [6.53358, 46.45431], [6.82312, 46.42661], [6.8024, 46.39171], [6.77152, 46.34784], [6.86052, 46.28512], [6.78968, 46.14058], [6.89321, 46.12548], [6.87868, 46.03855], [6.93862, 46.06502], [7.00946, 45.9944], [7.04151, 45.92435], [7.10685, 45.85653], [7.56343, 45.97421], [7.85949, 45.91485], [7.9049, 45.99945], [7.98881, 45.99867], [8.02906, 46.10331], [8.11383, 46.11577], [8.16866, 46.17817], [8.08814, 46.26692], [8.31162, 46.38044], [8.30648, 46.41587], [8.42464, 46.46367], [8.46317, 46.43712], [8.45032, 46.26869], [8.62242, 46.12112], [8.75697, 46.10395], [8.80778, 46.10085], [8.85617, 46.0748], [8.79414, 46.00913], [8.78585, 45.98973], [8.79362, 45.99207], [8.8319, 45.9879], [8.85121, 45.97239], [8.86688, 45.96135], [8.88904, 45.95465], [8.93649, 45.86775], [8.94372, 45.86587], [8.93504, 45.86245], [8.91129, 45.8388], [8.94737, 45.84285], [8.9621, 45.83707], [8.99663, 45.83466], [9.00324, 45.82055], [9.0298, 45.82127], [9.03279, 45.82865], [9.03793, 45.83548], [9.03505, 45.83976], [9.04059, 45.8464], [9.04546, 45.84968], [9.06642, 45.8761], [9.09065, 45.89906], [8.99257, 45.9698], [9.01618, 46.04928], [9.24503, 46.23616], [9.29226, 46.32717], [9.25502, 46.43743], [9.28136, 46.49685], [9.36128, 46.5081], [9.40487, 46.46621], [9.45936, 46.50873], [9.46117, 46.37481], [9.57015, 46.2958], [9.71273, 46.29266], [9.73086, 46.35071], [9.95249, 46.38045], [10.07055, 46.21668], [10.14439, 46.22992], [10.17862, 46.25626], [10.10506, 46.3372], [10.165, 46.41051], [10.03715, 46.44479], [10.10307, 46.61003], [10.23674, 46.63484], [10.25309, 46.57432], [10.46136, 46.53164], [10.49375, 46.62049], [10.44686, 46.64162], [10.40475, 46.63671], [10.38659, 46.67847], [10.47197, 46.85698], [10.48376, 46.93891], [10.36933, 47.00212], [10.30031, 46.92093], [10.24128, 46.93147], [10.22675, 46.86942], [10.10715, 46.84296], [9.98058, 46.91434], [9.88266, 46.93343], [9.87935, 47.01337], [9.60717, 47.06091], [9.55721, 47.04762], [9.54041, 47.06495], [9.47548, 47.05257], [9.47139, 47.06402], [9.51362, 47.08505], [9.52089, 47.10019], [9.51044, 47.13727], [9.48774, 47.17402], [9.4891, 47.19346], [9.50318, 47.22153], [9.52406, 47.24959], [9.53116, 47.27029], [9.54773, 47.2809], [9.55857, 47.29919], [9.58513, 47.31334], [9.59978, 47.34671], [9.62476, 47.36639], [9.65427, 47.36824], [9.66243, 47.37136], [9.6711, 47.37824], [9.67445, 47.38429], [9.67334, 47.39191], [9.6629, 47.39591], [9.65136, 47.40504], [9.65043, 47.41937], [9.6446, 47.43233], [9.64483, 47.43842], [9.65863, 47.44847], [9.65728, 47.45383], [9.6423, 47.45599], [9.62475, 47.45685], [9.62158, 47.45858], [9.60841, 47.47178], [9.60484, 47.46358], [9.60205, 47.46165], [9.59482, 47.46305], [9.58208, 47.48344], [9.56312, 47.49495], [9.55125, 47.53629], [9.25619, 47.65939], [9.18203, 47.65598], [9.17593, 47.65399], [9.1755, 47.65584], [9.1705, 47.65513], [9.15181, 47.66904], [9.13845, 47.66389], [9.09891, 47.67801], [9.02093, 47.6868], [8.94093, 47.65596], [8.89946, 47.64769], [8.87625, 47.65441], [8.87383, 47.67045], [8.85065, 47.68209], [8.86989, 47.70504], [8.82002, 47.71458], [8.80663, 47.73821], [8.77309, 47.72059], [8.76965, 47.7075], [8.79966, 47.70222], [8.79511, 47.67462], [8.75856, 47.68969], [8.72809, 47.69282]], [[8.95861, 45.96485], [8.96668, 45.98436], [8.97741, 45.98317], [8.97604, 45.96151], [8.95861, 45.96485]], [[8.70847, 47.68904], [8.68985, 47.69552], [8.66837, 47.68437], [8.65769, 47.68928], [8.67508, 47.6979], [8.66416, 47.71367], [8.70237, 47.71453], [8.71773, 47.69088], [8.70847, 47.68904]]]] }, properties: { iso1A2: "CH", iso1A3: "CHE", iso1N3: "756", wikidata: "Q39", nameEn: "Switzerland", groups: ["155", "150", "UN"], callingCodes: ["41"] } },
    { type: "Feature", properties: { iso1A2: "CI", iso1A3: "CIV", iso1N3: "384", wikidata: "Q1008", nameEn: "C\xF4te d'Ivoire", groups: ["011", "202", "002", "UN"], callingCodes: ["225"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-7.52774, 3.7105], [-3.34019, 4.17519], [-3.10675, 5.08515], [-3.11073, 5.12675], [-3.063, 5.13665], [-2.96554, 5.10397], [-2.95261, 5.12477], [-2.75502, 5.10657], [-2.73074, 5.1364], [-2.77625, 5.34621], [-2.72737, 5.34789], [-2.76614, 5.60963], [-2.85378, 5.65156], [-2.93132, 5.62137], [-2.96671, 5.6415], [-2.95323, 5.71865], [-3.01896, 5.71697], [-3.25999, 6.62521], [-3.21954, 6.74407], [-3.23327, 6.81744], [-2.95438, 7.23737], [-2.97822, 7.27165], [-2.92339, 7.60847], [-2.79467, 7.86002], [-2.78395, 7.94974], [-2.74819, 7.92613], [-2.67787, 8.02055], [-2.61232, 8.02645], [-2.62901, 8.11495], [-2.49037, 8.20872], [-2.58243, 8.7789], [-2.66357, 9.01771], [-2.77799, 9.04949], [-2.69814, 9.22717], [-2.68802, 9.49343], [-2.76494, 9.40778], [-2.93012, 9.57403], [-3.00765, 9.74019], [-3.16609, 9.85147], [-3.19306, 9.93781], [-3.27228, 9.84981], [-3.31779, 9.91125], [-3.69703, 9.94279], [-4.25999, 9.76012], [-4.31392, 9.60062], [-4.6426, 9.70696], [-4.96621, 9.89132], [-4.96453, 9.99923], [-5.12465, 10.29788], [-5.39602, 10.2929], [-5.51058, 10.43177], [-5.65135, 10.46767], [-5.78124, 10.43952], [-5.99478, 10.19694], [-6.18851, 10.24244], [-6.1731, 10.46983], [-6.24795, 10.74248], [-6.325, 10.68624], [-6.40646, 10.69922], [-6.42847, 10.5694], [-6.52974, 10.59104], [-6.63541, 10.66893], [-6.68164, 10.35074], [-6.93921, 10.35291], [-7.01186, 10.25111], [-6.97444, 10.21644], [-7.00966, 10.15794], [-7.0603, 10.14711], [-7.13331, 10.24877], [-7.3707, 10.24677], [-7.44555, 10.44602], [-7.52261, 10.4655], [-7.54462, 10.40921], [-7.63048, 10.46334], [-7.92107, 10.15577], [-7.97971, 10.17117], [-8.01225, 10.1021], [-8.11921, 10.04577], [-8.15652, 9.94288], [-8.09434, 9.86936], [-8.14657, 9.55062], [-8.03463, 9.39604], [-7.85056, 9.41812], [-7.90777, 9.20456], [-7.73862, 9.08422], [-7.92518, 8.99332], [-7.95503, 8.81146], [-7.69882, 8.66148], [-7.65653, 8.36873], [-7.92518, 8.50652], [-8.22991, 8.48438], [-8.2411, 8.24196], [-8.062, 8.16071], [-7.98675, 8.20134], [-7.99919, 8.11023], [-7.94695, 8.00925], [-8.06449, 8.04989], [-8.13414, 7.87991], [-8.09931, 7.78626], [-8.21374, 7.54466], [-8.4003, 7.6285], [-8.47114, 7.55676], [-8.41935, 7.51203], [-8.37458, 7.25794], [-8.29249, 7.1691], [-8.31736, 6.82837], [-8.59456, 6.50612], [-8.48652, 6.43797], [-8.45666, 6.49977], [-8.38453, 6.35887], [-8.3298, 6.36381], [-8.17557, 6.28222], [-8.00642, 6.31684], [-7.90692, 6.27728], [-7.83478, 6.20309], [-7.8497, 6.08932], [-7.79747, 6.07696], [-7.78254, 5.99037], [-7.70294, 5.90625], [-7.67309, 5.94337], [-7.48155, 5.80974], [-7.46165, 5.84934], [-7.43677, 5.84687], [-7.43926, 5.74787], [-7.37209, 5.61173], [-7.43428, 5.42355], [-7.36463, 5.32944], [-7.46165, 5.26256], [-7.48901, 5.14118], [-7.55369, 5.08667], [-7.53876, 4.94294], [-7.59349, 4.8909], [-7.53259, 4.35145], [-7.52774, 3.7105]]]] } },
    { type: "Feature", properties: { iso1A2: "CK", iso1A3: "COK", iso1N3: "184", wikidata: "Q26988", nameEn: "Cook Islands", country: "NZ", groups: ["061", "009", "UN"], driveSide: "left", callingCodes: ["682"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-168.15106, -10.26955], [-156.45576, -31.75456], [-156.48634, -15.52824], [-156.50903, -7.4975], [-168.15106, -10.26955]]]] } },
    { type: "Feature", properties: { iso1A2: "CL", iso1A3: "CHL", iso1N3: "152", wikidata: "Q298", nameEn: "Chile", groups: ["005", "419", "019", "UN"], callingCodes: ["56"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-68.60702, -52.65781], [-68.41683, -52.33516], [-69.97824, -52.00845], [-71.99889, -51.98018], [-72.33873, -51.59954], [-72.31343, -50.58411], [-73.15765, -50.78337], [-73.55259, -49.92488], [-73.45156, -49.79461], [-73.09655, -49.14342], [-72.56894, -48.81116], [-72.54042, -48.52392], [-72.27662, -48.28727], [-72.50478, -47.80586], [-71.94152, -47.13595], [-71.68577, -46.55385], [-71.75614, -45.61611], [-71.35687, -45.22075], [-72.06985, -44.81756], [-71.26418, -44.75684], [-71.16436, -44.46244], [-71.81318, -44.38097], [-71.64206, -43.64774], [-72.14828, -42.85321], [-72.15541, -42.15941], [-71.74901, -42.11711], [-71.92726, -40.72714], [-71.37826, -38.91474], [-70.89532, -38.6923], [-71.24279, -37.20264], [-70.95047, -36.4321], [-70.38008, -36.02375], [-70.49416, -35.24145], [-69.87386, -34.13344], [-69.88099, -33.34489], [-70.55832, -31.51559], [-70.14479, -30.36595], [-69.8596, -30.26131], [-69.99507, -29.28351], [-69.80969, -29.07185], [-69.66709, -28.44055], [-69.22504, -27.95042], [-68.77586, -27.16029], [-68.43363, -27.08414], [-68.27677, -26.90626], [-68.59048, -26.49861], [-68.56909, -26.28146], [-68.38372, -26.15353], [-68.57622, -25.32505], [-68.38372, -25.08636], [-68.56909, -24.69831], [-68.24825, -24.42596], [-67.33563, -24.04237], [-66.99632, -22.99839], [-67.18382, -22.81525], [-67.54284, -22.89771], [-67.85114, -22.87076], [-68.18816, -21.28614], [-68.40403, -20.94562], [-68.53957, -20.91542], [-68.55383, -20.7355], [-68.44023, -20.62701], [-68.7276, -20.46178], [-68.74273, -20.08817], [-68.57132, -20.03134], [-68.54611, -19.84651], [-68.66761, -19.72118], [-68.41218, -19.40499], [-68.61989, -19.27584], [-68.80602, -19.08355], [-68.87082, -19.06003], [-68.94987, -18.93302], [-69.07432, -18.28259], [-69.14807, -18.16893], [-69.07496, -18.03715], [-69.28671, -17.94844], [-69.34126, -17.72753], [-69.46623, -17.60518], [-69.46897, -17.4988], [-69.66483, -17.65083], [-69.79087, -17.65563], [-69.82868, -17.72048], [-69.75305, -17.94605], [-69.81607, -18.12582], [-69.96732, -18.25992], [-70.16394, -18.31737], [-70.31267, -18.31258], [-70.378, -18.3495], [-70.59118, -18.35072], [-113.52687, -26.52828], [-68.11646, -58.14883], [-66.07313, -55.19618], [-67.11046, -54.94199], [-67.46182, -54.92205], [-68.01394, -54.8753], [-68.60733, -54.9125], [-68.60702, -52.65781]]]] } },
    { type: "Feature", properties: { iso1A2: "CM", iso1A3: "CMR", iso1N3: "120", wikidata: "Q1009", nameEn: "Cameroon", groups: ["017", "202", "002", "UN"], callingCodes: ["237"] }, geometry: { type: "MultiPolygon", coordinates: [[[[14.83314, 12.62963], [14.55058, 12.78256], [14.56101, 12.91036], [14.46881, 13.08259], [14.08251, 13.0797], [14.20204, 12.53405], [14.17523, 12.41916], [14.22215, 12.36533], [14.4843, 12.35223], [14.6474, 12.17466], [14.61612, 11.7798], [14.55207, 11.72001], [14.64591, 11.66166], [14.6124, 11.51283], [14.17821, 11.23831], [13.97489, 11.30258], [13.78945, 11.00154], [13.7403, 11.00593], [13.70753, 10.94451], [13.73434, 10.9255], [13.54964, 10.61236], [13.5705, 10.53183], [13.43644, 10.13326], [13.34111, 10.12299], [13.25025, 10.03647], [13.25323, 10.00127], [13.286, 9.9822], [13.27409, 9.93232], [13.24132, 9.91031], [13.25025, 9.86042], [13.29941, 9.8296], [13.25472, 9.76795], [13.22642, 9.57266], [13.02385, 9.49334], [12.85628, 9.36698], [12.91958, 9.33905], [12.90022, 9.11411], [12.81085, 8.91992], [12.79, 8.75361], [12.71701, 8.7595], [12.68722, 8.65938], [12.44146, 8.6152], [12.4489, 8.52536], [12.26123, 8.43696], [12.24782, 8.17904], [12.19271, 8.10826], [12.20909, 7.97553], [11.99908, 7.67302], [12.01844, 7.52981], [11.93205, 7.47812], [11.84864, 7.26098], [11.87396, 7.09398], [11.63117, 6.9905], [11.55818, 6.86186], [11.57755, 6.74059], [11.51499, 6.60892], [11.42264, 6.5882], [11.42041, 6.53789], [11.09495, 6.51717], [11.09644, 6.68437], [10.94302, 6.69325], [10.8179, 6.83377], [10.83727, 6.9358], [10.60789, 7.06885], [10.59746, 7.14719], [10.57214, 7.16345], [10.53639, 6.93432], [10.21466, 6.88996], [10.15135, 7.03781], [9.86314, 6.77756], [9.77824, 6.79088], [9.70674, 6.51717], [9.51757, 6.43874], [8.84209, 5.82562], [8.88156, 5.78857], [8.83687, 5.68483], [8.92029, 5.58403], [8.78027, 5.1243], [8.60302, 4.87353], [8.34397, 4.30689], [9.22018, 3.72052], [9.81162, 2.33797], [9.82123, 2.35097], [9.83754, 2.32428], [9.83238, 2.29079], [9.84716, 2.24676], [9.89012, 2.20457], [9.90749, 2.20049], [9.991, 2.16561], [11.3561, 2.17217], [11.37116, 2.29975], [13.28534, 2.25716], [13.29457, 2.16106], [14.61145, 2.17866], [15.00996, 1.98887], [15.22634, 2.03243], [15.34776, 1.91264], [15.48942, 1.98265], [16.02959, 1.76483], [16.02647, 1.65591], [16.14634, 1.70259], [16.05294, 1.9811], [16.08563, 2.19733], [16.15568, 2.18955], [16.19357, 2.21537], [16.08252, 2.45708], [16.05449, 3.02306], [15.77725, 3.26835], [15.73522, 3.24348], [15.07686, 4.01805], [15.17482, 4.05131], [15.10644, 4.1362], [15.08609, 4.30282], [15.00825, 4.41458], [14.73383, 4.6135], [14.65489, 5.21343], [14.57083, 5.23979], [14.52724, 5.28319], [14.62531, 5.51411], [14.58951, 5.59777], [14.62375, 5.70466], [14.60974, 5.91838], [14.49455, 5.91683], [14.42917, 6.00508], [14.43073, 6.08867], [14.56149, 6.18928], [14.74206, 6.26356], [14.80122, 6.34866], [14.79966, 6.39043], [14.96311, 6.75693], [15.04717, 6.77085], [15.23397, 7.25135], [15.49743, 7.52179], [15.56964, 7.58936], [15.59272, 7.7696], [15.50743, 7.79302], [15.20426, 8.50892], [15.09484, 8.65982], [14.83566, 8.80557], [14.35707, 9.19611], [14.37094, 9.2954], [13.97544, 9.6365], [14.01793, 9.73169], [14.1317, 9.82413], [14.20411, 10.00055], [14.4673, 10.00264], [14.80082, 9.93818], [14.95722, 9.97926], [15.05999, 9.94845], [15.14043, 9.99246], [15.24618, 9.99246], [15.41408, 9.92876], [15.68761, 9.99344], [15.50535, 10.1098], [15.30874, 10.31063], [15.23724, 10.47764], [15.14936, 10.53915], [15.15532, 10.62846], [15.06737, 10.80921], [15.09127, 10.87431], [15.04957, 11.02347], [15.10021, 11.04101], [15.0585, 11.40481], [15.13149, 11.5537], [15.06595, 11.71126], [15.11579, 11.79313], [15.04808, 11.8731], [15.05786, 12.0608], [15.0349, 12.10698], [15.00146, 12.1223], [14.96952, 12.0925], [14.89019, 12.16593], [14.90827, 12.3269], [14.83314, 12.62963]]]] } },
    { type: "Feature", properties: { iso1A2: "CN", iso1A3: "CHN", iso1N3: "156", wikidata: "Q148", nameEn: "People's Republic of China" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "CO", iso1A3: "COL", iso1N3: "170", wikidata: "Q739", nameEn: "Colombia", groups: ["005", "419", "019", "UN"], callingCodes: ["57"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-71.19849, 12.65801], [-81.58685, 18.0025], [-82.06974, 14.49418], [-82.56142, 11.91792], [-78.79327, 9.93766], [-77.58292, 9.22278], [-77.32389, 8.81247], [-77.45064, 8.49991], [-77.17257, 7.97422], [-77.57185, 7.51147], [-77.72514, 7.72348], [-77.72157, 7.47612], [-77.81426, 7.48319], [-77.89178, 7.22681], [-78.06168, 7.07793], [-82.12561, 4.00341], [-78.87137, 1.47457], [-78.42749, 1.15389], [-77.85677, 0.80197], [-77.7148, 0.85003], [-77.68613, 0.83029], [-77.66416, 0.81604], [-77.67815, 0.73863], [-77.49984, 0.64476], [-77.52001, 0.40782], [-76.89177, 0.24736], [-76.4094, 0.24015], [-76.41215, 0.38228], [-76.23441, 0.42294], [-75.82927, 0.09578], [-75.25764, -0.11943], [-75.18513, -0.0308], [-74.42701, -0.50218], [-74.26675, -0.97229], [-73.65312, -1.26222], [-72.92587, -2.44514], [-71.75223, -2.15058], [-70.94377, -2.23142], [-70.04609, -2.73906], [-70.71396, -3.7921], [-70.52393, -3.87553], [-70.3374, -3.79505], [-69.94708, -4.2431], [-69.43395, -1.42219], [-69.4215, -1.01853], [-69.59796, -0.75136], [-69.603, -0.51947], [-70.03658, -0.19681], [-70.04162, 0.55437], [-69.47696, 0.71065], [-69.20976, 0.57958], [-69.14422, 0.84172], [-69.26017, 1.06856], [-69.82987, 1.07864], [-69.83491, 1.69353], [-69.53746, 1.76408], [-69.38621, 1.70865], [-68.18128, 1.72881], [-68.26699, 1.83463], [-68.18632, 2.00091], [-67.9292, 1.82455], [-67.40488, 2.22258], [-67.299, 1.87494], [-67.15784, 1.80439], [-67.08222, 1.17441], [-66.85795, 1.22998], [-67.21967, 2.35778], [-67.65696, 2.81691], [-67.85862, 2.79173], [-67.85862, 2.86727], [-67.30945, 3.38393], [-67.50067, 3.75812], [-67.62671, 3.74303], [-67.85358, 4.53249], [-67.83341, 5.31104], [-67.59141, 5.5369], [-67.63914, 5.64963], [-67.58558, 5.84537], [-67.43513, 5.98835], [-67.4625, 6.20625], [-67.60654, 6.2891], [-69.41843, 6.1072], [-70.10716, 6.96516], [-70.7596, 7.09799], [-71.03941, 6.98163], [-71.37234, 7.01588], [-71.42212, 7.03854], [-71.44118, 7.02116], [-71.82441, 7.04314], [-72.04895, 7.03837], [-72.19437, 7.37034], [-72.43132, 7.40034], [-72.47415, 7.48928], [-72.45321, 7.57232], [-72.47827, 7.65604], [-72.46763, 7.79518], [-72.44454, 7.86031], [-72.46183, 7.90682], [-72.45806, 7.91141], [-72.47042, 7.92306], [-72.48183, 7.92909], [-72.48801, 7.94329], [-72.47213, 7.96106], [-72.39137, 8.03534], [-72.35163, 8.01163], [-72.36987, 8.19976], [-72.4042, 8.36513], [-72.65474, 8.61428], [-72.77415, 9.10165], [-72.94052, 9.10663], [-73.02119, 9.27584], [-73.36905, 9.16636], [-72.98085, 9.85253], [-72.88002, 10.44309], [-72.4767, 11.1117], [-72.24983, 11.14138], [-71.9675, 11.65536], [-71.3275, 11.85], [-70.92579, 11.96275], [-71.19849, 12.65801]]]] } },
    { type: "Feature", properties: { iso1A2: "CP", iso1A3: "CPT", wikidata: "Q161258", nameEn: "Clipperton Island", country: "FR", groups: ["EU", "013", "003", "019", "UN"], isoStatus: "excRes" }, geometry: { type: "MultiPolygon", coordinates: [[[[-110.36279, 9.79626], [-108.755, 9.84085], [-109.04145, 11.13245], [-110.36279, 9.79626]]]] } },
    { type: "Feature", properties: { iso1A2: "CR", iso1A3: "CRI", iso1N3: "188", wikidata: "Q800", nameEn: "Costa Rica", groups: ["013", "003", "419", "019", "UN"], callingCodes: ["506"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-83.68276, 11.01562], [-83.66597, 10.79916], [-83.90838, 10.71161], [-84.68197, 11.07568], [-84.92439, 10.9497], [-85.60529, 11.22607], [-85.71223, 11.06868], [-86.14524, 11.09059], [-87.41779, 5.02401], [-82.94503, 7.93865], [-82.89978, 8.04083], [-82.89137, 8.05755], [-82.88641, 8.10219], [-82.9388, 8.26634], [-83.05209, 8.33394], [-82.93056, 8.43465], [-82.8679, 8.44042], [-82.8382, 8.48117], [-82.83322, 8.52464], [-82.83975, 8.54755], [-82.82739, 8.60153], [-82.8794, 8.6981], [-82.92068, 8.74832], [-82.91377, 8.774], [-82.88253, 8.83331], [-82.72126, 8.97125], [-82.93516, 9.07687], [-82.93516, 9.46741], [-82.84871, 9.4973], [-82.87919, 9.62645], [-82.77206, 9.59573], [-82.66667, 9.49746], [-82.61345, 9.49881], [-82.56507, 9.57279], [-82.51044, 9.65379], [-83.54024, 10.96805], [-83.68276, 11.01562]]]] } },
    { type: "Feature", properties: { iso1A2: "CU", iso1A3: "CUB", iso1N3: "192", wikidata: "Q241", nameEn: "Cuba", groups: ["029", "003", "419", "019", "UN"], callingCodes: ["53"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-73.62304, 20.6935], [-82.02215, 24.23074], [-85.77883, 21.92705], [-74.81171, 18.82201], [-73.62304, 20.6935]]]] } },
    { type: "Feature", properties: { iso1A2: "CV", iso1A3: "CPV", iso1N3: "132", wikidata: "Q1011", nameEn: "Cape Verde", groups: ["Q105472", "011", "202", "002", "UN"], callingCodes: ["238"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-28.81604, 14.57305], [-20.39702, 14.12816], [-23.37101, 19.134], [-28.81604, 14.57305]]]] } },
    { type: "Feature", properties: { iso1A2: "CW", iso1A3: "CUW", iso1N3: "531", wikidata: "Q25279", nameEn: "Cura\xE7ao", aliases: ["NL-CW"], country: "NL", groups: ["Q1451600", "029", "003", "419", "019", "UN"], callingCodes: ["599"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-68.90012, 12.62309], [-69.59009, 12.46019], [-68.99639, 11.79035], [-68.33524, 11.78151], [-68.90012, 12.62309]]]] } },
    { type: "Feature", properties: { iso1A2: "CX", iso1A3: "CXR", iso1N3: "162", wikidata: "Q31063", nameEn: "Christmas Island", country: "AU", groups: ["053", "009", "UN"], driveSide: "left", callingCodes: ["61"] }, geometry: { type: "MultiPolygon", coordinates: [[[[105.66835, -9.31927], [104.67494, -11.2566], [106.66176, -11.14349], [105.66835, -9.31927]]]] } },
    { type: "Feature", properties: { iso1A2: "CY", iso1A3: "CYP", iso1N3: "196", wikidata: "Q229", nameEn: "Republic of Cyprus", groups: ["Q644636", "EU", "145", "142", "UN"], driveSide: "left", callingCodes: ["357"] }, geometry: { type: "MultiPolygon", coordinates: [[[[32.46489, 35.48584], [30.15137, 34.08517], [32.74412, 34.43926], [32.75515, 34.64985], [32.76136, 34.68318], [32.79433, 34.67883], [32.82717, 34.70622], [32.86014, 34.70585], [32.86167, 34.68734], [32.9068, 34.66102], [32.91398, 34.67343], [32.93043, 34.67091], [32.92807, 34.66736], [32.93449, 34.66241], [32.93693, 34.67027], [32.94379, 34.67111], [32.94683, 34.67907], [32.95539, 34.68471], [32.99135, 34.68061], [32.98668, 34.67268], [32.99014, 34.65518], [32.97736, 34.65277], [32.97079, 34.66112], [32.95325, 34.66462], [32.94796, 34.6587], [32.94976, 34.65204], [32.95471, 34.64528], [32.95323, 34.64075], [32.95891, 34.62919], [32.96718, 34.63446], [32.96968, 34.64046], [33.0138, 34.64424], [33.26744, 34.49942], [33.83531, 34.73974], [33.70575, 34.97947], [33.70639, 34.99303], [33.71514, 35.00294], [33.69731, 35.01754], [33.69938, 35.03123], [33.67678, 35.03866], [33.63765, 35.03869], [33.61215, 35.0527], [33.59658, 35.03635], [33.567, 35.04803], [33.57478, 35.06049], [33.53975, 35.08151], [33.48915, 35.06594], [33.47666, 35.00701], [33.45256, 35.00288], [33.45178, 35.02078], [33.47825, 35.04103], [33.48136, 35.0636], [33.46813, 35.10564], [33.41675, 35.16325], [33.4076, 35.20062], [33.38575, 35.2018], [33.37248, 35.18698], [33.3717, 35.1788], [33.36569, 35.17479], [33.35612, 35.17402], [33.35596, 35.17942], [33.34964, 35.17803], [33.35056, 35.18328], [33.31955, 35.18096], [33.3072, 35.16816], [33.27068, 35.16815], [33.15138, 35.19504], [33.11105, 35.15639], [33.08249, 35.17319], [33.01192, 35.15639], [32.94471, 35.09422], [32.86406, 35.1043], [32.85733, 35.07742], [32.70779, 35.14127], [32.70947, 35.18328], [32.64864, 35.19967], [32.60361, 35.16647], [32.46489, 35.48584]]], [[[33.74144, 35.01053], [33.7492, 35.01319], [33.74983, 35.02274], [33.74265, 35.02329], [33.73781, 35.02181], [33.7343, 35.01178], [33.74144, 35.01053]]], [[[33.77312, 34.9976], [33.75994, 35.00113], [33.75682, 34.99916], [33.76605, 34.99543], [33.76738, 34.99188], [33.7778, 34.98981], [33.77843, 34.988], [33.78149, 34.98854], [33.78318, 34.98699], [33.78571, 34.98951], [33.78917, 34.98854], [33.79191, 34.98914], [33.78516, 34.99582], [33.77553, 34.99518], [33.77312, 34.9976]]]] } },
    { type: "Feature", properties: { iso1A2: "CZ", iso1A3: "CZE", iso1N3: "203", wikidata: "Q213", nameEn: "Czechia", groups: ["EU", "151", "150", "UN"], callingCodes: ["420"] }, geometry: { type: "MultiPolygon", coordinates: [[[[14.82803, 50.86966], [14.79139, 50.81438], [14.70661, 50.84096], [14.61993, 50.86049], [14.63434, 50.8883], [14.65259, 50.90513], [14.64802, 50.93241], [14.58024, 50.91443], [14.56374, 50.922], [14.59702, 50.96148], [14.59908, 50.98685], [14.58215, 50.99306], [14.56432, 51.01008], [14.53438, 51.00374], [14.53321, 51.01679], [14.49873, 51.02242], [14.50809, 51.0427], [14.49991, 51.04692], [14.49154, 51.04382], [14.49202, 51.02286], [14.45827, 51.03712], [14.41335, 51.02086], [14.30098, 51.05515], [14.25665, 50.98935], [14.28776, 50.97718], [14.32353, 50.98556], [14.32793, 50.97379], [14.30251, 50.96606], [14.31422, 50.95243], [14.39848, 50.93866], [14.38691, 50.89907], [14.30098, 50.88448], [14.27123, 50.89386], [14.24314, 50.88761], [14.22331, 50.86049], [14.02982, 50.80662], [13.98864, 50.8177], [13.89113, 50.78533], [13.89444, 50.74142], [13.82942, 50.7251], [13.76316, 50.73487], [13.70204, 50.71771], [13.65977, 50.73096], [13.52474, 50.70394], [13.53748, 50.67654], [13.5226, 50.64721], [13.49742, 50.63133], [13.46413, 50.60102], [13.42189, 50.61243], [13.37485, 50.64931], [13.37805, 50.627], [13.32264, 50.60317], [13.32594, 50.58009], [13.29454, 50.57904], [13.25158, 50.59268], [13.19043, 50.50237], [13.13424, 50.51709], [13.08301, 50.50132], [13.0312, 50.50944], [13.02038, 50.4734], [13.02147, 50.44763], [12.98433, 50.42016], [12.94058, 50.40944], [12.82465, 50.45738], [12.73476, 50.43237], [12.73044, 50.42268], [12.70731, 50.39948], [12.67261, 50.41949], [12.51356, 50.39694], [12.48747, 50.37278], [12.49214, 50.35228], [12.48256, 50.34784], [12.46643, 50.35527], [12.43722, 50.33774], [12.43371, 50.32506], [12.39924, 50.32302], [12.40158, 50.29521], [12.36594, 50.28289], [12.35425, 50.23993], [12.33263, 50.24367], [12.32445, 50.20442], [12.33847, 50.19432], [12.32596, 50.17146], [12.29232, 50.17524], [12.28063, 50.19544], [12.28755, 50.22429], [12.23943, 50.24594], [12.24791, 50.25525], [12.26953, 50.25189], [12.25119, 50.27079], [12.20823, 50.2729], [12.18013, 50.32146], [12.10907, 50.32041], [12.13716, 50.27396], [12.09287, 50.25032], [12.19335, 50.19997], [12.21484, 50.16399], [12.1917, 50.13434], [12.2073, 50.10315], [12.23709, 50.10213], [12.27433, 50.0771], [12.26111, 50.06331], [12.30798, 50.05719], [12.49908, 49.97305], [12.47264, 49.94222], [12.55197, 49.92094], [12.48256, 49.83575], [12.46603, 49.78882], [12.40489, 49.76321], [12.4462, 49.70233], [12.52553, 49.68415], [12.53544, 49.61888], [12.56188, 49.6146], [12.60155, 49.52887], [12.64782, 49.52565], [12.64121, 49.47628], [12.669, 49.42935], [12.71227, 49.42363], [12.75854, 49.3989], [12.78168, 49.34618], [12.88414, 49.33541], [12.88249, 49.35479], [12.94859, 49.34079], [13.03618, 49.30417], [13.02957, 49.27399], [13.05883, 49.26259], [13.17665, 49.16713], [13.17019, 49.14339], [13.20405, 49.12303], [13.23689, 49.11412], [13.28242, 49.1228], [13.39479, 49.04812], [13.40802, 48.98851], [13.50221, 48.93752], [13.50552, 48.97441], [13.58319, 48.96899], [13.61624, 48.9462], [13.67739, 48.87886], [13.73854, 48.88538], [13.76994, 48.83537], [13.78977, 48.83319], [13.8096, 48.77877], [13.84023, 48.76988], [14.06151, 48.66873], [14.01482, 48.63788], [14.09104, 48.5943], [14.20691, 48.5898], [14.33909, 48.55852], [14.43076, 48.58855], [14.4587, 48.64695], [14.56139, 48.60429], [14.60808, 48.62881], [14.66762, 48.58215], [14.71794, 48.59794], [14.72756, 48.69502], [14.80584, 48.73489], [14.80821, 48.77711], [14.81545, 48.7874], [14.94773, 48.76268], [14.95641, 48.75915], [14.9758, 48.76857], [14.98112, 48.77524], [14.9782, 48.7766], [14.98032, 48.77959], [14.95072, 48.79101], [14.98917, 48.90082], [14.97612, 48.96983], [14.99878, 49.01444], [15.15534, 48.99056], [15.16358, 48.94278], [15.26177, 48.95766], [15.28305, 48.98831], [15.34823, 48.98444], [15.48027, 48.94481], [15.51357, 48.91549], [15.61622, 48.89541], [15.6921, 48.85973], [15.75341, 48.8516], [15.78087, 48.87644], [15.84404, 48.86921], [16.06034, 48.75436], [16.37345, 48.729], [16.40915, 48.74576], [16.46134, 48.80865], [16.67008, 48.77699], [16.68518, 48.7281], [16.71883, 48.73806], [16.79779, 48.70998], [16.90354, 48.71541], [16.93955, 48.60371], [17.00215, 48.70887], [17.11202, 48.82925], [17.19355, 48.87602], [17.29054, 48.85546], [17.3853, 48.80936], [17.45671, 48.85004], [17.5295, 48.81117], [17.7094, 48.86721], [17.73126, 48.87885], [17.77944, 48.92318], [17.87831, 48.92679], [17.91814, 49.01784], [18.06885, 49.03157], [18.1104, 49.08624], [18.15022, 49.24518], [18.18456, 49.28909], [18.36446, 49.3267], [18.4139, 49.36517], [18.4084, 49.40003], [18.44686, 49.39467], [18.54848, 49.47059], [18.53063, 49.49022], [18.57183, 49.51162], [18.6144, 49.49824], [18.67757, 49.50895], [18.74761, 49.492], [18.84521, 49.51672], [18.84786, 49.5446], [18.80479, 49.6815], [18.72838, 49.68163], [18.69817, 49.70473], [18.62676, 49.71983], [18.62943, 49.74603], [18.62645, 49.75002], [18.61368, 49.75426], [18.61278, 49.7618], [18.57183, 49.83334], [18.60341, 49.86256], [18.57045, 49.87849], [18.57697, 49.91565], [18.54299, 49.92537], [18.54495, 49.9079], [18.53423, 49.89906], [18.41604, 49.93498], [18.33562, 49.94747], [18.33278, 49.92415], [18.31914, 49.91565], [18.27794, 49.93863], [18.27107, 49.96779], [18.21752, 49.97309], [18.20241, 49.99958], [18.10628, 50.00223], [18.07898, 50.04535], [18.03212, 50.06574], [18.00396, 50.04954], [18.04585, 50.03311], [18.04585, 50.01194], [18.00191, 50.01723], [17.86886, 49.97452], [17.77669, 50.02253], [17.7506, 50.07896], [17.6888, 50.12037], [17.66683, 50.10275], [17.59404, 50.16437], [17.70528, 50.18812], [17.76296, 50.23382], [17.72176, 50.25665], [17.74648, 50.29966], [17.69292, 50.32859], [17.67764, 50.28977], [17.58889, 50.27837], [17.3702, 50.28123], [17.34548, 50.2628], [17.34273, 50.32947], [17.27681, 50.32246], [17.19991, 50.3654], [17.19579, 50.38817], [17.14498, 50.38117], [17.1224, 50.39494], [16.89229, 50.45117], [16.85933, 50.41093], [16.90877, 50.38642], [16.94448, 50.31281], [16.99803, 50.30316], [17.02138, 50.27772], [16.99803, 50.25753], [17.02825, 50.23118], [17.00353, 50.21449], [16.98018, 50.24172], [16.8456, 50.20834], [16.7014, 50.09659], [16.63137, 50.1142], [16.55446, 50.16613], [16.56407, 50.21009], [16.42674, 50.32509], [16.39379, 50.3207], [16.3622, 50.34875], [16.36495, 50.37679], [16.30289, 50.38292], [16.28118, 50.36891], [16.22821, 50.41054], [16.21585, 50.40627], [16.19526, 50.43291], [16.31413, 50.50274], [16.34572, 50.49575], [16.44597, 50.58041], [16.33611, 50.66579], [16.23174, 50.67101], [16.20839, 50.63096], [16.10265, 50.66405], [16.02437, 50.60046], [15.98317, 50.61528], [16.0175, 50.63009], [15.97219, 50.69799], [15.87331, 50.67188], [15.81683, 50.75666], [15.73186, 50.73885], [15.43798, 50.80833], [15.3803, 50.77187], [15.36656, 50.83956], [15.2773, 50.8907], [15.27043, 50.97724], [15.2361, 50.99886], [15.1743, 50.9833], [15.16744, 51.01959], [15.11937, 50.99021], [15.10152, 51.01095], [15.06218, 51.02269], [15.03895, 51.0123], [15.02433, 51.0242], [14.96419, 50.99108], [15.01088, 50.97984], [14.99852, 50.86817], [14.82803, 50.86966]]]] } },
    { type: "Feature", properties: { iso1A2: "DE", iso1A3: "DEU", iso1N3: "276", wikidata: "Q183", nameEn: "Germany", groups: ["EU", "155", "150", "UN"], callingCodes: ["49"] }, geometry: { type: "MultiPolygon", coordinates: [[[[8.70847, 47.68904], [8.71773, 47.69088], [8.70237, 47.71453], [8.66416, 47.71367], [8.67508, 47.6979], [8.65769, 47.68928], [8.66837, 47.68437], [8.68985, 47.69552], [8.70847, 47.68904]]], [[[8.72617, 47.69651], [8.72809, 47.69282], [8.75856, 47.68969], [8.79511, 47.67462], [8.79966, 47.70222], [8.76965, 47.7075], [8.77309, 47.72059], [8.80663, 47.73821], [8.82002, 47.71458], [8.86989, 47.70504], [8.85065, 47.68209], [8.87383, 47.67045], [8.87625, 47.65441], [8.89946, 47.64769], [8.94093, 47.65596], [9.02093, 47.6868], [9.09891, 47.67801], [9.13845, 47.66389], [9.15181, 47.66904], [9.1705, 47.65513], [9.1755, 47.65584], [9.17593, 47.65399], [9.18203, 47.65598], [9.25619, 47.65939], [9.55125, 47.53629], [9.72736, 47.53457], [9.76748, 47.5934], [9.80254, 47.59419], [9.82591, 47.58158], [9.8189, 47.54688], [9.87499, 47.52953], [9.87733, 47.54688], [9.92407, 47.53111], [9.96029, 47.53899], [10.00003, 47.48216], [10.03859, 47.48927], [10.07131, 47.45531], [10.09001, 47.46005], [10.1052, 47.4316], [10.06897, 47.40709], [10.09819, 47.35724], [10.11805, 47.37228], [10.16362, 47.36674], [10.17648, 47.38889], [10.2127, 47.38019], [10.22774, 47.38904], [10.23757, 47.37609], [10.19998, 47.32832], [10.2147, 47.31014], [10.17648, 47.29149], [10.17531, 47.27167], [10.23257, 47.27088], [10.33424, 47.30813], [10.39851, 47.37623], [10.4324, 47.38494], [10.4359, 47.41183], [10.47446, 47.43318], [10.46278, 47.47901], [10.44291, 47.48453], [10.4324, 47.50111], [10.44992, 47.5524], [10.43473, 47.58394], [10.47329, 47.58552], [10.48849, 47.54057], [10.56912, 47.53584], [10.60337, 47.56755], [10.63456, 47.5591], [10.68832, 47.55752], [10.6965, 47.54253], [10.7596, 47.53228], [10.77596, 47.51729], [10.88814, 47.53701], [10.91268, 47.51334], [10.86945, 47.5015], [10.87061, 47.4786], [10.90918, 47.48571], [10.93839, 47.48018], [10.92437, 47.46991], [10.98513, 47.42882], [10.97111, 47.41617], [10.97111, 47.39561], [11.11835, 47.39719], [11.12536, 47.41222], [11.20482, 47.43198], [11.25157, 47.43277], [11.22002, 47.3964], [11.27844, 47.39956], [11.29597, 47.42566], [11.33804, 47.44937], [11.4175, 47.44621], [11.38128, 47.47465], [11.4362, 47.51413], [11.52618, 47.50939], [11.58578, 47.52281], [11.58811, 47.55515], [11.60681, 47.57881], [11.63934, 47.59202], [11.84052, 47.58354], [11.85572, 47.60166], [12.0088, 47.62451], [12.02282, 47.61033], [12.05788, 47.61742], [12.13734, 47.60639], [12.17824, 47.61506], [12.18145, 47.61019], [12.17737, 47.60121], [12.18568, 47.6049], [12.20398, 47.60667], [12.20801, 47.61082], [12.19895, 47.64085], [12.18507, 47.65984], [12.18347, 47.66663], [12.16769, 47.68167], [12.16217, 47.70105], [12.18303, 47.70065], [12.22571, 47.71776], [12.2542, 47.7433], [12.26238, 47.73544], [12.24017, 47.69534], [12.26004, 47.67725], [12.27991, 47.68827], [12.336, 47.69534], [12.37222, 47.68433], [12.43883, 47.6977], [12.44117, 47.6741], [12.50076, 47.62293], [12.53816, 47.63553], [12.57438, 47.63238], [12.6071, 47.6741], [12.7357, 47.6787], [12.77777, 47.66689], [12.76492, 47.64485], [12.82101, 47.61493], [12.77427, 47.58025], [12.80699, 47.54477], [12.84672, 47.54556], [12.85256, 47.52741], [12.9624, 47.47452], [12.98344, 47.48716], [12.9998, 47.46267], [13.04537, 47.49426], [13.03252, 47.53373], [13.05355, 47.56291], [13.04537, 47.58183], [13.06641, 47.58577], [13.06407, 47.60075], [13.09562, 47.63304], [13.07692, 47.68814], [13.01382, 47.72116], [12.98578, 47.7078], [12.92969, 47.71094], [12.91333, 47.7178], [12.90274, 47.72513], [12.91711, 47.74026], [12.9353, 47.74788], [12.94371, 47.76281], [12.93202, 47.77302], [12.96311, 47.79957], [12.98543, 47.82896], [13.00588, 47.84374], [12.94163, 47.92927], [12.93886, 47.94046], [12.93642, 47.94436], [12.93419, 47.94063], [12.92668, 47.93879], [12.91985, 47.94069], [12.9211, 47.95135], [12.91683, 47.95647], [12.87476, 47.96195], [12.8549, 48.01122], [12.76141, 48.07373], [12.74973, 48.10885], [12.7617, 48.12796], [12.78595, 48.12445], [12.80676, 48.14979], [12.82673, 48.15245], [12.8362, 48.15876], [12.836, 48.1647], [12.84475, 48.16556], [12.87126, 48.20318], [12.95306, 48.20629], [13.02083, 48.25689], [13.0851, 48.27711], [13.126, 48.27867], [13.18093, 48.29577], [13.26039, 48.29422], [13.30897, 48.31575], [13.40709, 48.37292], [13.43929, 48.43386], [13.42527, 48.45711], [13.45727, 48.51092], [13.43695, 48.55776], [13.45214, 48.56472], [13.46967, 48.55157], [13.50663, 48.57506], [13.50131, 48.58091], [13.51291, 48.59023], [13.57535, 48.55912], [13.59705, 48.57013], [13.62508, 48.55501], [13.65186, 48.55092], [13.66113, 48.53558], [13.72802, 48.51208], [13.74816, 48.53058], [13.7513, 48.5624], [13.76921, 48.55324], [13.80519, 48.58026], [13.80038, 48.59487], [13.82609, 48.62345], [13.81901, 48.6761], [13.81283, 48.68426], [13.81791, 48.69832], [13.79337, 48.71375], [13.81863, 48.73257], [13.82266, 48.75544], [13.84023, 48.76988], [13.8096, 48.77877], [13.78977, 48.83319], [13.76994, 48.83537], [13.73854, 48.88538], [13.67739, 48.87886], [13.61624, 48.9462], [13.58319, 48.96899], [13.50552, 48.97441], [13.50221, 48.93752], [13.40802, 48.98851], [13.39479, 49.04812], [13.28242, 49.1228], [13.23689, 49.11412], [13.20405, 49.12303], [13.17019, 49.14339], [13.17665, 49.16713], [13.05883, 49.26259], [13.02957, 49.27399], [13.03618, 49.30417], [12.94859, 49.34079], [12.88249, 49.35479], [12.88414, 49.33541], [12.78168, 49.34618], [12.75854, 49.3989], [12.71227, 49.42363], [12.669, 49.42935], [12.64121, 49.47628], [12.64782, 49.52565], [12.60155, 49.52887], [12.56188, 49.6146], [12.53544, 49.61888], [12.52553, 49.68415], [12.4462, 49.70233], [12.40489, 49.76321], [12.46603, 49.78882], [12.48256, 49.83575], [12.55197, 49.92094], [12.47264, 49.94222], [12.49908, 49.97305], [12.30798, 50.05719], [12.26111, 50.06331], [12.27433, 50.0771], [12.23709, 50.10213], [12.2073, 50.10315], [12.1917, 50.13434], [12.21484, 50.16399], [12.19335, 50.19997], [12.09287, 50.25032], [12.13716, 50.27396], [12.10907, 50.32041], [12.18013, 50.32146], [12.20823, 50.2729], [12.25119, 50.27079], [12.26953, 50.25189], [12.24791, 50.25525], [12.23943, 50.24594], [12.28755, 50.22429], [12.28063, 50.19544], [12.29232, 50.17524], [12.32596, 50.17146], [12.33847, 50.19432], [12.32445, 50.20442], [12.33263, 50.24367], [12.35425, 50.23993], [12.36594, 50.28289], [12.40158, 50.29521], [12.39924, 50.32302], [12.43371, 50.32506], [12.43722, 50.33774], [12.46643, 50.35527], [12.48256, 50.34784], [12.49214, 50.35228], [12.48747, 50.37278], [12.51356, 50.39694], [12.67261, 50.41949], [12.70731, 50.39948], [12.73044, 50.42268], [12.73476, 50.43237], [12.82465, 50.45738], [12.94058, 50.40944], [12.98433, 50.42016], [13.02147, 50.44763], [13.02038, 50.4734], [13.0312, 50.50944], [13.08301, 50.50132], [13.13424, 50.51709], [13.19043, 50.50237], [13.25158, 50.59268], [13.29454, 50.57904], [13.32594, 50.58009], [13.32264, 50.60317], [13.37805, 50.627], [13.37485, 50.64931], [13.42189, 50.61243], [13.46413, 50.60102], [13.49742, 50.63133], [13.5226, 50.64721], [13.53748, 50.67654], [13.52474, 50.70394], [13.65977, 50.73096], [13.70204, 50.71771], [13.76316, 50.73487], [13.82942, 50.7251], [13.89444, 50.74142], [13.89113, 50.78533], [13.98864, 50.8177], [14.02982, 50.80662], [14.22331, 50.86049], [14.24314, 50.88761], [14.27123, 50.89386], [14.30098, 50.88448], [14.38691, 50.89907], [14.39848, 50.93866], [14.31422, 50.95243], [14.30251, 50.96606], [14.32793, 50.97379], [14.32353, 50.98556], [14.28776, 50.97718], [14.25665, 50.98935], [14.30098, 51.05515], [14.41335, 51.02086], [14.45827, 51.03712], [14.49202, 51.02286], [14.49154, 51.04382], [14.49991, 51.04692], [14.50809, 51.0427], [14.49873, 51.02242], [14.53321, 51.01679], [14.53438, 51.00374], [14.56432, 51.01008], [14.58215, 50.99306], [14.59908, 50.98685], [14.59702, 50.96148], [14.56374, 50.922], [14.58024, 50.91443], [14.64802, 50.93241], [14.65259, 50.90513], [14.63434, 50.8883], [14.61993, 50.86049], [14.70661, 50.84096], [14.79139, 50.81438], [14.82803, 50.86966], [14.81664, 50.88148], [14.89681, 50.9422], [14.89252, 50.94999], [14.92942, 50.99744], [14.95529, 51.04552], [14.97938, 51.07742], [14.98229, 51.11354], [14.99689, 51.12205], [14.99079, 51.14284], [14.99646, 51.14365], [15.00083, 51.14974], [14.99414, 51.15813], [14.99311, 51.16249], [15.0047, 51.16874], [15.01242, 51.21285], [15.04288, 51.28387], [14.98008, 51.33449], [14.96899, 51.38367], [14.9652, 51.44793], [14.94749, 51.47155], [14.73219, 51.52922], [14.72652, 51.53902], [14.73047, 51.54606], [14.71125, 51.56209], [14.7727, 51.61263], [14.75759, 51.62318], [14.75392, 51.67445], [14.69065, 51.70842], [14.66386, 51.73282], [14.64625, 51.79472], [14.60493, 51.80473], [14.59089, 51.83302], [14.6588, 51.88359], [14.6933, 51.9044], [14.70601, 51.92944], [14.7177, 51.94048], [14.72163, 51.95188], [14.71836, 51.95606], [14.7139, 51.95643], [14.70488, 51.97679], [14.71339, 52.00337], [14.76026, 52.06624], [14.72971, 52.09167], [14.6917, 52.10283], [14.67683, 52.13936], [14.70616, 52.16927], [14.68344, 52.19612], [14.71319, 52.22144], [14.70139, 52.25038], [14.58149, 52.28007], [14.56378, 52.33838], [14.55228, 52.35264], [14.54423, 52.42568], [14.63056, 52.48993], [14.60081, 52.53116], [14.6289, 52.57136], [14.61073, 52.59847], [14.22071, 52.81175], [14.13806, 52.82392], [14.12256, 52.84311], [14.15873, 52.87715], [14.14056, 52.95786], [14.25954, 53.00264], [14.35044, 53.05829], [14.38679, 53.13669], [14.36696, 53.16444], [14.37853, 53.20405], [14.40662, 53.21098], [14.45125, 53.26241], [14.44133, 53.27427], [14.4215, 53.27724], [14.35209, 53.49506], [14.3273, 53.50587], [14.30416, 53.55499], [14.31904, 53.61581], [14.2853, 53.63392], [14.28477, 53.65955], [14.27133, 53.66613], [14.2836, 53.67721], [14.26782, 53.69866], [14.27249, 53.74464], [14.21323, 53.8664], [14.20823, 53.90776], [14.18544, 53.91258], [14.20647, 53.91671], [14.22634, 53.9291], [14.20811, 54.12784], [13.93395, 54.84044], [12.85844, 54.82438], [11.90309, 54.38543], [11.00303, 54.63689], [10.31111, 54.65968], [10.16755, 54.73883], [9.89314, 54.84171], [9.73563, 54.8247], [9.61187, 54.85548], [9.62734, 54.88057], [9.58937, 54.88785], [9.4659, 54.83131], [9.43155, 54.82586], [9.41213, 54.84254], [9.38532, 54.83968], [9.36496, 54.81749], [9.33849, 54.80233], [9.32771, 54.80602], [9.2474, 54.8112], [9.23445, 54.83432], [9.24631, 54.84726], [9.20571, 54.85841], [9.14275, 54.87421], [9.04629, 54.87249], [8.92795, 54.90452], [8.81178, 54.90518], [8.76387, 54.8948], [8.63979, 54.91069], [8.55769, 54.91837], [8.45719, 55.06747], [8.02459, 55.09613], [5.45168, 54.20039], [6.91025, 53.44221], [7.00198, 53.32672], [7.19052, 53.31866], [7.21679, 53.20058], [7.22681, 53.18165], [7.17898, 53.13817], [7.21694, 53.00742], [7.07253, 52.81083], [7.04557, 52.63318], [6.77307, 52.65375], [6.71641, 52.62905], [6.69507, 52.488], [6.94293, 52.43597], [6.99041, 52.47235], [7.03417, 52.40237], [7.07044, 52.37805], [7.02703, 52.27941], [7.06365, 52.23789], [7.03729, 52.22695], [6.9897, 52.2271], [6.97189, 52.20329], [6.83984, 52.11728], [6.76117, 52.11895], [6.68128, 52.05052], [6.83035, 51.9905], [6.82357, 51.96711], [6.72319, 51.89518], [6.68386, 51.91861], [6.58556, 51.89386], [6.50231, 51.86313], [6.47179, 51.85395], [6.38815, 51.87257], [6.40704, 51.82771], [6.30593, 51.84998], [6.29872, 51.86801], [6.21443, 51.86801], [6.15349, 51.90439], [6.11551, 51.89769], [6.16902, 51.84094], [6.10337, 51.84829], [6.06705, 51.86136], [5.99848, 51.83195], [5.94568, 51.82786], [5.98665, 51.76944], [5.95003, 51.7493], [6.04091, 51.71821], [6.02767, 51.6742], [6.11759, 51.65609], [6.09055, 51.60564], [6.18017, 51.54096], [6.21724, 51.48568], [6.20654, 51.40049], [6.22641, 51.39948], [6.22674, 51.36135], [6.16977, 51.33169], [6.07889, 51.24432], [6.07889, 51.17038], [6.17384, 51.19589], [6.16706, 51.15677], [5.98292, 51.07469], [5.9541, 51.03496], [5.9134, 51.06736], [5.86735, 51.05182], [5.87849, 51.01969], [5.90493, 51.00198], [5.90296, 50.97356], [5.95282, 50.98728], [6.02697, 50.98303], [6.01615, 50.93367], [6.09297, 50.92066], [6.07486, 50.89307], [6.08805, 50.87223], [6.07693, 50.86025], [6.07431, 50.84674], [6.05702, 50.85179], [6.05623, 50.8572], [6.01921, 50.84435], [6.02328, 50.81694], [6.00462, 50.80065], [5.98404, 50.80988], [5.97497, 50.79992], [6.02624, 50.77453], [6.01976, 50.75398], [6.03889, 50.74618], [6.0326, 50.72647], [6.0406, 50.71848], [6.04428, 50.72861], [6.11707, 50.72231], [6.17852, 50.6245], [6.26957, 50.62444], [6.2476, 50.60392], [6.24888, 50.59869], [6.24005, 50.58732], [6.22581, 50.5907], [6.20281, 50.56952], [6.17739, 50.55875], [6.17802, 50.54179], [6.19735, 50.53576], [6.19579, 50.5313], [6.18716, 50.52653], [6.19193, 50.5212], [6.20599, 50.52089], [6.22335, 50.49578], [6.26637, 50.50272], [6.30809, 50.50058], [6.3465, 50.48833], [6.34005, 50.46083], [6.37219, 50.45397], [6.36852, 50.40776], [6.34406, 50.37994], [6.3688, 50.35898], [6.40785, 50.33557], [6.40641, 50.32425], [6.35701, 50.31139], [6.32488, 50.32333], [6.29949, 50.30887], [6.28797, 50.27458], [6.208, 50.25179], [6.16853, 50.2234], [6.18364, 50.20815], [6.18739, 50.1822], [6.14588, 50.17106], [6.14132, 50.14971], [6.15298, 50.14126], [6.1379, 50.12964], [6.12055, 50.09171], [6.11274, 50.05916], [6.13458, 50.04141], [6.13044, 50.02929], [6.14666, 50.02207], [6.13794, 50.01466], [6.13273, 50.02019], [6.1295, 50.01849], [6.13806, 50.01056], [6.14948, 50.00908], [6.14147, 49.99563], [6.1701, 49.98518], [6.16466, 49.97086], [6.17872, 49.9537], [6.18554, 49.95622], [6.18045, 49.96611], [6.19089, 49.96991], [6.19856, 49.95053], [6.22094, 49.94955], [6.22608, 49.929], [6.21882, 49.92403], [6.22926, 49.92096], [6.23496, 49.89972], [6.26146, 49.88203], [6.28874, 49.87592], [6.29692, 49.86685], [6.30963, 49.87021], [6.32303, 49.85133], [6.32098, 49.83728], [6.33585, 49.83785], [6.34267, 49.84974], [6.36576, 49.85032], [6.40022, 49.82029], [6.42521, 49.81591], [6.42905, 49.81091], [6.44131, 49.81443], [6.45425, 49.81164], [6.47111, 49.82263], [6.48718, 49.81267], [6.50647, 49.80916], [6.51215, 49.80124], [6.52121, 49.81338], [6.53122, 49.80666], [6.52169, 49.79787], [6.50534, 49.78952], [6.51669, 49.78336], [6.51056, 49.77515], [6.51828, 49.76855], [6.51646, 49.75961], [6.50174, 49.75292], [6.50193, 49.73291], [6.51805, 49.72425], [6.51397, 49.72058], [6.50261, 49.72718], [6.49535, 49.72645], [6.49694, 49.72205], [6.5042, 49.71808], [6.50647, 49.71353], [6.49785, 49.71118], [6.48014, 49.69767], [6.46048, 49.69092], [6.44654, 49.67799], [6.42937, 49.66857], [6.42726, 49.66078], [6.43768, 49.66021], [6.4413, 49.65722], [6.41861, 49.61723], [6.39822, 49.60081], [6.385, 49.59946], [6.37464, 49.58886], [6.38342, 49.5799], [6.38024, 49.57593], [6.36676, 49.57813], [6.35825, 49.57053], [6.38228, 49.55855], [6.38072, 49.55171], [6.35666, 49.52931], [6.36788, 49.50377], [6.36907, 49.48931], [6.36778, 49.46937], [6.38352, 49.46463], [6.39168, 49.4667], [6.40274, 49.46546], [6.42432, 49.47683], [6.55404, 49.42464], [6.533, 49.40748], [6.60091, 49.36864], [6.58807, 49.35358], [6.572, 49.35027], [6.60186, 49.31055], [6.66583, 49.28065], [6.69274, 49.21661], [6.71843, 49.2208], [6.73256, 49.20486], [6.71137, 49.18808], [6.73765, 49.16375], [6.78265, 49.16793], [6.83385, 49.15162], [6.84703, 49.15734], [6.86225, 49.18185], [6.85016, 49.19354], [6.85119, 49.20038], [6.83555, 49.21249], [6.85939, 49.22376], [6.89298, 49.20863], [6.91875, 49.22261], [6.93831, 49.2223], [6.94028, 49.21641], [6.95963, 49.203], [6.97273, 49.2099], [7.01318, 49.19018], [7.03459, 49.19096], [7.0274, 49.17042], [7.03178, 49.15734], [7.04662, 49.13724], [7.04409, 49.12123], [7.04843, 49.11422], [7.05548, 49.11185], [7.06642, 49.11415], [7.07162, 49.1255], [7.09007, 49.13094], [7.07859, 49.15031], [7.10715, 49.15631], [7.10384, 49.13787], [7.12504, 49.14253], [7.1358, 49.1282], [7.1593, 49.1204], [7.23473, 49.12971], [7.29514, 49.11426], [7.3195, 49.14231], [7.35995, 49.14399], [7.3662, 49.17308], [7.44052, 49.18354], [7.44455, 49.16765], [7.49473, 49.17], [7.49172, 49.13915], [7.53012, 49.09818], [7.56416, 49.08136], [7.62575, 49.07654], [7.63618, 49.05428], [7.75948, 49.04562], [7.79557, 49.06583], [7.86386, 49.03499], [7.93641, 49.05544], [7.97783, 49.03161], [8.14189, 48.97833], [8.22604, 48.97352], [8.20031, 48.95856], [8.19989, 48.95825], [8.12813, 48.87985], [8.10253, 48.81829], [8.06802, 48.78957], [8.0326, 48.79017], [8.01534, 48.76085], [7.96994, 48.75606], [7.96812, 48.72491], [7.89002, 48.66317], [7.84098, 48.64217], [7.80057, 48.5857], [7.80167, 48.54758], [7.80647, 48.51239], [7.76833, 48.48945], [7.73109, 48.39192], [7.74562, 48.32736], [7.69022, 48.30018], [7.6648, 48.22219], [7.57137, 48.12292], [7.56966, 48.03265], [7.62302, 47.97898], [7.55673, 47.87371], [7.52921, 47.77747], [7.54761, 47.72912], [7.53722, 47.71635], [7.51266, 47.70197], [7.51915, 47.68335], [7.52067, 47.66437], [7.53384, 47.65115], [7.5591, 47.63849], [7.57423, 47.61628], [7.58851, 47.60794], [7.59301, 47.60058], [7.58945, 47.59017], [7.60523, 47.58519], [7.60459, 47.57869], [7.61929, 47.57683], [7.64309, 47.59151], [7.64213, 47.5944], [7.64599, 47.59695], [7.67395, 47.59212], [7.68229, 47.59905], [7.69385, 47.60099], [7.68486, 47.59601], [7.67115, 47.5871], [7.68904, 47.57133], [7.67655, 47.56435], [7.63338, 47.56256], [7.65083, 47.54662], [7.66174, 47.54554], [7.6656, 47.53752], [7.68101, 47.53232], [7.69642, 47.53297], [7.71961, 47.54219], [7.75261, 47.54599], [7.79486, 47.55691], [7.81901, 47.58798], [7.84412, 47.5841], [7.88664, 47.58854], [7.90673, 47.57674], [7.91251, 47.55031], [7.94494, 47.54511], [7.95682, 47.55789], [7.97581, 47.55493], [8.00113, 47.55616], [8.02136, 47.55096], [8.04383, 47.55443], [8.06663, 47.56374], [8.08557, 47.55768], [8.10002, 47.56504], [8.10395, 47.57918], [8.11543, 47.5841], [8.13662, 47.58432], [8.13823, 47.59147], [8.14947, 47.59558], [8.1652, 47.5945], [8.19378, 47.61636], [8.20617, 47.62141], [8.22011, 47.6181], [8.22577, 47.60385], [8.23809, 47.61204], [8.25863, 47.61571], [8.26313, 47.6103], [8.2824, 47.61225], [8.29722, 47.60603], [8.29524, 47.5919], [8.30277, 47.58607], [8.32735, 47.57133], [8.35512, 47.57014], [8.38273, 47.56608], [8.39477, 47.57826], [8.43235, 47.56617], [8.49431, 47.58107], [8.48949, 47.588], [8.46637, 47.58389], [8.45578, 47.60121], [8.50747, 47.61897], [8.51686, 47.63476], [8.55756, 47.62394], [8.57586, 47.59537], [8.60348, 47.61204], [8.59545, 47.64298], [8.60701, 47.65271], [8.61471, 47.64514], [8.60412, 47.63735], [8.62049, 47.63757], [8.62884, 47.65098], [8.61113, 47.66332], [8.6052, 47.67258], [8.57683, 47.66158], [8.56141, 47.67088], [8.52801, 47.66059], [8.5322, 47.64687], [8.49656, 47.64709], [8.46605, 47.64103], [8.4667, 47.65747], [8.44711, 47.65379], [8.42264, 47.66667], [8.41346, 47.66676], [8.40473, 47.67499], [8.4211, 47.68407], [8.40569, 47.69855], [8.44807, 47.72426], [8.45771, 47.7493], [8.48868, 47.77215], [8.56814, 47.78001], [8.56415, 47.80633], [8.61657, 47.79998], [8.62408, 47.7626], [8.64425, 47.76398], [8.65292, 47.80066], [8.68022, 47.78599], [8.68985, 47.75686], [8.71778, 47.76571], [8.74251, 47.75168], [8.70543, 47.73121], [8.73671, 47.7169], [8.72617, 47.69651]]]] } },
    { type: "Feature", properties: { iso1A2: "DG", iso1A3: "DGA", wikidata: "Q184851", nameEn: "Diego Garcia", country: "GB", groups: ["IO", "BOTS", "014", "202", "002", "UN"], isoStatus: "excRes", callingCodes: ["246"] }, geometry: { type: "MultiPolygon", coordinates: [[[[73.14823, -7.76302], [73.09982, -6.07324], [71.43792, -7.73904], [73.14823, -7.76302]]]] } },
    { type: "Feature", properties: { iso1A2: "DJ", iso1A3: "DJI", iso1N3: "262", wikidata: "Q977", nameEn: "Djibouti", groups: ["014", "202", "002", "UN"], callingCodes: ["253"] }, geometry: { type: "MultiPolygon", coordinates: [[[[43.90659, 12.3823], [43.90659, 12.3823], [43.32909, 12.59711], [43.29075, 12.79154], [42.86195, 12.58747], [42.7996, 12.42629], [42.6957, 12.36201], [42.46941, 12.52661], [42.4037, 12.46478], [41.95461, 11.81157], [41.82878, 11.72361], [41.77727, 11.49902], [41.8096, 11.33606], [41.80056, 10.97127], [42.06302, 10.92599], [42.13691, 10.97586], [42.42669, 10.98493], [42.62989, 11.09711], [42.75111, 11.06992], [42.79037, 10.98493], [42.95776, 10.98533], [43.90659, 12.3823]]]] } },
    { type: "Feature", properties: { iso1A2: "DK", iso1A3: "DNK", iso1N3: "208", wikidata: "Q756617", nameEn: "Kingdom of Denmark" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "DM", iso1A3: "DMA", iso1N3: "212", wikidata: "Q784", nameEn: "Dominica", groups: ["029", "003", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", callingCodes: ["1 767"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-61.32485, 14.91445], [-60.86656, 15.82603], [-61.95646, 15.5094], [-61.32485, 14.91445]]]] } },
    { type: "Feature", properties: { iso1A2: "DO", iso1A3: "DOM", iso1N3: "214", wikidata: "Q786", nameEn: "Dominican Republic", groups: ["029", "003", "419", "019", "UN"], callingCodes: ["1 809", "1 829", "1 849"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-67.87844, 21.7938], [-72.38946, 20.27111], [-71.77419, 19.73128], [-71.75865, 19.70231], [-71.7429, 19.58445], [-71.71449, 19.55364], [-71.71268, 19.53374], [-71.6802, 19.45008], [-71.69448, 19.37866], [-71.77766, 19.33823], [-71.73229, 19.26686], [-71.62642, 19.21212], [-71.65337, 19.11759], [-71.69938, 19.10916], [-71.71088, 19.08353], [-71.74088, 19.0437], [-71.88102, 18.95007], [-71.77766, 18.95007], [-71.72624, 18.87802], [-71.71885, 18.78423], [-71.82556, 18.62551], [-71.95412, 18.64939], [-72.00201, 18.62312], [-71.88102, 18.50125], [-71.90875, 18.45821], [-71.69952, 18.34101], [-71.78271, 18.18302], [-71.75465, 18.14405], [-71.74994, 18.11115], [-71.73783, 18.07177], [-71.75671, 18.03456], [-72.29523, 17.48026], [-68.39466, 16.14167], [-67.87844, 21.7938]]]] } },
    { type: "Feature", properties: { iso1A2: "DZ", iso1A3: "DZA", iso1N3: "012", wikidata: "Q262", nameEn: "Algeria", groups: ["015", "002", "UN"], callingCodes: ["213"] }, geometry: { type: "MultiPolygon", coordinates: [[[[8.59123, 37.14286], [5.10072, 39.89531], [-2.27707, 35.35051], [-2.21248, 35.08532], [-2.21445, 35.04378], [-2.04734, 34.93218], [-1.97833, 34.93218], [-1.97469, 34.886], [-1.73707, 34.74226], [-1.84569, 34.61907], [-1.69788, 34.48056], [-1.78042, 34.39018], [-1.64666, 34.10405], [-1.73494, 33.71721], [-1.59508, 33.59929], [-1.67067, 33.27084], [-1.46249, 33.0499], [-1.54244, 32.95499], [-1.37794, 32.73628], [-0.9912, 32.52467], [-1.24998, 32.32993], [-1.24453, 32.1917], [-1.15735, 32.12096], [-1.22829, 32.07832], [-2.46166, 32.16603], [-2.93873, 32.06557], [-2.82784, 31.79459], [-3.66314, 31.6339], [-3.66386, 31.39202], [-3.77647, 31.31912], [-3.77103, 31.14984], [-3.54944, 31.0503], [-3.65418, 30.85566], [-3.64735, 30.67539], [-4.31774, 30.53229], [-4.6058, 30.28343], [-5.21671, 29.95253], [-5.58831, 29.48103], [-5.72121, 29.52322], [-5.75616, 29.61407], [-6.69965, 29.51623], [-6.78351, 29.44634], [-6.95824, 29.50924], [-7.61585, 29.36252], [-8.6715, 28.71194], [-8.66879, 27.6666], [-8.66674, 27.31569], [-4.83423, 24.99935], [1.15698, 21.12843], [1.20992, 20.73533], [3.24648, 19.81703], [3.12501, 19.1366], [3.36082, 18.9745], [4.26651, 19.14224], [5.8153, 19.45101], [7.38361, 20.79165], [7.48273, 20.87258], [11.96886, 23.51735], [11.62498, 24.26669], [11.41061, 24.21456], [10.85323, 24.5595], [10.33159, 24.5465], [10.02432, 24.98124], [10.03146, 25.35635], [9.38834, 26.19288], [9.51696, 26.39148], [9.89569, 26.57696], [9.78136, 29.40961], [9.3876, 30.16738], [9.55544, 30.23971], [9.07483, 32.07865], [8.35999, 32.50101], [8.31895, 32.83483], [8.1179, 33.05086], [8.11433, 33.10175], [7.83028, 33.18851], [7.73687, 33.42114], [7.54088, 33.7726], [7.52851, 34.06493], [7.66174, 34.20167], [7.74207, 34.16492], [7.81242, 34.21841], [7.86264, 34.3987], [8.20482, 34.57575], [8.29655, 34.72798], [8.25189, 34.92009], [8.30727, 34.95378], [8.3555, 35.10007], [8.47318, 35.23376], [8.30329, 35.29884], [8.36086, 35.47774], [8.35371, 35.66373], [8.26472, 35.73669], [8.2626, 35.91733], [8.40731, 36.42208], [8.18936, 36.44939], [8.16167, 36.48817], [8.47609, 36.66607], [8.46537, 36.7706], [8.57613, 36.78062], [8.67706, 36.8364], [8.62972, 36.86499], [8.64044, 36.9401], [8.59123, 37.14286]]]] } },
    { type: "Feature", properties: { iso1A2: "EA", wikidata: "Q28868874", nameEn: "Ceuta, Melilla", country: "ES", level: "territory", isoStatus: "excRes" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "EC", iso1A3: "ECU", iso1N3: "218", wikidata: "Q736", nameEn: "Ecuador" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "EE", iso1A3: "EST", iso1N3: "233", wikidata: "Q191", nameEn: "Estonia", aliases: ["EW"], groups: ["EU", "154", "150", "UN"], callingCodes: ["372"] }, geometry: { type: "MultiPolygon", coordinates: [[[[26.32936, 60.00121], [20.5104, 59.15546], [19.84909, 57.57876], [22.80496, 57.87798], [23.20055, 57.56697], [24.26221, 57.91787], [24.3579, 57.87471], [25.19484, 58.0831], [25.28237, 57.98539], [25.29581, 58.08288], [25.73499, 57.90193], [26.05949, 57.84744], [26.0324, 57.79037], [26.02456, 57.78342], [26.027, 57.78158], [26.0266, 57.77441], [26.02069, 57.77169], [26.02415, 57.76865], [26.03332, 57.7718], [26.0543, 57.76105], [26.08098, 57.76619], [26.2029, 57.7206], [26.1866, 57.6849], [26.29253, 57.59244], [26.46527, 57.56885], [26.54675, 57.51813], [26.90364, 57.62823], [27.34698, 57.52242], [27.31919, 57.57672], [27.40393, 57.62125], [27.3746, 57.66834], [27.52615, 57.72843], [27.50171, 57.78842], [27.56689, 57.83356], [27.78526, 57.83963], [27.81841, 57.89244], [27.67282, 57.92627], [27.62393, 58.09462], [27.48541, 58.22615], [27.55489, 58.39525], [27.36366, 58.78381], [27.74429, 58.98351], [27.80482, 59.1116], [27.87978, 59.18097], [27.90911, 59.24353], [28.00689, 59.28351], [28.14215, 59.28934], [28.19284, 59.35791], [28.20537, 59.36491], [28.21137, 59.38058], [28.19061, 59.39962], [28.04187, 59.47017], [27.85643, 59.58538], [26.90044, 59.63819], [26.32936, 60.00121]]]] } },
    { type: "Feature", properties: { iso1A2: "EG", iso1A3: "EGY", iso1N3: "818", wikidata: "Q79", nameEn: "Egypt", groups: ["015", "002", "UN"], callingCodes: ["20"] }, geometry: { type: "MultiPolygon", coordinates: [[[[33.62659, 31.82938], [26.92891, 33.39516], [24.8458, 31.39877], [25.01077, 30.73861], [24.71117, 30.17441], [24.99968, 29.24574], [24.99885, 21.99535], [33.17563, 22.00405], [34.0765, 22.00501], [37.8565, 22.00903], [34.4454, 27.91479], [34.8812, 29.36878], [34.92298, 29.45305], [34.26742, 31.21998], [34.24012, 31.29591], [34.23572, 31.2966], [34.21853, 31.32363], [34.052, 31.46619], [33.62659, 31.82938]]]] } },
    { type: "Feature", properties: { iso1A2: "EH", iso1A3: "ESH", iso1N3: "732", wikidata: "Q6250", nameEn: "Western Sahara", groups: ["015", "002"], callingCodes: ["212"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-8.66879, 27.6666], [-8.77527, 27.66663], [-8.71787, 26.9898], [-9.08698, 26.98639], [-9.56957, 26.90042], [-9.81998, 26.71379], [-10.68417, 26.90984], [-11.35695, 26.8505], [-11.23622, 26.72023], [-11.38635, 26.611], [-11.62052, 26.05229], [-12.06001, 26.04442], [-12.12281, 25.13682], [-12.92147, 24.39502], [-13.00628, 24.01923], [-13.75627, 23.77231], [-14.10361, 22.75501], [-14.1291, 22.41636], [-14.48112, 22.00886], [-14.47329, 21.63839], [-14.78487, 21.36587], [-16.44269, 21.39745], [-16.9978, 21.36239], [-17.02707, 21.34022], [-17.21511, 21.34226], [-17.35589, 20.80492], [-17.0471, 20.76408], [-17.0695, 20.85742], [-17.06781, 20.92697], [-17.0396, 20.9961], [-17.0357, 21.05368], [-16.99806, 21.12142], [-16.95474, 21.33997], [-13.01525, 21.33343], [-13.08438, 22.53866], [-13.15313, 22.75649], [-13.10753, 22.89493], [-13.00412, 23.02297], [-12.5741, 23.28975], [-12.36213, 23.3187], [-12.14969, 23.41935], [-12.00251, 23.4538], [-12.0002, 25.9986], [-8.66721, 25.99918], [-8.66674, 27.31569], [-8.66879, 27.6666]]]] } },
    { type: "Feature", properties: { iso1A2: "ER", iso1A3: "ERI", iso1N3: "232", wikidata: "Q986", nameEn: "Eritrea", groups: ["014", "202", "002", "UN"], callingCodes: ["291"] }, geometry: { type: "MultiPolygon", coordinates: [[[[40.99158, 15.81743], [39.63762, 18.37348], [38.57727, 17.98125], [38.45916, 17.87167], [38.37133, 17.66269], [38.13362, 17.53906], [37.50967, 17.32199], [37.42694, 17.04041], [36.99777, 17.07172], [36.92193, 16.23451], [36.76371, 15.80831], [36.69761, 15.75323], [36.54276, 15.23478], [36.44337, 15.14963], [36.54376, 14.25597], [36.56536, 14.26177], [36.55659, 14.28237], [36.63364, 14.31172], [36.85787, 14.32201], [37.01622, 14.2561], [37.09486, 14.27155], [37.13206, 14.40746], [37.3106, 14.44657], [37.47319, 14.2149], [37.528, 14.18413], [37.91287, 14.89447], [38.0364, 14.72745], [38.25562, 14.67287], [38.3533, 14.51323], [38.45748, 14.41445], [38.78306, 14.4754], [38.98058, 14.54895], [39.02834, 14.63717], [39.16074, 14.65187], [39.14772, 14.61827], [39.19547, 14.56996], [39.23888, 14.56365], [39.26927, 14.48801], [39.2302, 14.44598], [39.2519, 14.40393], [39.37685, 14.54402], [39.52756, 14.49011], [39.50585, 14.55735], [39.58182, 14.60987], [39.76632, 14.54264], [39.9443, 14.41024], [40.07236, 14.54264], [40.14649, 14.53969], [40.21128, 14.39342], [40.25686, 14.41445], [40.9167, 14.11152], [41.25097, 13.60787], [41.62864, 13.38626], [42.05841, 12.80912], [42.21469, 12.75832], [42.2798, 12.6355], [42.4037, 12.46478], [42.46941, 12.52661], [42.6957, 12.36201], [42.7996, 12.42629], [42.86195, 12.58747], [43.29075, 12.79154], [40.99158, 15.81743]]]] } },
    { type: "Feature", properties: { iso1A2: "ES", iso1A3: "ESP", iso1N3: "724", wikidata: "Q29", nameEn: "Spain" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "ET", iso1A3: "ETH", iso1N3: "231", wikidata: "Q115", nameEn: "Ethiopia", groups: ["014", "202", "002", "UN"], callingCodes: ["251"] }, geometry: { type: "MultiPolygon", coordinates: [[[[42.4037, 12.46478], [42.2798, 12.6355], [42.21469, 12.75832], [42.05841, 12.80912], [41.62864, 13.38626], [41.25097, 13.60787], [40.9167, 14.11152], [40.25686, 14.41445], [40.21128, 14.39342], [40.14649, 14.53969], [40.07236, 14.54264], [39.9443, 14.41024], [39.76632, 14.54264], [39.58182, 14.60987], [39.50585, 14.55735], [39.52756, 14.49011], [39.37685, 14.54402], [39.2519, 14.40393], [39.2302, 14.44598], [39.26927, 14.48801], [39.23888, 14.56365], [39.19547, 14.56996], [39.14772, 14.61827], [39.16074, 14.65187], [39.02834, 14.63717], [38.98058, 14.54895], [38.78306, 14.4754], [38.45748, 14.41445], [38.3533, 14.51323], [38.25562, 14.67287], [38.0364, 14.72745], [37.91287, 14.89447], [37.528, 14.18413], [37.47319, 14.2149], [37.3106, 14.44657], [37.13206, 14.40746], [37.09486, 14.27155], [37.01622, 14.2561], [36.85787, 14.32201], [36.63364, 14.31172], [36.55659, 14.28237], [36.56536, 14.26177], [36.54376, 14.25597], [36.44653, 13.95666], [36.48824, 13.83954], [36.38993, 13.56459], [36.24545, 13.36759], [36.13374, 12.92665], [36.16651, 12.88019], [36.14268, 12.70879], [36.01458, 12.72478], [35.70476, 12.67101], [35.24302, 11.91132], [35.11492, 11.85156], [35.05832, 11.71158], [35.09556, 11.56278], [34.95704, 11.24448], [35.01215, 11.19626], [34.93172, 10.95946], [34.97789, 10.91559], [34.97491, 10.86147], [34.86916, 10.78832], [34.86618, 10.74588], [34.77532, 10.69027], [34.77383, 10.74588], [34.59062, 10.89072], [34.4372, 10.781], [34.2823, 10.53508], [34.34783, 10.23914], [34.32102, 10.11599], [34.22718, 10.02506], [34.20484, 9.9033], [34.13186, 9.7492], [34.08717, 9.55243], [34.10229, 9.50238], [34.14304, 9.04654], [34.14453, 8.60204], [34.01346, 8.50041], [33.89579, 8.4842], [33.87195, 8.41938], [33.71407, 8.3678], [33.66938, 8.44442], [33.54575, 8.47094], [33.3119, 8.45474], [33.19721, 8.40317], [33.1853, 8.29264], [33.18083, 8.13047], [33.08401, 8.05822], [33.0006, 7.90333], [33.04944, 7.78989], [33.24637, 7.77939], [33.32531, 7.71297], [33.44745, 7.7543], [33.71407, 7.65983], [33.87642, 7.5491], [34.02984, 7.36449], [34.03878, 7.27437], [34.01495, 7.25664], [34.19369, 7.12807], [34.19369, 7.04382], [34.35753, 6.91963], [34.47669, 6.91076], [34.53925, 6.82794], [34.53776, 6.74808], [34.65096, 6.72589], [34.77459, 6.5957], [34.87736, 6.60161], [35.01738, 6.46991], [34.96227, 6.26415], [35.00546, 5.89387], [35.12611, 5.68937], [35.13058, 5.62118], [35.31188, 5.50106], [35.29938, 5.34042], [35.50792, 5.42431], [35.8576, 5.33413], [35.81968, 5.10757], [35.82118, 4.77382], [35.9419, 4.61933], [35.95449, 4.53244], [36.03924, 4.44406], [36.84474, 4.44518], [37.07724, 4.33503], [38.14168, 3.62487], [38.45812, 3.60445], [38.52336, 3.62551], [38.91938, 3.51198], [39.07736, 3.5267], [39.19954, 3.47834], [39.49444, 3.45521], [39.51551, 3.40895], [39.55132, 3.39634], [39.58339, 3.47434], [39.76808, 3.67058], [39.86043, 3.86974], [40.77498, 4.27683], [41.1754, 3.94079], [41.89488, 3.97375], [42.07619, 4.17667], [42.55853, 4.20518], [42.84526, 4.28357], [42.97746, 4.44032], [43.04177, 4.57923], [43.40263, 4.79289], [44.02436, 4.9451], [44.98104, 4.91821], [47.97917, 8.00124], [47.92477, 8.00111], [46.99339, 7.9989], [44.19222, 8.93028], [43.32613, 9.59205], [43.23518, 9.84605], [43.0937, 9.90579], [42.87643, 10.18441], [42.69452, 10.62672], [42.95776, 10.98533], [42.79037, 10.98493], [42.75111, 11.06992], [42.62989, 11.09711], [42.42669, 10.98493], [42.13691, 10.97586], [42.06302, 10.92599], [41.80056, 10.97127], [41.8096, 11.33606], [41.77727, 11.49902], [41.82878, 11.72361], [41.95461, 11.81157], [42.4037, 12.46478]]]] } },
    { type: "Feature", properties: { iso1A2: "EU", iso1A3: "EUE", wikidata: "Q458", nameEn: "European Union", level: "union", isoStatus: "excRes" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "FI", iso1A3: "FIN", iso1N3: "246", wikidata: "Q33", nameEn: "Finland", aliases: ["SF"] }, geometry: null },
    { type: "Feature", properties: { iso1A2: "FJ", iso1A3: "FJI", iso1N3: "242", wikidata: "Q712", nameEn: "Fiji", groups: ["054", "009", "UN"], driveSide: "left", callingCodes: ["679"] }, geometry: { type: "MultiPolygon", coordinates: [[[[174.245, -23.1974], [179.99999, -22.5], [179.99999, -11.5], [174, -11.5], [174.245, -23.1974]]], [[[-176.76826, -14.95183], [-180, -14.96041], [-180, -22.90585], [-176.74538, -22.89767], [-176.76826, -14.95183]]]] } },
    { type: "Feature", properties: { iso1A2: "FK", iso1A3: "FLK", iso1N3: "238", wikidata: "Q9648", nameEn: "Falkland Islands", country: "GB", groups: ["BOTS", "005", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["500"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-63.67376, -55.11859], [-54.56126, -51.26248], [-61.26735, -50.63919], [-63.67376, -55.11859]]]] } },
    { type: "Feature", properties: { iso1A2: "FM", iso1A3: "FSM", iso1N3: "583", wikidata: "Q702", nameEn: "Federated States of Micronesia", groups: ["057", "009", "UN"], roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["691"] }, geometry: { type: "MultiPolygon", coordinates: [[[[138.20583, 13.3783], [136.27107, 6.73747], [156.88247, -1.39237], [165.19726, 6.22546], [138.20583, 13.3783]]]] } },
    { type: "Feature", properties: { iso1A2: "FO", iso1A3: "FRO", iso1N3: "234", wikidata: "Q4628", nameEn: "Faroe Islands", country: "DK", groups: ["154", "150", "UN"], callingCodes: ["298"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-8.51774, 62.35338], [-6.51083, 60.95272], [-5.70102, 62.77194], [-8.51774, 62.35338]]]] } },
    { type: "Feature", properties: { iso1A2: "FR", iso1A3: "FRA", iso1N3: "250", wikidata: "Q142", nameEn: "France" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "FX", iso1A3: "FXX", iso1N3: "249", wikidata: "Q212429", nameEn: "Metropolitan France", country: "FR", groups: ["EU", "155", "150", "UN"], isoStatus: "excRes", callingCodes: ["33"] }, geometry: { type: "MultiPolygon", coordinates: [[[[2.55904, 51.07014], [2.18458, 51.52087], [1.17405, 50.74239], [-2.02963, 49.91866], [-2.09454, 49.46288], [-1.83944, 49.23037], [-2.00491, 48.86706], [-2.65349, 49.15373], [-6.28985, 48.93406], [-1.81005, 43.59738], [-1.77289, 43.38957], [-1.79319, 43.37497], [-1.78332, 43.36399], [-1.78714, 43.35476], [-1.77068, 43.34396], [-1.75334, 43.34107], [-1.75079, 43.3317], [-1.7397, 43.32979], [-1.73074, 43.29481], [-1.69407, 43.31378], [-1.62481, 43.30726], [-1.63052, 43.28591], [-1.61341, 43.25269], [-1.57674, 43.25269], [-1.55963, 43.28828], [-1.50992, 43.29481], [-1.45289, 43.27049], [-1.40942, 43.27272], [-1.3758, 43.24511], [-1.41562, 43.12815], [-1.47555, 43.08372], [-1.44067, 43.047], [-1.35272, 43.02658], [-1.34419, 43.09665], [-1.32209, 43.1127], [-1.27118, 43.11961], [-1.30052, 43.09581], [-1.30531, 43.06859], [-1.25244, 43.04164], [-1.22881, 43.05534], [-1.10333, 43.0059], [-1.00963, 42.99279], [-0.97133, 42.96239], [-0.81652, 42.95166], [-0.75478, 42.96916], [-0.72037, 42.92541], [-0.73422, 42.91228], [-0.72608, 42.89318], [-0.69837, 42.87945], [-0.67637, 42.88303], [-0.55497, 42.77846], [-0.50863, 42.82713], [-0.44334, 42.79939], [-0.41319, 42.80776], [-0.38833, 42.80132], [-0.3122, 42.84788], [-0.17939, 42.78974], [-0.16141, 42.79535], [-0.10519, 42.72761], [-0.02468, 42.68513], [0.17569, 42.73424], [0.25336, 42.7174], [0.29407, 42.67431], [0.36251, 42.72282], [0.40214, 42.69779], [0.67873, 42.69458], [0.65421, 42.75872], [0.66121, 42.84021], [0.711, 42.86372], [0.93089, 42.79154], [0.96166, 42.80629], [0.98292, 42.78754], [1.0804, 42.78569], [1.15928, 42.71407], [1.35562, 42.71944], [1.44197, 42.60217], [1.47986, 42.61346], [1.46718, 42.63296], [1.48043, 42.65203], [1.50867, 42.64483], [1.55418, 42.65669], [1.60085, 42.62703], [1.63485, 42.62957], [1.6625, 42.61982], [1.68267, 42.62533], [1.73452, 42.61515], [1.72588, 42.59098], [1.7858, 42.57698], [1.73683, 42.55492], [1.72515, 42.50338], [1.76335, 42.48863], [1.83037, 42.48395], [1.88853, 42.4501], [1.93663, 42.45439], [1.94292, 42.44316], [1.94061, 42.43333], [1.94084, 42.43039], [1.9574, 42.42401], [1.96482, 42.37787], [2.00488, 42.35399], [2.06241, 42.35906], [2.11621, 42.38393], [2.12789, 42.41291], [2.16599, 42.42314], [2.20578, 42.41633], [2.25551, 42.43757], [2.38504, 42.39977], [2.43299, 42.39423], [2.43508, 42.37568], [2.48457, 42.33933], [2.54382, 42.33406], [2.55516, 42.35351], [2.57934, 42.35808], [2.6747, 42.33974], [2.65311, 42.38771], [2.72056, 42.42298], [2.75497, 42.42578], [2.77464, 42.41046], [2.84335, 42.45724], [2.85675, 42.45444], [2.86983, 42.46843], [2.88413, 42.45938], [2.92107, 42.4573], [2.94283, 42.48174], [2.96518, 42.46692], [3.03734, 42.47363], [3.08167, 42.42748], [3.10027, 42.42621], [3.11379, 42.43646], [3.17156, 42.43545], [3.75438, 42.33445], [7.60802, 41.05927], [10.09675, 41.44089], [9.56115, 43.20816], [7.50102, 43.51859], [7.42422, 43.72209], [7.40903, 43.7296], [7.41113, 43.73156], [7.41291, 43.73168], [7.41298, 43.73311], [7.41233, 43.73439], [7.42062, 43.73977], [7.42299, 43.74176], [7.42443, 43.74087], [7.42809, 43.74396], [7.43013, 43.74895], [7.43624, 43.75014], [7.43708, 43.75197], [7.4389, 43.75151], [7.4379, 43.74963], [7.47823, 43.73341], [7.53006, 43.78405], [7.50423, 43.84345], [7.49355, 43.86551], [7.51162, 43.88301], [7.56075, 43.89932], [7.56858, 43.94506], [7.60771, 43.95772], [7.65266, 43.9763], [7.66848, 43.99943], [7.6597, 44.03009], [7.72508, 44.07578], [7.66878, 44.12795], [7.68694, 44.17487], [7.63245, 44.17877], [7.62155, 44.14881], [7.36364, 44.11882], [7.34547, 44.14359], [7.27827, 44.1462], [7.16929, 44.20352], [7.00764, 44.23736], [6.98221, 44.28289], [6.89171, 44.36637], [6.88784, 44.42043], [6.94504, 44.43112], [6.86233, 44.49834], [6.85507, 44.53072], [6.96042, 44.62129], [6.95133, 44.66264], [7.00582, 44.69364], [7.07484, 44.68073], [7.00401, 44.78782], [7.02217, 44.82519], [6.93499, 44.8664], [6.90774, 44.84322], [6.75518, 44.89915], [6.74519, 44.93661], [6.74791, 45.01939], [6.66981, 45.02324], [6.62803, 45.11175], [6.7697, 45.16044], [6.85144, 45.13226], [6.96706, 45.20841], [7.07074, 45.21228], [7.13115, 45.25386], [7.10572, 45.32924], [7.18019, 45.40071], [7.00037, 45.509], [6.98948, 45.63869], [6.80785, 45.71864], [6.80785, 45.83265], [6.95315, 45.85163], [7.04151, 45.92435], [7.00946, 45.9944], [6.93862, 46.06502], [6.87868, 46.03855], [6.89321, 46.12548], [6.78968, 46.14058], [6.86052, 46.28512], [6.77152, 46.34784], [6.8024, 46.39171], [6.82312, 46.42661], [6.53358, 46.45431], [6.25432, 46.3632], [6.21981, 46.31304], [6.24826, 46.30175], [6.25137, 46.29014], [6.23775, 46.27822], [6.24952, 46.26255], [6.26749, 46.24745], [6.29474, 46.26221], [6.31041, 46.24417], [6.29663, 46.22688], [6.27694, 46.21566], [6.26007, 46.21165], [6.24821, 46.20531], [6.23913, 46.20511], [6.23544, 46.20714], [6.22175, 46.20045], [6.22222, 46.19888], [6.21844, 46.19837], [6.21603, 46.19507], [6.21273, 46.19409], [6.21114, 46.1927], [6.20539, 46.19163], [6.19807, 46.18369], [6.19552, 46.18401], [6.18707, 46.17999], [6.18871, 46.16644], [6.18116, 46.16187], [6.15305, 46.15194], [6.13397, 46.1406], [6.09926, 46.14373], [6.09199, 46.15191], [6.07491, 46.14879], [6.05203, 46.15191], [6.04564, 46.14031], [6.03614, 46.13712], [6.01791, 46.14228], [5.9871, 46.14499], [5.97893, 46.13303], [5.95781, 46.12925], [5.9641, 46.14412], [5.97508, 46.15863], [5.98188, 46.17392], [5.98846, 46.17046], [5.99573, 46.18587], [5.96515, 46.19638], [5.97542, 46.21525], [6.02461, 46.23313], [6.03342, 46.2383], [6.04602, 46.23127], [6.05029, 46.23518], [6.0633, 46.24583], [6.07072, 46.24085], [6.08563, 46.24651], [6.10071, 46.23772], [6.12446, 46.25059], [6.11926, 46.2634], [6.1013, 46.28512], [6.11697, 46.29547], [6.1198, 46.31157], [6.13876, 46.33844], [6.15738, 46.3491], [6.16987, 46.36759], [6.15985, 46.37721], [6.15016, 46.3778], [6.09926, 46.40768], [6.06407, 46.41676], [6.08427, 46.44305], [6.07269, 46.46244], [6.1567, 46.54402], [6.11084, 46.57649], [6.27135, 46.68251], [6.38351, 46.73171], [6.45209, 46.77502], [6.43216, 46.80336], [6.46456, 46.88865], [6.43341, 46.92703], [6.71531, 47.0494], [6.68823, 47.06616], [6.76788, 47.1208], [6.8489, 47.15933], [6.9508, 47.24338], [6.95108, 47.26428], [6.94316, 47.28747], [7.05305, 47.33304], [7.0564, 47.35134], [7.03125, 47.36996], [6.87959, 47.35335], [6.88542, 47.37262], [6.93744, 47.40714], [6.93953, 47.43388], [7.0024, 47.45264], [6.98425, 47.49432], [7.0231, 47.50522], [7.07425, 47.48863], [7.12781, 47.50371], [7.16249, 47.49025], [7.19583, 47.49455], [7.17026, 47.44312], [7.24669, 47.4205], [7.33526, 47.44186], [7.35603, 47.43432], [7.40308, 47.43638], [7.43088, 47.45846], [7.4462, 47.46264], [7.4583, 47.47216], [7.42923, 47.48628], [7.43356, 47.49712], [7.47534, 47.47932], [7.51076, 47.49651], [7.49804, 47.51798], [7.5229, 47.51644], [7.53199, 47.5284], [7.51904, 47.53515], [7.50588, 47.52856], [7.49691, 47.53821], [7.50873, 47.54546], [7.51723, 47.54578], [7.52831, 47.55347], [7.53634, 47.55553], [7.55652, 47.56779], [7.55689, 47.57232], [7.56548, 47.57617], [7.56684, 47.57785], [7.58386, 47.57536], [7.58945, 47.59017], [7.59301, 47.60058], [7.58851, 47.60794], [7.57423, 47.61628], [7.5591, 47.63849], [7.53384, 47.65115], [7.52067, 47.66437], [7.51915, 47.68335], [7.51266, 47.70197], [7.53722, 47.71635], [7.54761, 47.72912], [7.52921, 47.77747], [7.55673, 47.87371], [7.62302, 47.97898], [7.56966, 48.03265], [7.57137, 48.12292], [7.6648, 48.22219], [7.69022, 48.30018], [7.74562, 48.32736], [7.73109, 48.39192], [7.76833, 48.48945], [7.80647, 48.51239], [7.80167, 48.54758], [7.80057, 48.5857], [7.84098, 48.64217], [7.89002, 48.66317], [7.96812, 48.72491], [7.96994, 48.75606], [8.01534, 48.76085], [8.0326, 48.79017], [8.06802, 48.78957], [8.10253, 48.81829], [8.12813, 48.87985], [8.19989, 48.95825], [8.20031, 48.95856], [8.22604, 48.97352], [8.14189, 48.97833], [7.97783, 49.03161], [7.93641, 49.05544], [7.86386, 49.03499], [7.79557, 49.06583], [7.75948, 49.04562], [7.63618, 49.05428], [7.62575, 49.07654], [7.56416, 49.08136], [7.53012, 49.09818], [7.49172, 49.13915], [7.49473, 49.17], [7.44455, 49.16765], [7.44052, 49.18354], [7.3662, 49.17308], [7.35995, 49.14399], [7.3195, 49.14231], [7.29514, 49.11426], [7.23473, 49.12971], [7.1593, 49.1204], [7.1358, 49.1282], [7.12504, 49.14253], [7.10384, 49.13787], [7.10715, 49.15631], [7.07859, 49.15031], [7.09007, 49.13094], [7.07162, 49.1255], [7.06642, 49.11415], [7.05548, 49.11185], [7.04843, 49.11422], [7.04409, 49.12123], [7.04662, 49.13724], [7.03178, 49.15734], [7.0274, 49.17042], [7.03459, 49.19096], [7.01318, 49.19018], [6.97273, 49.2099], [6.95963, 49.203], [6.94028, 49.21641], [6.93831, 49.2223], [6.91875, 49.22261], [6.89298, 49.20863], [6.85939, 49.22376], [6.83555, 49.21249], [6.85119, 49.20038], [6.85016, 49.19354], [6.86225, 49.18185], [6.84703, 49.15734], [6.83385, 49.15162], [6.78265, 49.16793], [6.73765, 49.16375], [6.71137, 49.18808], [6.73256, 49.20486], [6.71843, 49.2208], [6.69274, 49.21661], [6.66583, 49.28065], [6.60186, 49.31055], [6.572, 49.35027], [6.58807, 49.35358], [6.60091, 49.36864], [6.533, 49.40748], [6.55404, 49.42464], [6.42432, 49.47683], [6.40274, 49.46546], [6.39168, 49.4667], [6.38352, 49.46463], [6.36778, 49.46937], [6.3687, 49.4593], [6.28818, 49.48465], [6.27875, 49.503], [6.25029, 49.50609], [6.2409, 49.51408], [6.19543, 49.50536], [6.17386, 49.50934], [6.15366, 49.50226], [6.16115, 49.49297], [6.14321, 49.48796], [6.12814, 49.49365], [6.12346, 49.4735], [6.10325, 49.4707], [6.09845, 49.46351], [6.10072, 49.45268], [6.08373, 49.45594], [6.07887, 49.46399], [6.05553, 49.46663], [6.04176, 49.44801], [6.02743, 49.44845], [6.02648, 49.45451], [5.97693, 49.45513], [5.96876, 49.49053], [5.94224, 49.49608], [5.94128, 49.50034], [5.86571, 49.50015], [5.83389, 49.52152], [5.83467, 49.52717], [5.84466, 49.53027], [5.83648, 49.5425], [5.81664, 49.53775], [5.80871, 49.5425], [5.81838, 49.54777], [5.79195, 49.55228], [5.77435, 49.56298], [5.7577, 49.55915], [5.75649, 49.54321], [5.64505, 49.55146], [5.60909, 49.51228], [5.55001, 49.52729], [5.46541, 49.49825], [5.46734, 49.52648], [5.43713, 49.5707], [5.3974, 49.61596], [5.34837, 49.62889], [5.33851, 49.61599], [5.3137, 49.61225], [5.30214, 49.63055], [5.33039, 49.6555], [5.31465, 49.66846], [5.26232, 49.69456], [5.14545, 49.70287], [5.09249, 49.76193], [4.96714, 49.79872], [4.85464, 49.78995], [4.86965, 49.82271], [4.85134, 49.86457], [4.88529, 49.9236], [4.78827, 49.95609], [4.8382, 50.06738], [4.88602, 50.15182], [4.83279, 50.15331], [4.82438, 50.16878], [4.75237, 50.11314], [4.70064, 50.09384], [4.68695, 49.99685], [4.5414, 49.96911], [4.51098, 49.94659], [4.43488, 49.94122], [4.35051, 49.95315], [4.31963, 49.97043], [4.20532, 49.95803], [4.14239, 49.98034], [4.13508, 50.01976], [4.16294, 50.04719], [4.23101, 50.06945], [4.20147, 50.13535], [4.13561, 50.13078], [4.16014, 50.19239], [4.15524, 50.21103], [4.21945, 50.25539], [4.20651, 50.27333], [4.17861, 50.27443], [4.17347, 50.28838], [4.15524, 50.2833], [4.16808, 50.25786], [4.13665, 50.25609], [4.11954, 50.30425], [4.10957, 50.30234], [4.10237, 50.31247], [4.0689, 50.3254], [4.0268, 50.35793], [3.96771, 50.34989], [3.90781, 50.32814], [3.84314, 50.35219], [3.73911, 50.34809], [3.70987, 50.3191], [3.71009, 50.30305], [3.66976, 50.34563], [3.65709, 50.36873], [3.67262, 50.38663], [3.67494, 50.40239], [3.66153, 50.45165], [3.64426, 50.46275], [3.61014, 50.49568], [3.58361, 50.49049], [3.5683, 50.50192], [3.49509, 50.48885], [3.51564, 50.5256], [3.47385, 50.53397], [3.44629, 50.51009], [3.37693, 50.49538], [3.28575, 50.52724], [3.2729, 50.60718], [3.23951, 50.6585], [3.264, 50.67668], [3.2536, 50.68977], [3.26141, 50.69151], [3.26063, 50.70086], [3.24593, 50.71389], [3.22042, 50.71019], [3.20845, 50.71662], [3.19017, 50.72569], [3.20064, 50.73547], [3.18811, 50.74025], [3.18339, 50.74981], [3.16476, 50.76843], [3.15017, 50.79031], [3.1257, 50.78603], [3.11987, 50.79188], [3.11206, 50.79416], [3.10614, 50.78303], [3.09163, 50.77717], [3.04314, 50.77674], [3.00537, 50.76588], [2.96778, 50.75242], [2.95019, 50.75138], [2.90873, 50.702], [2.91036, 50.6939], [2.90069, 50.69263], [2.88504, 50.70656], [2.87937, 50.70298], [2.86985, 50.7033], [2.8483, 50.72276], [2.81056, 50.71773], [2.71165, 50.81295], [2.63331, 50.81457], [2.59093, 50.91751], [2.63074, 50.94746], [2.57551, 51.00326], [2.55904, 51.07014]], [[1.99838, 42.44682], [1.98378, 42.44697], [1.96125, 42.45364], [1.95606, 42.45785], [1.96215, 42.47854], [1.97003, 42.48081], [1.97227, 42.48487], [1.97697, 42.48568], [1.98022, 42.49569], [1.98916, 42.49351], [1.99766, 42.4858], [1.98579, 42.47486], [1.99216, 42.46208], [2.01564, 42.45171], [1.99838, 42.44682]]]] } },
    { type: "Feature", properties: { iso1A2: "GA", iso1A3: "GAB", iso1N3: "266", wikidata: "Q1000", nameEn: "Gabon", groups: ["017", "202", "002", "UN"], callingCodes: ["241"] }, geometry: { type: "MultiPolygon", coordinates: [[[[13.29457, 2.16106], [13.28534, 2.25716], [11.37116, 2.29975], [11.3561, 2.17217], [11.35307, 1.00251], [9.79648, 1.0019], [9.75065, 1.06753], [9.66433, 1.06723], [7.24416, -0.64092], [10.75913, -4.39519], [11.12647, -3.94169], [11.22301, -3.69888], [11.48764, -3.51089], [11.57949, -3.52798], [11.68608, -3.68942], [11.87083, -3.71571], [11.92719, -3.62768], [11.8318, -3.5812], [11.96554, -3.30267], [11.70227, -3.17465], [11.70558, -3.0773], [11.80365, -3.00424], [11.64798, -2.81146], [11.5359, -2.85654], [11.64487, -2.61865], [11.57637, -2.33379], [11.74605, -2.39936], [11.96866, -2.33559], [12.04895, -2.41704], [12.47925, -2.32626], [12.44656, -1.92025], [12.61312, -1.8129], [12.82172, -1.91091], [13.02759, -2.33098], [13.47977, -2.43224], [13.75884, -2.09293], [13.92073, -2.35581], [13.85846, -2.46935], [14.10442, -2.49268], [14.23829, -2.33715], [14.16202, -2.23916], [14.23518, -2.15671], [14.25932, -1.97624], [14.41838, -1.89412], [14.52569, -0.57818], [14.41887, -0.44799], [14.2165, -0.38261], [14.06862, -0.20826], [13.90632, -0.2287], [13.88648, 0.26652], [14.10909, 0.58563], [14.26066, 0.57255], [14.48179, 0.9152], [14.25186, 1.39842], [13.89582, 1.4261], [13.15519, 1.23368], [13.25447, 1.32339], [13.13461, 1.57238], [13.29457, 2.16106]]]] } },
    { type: "Feature", properties: { iso1A2: "GB", iso1A3: "GBR", iso1N3: "826", wikidata: "Q145", ccTLD: ".uk", nameEn: "United Kingdom", aliases: ["UK"] }, geometry: null },
    { type: "Feature", properties: { iso1A2: "GD", iso1A3: "GRD", iso1N3: "308", wikidata: "Q769", nameEn: "Grenada", aliases: ["WG"], groups: ["029", "003", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", callingCodes: ["1 473"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-62.64026, 12.69984], [-61.77886, 11.36496], [-59.94058, 12.34011], [-62.64026, 12.69984]]]] } },
    { type: "Feature", properties: { iso1A2: "GE", iso1A3: "GEO", iso1N3: "268", wikidata: "Q230", nameEn: "Georgia", groups: ["145", "142", "UN"], callingCodes: ["995"] }, geometry: { type: "MultiPolygon", coordinates: [[[[46.42738, 41.91323], [45.61676, 42.20768], [45.78692, 42.48358], [45.36501, 42.55268], [45.15318, 42.70598], [44.88754, 42.74934], [44.80941, 42.61277], [44.70002, 42.74679], [44.54202, 42.75699], [43.95517, 42.55396], [43.73119, 42.62043], [43.81453, 42.74297], [43.0419, 43.02413], [43.03322, 43.08883], [42.75889, 43.19651], [42.66667, 43.13917], [42.40563, 43.23226], [41.64935, 43.22331], [40.65957, 43.56212], [40.10657, 43.57344], [40.04445, 43.47776], [40.03312, 43.44262], [40.01007, 43.42411], [40.01552, 43.42025], [40.00853, 43.40578], [40.0078, 43.38551], [39.81147, 43.06294], [40.89217, 41.72528], [41.54366, 41.52185], [41.7148, 41.4932], [41.7124, 41.47417], [41.81939, 41.43621], [41.95134, 41.52466], [42.26387, 41.49346], [42.51772, 41.43606], [42.59202, 41.58183], [42.72794, 41.59714], [42.84471, 41.58912], [42.78995, 41.50126], [42.84899, 41.47265], [42.8785, 41.50516], [43.02956, 41.37891], [43.21707, 41.30331], [43.13373, 41.25503], [43.1945, 41.25242], [43.23096, 41.17536], [43.36118, 41.2028], [43.44973, 41.17666], [43.4717, 41.12611], [43.67712, 41.13398], [43.74717, 41.1117], [43.84835, 41.16329], [44.16591, 41.19141], [44.18148, 41.24644], [44.32139, 41.2079], [44.34337, 41.20312], [44.34417, 41.2382], [44.46791, 41.18204], [44.59322, 41.1933], [44.61462, 41.24018], [44.72814, 41.20338], [44.82084, 41.21513], [44.87887, 41.20195], [44.89911, 41.21366], [44.84358, 41.23088], [44.81749, 41.23488], [44.80053, 41.25949], [44.81437, 41.30371], [44.93493, 41.25685], [45.0133, 41.29747], [45.09867, 41.34065], [45.1797, 41.42231], [45.26285, 41.46433], [45.31352, 41.47168], [45.4006, 41.42402], [45.45973, 41.45898], [45.68389, 41.3539], [45.71035, 41.36208], [45.75705, 41.35157], [45.69946, 41.29545], [45.80842, 41.2229], [45.95786, 41.17956], [46.13221, 41.19479], [46.27698, 41.19011], [46.37661, 41.10805], [46.456, 41.09984], [46.48558, 41.0576], [46.55096, 41.1104], [46.63969, 41.09515], [46.66148, 41.20533], [46.72375, 41.28609], [46.63658, 41.37727], [46.4669, 41.43331], [46.40307, 41.48464], [46.33925, 41.4963], [46.29794, 41.5724], [46.34126, 41.57454], [46.34039, 41.5947], [46.3253, 41.60912], [46.28182, 41.60089], [46.26531, 41.63339], [46.24429, 41.59883], [46.19759, 41.62327], [46.17891, 41.72094], [46.20538, 41.77205], [46.23962, 41.75811], [46.30863, 41.79133], [46.3984, 41.84399], [46.42738, 41.91323]]]] } },
    { type: "Feature", properties: { iso1A2: "GF", iso1A3: "GUF", iso1N3: "254", wikidata: "Q3769", nameEn: "French Guiana", country: "FR", groups: ["Q3320166", "EU", "005", "419", "019", "UN"], callingCodes: ["594"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-51.35485, 4.8383], [-53.7094, 6.2264], [-54.01074, 5.68785], [-54.01877, 5.52789], [-54.26916, 5.26909], [-54.4717, 4.91964], [-54.38444, 4.13222], [-54.19367, 3.84387], [-54.05128, 3.63557], [-53.98914, 3.627], [-53.9849, 3.58697], [-54.28534, 2.67798], [-54.42864, 2.42442], [-54.6084, 2.32856], [-54.16286, 2.10779], [-53.78743, 2.34412], [-52.96539, 2.1881], [-52.6906, 2.37298], [-52.31787, 3.17896], [-51.85573, 3.83427], [-51.82312, 3.85825], [-51.79599, 3.89336], [-51.61983, 4.14596], [-51.63798, 4.51394], [-51.35485, 4.8383]]]] } },
    { type: "Feature", properties: { iso1A2: "GG", iso1A3: "GGY", iso1N3: "831", wikidata: "Q25230", nameEn: "Bailiwick of Guernsey", country: "GB" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "GH", iso1A3: "GHA", iso1N3: "288", wikidata: "Q117", nameEn: "Ghana", groups: ["011", "202", "002", "UN"], callingCodes: ["233"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-0.13493, 11.14075], [-0.27374, 11.17157], [-0.28566, 11.12713], [-0.35955, 11.07801], [-0.38219, 11.12596], [-0.42391, 11.11661], [-0.44298, 11.04292], [-0.61937, 10.91305], [-0.67143, 10.99811], [-2.83373, 11.0067], [-2.94232, 10.64281], [-2.83108, 10.40252], [-2.74174, 9.83172], [-2.76534, 9.56589], [-2.68802, 9.49343], [-2.69814, 9.22717], [-2.77799, 9.04949], [-2.66357, 9.01771], [-2.58243, 8.7789], [-2.49037, 8.20872], [-2.62901, 8.11495], [-2.61232, 8.02645], [-2.67787, 8.02055], [-2.74819, 7.92613], [-2.78395, 7.94974], [-2.79467, 7.86002], [-2.92339, 7.60847], [-2.97822, 7.27165], [-2.95438, 7.23737], [-3.23327, 6.81744], [-3.21954, 6.74407], [-3.25999, 6.62521], [-3.01896, 5.71697], [-2.95323, 5.71865], [-2.96671, 5.6415], [-2.93132, 5.62137], [-2.85378, 5.65156], [-2.76614, 5.60963], [-2.72737, 5.34789], [-2.77625, 5.34621], [-2.73074, 5.1364], [-2.75502, 5.10657], [-2.95261, 5.12477], [-2.96554, 5.10397], [-3.063, 5.13665], [-3.11073, 5.12675], [-3.10675, 5.08515], [-3.34019, 4.17519], [1.07031, 5.15655], [1.27574, 5.93551], [1.19771, 6.11522], [1.19966, 6.17069], [1.09187, 6.17074], [1.05969, 6.22998], [1.03108, 6.24064], [0.99652, 6.33779], [0.89283, 6.33779], [0.71048, 6.53083], [0.74862, 6.56517], [0.63659, 6.63857], [0.6497, 6.73682], [0.58176, 6.76049], [0.57406, 6.80348], [0.52853, 6.82921], [0.56508, 6.92971], [0.52098, 6.94391], [0.52217, 6.9723], [0.59606, 7.01252], [0.65327, 7.31643], [0.62943, 7.41099], [0.57223, 7.39326], [0.52455, 7.45354], [0.51979, 7.58706], [0.58295, 7.62368], [0.62943, 7.85751], [0.58891, 8.12779], [0.6056, 8.13959], [0.61156, 8.18324], [0.5913, 8.19622], [0.63897, 8.25873], [0.73432, 8.29529], [0.64731, 8.48866], [0.47211, 8.59945], [0.37319, 8.75262], [0.52455, 8.87746], [0.45424, 9.04581], [0.56388, 9.40697], [0.49118, 9.48339], [0.36485, 9.49749], [0.33148, 9.44812], [0.25758, 9.42696], [0.2254, 9.47869], [0.31241, 9.50337], [0.30406, 9.521], [0.2409, 9.52335], [0.23851, 9.57389], [0.38153, 9.58682], [0.36008, 9.6256], [0.29334, 9.59387], [0.26712, 9.66437], [0.28261, 9.69022], [0.32313, 9.6491], [0.34816, 9.66907], [0.34816, 9.71607], [0.32075, 9.72781], [0.36366, 10.03309], [0.41252, 10.02018], [0.41371, 10.06361], [0.35293, 10.09412], [0.39584, 10.31112], [0.33028, 10.30408], [0.29453, 10.41546], [0.18846, 10.4096], [0.12886, 10.53149], [-0.05945, 10.63458], [-0.09141, 10.7147], [-0.07327, 10.71845], [-0.07183, 10.76794], [-0.0228, 10.81916], [-0.02685, 10.8783], [-908e-5, 10.91644], [-63e-4, 10.96417], [0.03355, 10.9807], [0.02395, 11.06229], [342e-5, 11.08317], [-514e-5, 11.10763], [-0.0275, 11.11202], [-0.05733, 11.08628], [-0.14462, 11.10811], [-0.13493, 11.14075]]]] } },
    { type: "Feature", properties: { iso1A2: "GI", iso1A3: "GIB", iso1N3: "292", wikidata: "Q1410", nameEn: "Gibraltar", country: "GB", groups: ["Q12837", "BOTS", "039", "150", "UN"], callingCodes: ["350"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-5.34064, 36.03744], [-5.27801, 36.14942], [-5.33822, 36.15272], [-5.34536, 36.15501], [-5.40526, 36.15488], [-5.34064, 36.03744]]]] } },
    { type: "Feature", properties: { iso1A2: "GL", iso1A3: "GRL", iso1N3: "304", wikidata: "Q223", nameEn: "Greenland", country: "DK", groups: ["Q1451600", "021", "003", "019", "UN"], callingCodes: ["299"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-49.33696, 84.57952], [-68.21821, 80.48551], [-77.52957, 77.23408], [-46.37635, 57.3249], [-9.68082, 72.73731], [-5.7106, 84.28058], [-49.33696, 84.57952]]]] } },
    { type: "Feature", properties: { iso1A2: "GM", iso1A3: "GMB", iso1N3: "270", wikidata: "Q1005", nameEn: "The Gambia", groups: ["011", "202", "002", "UN"], callingCodes: ["220"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-15.14917, 13.57989], [-14.36795, 13.23033], [-13.79409, 13.34472], [-13.8955, 13.59126], [-14.34721, 13.46578], [-14.93719, 13.80173], [-15.36504, 13.79313], [-15.47902, 13.58758], [-17.43598, 13.59273], [-17.43966, 13.04579], [-16.74676, 13.06025], [-16.69343, 13.16791], [-15.80355, 13.16729], [-15.80478, 13.34832], [-15.26908, 13.37768], [-15.14917, 13.57989]]]] } },
    { type: "Feature", properties: { iso1A2: "GN", iso1A3: "GIN", iso1N3: "324", wikidata: "Q1006", nameEn: "Guinea", groups: ["011", "202", "002", "UN"], callingCodes: ["224"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-11.37536, 12.40788], [-11.46267, 12.44559], [-11.91331, 12.42008], [-12.35415, 12.32758], [-12.87336, 12.51892], [-13.06603, 12.49342], [-13.05296, 12.64003], [-13.70523, 12.68013], [-13.7039, 12.60313], [-13.65089, 12.49515], [-13.64168, 12.42764], [-13.70851, 12.24978], [-13.92745, 12.24077], [-13.94589, 12.16869], [-13.7039, 12.00869], [-13.7039, 11.70195], [-14.09799, 11.63649], [-14.26623, 11.67486], [-14.31513, 11.60713], [-14.51173, 11.49708], [-14.66677, 11.51188], [-14.77786, 11.36323], [-14.95993, 10.99244], [-15.07174, 10.89557], [-15.96748, 10.162], [-14.36218, 8.64107], [-13.29911, 9.04245], [-13.18586, 9.0925], [-13.08953, 9.0409], [-12.94095, 9.26335], [-12.76788, 9.3133], [-12.47254, 9.86834], [-12.24262, 9.92386], [-12.12634, 9.87203], [-11.91023, 9.93927], [-11.89624, 9.99763], [-11.2118, 10.00098], [-10.6534, 9.29919], [-10.74484, 9.07998], [-10.5783, 9.06386], [-10.56197, 8.81225], [-10.47707, 8.67669], [-10.61422, 8.5314], [-10.70565, 8.29235], [-10.63934, 8.35326], [-10.54891, 8.31174], [-10.37257, 8.48941], [-10.27575, 8.48711], [-10.203, 8.47991], [-10.14579, 8.52665], [-10.05375, 8.50697], [-10.05873, 8.42578], [-9.77763, 8.54633], [-9.47415, 8.35195], [-9.50898, 8.18455], [-9.41445, 8.02448], [-9.44928, 7.9284], [-9.35724, 7.74111], [-9.37465, 7.62032], [-9.48161, 7.37122], [-9.41943, 7.41809], [-9.305, 7.42056], [-9.20798, 7.38109], [-9.18311, 7.30461], [-9.09107, 7.1985], [-8.93435, 7.2824], [-8.85724, 7.26019], [-8.8448, 7.35149], [-8.72789, 7.51429], [-8.67814, 7.69428], [-8.55874, 7.70167], [-8.55874, 7.62525], [-8.47114, 7.55676], [-8.4003, 7.6285], [-8.21374, 7.54466], [-8.09931, 7.78626], [-8.13414, 7.87991], [-8.06449, 8.04989], [-7.94695, 8.00925], [-7.99919, 8.11023], [-7.98675, 8.20134], [-8.062, 8.16071], [-8.2411, 8.24196], [-8.22991, 8.48438], [-7.92518, 8.50652], [-7.65653, 8.36873], [-7.69882, 8.66148], [-7.95503, 8.81146], [-7.92518, 8.99332], [-7.73862, 9.08422], [-7.90777, 9.20456], [-7.85056, 9.41812], [-8.03463, 9.39604], [-8.14657, 9.55062], [-8.09434, 9.86936], [-8.15652, 9.94288], [-8.11921, 10.04577], [-8.01225, 10.1021], [-7.97971, 10.17117], [-7.9578, 10.2703], [-8.10207, 10.44649], [-8.22711, 10.41722], [-8.32614, 10.69273], [-8.2667, 10.91762], [-8.35083, 11.06234], [-8.66923, 10.99397], [-8.40058, 11.37466], [-8.80854, 11.66715], [-8.94784, 12.34842], [-9.13689, 12.50875], [-9.38067, 12.48446], [-9.32097, 12.29009], [-9.63938, 12.18312], [-9.714, 12.0226], [-10.30604, 12.24634], [-10.71897, 11.91552], [-10.80355, 12.1053], [-10.99758, 12.24634], [-11.24136, 12.01286], [-11.50006, 12.17826], [-11.37536, 12.40788]]]] } },
    { type: "Feature", properties: { iso1A2: "GP", iso1A3: "GLP", iso1N3: "312", wikidata: "Q17012", nameEn: "Guadeloupe", country: "FR", groups: ["Q3320166", "EU", "029", "003", "419", "019", "UN"], callingCodes: ["590"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-60.03183, 16.1129], [-61.60296, 16.73066], [-63.00549, 15.26166], [-60.03183, 16.1129]]]] } },
    { type: "Feature", properties: { iso1A2: "GQ", iso1A3: "GNQ", iso1N3: "226", wikidata: "Q983", nameEn: "Equatorial Guinea", groups: ["017", "202", "002", "UN"], callingCodes: ["240"] }, geometry: { type: "MultiPolygon", coordinates: [[[[9.22018, 3.72052], [8.34397, 4.30689], [7.71762, 0.6674], [3.35016, -3.29031], [9.66433, 1.06723], [9.75065, 1.06753], [9.79648, 1.0019], [11.35307, 1.00251], [11.3561, 2.17217], [9.991, 2.16561], [9.90749, 2.20049], [9.89012, 2.20457], [9.84716, 2.24676], [9.83238, 2.29079], [9.83754, 2.32428], [9.82123, 2.35097], [9.81162, 2.33797], [9.22018, 3.72052]]]] } },
    { type: "Feature", properties: { iso1A2: "GR", iso1A3: "GRC", iso1N3: "300", wikidata: "Q41", nameEn: "Greece", aliases: ["EL"], groups: ["EU", "039", "150", "UN"], callingCodes: ["30"] }, geometry: { type: "MultiPolygon", coordinates: [[[[26.03489, 40.73051], [26.0754, 40.72772], [26.08638, 40.73214], [26.12495, 40.74283], [26.12854, 40.77339], [26.15685, 40.80709], [26.21351, 40.83298], [26.20856, 40.86048], [26.26169, 40.9168], [26.29441, 40.89119], [26.28623, 40.93005], [26.32259, 40.94042], [26.35894, 40.94292], [26.33297, 40.98388], [26.3606, 41.02027], [26.31928, 41.07386], [26.32259, 41.24929], [26.39861, 41.25053], [26.5209, 41.33993], [26.5837, 41.32131], [26.62997, 41.34613], [26.61767, 41.42281], [26.59742, 41.48058], [26.59196, 41.60491], [26.5209, 41.62592], [26.47958, 41.67037], [26.35957, 41.71149], [26.30255, 41.70925], [26.2654, 41.71544], [26.22888, 41.74139], [26.21325, 41.73223], [26.16841, 41.74858], [26.06148, 41.70345], [26.07083, 41.64584], [26.15146, 41.60828], [26.14328, 41.55496], [26.17951, 41.55409], [26.176, 41.50072], [26.14796, 41.47533], [26.20288, 41.43943], [26.16548, 41.42278], [26.12926, 41.35878], [25.87919, 41.30526], [25.8266, 41.34563], [25.70507, 41.29209], [25.66183, 41.31316], [25.61042, 41.30614], [25.55082, 41.31667], [25.52394, 41.2798], [25.48187, 41.28506], [25.28322, 41.23411], [25.11611, 41.34212], [24.942, 41.38685], [24.90928, 41.40876], [24.86136, 41.39298], [24.82514, 41.4035], [24.8041, 41.34913], [24.71529, 41.41928], [24.61129, 41.42278], [24.52599, 41.56808], [24.30513, 41.51297], [24.27124, 41.57682], [24.18126, 41.51735], [24.10063, 41.54796], [24.06323, 41.53222], [24.06908, 41.46132], [23.96975, 41.44118], [23.91483, 41.47971], [23.89613, 41.45257], [23.80148, 41.43943], [23.76525, 41.40175], [23.67644, 41.41139], [23.63203, 41.37632], [23.52453, 41.40262], [23.40416, 41.39999], [23.33639, 41.36317], [23.31301, 41.40525], [23.22771, 41.37106], [23.21953, 41.33773], [23.1833, 41.31755], [22.93334, 41.34104], [22.81199, 41.3398], [22.76408, 41.32225], [22.74538, 41.16321], [22.71266, 41.13945], [22.65306, 41.18168], [22.62852, 41.14385], [22.58295, 41.11568], [22.5549, 41.13065], [22.42285, 41.11921], [22.26744, 41.16409], [22.17629, 41.15969], [22.1424, 41.12449], [22.06527, 41.15617], [21.90869, 41.09191], [21.91102, 41.04786], [21.7556, 40.92525], [21.69601, 40.9429], [21.57448, 40.86076], [21.53007, 40.90759], [21.41555, 40.9173], [21.35595, 40.87578], [21.25779, 40.86165], [21.21105, 40.8855], [21.15262, 40.85546], [20.97887, 40.85475], [20.98396, 40.79109], [20.95752, 40.76982], [20.98134, 40.76046], [21.05833, 40.66586], [21.03932, 40.56299], [20.96908, 40.51526], [20.94925, 40.46625], [20.83688, 40.47882], [20.7906, 40.42726], [20.78234, 40.35803], [20.71789, 40.27739], [20.67162, 40.09433], [20.62566, 40.0897], [20.61081, 40.07866], [20.55593, 40.06524], [20.51297, 40.08168], [20.48487, 40.06271], [20.42373, 40.06777], [20.37911, 39.99058], [20.31135, 39.99438], [20.41546, 39.82832], [20.41475, 39.81437], [20.38572, 39.78516], [20.30804, 39.81563], [20.29152, 39.80421], [20.31961, 39.72799], [20.27412, 39.69884], [20.22707, 39.67459], [20.22376, 39.64532], [20.15988, 39.652], [20.12956, 39.65805], [20.05189, 39.69112], [20.00957, 39.69227], [19.98042, 39.6504], [19.92466, 39.69533], [19.97622, 39.78684], [19.95905, 39.82857], [19.0384, 40.35325], [19.20409, 39.7532], [22.5213, 33.45682], [29.73302, 35.92555], [29.69611, 36.10365], [29.61805, 36.14179], [29.61002, 36.1731], [29.48192, 36.18377], [29.30783, 36.01033], [28.23708, 36.56812], [27.95037, 36.46155], [27.89482, 36.69898], [27.46117, 36.53789], [27.24613, 36.71622], [27.45627, 36.9008], [27.20312, 36.94571], [27.14757, 37.32], [26.95583, 37.64989], [26.99377, 37.69034], [27.16428, 37.72343], [27.05537, 37.9131], [26.21136, 38.17558], [26.24183, 38.44695], [26.32173, 38.48731], [26.21136, 38.65436], [26.61814, 38.81372], [26.70773, 39.0312], [26.43357, 39.43096], [25.94257, 39.39358], [25.61285, 40.17161], [26.04292, 40.3958], [25.94795, 40.72797], [26.03489, 40.73051]]]] } },
    { type: "Feature", properties: { iso1A2: "GS", iso1A3: "SGS", iso1N3: "239", wikidata: "Q35086", nameEn: "South Georgia and South Sandwich Islands", country: "GB", groups: ["BOTS", "005", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["500"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-35.26394, -43.68272], [-53.39656, -59.87088], [-22.31757, -59.85974], [-35.26394, -43.68272]]]] } },
    { type: "Feature", properties: { iso1A2: "GT", iso1A3: "GTM", iso1N3: "320", wikidata: "Q774", nameEn: "Guatemala", groups: ["013", "003", "419", "019", "UN"], callingCodes: ["502"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-89.14985, 17.81563], [-90.98678, 17.81655], [-90.99199, 17.25192], [-91.43809, 17.25373], [-91.04436, 16.92175], [-90.69064, 16.70697], [-90.61212, 16.49832], [-90.40499, 16.40524], [-90.44567, 16.07573], [-91.73182, 16.07371], [-92.20983, 15.26077], [-92.0621, 15.07406], [-92.1454, 14.98143], [-92.1423, 14.88647], [-92.18161, 14.84147], [-92.1454, 14.6804], [-92.2261, 14.53423], [-92.37213, 14.39277], [-90.55276, 12.8866], [-90.11344, 13.73679], [-90.10505, 13.85104], [-89.88937, 14.0396], [-89.81807, 14.07073], [-89.76103, 14.02923], [-89.73251, 14.04133], [-89.75569, 14.07073], [-89.70756, 14.1537], [-89.61844, 14.21937], [-89.52397, 14.22628], [-89.50614, 14.26084], [-89.58814, 14.33165], [-89.57441, 14.41637], [-89.39028, 14.44561], [-89.34776, 14.43013], [-89.35189, 14.47553], [-89.23719, 14.58046], [-89.15653, 14.57802], [-89.13132, 14.71582], [-89.23467, 14.85596], [-89.15149, 14.97775], [-89.18048, 14.99967], [-89.15149, 15.07392], [-88.97343, 15.14039], [-88.32467, 15.63665], [-88.31459, 15.66942], [-88.24022, 15.69247], [-88.22552, 15.72294], [-88.20359, 16.03858], [-88.40779, 16.09624], [-88.95358, 15.88698], [-89.02415, 15.9063], [-89.17418, 15.90898], [-89.22683, 15.88619], [-89.15025, 17.04813], [-89.14985, 17.81563]]]] } },
    { type: "Feature", properties: { iso1A2: "GU", iso1A3: "GUM", iso1N3: "316", wikidata: "Q16635", nameEn: "Guam", aliases: ["US-GU"], country: "US", groups: ["Q1352230", "Q153732", "057", "009", "UN"], roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["1 671"] }, geometry: { type: "MultiPolygon", coordinates: [[[[146.25931, 13.85876], [143.82485, 13.92273], [144.61642, 12.82462], [146.25931, 13.85876]]]] } },
    { type: "Feature", properties: { iso1A2: "GW", iso1A3: "GNB", iso1N3: "624", wikidata: "Q1007", nameEn: "Guinea-Bissau", groups: ["011", "202", "002", "UN"], callingCodes: ["245"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-14.31513, 11.60713], [-14.26623, 11.67486], [-14.09799, 11.63649], [-13.7039, 11.70195], [-13.7039, 12.00869], [-13.94589, 12.16869], [-13.92745, 12.24077], [-13.70851, 12.24978], [-13.64168, 12.42764], [-13.65089, 12.49515], [-13.7039, 12.60313], [-13.70523, 12.68013], [-15.17582, 12.6847], [-15.67302, 12.42974], [-16.20591, 12.46157], [-16.38191, 12.36449], [-16.70562, 12.34803], [-17.4623, 11.92379], [-15.96748, 10.162], [-15.07174, 10.89557], [-14.95993, 10.99244], [-14.77786, 11.36323], [-14.66677, 11.51188], [-14.51173, 11.49708], [-14.31513, 11.60713]]]] } },
    { type: "Feature", properties: { iso1A2: "GY", iso1A3: "GUY", iso1N3: "328", wikidata: "Q734", nameEn: "Guyana", groups: ["005", "419", "019", "UN"], driveSide: "left", callingCodes: ["592"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-56.84822, 6.73257], [-59.54058, 8.6862], [-59.98508, 8.53046], [-59.85562, 8.35213], [-59.80661, 8.28906], [-59.83156, 8.23261], [-59.97059, 8.20791], [-60.02407, 8.04557], [-60.38056, 7.8302], [-60.51959, 7.83373], [-60.64793, 7.56877], [-60.71923, 7.55817], [-60.59802, 7.33194], [-60.63367, 7.25061], [-60.54098, 7.14804], [-60.44116, 7.20817], [-60.28074, 7.1162], [-60.39419, 6.94847], [-60.54873, 6.8631], [-61.13632, 6.70922], [-61.20762, 6.58174], [-61.15058, 6.19558], [-61.4041, 5.95304], [-60.73204, 5.20931], [-60.32352, 5.21299], [-60.20944, 5.28754], [-59.98129, 5.07097], [-60.04189, 4.69801], [-60.15953, 4.53456], [-59.78878, 4.45637], [-59.69361, 4.34069], [-59.73353, 4.20399], [-59.51963, 3.91951], [-59.86899, 3.57089], [-59.79769, 3.37162], [-59.99733, 2.92312], [-59.91177, 2.36759], [-59.7264, 2.27497], [-59.74066, 1.87596], [-59.25583, 1.40559], [-58.92072, 1.31293], [-58.84229, 1.17749], [-58.53571, 1.29154], [-58.4858, 1.48399], [-58.33887, 1.58014], [-58.01873, 1.51966], [-57.97336, 1.64566], [-57.77281, 1.73344], [-57.55743, 1.69605], [-57.35073, 1.98327], [-57.23981, 1.95808], [-57.09109, 2.01854], [-57.07092, 1.95304], [-56.7659, 1.89509], [-56.47045, 1.95135], [-56.55439, 2.02003], [-56.70519, 2.02964], [-57.35891, 3.32121], [-58.0307, 3.95513], [-57.8699, 4.89394], [-57.37442, 5.0208], [-57.22536, 5.15605], [-57.31629, 5.33714], [-56.84822, 6.73257]]]] } },
    { type: "Feature", properties: { iso1A2: "HK", iso1A3: "HKG", iso1N3: "344", wikidata: "Q8646", nameEn: "Hong Kong", country: "CN", groups: ["030", "142", "UN"], driveSide: "left", callingCodes: ["852"] }, geometry: { type: "MultiPolygon", coordinates: [[[[113.92195, 22.13873], [114.50148, 22.15017], [114.44998, 22.55977], [114.25154, 22.55977], [114.22888, 22.5436], [114.22185, 22.55343], [114.20655, 22.55706], [114.18338, 22.55444], [114.17247, 22.55944], [114.1597, 22.56041], [114.15123, 22.55163], [114.1482, 22.54091], [114.13823, 22.54319], [114.12665, 22.54003], [114.11656, 22.53415], [114.11181, 22.52878], [114.1034, 22.5352], [114.09692, 22.53435], [114.09048, 22.53716], [114.08606, 22.53276], [114.07817, 22.52997], [114.07267, 22.51855], [114.06272, 22.51617], [114.05729, 22.51104], [114.05438, 22.5026], [114.03113, 22.5065], [113.86771, 22.42972], [113.81621, 22.2163], [113.83338, 22.1826], [113.92195, 22.13873]]]] } },
    { type: "Feature", properties: { iso1A2: "HM", iso1A3: "HMD", iso1N3: "334", wikidata: "Q131198", nameEn: "Heard Island and McDonald Islands", country: "AU", groups: ["053", "009", "UN"], driveSide: "left" }, geometry: { type: "MultiPolygon", coordinates: [[[[71.08716, -53.87687], [75.44182, -53.99822], [72.87012, -51.48322], [71.08716, -53.87687]]]] } },
    { type: "Feature", properties: { iso1A2: "HN", iso1A3: "HND", iso1N3: "340", wikidata: "Q783", nameEn: "Honduras", groups: ["013", "003", "419", "019", "UN"], callingCodes: ["504"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-83.86109, 17.73736], [-88.20359, 16.03858], [-88.22552, 15.72294], [-88.24022, 15.69247], [-88.31459, 15.66942], [-88.32467, 15.63665], [-88.97343, 15.14039], [-89.15149, 15.07392], [-89.18048, 14.99967], [-89.15149, 14.97775], [-89.23467, 14.85596], [-89.13132, 14.71582], [-89.15653, 14.57802], [-89.23719, 14.58046], [-89.35189, 14.47553], [-89.34776, 14.43013], [-89.04187, 14.33644], [-88.94608, 14.20207], [-88.85785, 14.17763], [-88.815, 14.11652], [-88.73182, 14.10919], [-88.70661, 14.04317], [-88.49738, 13.97224], [-88.48982, 13.86458], [-88.25791, 13.91108], [-88.23018, 13.99915], [-88.07641, 13.98447], [-88.00331, 13.86948], [-87.7966, 13.91353], [-87.68821, 13.80829], [-87.73106, 13.75443], [-87.78148, 13.52906], [-87.71657, 13.50577], [-87.72115, 13.46083], [-87.73841, 13.44169], [-87.77354, 13.45767], [-87.83467, 13.44655], [-87.84675, 13.41078], [-87.80177, 13.35689], [-87.73714, 13.32715], [-87.69751, 13.25228], [-87.55124, 13.12523], [-87.37107, 12.98646], [-87.06306, 13.00892], [-87.03785, 12.98682], [-86.93197, 13.05313], [-86.93383, 13.18677], [-86.87066, 13.30641], [-86.71267, 13.30348], [-86.76812, 13.79605], [-86.35219, 13.77157], [-86.14801, 14.04317], [-86.00685, 14.08474], [-86.03458, 13.99181], [-85.75477, 13.8499], [-85.73964, 13.9698], [-85.45762, 14.11304], [-85.32149, 14.2562], [-85.18602, 14.24929], [-85.1575, 14.53934], [-84.90082, 14.80489], [-84.82596, 14.82212], [-84.70119, 14.68078], [-84.48373, 14.63249], [-84.10584, 14.76353], [-83.89551, 14.76697], [-83.62101, 14.89448], [-83.49268, 15.01158], [-83.13724, 15.00002], [-83.04763, 15.03256], [-82.06974, 14.49418], [-81.58685, 18.0025], [-83.86109, 17.73736]]]] } },
    { type: "Feature", properties: { iso1A2: "HR", iso1A3: "HRV", iso1N3: "191", wikidata: "Q224", nameEn: "Croatia", groups: ["EU", "039", "150", "UN"], callingCodes: ["385"] }, geometry: { type: "MultiPolygon", coordinates: [[[[17.6444, 42.88641], [17.5392, 42.92787], [17.70879, 42.97223], [17.64268, 43.08595], [17.46986, 43.16559], [17.286, 43.33065], [17.25579, 43.40353], [17.29699, 43.44542], [17.24411, 43.49376], [17.15828, 43.49376], [17.00585, 43.58037], [16.80736, 43.76011], [16.75316, 43.77157], [16.70922, 43.84887], [16.55472, 43.95326], [16.50528, 44.0244], [16.43629, 44.02826], [16.43662, 44.07523], [16.36864, 44.08263], [16.18688, 44.27012], [16.21346, 44.35231], [16.12969, 44.38275], [16.16814, 44.40679], [16.10566, 44.52586], [16.03012, 44.55572], [16.00884, 44.58605], [16.05828, 44.61538], [15.89348, 44.74964], [15.8255, 44.71501], [15.72584, 44.82334], [15.79472, 44.8455], [15.76096, 44.87045], [15.74723, 44.96818], [15.78568, 44.97401], [15.74585, 45.0638], [15.78842, 45.11519], [15.76371, 45.16508], [15.83512, 45.22459], [15.98412, 45.23088], [16.12153, 45.09616], [16.29036, 44.99732], [16.35404, 45.00241], [16.35863, 45.03529], [16.3749, 45.05206], [16.38219, 45.05139], [16.38309, 45.05955], [16.40023, 45.1147], [16.4634, 45.14522], [16.49155, 45.21153], [16.52982, 45.22713], [16.5501, 45.2212], [16.56559, 45.22307], [16.60194, 45.23042], [16.64962, 45.20714], [16.74845, 45.20393], [16.78219, 45.19002], [16.81137, 45.18434], [16.83804, 45.18951], [16.92405, 45.27607], [16.9385, 45.22742], [17.0415, 45.20759], [17.18438, 45.14764], [17.24325, 45.146], [17.25131, 45.14957], [17.26815, 45.18444], [17.32092, 45.16246], [17.33573, 45.14521], [17.41229, 45.13335], [17.4498, 45.16119], [17.45615, 45.12523], [17.47589, 45.12656], [17.51469, 45.10791], [17.59104, 45.10816], [17.66571, 45.13408], [17.84826, 45.04489], [17.87148, 45.04645], [17.93706, 45.08016], [17.97336, 45.12245], [17.97834, 45.13831], [17.99479, 45.14958], [18.01594, 45.15163], [18.03121, 45.12632], [18.1624, 45.07654], [18.24387, 45.13699], [18.32077, 45.1021], [18.41896, 45.11083], [18.47939, 45.05871], [18.65723, 45.07544], [18.78357, 44.97741], [18.80661, 44.93561], [18.76369, 44.93707], [18.76347, 44.90669], [18.8704, 44.85097], [19.01994, 44.85493], [18.98957, 44.90645], [19.02871, 44.92541], [19.06853, 44.89915], [19.15573, 44.95409], [19.05205, 44.97692], [19.1011, 45.01191], [19.07952, 45.14668], [19.14063, 45.12972], [19.19144, 45.17863], [19.43589, 45.17137], [19.41941, 45.23475], [19.28208, 45.23813], [19.10774, 45.29547], [18.97446, 45.37528], [18.99918, 45.49333], [19.08364, 45.48804], [19.07471, 45.53086], [18.94562, 45.53712], [18.88776, 45.57253], [18.96691, 45.66731], [18.90305, 45.71863], [18.85783, 45.85493], [18.81394, 45.91329], [18.80211, 45.87995], [18.6792, 45.92057], [18.57483, 45.80772], [18.44368, 45.73972], [18.12439, 45.78905], [18.08869, 45.76511], [17.99805, 45.79671], [17.87377, 45.78522], [17.66545, 45.84207], [17.56821, 45.93728], [17.35672, 45.95209], [17.14592, 46.16697], [16.8903, 46.28122], [16.8541, 46.36255], [16.7154, 46.39523], [16.6639, 46.45203], [16.59527, 46.47524], [16.52604, 46.47831], [16.5007, 46.49644], [16.44036, 46.5171], [16.38771, 46.53608], [16.37193, 46.55008], [16.29793, 46.5121], [16.26733, 46.51505], [16.26759, 46.50566], [16.23961, 46.49653], [16.25124, 46.48067], [16.27398, 46.42875], [16.27329, 46.41467], [16.30162, 46.40437], [16.30233, 46.37837], [16.18824, 46.38282], [16.14859, 46.40547], [16.05281, 46.39141], [16.05065, 46.3833], [16.07314, 46.36458], [16.07616, 46.3463], [15.97965, 46.30652], [15.79284, 46.25811], [15.78817, 46.21719], [15.75479, 46.20336], [15.75436, 46.21969], [15.67395, 46.22478], [15.6434, 46.21396], [15.64904, 46.19229], [15.59909, 46.14761], [15.6083, 46.11992], [15.62317, 46.09103], [15.72977, 46.04682], [15.71246, 46.01196], [15.70327, 46.00015], [15.70636, 45.92116], [15.67967, 45.90455], [15.68383, 45.88867], [15.68232, 45.86819], [15.70411, 45.8465], [15.66662, 45.84085], [15.64185, 45.82915], [15.57952, 45.84953], [15.52234, 45.82195], [15.47325, 45.8253], [15.47531, 45.79802], [15.40836, 45.79491], [15.25423, 45.72275], [15.30872, 45.69014], [15.34919, 45.71623], [15.4057, 45.64727], [15.38952, 45.63682], [15.34214, 45.64702], [15.34695, 45.63382], [15.31027, 45.6303], [15.27747, 45.60504], [15.29837, 45.5841], [15.30249, 45.53224], [15.38188, 45.48752], [15.33051, 45.45258], [15.27758, 45.46678], [15.16862, 45.42309], [15.05187, 45.49079], [15.02385, 45.48533], [14.92266, 45.52788], [14.90554, 45.47769], [14.81992, 45.45913], [14.80124, 45.49515], [14.71718, 45.53442], [14.68605, 45.53006], [14.69694, 45.57366], [14.59576, 45.62812], [14.60977, 45.66403], [14.57397, 45.67165], [14.53816, 45.6205], [14.5008, 45.60852], [14.49769, 45.54424], [14.36693, 45.48642], [14.32487, 45.47142], [14.27681, 45.4902], [14.26611, 45.48239], [14.24239, 45.50607], [14.22371, 45.50388], [14.20348, 45.46896], [14.07116, 45.48752], [14.00578, 45.52352], [13.96063, 45.50825], [13.99488, 45.47551], [13.97309, 45.45258], [13.90771, 45.45149], [13.88124, 45.42637], [13.81742, 45.43729], [13.7785, 45.46787], [13.67398, 45.4436], [13.62902, 45.45898], [13.56979, 45.4895], [13.45644, 45.59464], [13.05142, 45.33128], [13.12821, 44.48877], [16.15283, 42.18525], [18.45131, 42.21682], [18.54128, 42.39171], [18.52152, 42.42302], [18.43588, 42.48556], [18.44307, 42.51077], [18.43735, 42.55921], [18.36197, 42.61423], [18.24318, 42.6112], [17.88201, 42.83668], [17.80854, 42.9182], [17.7948, 42.89556], [17.68151, 42.92725], [17.6444, 42.88641]]]] } },
    { type: "Feature", properties: { iso1A2: "HT", iso1A3: "HTI", iso1N3: "332", wikidata: "Q790", nameEn: "Haiti", aliases: ["RH"], groups: ["029", "003", "419", "019", "UN"], callingCodes: ["509"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-71.71885, 18.78423], [-71.72624, 18.87802], [-71.77766, 18.95007], [-71.88102, 18.95007], [-71.74088, 19.0437], [-71.71088, 19.08353], [-71.69938, 19.10916], [-71.65337, 19.11759], [-71.62642, 19.21212], [-71.73229, 19.26686], [-71.77766, 19.33823], [-71.69448, 19.37866], [-71.6802, 19.45008], [-71.71268, 19.53374], [-71.71449, 19.55364], [-71.7429, 19.58445], [-71.75865, 19.70231], [-71.77419, 19.73128], [-72.38946, 20.27111], [-73.37289, 20.43199], [-74.7289, 18.71009], [-74.76465, 18.06252], [-72.29523, 17.48026], [-71.75671, 18.03456], [-71.73783, 18.07177], [-71.74994, 18.11115], [-71.75465, 18.14405], [-71.78271, 18.18302], [-71.69952, 18.34101], [-71.90875, 18.45821], [-71.88102, 18.50125], [-72.00201, 18.62312], [-71.95412, 18.64939], [-71.82556, 18.62551], [-71.71885, 18.78423]]]] } },
    { type: "Feature", properties: { iso1A2: "HU", iso1A3: "HUN", iso1N3: "348", wikidata: "Q28", nameEn: "Hungary", groups: ["EU", "151", "150", "UN"], callingCodes: ["36"] }, geometry: { type: "MultiPolygon", coordinates: [[[[21.72525, 48.34628], [21.67134, 48.3989], [21.6068, 48.50365], [21.44063, 48.58456], [21.11516, 48.49546], [20.83248, 48.5824], [20.5215, 48.53336], [20.29943, 48.26104], [20.24312, 48.2784], [19.92452, 48.1283], [19.63338, 48.25006], [19.52489, 48.19791], [19.47957, 48.09437], [19.28182, 48.08336], [19.23924, 48.0595], [19.01952, 48.07052], [18.82176, 48.04206], [18.76134, 47.97499], [18.76821, 47.87469], [18.8506, 47.82308], [18.74074, 47.8157], [18.66521, 47.76772], [18.56496, 47.76588], [18.29305, 47.73541], [18.02938, 47.75665], [17.71215, 47.7548], [17.23699, 48.02094], [17.16001, 48.00636], [17.09786, 47.97336], [17.11022, 47.92461], [17.08275, 47.87719], [17.00997, 47.86245], [17.07039, 47.81129], [17.05048, 47.79377], [17.08893, 47.70928], [16.87538, 47.68895], [16.86509, 47.72268], [16.82938, 47.68432], [16.7511, 47.67878], [16.72089, 47.73469], [16.65679, 47.74197], [16.61183, 47.76171], [16.54779, 47.75074], [16.53514, 47.73837], [16.55129, 47.72268], [16.4222, 47.66537], [16.58699, 47.61772], [16.64193, 47.63114], [16.71059, 47.52692], [16.64821, 47.50155], [16.6718, 47.46139], [16.57152, 47.40868], [16.52414, 47.41007], [16.49908, 47.39416], [16.45104, 47.41181], [16.47782, 47.25918], [16.44142, 47.25079], [16.43663, 47.21127], [16.41739, 47.20649], [16.42801, 47.18422], [16.4523, 47.18812], [16.46442, 47.16845], [16.44932, 47.14418], [16.52863, 47.13974], [16.46134, 47.09395], [16.52176, 47.05747], [16.43936, 47.03548], [16.51369, 47.00084], [16.28202, 47.00159], [16.27594, 46.9643], [16.22403, 46.939], [16.19904, 46.94134], [16.10983, 46.867], [16.14365, 46.8547], [16.15711, 46.85434], [16.21892, 46.86961], [16.2365, 46.87775], [16.2941, 46.87137], [16.34547, 46.83836], [16.3408, 46.80641], [16.31303, 46.79838], [16.30966, 46.7787], [16.37816, 46.69975], [16.42641, 46.69228], [16.41863, 46.66238], [16.38594, 46.6549], [16.39217, 46.63673], [16.50139, 46.56684], [16.52885, 46.53303], [16.52604, 46.5051], [16.59527, 46.47524], [16.6639, 46.45203], [16.7154, 46.39523], [16.8541, 46.36255], [16.8903, 46.28122], [17.14592, 46.16697], [17.35672, 45.95209], [17.56821, 45.93728], [17.66545, 45.84207], [17.87377, 45.78522], [17.99805, 45.79671], [18.08869, 45.76511], [18.12439, 45.78905], [18.44368, 45.73972], [18.57483, 45.80772], [18.6792, 45.92057], [18.80211, 45.87995], [18.81394, 45.91329], [18.99712, 45.93537], [19.01284, 45.96529], [19.0791, 45.96458], [19.10388, 46.04015], [19.14543, 45.9998], [19.28826, 45.99694], [19.52473, 46.1171], [19.56113, 46.16824], [19.66007, 46.19005], [19.81491, 46.1313], [19.93508, 46.17553], [20.01816, 46.17696], [20.03533, 46.14509], [20.09713, 46.17315], [20.26068, 46.12332], [20.28324, 46.1438], [20.35573, 46.16629], [20.45377, 46.14405], [20.49718, 46.18721], [20.63863, 46.12728], [20.76085, 46.21002], [20.74574, 46.25467], [20.86797, 46.28884], [21.06572, 46.24897], [21.16872, 46.30118], [21.28061, 46.44941], [21.26929, 46.4993], [21.33214, 46.63035], [21.43926, 46.65109], [21.5151, 46.72147], [21.48935, 46.7577], [21.52028, 46.84118], [21.59307, 46.86935], [21.59581, 46.91628], [21.68645, 46.99595], [21.648, 47.03902], [21.78395, 47.11104], [21.94463, 47.38046], [22.01055, 47.37767], [22.03389, 47.42508], [22.00917, 47.50492], [22.31816, 47.76126], [22.41979, 47.7391], [22.46559, 47.76583], [22.67247, 47.7871], [22.76617, 47.8417], [22.77991, 47.87211], [22.89849, 47.95851], [22.84276, 47.98602], [22.87847, 48.04665], [22.81804, 48.11363], [22.73427, 48.12005], [22.66835, 48.09162], [22.58733, 48.10813], [22.59007, 48.15121], [22.49806, 48.25189], [22.38133, 48.23726], [22.2083, 48.42534], [22.14689, 48.4005], [21.83339, 48.36242], [21.8279, 48.33321], [21.72525, 48.34628]]]] } },
    { type: "Feature", properties: { iso1A2: "IC", wikidata: "Q5813", nameEn: "Canary Islands", country: "ES", groups: ["Q3320166", "Q105472", "EU", "039", "150", "UN"], isoStatus: "excRes", callingCodes: ["34"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-12.00985, 30.24121], [-25.3475, 27.87574], [-14.43883, 27.02969], [-12.00985, 30.24121]]]] } },
    { type: "Feature", properties: { iso1A2: "ID", iso1A3: "IDN", iso1N3: "360", wikidata: "Q252", nameEn: "Indonesia", aliases: ["RI"] }, geometry: null },
    { type: "Feature", geometry: { type: "MultiPolygon", coordinates: [[[[-6.26218, 54.09785], [-6.29003, 54.11278], [-6.32694, 54.09337], [-6.36279, 54.11248], [-6.36605, 54.07234], [-6.47849, 54.06947], [-6.62842, 54.03503], [-6.66264, 54.0666], [-6.6382, 54.17071], [-6.70175, 54.20218], [-6.74575, 54.18788], [-6.81583, 54.22791], [-6.85179, 54.29176], [-6.87775, 54.34682], [-7.02034, 54.4212], [-7.19145, 54.31296], [-7.14908, 54.22732], [-7.25012, 54.20063], [-7.26316, 54.13863], [-7.29493, 54.12013], [-7.29687, 54.1354], [-7.28017, 54.16714], [-7.29157, 54.17191], [-7.34005, 54.14698], [-7.30553, 54.11869], [-7.32834, 54.11475], [-7.44567, 54.1539], [-7.4799, 54.12239], [-7.55812, 54.12239], [-7.69501, 54.20731], [-7.81397, 54.20159], [-7.8596, 54.21779], [-7.87101, 54.29299], [-8.04555, 54.36292], [-8.179, 54.46763], [-8.04538, 54.48941], [-7.99812, 54.54427], [-7.8596, 54.53671], [-7.70315, 54.62077], [-7.93293, 54.66603], [-7.83352, 54.73854], [-7.75041, 54.7103], [-7.64449, 54.75265], [-7.54671, 54.74606], [-7.54508, 54.79401], [-7.47626, 54.83084], [-7.4473, 54.87003], [-7.44404, 54.9403], [-7.40004, 54.94498], [-7.4033, 55.00391], [-7.34464, 55.04688], [-7.2471, 55.06933], [-6.34755, 55.49206], [-7.75229, 55.93854], [-11.75, 54], [-11, 51], [-6.03913, 51.13217], [-5.37267, 53.63269], [-6.26218, 54.09785]]]] }, properties: { iso1A2: "IE", iso1A3: "IRL", iso1N3: "372", wikidata: "Q27", nameEn: "Republic of Ireland", groups: ["EU", "Q22890", "154", "150", "UN"], driveSide: "left", callingCodes: ["353"] } },
    { type: "Feature", properties: { iso1A2: "IL", iso1A3: "ISR", iso1N3: "376", wikidata: "Q801", nameEn: "Israel", groups: ["145", "142", "UN"], callingCodes: ["972"] }, geometry: { type: "MultiPolygon", coordinates: [[[[34.052, 31.46619], [34.29262, 31.70393], [34.48681, 31.59711], [34.56797, 31.54197], [34.48892, 31.48365], [34.40077, 31.40926], [34.36505, 31.36404], [34.37381, 31.30598], [34.36523, 31.28963], [34.29417, 31.24194], [34.26742, 31.21998], [34.92298, 29.45305], [34.97718, 29.54294], [34.98207, 29.58147], [35.02147, 29.66343], [35.14108, 30.07374], [35.19183, 30.34636], [35.16218, 30.43535], [35.19595, 30.50297], [35.21379, 30.60401], [35.29311, 30.71365], [35.33456, 30.81224], [35.33984, 30.8802], [35.41371, 30.95565], [35.43658, 31.12444], [35.40316, 31.25535], [35.47672, 31.49578], [35.39675, 31.49572], [35.22921, 31.37445], [35.13033, 31.3551], [35.02459, 31.35979], [34.92571, 31.34337], [34.88932, 31.37093], [34.87833, 31.39321], [34.89756, 31.43891], [34.93258, 31.47816], [34.94356, 31.50743], [34.9415, 31.55601], [34.95249, 31.59813], [35.00879, 31.65426], [35.08226, 31.69107], [35.10782, 31.71594], [35.11895, 31.71454], [35.12933, 31.7325], [35.13931, 31.73012], [35.15119, 31.73634], [35.15474, 31.73352], [35.16478, 31.73242], [35.18023, 31.72067], [35.20538, 31.72388], [35.21937, 31.71578], [35.22392, 31.71899], [35.23972, 31.70896], [35.24315, 31.71244], [35.2438, 31.7201], [35.24981, 31.72543], [35.25182, 31.73945], [35.26319, 31.74846], [35.25225, 31.7678], [35.26058, 31.79064], [35.25573, 31.81362], [35.26404, 31.82567], [35.251, 31.83085], [35.25753, 31.8387], [35.24816, 31.8458], [35.2304, 31.84222], [35.2249, 31.85433], [35.22817, 31.8638], [35.22567, 31.86745], [35.22294, 31.87889], [35.22014, 31.88264], [35.2136, 31.88241], [35.21276, 31.88153], [35.21016, 31.88237], [35.20945, 31.8815], [35.20791, 31.8821], [35.20673, 31.88151], [35.20381, 31.86716], [35.21128, 31.863], [35.216, 31.83894], [35.21469, 31.81835], [35.19461, 31.82687], [35.18169, 31.82542], [35.18603, 31.80901], [35.14174, 31.81325], [35.07677, 31.85627], [35.05617, 31.85685], [35.01978, 31.82944], [34.9724, 31.83352], [34.99712, 31.85569], [35.03489, 31.85919], [35.03978, 31.89276], [35.03489, 31.92448], [35.00124, 31.93264], [34.98682, 31.96935], [35.00261, 32.027], [34.9863, 32.09551], [34.99437, 32.10962], [34.98507, 32.12606], [34.99039, 32.14626], [34.96009, 32.17503], [34.95703, 32.19522], [34.98885, 32.20758], [35.01841, 32.23981], [35.02939, 32.2671], [35.01119, 32.28684], [35.01772, 32.33863], [35.04243, 32.35008], [35.05142, 32.3667], [35.0421, 32.38242], [35.05311, 32.4024], [35.05423, 32.41754], [35.07059, 32.4585], [35.08564, 32.46948], [35.09236, 32.47614], [35.10024, 32.47856], [35.10882, 32.4757], [35.15937, 32.50466], [35.2244, 32.55289], [35.25049, 32.52453], [35.29306, 32.50947], [35.30685, 32.51024], [35.35212, 32.52047], [35.40224, 32.50136], [35.42034, 32.46009], [35.41598, 32.45593], [35.41048, 32.43706], [35.42078, 32.41562], [35.55807, 32.38674], [35.55494, 32.42687], [35.57485, 32.48669], [35.56614, 32.64393], [35.59813, 32.65159], [35.61669, 32.67999], [35.66527, 32.681], [35.68467, 32.70715], [35.75983, 32.74803], [35.78745, 32.77938], [35.83758, 32.82817], [35.84021, 32.8725], [35.87012, 32.91976], [35.89298, 32.9456], [35.87188, 32.98028], [35.84802, 33.1031], [35.81911, 33.11077], [35.81911, 33.1336], [35.84285, 33.16673], [35.83846, 33.19397], [35.81647, 33.2028], [35.81295, 33.24841], [35.77513, 33.27342], [35.813, 33.3172], [35.77477, 33.33609], [35.62019, 33.27278], [35.62283, 33.24226], [35.58502, 33.26653], [35.58326, 33.28381], [35.56523, 33.28969], [35.55555, 33.25844], [35.54544, 33.25513], [35.54808, 33.236], [35.5362, 33.23196], [35.54228, 33.19865], [35.52573, 33.11921], [35.50335, 33.114], [35.50272, 33.09056], [35.448, 33.09264], [35.43059, 33.06659], [35.35223, 33.05617], [35.31429, 33.10515], [35.1924, 33.08743], [35.10645, 33.09318], [34.78515, 33.20368], [33.62659, 31.82938], [34.052, 31.46619]]]] } },
    { type: "Feature", properties: { iso1A2: "IM", iso1A3: "IMN", iso1N3: "833", wikidata: "Q9676", nameEn: "Isle of Man", country: "GB", groups: ["Q185086", "154", "150", "UN"], driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["44 01624", "44 07624", "44 07524", "44 07924"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-3.98763, 54.07351], [-4.1819, 54.57861], [-5.6384, 53.81157], [-3.98763, 54.07351]]]] } },
    { type: "Feature", properties: { iso1A2: "IN", iso1A3: "IND", iso1N3: "356", wikidata: "Q668", nameEn: "India" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "IO", iso1A3: "IOT", iso1N3: "086", wikidata: "Q43448", nameEn: "British Indian Ocean Territory", country: "GB" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "IQ", iso1A3: "IRQ", iso1N3: "368", wikidata: "Q796", nameEn: "Iraq", groups: ["145", "142", "UN"], callingCodes: ["964"] }, geometry: { type: "MultiPolygon", coordinates: [[[[42.78887, 37.38615], [42.56725, 37.14878], [42.35724, 37.10998], [42.36697, 37.0627], [41.81736, 36.58782], [41.40058, 36.52502], [41.28864, 36.35368], [41.2564, 36.06012], [41.37027, 35.84095], [41.38184, 35.62502], [41.26569, 35.42708], [41.21654, 35.1508], [41.2345, 34.80049], [41.12388, 34.65742], [40.97676, 34.39788], [40.64314, 34.31604], [38.79171, 33.37328], [39.08202, 32.50304], [38.98762, 32.47694], [39.04251, 32.30203], [39.26157, 32.35555], [39.29903, 32.23259], [40.01521, 32.05667], [42.97601, 30.72204], [42.97796, 30.48295], [44.72255, 29.19736], [46.42415, 29.05947], [46.5527, 29.10283], [46.89695, 29.50584], [47.15166, 30.01044], [47.37192, 30.10421], [47.7095, 30.10453], [48.01114, 29.98906], [48.06782, 30.02906], [48.17332, 30.02448], [48.40479, 29.85763], [48.59531, 29.66815], [48.83867, 29.78572], [48.61441, 29.93675], [48.51011, 29.96238], [48.44785, 30.00148], [48.4494, 30.04456], [48.43384, 30.08233], [48.38869, 30.11062], [48.38714, 30.13485], [48.41671, 30.17254], [48.41117, 30.19846], [48.26393, 30.3408], [48.24385, 30.33846], [48.21279, 30.31644], [48.19425, 30.32796], [48.18321, 30.39703], [48.14585, 30.44133], [48.02443, 30.4789], [48.03221, 30.9967], [47.68219, 31.00004], [47.6804, 31.39086], [47.86337, 31.78422], [47.64771, 32.07666], [47.52474, 32.15972], [47.57144, 32.20583], [47.37529, 32.47808], [47.17218, 32.45393], [46.46788, 32.91992], [46.32298, 32.9731], [46.17198, 32.95612], [46.09103, 32.98354], [46.15175, 33.07229], [46.03966, 33.09577], [46.05367, 33.13097], [46.11905, 33.11924], [46.20623, 33.20395], [45.99919, 33.5082], [45.86687, 33.49263], [45.96183, 33.55751], [45.89801, 33.63661], [45.77814, 33.60938], [45.50261, 33.94968], [45.42789, 33.9458], [45.41077, 33.97421], [45.47264, 34.03099], [45.56176, 34.15088], [45.58667, 34.30147], [45.53552, 34.35148], [45.49171, 34.3439], [45.46697, 34.38221], [45.43879, 34.45949], [45.51883, 34.47692], [45.53219, 34.60441], [45.59074, 34.55558], [45.60224, 34.55057], [45.73923, 34.54416], [45.70031, 34.69277], [45.65672, 34.7222], [45.68284, 34.76624], [45.70031, 34.82322], [45.73641, 34.83975], [45.79682, 34.85133], [45.78904, 34.91135], [45.86532, 34.89858], [45.89477, 34.95805], [45.87864, 35.03441], [45.92173, 35.0465], [45.92203, 35.09538], [45.93108, 35.08148], [45.94756, 35.09188], [46.06508, 35.03699], [46.07747, 35.0838], [46.11763, 35.07551], [46.19116, 35.11097], [46.15642, 35.1268], [46.16229, 35.16984], [46.19738, 35.18536], [46.18457, 35.22561], [46.11367, 35.23729], [46.15474, 35.2883], [46.13152, 35.32548], [46.05358, 35.38568], [45.98453, 35.49848], [46.01518, 35.52012], [45.97584, 35.58132], [46.03028, 35.57416], [46.01307, 35.59756], [46.0165, 35.61501], [45.99452, 35.63574], [46.0117, 35.65059], [46.01631, 35.69139], [46.23736, 35.71414], [46.34166, 35.78363], [46.32921, 35.82655], [46.17198, 35.8013], [46.08325, 35.8581], [45.94711, 35.82218], [45.89784, 35.83708], [45.81442, 35.82107], [45.76145, 35.79898], [45.6645, 35.92872], [45.60018, 35.96069], [45.55245, 35.99943], [45.46594, 36.00042], [45.38275, 35.97156], [45.33916, 35.99424], [45.37652, 36.06222], [45.37312, 36.09917], [45.32235, 36.17383], [45.30038, 36.27769], [45.26261, 36.3001], [45.27394, 36.35846], [45.23953, 36.43257], [45.11811, 36.40751], [45.00759, 36.5402], [45.06985, 36.62645], [45.06985, 36.6814], [45.01537, 36.75128], [44.84725, 36.77622], [44.83479, 36.81362], [44.90173, 36.86096], [44.91199, 36.91468], [44.89862, 37.01897], [44.81611, 37.04383], [44.75229, 37.11958], [44.78319, 37.1431], [44.76698, 37.16162], [44.63179, 37.19229], [44.42631, 37.05825], [44.38117, 37.05825], [44.35315, 37.04955], [44.35937, 37.02843], [44.30645, 36.97373], [44.25975, 36.98119], [44.18503, 37.09551], [44.22239, 37.15756], [44.27998, 37.16501], [44.2613, 37.25055], [44.13521, 37.32486], [44.02002, 37.33229], [43.90949, 37.22453], [43.84878, 37.22205], [43.82699, 37.19477], [43.8052, 37.22825], [43.7009, 37.23692], [43.63085, 37.21957], [43.56702, 37.25675], [43.50787, 37.24436], [43.33508, 37.33105], [43.30083, 37.30629], [43.11403, 37.37436], [42.93705, 37.32015], [42.78887, 37.38615]]]] } },
    { type: "Feature", properties: { iso1A2: "IR", iso1A3: "IRN", iso1N3: "364", wikidata: "Q794", nameEn: "Iran", groups: ["034", "142", "UN"], callingCodes: ["98"] }, geometry: { type: "MultiPolygon", coordinates: [[[[44.96746, 39.42998], [44.88916, 39.59653], [44.81043, 39.62677], [44.71806, 39.71124], [44.65422, 39.72163], [44.6137, 39.78393], [44.47298, 39.68788], [44.48111, 39.61579], [44.41849, 39.56659], [44.42832, 39.4131], [44.37921, 39.4131], [44.29818, 39.378], [44.22452, 39.4169], [44.03667, 39.39223], [44.1043, 39.19842], [44.20946, 39.13975], [44.18863, 38.93881], [44.30322, 38.81581], [44.26155, 38.71427], [44.28065, 38.6465], [44.32058, 38.62752], [44.3207, 38.49799], [44.3119, 38.37887], [44.38309, 38.36117], [44.44386, 38.38295], [44.50115, 38.33939], [44.42476, 38.25763], [44.22509, 37.88859], [44.3883, 37.85433], [44.45948, 37.77065], [44.55498, 37.783], [44.62096, 37.71985], [44.56887, 37.6429], [44.61401, 37.60165], [44.58449, 37.45018], [44.81021, 37.2915], [44.75986, 37.21549], [44.7868, 37.16644], [44.78319, 37.1431], [44.75229, 37.11958], [44.81611, 37.04383], [44.89862, 37.01897], [44.91199, 36.91468], [44.90173, 36.86096], [44.83479, 36.81362], [44.84725, 36.77622], [45.01537, 36.75128], [45.06985, 36.6814], [45.06985, 36.62645], [45.00759, 36.5402], [45.11811, 36.40751], [45.23953, 36.43257], [45.27394, 36.35846], [45.26261, 36.3001], [45.30038, 36.27769], [45.32235, 36.17383], [45.37312, 36.09917], [45.37652, 36.06222], [45.33916, 35.99424], [45.38275, 35.97156], [45.46594, 36.00042], [45.55245, 35.99943], [45.60018, 35.96069], [45.6645, 35.92872], [45.76145, 35.79898], [45.81442, 35.82107], [45.89784, 35.83708], [45.94711, 35.82218], [46.08325, 35.8581], [46.17198, 35.8013], [46.32921, 35.82655], [46.34166, 35.78363], [46.23736, 35.71414], [46.01631, 35.69139], [46.0117, 35.65059], [45.99452, 35.63574], [46.0165, 35.61501], [46.01307, 35.59756], [46.03028, 35.57416], [45.97584, 35.58132], [46.01518, 35.52012], [45.98453, 35.49848], [46.05358, 35.38568], [46.13152, 35.32548], [46.15474, 35.2883], [46.11367, 35.23729], [46.18457, 35.22561], [46.19738, 35.18536], [46.16229, 35.16984], [46.15642, 35.1268], [46.19116, 35.11097], [46.11763, 35.07551], [46.07747, 35.0838], [46.06508, 35.03699], [45.94756, 35.09188], [45.93108, 35.08148], [45.92203, 35.09538], [45.92173, 35.0465], [45.87864, 35.03441], [45.89477, 34.95805], [45.86532, 34.89858], [45.78904, 34.91135], [45.79682, 34.85133], [45.73641, 34.83975], [45.70031, 34.82322], [45.68284, 34.76624], [45.65672, 34.7222], [45.70031, 34.69277], [45.73923, 34.54416], [45.60224, 34.55057], [45.59074, 34.55558], [45.53219, 34.60441], [45.51883, 34.47692], [45.43879, 34.45949], [45.46697, 34.38221], [45.49171, 34.3439], [45.53552, 34.35148], [45.58667, 34.30147], [45.56176, 34.15088], [45.47264, 34.03099], [45.41077, 33.97421], [45.42789, 33.9458], [45.50261, 33.94968], [45.77814, 33.60938], [45.89801, 33.63661], [45.96183, 33.55751], [45.86687, 33.49263], [45.99919, 33.5082], [46.20623, 33.20395], [46.11905, 33.11924], [46.05367, 33.13097], [46.03966, 33.09577], [46.15175, 33.07229], [46.09103, 32.98354], [46.17198, 32.95612], [46.32298, 32.9731], [46.46788, 32.91992], [47.17218, 32.45393], [47.37529, 32.47808], [47.57144, 32.20583], [47.52474, 32.15972], [47.64771, 32.07666], [47.86337, 31.78422], [47.6804, 31.39086], [47.68219, 31.00004], [48.03221, 30.9967], [48.02443, 30.4789], [48.14585, 30.44133], [48.18321, 30.39703], [48.19425, 30.32796], [48.21279, 30.31644], [48.24385, 30.33846], [48.26393, 30.3408], [48.41117, 30.19846], [48.41671, 30.17254], [48.38714, 30.13485], [48.38869, 30.11062], [48.43384, 30.08233], [48.4494, 30.04456], [48.44785, 30.00148], [48.51011, 29.96238], [48.61441, 29.93675], [48.83867, 29.78572], [49.98877, 27.87827], [50.37726, 27.89227], [54.39838, 25.68383], [55.14145, 25.62624], [55.81777, 26.18798], [56.2644, 26.58649], [56.68954, 26.76645], [56.79239, 26.41236], [56.82555, 25.7713], [56.86325, 25.03856], [61.46682, 24.57869], [61.6433, 25.27541], [61.683, 25.66638], [61.83968, 25.7538], [61.83831, 26.07249], [61.89391, 26.26251], [62.05117, 26.31647], [62.21304, 26.26601], [62.31484, 26.528], [62.77352, 26.64099], [63.1889, 26.65072], [63.18688, 26.83844], [63.25005, 26.84212], [63.25005, 27.08692], [63.32283, 27.14437], [63.19649, 27.25674], [62.80604, 27.22412], [62.79684, 27.34381], [62.84905, 27.47627], [62.7638, 28.02992], [62.79412, 28.28108], [62.59499, 28.24842], [62.40259, 28.42703], [61.93581, 28.55284], [61.65978, 28.77937], [61.53765, 29.00507], [61.31508, 29.38903], [60.87231, 29.86514], [61.80829, 30.84224], [61.78268, 30.92724], [61.8335, 30.97669], [61.83257, 31.0452], [61.80957, 31.12576], [61.80569, 31.16167], [61.70929, 31.37391], [60.84541, 31.49561], [60.86191, 32.22565], [60.56485, 33.12944], [60.88908, 33.50219], [60.91133, 33.55596], [60.69573, 33.56054], [60.57762, 33.59772], [60.5485, 33.73422], [60.5838, 33.80793], [60.50209, 34.13992], [60.66502, 34.31539], [60.91321, 34.30411], [60.72316, 34.52857], [60.99922, 34.63064], [61.00197, 34.70631], [61.06926, 34.82139], [61.12831, 35.09938], [61.0991, 35.27845], [61.18187, 35.30249], [61.27371, 35.61482], [61.22719, 35.67038], [61.26152, 35.80749], [61.22444, 35.92879], [61.12007, 35.95992], [61.22719, 36.12759], [61.1393, 36.38782], [61.18187, 36.55348], [61.14516, 36.64644], [60.34767, 36.63214], [60.00768, 37.04102], [59.74678, 37.12499], [59.55178, 37.13594], [59.39385, 37.34257], [59.39797, 37.47892], [59.33507, 37.53146], [59.22905, 37.51161], [58.9338, 37.67374], [58.6921, 37.64548], [58.5479, 37.70526], [58.47786, 37.6433], [58.39959, 37.63134], [58.22999, 37.6856], [58.21399, 37.77281], [57.79534, 37.89299], [57.35042, 37.98546], [57.37236, 38.09321], [57.21169, 38.28965], [57.03453, 38.18717], [56.73928, 38.27887], [56.62255, 38.24005], [56.43303, 38.26054], [56.32454, 38.18502], [56.33278, 38.08132], [55.97847, 38.08024], [55.76561, 38.12238], [55.44152, 38.08564], [55.13412, 37.94705], [54.851, 37.75739], [54.77684, 37.62264], [54.81804, 37.61285], [54.77822, 37.51597], [54.67247, 37.43532], [54.58664, 37.45809], [54.36211, 37.34912], [54.24565, 37.32047], [53.89734, 37.3464], [48.88288, 38.43975], [48.84969, 38.45015], [48.81072, 38.44853], [48.78979, 38.45026], [48.70001, 38.40564], [48.62217, 38.40198], [48.58793, 38.45076], [48.45084, 38.61013], [48.3146, 38.59958], [48.24773, 38.71883], [48.02581, 38.82705], [48.01409, 38.90333], [48.07734, 38.91616], [48.08627, 38.94434], [48.28437, 38.97186], [48.33884, 39.03022], [48.31239, 39.09278], [48.15361, 39.19419], [48.12404, 39.25208], [48.15984, 39.30028], [48.37385, 39.37584], [48.34264, 39.42935], [47.98977, 39.70999], [47.84774, 39.66285], [47.50099, 39.49615], [47.38978, 39.45999], [47.31301, 39.37492], [47.05927, 39.24846], [47.05771, 39.20143], [46.95341, 39.13505], [46.92539, 39.16644], [46.83822, 39.13143], [46.75752, 39.03231], [46.53497, 38.86548], [46.34059, 38.92076], [46.20601, 38.85262], [46.14785, 38.84206], [46.06766, 38.87861], [46.00228, 38.87376], [45.94624, 38.89072], [45.90266, 38.87739], [45.83883, 38.90768], [45.65172, 38.95199], [45.6155, 38.94304], [45.6131, 38.964], [45.44966, 38.99243], [45.44811, 39.04927], [45.40452, 39.07224], [45.40148, 39.09007], [45.30489, 39.18333], [45.16168, 39.21952], [45.08751, 39.35052], [45.05932, 39.36435], [44.96746, 39.42998]]]] } },
    { type: "Feature", properties: { iso1A2: "IS", iso1A3: "ISL", iso1N3: "352", wikidata: "Q189", nameEn: "Iceland", groups: ["154", "150", "UN"], callingCodes: ["354"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-33.15676, 62.62995], [-8.25539, 63.0423], [-15.70914, 69.67442], [-33.15676, 62.62995]]]] } },
    { type: "Feature", properties: { iso1A2: "IT", iso1A3: "ITA", iso1N3: "380", wikidata: "Q38", nameEn: "Italy", groups: ["EU", "039", "150", "UN"], callingCodes: ["39"] }, geometry: { type: "MultiPolygon", coordinates: [[[[8.95861, 45.96485], [8.97604, 45.96151], [8.97741, 45.98317], [8.96668, 45.98436], [8.95861, 45.96485]]], [[[7.63035, 43.57419], [9.56115, 43.20816], [10.09675, 41.44089], [7.60802, 41.05927], [7.89009, 38.19924], [11.2718, 37.6713], [12.13667, 34.20326], [14.02721, 36.53141], [17.67657, 35.68918], [18.83516, 40.36999], [16.15283, 42.18525], [13.12821, 44.48877], [13.05142, 45.33128], [13.45644, 45.59464], [13.6076, 45.64761], [13.7198, 45.59352], [13.74587, 45.59811], [13.78445, 45.5825], [13.84106, 45.58185], [13.86771, 45.59898], [13.8695, 45.60835], [13.9191, 45.6322], [13.87933, 45.65207], [13.83422, 45.68703], [13.83332, 45.70855], [13.8235, 45.7176], [13.66986, 45.79955], [13.59784, 45.8072], [13.58858, 45.83503], [13.57563, 45.8425], [13.58644, 45.88173], [13.59565, 45.89446], [13.60857, 45.89907], [13.61931, 45.91782], [13.63815, 45.93607], [13.6329, 45.94894], [13.64307, 45.98326], [13.63458, 45.98947], [13.62074, 45.98388], [13.58903, 45.99009], [13.56759, 45.96991], [13.52963, 45.96588], [13.50104, 45.98078], [13.47474, 46.00546], [13.49702, 46.01832], [13.50998, 46.04498], [13.49568, 46.04839], [13.50104, 46.05986], [13.57072, 46.09022], [13.64053, 46.13587], [13.66472, 46.17392], [13.64451, 46.18966], [13.56682, 46.18703], [13.56114, 46.2054], [13.47587, 46.22725], [13.42218, 46.20758], [13.37671, 46.29668], [13.44808, 46.33507], [13.43418, 46.35992], [13.47019, 46.3621], [13.5763, 46.40915], [13.5763, 46.42613], [13.59777, 46.44137], [13.68684, 46.43881], [13.7148, 46.5222], [13.64088, 46.53438], [13.27627, 46.56059], [12.94445, 46.60401], [12.59992, 46.6595], [12.38708, 46.71529], [12.27591, 46.88651], [12.2006, 46.88854], [12.11675, 47.01241], [12.21781, 47.03996], [12.19254, 47.09331], [11.74789, 46.98484], [11.50739, 47.00644], [11.33355, 46.99862], [11.10618, 46.92966], [11.00764, 46.76896], [10.72974, 46.78972], [10.75753, 46.82258], [10.66405, 46.87614], [10.54783, 46.84505], [10.47197, 46.85698], [10.38659, 46.67847], [10.40475, 46.63671], [10.44686, 46.64162], [10.49375, 46.62049], [10.46136, 46.53164], [10.25309, 46.57432], [10.23674, 46.63484], [10.10307, 46.61003], [10.03715, 46.44479], [10.165, 46.41051], [10.10506, 46.3372], [10.17862, 46.25626], [10.14439, 46.22992], [10.07055, 46.21668], [9.95249, 46.38045], [9.73086, 46.35071], [9.71273, 46.29266], [9.57015, 46.2958], [9.46117, 46.37481], [9.45936, 46.50873], [9.40487, 46.46621], [9.36128, 46.5081], [9.28136, 46.49685], [9.25502, 46.43743], [9.29226, 46.32717], [9.24503, 46.23616], [9.01618, 46.04928], [8.99257, 45.9698], [9.09065, 45.89906], [9.06642, 45.8761], [9.04546, 45.84968], [9.04059, 45.8464], [9.03505, 45.83976], [9.03793, 45.83548], [9.03279, 45.82865], [9.0298, 45.82127], [9.00324, 45.82055], [8.99663, 45.83466], [8.9621, 45.83707], [8.94737, 45.84285], [8.91129, 45.8388], [8.93504, 45.86245], [8.94372, 45.86587], [8.93649, 45.86775], [8.88904, 45.95465], [8.86688, 45.96135], [8.85121, 45.97239], [8.8319, 45.9879], [8.79362, 45.99207], [8.78585, 45.98973], [8.79414, 46.00913], [8.85617, 46.0748], [8.80778, 46.10085], [8.75697, 46.10395], [8.62242, 46.12112], [8.45032, 46.26869], [8.46317, 46.43712], [8.42464, 46.46367], [8.30648, 46.41587], [8.31162, 46.38044], [8.08814, 46.26692], [8.16866, 46.17817], [8.11383, 46.11577], [8.02906, 46.10331], [7.98881, 45.99867], [7.9049, 45.99945], [7.85949, 45.91485], [7.56343, 45.97421], [7.10685, 45.85653], [7.04151, 45.92435], [6.95315, 45.85163], [6.80785, 45.83265], [6.80785, 45.71864], [6.98948, 45.63869], [7.00037, 45.509], [7.18019, 45.40071], [7.10572, 45.32924], [7.13115, 45.25386], [7.07074, 45.21228], [6.96706, 45.20841], [6.85144, 45.13226], [6.7697, 45.16044], [6.62803, 45.11175], [6.66981, 45.02324], [6.74791, 45.01939], [6.74519, 44.93661], [6.75518, 44.89915], [6.90774, 44.84322], [6.93499, 44.8664], [7.02217, 44.82519], [7.00401, 44.78782], [7.07484, 44.68073], [7.00582, 44.69364], [6.95133, 44.66264], [6.96042, 44.62129], [6.85507, 44.53072], [6.86233, 44.49834], [6.94504, 44.43112], [6.88784, 44.42043], [6.89171, 44.36637], [6.98221, 44.28289], [7.00764, 44.23736], [7.16929, 44.20352], [7.27827, 44.1462], [7.34547, 44.14359], [7.36364, 44.11882], [7.62155, 44.14881], [7.63245, 44.17877], [7.68694, 44.17487], [7.66878, 44.12795], [7.72508, 44.07578], [7.6597, 44.03009], [7.66848, 43.99943], [7.65266, 43.9763], [7.60771, 43.95772], [7.56858, 43.94506], [7.56075, 43.89932], [7.51162, 43.88301], [7.49355, 43.86551], [7.50423, 43.84345], [7.53006, 43.78405], [7.63035, 43.57419]], [[12.45181, 41.90056], [12.44834, 41.90095], [12.44582, 41.90194], [12.44815, 41.90326], [12.44984, 41.90545], [12.45091, 41.90625], [12.45543, 41.90738], [12.45561, 41.90629], [12.45762, 41.9058], [12.45755, 41.9033], [12.45826, 41.90281], [12.45834, 41.90174], [12.4577, 41.90115], [12.45691, 41.90125], [12.45626, 41.90172], [12.45435, 41.90143], [12.45446, 41.90028], [12.45181, 41.90056]], [[12.45648, 43.89369], [12.44184, 43.90498], [12.41641, 43.89991], [12.40935, 43.9024], [12.41233, 43.90956], [12.40733, 43.92379], [12.41551, 43.92984], [12.41165, 43.93769], [12.40506, 43.94325], [12.40415, 43.95485], [12.41414, 43.95273], [12.42005, 43.9578], [12.43662, 43.95698], [12.44684, 43.96597], [12.46205, 43.97463], [12.47853, 43.98052], [12.49406, 43.98492], [12.50678, 43.99113], [12.51463, 43.99122], [12.5154, 43.98508], [12.51064, 43.98165], [12.51109, 43.97201], [12.50622, 43.97131], [12.50875, 43.96198], [12.50655, 43.95796], [12.51427, 43.94897], [12.51553, 43.94096], [12.50496, 43.93017], [12.50269, 43.92363], [12.49724, 43.92248], [12.49247, 43.91774], [12.49429, 43.90973], [12.48771, 43.89706], [12.45648, 43.89369]]]] } },
    { type: "Feature", properties: { iso1A2: "JE", iso1A3: "JEY", iso1N3: "832", wikidata: "Q785", nameEn: "Bailiwick of Jersey", country: "GB", groups: ["830", "Q185086", "154", "150", "UN"], driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["44 01534"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-2.00491, 48.86706], [-1.83944, 49.23037], [-2.09454, 49.46288], [-2.65349, 49.15373], [-2.00491, 48.86706]]]] } },
    { type: "Feature", properties: { iso1A2: "JM", iso1A3: "JAM", iso1N3: "388", wikidata: "Q766", nameEn: "Jamaica", aliases: ["JA"], groups: ["029", "003", "419", "019", "UN"], driveSide: "left", callingCodes: ["1 876", "1 658"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-74.09729, 17.36817], [-78.9741, 19.59515], [-78.34606, 16.57862], [-74.09729, 17.36817]]]] } },
    { type: "Feature", properties: { iso1A2: "JO", iso1A3: "JOR", iso1N3: "400", wikidata: "Q810", nameEn: "Jordan", groups: ["145", "142", "UN"], callingCodes: ["962"] }, geometry: { type: "MultiPolygon", coordinates: [[[[39.04251, 32.30203], [38.98762, 32.47694], [39.08202, 32.50304], [38.79171, 33.37328], [36.83946, 32.31293], [36.40959, 32.37908], [36.23948, 32.50108], [36.20875, 32.49529], [36.20379, 32.52751], [36.08074, 32.51463], [36.02239, 32.65911], [35.96633, 32.66237], [35.93307, 32.71966], [35.88405, 32.71321], [35.75983, 32.74803], [35.68467, 32.70715], [35.66527, 32.681], [35.61669, 32.67999], [35.59813, 32.65159], [35.56614, 32.64393], [35.57485, 32.48669], [35.55494, 32.42687], [35.55807, 32.38674], [35.57111, 32.21877], [35.52012, 32.04076], [35.54375, 31.96587], [35.52758, 31.9131], [35.55941, 31.76535], [35.47672, 31.49578], [35.40316, 31.25535], [35.43658, 31.12444], [35.41371, 30.95565], [35.33984, 30.8802], [35.33456, 30.81224], [35.29311, 30.71365], [35.21379, 30.60401], [35.19595, 30.50297], [35.16218, 30.43535], [35.19183, 30.34636], [35.14108, 30.07374], [35.02147, 29.66343], [34.98207, 29.58147], [34.97718, 29.54294], [34.92298, 29.45305], [34.8812, 29.36878], [36.07081, 29.18469], [36.50005, 29.49696], [36.75083, 29.86903], [37.4971, 29.99949], [37.66395, 30.33245], [37.99354, 30.49998], [36.99791, 31.50081], [38.99233, 31.99721], [39.29903, 32.23259], [39.26157, 32.35555], [39.04251, 32.30203]]]] } },
    { type: "Feature", properties: { iso1A2: "JP", iso1A3: "JPN", iso1N3: "392", wikidata: "Q17", nameEn: "Japan", groups: ["030", "142", "UN"], driveSide: "left", callingCodes: ["81"] }, geometry: { type: "MultiPolygon", coordinates: [[[[145.82361, 43.38904], [145.23667, 43.76813], [145.82343, 44.571], [140.9182, 45.92937], [133.61399, 37.41], [129.2669, 34.87122], [122.26612, 25.98197], [123.92912, 17.8782], [155.16731, 23.60141], [145.82361, 43.38904]]]] } },
    { type: "Feature", properties: { iso1A2: "KE", iso1A3: "KEN", iso1N3: "404", wikidata: "Q114", nameEn: "Kenya", groups: ["014", "202", "002", "UN"], driveSide: "left", callingCodes: ["254"] }, geometry: { type: "MultiPolygon", coordinates: [[[[35.9419, 4.61933], [35.51424, 4.61643], [35.42366, 4.76969], [35.47843, 4.91872], [35.30992, 4.90402], [35.34151, 5.02364], [34.47601, 4.72162], [33.9873, 4.23316], [34.06046, 4.15235], [34.15429, 3.80464], [34.45815, 3.67385], [34.44922, 3.51627], [34.39112, 3.48802], [34.41794, 3.44342], [34.40006, 3.37949], [34.45815, 3.18319], [34.56242, 3.11478], [34.60114, 2.93034], [34.65774, 2.8753], [34.73967, 2.85447], [34.78137, 2.76223], [34.77244, 2.70272], [34.95267, 2.47209], [34.90947, 2.42447], [34.98692, 1.97348], [34.9899, 1.6668], [34.92734, 1.56109], [34.87819, 1.5596], [34.7918, 1.36752], [34.82606, 1.30944], [34.82606, 1.26626], [34.80223, 1.22754], [34.67562, 1.21265], [34.58029, 1.14712], [34.57427, 1.09868], [34.52369, 1.10692], [34.43349, 0.85254], [34.40041, 0.80266], [34.31516, 0.75693], [34.27345, 0.63182], [34.20196, 0.62289], [34.13493, 0.58118], [34.11408, 0.48884], [34.08727, 0.44713], [34.10067, 0.36372], [33.90936, 0.10581], [33.98449, -0.13079], [33.9264, -0.54188], [33.93107, -0.99298], [34.02286, -1.00779], [34.03084, -1.05101], [34.0824, -1.02264], [37.67199, -3.06222], [37.71745, -3.304], [37.5903, -3.42735], [37.63099, -3.50723], [37.75036, -3.54243], [37.81321, -3.69179], [39.21631, -4.67835], [39.44306, -4.93877], [39.62121, -4.68136], [41.75542, -1.85308], [41.56362, -1.66375], [41.56, -1.59812], [41.00099, -0.83068], [40.98767, 2.82959], [41.31368, 3.14314], [41.89488, 3.97375], [41.1754, 3.94079], [40.77498, 4.27683], [39.86043, 3.86974], [39.76808, 3.67058], [39.58339, 3.47434], [39.55132, 3.39634], [39.51551, 3.40895], [39.49444, 3.45521], [39.19954, 3.47834], [39.07736, 3.5267], [38.91938, 3.51198], [38.52336, 3.62551], [38.45812, 3.60445], [38.14168, 3.62487], [37.07724, 4.33503], [36.84474, 4.44518], [36.03924, 4.44406], [35.95449, 4.53244], [35.9419, 4.61933]]]] } },
    { type: "Feature", properties: { iso1A2: "KG", iso1A3: "KGZ", iso1N3: "417", wikidata: "Q813", nameEn: "Kyrgyzstan", groups: ["143", "142", "UN"], callingCodes: ["996"] }, geometry: { type: "MultiPolygon", coordinates: [[[[74.88756, 42.98612], [74.75, 42.99029], [74.70331, 43.02519], [74.64615, 43.05881], [74.57491, 43.13702], [74.22489, 43.24657], [73.55634, 43.03071], [73.50992, 42.82356], [73.44393, 42.43098], [71.88792, 42.83578], [71.62405, 42.76613], [71.53272, 42.8014], [71.2724, 42.77853], [71.22785, 42.69248], [71.17807, 42.67381], [71.15232, 42.60486], [70.97717, 42.50147], [70.85973, 42.30188], [70.94483, 42.26238], [71.13263, 42.28356], [71.28719, 42.18033], [70.69777, 41.92554], [70.17682, 41.5455], [70.48909, 41.40335], [70.67586, 41.47953], [70.78572, 41.36419], [70.77885, 41.24813], [70.86263, 41.23833], [70.9615, 41.16393], [71.02193, 41.19494], [71.11806, 41.15359], [71.25813, 41.18796], [71.27187, 41.11015], [71.34877, 41.16807], [71.40198, 41.09436], [71.46148, 41.13958], [71.43814, 41.19644], [71.46688, 41.31883], [71.57227, 41.29175], [71.6787, 41.42111], [71.65914, 41.49599], [71.73054, 41.54713], [71.71132, 41.43012], [71.76625, 41.4466], [71.83914, 41.3546], [71.91457, 41.2982], [71.85964, 41.19081], [72.07249, 41.11739], [72.10745, 41.15483], [72.16433, 41.16483], [72.17594, 41.15522], [72.14864, 41.13363], [72.1792, 41.10621], [72.21061, 41.05607], [72.17594, 41.02377], [72.18339, 40.99571], [72.324, 41.03381], [72.34026, 41.04539], [72.34757, 41.06104], [72.36138, 41.04384], [72.38511, 41.02785], [72.45206, 41.03018], [72.48742, 40.97136], [72.55109, 40.96046], [72.59136, 40.86947], [72.68157, 40.84942], [72.84291, 40.85512], [72.94454, 40.8094], [73.01869, 40.84681], [73.13267, 40.83512], [73.13412, 40.79122], [73.0612, 40.76678], [72.99133, 40.76457], [72.93296, 40.73089], [72.8722, 40.71111], [72.85372, 40.7116], [72.84754, 40.67229], [72.80137, 40.67856], [72.74866, 40.60873], [72.74894, 40.59592], [72.75982, 40.57273], [72.74862, 40.57131], [72.74768, 40.58051], [72.73995, 40.58409], [72.69579, 40.59778], [72.66713, 40.59076], [72.66713, 40.5219], [72.47795, 40.5532], [72.40517, 40.61917], [72.34406, 40.60144], [72.41714, 40.55736], [72.38384, 40.51535], [72.41513, 40.50856], [72.44191, 40.48222], [72.40346, 40.4007], [72.24368, 40.46091], [72.18648, 40.49893], [71.96401, 40.31907], [72.05464, 40.27586], [71.85002, 40.25647], [71.82646, 40.21872], [71.73054, 40.14818], [71.71719, 40.17886], [71.69621, 40.18492], [71.70569, 40.20391], [71.68386, 40.26984], [71.61931, 40.26775], [71.61725, 40.20615], [71.51549, 40.22986], [71.51215, 40.26943], [71.4246, 40.28619], [71.36663, 40.31593], [71.13042, 40.34106], [71.05901, 40.28765], [70.95789, 40.28761], [70.9818, 40.22392], [70.80495, 40.16813], [70.7928, 40.12797], [70.65827, 40.0981], [70.65946, 39.9878], [70.58912, 39.95211], [70.55033, 39.96619], [70.47557, 39.93216], [70.57384, 39.99394], [70.58297, 40.00891], [70.01283, 40.23288], [69.67001, 40.10639], [69.64704, 40.12165], [69.57615, 40.10524], [69.55555, 40.12296], [69.53794, 40.11833], [69.53855, 40.0887], [69.5057, 40.03277], [69.53615, 39.93991], [69.43557, 39.92877], [69.43134, 39.98431], [69.35649, 40.01994], [69.26938, 39.8127], [69.3594, 39.52516], [69.68677, 39.59281], [69.87491, 39.53882], [70.11111, 39.58223], [70.2869, 39.53141], [70.44757, 39.60128], [70.64087, 39.58792], [70.7854, 39.38933], [71.06418, 39.41586], [71.08752, 39.50704], [71.49814, 39.61397], [71.55856, 39.57588], [71.5517, 39.45722], [71.62688, 39.44056], [71.76816, 39.45456], [71.80164, 39.40631], [71.7522, 39.32031], [71.79202, 39.27355], [71.90601, 39.27674], [72.04059, 39.36704], [72.09689, 39.26823], [72.17242, 39.2661], [72.23834, 39.17248], [72.33173, 39.33093], [72.62027, 39.39696], [72.85934, 39.35116], [73.18454, 39.35536], [73.31912, 39.38615], [73.45096, 39.46677], [73.59831, 39.46425], [73.87018, 39.47879], [73.94683, 39.60733], [73.92354, 39.69565], [73.9051, 39.75073], [73.83006, 39.76136], [73.97049, 40.04378], [74.25533, 40.13191], [74.35063, 40.09742], [74.69875, 40.34668], [74.85996, 40.32857], [74.78168, 40.44886], [74.82013, 40.52197], [75.08243, 40.43945], [75.22834, 40.45382], [75.5854, 40.66874], [75.69663, 40.28642], [75.91361, 40.2948], [75.96168, 40.38064], [76.33659, 40.3482], [76.5261, 40.46114], [76.75681, 40.95354], [76.99302, 41.0696], [77.28004, 41.0033], [77.3693, 41.0375], [77.52723, 41.00227], [77.76206, 41.01574], [77.81287, 41.14307], [78.12873, 41.23091], [78.15757, 41.38565], [78.3732, 41.39603], [79.92977, 42.04113], [80.17842, 42.03211], [80.17807, 42.21166], [79.97364, 42.42816], [79.52921, 42.44778], [79.19763, 42.804], [78.91502, 42.76839], [78.48469, 42.89649], [75.82823, 42.94848], [75.72174, 42.79672], [75.29966, 42.86183], [75.22619, 42.85528], [74.88756, 42.98612]], [[70.74189, 39.86319], [70.63105, 39.77923], [70.59667, 39.83542], [70.54998, 39.85137], [70.52631, 39.86989], [70.53651, 39.89155], [70.74189, 39.86319]], [[71.86463, 39.98598], [71.84316, 39.95582], [71.7504, 39.93701], [71.71511, 39.96348], [71.78838, 40.01404], [71.86463, 39.98598]], [[71.21139, 40.03369], [71.1427, 39.95026], [71.23067, 39.93581], [71.16101, 39.88423], [71.10531, 39.91354], [71.04979, 39.89808], [71.10501, 39.95568], [71.09063, 39.99], [71.11668, 39.99291], [71.11037, 40.01984], [71.01035, 40.05481], [71.00236, 40.18154], [71.06305, 40.1771], [71.12218, 40.03052], [71.21139, 40.03369]]]] } },
    { type: "Feature", properties: { iso1A2: "KH", iso1A3: "KHM", iso1N3: "116", wikidata: "Q424", nameEn: "Cambodia", groups: ["035", "142", "UN"], callingCodes: ["855"] }, geometry: { type: "MultiPolygon", coordinates: [[[[105.87328, 11.55953], [105.81645, 11.56876], [105.80867, 11.60536], [105.8507, 11.66635], [105.88962, 11.67854], [105.95188, 11.63738], [106.00792, 11.7197], [106.02038, 11.77457], [106.06708, 11.77761], [106.13158, 11.73283], [106.18539, 11.75171], [106.26478, 11.72122], [106.30525, 11.67549], [106.37219, 11.69836], [106.44691, 11.66787], [106.45158, 11.68616], [106.41577, 11.76999], [106.44535, 11.8279], [106.44068, 11.86294], [106.4687, 11.86751], [106.4111, 11.97413], [106.70687, 11.96956], [106.79405, 12.0807], [106.92325, 12.06548], [106.99953, 12.08983], [107.15831, 12.27547], [107.34511, 12.33327], [107.42917, 12.24657], [107.4463, 12.29373], [107.55059, 12.36824], [107.5755, 12.52177], [107.55993, 12.7982], [107.49611, 12.88926], [107.49144, 13.01215], [107.62843, 13.3668], [107.61909, 13.52577], [107.53503, 13.73908], [107.45252, 13.78897], [107.46498, 13.91593], [107.44318, 13.99751], [107.38247, 13.99147], [107.35757, 14.02319], [107.37158, 14.07906], [107.33577, 14.11832], [107.40427, 14.24509], [107.39493, 14.32655], [107.44941, 14.41552], [107.48521, 14.40346], [107.52569, 14.54665], [107.52102, 14.59034], [107.55371, 14.628], [107.54361, 14.69092], [107.47238, 14.61523], [107.44435, 14.52785], [107.37897, 14.54443], [107.3276, 14.58812], [107.29803, 14.58963], [107.26534, 14.54292], [107.256, 14.48716], [107.21241, 14.48716], [107.17038, 14.41782], [107.09722, 14.3937], [107.03962, 14.45099], [107.04585, 14.41782], [106.98825, 14.36806], [106.9649, 14.3198], [106.90574, 14.33639], [106.8497, 14.29416], [106.80767, 14.31226], [106.73762, 14.42687], [106.63333, 14.44194], [106.59908, 14.50977], [106.57106, 14.50525], [106.54148, 14.59565], [106.50723, 14.58963], [106.45898, 14.55045], [106.47766, 14.50977], [106.43874, 14.52032], [106.40916, 14.45249], [106.32355, 14.44043], [106.25194, 14.48415], [106.21302, 14.36203], [106.00131, 14.36957], [105.99509, 14.32734], [106.02311, 14.30623], [106.04801, 14.20363], [106.10872, 14.18401], [106.11962, 14.11307], [106.18656, 14.06324], [106.16632, 14.01794], [106.10094, 13.98471], [106.10405, 13.9137], [105.90791, 13.92881], [105.78182, 14.02247], [105.78338, 14.08438], [105.5561, 14.15684], [105.44869, 14.10703], [105.36775, 14.09948], [105.2759, 14.17496], [105.20894, 14.34967], [105.17748, 14.34432], [105.14012, 14.23873], [105.08408, 14.20402], [105.02804, 14.23722], [104.97667, 14.38806], [104.69335, 14.42726], [104.55014, 14.36091], [104.27616, 14.39861], [103.93836, 14.3398], [103.70175, 14.38052], [103.71109, 14.4348], [103.53518, 14.42575], [103.39353, 14.35639], [103.16469, 14.33075], [102.93275, 14.19044], [102.91251, 14.01531], [102.77864, 13.93374], [102.72727, 13.77806], [102.56848, 13.69366], [102.5481, 13.6589], [102.58635, 13.6286], [102.62483, 13.60883], [102.57573, 13.60461], [102.5358, 13.56933], [102.44601, 13.5637], [102.36859, 13.57488], [102.33828, 13.55613], [102.361, 13.50551], [102.35563, 13.47307], [102.35692, 13.38274], [102.34611, 13.35618], [102.36001, 13.31142], [102.36146, 13.26006], [102.43422, 13.09061], [102.46011, 13.08057], [102.52275, 12.99813], [102.48694, 12.97537], [102.49335, 12.92711], [102.53053, 12.77506], [102.4994, 12.71736], [102.51963, 12.66117], [102.57567, 12.65358], [102.7796, 12.43781], [102.78116, 12.40284], [102.73134, 12.37091], [102.70176, 12.1686], [102.77026, 12.06815], [102.78427, 11.98746], [102.83957, 11.8519], [102.90973, 11.75613], [102.91449, 11.65512], [102.52395, 11.25257], [102.47649, 9.66162], [103.99198, 10.48391], [104.43778, 10.42386], [104.47963, 10.43046], [104.49869, 10.4057], [104.59018, 10.53073], [104.87933, 10.52833], [104.95094, 10.64003], [105.09571, 10.72722], [105.02722, 10.89236], [105.08326, 10.95656], [105.11449, 10.96332], [105.34011, 10.86179], [105.42884, 10.96878], [105.50045, 10.94586], [105.77751, 11.03671], [105.86376, 10.89839], [105.84603, 10.85873], [105.93403, 10.83853], [105.94535, 10.9168], [106.06708, 10.8098], [106.18539, 10.79451], [106.14301, 10.98176], [106.20095, 10.97795], [106.1757, 11.07301], [106.1527, 11.10476], [106.10444, 11.07879], [105.86782, 11.28343], [105.88962, 11.43605], [105.87328, 11.55953]]]] } },
    { type: "Feature", properties: { iso1A2: "KI", iso1A3: "KIR", iso1N3: "296", wikidata: "Q710", nameEn: "Kiribati", groups: ["057", "009", "UN"], driveSide: "left", callingCodes: ["686"] }, geometry: { type: "MultiPolygon", coordinates: [[[[169, 3.9], [169, -3.5], [178, -3.5], [178, 3.9], [169, 3.9]]], [[[-161.06795, 5.2462], [-158.12991, -1.86122], [-175.33482, -1.40631], [-175.31804, -7.54825], [-156.50903, -7.4975], [-156.48634, -15.52824], [-135.59706, -4.70473], [-161.06795, 5.2462]]]] } },
    { type: "Feature", properties: { iso1A2: "KM", iso1A3: "COM", iso1N3: "174", wikidata: "Q970", nameEn: "Comoros", groups: ["014", "202", "002", "UN"], callingCodes: ["269"] }, geometry: { type: "MultiPolygon", coordinates: [[[[42.63904, -10.02522], [43.28731, -13.97126], [45.4971, -11.75965], [42.63904, -10.02522]]]] } },
    { type: "Feature", properties: { iso1A2: "KN", iso1A3: "KNA", iso1N3: "659", wikidata: "Q763", nameEn: "St. Kitts and Nevis", groups: ["029", "003", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", callingCodes: ["1 869"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-62.29333, 17.43155], [-62.76692, 17.64353], [-63.09677, 17.21372], [-62.63813, 16.65446], [-62.29333, 17.43155]]]] } },
    { type: "Feature", properties: { iso1A2: "KP", iso1A3: "PRK", iso1N3: "408", wikidata: "Q423", nameEn: "North Korea", groups: ["030", "142", "UN"], callingCodes: ["850"] }, geometry: { type: "MultiPolygon", coordinates: [[[[130.26095, 42.9027], [130.09764, 42.91425], [130.12957, 42.98361], [129.96409, 42.97306], [129.95082, 43.01051], [129.8865, 43.00395], [129.85261, 42.96494], [129.83277, 42.86746], [129.80719, 42.79218], [129.7835, 42.76521], [129.77183, 42.69435], [129.75294, 42.59409], [129.72541, 42.43739], [129.60482, 42.44461], [129.54701, 42.37254], [129.42882, 42.44702], [129.28541, 42.41574], [129.22423, 42.3553], [129.22285, 42.26491], [129.15178, 42.17224], [128.96068, 42.06657], [128.94007, 42.03537], [128.04487, 42.01769], [128.15119, 41.74568], [128.30716, 41.60322], [128.20061, 41.40895], [128.18546, 41.41279], [128.12967, 41.37931], [128.03311, 41.39232], [128.02633, 41.42103], [127.92943, 41.44291], [127.29712, 41.49473], [127.17841, 41.59714], [126.90729, 41.79955], [126.60631, 41.65565], [126.53189, 41.35206], [126.242, 41.15454], [126.00335, 40.92835], [125.76869, 40.87908], [125.71172, 40.85223], [124.86913, 40.45387], [124.40719, 40.13655], [124.38556, 40.11047], [124.3322, 40.05573], [124.37089, 40.03004], [124.35029, 39.95639], [124.23201, 39.9248], [124.17532, 39.8232], [123.90497, 38.79949], [123.85601, 37.49093], [124.67666, 38.05679], [124.84224, 37.977], [124.87921, 37.80827], [125.06408, 37.66334], [125.37112, 37.62643], [125.81159, 37.72949], [126.13074, 37.70512], [126.18776, 37.74728], [126.19097, 37.81462], [126.24402, 37.83113], [126.43239, 37.84095], [126.46818, 37.80873], [126.56709, 37.76857], [126.59918, 37.76364], [126.66067, 37.7897], [126.68793, 37.83728], [126.68793, 37.9175], [126.67023, 37.95852], [126.84961, 38.0344], [126.88106, 38.10246], [126.95887, 38.1347], [126.95338, 38.17735], [127.04479, 38.25518], [127.15749, 38.30722], [127.38727, 38.33227], [127.49672, 38.30647], [127.55013, 38.32257], [128.02917, 38.31861], [128.27652, 38.41657], [128.31105, 38.58462], [128.37487, 38.62345], [128.65655, 38.61914], [131.95041, 41.5445], [130.65022, 42.32281], [130.66367, 42.38024], [130.64181, 42.41422], [130.60805, 42.4317], [130.56835, 42.43281], [130.55143, 42.52158], [130.50123, 42.61636], [130.44361, 42.54849], [130.41826, 42.6011], [130.2385, 42.71127], [130.23068, 42.80125], [130.26095, 42.9027]]]] } },
    { type: "Feature", properties: { iso1A2: "KR", iso1A3: "KOR", iso1N3: "410", wikidata: "Q884", nameEn: "South Korea", groups: ["030", "142", "UN"], callingCodes: ["82"] }, geometry: { type: "MultiPolygon", coordinates: [[[[133.11729, 37.53115], [128.65655, 38.61914], [128.37487, 38.62345], [128.31105, 38.58462], [128.27652, 38.41657], [128.02917, 38.31861], [127.55013, 38.32257], [127.49672, 38.30647], [127.38727, 38.33227], [127.15749, 38.30722], [127.04479, 38.25518], [126.95338, 38.17735], [126.95887, 38.1347], [126.88106, 38.10246], [126.84961, 38.0344], [126.67023, 37.95852], [126.68793, 37.9175], [126.68793, 37.83728], [126.66067, 37.7897], [126.59918, 37.76364], [126.56709, 37.76857], [126.46818, 37.80873], [126.43239, 37.84095], [126.24402, 37.83113], [126.19097, 37.81462], [126.18776, 37.74728], [126.13074, 37.70512], [125.81159, 37.72949], [125.37112, 37.62643], [125.06408, 37.66334], [124.87921, 37.80827], [124.84224, 37.977], [124.67666, 38.05679], [123.85601, 37.49093], [122.80525, 33.30571], [125.99728, 32.63328], [129.2669, 34.87122], [133.11729, 37.53115]]]] } },
    { type: "Feature", properties: { iso1A2: "KW", iso1A3: "KWT", iso1N3: "414", wikidata: "Q817", nameEn: "Kuwait", groups: ["145", "142", "UN"], callingCodes: ["965"] }, geometry: { type: "MultiPolygon", coordinates: [[[[49.00421, 28.81495], [48.59531, 29.66815], [48.40479, 29.85763], [48.17332, 30.02448], [48.06782, 30.02906], [48.01114, 29.98906], [47.7095, 30.10453], [47.37192, 30.10421], [47.15166, 30.01044], [46.89695, 29.50584], [46.5527, 29.10283], [47.46202, 29.0014], [47.58376, 28.83382], [47.59863, 28.66798], [47.70561, 28.5221], [48.42991, 28.53628], [49.00421, 28.81495]]]] } },
    { type: "Feature", properties: { iso1A2: "KY", iso1A3: "CYM", iso1N3: "136", wikidata: "Q5785", nameEn: "Cayman Islands", country: "GB", groups: ["BOTS", "029", "003", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["1 345"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-82.11509, 19.60401], [-80.36068, 18.11751], [-79.32727, 20.06742], [-82.11509, 19.60401]]]] } },
    { type: "Feature", properties: { iso1A2: "KZ", iso1A3: "KAZ", iso1N3: "398", wikidata: "Q232", nameEn: "Kazakhstan", groups: ["143", "142", "UN"], callingCodes: ["7"] }, geometry: { type: "MultiPolygon", coordinates: [[[[68.90865, 55.38148], [68.19206, 55.18823], [68.26661, 55.09226], [68.21308, 54.98645], [65.20174, 54.55216], [65.24663, 54.35721], [65.11033, 54.33028], [64.97216, 54.4212], [63.97686, 54.29763], [64.02715, 54.22679], [63.91224, 54.20013], [63.80604, 54.27079], [62.58651, 54.05871], [62.56876, 53.94047], [62.45931, 53.90737], [62.38535, 54.03961], [62.00966, 54.04134], [62.03913, 53.94768], [61.65318, 54.02445], [61.56941, 53.95703], [61.47603, 54.08048], [61.3706, 54.08464], [61.26863, 53.92797], [60.99796, 53.93699], [61.14283, 53.90063], [61.22574, 53.80268], [60.90626, 53.62937], [61.55706, 53.57144], [61.57185, 53.50112], [61.37957, 53.45887], [61.29082, 53.50992], [61.14291, 53.41481], [61.19024, 53.30536], [62.14574, 53.09626], [62.12799, 52.99133], [62.0422, 52.96105], [61.23462, 53.03227], [61.05842, 52.92217], [60.71989, 52.75923], [60.71693, 52.66245], [60.84118, 52.63912], [60.84709, 52.52228], [60.98021, 52.50068], [61.05417, 52.35096], [60.78201, 52.22067], [60.72581, 52.15538], [60.48915, 52.15175], [60.19925, 51.99173], [59.99809, 51.98263], [60.09867, 51.87135], [60.50986, 51.7964], [60.36787, 51.66815], [60.5424, 51.61675], [60.92401, 51.61124], [60.95655, 51.48615], [61.50677, 51.40687], [61.55114, 51.32746], [61.6813, 51.25716], [61.56889, 51.23679], [61.4431, 50.80679], [60.81833, 50.6629], [60.31914, 50.67705], [60.17262, 50.83312], [60.01288, 50.8163], [59.81172, 50.54451], [59.51886, 50.49937], [59.48928, 50.64216], [58.87974, 50.70852], [58.3208, 51.15151], [57.75578, 51.13852], [57.74986, 50.93017], [57.44221, 50.88354], [57.17302, 51.11253], [56.17906, 50.93204], [56.11398, 50.7471], [55.67774, 50.54508], [54.72067, 51.03261], [54.56685, 51.01958], [54.71476, 50.61214], [54.55797, 50.52006], [54.41894, 50.61214], [54.46331, 50.85554], [54.12248, 51.11542], [53.69299, 51.23466], [53.46165, 51.49445], [52.54329, 51.48444], [52.36119, 51.74161], [51.8246, 51.67916], [51.77431, 51.49536], [51.301, 51.48799], [51.26254, 51.68466], [50.59695, 51.61859], [50.26859, 51.28677], [49.97277, 51.2405], [49.76866, 51.11067], [49.39001, 51.09396], [49.41959, 50.85927], [49.12673, 50.78639], [48.86936, 50.61589], [48.57946, 50.63278], [48.90782, 50.02281], [48.68352, 49.89546], [48.42564, 49.82283], [48.24519, 49.86099], [48.10044, 50.09242], [47.58551, 50.47867], [47.30448, 50.30894], [47.34589, 50.09308], [47.18319, 49.93721], [46.9078, 49.86707], [46.78398, 49.34026], [47.04658, 49.19834], [47.00857, 49.04921], [46.78392, 48.95352], [46.49011, 48.43019], [47.11516, 48.27188], [47.12107, 47.83687], [47.38731, 47.68176], [47.41689, 47.83687], [47.64973, 47.76559], [48.15348, 47.74545], [48.45173, 47.40818], [48.52326, 47.4102], [49.01136, 46.72716], [48.51142, 46.69268], [48.54988, 46.56267], [49.16518, 46.38542], [49.32259, 46.26944], [49.88945, 46.04554], [49.2134, 44.84989], [52.26048, 41.69249], [52.47884, 41.78034], [52.97575, 42.1308], [54.20635, 42.38477], [54.95182, 41.92424], [55.45471, 41.25609], [56.00314, 41.32584], [55.97584, 44.99322], [55.97584, 44.99328], [55.97584, 44.99338], [55.97584, 44.99343], [55.97584, 44.99348], [55.97584, 44.99353], [55.97584, 44.99359], [55.97584, 44.99369], [55.97584, 44.99374], [55.97584, 44.99384], [55.97584, 44.9939], [55.97584, 44.994], [55.97584, 44.99405], [55.97584, 44.99415], [55.97584, 44.99421], [55.97584, 44.99426], [55.97584, 44.99431], [55.97584, 44.99436], [55.97584, 44.99441], [55.97594, 44.99446], [55.97605, 44.99452], [55.97605, 44.99457], [55.97605, 44.99462], [55.97605, 44.99467], [55.97605, 44.99477], [55.97615, 44.99477], [55.97615, 44.99483], [55.97615, 44.99493], [55.97615, 44.99498], [55.97615, 44.99503], [55.97615, 44.99508], [55.97625, 44.99514], [55.97636, 44.99519], [55.97636, 44.99524], [55.97646, 44.99529], [55.97646, 44.99534], [55.97656, 44.99539], [55.97667, 44.99545], [55.97677, 44.9955], [55.97677, 44.99555], [55.97677, 44.9956], [55.97687, 44.9956], [55.97698, 44.99565], [55.97698, 44.9957], [55.97708, 44.99576], [55.97718, 44.99581], [55.97729, 44.99586], [55.97739, 44.99586], [55.97739, 44.99591], [55.97749, 44.99591], [55.9776, 44.99591], [55.9777, 44.99596], [55.9777, 44.99601], [55.9778, 44.99607], [55.97791, 44.99607], [55.97801, 44.99607], [55.97801, 44.99612], [55.97811, 44.99617], [55.97822, 44.99617], [55.97832, 44.99622], [55.97842, 44.99622], [58.59711, 45.58671], [61.01475, 44.41383], [62.01711, 43.51008], [63.34656, 43.64003], [64.53885, 43.56941], [64.96464, 43.74748], [65.18666, 43.48835], [65.53277, 43.31856], [65.85194, 42.85481], [66.09482, 42.93426], [66.00546, 41.94455], [66.53302, 41.87388], [66.69129, 41.1311], [67.9644, 41.14611], [67.98511, 41.02794], [68.08273, 41.08148], [68.1271, 41.0324], [67.96736, 40.83798], [68.49983, 40.56437], [68.63, 40.59358], [68.58444, 40.91447], [68.49983, 40.99669], [68.62221, 41.03019], [68.65662, 40.93861], [68.73945, 40.96989], [68.7217, 41.05025], [69.01308, 41.22804], [69.05006, 41.36183], [69.15137, 41.43078], [69.17701, 41.43769], [69.18528, 41.45175], [69.20439, 41.45391], [69.22671, 41.46298], [69.23332, 41.45847], [69.25059, 41.46693], [69.29778, 41.43673], [69.35554, 41.47211], [69.37468, 41.46555], [69.45081, 41.46246], [69.39485, 41.51518], [69.45751, 41.56863], [69.49545, 41.545], [70.94483, 42.26238], [70.85973, 42.30188], [70.97717, 42.50147], [71.15232, 42.60486], [71.17807, 42.67381], [71.22785, 42.69248], [71.2724, 42.77853], [71.53272, 42.8014], [71.62405, 42.76613], [71.88792, 42.83578], [73.44393, 42.43098], [73.50992, 42.82356], [73.55634, 43.03071], [74.22489, 43.24657], [74.57491, 43.13702], [74.64615, 43.05881], [74.70331, 43.02519], [74.75, 42.99029], [74.88756, 42.98612], [75.22619, 42.85528], [75.29966, 42.86183], [75.72174, 42.79672], [75.82823, 42.94848], [78.48469, 42.89649], [78.91502, 42.76839], [79.19763, 42.804], [79.52921, 42.44778], [79.97364, 42.42816], [80.17807, 42.21166], [80.26841, 42.23797], [80.16892, 42.61137], [80.26886, 42.8366], [80.38169, 42.83142], [80.58999, 42.9011], [80.3735, 43.01557], [80.62913, 43.141], [80.78817, 43.14235], [80.77771, 43.30065], [80.69718, 43.32589], [80.75156, 43.44948], [80.40031, 44.10986], [80.40229, 44.23319], [80.38384, 44.63073], [79.8987, 44.89957], [80.11169, 45.03352], [81.73278, 45.3504], [82.51374, 45.1755], [82.58474, 45.40027], [82.21792, 45.56619], [83.04622, 47.19053], [83.92184, 46.98912], [84.73077, 47.01394], [84.93995, 46.87399], [85.22443, 47.04816], [85.54294, 47.06171], [85.69696, 47.2898], [85.61067, 47.49753], [85.5169, 48.05493], [85.73581, 48.3939], [86.38069, 48.46064], [86.75343, 48.70331], [86.73568, 48.99918], [86.87238, 49.12432], [87.28386, 49.11626], [87.31465, 49.23603], [87.03071, 49.25142], [86.82606, 49.51796], [86.61307, 49.60239], [86.79056, 49.74787], [86.63674, 49.80136], [86.18709, 49.50259], [85.24047, 49.60239], [84.99198, 50.06793], [84.29385, 50.27257], [83.8442, 50.87375], [83.14607, 51.00796], [82.55443, 50.75412], [81.94999, 50.79307], [81.46581, 50.77658], [81.41248, 50.97524], [81.06091, 50.94833], [81.16999, 51.15662], [80.80318, 51.28262], [80.44819, 51.20855], [80.4127, 50.95581], [80.08138, 50.77658], [79.11255, 52.01171], [77.90383, 53.29807], [76.54243, 53.99329], [76.44076, 54.16017], [76.82266, 54.1798], [76.91052, 54.4677], [75.3668, 54.07439], [75.43398, 53.98652], [75.07405, 53.80831], [73.39218, 53.44623], [73.25412, 53.61532], [73.68921, 53.86522], [73.74778, 54.07194], [73.37963, 53.96132], [72.71026, 54.1161], [72.43415, 53.92685], [72.17477, 54.36303], [71.96141, 54.17736], [71.10379, 54.13326], [71.08706, 54.33376], [71.24185, 54.64965], [71.08288, 54.71253], [70.96009, 55.10558], [70.76493, 55.3027], [70.19179, 55.1476], [69.74917, 55.35545], [69.34224, 55.36344], [68.90865, 55.38148]]]] } },
    { type: "Feature", properties: { iso1A2: "LA", iso1A3: "LAO", iso1N3: "418", wikidata: "Q819", nameEn: "Laos", groups: ["035", "142", "UN"], callingCodes: ["856"] }, geometry: { type: "MultiPolygon", coordinates: [[[[102.1245, 22.43372], [102.03633, 22.46164], [101.98487, 22.42766], [101.91344, 22.44417], [101.90714, 22.38688], [101.86828, 22.38397], [101.7685, 22.50337], [101.68973, 22.46843], [101.61306, 22.27515], [101.56789, 22.28876], [101.53638, 22.24794], [101.60675, 22.13513], [101.57525, 22.13026], [101.62566, 21.96574], [101.7791, 21.83019], [101.74555, 21.72852], [101.83257, 21.61562], [101.80001, 21.57461], [101.7475, 21.5873], [101.7727, 21.51794], [101.74224, 21.48276], [101.74014, 21.30967], [101.84412, 21.25291], [101.83887, 21.20983], [101.76745, 21.21571], [101.79266, 21.19025], [101.7622, 21.14813], [101.70548, 21.14911], [101.66977, 21.20004], [101.60886, 21.17947], [101.59491, 21.18621], [101.6068, 21.23329], [101.54563, 21.25668], [101.29326, 21.17254], [101.2229, 21.23271], [101.26912, 21.36482], [101.19349, 21.41959], [101.2124, 21.56422], [101.15156, 21.56129], [101.16198, 21.52808], [101.00234, 21.39612], [100.80173, 21.2934], [100.72716, 21.31786], [100.63578, 21.05639], [100.55281, 21.02796], [100.50974, 20.88574], [100.64628, 20.88279], [100.60112, 20.8347], [100.51079, 20.82194], [100.36375, 20.82783], [100.1957, 20.68247], [100.08404, 20.36626], [100.09999, 20.31614], [100.09337, 20.26293], [100.11785, 20.24787], [100.1712, 20.24324], [100.16668, 20.2986], [100.22076, 20.31598], [100.25769, 20.3992], [100.33383, 20.4028], [100.37439, 20.35156], [100.41473, 20.25625], [100.44992, 20.23644], [100.4537, 20.19971], [100.47567, 20.19133], [100.51052, 20.14928], [100.55218, 20.17741], [100.58808, 20.15791], [100.5094, 19.87904], [100.398, 19.75047], [100.49604, 19.53504], [100.58219, 19.49164], [100.64606, 19.55884], [100.77231, 19.48324], [100.90302, 19.61901], [101.08928, 19.59748], [101.26545, 19.59242], [101.26991, 19.48324], [101.21347, 19.46223], [101.20604, 19.35296], [101.24911, 19.33334], [101.261, 19.12717], [101.35606, 19.04716], [101.25803, 18.89545], [101.22832, 18.73377], [101.27585, 18.68875], [101.06047, 18.43247], [101.18227, 18.34367], [101.15108, 18.25624], [101.19118, 18.2125], [101.1793, 18.0544], [101.02185, 17.87637], [100.96541, 17.57926], [101.15108, 17.47586], [101.44667, 17.7392], [101.72294, 17.92867], [101.78087, 18.07559], [101.88485, 18.02474], [102.11359, 18.21532], [102.45523, 17.97106], [102.59234, 17.96127], [102.60971, 17.95411], [102.61432, 17.92273], [102.5896, 17.84889], [102.59485, 17.83537], [102.68194, 17.80151], [102.69946, 17.81686], [102.67543, 17.84529], [102.68538, 17.86653], [102.75954, 17.89561], [102.79044, 17.93612], [102.81988, 17.94233], [102.86323, 17.97531], [102.95812, 18.0054], [102.9912, 17.9949], [103.01998, 17.97095], [103.0566, 18.00144], [103.07823, 18.03833], [103.07343, 18.12351], [103.1493, 18.17799], [103.14994, 18.23172], [103.17093, 18.2618], [103.29757, 18.30475], [103.23818, 18.34875], [103.24779, 18.37807], [103.30977, 18.4341], [103.41044, 18.4486], [103.47773, 18.42841], [103.60957, 18.40528], [103.699, 18.34125], [103.82449, 18.33979], [103.85642, 18.28666], [103.93916, 18.33914], [103.97725, 18.33631], [104.06533, 18.21656], [104.10927, 18.10826], [104.21776, 17.99335], [104.2757, 17.86139], [104.35432, 17.82871], [104.45404, 17.66788], [104.69867, 17.53038], [104.80061, 17.39367], [104.80716, 17.19025], [104.73712, 17.01404], [104.7373, 16.91125], [104.76442, 16.84752], [104.7397, 16.81005], [104.76099, 16.69302], [104.73349, 16.565], [104.88057, 16.37311], [105.00262, 16.25627], [105.06204, 16.09792], [105.42001, 16.00657], [105.38508, 15.987], [105.34115, 15.92737], [105.37959, 15.84074], [105.42285, 15.76971], [105.46573, 15.74742], [105.61756, 15.68792], [105.60446, 15.53301], [105.58191, 15.41031], [105.47635, 15.3796], [105.4692, 15.33709], [105.50662, 15.32054], [105.58043, 15.32724], [105.46661, 15.13132], [105.61162, 15.00037], [105.5121, 14.80802], [105.53864, 14.55731], [105.43783, 14.43865], [105.20894, 14.34967], [105.2759, 14.17496], [105.36775, 14.09948], [105.44869, 14.10703], [105.5561, 14.15684], [105.78338, 14.08438], [105.78182, 14.02247], [105.90791, 13.92881], [106.10405, 13.9137], [106.10094, 13.98471], [106.16632, 14.01794], [106.18656, 14.06324], [106.11962, 14.11307], [106.10872, 14.18401], [106.04801, 14.20363], [106.02311, 14.30623], [105.99509, 14.32734], [106.00131, 14.36957], [106.21302, 14.36203], [106.25194, 14.48415], [106.32355, 14.44043], [106.40916, 14.45249], [106.43874, 14.52032], [106.47766, 14.50977], [106.45898, 14.55045], [106.50723, 14.58963], [106.54148, 14.59565], [106.57106, 14.50525], [106.59908, 14.50977], [106.63333, 14.44194], [106.73762, 14.42687], [106.80767, 14.31226], [106.8497, 14.29416], [106.90574, 14.33639], [106.9649, 14.3198], [106.98825, 14.36806], [107.04585, 14.41782], [107.03962, 14.45099], [107.09722, 14.3937], [107.17038, 14.41782], [107.21241, 14.48716], [107.256, 14.48716], [107.26534, 14.54292], [107.29803, 14.58963], [107.3276, 14.58812], [107.37897, 14.54443], [107.44435, 14.52785], [107.47238, 14.61523], [107.54361, 14.69092], [107.51579, 14.79282], [107.59285, 14.87795], [107.48277, 14.93751], [107.46516, 15.00982], [107.61486, 15.0566], [107.61926, 15.13949], [107.58844, 15.20111], [107.62587, 15.2266], [107.60605, 15.37524], [107.62367, 15.42193], [107.53341, 15.40496], [107.50699, 15.48771], [107.3815, 15.49832], [107.34408, 15.62345], [107.27583, 15.62769], [107.27143, 15.71459], [107.21859, 15.74638], [107.21419, 15.83747], [107.34188, 15.89464], [107.39471, 15.88829], [107.46296, 16.01106], [107.44975, 16.08511], [107.33968, 16.05549], [107.25822, 16.13587], [107.14595, 16.17816], [107.15035, 16.26271], [107.09091, 16.3092], [107.02597, 16.31132], [106.97385, 16.30204], [106.96638, 16.34938], [106.88067, 16.43594], [106.88727, 16.52671], [106.84104, 16.55415], [106.74418, 16.41904], [106.65832, 16.47816], [106.66052, 16.56892], [106.61477, 16.60713], [106.58267, 16.6012], [106.59013, 16.62259], [106.55485, 16.68704], [106.55265, 16.86831], [106.52183, 16.87884], [106.51963, 16.92097], [106.54824, 16.92729], [106.55045, 17.0031], [106.50862, 16.9673], [106.43597, 17.01362], [106.31929, 17.20509], [106.29287, 17.3018], [106.24444, 17.24714], [106.18991, 17.28227], [106.09019, 17.36399], [105.85744, 17.63221], [105.76612, 17.67147], [105.60381, 17.89356], [105.64784, 17.96687], [105.46292, 18.22008], [105.38366, 18.15315], [105.15942, 18.38691], [105.10408, 18.43533], [105.1327, 18.58355], [105.19654, 18.64196], [105.12829, 18.70453], [104.64617, 18.85668], [104.5361, 18.97747], [103.87125, 19.31854], [104.06058, 19.43484], [104.10832, 19.51575], [104.05617, 19.61743], [104.06498, 19.66926], [104.23229, 19.70242], [104.41281, 19.70035], [104.53169, 19.61743], [104.64837, 19.62365], [104.68359, 19.72729], [104.8355, 19.80395], [104.8465, 19.91783], [104.9874, 20.09573], [104.91695, 20.15567], [104.86852, 20.14121], [104.61315, 20.24452], [104.62195, 20.36633], [104.72102, 20.40554], [104.66158, 20.47774], [104.47886, 20.37459], [104.40621, 20.3849], [104.38199, 20.47155], [104.63957, 20.6653], [104.27412, 20.91433], [104.11121, 20.96779], [103.98024, 20.91531], [103.82282, 20.8732], [103.73478, 20.6669], [103.68633, 20.66324], [103.45737, 20.82382], [103.38032, 20.79501], [103.21497, 20.89832], [103.12055, 20.89994], [103.03469, 21.05821], [102.97745, 21.05821], [102.89825, 21.24707], [102.80794, 21.25736], [102.88939, 21.3107], [102.94223, 21.46034], [102.86297, 21.4255], [102.98846, 21.58936], [102.97965, 21.74076], [102.86077, 21.71213], [102.85637, 21.84501], [102.81894, 21.83888], [102.82115, 21.73667], [102.74189, 21.66713], [102.67145, 21.65894], [102.62301, 21.91447], [102.49092, 21.99002], [102.51734, 22.02676], [102.18712, 22.30403], [102.14099, 22.40092], [102.1245, 22.43372]]]] } },
    { type: "Feature", properties: { iso1A2: "LB", iso1A3: "LBN", iso1N3: "422", wikidata: "Q822", nameEn: "Lebanon", aliases: ["RL"], groups: ["145", "142", "UN"], callingCodes: ["961"] }, geometry: { type: "MultiPolygon", coordinates: [[[[35.94816, 33.47886], [35.94465, 33.52774], [36.05723, 33.57904], [35.9341, 33.6596], [36.06778, 33.82927], [36.14517, 33.85118], [36.3967, 33.83365], [36.38263, 33.86579], [36.28589, 33.91981], [36.41078, 34.05253], [36.50576, 34.05982], [36.5128, 34.09916], [36.62537, 34.20251], [36.59195, 34.2316], [36.58667, 34.27667], [36.60778, 34.31009], [36.56556, 34.31881], [36.53039, 34.3798], [36.55853, 34.41609], [36.46179, 34.46541], [36.4442, 34.50165], [36.34745, 34.5002], [36.3369, 34.52629], [36.39846, 34.55672], [36.41429, 34.61175], [36.45299, 34.59438], [36.46003, 34.6378], [36.42941, 34.62505], [36.35384, 34.65447], [36.35135, 34.68516], [36.32399, 34.69334], [36.29165, 34.62991], [35.98718, 34.64977], [35.97386, 34.63322], [35.48515, 34.70851], [34.78515, 33.20368], [35.10645, 33.09318], [35.1924, 33.08743], [35.31429, 33.10515], [35.35223, 33.05617], [35.43059, 33.06659], [35.448, 33.09264], [35.50272, 33.09056], [35.50335, 33.114], [35.52573, 33.11921], [35.54228, 33.19865], [35.5362, 33.23196], [35.54808, 33.236], [35.54544, 33.25513], [35.55555, 33.25844], [35.56523, 33.28969], [35.58326, 33.28381], [35.58502, 33.26653], [35.62283, 33.24226], [35.62019, 33.27278], [35.77477, 33.33609], [35.81324, 33.36354], [35.82577, 33.40479], [35.88668, 33.43183], [35.94816, 33.47886]]]] } },
    { type: "Feature", properties: { iso1A2: "LC", iso1A3: "LCA", iso1N3: "662", wikidata: "Q760", nameEn: "St. Lucia", aliases: ["WL"], groups: ["029", "003", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", callingCodes: ["1 758"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-59.95997, 14.20285], [-61.69315, 14.26451], [-59.94058, 12.34011], [-59.95997, 14.20285]]]] } },
    { type: "Feature", properties: { iso1A2: "LI", iso1A3: "LIE", iso1N3: "438", wikidata: "Q347", nameEn: "Liechtenstein", aliases: ["FL"], groups: ["155", "150", "UN"], callingCodes: ["423"] }, geometry: { type: "MultiPolygon", coordinates: [[[[9.60717, 47.06091], [9.61216, 47.07732], [9.63395, 47.08443], [9.62623, 47.14685], [9.56539, 47.17124], [9.58264, 47.20673], [9.56981, 47.21926], [9.55176, 47.22585], [9.56766, 47.24281], [9.53116, 47.27029], [9.52406, 47.24959], [9.50318, 47.22153], [9.4891, 47.19346], [9.48774, 47.17402], [9.51044, 47.13727], [9.52089, 47.10019], [9.51362, 47.08505], [9.47139, 47.06402], [9.47548, 47.05257], [9.54041, 47.06495], [9.55721, 47.04762], [9.60717, 47.06091]]]] } },
    { type: "Feature", properties: { iso1A2: "LK", iso1A3: "LKA", iso1N3: "144", wikidata: "Q854", nameEn: "Sri Lanka", groups: ["034", "142", "UN"], driveSide: "left", callingCodes: ["94"] }, geometry: { type: "MultiPolygon", coordinates: [[[[76.59015, 5.591], [85.15017, 5.21497], [80.48418, 10.20786], [79.42124, 9.80115], [79.50447, 8.91876], [76.59015, 5.591]]]] } },
    { type: "Feature", properties: { iso1A2: "LR", iso1A3: "LBR", iso1N3: "430", wikidata: "Q1014", nameEn: "Liberia", groups: ["011", "202", "002", "UN"], callingCodes: ["231"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-8.47114, 7.55676], [-8.55874, 7.62525], [-8.55874, 7.70167], [-8.67814, 7.69428], [-8.72789, 7.51429], [-8.8448, 7.35149], [-8.85724, 7.26019], [-8.93435, 7.2824], [-9.09107, 7.1985], [-9.18311, 7.30461], [-9.20798, 7.38109], [-9.305, 7.42056], [-9.41943, 7.41809], [-9.48161, 7.37122], [-9.37465, 7.62032], [-9.35724, 7.74111], [-9.44928, 7.9284], [-9.41445, 8.02448], [-9.50898, 8.18455], [-9.47415, 8.35195], [-9.77763, 8.54633], [-10.05873, 8.42578], [-10.05375, 8.50697], [-10.14579, 8.52665], [-10.203, 8.47991], [-10.27575, 8.48711], [-10.30084, 8.30008], [-10.31635, 8.28554], [-10.29839, 8.21283], [-10.35227, 8.15223], [-10.45023, 8.15627], [-10.51554, 8.1393], [-10.57523, 8.04829], [-10.60492, 8.04072], [-10.60422, 7.7739], [-11.29417, 7.21576], [-11.4027, 6.97746], [-11.50429, 6.92704], [-12.15048, 6.15992], [-7.52774, 3.7105], [-7.53259, 4.35145], [-7.59349, 4.8909], [-7.53876, 4.94294], [-7.55369, 5.08667], [-7.48901, 5.14118], [-7.46165, 5.26256], [-7.36463, 5.32944], [-7.43428, 5.42355], [-7.37209, 5.61173], [-7.43926, 5.74787], [-7.43677, 5.84687], [-7.46165, 5.84934], [-7.48155, 5.80974], [-7.67309, 5.94337], [-7.70294, 5.90625], [-7.78254, 5.99037], [-7.79747, 6.07696], [-7.8497, 6.08932], [-7.83478, 6.20309], [-7.90692, 6.27728], [-8.00642, 6.31684], [-8.17557, 6.28222], [-8.3298, 6.36381], [-8.38453, 6.35887], [-8.45666, 6.49977], [-8.48652, 6.43797], [-8.59456, 6.50612], [-8.31736, 6.82837], [-8.29249, 7.1691], [-8.37458, 7.25794], [-8.41935, 7.51203], [-8.47114, 7.55676]]]] } },
    { type: "Feature", properties: { iso1A2: "LS", iso1A3: "LSO", iso1N3: "426", wikidata: "Q1013", nameEn: "Lesotho", groups: ["018", "202", "002", "UN"], driveSide: "left", callingCodes: ["266"] }, geometry: { type: "MultiPolygon", coordinates: [[[[29.33204, -29.45598], [29.44883, -29.3772], [29.40524, -29.21246], [28.68043, -28.58744], [28.65091, -28.57025], [28.40612, -28.6215], [28.30518, -28.69531], [28.2348, -28.69471], [28.1317, -28.7293], [28.02503, -28.85991], [27.98675, -28.8787], [27.9392, -28.84864], [27.88933, -28.88156], [27.8907, -28.91612], [27.75458, -28.89839], [27.55974, -29.18954], [27.5158, -29.2261], [27.54258, -29.25575], [27.48679, -29.29349], [27.45125, -29.29708], [27.47254, -29.31968], [27.4358, -29.33465], [27.33464, -29.48161], [27.01016, -29.65439], [27.09489, -29.72796], [27.22719, -30.00718], [27.29603, -30.05473], [27.32555, -30.14785], [27.40778, -30.14577], [27.37293, -30.19401], [27.36649, -30.27246], [27.38108, -30.33456], [27.45452, -30.32239], [27.56901, -30.42504], [27.56781, -30.44562], [27.62137, -30.50509], [27.6521, -30.51707], [27.67819, -30.53437], [27.69467, -30.55862], [27.74814, -30.60635], [28.12073, -30.68072], [28.2319, -30.28476], [28.399, -30.1592], [28.68627, -30.12885], [28.80222, -30.10579], [28.9338, -30.05072], [29.16548, -29.91706], [29.12553, -29.76266], [29.28545, -29.58456], [29.33204, -29.45598]]]] } },
    { type: "Feature", properties: { iso1A2: "LT", iso1A3: "LTU", iso1N3: "440", wikidata: "Q37", nameEn: "Lithuania", groups: ["EU", "154", "150", "UN"], callingCodes: ["370"] }, geometry: { type: "MultiPolygon", coordinates: [[[[24.89005, 56.46666], [24.83686, 56.41565], [24.70022, 56.40483], [24.57353, 56.31525], [24.58143, 56.29125], [24.42746, 56.26522], [24.32334, 56.30226], [24.13139, 56.24881], [24.02657, 56.3231], [23.75726, 56.37282], [23.49803, 56.34307], [23.40486, 56.37689], [23.31606, 56.3827], [23.17312, 56.36795], [23.09531, 56.30511], [22.96988, 56.41213], [22.83048, 56.367], [22.69354, 56.36284], [22.56441, 56.39305], [22.3361, 56.4016], [22.09728, 56.42851], [22.00548, 56.41508], [21.74558, 56.33181], [21.57888, 56.31406], [21.49736, 56.29106], [21.24644, 56.16917], [21.15016, 56.07818], [20.68447, 56.04073], [20.60454, 55.40986], [20.95181, 55.27994], [21.26425, 55.24456], [21.35465, 55.28427], [21.38446, 55.29348], [21.46766, 55.21115], [21.51095, 55.18507], [21.55605, 55.20311], [21.64954, 55.1791], [21.85521, 55.09493], [21.96505, 55.07353], [21.99543, 55.08691], [22.03984, 55.07888], [22.02582, 55.05078], [22.06087, 55.02935], [22.11697, 55.02131], [22.14267, 55.05345], [22.31562, 55.0655], [22.47688, 55.04408], [22.58907, 55.07085], [22.60075, 55.01863], [22.65451, 54.97037], [22.68723, 54.9811], [22.76422, 54.92521], [22.85083, 54.88711], [22.87317, 54.79492], [22.73631, 54.72952], [22.73397, 54.66604], [22.75467, 54.6483], [22.74225, 54.64339], [22.7522, 54.63525], [22.68021, 54.58486], [22.71293, 54.56454], [22.67788, 54.532], [22.70208, 54.45312], [22.7253, 54.41732], [22.79705, 54.36264], [22.83756, 54.40827], [23.00584, 54.38514], [22.99649, 54.35927], [23.05726, 54.34565], [23.04323, 54.31567], [23.104, 54.29794], [23.13905, 54.31567], [23.15526, 54.31076], [23.15938, 54.29894], [23.24656, 54.25701], [23.3494, 54.25155], [23.39525, 54.21672], [23.42418, 54.17911], [23.45223, 54.17775], [23.49196, 54.14764], [23.52702, 54.04622], [23.48261, 53.98855], [23.51284, 53.95052], [23.61677, 53.92691], [23.71726, 53.93379], [23.80543, 53.89558], [23.81309, 53.94205], [23.95098, 53.9613], [23.98837, 53.92554], [24.19638, 53.96405], [24.34128, 53.90076], [24.44411, 53.90076], [24.62275, 54.00217], [24.69652, 54.01901], [24.69185, 53.96543], [24.74279, 53.96663], [24.85311, 54.02862], [24.77131, 54.11091], [24.96894, 54.17589], [24.991, 54.14241], [25.0728, 54.13419], [25.19199, 54.219], [25.22705, 54.26271], [25.35559, 54.26544], [25.509, 54.30267], [25.56823, 54.25212], [25.51452, 54.17799], [25.54724, 54.14925], [25.64875, 54.1259], [25.71084, 54.16704], [25.78563, 54.15747], [25.78553, 54.23327], [25.68513, 54.31727], [25.55425, 54.31591], [25.5376, 54.33158], [25.63371, 54.42075], [25.62203, 54.4656], [25.64813, 54.48704], [25.68045, 54.5321], [25.75977, 54.57252], [25.74122, 54.80108], [25.89462, 54.93438], [25.99129, 54.95705], [26.05907, 54.94631], [26.13386, 54.98924], [26.20397, 54.99729], [26.26941, 55.08032], [26.23202, 55.10439], [26.30628, 55.12536], [26.35121, 55.1525], [26.46249, 55.12814], [26.51481, 55.16051], [26.54753, 55.14181], [26.69243, 55.16718], [26.68075, 55.19787], [26.72983, 55.21788], [26.73017, 55.24226], [26.835, 55.28182], [26.83266, 55.30444], [26.80929, 55.31642], [26.6714, 55.33902], [26.5709, 55.32572], [26.44937, 55.34832], [26.5522, 55.40277], [26.55094, 55.5093], [26.63167, 55.57887], [26.63231, 55.67968], [26.58248, 55.6754], [26.46661, 55.70375], [26.39561, 55.71156], [26.18509, 55.86813], [26.03815, 55.95884], [25.90047, 56.0013], [25.85893, 56.00188], [25.81773, 56.05444], [25.69246, 56.08892], [25.68588, 56.14725], [25.53621, 56.16663], [25.39751, 56.15707], [25.23099, 56.19147], [25.09325, 56.1878], [25.05762, 56.26742], [24.89005, 56.46666]]]] } },
    { type: "Feature", properties: { iso1A2: "LU", iso1A3: "LUX", iso1N3: "442", wikidata: "Q32", nameEn: "Luxembourg", groups: ["EU", "155", "150", "UN"], callingCodes: ["352"] }, geometry: { type: "MultiPolygon", coordinates: [[[[6.1379, 50.12964], [6.1137, 50.13668], [6.12028, 50.16374], [6.08577, 50.17246], [6.06406, 50.15344], [6.03093, 50.16362], [6.02488, 50.18283], [5.96453, 50.17259], [5.95929, 50.13295], [5.89488, 50.11476], [5.8857, 50.07824], [5.85474, 50.06342], [5.86904, 50.04614], [5.8551, 50.02683], [5.81866, 50.01286], [5.82331, 49.99662], [5.83968, 49.9892], [5.83467, 49.97823], [5.81163, 49.97142], [5.80833, 49.96451], [5.77291, 49.96056], [5.77314, 49.93646], [5.73621, 49.89796], [5.78415, 49.87922], [5.75269, 49.8711], [5.75861, 49.85631], [5.74567, 49.85368], [5.75884, 49.84811], [5.74953, 49.84709], [5.74975, 49.83933], [5.74076, 49.83823], [5.7404, 49.83452], [5.74844, 49.82435], [5.74364, 49.82058], [5.74953, 49.81428], [5.75409, 49.79239], [5.78871, 49.7962], [5.82245, 49.75048], [5.83149, 49.74729], [5.82562, 49.72395], [5.84193, 49.72161], [5.86503, 49.72739], [5.88677, 49.70951], [5.86527, 49.69291], [5.86175, 49.67862], [5.9069, 49.66377], [5.90164, 49.6511], [5.90599, 49.63853], [5.88552, 49.63507], [5.88393, 49.62802], [5.87609, 49.62047], [5.8762, 49.60898], [5.84826, 49.5969], [5.84971, 49.58674], [5.86986, 49.58756], [5.87256, 49.57539], [5.8424, 49.56082], [5.84692, 49.55663], [5.84143, 49.5533], [5.81838, 49.54777], [5.80871, 49.5425], [5.81664, 49.53775], [5.83648, 49.5425], [5.84466, 49.53027], [5.83467, 49.52717], [5.83389, 49.52152], [5.86571, 49.50015], [5.94128, 49.50034], [5.94224, 49.49608], [5.96876, 49.49053], [5.97693, 49.45513], [6.02648, 49.45451], [6.02743, 49.44845], [6.04176, 49.44801], [6.05553, 49.46663], [6.07887, 49.46399], [6.08373, 49.45594], [6.10072, 49.45268], [6.09845, 49.46351], [6.10325, 49.4707], [6.12346, 49.4735], [6.12814, 49.49365], [6.14321, 49.48796], [6.16115, 49.49297], [6.15366, 49.50226], [6.17386, 49.50934], [6.19543, 49.50536], [6.2409, 49.51408], [6.25029, 49.50609], [6.27875, 49.503], [6.28818, 49.48465], [6.3687, 49.4593], [6.36778, 49.46937], [6.36907, 49.48931], [6.36788, 49.50377], [6.35666, 49.52931], [6.38072, 49.55171], [6.38228, 49.55855], [6.35825, 49.57053], [6.36676, 49.57813], [6.38024, 49.57593], [6.38342, 49.5799], [6.37464, 49.58886], [6.385, 49.59946], [6.39822, 49.60081], [6.41861, 49.61723], [6.4413, 49.65722], [6.43768, 49.66021], [6.42726, 49.66078], [6.42937, 49.66857], [6.44654, 49.67799], [6.46048, 49.69092], [6.48014, 49.69767], [6.49785, 49.71118], [6.50647, 49.71353], [6.5042, 49.71808], [6.49694, 49.72205], [6.49535, 49.72645], [6.50261, 49.72718], [6.51397, 49.72058], [6.51805, 49.72425], [6.50193, 49.73291], [6.50174, 49.75292], [6.51646, 49.75961], [6.51828, 49.76855], [6.51056, 49.77515], [6.51669, 49.78336], [6.50534, 49.78952], [6.52169, 49.79787], [6.53122, 49.80666], [6.52121, 49.81338], [6.51215, 49.80124], [6.50647, 49.80916], [6.48718, 49.81267], [6.47111, 49.82263], [6.45425, 49.81164], [6.44131, 49.81443], [6.42905, 49.81091], [6.42521, 49.81591], [6.40022, 49.82029], [6.36576, 49.85032], [6.34267, 49.84974], [6.33585, 49.83785], [6.32098, 49.83728], [6.32303, 49.85133], [6.30963, 49.87021], [6.29692, 49.86685], [6.28874, 49.87592], [6.26146, 49.88203], [6.23496, 49.89972], [6.22926, 49.92096], [6.21882, 49.92403], [6.22608, 49.929], [6.22094, 49.94955], [6.19856, 49.95053], [6.19089, 49.96991], [6.18045, 49.96611], [6.18554, 49.95622], [6.17872, 49.9537], [6.16466, 49.97086], [6.1701, 49.98518], [6.14147, 49.99563], [6.14948, 50.00908], [6.13806, 50.01056], [6.1295, 50.01849], [6.13273, 50.02019], [6.13794, 50.01466], [6.14666, 50.02207], [6.13044, 50.02929], [6.13458, 50.04141], [6.11274, 50.05916], [6.12055, 50.09171], [6.1379, 50.12964]]]] } },
    { type: "Feature", properties: { iso1A2: "LV", iso1A3: "LVA", iso1N3: "428", wikidata: "Q211", nameEn: "Latvia", groups: ["EU", "154", "150", "UN"], callingCodes: ["371"] }, geometry: { type: "MultiPolygon", coordinates: [[[[27.34698, 57.52242], [26.90364, 57.62823], [26.54675, 57.51813], [26.46527, 57.56885], [26.29253, 57.59244], [26.1866, 57.6849], [26.2029, 57.7206], [26.08098, 57.76619], [26.0543, 57.76105], [26.03332, 57.7718], [26.02415, 57.76865], [26.02069, 57.77169], [26.0266, 57.77441], [26.027, 57.78158], [26.02456, 57.78342], [26.0324, 57.79037], [26.05949, 57.84744], [25.73499, 57.90193], [25.29581, 58.08288], [25.28237, 57.98539], [25.19484, 58.0831], [24.3579, 57.87471], [24.26221, 57.91787], [23.20055, 57.56697], [22.80496, 57.87798], [19.84909, 57.57876], [19.64795, 57.06466], [20.68447, 56.04073], [21.15016, 56.07818], [21.24644, 56.16917], [21.49736, 56.29106], [21.57888, 56.31406], [21.74558, 56.33181], [22.00548, 56.41508], [22.09728, 56.42851], [22.3361, 56.4016], [22.56441, 56.39305], [22.69354, 56.36284], [22.83048, 56.367], [22.96988, 56.41213], [23.09531, 56.30511], [23.17312, 56.36795], [23.31606, 56.3827], [23.40486, 56.37689], [23.49803, 56.34307], [23.75726, 56.37282], [24.02657, 56.3231], [24.13139, 56.24881], [24.32334, 56.30226], [24.42746, 56.26522], [24.58143, 56.29125], [24.57353, 56.31525], [24.70022, 56.40483], [24.83686, 56.41565], [24.89005, 56.46666], [25.05762, 56.26742], [25.09325, 56.1878], [25.23099, 56.19147], [25.39751, 56.15707], [25.53621, 56.16663], [25.68588, 56.14725], [25.69246, 56.08892], [25.81773, 56.05444], [25.85893, 56.00188], [25.90047, 56.0013], [26.03815, 55.95884], [26.18509, 55.86813], [26.39561, 55.71156], [26.46661, 55.70375], [26.58248, 55.6754], [26.63231, 55.67968], [26.64888, 55.70515], [26.71802, 55.70645], [26.76872, 55.67658], [26.87448, 55.7172], [26.97153, 55.8102], [27.1559, 55.85032], [27.27804, 55.78299], [27.3541, 55.8089], [27.61683, 55.78558], [27.63065, 55.89687], [27.97865, 56.11849], [28.15217, 56.16964], [28.23716, 56.27588], [28.16599, 56.37806], [28.19057, 56.44637], [28.10069, 56.524], [28.13526, 56.57989], [28.04768, 56.59004], [27.86101, 56.88204], [27.66511, 56.83921], [27.86101, 57.29402], [27.52453, 57.42826], [27.56832, 57.53728], [27.34698, 57.52242]]]] } },
    { type: "Feature", properties: { iso1A2: "LY", iso1A3: "LBY", iso1N3: "434", wikidata: "Q1016", nameEn: "Libya", groups: ["015", "002", "UN"], callingCodes: ["218"] }, geometry: { type: "MultiPolygon", coordinates: [[[[26.92891, 33.39516], [11.58941, 33.36891], [11.55852, 33.1409], [11.51549, 33.09826], [11.46037, 32.6307], [11.57828, 32.48013], [11.53898, 32.4138], [11.04234, 32.2145], [10.7315, 31.97235], [10.62788, 31.96629], [10.48497, 31.72956], [10.31364, 31.72648], [10.12239, 31.42098], [10.29516, 30.90337], [9.88152, 30.34074], [9.76848, 30.34366], [9.55544, 30.23971], [9.3876, 30.16738], [9.78136, 29.40961], [9.89569, 26.57696], [9.51696, 26.39148], [9.38834, 26.19288], [10.03146, 25.35635], [10.02432, 24.98124], [10.33159, 24.5465], [10.85323, 24.5595], [11.41061, 24.21456], [11.62498, 24.26669], [11.96886, 23.51735], [13.5631, 23.16574], [14.22918, 22.61719], [14.99751, 23.00539], [15.99566, 23.49639], [23.99539, 19.49944], [23.99715, 20.00038], [24.99794, 19.99661], [24.99885, 21.99535], [24.99968, 29.24574], [24.71117, 30.17441], [25.01077, 30.73861], [24.8458, 31.39877], [26.92891, 33.39516]]]] } },
    { type: "Feature", properties: { iso1A2: "MA", iso1A3: "MAR", iso1N3: "504", wikidata: "Q1028", nameEn: "Morocco", groups: ["015", "002", "UN"], callingCodes: ["212"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-2.27707, 35.35051], [-5.10878, 36.05227], [-7.2725, 35.73269], [-14.43883, 27.02969], [-17.27295, 21.93519], [-17.21511, 21.34226], [-17.02707, 21.34022], [-16.9978, 21.36239], [-16.44269, 21.39745], [-14.78487, 21.36587], [-14.47329, 21.63839], [-14.48112, 22.00886], [-14.1291, 22.41636], [-14.10361, 22.75501], [-13.75627, 23.77231], [-13.00628, 24.01923], [-12.92147, 24.39502], [-12.12281, 25.13682], [-12.06001, 26.04442], [-11.62052, 26.05229], [-11.38635, 26.611], [-11.23622, 26.72023], [-11.35695, 26.8505], [-10.68417, 26.90984], [-9.81998, 26.71379], [-9.56957, 26.90042], [-9.08698, 26.98639], [-8.71787, 26.9898], [-8.77527, 27.66663], [-8.66879, 27.6666], [-8.6715, 28.71194], [-7.61585, 29.36252], [-6.95824, 29.50924], [-6.78351, 29.44634], [-6.69965, 29.51623], [-5.75616, 29.61407], [-5.72121, 29.52322], [-5.58831, 29.48103], [-5.21671, 29.95253], [-4.6058, 30.28343], [-4.31774, 30.53229], [-3.64735, 30.67539], [-3.65418, 30.85566], [-3.54944, 31.0503], [-3.77103, 31.14984], [-3.77647, 31.31912], [-3.66386, 31.39202], [-3.66314, 31.6339], [-2.82784, 31.79459], [-2.93873, 32.06557], [-2.46166, 32.16603], [-1.22829, 32.07832], [-1.15735, 32.12096], [-1.24453, 32.1917], [-1.24998, 32.32993], [-0.9912, 32.52467], [-1.37794, 32.73628], [-1.54244, 32.95499], [-1.46249, 33.0499], [-1.67067, 33.27084], [-1.59508, 33.59929], [-1.73494, 33.71721], [-1.64666, 34.10405], [-1.78042, 34.39018], [-1.69788, 34.48056], [-1.84569, 34.61907], [-1.73707, 34.74226], [-1.97469, 34.886], [-1.97833, 34.93218], [-2.04734, 34.93218], [-2.21445, 35.04378], [-2.21248, 35.08532], [-2.27707, 35.35051]], [[-2.91909, 35.33927], [-2.92272, 35.27509], [-2.93893, 35.26737], [-2.95065, 35.26576], [-2.95431, 35.2728], [-2.96516, 35.27967], [-2.96826, 35.28296], [-2.96507, 35.28801], [-2.97035, 35.28852], [-2.96978, 35.29459], [-2.96648, 35.30475], [-2.96038, 35.31609], [-2.91909, 35.33927]], [[-3.90602, 35.21494], [-3.89343, 35.22728], [-3.88372, 35.20767], [-3.90602, 35.21494]], [[-4.30191, 35.17419], [-4.29436, 35.17149], [-4.30112, 35.17058], [-4.30191, 35.17419]], [[-2.40316, 35.16893], [-2.45965, 35.16527], [-2.43262, 35.20652], [-2.40316, 35.16893]], [[-5.38491, 35.92591], [-5.21179, 35.90091], [-5.34379, 35.8711], [-5.35844, 35.87375], [-5.37338, 35.88417], [-5.38491, 35.92591]]]] } },
    { type: "Feature", properties: { iso1A2: "MC", iso1A3: "MCO", iso1N3: "492", wikidata: "Q235", nameEn: "Monaco", groups: ["155", "150", "UN"], callingCodes: ["377"] }, geometry: { type: "MultiPolygon", coordinates: [[[[7.47823, 43.73341], [7.4379, 43.74963], [7.4389, 43.75151], [7.43708, 43.75197], [7.43624, 43.75014], [7.43013, 43.74895], [7.42809, 43.74396], [7.42443, 43.74087], [7.42299, 43.74176], [7.42062, 43.73977], [7.41233, 43.73439], [7.41298, 43.73311], [7.41291, 43.73168], [7.41113, 43.73156], [7.40903, 43.7296], [7.42422, 43.72209], [7.47823, 43.73341]]]] } },
    { type: "Feature", properties: { iso1A2: "MD", iso1A3: "MDA", iso1N3: "498", wikidata: "Q217", nameEn: "Moldova", groups: ["151", "150", "UN"], callingCodes: ["373"] }, geometry: { type: "MultiPolygon", coordinates: [[[[27.74422, 48.45926], [27.6658, 48.44034], [27.59027, 48.46311], [27.5889, 48.49224], [27.46942, 48.454], [27.44333, 48.41209], [27.37741, 48.41026], [27.37604, 48.44398], [27.32159, 48.4434], [27.27855, 48.37534], [27.13434, 48.37288], [27.08078, 48.43214], [27.0231, 48.42485], [27.03821, 48.37653], [26.93384, 48.36558], [26.85556, 48.41095], [26.71274, 48.40388], [26.82809, 48.31629], [26.79239, 48.29071], [26.6839, 48.35828], [26.62823, 48.25804], [26.81161, 48.25049], [26.87708, 48.19919], [26.94265, 48.1969], [26.98042, 48.15752], [26.96119, 48.13003], [27.04118, 48.12522], [27.02985, 48.09083], [27.15622, 47.98538], [27.1618, 47.92391], [27.29069, 47.73722], [27.25519, 47.71366], [27.32202, 47.64009], [27.3979, 47.59473], [27.47942, 47.48113], [27.55731, 47.46637], [27.60263, 47.32507], [27.68706, 47.28962], [27.73172, 47.29248], [27.81892, 47.1381], [28.09095, 46.97621], [28.12173, 46.82283], [28.24808, 46.64305], [28.22281, 46.50481], [28.25769, 46.43334], [28.18902, 46.35283], [28.19864, 46.31869], [28.10937, 46.22852], [28.13684, 46.18099], [28.08612, 46.01105], [28.13111, 45.92819], [28.16568, 45.6421], [28.08927, 45.6051], [28.18741, 45.47358], [28.21139, 45.46895], [28.30201, 45.54744], [28.41836, 45.51715], [28.43072, 45.48538], [28.51449, 45.49982], [28.49252, 45.56716], [28.54196, 45.58062], [28.51587, 45.6613], [28.47879, 45.66994], [28.52823, 45.73803], [28.70401, 45.78019], [28.69852, 45.81753], [28.78503, 45.83475], [28.74383, 45.96664], [28.98004, 46.00385], [29.00613, 46.04962], [28.94643, 46.09176], [29.06656, 46.19716], [28.94953, 46.25852], [28.98478, 46.31803], [29.004, 46.31495], [28.9306, 46.45699], [29.01241, 46.46177], [29.02409, 46.49582], [29.23547, 46.55435], [29.24886, 46.37912], [29.35357, 46.49505], [29.49914, 46.45889], [29.5939, 46.35472], [29.6763, 46.36041], [29.66359, 46.4215], [29.74496, 46.45605], [29.88329, 46.35851], [29.94114, 46.40114], [30.09103, 46.38694], [30.16794, 46.40967], [30.02511, 46.45132], [29.88916, 46.54302], [29.94409, 46.56002], [29.9743, 46.75325], [29.94522, 46.80055], [29.98814, 46.82358], [29.87405, 46.88199], [29.75458, 46.8604], [29.72986, 46.92234], [29.57056, 46.94766], [29.62137, 47.05069], [29.61038, 47.09932], [29.53044, 47.07851], [29.49732, 47.12878], [29.57696, 47.13581], [29.54996, 47.24962], [29.59665, 47.25521], [29.5733, 47.36508], [29.48678, 47.36043], [29.47854, 47.30366], [29.39889, 47.30179], [29.3261, 47.44664], [29.18603, 47.43387], [29.11743, 47.55001], [29.22414, 47.60012], [29.22242, 47.73607], [29.27255, 47.79953], [29.20663, 47.80367], [29.27804, 47.88893], [29.19839, 47.89261], [29.1723, 47.99013], [28.9306, 47.96255], [28.8414, 48.03392], [28.85232, 48.12506], [28.69896, 48.13106], [28.53921, 48.17453], [28.48428, 48.0737], [28.42454, 48.12047], [28.43701, 48.15832], [28.38712, 48.17567], [28.34009, 48.13147], [28.30609, 48.14018], [28.30586, 48.1597], [28.34912, 48.1787], [28.36996, 48.20543], [28.35519, 48.24957], [28.32508, 48.23384], [28.2856, 48.23202], [28.19314, 48.20749], [28.17666, 48.25963], [28.07504, 48.23494], [28.09873, 48.3124], [28.04527, 48.32661], [27.95883, 48.32368], [27.88391, 48.36699], [27.87533, 48.4037], [27.81902, 48.41874], [27.79225, 48.44244], [27.74422, 48.45926]]]] } },
    { type: "Feature", properties: { iso1A2: "ME", iso1A3: "MNE", iso1N3: "499", wikidata: "Q236", nameEn: "Montenegro", groups: ["039", "150", "UN"], callingCodes: ["382"] }, geometry: { type: "MultiPolygon", coordinates: [[[[19.22807, 43.5264], [19.15685, 43.53943], [19.13933, 43.5282], [19.04934, 43.50384], [19.01078, 43.55806], [18.91379, 43.50299], [18.95469, 43.49367], [18.96053, 43.45042], [19.01078, 43.43854], [19.04071, 43.397], [19.08673, 43.31453], [19.08206, 43.29668], [19.04233, 43.30008], [19.00844, 43.24988], [18.95001, 43.29327], [18.95819, 43.32899], [18.90911, 43.36383], [18.83912, 43.34795], [18.84794, 43.33735], [18.85342, 43.32426], [18.76538, 43.29838], [18.6976, 43.25243], [18.71747, 43.2286], [18.66605, 43.2056], [18.64735, 43.14766], [18.66254, 43.03928], [18.52232, 43.01451], [18.49076, 42.95553], [18.49661, 42.89306], [18.4935, 42.86433], [18.47633, 42.85829], [18.45921, 42.81682], [18.47324, 42.74992], [18.56789, 42.72074], [18.55221, 42.69045], [18.54603, 42.69171], [18.54841, 42.68328], [18.57373, 42.64429], [18.52232, 42.62279], [18.55504, 42.58409], [18.53751, 42.57376], [18.49778, 42.58409], [18.43735, 42.55921], [18.44307, 42.51077], [18.43588, 42.48556], [18.52152, 42.42302], [18.54128, 42.39171], [18.45131, 42.21682], [19.26406, 41.74971], [19.37597, 41.84849], [19.37451, 41.8842], [19.33812, 41.90669], [19.34601, 41.95675], [19.37691, 41.96977], [19.36867, 42.02564], [19.37548, 42.06835], [19.40687, 42.10024], [19.28623, 42.17745], [19.42, 42.33019], [19.42352, 42.36546], [19.4836, 42.40831], [19.65972, 42.62774], [19.73244, 42.66299], [19.77375, 42.58517], [19.74731, 42.57422], [19.76549, 42.50237], [19.82333, 42.46581], [19.9324, 42.51699], [20.00842, 42.5109], [20.01834, 42.54622], [20.07761, 42.55582], [20.0969, 42.65559], [20.02915, 42.71147], [20.02088, 42.74789], [20.04898, 42.77701], [20.2539, 42.76245], [20.27869, 42.81945], [20.35692, 42.8335], [20.34528, 42.90676], [20.16415, 42.97177], [20.14896, 42.99058], [20.12325, 42.96237], [20.05431, 42.99571], [20.04729, 43.02732], [19.98887, 43.0538], [19.96549, 43.11098], [19.92576, 43.08539], [19.79255, 43.11951], [19.76918, 43.16044], [19.64063, 43.19027], [19.62661, 43.2286], [19.54598, 43.25158], [19.52962, 43.31623], [19.48171, 43.32644], [19.44315, 43.38846], [19.22229, 43.47926], [19.22807, 43.5264]]]] } },
    { type: "Feature", properties: { iso1A2: "MF", iso1A3: "MAF", iso1N3: "663", wikidata: "Q126125", nameEn: "Saint-Martin", country: "FR", groups: ["Q3320166", "EU", "029", "003", "419", "019", "UN"], callingCodes: ["590"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-62.93924, 18.02904], [-62.62718, 18.26185], [-63.35989, 18.06012], [-63.33064, 17.9615], [-63.13502, 18.05445], [-63.11042, 18.05339], [-63.09686, 18.04608], [-63.07759, 18.04943], [-63.0579, 18.06614], [-63.04039, 18.05619], [-63.02323, 18.05757], [-62.93924, 18.02904]]]] } },
    { type: "Feature", properties: { iso1A2: "MG", iso1A3: "MDG", iso1N3: "450", wikidata: "Q1019", nameEn: "Madagascar", aliases: ["RM"], groups: ["014", "202", "002", "UN"], callingCodes: ["261"] }, geometry: { type: "MultiPolygon", coordinates: [[[[51.93891, -10.85085], [45.84651, -12.77177], [42.14681, -19.63341], [45.80092, -33.00974], [51.93891, -10.85085]]]] } },
    { type: "Feature", properties: { iso1A2: "MH", iso1A3: "MHL", iso1N3: "584", wikidata: "Q709", nameEn: "Marshall Islands", groups: ["057", "009", "UN"], roadSpeedUnit: "mph", callingCodes: ["692"] }, geometry: { type: "MultiPolygon", coordinates: [[[[169, 3.9], [173.53711, 5.70687], [169.29099, 15.77133], [159.04653, 10.59067], [169, 3.9]]]] } },
    { type: "Feature", properties: { iso1A2: "MK", iso1A3: "MKD", iso1N3: "807", wikidata: "Q221", nameEn: "North Macedonia", groups: ["039", "150", "UN"], callingCodes: ["389"] }, geometry: { type: "MultiPolygon", coordinates: [[[[22.34773, 42.31725], [22.29275, 42.34913], [22.29605, 42.37477], [22.16384, 42.32103], [22.02908, 42.29848], [21.94405, 42.34669], [21.91595, 42.30392], [21.84654, 42.3247], [21.77176, 42.2648], [21.70111, 42.23789], [21.58992, 42.25915], [21.52145, 42.24465], [21.50823, 42.27156], [21.43882, 42.2789], [21.43882, 42.23609], [21.38428, 42.24465], [21.30496, 42.1418], [21.29913, 42.13954], [21.31983, 42.10993], [21.22728, 42.08909], [21.16614, 42.19815], [21.11491, 42.20794], [20.75464, 42.05229], [20.76786, 41.91839], [20.68523, 41.85318], [20.59524, 41.8818], [20.55976, 41.87068], [20.57144, 41.7897], [20.53405, 41.78099], [20.51301, 41.72433], [20.52937, 41.69292], [20.51769, 41.65975], [20.55508, 41.58113], [20.52103, 41.56473], [20.45809, 41.5549], [20.45331, 41.51436], [20.49039, 41.49277], [20.51301, 41.442], [20.55976, 41.4087], [20.52119, 41.34381], [20.49432, 41.33679], [20.51068, 41.2323], [20.59715, 41.13644], [20.58546, 41.11179], [20.59832, 41.09066], [20.63454, 41.0889], [20.65558, 41.08009], [20.71634, 40.91781], [20.73504, 40.9081], [20.81567, 40.89662], [20.83671, 40.92752], [20.94305, 40.92399], [20.97693, 40.90103], [20.97887, 40.85475], [21.15262, 40.85546], [21.21105, 40.8855], [21.25779, 40.86165], [21.35595, 40.87578], [21.41555, 40.9173], [21.53007, 40.90759], [21.57448, 40.86076], [21.69601, 40.9429], [21.7556, 40.92525], [21.91102, 41.04786], [21.90869, 41.09191], [22.06527, 41.15617], [22.1424, 41.12449], [22.17629, 41.15969], [22.26744, 41.16409], [22.42285, 41.11921], [22.5549, 41.13065], [22.58295, 41.11568], [22.62852, 41.14385], [22.65306, 41.18168], [22.71266, 41.13945], [22.74538, 41.16321], [22.76408, 41.32225], [22.81199, 41.3398], [22.93334, 41.34104], [22.96331, 41.35782], [22.95513, 41.63265], [23.03342, 41.71034], [23.01239, 41.76527], [22.96682, 41.77137], [22.90254, 41.87587], [22.86749, 42.02275], [22.67701, 42.06614], [22.51224, 42.15457], [22.50289, 42.19527], [22.47251, 42.20393], [22.38136, 42.30339], [22.34773, 42.31725]]]] } },
    { type: "Feature", properties: { iso1A2: "ML", iso1A3: "MLI", iso1N3: "466", wikidata: "Q912", nameEn: "Mali", groups: ["011", "202", "002", "UN"], callingCodes: ["223"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-4.83423, 24.99935], [-6.57191, 25.0002], [-5.60725, 16.49919], [-5.33435, 16.33354], [-5.50165, 15.50061], [-9.32979, 15.50032], [-9.31106, 15.69412], [-9.33314, 15.7044], [-9.44673, 15.60553], [-9.40447, 15.4396], [-10.71721, 15.4223], [-10.90932, 15.11001], [-11.43483, 15.62339], [-11.70705, 15.51558], [-11.94903, 14.76143], [-12.23936, 14.76324], [-11.93043, 13.84505], [-12.06897, 13.71049], [-11.83345, 13.33333], [-11.63025, 13.39174], [-11.39935, 12.97808], [-11.37536, 12.40788], [-11.50006, 12.17826], [-11.24136, 12.01286], [-10.99758, 12.24634], [-10.80355, 12.1053], [-10.71897, 11.91552], [-10.30604, 12.24634], [-9.714, 12.0226], [-9.63938, 12.18312], [-9.32097, 12.29009], [-9.38067, 12.48446], [-9.13689, 12.50875], [-8.94784, 12.34842], [-8.80854, 11.66715], [-8.40058, 11.37466], [-8.66923, 10.99397], [-8.35083, 11.06234], [-8.2667, 10.91762], [-8.32614, 10.69273], [-8.22711, 10.41722], [-8.10207, 10.44649], [-7.9578, 10.2703], [-7.97971, 10.17117], [-7.92107, 10.15577], [-7.63048, 10.46334], [-7.54462, 10.40921], [-7.52261, 10.4655], [-7.44555, 10.44602], [-7.3707, 10.24677], [-7.13331, 10.24877], [-7.0603, 10.14711], [-7.00966, 10.15794], [-6.97444, 10.21644], [-7.01186, 10.25111], [-6.93921, 10.35291], [-6.68164, 10.35074], [-6.63541, 10.66893], [-6.52974, 10.59104], [-6.42847, 10.5694], [-6.40646, 10.69922], [-6.325, 10.68624], [-6.24795, 10.74248], [-6.1731, 10.46983], [-6.18851, 10.24244], [-5.99478, 10.19694], [-5.78124, 10.43952], [-5.65135, 10.46767], [-5.51058, 10.43177], [-5.46643, 10.56074], [-5.47083, 10.75329], [-5.41579, 10.84628], [-5.49284, 11.07538], [-5.32994, 11.13371], [-5.32553, 11.21578], [-5.25949, 11.24816], [-5.25509, 11.36905], [-5.20665, 11.43811], [-5.22867, 11.60421], [-5.29251, 11.61715], [-5.26389, 11.75728], [-5.40258, 11.8327], [-5.26389, 11.84778], [-5.07897, 11.97918], [-4.72893, 12.01579], [-4.70692, 12.06746], [-4.62987, 12.06531], [-4.62546, 12.13204], [-4.54841, 12.1385], [-4.57703, 12.19875], [-4.41412, 12.31922], [-4.47356, 12.71252], [-4.238, 12.71467], [-4.21819, 12.95722], [-4.34477, 13.12927], [-3.96501, 13.49778], [-3.90558, 13.44375], [-3.96282, 13.38164], [-3.7911, 13.36665], [-3.54454, 13.1781], [-3.4313, 13.1588], [-3.43507, 13.27272], [-3.23599, 13.29035], [-3.28396, 13.5422], [-3.26407, 13.70699], [-2.88189, 13.64921], [-2.90831, 13.81174], [-2.84667, 14.05532], [-2.66175, 14.14713], [-2.47587, 14.29671], [-2.10223, 14.14878], [-1.9992, 14.19011], [-1.97945, 14.47709], [-1.68083, 14.50023], [-1.32166, 14.72774], [-1.05875, 14.7921], [-0.72004, 15.08655], [-0.24673, 15.07805], [0.06588, 14.96961], [0.23859, 15.00135], [0.72632, 14.95898], [0.96711, 14.98275], [1.31275, 15.27978], [3.01806, 15.34571], [3.03134, 15.42221], [3.50368, 15.35934], [4.19893, 16.39923], [4.21787, 17.00118], [4.26762, 17.00432], [4.26651, 19.14224], [3.36082, 18.9745], [3.12501, 19.1366], [3.24648, 19.81703], [1.20992, 20.73533], [1.15698, 21.12843], [-4.83423, 24.99935]]]] } },
    { type: "Feature", properties: { iso1A2: "MM", iso1A3: "MMR", iso1N3: "104", wikidata: "Q836", nameEn: "Myanmar", aliases: ["Burma", "BU"], groups: ["035", "142", "UN"], callingCodes: ["95"] }, geometry: { type: "MultiPolygon", coordinates: [[[[92.62187, 21.87037], [92.59775, 21.6092], [92.68152, 21.28454], [92.60187, 21.24615], [92.55105, 21.3856], [92.43158, 21.37025], [92.37939, 21.47764], [92.20087, 21.337], [92.17752, 21.17445], [92.26071, 21.05697], [92.47409, 20.38654], [92.61042, 13.76986], [94.6371, 13.81803], [97.63455, 9.60854], [98.12555, 9.44056], [98.33094, 9.91973], [98.47298, 9.95782], [98.52291, 9.92389], [98.55174, 9.92804], [98.7391, 10.31488], [98.81944, 10.52761], [98.77275, 10.62548], [98.78511, 10.68351], [98.86819, 10.78336], [99.0069, 10.85485], [98.99701, 10.92962], [99.02337, 10.97217], [99.06938, 10.94857], [99.32756, 11.28545], [99.31573, 11.32081], [99.39485, 11.3925], [99.47598, 11.62434], [99.5672, 11.62732], [99.64108, 11.78948], [99.64891, 11.82699], [99.53424, 12.02317], [99.56445, 12.14805], [99.47519, 12.1353], [99.409, 12.60603], [99.29254, 12.68921], [99.18905, 12.84799], [99.18748, 12.9898], [99.10646, 13.05804], [99.12225, 13.19847], [99.20617, 13.20575], [99.16695, 13.72621], [98.97356, 14.04868], [98.56762, 14.37701], [98.24874, 14.83013], [98.18821, 15.13125], [98.22, 15.21327], [98.30446, 15.30667], [98.40522, 15.25268], [98.41906, 15.27103], [98.39351, 15.34177], [98.4866, 15.39154], [98.56027, 15.33471], [98.58598, 15.46821], [98.541, 15.65406], [98.59853, 15.87197], [98.57019, 16.04578], [98.69585, 16.13353], [98.8376, 16.11706], [98.92656, 16.36425], [98.84485, 16.42354], [98.68074, 16.27068], [98.63817, 16.47424], [98.57912, 16.55983], [98.5695, 16.62826], [98.51113, 16.64503], [98.51833, 16.676], [98.51472, 16.68521], [98.51579, 16.69433], [98.51043, 16.70107], [98.49713, 16.69022], [98.50253, 16.7139], [98.46994, 16.73613], [98.53833, 16.81934], [98.49603, 16.8446], [98.52624, 16.89979], [98.39441, 17.06266], [98.34566, 17.04822], [98.10439, 17.33847], [98.11185, 17.36829], [97.91829, 17.54504], [97.76407, 17.71595], [97.66794, 17.88005], [97.73723, 17.97912], [97.60841, 18.23846], [97.64116, 18.29778], [97.56219, 18.33885], [97.50383, 18.26844], [97.34522, 18.54596], [97.36444, 18.57138], [97.5258, 18.4939], [97.76752, 18.58097], [97.73836, 18.88478], [97.66487, 18.9371], [97.73654, 18.9812], [97.73797, 19.04261], [97.83479, 19.09972], [97.84024, 19.22217], [97.78606, 19.26769], [97.84186, 19.29526], [97.78769, 19.39429], [97.88423, 19.5041], [97.84715, 19.55782], [98.04364, 19.65755], [98.03314, 19.80941], [98.13829, 19.78541], [98.24884, 19.67876], [98.51182, 19.71303], [98.56065, 19.67807], [98.83661, 19.80931], [98.98679, 19.7419], [99.0735, 20.10298], [99.20328, 20.12877], [99.416, 20.08614], [99.52943, 20.14811], [99.5569, 20.20676], [99.46077, 20.36198], [99.46008, 20.39673], [99.68255, 20.32077], [99.81096, 20.33687], [99.86383, 20.44371], [99.88211, 20.44488], [99.88451, 20.44596], [99.89168, 20.44548], [99.89301, 20.44311], [99.89692, 20.44789], [99.90499, 20.4487], [99.91616, 20.44986], [99.95721, 20.46301], [100.08404, 20.36626], [100.1957, 20.68247], [100.36375, 20.82783], [100.51079, 20.82194], [100.60112, 20.8347], [100.64628, 20.88279], [100.50974, 20.88574], [100.55281, 21.02796], [100.63578, 21.05639], [100.72716, 21.31786], [100.80173, 21.2934], [101.00234, 21.39612], [101.16198, 21.52808], [101.15156, 21.56129], [101.11744, 21.77659], [100.87265, 21.67396], [100.72143, 21.51898], [100.57861, 21.45637], [100.4811, 21.46148], [100.42892, 21.54325], [100.35201, 21.53176], [100.25863, 21.47043], [100.18447, 21.51898], [100.1625, 21.48704], [100.12542, 21.50365], [100.10757, 21.59945], [100.17486, 21.65306], [100.12679, 21.70539], [100.04956, 21.66843], [99.98654, 21.71064], [99.94003, 21.82782], [99.99084, 21.97053], [99.96612, 22.05965], [99.85351, 22.04183], [99.47585, 22.13345], [99.33166, 22.09656], [99.1552, 22.15874], [99.19176, 22.16983], [99.17318, 22.18025], [99.28771, 22.4105], [99.37972, 22.50188], [99.38247, 22.57544], [99.31243, 22.73893], [99.45654, 22.85726], [99.43537, 22.94086], [99.54218, 22.90014], [99.52214, 23.08218], [99.34127, 23.13099], [99.25741, 23.09025], [99.04601, 23.12215], [99.05975, 23.16382], [98.88597, 23.18656], [98.92515, 23.29535], [98.93958, 23.31414], [98.87573, 23.33038], [98.92104, 23.36946], [98.87683, 23.48995], [98.82877, 23.47908], [98.80294, 23.5345], [98.88396, 23.59555], [98.81775, 23.694], [98.82933, 23.72921], [98.79607, 23.77947], [98.68209, 23.80492], [98.67797, 23.9644], [98.89632, 24.10612], [98.87998, 24.15624], [98.85319, 24.13042], [98.59256, 24.08371], [98.54476, 24.13119], [98.20666, 24.11406], [98.07806, 24.07988], [98.06703, 24.08028], [98.0607, 24.07812], [98.05671, 24.07961], [98.05302, 24.07408], [98.04709, 24.07616], [97.99583, 24.04932], [97.98691, 24.03897], [97.93951, 24.01953], [97.90998, 24.02094], [97.88616, 24.00463], [97.88414, 23.99405], [97.88814, 23.98605], [97.89683, 23.98389], [97.89676, 23.97931], [97.8955, 23.97758], [97.88811, 23.97446], [97.86545, 23.97723], [97.84328, 23.97603], [97.79416, 23.95663], [97.79456, 23.94836], [97.72302, 23.89288], [97.64667, 23.84574], [97.5247, 23.94032], [97.62363, 24.00506], [97.72903, 24.12606], [97.75305, 24.16902], [97.72799, 24.18883], [97.72998, 24.2302], [97.76799, 24.26365], [97.71941, 24.29652], [97.66723, 24.30027], [97.65624, 24.33781], [97.7098, 24.35658], [97.66998, 24.45288], [97.60029, 24.4401], [97.52757, 24.43748], [97.56286, 24.54535], [97.56525, 24.72838], [97.54675, 24.74202], [97.5542, 24.74943], [97.56383, 24.75535], [97.56648, 24.76475], [97.64354, 24.79171], [97.70181, 24.84557], [97.73127, 24.83015], [97.76481, 24.8289], [97.79949, 24.85655], [97.72903, 24.91332], [97.72216, 25.08508], [97.77023, 25.11492], [97.83614, 25.2715], [97.92541, 25.20815], [98.14925, 25.41547], [98.12591, 25.50722], [98.18084, 25.56298], [98.16848, 25.62739], [98.25774, 25.6051], [98.31268, 25.55307], [98.40606, 25.61129], [98.54064, 25.85129], [98.63128, 25.79937], [98.70818, 25.86241], [98.60763, 26.01512], [98.57085, 26.11547], [98.63128, 26.15492], [98.66884, 26.09165], [98.7329, 26.17218], [98.67797, 26.24487], [98.72741, 26.36183], [98.77547, 26.61994], [98.7333, 26.85615], [98.69582, 27.56499], [98.43353, 27.67086], [98.42529, 27.55404], [98.32641, 27.51385], [98.13964, 27.9478], [98.15337, 28.12114], [97.90069, 28.3776], [97.79632, 28.33168], [97.70705, 28.5056], [97.56835, 28.55628], [97.50518, 28.49716], [97.47085, 28.2688], [97.41729, 28.29783], [97.34547, 28.21385], [97.31292, 28.06784], [97.35412, 28.06663], [97.38845, 28.01329], [97.35824, 27.87256], [97.29919, 27.92233], [96.90112, 27.62149], [96.91431, 27.45752], [97.17422, 27.14052], [97.14675, 27.09041], [96.89132, 27.17474], [96.85287, 27.2065], [96.88445, 27.25046], [96.73888, 27.36638], [96.55761, 27.29928], [96.40779, 27.29818], [96.15591, 27.24572], [96.04949, 27.19428], [95.93002, 27.04149], [95.81603, 27.01335], [95.437, 26.7083], [95.30339, 26.65372], [95.23513, 26.68499], [95.05798, 26.45408], [95.12801, 26.38397], [95.11428, 26.1019], [95.18556, 26.07338], [94.80117, 25.49359], [94.68032, 25.47003], [94.57458, 25.20318], [94.74212, 25.13606], [94.73937, 25.00545], [94.60204, 24.70889], [94.5526, 24.70764], [94.50729, 24.59281], [94.45279, 24.56656], [94.32362, 24.27692], [94.30215, 24.23752], [94.14081, 23.83333], [93.92089, 23.95812], [93.80279, 23.92549], [93.75952, 24.0003], [93.62871, 24.00922], [93.50616, 23.94432], [93.46633, 23.97067], [93.41415, 24.07854], [93.34735, 24.10151], [93.32351, 24.04468], [93.36059, 23.93176], [93.3908, 23.92925], [93.3908, 23.7622], [93.43475, 23.68299], [93.38805, 23.4728], [93.39981, 23.38828], [93.38781, 23.36139], [93.36862, 23.35426], [93.38478, 23.13698], [93.2878, 23.00464], [93.12988, 23.05772], [93.134, 22.92498], [93.09417, 22.69459], [93.134, 22.59573], [93.11477, 22.54374], [93.13537, 22.45873], [93.18206, 22.43716], [93.19991, 22.25425], [93.14224, 22.24535], [93.15734, 22.18687], [93.04885, 22.20595], [92.99255, 22.05965], [92.99804, 21.98964], [92.93899, 22.02656], [92.89504, 21.95143], [92.86208, 22.05456], [92.70416, 22.16017], [92.67532, 22.03547], [92.60949, 21.97638], [92.62187, 21.87037]]]] } },
    { type: "Feature", properties: { iso1A2: "MN", iso1A3: "MNG", iso1N3: "496", wikidata: "Q711", nameEn: "Mongolia", groups: ["030", "142", "UN"], callingCodes: ["976"] }, geometry: { type: "MultiPolygon", coordinates: [[[[102.14032, 51.35566], [101.5044, 51.50467], [101.39085, 51.45753], [100.61116, 51.73028], [99.89203, 51.74903], [99.75578, 51.90108], [99.27888, 51.96876], [98.87768, 52.14563], [98.74142, 51.8637], [98.33222, 51.71832], [98.22053, 51.46579], [98.05257, 51.46696], [97.83305, 51.00248], [98.01472, 50.86652], [97.9693, 50.78044], [98.06393, 50.61262], [98.31373, 50.4996], [98.29481, 50.33561], [97.85197, 49.91339], [97.76871, 49.99861], [97.56432, 49.92801], [97.56811, 49.84265], [97.24639, 49.74737], [96.97388, 49.88413], [95.80056, 50.04239], [95.74757, 49.97915], [95.02465, 49.96941], [94.97166, 50.04725], [94.6121, 50.04239], [94.49477, 50.17832], [94.39258, 50.22193], [94.30823, 50.57498], [92.99595, 50.63183], [93.01109, 50.79001], [92.44714, 50.78762], [92.07173, 50.69585], [91.86048, 50.73734], [89.59711, 49.90851], [89.70687, 49.72535], [88.82499, 49.44808], [88.42449, 49.48821], [88.17223, 49.46934], [88.15543, 49.30314], [87.98977, 49.18147], [87.81333, 49.17354], [87.88171, 48.95853], [87.73822, 48.89582], [88.0788, 48.71436], [87.96361, 48.58478], [88.58939, 48.34531], [88.58316, 48.21893], [88.8011, 48.11302], [88.93186, 48.10263], [89.0711, 47.98528], [89.55453, 48.0423], [89.76624, 47.82745], [90.06512, 47.88177], [90.10871, 47.7375], [90.33598, 47.68303], [90.48854, 47.41826], [90.48542, 47.30438], [90.76108, 46.99399], [90.84035, 46.99525], [91.03649, 46.72916], [91.0147, 46.58171], [91.07696, 46.57315], [90.89639, 46.30711], [90.99672, 46.14207], [91.03026, 46.04194], [90.70907, 45.73437], [90.65114, 45.49314], [90.89169, 45.19667], [91.64048, 45.07408], [93.51161, 44.95964], [94.10003, 44.71016], [94.71959, 44.35284], [95.01191, 44.25274], [95.39772, 44.2805], [95.32891, 44.02407], [95.52594, 43.99353], [95.89543, 43.2528], [96.35658, 42.90363], [96.37926, 42.72055], [97.1777, 42.7964], [99.50671, 42.56535], [100.33297, 42.68231], [100.84979, 42.67087], [101.80515, 42.50074], [102.07645, 42.22519], [102.72403, 42.14675], [103.92804, 41.78246], [104.52258, 41.8706], [104.51667, 41.66113], [105.0123, 41.63188], [106.76517, 42.28741], [107.24774, 42.36107], [107.29755, 42.41395], [107.49681, 42.46221], [107.57258, 42.40898], [108.84489, 42.40246], [109.00679, 42.45302], [109.452, 42.44842], [109.89402, 42.63111], [110.08401, 42.6411], [110.4327, 42.78293], [111.0149, 43.3289], [111.59087, 43.51207], [111.79758, 43.6637], [111.93776, 43.68709], [111.96289, 43.81596], [111.40498, 44.3461], [111.76275, 44.98032], [111.98695, 45.09074], [112.4164, 45.06858], [112.74662, 44.86297], [113.70918, 44.72891], [114.5166, 45.27189], [114.54801, 45.38337], [114.74612, 45.43585], [114.94546, 45.37377], [115.60329, 45.44717], [116.16989, 45.68603], [116.27366, 45.78637], [116.24012, 45.8778], [116.26678, 45.96479], [116.58612, 46.30211], [116.75551, 46.33083], [116.83166, 46.38637], [117.36609, 46.36335], [117.41782, 46.57862], [117.60748, 46.59771], [117.69554, 46.50991], [118.30534, 46.73519], [118.78747, 46.68689], [118.8337, 46.77742], [118.89974, 46.77139], [118.92616, 46.72765], [119.00541, 46.74273], [119.10448, 46.65516], [119.24978, 46.64761], [119.32827, 46.61433], [119.42827, 46.63783], [119.65265, 46.62342], [119.68127, 46.59015], [119.77373, 46.62947], [119.80455, 46.67631], [119.89261, 46.66423], [119.91242, 46.90091], [119.85518, 46.92196], [119.71209, 47.19192], [119.62403, 47.24575], [119.56019, 47.24874], [119.54918, 47.29505], [119.31964, 47.42617], [119.35892, 47.48104], [119.13995, 47.53997], [119.12343, 47.66458], [118.7564, 47.76947], [118.55766, 47.99277], [118.29654, 48.00246], [118.22677, 48.03853], [118.11009, 48.04], [118.03676, 48.00982], [117.80196, 48.01661], [117.50181, 47.77216], [117.37875, 47.63627], [116.9723, 47.87285], [116.67405, 47.89039], [116.4465, 47.83662], [116.21879, 47.88505], [115.94296, 47.67741], [115.57128, 47.91988], [115.52082, 48.15367], [115.811, 48.25699], [115.78876, 48.51781], [116.06565, 48.81716], [116.03781, 48.87014], [116.71193, 49.83813], [116.62502, 49.92919], [116.22402, 50.04477], [115.73602, 49.87688], [115.26068, 49.97367], [114.9703, 50.19254], [114.325, 50.28098], [113.20216, 49.83356], [113.02647, 49.60772], [110.64493, 49.1816], [110.39891, 49.25083], [110.24373, 49.16676], [109.51325, 49.22859], [109.18017, 49.34709], [108.53969, 49.32325], [108.27937, 49.53167], [107.95387, 49.66659], [107.96116, 49.93191], [107.36407, 49.97612], [107.1174, 50.04239], [107.00007, 50.1977], [106.80326, 50.30177], [106.58373, 50.34044], [106.51122, 50.34408], [106.49628, 50.32436], [106.47156, 50.31909], [106.07865, 50.33474], [106.05562, 50.40582], [105.32528, 50.4648], [103.70343, 50.13952], [102.71178, 50.38873], [102.32194, 50.67982], [102.14032, 51.35566]]]] } },
    { type: "Feature", properties: { iso1A2: "MO", iso1A3: "MAC", iso1N3: "446", wikidata: "Q14773", nameEn: "Macau", aliases: ["Macao"], country: "CN", groups: ["030", "142", "UN"], driveSide: "left", callingCodes: ["853"] }, geometry: { type: "MultiPolygon", coordinates: [[[[113.54942, 22.14519], [113.54839, 22.10909], [113.57191, 22.07696], [113.63011, 22.10782], [113.60504, 22.20464], [113.57123, 22.20416], [113.56865, 22.20973], [113.5508, 22.21672], [113.54333, 22.21688], [113.54093, 22.21314], [113.53593, 22.2137], [113.53301, 22.21235], [113.53552, 22.20607], [113.52659, 22.18271], [113.54093, 22.15497], [113.54942, 22.14519]]]] } },
    { type: "Feature", properties: { iso1A2: "MP", iso1A3: "MNP", iso1N3: "580", wikidata: "Q16644", nameEn: "Northern Mariana Islands", aliases: ["US-MP"], country: "US", groups: ["Q1352230", "Q153732", "057", "009", "UN"], roadSpeedUnit: "mph", callingCodes: ["1 670"] }, geometry: { type: "MultiPolygon", coordinates: [[[[135.52896, 14.32623], [152.19114, 13.63487], [145.05972, 21.28731], [135.52896, 14.32623]]]] } },
    { type: "Feature", properties: { iso1A2: "MQ", iso1A3: "MTQ", iso1N3: "474", wikidata: "Q17054", nameEn: "Martinique", country: "FR", groups: ["Q3320166", "EU", "029", "003", "419", "019", "UN"], callingCodes: ["596"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-59.95997, 14.20285], [-61.07821, 15.25109], [-61.69315, 14.26451], [-59.95997, 14.20285]]]] } },
    { type: "Feature", properties: { iso1A2: "MR", iso1A3: "MRT", iso1N3: "478", wikidata: "Q1025", nameEn: "Mauritania", groups: ["011", "202", "002", "UN"], callingCodes: ["222"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-5.60725, 16.49919], [-6.57191, 25.0002], [-4.83423, 24.99935], [-8.66674, 27.31569], [-8.66721, 25.99918], [-12.0002, 25.9986], [-12.00251, 23.4538], [-12.14969, 23.41935], [-12.36213, 23.3187], [-12.5741, 23.28975], [-13.00412, 23.02297], [-13.10753, 22.89493], [-13.15313, 22.75649], [-13.08438, 22.53866], [-13.01525, 21.33343], [-16.95474, 21.33997], [-16.99806, 21.12142], [-17.0357, 21.05368], [-17.0396, 20.9961], [-17.06781, 20.92697], [-17.0695, 20.85742], [-17.0471, 20.76408], [-17.15288, 16.07139], [-16.50854, 16.09032], [-16.48967, 16.0496], [-16.44814, 16.09753], [-16.4429, 16.20605], [-16.27016, 16.51565], [-15.6509, 16.50315], [-15.00557, 16.64997], [-14.32144, 16.61495], [-13.80075, 16.13961], [-13.43135, 16.09022], [-13.11029, 15.52116], [-12.23936, 14.76324], [-11.94903, 14.76143], [-11.70705, 15.51558], [-11.43483, 15.62339], [-10.90932, 15.11001], [-10.71721, 15.4223], [-9.40447, 15.4396], [-9.44673, 15.60553], [-9.33314, 15.7044], [-9.31106, 15.69412], [-9.32979, 15.50032], [-5.50165, 15.50061], [-5.33435, 16.33354], [-5.60725, 16.49919]]]] } },
    { type: "Feature", properties: { iso1A2: "MS", iso1A3: "MSR", iso1N3: "500", wikidata: "Q13353", nameEn: "Montserrat", country: "GB", groups: ["BOTS", "029", "003", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["1 664"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-61.91508, 16.51165], [-62.1023, 16.97277], [-62.58307, 16.68909], [-61.91508, 16.51165]]]] } },
    { type: "Feature", properties: { iso1A2: "MT", iso1A3: "MLT", iso1N3: "470", wikidata: "Q233", nameEn: "Malta", groups: ["EU", "039", "150", "UN"], driveSide: "left", callingCodes: ["356"] }, geometry: { type: "MultiPolygon", coordinates: [[[[15.70991, 35.79901], [14.07544, 36.41525], [13.27636, 35.20764], [15.70991, 35.79901]]]] } },
    { type: "Feature", properties: { iso1A2: "MU", iso1A3: "MUS", iso1N3: "480", wikidata: "Q1027", nameEn: "Mauritius", groups: ["014", "202", "002", "UN"], driveSide: "left", callingCodes: ["230"] }, geometry: { type: "MultiPolygon", coordinates: [[[[56.09755, -9.55401], [57.50644, -31.92637], [68.4673, -19.15185], [56.09755, -9.55401]]]] } },
    { type: "Feature", properties: { iso1A2: "MV", iso1A3: "MDV", iso1N3: "462", wikidata: "Q826", nameEn: "Maldives", groups: ["034", "142", "UN"], driveSide: "left", callingCodes: ["960"] }, geometry: { type: "MultiPolygon", coordinates: [[[[71.9161, 8.55531], [72.57428, -3.7623], [76.59015, 5.591], [71.9161, 8.55531]]]] } },
    { type: "Feature", properties: { iso1A2: "MW", iso1A3: "MWI", iso1N3: "454", wikidata: "Q1020", nameEn: "Malawi", groups: ["014", "202", "002", "UN"], driveSide: "left", callingCodes: ["265"] }, geometry: { type: "MultiPolygon", coordinates: [[[[33.48052, -9.62442], [33.31581, -9.48554], [33.14925, -9.49322], [32.99397, -9.36712], [32.95389, -9.40138], [33.00476, -9.5133], [33.00256, -9.63053], [33.05485, -9.61316], [33.10163, -9.66525], [33.12144, -9.58929], [33.2095, -9.61099], [33.31517, -9.82364], [33.36581, -9.81063], [33.37902, -9.9104], [33.31297, -10.05133], [33.53863, -10.20148], [33.54797, -10.36077], [33.70675, -10.56896], [33.47636, -10.78465], [33.28022, -10.84428], [33.25998, -10.88862], [33.39697, -11.15296], [33.29267, -11.3789], [33.29267, -11.43536], [33.23663, -11.40637], [33.24252, -11.59302], [33.32692, -11.59248], [33.33937, -11.91252], [33.25998, -12.14242], [33.3705, -12.34931], [33.47636, -12.32498], [33.54485, -12.35996], [33.37517, -12.54085], [33.28177, -12.54692], [33.18837, -12.61377], [33.05917, -12.59554], [32.94397, -12.76868], [32.96733, -12.88251], [33.02181, -12.88707], [32.98289, -13.12671], [33.0078, -13.19492], [32.86113, -13.47292], [32.84176, -13.52794], [32.73683, -13.57682], [32.68436, -13.55769], [32.66468, -13.60019], [32.68654, -13.64268], [32.7828, -13.64805], [32.84528, -13.71576], [32.76962, -13.77224], [32.79015, -13.80755], [32.88985, -13.82956], [32.99042, -13.95689], [33.02977, -14.05022], [33.07568, -13.98447], [33.16749, -13.93992], [33.24249, -14.00019], [33.66677, -14.61306], [33.7247, -14.4989], [33.88503, -14.51652], [33.92898, -14.47929], [34.08588, -14.48893], [34.18733, -14.43823], [34.22355, -14.43607], [34.34453, -14.3985], [34.35843, -14.38652], [34.39277, -14.39467], [34.4192, -14.43191], [34.44641, -14.47746], [34.45053, -14.49873], [34.47628, -14.53363], [34.48932, -14.53646], [34.49636, -14.55091], [34.52366, -14.5667], [34.53962, -14.59776], [34.55112, -14.64494], [34.53516, -14.67782], [34.52057, -14.68263], [34.54503, -14.74672], [34.567, -14.77345], [34.61522, -14.99583], [34.57503, -15.30619], [34.43126, -15.44778], [34.44981, -15.60864], [34.25195, -15.90321], [34.43126, -16.04737], [34.40344, -16.20923], [35.04805, -16.83167], [35.13771, -16.81687], [35.17017, -16.93521], [35.04805, -17.00027], [35.0923, -17.13235], [35.3062, -17.1244], [35.27065, -16.93817], [35.30929, -16.82871], [35.27219, -16.69402], [35.14235, -16.56812], [35.25828, -16.4792], [35.30157, -16.2211], [35.43355, -16.11371], [35.52365, -16.15414], [35.70107, -16.10147], [35.80487, -16.03907], [35.85303, -15.41913], [35.78799, -15.17428], [35.91812, -14.89514], [35.87212, -14.89478], [35.86945, -14.67481], [35.5299, -14.27714], [35.47989, -14.15594], [34.86229, -13.48958], [34.60253, -13.48487], [34.37831, -12.17408], [34.46088, -12.0174], [34.70739, -12.15652], [34.82903, -12.04837], [34.57917, -11.87849], [34.64241, -11.57499], [34.96296, -11.57354], [34.91153, -11.39799], [34.79375, -11.32245], [34.63305, -11.11731], [34.61161, -11.01611], [34.67047, -10.93796], [34.65946, -10.6828], [34.57581, -10.56271], [34.51911, -10.12279], [34.54499, -10.0678], [34.03865, -9.49398], [33.95829, -9.54066], [33.9638, -9.62206], [33.93298, -9.71647], [33.76677, -9.58516], [33.48052, -9.62442]]]] } },
    { type: "Feature", properties: { iso1A2: "MX", iso1A3: "MEX", iso1N3: "484", wikidata: "Q96", nameEn: "Mexico", groups: ["013", "003", "419", "019", "UN"], callingCodes: ["52"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-117.1243, 32.53427], [-118.48109, 32.5991], [-120.12904, 18.41089], [-92.37213, 14.39277], [-92.2261, 14.53423], [-92.1454, 14.6804], [-92.18161, 14.84147], [-92.1423, 14.88647], [-92.1454, 14.98143], [-92.0621, 15.07406], [-92.20983, 15.26077], [-91.73182, 16.07371], [-90.44567, 16.07573], [-90.40499, 16.40524], [-90.61212, 16.49832], [-90.69064, 16.70697], [-91.04436, 16.92175], [-91.43809, 17.25373], [-90.99199, 17.25192], [-90.98678, 17.81655], [-89.14985, 17.81563], [-89.15105, 17.95104], [-89.03839, 18.0067], [-88.8716, 17.89535], [-88.71505, 18.0707], [-88.48242, 18.49164], [-88.3268, 18.49048], [-88.29909, 18.47591], [-88.26593, 18.47617], [-88.03238, 18.41778], [-88.03165, 18.16657], [-87.90671, 18.15213], [-87.87604, 18.18313], [-87.86657, 18.19971], [-87.85693, 18.18266], [-87.84815, 18.18511], [-86.92368, 17.61462], [-85.9092, 21.8218], [-96.92418, 25.97377], [-97.13927, 25.96583], [-97.35946, 25.92189], [-97.37332, 25.83854], [-97.42511, 25.83969], [-97.45669, 25.86874], [-97.49828, 25.89877], [-97.52025, 25.88518], [-97.66511, 26.01708], [-97.95155, 26.0625], [-97.97017, 26.05232], [-98.24603, 26.07191], [-98.27075, 26.09457], [-98.30491, 26.10475], [-98.35126, 26.15129], [-99.00546, 26.3925], [-99.03053, 26.41249], [-99.08477, 26.39849], [-99.53573, 27.30926], [-99.49744, 27.43746], [-99.482, 27.47128], [-99.48045, 27.49016], [-99.50208, 27.50021], [-99.52955, 27.49747], [-99.51478, 27.55836], [-99.55409, 27.61314], [-100.50029, 28.66117], [-100.51222, 28.70679], [-100.5075, 28.74066], [-100.52313, 28.75598], [-100.59809, 28.88197], [-100.63689, 28.90812], [-100.67294, 29.09744], [-100.79696, 29.24688], [-100.87982, 29.296], [-100.94056, 29.33371], [-100.94579, 29.34523], [-100.96725, 29.3477], [-101.01128, 29.36947], [-101.05686, 29.44738], [-101.47277, 29.7744], [-102.60596, 29.8192], [-103.15787, 28.93865], [-104.37752, 29.54255], [-104.39363, 29.55396], [-104.3969, 29.57105], [-104.5171, 29.64671], [-104.77674, 30.4236], [-106.00363, 31.39181], [-106.09025, 31.40569], [-106.20346, 31.46305], [-106.23711, 31.51262], [-106.24612, 31.54193], [-106.28084, 31.56173], [-106.30305, 31.62154], [-106.33419, 31.66303], [-106.34864, 31.69663], [-106.3718, 31.71165], [-106.38003, 31.73151], [-106.41773, 31.75196], [-106.43419, 31.75478], [-106.45244, 31.76523], [-106.46726, 31.75998], [-106.47298, 31.75054], [-106.48815, 31.74769], [-106.50111, 31.75714], [-106.50962, 31.76155], [-106.51251, 31.76922], [-106.52266, 31.77509], [-106.529, 31.784], [-108.20899, 31.78534], [-108.20979, 31.33316], [-111.07523, 31.33232], [-114.82011, 32.49609], [-114.79524, 32.55731], [-114.81141, 32.55543], [-114.80584, 32.62028], [-114.76736, 32.64094], [-114.71871, 32.71894], [-115.88053, 32.63624], [-117.1243, 32.53427]]]] } },
    { type: "Feature", properties: { iso1A2: "MY", iso1A3: "MYS", iso1N3: "458", wikidata: "Q833", nameEn: "Malaysia" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "MZ", iso1A3: "MOZ", iso1N3: "508", wikidata: "Q1029", nameEn: "Mozambique", groups: ["014", "202", "002", "UN"], driveSide: "left", callingCodes: ["258"] }, geometry: { type: "MultiPolygon", coordinates: [[[[40.74206, -10.25691], [40.44265, -10.4618], [40.00295, -10.80255], [39.58249, -10.96043], [39.24395, -11.17433], [38.88996, -11.16978], [38.47258, -11.4199], [38.21598, -11.27289], [37.93618, -11.26228], [37.8388, -11.3123], [37.76614, -11.53352], [37.3936, -11.68949], [36.80309, -11.56836], [36.62068, -11.72884], [36.19094, -11.70008], [36.19094, -11.57593], [35.82767, -11.41081], [35.63599, -11.55927], [34.96296, -11.57354], [34.64241, -11.57499], [34.57917, -11.87849], [34.82903, -12.04837], [34.70739, -12.15652], [34.46088, -12.0174], [34.37831, -12.17408], [34.60253, -13.48487], [34.86229, -13.48958], [35.47989, -14.15594], [35.5299, -14.27714], [35.86945, -14.67481], [35.87212, -14.89478], [35.91812, -14.89514], [35.78799, -15.17428], [35.85303, -15.41913], [35.80487, -16.03907], [35.70107, -16.10147], [35.52365, -16.15414], [35.43355, -16.11371], [35.30157, -16.2211], [35.25828, -16.4792], [35.14235, -16.56812], [35.27219, -16.69402], [35.30929, -16.82871], [35.27065, -16.93817], [35.3062, -17.1244], [35.0923, -17.13235], [35.04805, -17.00027], [35.17017, -16.93521], [35.13771, -16.81687], [35.04805, -16.83167], [34.40344, -16.20923], [34.43126, -16.04737], [34.25195, -15.90321], [34.44981, -15.60864], [34.43126, -15.44778], [34.57503, -15.30619], [34.61522, -14.99583], [34.567, -14.77345], [34.54503, -14.74672], [34.52057, -14.68263], [34.53516, -14.67782], [34.55112, -14.64494], [34.53962, -14.59776], [34.52366, -14.5667], [34.49636, -14.55091], [34.48932, -14.53646], [34.47628, -14.53363], [34.45053, -14.49873], [34.44641, -14.47746], [34.4192, -14.43191], [34.39277, -14.39467], [34.35843, -14.38652], [34.34453, -14.3985], [34.22355, -14.43607], [34.18733, -14.43823], [34.08588, -14.48893], [33.92898, -14.47929], [33.88503, -14.51652], [33.7247, -14.4989], [33.66677, -14.61306], [33.24249, -14.00019], [30.22098, -14.99447], [30.41902, -15.62269], [30.42568, -15.9962], [30.91597, -15.99924], [30.97761, -16.05848], [31.13171, -15.98019], [31.30563, -16.01193], [31.42451, -16.15154], [31.67988, -16.19595], [31.90223, -16.34388], [31.91324, -16.41569], [32.02772, -16.43892], [32.28529, -16.43892], [32.42838, -16.4727], [32.71017, -16.59932], [32.69917, -16.66893], [32.78943, -16.70267], [32.97655, -16.70689], [32.91051, -16.89446], [32.84113, -16.92259], [32.96554, -17.11971], [33.00517, -17.30477], [33.0426, -17.3468], [32.96554, -17.48964], [32.98536, -17.55891], [33.0492, -17.60298], [32.94133, -17.99705], [33.03159, -18.35054], [33.02278, -18.4696], [32.88629, -18.51344], [32.88629, -18.58023], [32.95013, -18.69079], [32.9017, -18.7992], [32.82465, -18.77419], [32.70137, -18.84712], [32.73439, -18.92628], [32.69917, -18.94293], [32.72118, -19.02204], [32.84006, -19.0262], [32.87088, -19.09279], [32.85107, -19.29238], [32.77966, -19.36098], [32.78282, -19.47513], [32.84446, -19.48343], [32.84666, -19.68462], [32.95013, -19.67219], [33.06461, -19.77787], [33.01178, -20.02007], [32.93032, -20.03868], [32.85987, -20.16686], [32.85987, -20.27841], [32.66174, -20.56106], [32.55167, -20.56312], [32.48122, -20.63319], [32.51644, -20.91929], [32.37115, -21.133], [32.48236, -21.32873], [32.41234, -21.31246], [31.38336, -22.36919], [31.30611, -22.422], [31.55779, -23.176], [31.56539, -23.47268], [31.67942, -23.60858], [31.70223, -23.72695], [31.77445, -23.90082], [31.87707, -23.95293], [31.90368, -24.18892], [31.9835, -24.29983], [32.03196, -25.10785], [32.01676, -25.38117], [31.97875, -25.46356], [32.00631, -25.65044], [31.92649, -25.84216], [31.974, -25.95387], [32.00916, -25.999], [32.08599, -26.00978], [32.10435, -26.15656], [32.07352, -26.40185], [32.13409, -26.5317], [32.13315, -26.84345], [32.19409, -26.84032], [32.22302, -26.84136], [32.29584, -26.852], [32.35222, -26.86027], [34.51034, -26.91792], [42.99868, -12.65261], [40.74206, -10.25691]]]] } },
    { type: "Feature", properties: { iso1A2: "NA", iso1A3: "NAM", iso1N3: "516", wikidata: "Q1030", nameEn: "Namibia", groups: ["018", "202", "002", "UN"], driveSide: "left", callingCodes: ["264"] }, geometry: { type: "MultiPolygon", coordinates: [[[[14.28743, -17.38814], [13.95896, -17.43141], [13.36212, -16.98048], [12.97145, -16.98567], [12.52111, -17.24495], [12.07076, -17.15165], [11.75063, -17.25013], [10.5065, -17.25284], [12.51595, -32.27486], [16.45332, -28.63117], [16.46592, -28.57126], [16.59922, -28.53246], [16.90446, -28.057], [17.15405, -28.08573], [17.4579, -28.68718], [18.99885, -28.89165], [19.99882, -28.42622], [19.99817, -24.76768], [19.99912, -21.99991], [20.99751, -22.00026], [20.99904, -18.31743], [21.45556, -18.31795], [23.0996, -18.00075], [23.29618, -17.99855], [23.61088, -18.4881], [24.19416, -18.01919], [24.40577, -17.95726], [24.57485, -18.07151], [24.6303, -17.9863], [24.71887, -17.9218], [24.73364, -17.89338], [24.95586, -17.79674], [25.05895, -17.84452], [25.16882, -17.78253], [25.26433, -17.79571], [25.00198, -17.58221], [24.70864, -17.49501], [24.5621, -17.52963], [24.38712, -17.46818], [24.32811, -17.49082], [24.23619, -17.47489], [23.47474, -17.62877], [21.42741, -18.02787], [21.14283, -17.94318], [18.84226, -17.80375], [18.39229, -17.38927], [14.28743, -17.38814]]]] } },
    { type: "Feature", properties: { iso1A2: "NC", iso1A3: "NCL", iso1N3: "540", wikidata: "Q33788", nameEn: "New Caledonia", country: "FR", groups: ["EU", "Q1451600", "054", "009", "UN"], callingCodes: ["687"] }, geometry: { type: "MultiPolygon", coordinates: [[[[159.77159, -28.41151], [174.245, -23.1974], [156.73836, -14.50464], [159.77159, -28.41151]]]] } },
    { type: "Feature", properties: { iso1A2: "NE", iso1A3: "NER", iso1N3: "562", wikidata: "Q1032", nameEn: "Niger", aliases: ["RN"], groups: ["011", "202", "002", "UN"], callingCodes: ["227"] }, geometry: { type: "MultiPolygon", coordinates: [[[[14.22918, 22.61719], [13.5631, 23.16574], [11.96886, 23.51735], [7.48273, 20.87258], [7.38361, 20.79165], [5.8153, 19.45101], [4.26651, 19.14224], [4.26762, 17.00432], [4.21787, 17.00118], [4.19893, 16.39923], [3.50368, 15.35934], [3.03134, 15.42221], [3.01806, 15.34571], [1.31275, 15.27978], [0.96711, 14.98275], [0.72632, 14.95898], [0.23859, 15.00135], [0.16936, 14.51654], [0.38051, 14.05575], [0.61924, 13.68491], [0.77377, 13.6866], [0.77637, 13.64442], [0.99514, 13.5668], [1.02813, 13.46635], [1.20088, 13.38951], [1.24429, 13.39373], [1.28509, 13.35488], [1.24516, 13.33968], [1.21217, 13.37853], [1.18873, 13.31771], [0.99253, 13.37515], [0.99167, 13.10727], [2.26349, 12.41915], [2.05785, 12.35539], [2.39723, 11.89473], [2.45824, 11.98672], [2.39657, 12.10952], [2.37783, 12.24804], [2.6593, 12.30631], [2.83978, 12.40585], [3.25352, 12.01467], [3.31613, 11.88495], [3.48187, 11.86092], [3.59375, 11.70269], [3.61075, 11.69181], [3.67988, 11.75429], [3.67122, 11.80865], [3.63063, 11.83042], [3.61955, 11.91847], [3.67775, 11.97599], [3.63136, 12.11826], [3.66364, 12.25884], [3.65111, 12.52223], [3.94339, 12.74979], [4.10006, 12.98862], [4.14367, 13.17189], [4.14186, 13.47586], [4.23456, 13.47725], [4.4668, 13.68286], [4.87425, 13.78], [4.9368, 13.7345], [5.07396, 13.75052], [5.21026, 13.73627], [5.27797, 13.75474], [5.35437, 13.83567], [5.52957, 13.8845], [6.15771, 13.64564], [6.27411, 13.67835], [6.43053, 13.6006], [6.69617, 13.34057], [6.94445, 12.99825], [7.0521, 13.00076], [7.12676, 13.02445], [7.22399, 13.1293], [7.39241, 13.09717], [7.81085, 13.34902], [8.07997, 13.30847], [8.25185, 13.20369], [8.41853, 13.06166], [8.49493, 13.07519], [8.60431, 13.01768], [8.64251, 12.93985], [8.97413, 12.83661], [9.65995, 12.80614], [10.00373, 13.18171], [10.19993, 13.27129], [10.46731, 13.28819], [10.66004, 13.36422], [11.4535, 13.37773], [11.88236, 13.2527], [12.04209, 13.14452], [12.16189, 13.10056], [12.19315, 13.12423], [12.47095, 13.06673], [12.58033, 13.27805], [12.6793, 13.29157], [12.87376, 13.48919], [13.05085, 13.53984], [13.19844, 13.52802], [13.33213, 13.71195], [13.6302, 13.71094], [13.47559, 14.40881], [13.48259, 14.46704], [13.68573, 14.55276], [13.67878, 14.64013], [13.809, 14.72915], [13.78991, 14.87519], [13.86301, 15.04043], [14.37425, 15.72591], [15.50373, 16.89649], [15.6032, 18.77402], [15.75098, 19.93002], [15.99632, 20.35364], [15.6721, 20.70069], [15.59841, 20.74039], [15.56004, 20.79488], [15.55382, 20.86507], [15.57248, 20.92138], [15.62515, 20.95395], [15.28332, 21.44557], [15.20213, 21.49365], [15.19692, 21.99339], [14.99751, 23.00539], [14.22918, 22.61719]]]] } },
    { type: "Feature", properties: { iso1A2: "NF", iso1A3: "NFK", iso1N3: "574", wikidata: "Q31057", nameEn: "Norfolk Island", country: "AU", groups: ["053", "009", "UN"], driveSide: "left", callingCodes: ["672 3"] }, geometry: { type: "MultiPolygon", coordinates: [[[[169.82316, -28.16667], [166.29505, -28.29175], [167.94076, -30.60745], [169.82316, -28.16667]]]] } },
    { type: "Feature", properties: { iso1A2: "NG", iso1A3: "NGA", iso1N3: "566", wikidata: "Q1033", nameEn: "Nigeria", groups: ["011", "202", "002", "UN"], callingCodes: ["234"] }, geometry: { type: "MultiPolygon", coordinates: [[[[6.15771, 13.64564], [5.52957, 13.8845], [5.35437, 13.83567], [5.27797, 13.75474], [5.21026, 13.73627], [5.07396, 13.75052], [4.9368, 13.7345], [4.87425, 13.78], [4.4668, 13.68286], [4.23456, 13.47725], [4.14186, 13.47586], [4.14367, 13.17189], [4.10006, 12.98862], [3.94339, 12.74979], [3.65111, 12.52223], [3.66364, 12.25884], [3.63136, 12.11826], [3.67775, 11.97599], [3.61955, 11.91847], [3.63063, 11.83042], [3.67122, 11.80865], [3.67988, 11.75429], [3.61075, 11.69181], [3.59375, 11.70269], [3.49175, 11.29765], [3.71505, 11.13015], [3.84243, 10.59316], [3.78292, 10.40538], [3.6844, 10.46351], [3.57275, 10.27185], [3.66908, 10.18136], [3.54429, 9.87739], [3.35383, 9.83641], [3.32099, 9.78032], [3.34726, 9.70696], [3.25093, 9.61632], [3.13928, 9.47167], [3.14147, 9.28375], [3.08017, 9.10006], [2.77907, 9.06924], [2.67523, 7.87825], [2.73095, 7.7755], [2.73405, 7.5423], [2.78668, 7.5116], [2.79442, 7.43486], [2.74489, 7.42565], [2.76965, 7.13543], [2.71702, 6.95722], [2.74024, 6.92802], [2.73405, 6.78508], [2.78823, 6.76356], [2.78204, 6.70514], [2.7325, 6.64057], [2.74334, 6.57291], [2.70464, 6.50831], [2.70566, 6.38038], [2.74181, 6.13349], [5.87055, 3.78489], [8.34397, 4.30689], [8.60302, 4.87353], [8.78027, 5.1243], [8.92029, 5.58403], [8.83687, 5.68483], [8.88156, 5.78857], [8.84209, 5.82562], [9.51757, 6.43874], [9.70674, 6.51717], [9.77824, 6.79088], [9.86314, 6.77756], [10.15135, 7.03781], [10.21466, 6.88996], [10.53639, 6.93432], [10.57214, 7.16345], [10.59746, 7.14719], [10.60789, 7.06885], [10.83727, 6.9358], [10.8179, 6.83377], [10.94302, 6.69325], [11.09644, 6.68437], [11.09495, 6.51717], [11.42041, 6.53789], [11.42264, 6.5882], [11.51499, 6.60892], [11.57755, 6.74059], [11.55818, 6.86186], [11.63117, 6.9905], [11.87396, 7.09398], [11.84864, 7.26098], [11.93205, 7.47812], [12.01844, 7.52981], [11.99908, 7.67302], [12.20909, 7.97553], [12.19271, 8.10826], [12.24782, 8.17904], [12.26123, 8.43696], [12.4489, 8.52536], [12.44146, 8.6152], [12.68722, 8.65938], [12.71701, 8.7595], [12.79, 8.75361], [12.81085, 8.91992], [12.90022, 9.11411], [12.91958, 9.33905], [12.85628, 9.36698], [13.02385, 9.49334], [13.22642, 9.57266], [13.25472, 9.76795], [13.29941, 9.8296], [13.25025, 9.86042], [13.24132, 9.91031], [13.27409, 9.93232], [13.286, 9.9822], [13.25323, 10.00127], [13.25025, 10.03647], [13.34111, 10.12299], [13.43644, 10.13326], [13.5705, 10.53183], [13.54964, 10.61236], [13.73434, 10.9255], [13.70753, 10.94451], [13.7403, 11.00593], [13.78945, 11.00154], [13.97489, 11.30258], [14.17821, 11.23831], [14.6124, 11.51283], [14.64591, 11.66166], [14.55207, 11.72001], [14.61612, 11.7798], [14.6474, 12.17466], [14.4843, 12.35223], [14.22215, 12.36533], [14.17523, 12.41916], [14.20204, 12.53405], [14.08251, 13.0797], [13.6302, 13.71094], [13.33213, 13.71195], [13.19844, 13.52802], [13.05085, 13.53984], [12.87376, 13.48919], [12.6793, 13.29157], [12.58033, 13.27805], [12.47095, 13.06673], [12.19315, 13.12423], [12.16189, 13.10056], [12.04209, 13.14452], [11.88236, 13.2527], [11.4535, 13.37773], [10.66004, 13.36422], [10.46731, 13.28819], [10.19993, 13.27129], [10.00373, 13.18171], [9.65995, 12.80614], [8.97413, 12.83661], [8.64251, 12.93985], [8.60431, 13.01768], [8.49493, 13.07519], [8.41853, 13.06166], [8.25185, 13.20369], [8.07997, 13.30847], [7.81085, 13.34902], [7.39241, 13.09717], [7.22399, 13.1293], [7.12676, 13.02445], [7.0521, 13.00076], [6.94445, 12.99825], [6.69617, 13.34057], [6.43053, 13.6006], [6.27411, 13.67835], [6.15771, 13.64564]]]] } },
    { type: "Feature", properties: { iso1A2: "NI", iso1A3: "NIC", iso1N3: "558", wikidata: "Q811", nameEn: "Nicaragua", groups: ["013", "003", "419", "019", "UN"], callingCodes: ["505"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-83.13724, 15.00002], [-83.49268, 15.01158], [-83.62101, 14.89448], [-83.89551, 14.76697], [-84.10584, 14.76353], [-84.48373, 14.63249], [-84.70119, 14.68078], [-84.82596, 14.82212], [-84.90082, 14.80489], [-85.1575, 14.53934], [-85.18602, 14.24929], [-85.32149, 14.2562], [-85.45762, 14.11304], [-85.73964, 13.9698], [-85.75477, 13.8499], [-86.03458, 13.99181], [-86.00685, 14.08474], [-86.14801, 14.04317], [-86.35219, 13.77157], [-86.76812, 13.79605], [-86.71267, 13.30348], [-86.87066, 13.30641], [-86.93383, 13.18677], [-86.93197, 13.05313], [-87.03785, 12.98682], [-87.06306, 13.00892], [-87.37107, 12.98646], [-87.55124, 13.12523], [-87.7346, 13.13228], [-88.11443, 12.63306], [-86.14524, 11.09059], [-85.71223, 11.06868], [-85.60529, 11.22607], [-84.92439, 10.9497], [-84.68197, 11.07568], [-83.90838, 10.71161], [-83.66597, 10.79916], [-83.68276, 11.01562], [-82.56142, 11.91792], [-82.06974, 14.49418], [-83.04763, 15.03256], [-83.13724, 15.00002]]]] } },
    { type: "Feature", properties: { iso1A2: "NL", iso1A3: "NLD", iso1N3: "528", wikidata: "Q29999", nameEn: "Kingdom of the Netherlands" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "NO", iso1A3: "NOR", iso1N3: "578", wikidata: "Q20", nameEn: "Norway" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "NP", iso1A3: "NPL", iso1N3: "524", wikidata: "Q837", nameEn: "Nepal", groups: ["034", "142", "UN"], driveSide: "left", callingCodes: ["977"] }, geometry: { type: "MultiPolygon", coordinates: [[[[88.13378, 27.88015], [87.82681, 27.95248], [87.72718, 27.80938], [87.56996, 27.84517], [87.11696, 27.84104], [87.03757, 27.94835], [86.75582, 28.04182], [86.74181, 28.10638], [86.56265, 28.09569], [86.51609, 27.96623], [86.42736, 27.91122], [86.22966, 27.9786], [86.18607, 28.17364], [86.088, 28.09264], [86.08333, 28.02121], [86.12069, 27.93047], [86.06309, 27.90021], [85.94946, 27.9401], [85.97813, 27.99023], [85.90743, 28.05144], [85.84672, 28.18187], [85.74864, 28.23126], [85.71907, 28.38064], [85.69105, 28.38475], [85.60854, 28.25045], [85.59765, 28.30529], [85.4233, 28.32996], [85.38127, 28.28336], [85.10729, 28.34092], [85.18668, 28.54076], [85.19135, 28.62825], [85.06059, 28.68562], [84.85511, 28.58041], [84.62317, 28.73887], [84.47528, 28.74023], [84.2231, 28.89571], [84.24801, 29.02783], [84.18107, 29.23451], [83.97559, 29.33091], [83.82303, 29.30513], [83.63156, 29.16249], [83.44787, 29.30513], [83.28131, 29.56813], [83.07116, 29.61957], [82.73024, 29.81695], [82.5341, 29.9735], [82.38622, 30.02608], [82.16984, 30.0692], [82.19475, 30.16884], [82.10757, 30.23745], [82.10135, 30.35439], [81.99082, 30.33423], [81.62033, 30.44703], [81.5459, 30.37688], [81.41018, 30.42153], [81.39928, 30.21862], [81.33355, 30.15303], [81.2623, 30.14596], [81.29032, 30.08806], [81.24362, 30.0126], [81.12842, 30.01395], [81.03953, 30.20059], [80.92547, 30.17193], [80.91143, 30.22173], [80.86673, 30.17321], [80.8778, 30.13384], [80.67076, 29.95732], [80.60226, 29.95732], [80.57179, 29.91422], [80.56247, 29.86661], [80.48997, 29.79566], [80.43458, 29.80466], [80.41554, 29.79451], [80.36803, 29.73865], [80.38428, 29.68513], [80.41858, 29.63581], [80.37939, 29.57098], [80.24322, 29.44299], [80.31428, 29.30784], [80.28626, 29.20327], [80.24112, 29.21414], [80.26602, 29.13938], [80.23178, 29.11626], [80.18085, 29.13649], [80.05743, 28.91479], [80.06957, 28.82763], [80.12125, 28.82346], [80.37188, 28.63371], [80.44504, 28.63098], [80.52443, 28.54897], [80.50575, 28.6706], [80.55142, 28.69182], [81.03471, 28.40054], [81.19847, 28.36284], [81.32923, 28.13521], [81.38683, 28.17638], [81.48179, 28.12148], [81.47867, 28.08303], [81.91223, 27.84995], [81.97214, 27.93322], [82.06554, 27.92222], [82.46405, 27.6716], [82.70378, 27.72122], [82.74119, 27.49838], [82.93261, 27.50328], [82.94938, 27.46036], [83.19413, 27.45632], [83.27197, 27.38309], [83.2673, 27.36235], [83.29999, 27.32778], [83.35136, 27.33885], [83.38872, 27.39276], [83.39495, 27.4798], [83.61288, 27.47013], [83.85595, 27.35797], [83.86182, 27.4241], [83.93306, 27.44939], [84.02229, 27.43836], [84.10791, 27.52399], [84.21376, 27.45218], [84.25735, 27.44941], [84.29315, 27.39], [84.62161, 27.33885], [84.69166, 27.21294], [84.64496, 27.04669], [84.793, 26.9968], [84.82913, 27.01989], [84.85754, 26.98984], [84.96687, 26.95599], [84.97186, 26.9149], [85.00536, 26.89523], [85.05592, 26.88991], [85.02635, 26.85381], [85.15883, 26.86966], [85.19291, 26.86909], [85.18046, 26.80519], [85.21159, 26.75933], [85.34302, 26.74954], [85.47752, 26.79292], [85.56471, 26.84133], [85.5757, 26.85955], [85.59461, 26.85161], [85.61621, 26.86721], [85.66239, 26.84822], [85.73483, 26.79613], [85.72315, 26.67471], [85.76907, 26.63076], [85.83126, 26.61134], [85.85126, 26.60866], [85.8492, 26.56667], [86.02729, 26.66756], [86.13596, 26.60651], [86.22513, 26.58863], [86.26235, 26.61886], [86.31564, 26.61925], [86.49726, 26.54218], [86.54258, 26.53819], [86.57073, 26.49825], [86.61313, 26.48658], [86.62686, 26.46891], [86.69124, 26.45169], [86.74025, 26.42386], [86.76797, 26.45892], [86.82898, 26.43919], [86.94543, 26.52076], [86.95912, 26.52076], [87.01559, 26.53228], [87.04691, 26.58685], [87.0707, 26.58571], [87.09147, 26.45039], [87.14751, 26.40542], [87.18863, 26.40558], [87.24682, 26.4143], [87.26587, 26.40592], [87.26568, 26.37294], [87.34568, 26.34787], [87.37314, 26.40815], [87.46566, 26.44058], [87.51571, 26.43106], [87.55274, 26.40596], [87.59175, 26.38342], [87.66803, 26.40294], [87.67893, 26.43501], [87.76004, 26.40711], [87.7918, 26.46737], [87.84193, 26.43663], [87.89085, 26.48565], [87.90115, 26.44923], [88.00895, 26.36029], [88.09414, 26.43732], [88.09963, 26.54195], [88.16452, 26.64111], [88.1659, 26.68177], [88.19107, 26.75516], [88.12302, 26.95324], [88.13422, 26.98705], [88.11719, 26.98758], [87.9887, 27.11045], [88.01587, 27.21388], [88.01646, 27.21612], [88.07277, 27.43007], [88.04008, 27.49223], [88.19107, 27.79285], [88.1973, 27.85067], [88.13378, 27.88015]]]] } },
    { type: "Feature", properties: { iso1A2: "NR", iso1A3: "NRU", iso1N3: "520", wikidata: "Q697", nameEn: "Nauru", groups: ["057", "009", "UN"], driveSide: "left", callingCodes: ["674"] }, geometry: { type: "MultiPolygon", coordinates: [[[[166.95155, 0.14829], [166.21778, -0.7977], [167.60042, -0.88259], [166.95155, 0.14829]]]] } },
    { type: "Feature", properties: { iso1A2: "NU", iso1A3: "NIU", iso1N3: "570", wikidata: "Q34020", nameEn: "Niue", country: "NZ", groups: ["061", "009", "UN"], driveSide: "left", callingCodes: ["683"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-170.83899, -18.53439], [-170.82274, -20.44429], [-168.63096, -18.60489], [-170.83899, -18.53439]]]] } },
    { type: "Feature", properties: { iso1A2: "NZ", iso1A3: "NZL", iso1N3: "554", wikidata: "Q664", nameEn: "New Zealand" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "OM", iso1A3: "OMN", iso1N3: "512", wikidata: "Q842", nameEn: "Oman", groups: ["145", "142", "UN"], callingCodes: ["968"] }, geometry: { type: "MultiPolygon", coordinates: [[[[56.82555, 25.7713], [56.79239, 26.41236], [56.68954, 26.76645], [56.2644, 26.58649], [55.81777, 26.18798], [56.08666, 26.05038], [56.15498, 26.06828], [56.19334, 25.9795], [56.13963, 25.82765], [56.17416, 25.77239], [56.13579, 25.73524], [56.14826, 25.66351], [56.18363, 25.65508], [56.20473, 25.61119], [56.25365, 25.60211], [56.26636, 25.60643], [56.25341, 25.61443], [56.26534, 25.62825], [56.82555, 25.7713]]], [[[56.26062, 25.33108], [56.23362, 25.31253], [56.25008, 25.28843], [56.24465, 25.27505], [56.20838, 25.25668], [56.20872, 25.24104], [56.24341, 25.22867], [56.27628, 25.23404], [56.34438, 25.26653], [56.35172, 25.30681], [56.3111, 25.30107], [56.3005, 25.31815], [56.26062, 25.33108]], [[56.28423, 25.26344], [56.27086, 25.26128], [56.2716, 25.27916], [56.28102, 25.28486], [56.29379, 25.2754], [56.28423, 25.26344]]], [[[61.45114, 22.55394], [56.86325, 25.03856], [56.3227, 24.97284], [56.34873, 24.93205], [56.30269, 24.88334], [56.20568, 24.85063], [56.20062, 24.78565], [56.13684, 24.73699], [56.06128, 24.74457], [56.03535, 24.81161], [55.97836, 24.87673], [55.97467, 24.89639], [56.05106, 24.87461], [56.05715, 24.95727], [55.96316, 25.00857], [55.90849, 24.96771], [55.85094, 24.96858], [55.81116, 24.9116], [55.81348, 24.80102], [55.83408, 24.77858], [55.83271, 24.68567], [55.76461, 24.5287], [55.83271, 24.41521], [55.83395, 24.32776], [55.80747, 24.31069], [55.79145, 24.27914], [55.76781, 24.26209], [55.75939, 24.26114], [55.75382, 24.2466], [55.75257, 24.23466], [55.76558, 24.23227], [55.77658, 24.23476], [55.83367, 24.20193], [55.95472, 24.2172], [56.01799, 24.07426], [55.8308, 24.01633], [55.73301, 24.05994], [55.48677, 23.94946], [55.57358, 23.669], [55.22634, 23.10378], [55.2137, 22.71065], [55.66469, 21.99658], [54.99756, 20.00083], [52.00311, 19.00083], [52.78009, 17.35124], [52.74267, 17.29519], [52.81185, 17.28568], [57.49095, 8.14549], [61.45114, 22.55394]]]] } },
    { type: "Feature", properties: { iso1A2: "PA", iso1A3: "PAN", iso1N3: "591", wikidata: "Q804", nameEn: "Panama", groups: ["013", "003", "419", "019", "UN"], callingCodes: ["507"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-77.32389, 8.81247], [-77.58292, 9.22278], [-78.79327, 9.93766], [-82.51044, 9.65379], [-82.56507, 9.57279], [-82.61345, 9.49881], [-82.66667, 9.49746], [-82.77206, 9.59573], [-82.87919, 9.62645], [-82.84871, 9.4973], [-82.93516, 9.46741], [-82.93516, 9.07687], [-82.72126, 8.97125], [-82.88253, 8.83331], [-82.91377, 8.774], [-82.92068, 8.74832], [-82.8794, 8.6981], [-82.82739, 8.60153], [-82.83975, 8.54755], [-82.83322, 8.52464], [-82.8382, 8.48117], [-82.8679, 8.44042], [-82.93056, 8.43465], [-83.05209, 8.33394], [-82.9388, 8.26634], [-82.88641, 8.10219], [-82.89137, 8.05755], [-82.89978, 8.04083], [-82.94503, 7.93865], [-82.13751, 6.97312], [-78.06168, 7.07793], [-77.89178, 7.22681], [-77.81426, 7.48319], [-77.72157, 7.47612], [-77.72514, 7.72348], [-77.57185, 7.51147], [-77.17257, 7.97422], [-77.45064, 8.49991], [-77.32389, 8.81247]]]] } },
    { type: "Feature", properties: { iso1A2: "PE", iso1A3: "PER", iso1N3: "604", wikidata: "Q419", nameEn: "Peru", groups: ["005", "419", "019", "UN"], callingCodes: ["51"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-74.26675, -0.97229], [-74.42701, -0.50218], [-75.18513, -0.0308], [-75.25764, -0.11943], [-75.40192, -0.17196], [-75.61997, -0.10012], [-75.60169, -0.18708], [-75.53615, -0.19213], [-75.22862, -0.60048], [-75.22862, -0.95588], [-75.3872, -0.9374], [-75.57429, -1.55961], [-76.05203, -2.12179], [-76.6324, -2.58397], [-77.94147, -3.05454], [-78.19369, -3.36431], [-78.14324, -3.47653], [-78.22642, -3.51113], [-78.24589, -3.39907], [-78.34362, -3.38633], [-78.68394, -4.60754], [-78.85149, -4.66795], [-79.01659, -5.01481], [-79.1162, -4.97774], [-79.26248, -4.95167], [-79.59402, -4.46848], [-79.79722, -4.47558], [-80.13945, -4.29786], [-80.39256, -4.48269], [-80.46386, -4.41516], [-80.32114, -4.21323], [-80.45023, -4.20938], [-80.4822, -4.05477], [-80.46386, -4.01342], [-80.13232, -3.90317], [-80.19926, -3.68894], [-80.18741, -3.63994], [-80.19848, -3.59249], [-80.21642, -3.5888], [-80.20535, -3.51667], [-80.22629, -3.501], [-80.23651, -3.48652], [-80.24586, -3.48677], [-80.24123, -3.46124], [-80.20647, -3.431], [-80.30602, -3.39149], [-84.52388, -3.36941], [-85.71054, -21.15413], [-70.59118, -18.35072], [-70.378, -18.3495], [-70.31267, -18.31258], [-70.16394, -18.31737], [-69.96732, -18.25992], [-69.81607, -18.12582], [-69.75305, -17.94605], [-69.82868, -17.72048], [-69.79087, -17.65563], [-69.66483, -17.65083], [-69.46897, -17.4988], [-69.46863, -17.37466], [-69.62883, -17.28142], [-69.16896, -16.72233], [-69.00853, -16.66769], [-69.04027, -16.57214], [-68.98358, -16.42165], [-68.79464, -16.33272], [-68.96238, -16.194], [-69.09986, -16.22693], [-69.20291, -16.16668], [-69.40336, -15.61358], [-69.14856, -15.23478], [-69.36254, -14.94634], [-68.88135, -14.18639], [-69.05265, -13.68546], [-68.8864, -13.40792], [-68.85615, -12.87769], [-68.65044, -12.50689], [-68.98115, -11.8979], [-69.57156, -10.94555], [-69.57835, -10.94051], [-69.90896, -10.92744], [-70.38791, -11.07096], [-70.51395, -10.92249], [-70.64134, -11.0108], [-70.62487, -9.80666], [-70.55429, -9.76692], [-70.58453, -9.58303], [-70.53373, -9.42628], [-71.23394, -9.9668], [-72.14742, -9.98049], [-72.31883, -9.5184], [-72.72216, -9.41397], [-73.21498, -9.40904], [-72.92886, -9.04074], [-73.76576, -7.89884], [-73.65485, -7.77897], [-73.96938, -7.58465], [-73.77011, -7.28944], [-73.73986, -6.87919], [-73.12983, -6.43852], [-73.24579, -6.05764], [-72.83973, -5.14765], [-72.64391, -5.0391], [-71.87003, -4.51661], [-70.96814, -4.36915], [-70.77601, -4.15717], [-70.33236, -4.15214], [-70.19582, -4.3607], [-70.11305, -4.27281], [-70.00888, -4.37833], [-69.94708, -4.2431], [-70.3374, -3.79505], [-70.52393, -3.87553], [-70.71396, -3.7921], [-70.04609, -2.73906], [-70.94377, -2.23142], [-71.75223, -2.15058], [-72.92587, -2.44514], [-73.65312, -1.26222], [-74.26675, -0.97229]]]] } },
    { type: "Feature", properties: { iso1A2: "PF", iso1A3: "PYF", iso1N3: "258", wikidata: "Q30971", nameEn: "French Polynesia", country: "FR", groups: ["EU", "Q1451600", "061", "009", "UN"], callingCodes: ["689"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-135.59706, -4.70473], [-156.48634, -15.52824], [-156.45576, -31.75456], [-133.59543, -28.4709], [-135.59706, -4.70473]]]] } },
    { type: "Feature", properties: { iso1A2: "PG", iso1A3: "PNG", iso1N3: "598", wikidata: "Q691", nameEn: "Papua New Guinea", groups: ["054", "009", "UN"], driveSide: "left", callingCodes: ["675"] }, geometry: { type: "MultiPolygon", coordinates: [[[[141.03157, 2.12829], [140.99813, -6.3233], [140.85295, -6.72996], [140.90448, -6.85033], [141.01763, -6.90181], [141.01842, -9.35091], [141.88934, -9.36111], [142.19246, -9.15378], [142.48658, -9.36754], [143.29772, -9.33993], [143.87386, -9.02382], [145.2855, -9.62524], [156.73836, -14.50464], [154.74815, -7.33315], [155.60735, -6.92266], [155.69784, -6.92661], [155.92557, -6.84664], [156.03993, -6.65703], [156.03296, -6.55528], [160.43769, -4.17974], [141.03157, 2.12829]]]] } },
    { type: "Feature", properties: { iso1A2: "PH", iso1A3: "PHL", iso1N3: "608", wikidata: "Q928", nameEn: "Philippines", aliases: ["PI", "RP"], groups: ["035", "142", "UN"], callingCodes: ["63"] }, geometry: { type: "MultiPolygon", coordinates: [[[[129.19694, 7.84182], [121.8109, 21.77688], [120.69238, 21.52331], [118.82252, 14.67191], [115.39742, 10.92666], [116.79524, 7.43869], [117.17735, 7.52841], [117.93857, 6.89845], [117.98544, 6.27477], [119.52945, 5.35672], [118.93936, 4.09009], [118.06469, 4.16638], [121.14448, 2.12444], [129.19694, 7.84182]]]] } },
    { type: "Feature", properties: { iso1A2: "PK", iso1A3: "PAK", iso1N3: "586", wikidata: "Q843", nameEn: "Pakistan", groups: ["034", "142", "UN"], driveSide: "left", callingCodes: ["92"] }, geometry: { type: "MultiPolygon", coordinates: [[[[75.72737, 36.7529], [75.45562, 36.71971], [75.40481, 36.95382], [75.13839, 37.02622], [74.56453, 37.03023], [74.53739, 36.96224], [74.43389, 37.00977], [74.04856, 36.82648], [73.82685, 36.91421], [72.6323, 36.84601], [72.18135, 36.71838], [71.80267, 36.49924], [71.60491, 36.39429], [71.19505, 36.04134], [71.37969, 35.95865], [71.55273, 35.71483], [71.49917, 35.6267], [71.65435, 35.4479], [71.54294, 35.31037], [71.5541, 35.28776], [71.67495, 35.21262], [71.52938, 35.09023], [71.55273, 35.02615], [71.49917, 35.00478], [71.50329, 34.97328], [71.29472, 34.87728], [71.28356, 34.80882], [71.08718, 34.69034], [71.11602, 34.63047], [71.0089, 34.54568], [71.02401, 34.44835], [71.17662, 34.36769], [71.12815, 34.26619], [71.13078, 34.16503], [71.09453, 34.13524], [71.09307, 34.11961], [71.06933, 34.10564], [71.07345, 34.06242], [70.88119, 33.97933], [70.54336, 33.9463], [69.90203, 34.04194], [69.87307, 33.9689], [69.85671, 33.93719], [70.00503, 33.73528], [70.14236, 33.71701], [70.14785, 33.6553], [70.20141, 33.64387], [70.17062, 33.53535], [70.32775, 33.34496], [70.13686, 33.21064], [70.07369, 33.22557], [70.02563, 33.14282], [69.85259, 33.09451], [69.79766, 33.13247], [69.71526, 33.09911], [69.57656, 33.09911], [69.49004, 33.01509], [69.49854, 32.88843], [69.5436, 32.8768], [69.47082, 32.85834], [69.38018, 32.76601], [69.43649, 32.7302], [69.44747, 32.6678], [69.38155, 32.56601], [69.2868, 32.53938], [69.23599, 32.45946], [69.27932, 32.29119], [69.27032, 32.14141], [69.3225, 31.93186], [69.20577, 31.85957], [69.11514, 31.70782], [69.00939, 31.62249], [68.95995, 31.64822], [68.91078, 31.59687], [68.79997, 31.61665], [68.6956, 31.75687], [68.57475, 31.83158], [68.44222, 31.76446], [68.27605, 31.75863], [68.25614, 31.80357], [68.1655, 31.82691], [68.00071, 31.6564], [67.86887, 31.63536], [67.72056, 31.52304], [67.58323, 31.52772], [67.62374, 31.40473], [67.7748, 31.4188], [67.78854, 31.33203], [67.29964, 31.19586], [67.03323, 31.24519], [67.04147, 31.31561], [66.83273, 31.26867], [66.72561, 31.20526], [66.68166, 31.07597], [66.58175, 30.97532], [66.42645, 30.95309], [66.39194, 30.9408], [66.28413, 30.57001], [66.34869, 30.404], [66.23609, 30.06321], [66.36042, 29.9583], [66.24175, 29.85181], [65.04005, 29.53957], [64.62116, 29.58903], [64.19796, 29.50407], [64.12966, 29.39157], [63.5876, 29.50456], [62.47751, 29.40782], [60.87231, 29.86514], [61.31508, 29.38903], [61.53765, 29.00507], [61.65978, 28.77937], [61.93581, 28.55284], [62.40259, 28.42703], [62.59499, 28.24842], [62.79412, 28.28108], [62.7638, 28.02992], [62.84905, 27.47627], [62.79684, 27.34381], [62.80604, 27.22412], [63.19649, 27.25674], [63.32283, 27.14437], [63.25005, 27.08692], [63.25005, 26.84212], [63.18688, 26.83844], [63.1889, 26.65072], [62.77352, 26.64099], [62.31484, 26.528], [62.21304, 26.26601], [62.05117, 26.31647], [61.89391, 26.26251], [61.83831, 26.07249], [61.83968, 25.7538], [61.683, 25.66638], [61.6433, 25.27541], [61.46682, 24.57869], [68.11329, 23.53945], [68.20763, 23.85849], [68.39339, 23.96838], [68.74643, 23.97027], [68.7416, 24.31904], [68.90914, 24.33156], [68.97781, 24.26021], [69.07806, 24.29777], [69.19341, 24.25646], [69.29778, 24.28712], [69.59579, 24.29777], [69.73335, 24.17007], [70.03428, 24.172], [70.11712, 24.30915], [70.5667, 24.43787], [70.57906, 24.27774], [70.71502, 24.23517], [70.88393, 24.27398], [70.85784, 24.30903], [70.94985, 24.3791], [71.04461, 24.34657], [71.12838, 24.42662], [71.00341, 24.46038], [70.97594, 24.60904], [71.09405, 24.69017], [70.94002, 24.92843], [70.89148, 25.15064], [70.66695, 25.39314], [70.67382, 25.68186], [70.60378, 25.71898], [70.53649, 25.68928], [70.37444, 25.67443], [70.2687, 25.71156], [70.0985, 25.93238], [70.08193, 26.08094], [70.17532, 26.24118], [70.17532, 26.55362], [70.05584, 26.60398], [69.88555, 26.56836], [69.50904, 26.74892], [69.58519, 27.18109], [70.03136, 27.56627], [70.12502, 27.8057], [70.37307, 28.01208], [70.60927, 28.02178], [70.79054, 27.68423], [71.89921, 27.96035], [71.9244, 28.11555], [72.20329, 28.3869], [72.29495, 28.66367], [72.40402, 28.78283], [72.94272, 29.02487], [73.01337, 29.16422], [73.05886, 29.1878], [73.28094, 29.56646], [73.3962, 29.94707], [73.58665, 30.01848], [73.80299, 30.06969], [73.97225, 30.19829], [73.95736, 30.28466], [73.88993, 30.36305], [74.5616, 31.04153], [74.67971, 31.05479], [74.6852, 31.12771], [74.60006, 31.13711], [74.60281, 31.10419], [74.56023, 31.08303], [74.51629, 31.13829], [74.53223, 31.30321], [74.59773, 31.4136], [74.64713, 31.45605], [74.59319, 31.50197], [74.61517, 31.55698], [74.57498, 31.60382], [74.47771, 31.72227], [74.58907, 31.87824], [74.79919, 31.95983], [74.86236, 32.04485], [74.9269, 32.0658], [75.00793, 32.03786], [75.25649, 32.10187], [75.38046, 32.26836], [75.28259, 32.36556], [75.03265, 32.49538], [74.97634, 32.45367], [74.84725, 32.49075], [74.68362, 32.49298], [74.67431, 32.56676], [74.65251, 32.56416], [74.64424, 32.60985], [74.69542, 32.66792], [74.65345, 32.71225], [74.7113, 32.84219], [74.64675, 32.82604], [74.6289, 32.75561], [74.45312, 32.77755], [74.41467, 32.90563], [74.31227, 32.92795], [74.34875, 32.97823], [74.31854, 33.02891], [74.17571, 33.07495], [74.15374, 33.13477], [74.02144, 33.18908], [74.01366, 33.25199], [74.08782, 33.26232], [74.17983, 33.3679], [74.18121, 33.4745], [74.10115, 33.56392], [74.03576, 33.56718], [73.97367, 33.64061], [73.98968, 33.66155], [73.96423, 33.73071], [74.00891, 33.75437], [74.05898, 33.82089], [74.14001, 33.83002], [74.26086, 33.92237], [74.25262, 34.01577], [74.21554, 34.03853], [73.91341, 34.01235], [73.88732, 34.05105], [73.90677, 34.10504], [73.98208, 34.2522], [73.90517, 34.35317], [73.8475, 34.32935], [73.74862, 34.34183], [73.74999, 34.3781], [73.88732, 34.48911], [73.89419, 34.54568], [73.93951, 34.57169], [73.93401, 34.63386], [73.96423, 34.68244], [74.12897, 34.70073], [74.31239, 34.79626], [74.58083, 34.77386], [74.6663, 34.703], [75.01479, 34.64629], [75.38009, 34.55021], [75.75438, 34.51827], [76.04614, 34.67566], [76.15463, 34.6429], [76.47186, 34.78965], [76.67648, 34.76371], [76.74377, 34.84039], [76.74514, 34.92488], [76.87193, 34.96906], [76.99251, 34.93349], [77.11796, 35.05419], [76.93465, 35.39866], [76.85088, 35.39754], [76.75475, 35.52617], [76.77323, 35.66062], [76.50961, 35.8908], [76.33453, 35.84296], [76.14913, 35.82848], [76.15325, 35.9264], [75.93028, 36.13136], [76.00906, 36.17511], [76.0324, 36.41198], [75.92391, 36.56986], [75.72737, 36.7529]]]] } },
    { type: "Feature", properties: { iso1A2: "PL", iso1A3: "POL", iso1N3: "616", wikidata: "Q36", nameEn: "Poland", groups: ["EU", "151", "150", "UN"], callingCodes: ["48"] }, geometry: { type: "MultiPolygon", coordinates: [[[[18.57853, 55.25302], [14.20811, 54.12784], [14.22634, 53.9291], [14.20647, 53.91671], [14.18544, 53.91258], [14.20823, 53.90776], [14.21323, 53.8664], [14.27249, 53.74464], [14.26782, 53.69866], [14.2836, 53.67721], [14.27133, 53.66613], [14.28477, 53.65955], [14.2853, 53.63392], [14.31904, 53.61581], [14.30416, 53.55499], [14.3273, 53.50587], [14.35209, 53.49506], [14.4215, 53.27724], [14.44133, 53.27427], [14.45125, 53.26241], [14.40662, 53.21098], [14.37853, 53.20405], [14.36696, 53.16444], [14.38679, 53.13669], [14.35044, 53.05829], [14.25954, 53.00264], [14.14056, 52.95786], [14.15873, 52.87715], [14.12256, 52.84311], [14.13806, 52.82392], [14.22071, 52.81175], [14.61073, 52.59847], [14.6289, 52.57136], [14.60081, 52.53116], [14.63056, 52.48993], [14.54423, 52.42568], [14.55228, 52.35264], [14.56378, 52.33838], [14.58149, 52.28007], [14.70139, 52.25038], [14.71319, 52.22144], [14.68344, 52.19612], [14.70616, 52.16927], [14.67683, 52.13936], [14.6917, 52.10283], [14.72971, 52.09167], [14.76026, 52.06624], [14.71339, 52.00337], [14.70488, 51.97679], [14.7139, 51.95643], [14.71836, 51.95606], [14.72163, 51.95188], [14.7177, 51.94048], [14.70601, 51.92944], [14.6933, 51.9044], [14.6588, 51.88359], [14.59089, 51.83302], [14.60493, 51.80473], [14.64625, 51.79472], [14.66386, 51.73282], [14.69065, 51.70842], [14.75392, 51.67445], [14.75759, 51.62318], [14.7727, 51.61263], [14.71125, 51.56209], [14.73047, 51.54606], [14.72652, 51.53902], [14.73219, 51.52922], [14.94749, 51.47155], [14.9652, 51.44793], [14.96899, 51.38367], [14.98008, 51.33449], [15.04288, 51.28387], [15.01242, 51.21285], [15.0047, 51.16874], [14.99311, 51.16249], [14.99414, 51.15813], [15.00083, 51.14974], [14.99646, 51.14365], [14.99079, 51.14284], [14.99689, 51.12205], [14.98229, 51.11354], [14.97938, 51.07742], [14.95529, 51.04552], [14.92942, 50.99744], [14.89252, 50.94999], [14.89681, 50.9422], [14.81664, 50.88148], [14.82803, 50.86966], [14.99852, 50.86817], [15.01088, 50.97984], [14.96419, 50.99108], [15.02433, 51.0242], [15.03895, 51.0123], [15.06218, 51.02269], [15.10152, 51.01095], [15.11937, 50.99021], [15.16744, 51.01959], [15.1743, 50.9833], [15.2361, 50.99886], [15.27043, 50.97724], [15.2773, 50.8907], [15.36656, 50.83956], [15.3803, 50.77187], [15.43798, 50.80833], [15.73186, 50.73885], [15.81683, 50.75666], [15.87331, 50.67188], [15.97219, 50.69799], [16.0175, 50.63009], [15.98317, 50.61528], [16.02437, 50.60046], [16.10265, 50.66405], [16.20839, 50.63096], [16.23174, 50.67101], [16.33611, 50.66579], [16.44597, 50.58041], [16.34572, 50.49575], [16.31413, 50.50274], [16.19526, 50.43291], [16.21585, 50.40627], [16.22821, 50.41054], [16.28118, 50.36891], [16.30289, 50.38292], [16.36495, 50.37679], [16.3622, 50.34875], [16.39379, 50.3207], [16.42674, 50.32509], [16.56407, 50.21009], [16.55446, 50.16613], [16.63137, 50.1142], [16.7014, 50.09659], [16.8456, 50.20834], [16.98018, 50.24172], [17.00353, 50.21449], [17.02825, 50.23118], [16.99803, 50.25753], [17.02138, 50.27772], [16.99803, 50.30316], [16.94448, 50.31281], [16.90877, 50.38642], [16.85933, 50.41093], [16.89229, 50.45117], [17.1224, 50.39494], [17.14498, 50.38117], [17.19579, 50.38817], [17.19991, 50.3654], [17.27681, 50.32246], [17.34273, 50.32947], [17.34548, 50.2628], [17.3702, 50.28123], [17.58889, 50.27837], [17.67764, 50.28977], [17.69292, 50.32859], [17.74648, 50.29966], [17.72176, 50.25665], [17.76296, 50.23382], [17.70528, 50.18812], [17.59404, 50.16437], [17.66683, 50.10275], [17.6888, 50.12037], [17.7506, 50.07896], [17.77669, 50.02253], [17.86886, 49.97452], [18.00191, 50.01723], [18.04585, 50.01194], [18.04585, 50.03311], [18.00396, 50.04954], [18.03212, 50.06574], [18.07898, 50.04535], [18.10628, 50.00223], [18.20241, 49.99958], [18.21752, 49.97309], [18.27107, 49.96779], [18.27794, 49.93863], [18.31914, 49.91565], [18.33278, 49.92415], [18.33562, 49.94747], [18.41604, 49.93498], [18.53423, 49.89906], [18.54495, 49.9079], [18.54299, 49.92537], [18.57697, 49.91565], [18.57045, 49.87849], [18.60341, 49.86256], [18.57183, 49.83334], [18.61278, 49.7618], [18.61368, 49.75426], [18.62645, 49.75002], [18.62943, 49.74603], [18.62676, 49.71983], [18.69817, 49.70473], [18.72838, 49.68163], [18.80479, 49.6815], [18.84786, 49.5446], [18.84521, 49.51672], [18.94536, 49.52143], [18.97283, 49.49914], [18.9742, 49.39557], [19.18019, 49.41165], [19.25435, 49.53391], [19.36009, 49.53747], [19.37795, 49.574], [19.45348, 49.61583], [19.52626, 49.57311], [19.53313, 49.52856], [19.57845, 49.46077], [19.64162, 49.45184], [19.6375, 49.40897], [19.72127, 49.39288], [19.78581, 49.41701], [19.82237, 49.27806], [19.75286, 49.20751], [19.86409, 49.19316], [19.90529, 49.23532], [19.98494, 49.22904], [20.08238, 49.1813], [20.13738, 49.31685], [20.21977, 49.35265], [20.31453, 49.34817], [20.31728, 49.39914], [20.39939, 49.3896], [20.46422, 49.41612], [20.5631, 49.375], [20.61666, 49.41791], [20.72274, 49.41813], [20.77971, 49.35383], [20.9229, 49.29626], [20.98733, 49.30774], [21.09799, 49.37176], [21.041, 49.41791], [21.12477, 49.43666], [21.19756, 49.4054], [21.27858, 49.45988], [21.43376, 49.41433], [21.62328, 49.4447], [21.77983, 49.35443], [21.82927, 49.39467], [21.96385, 49.3437], [22.04427, 49.22136], [22.56155, 49.08865], [22.89122, 49.00725], [22.86336, 49.10513], [22.72009, 49.20288], [22.748, 49.32759], [22.69444, 49.49378], [22.64534, 49.53094], [22.78304, 49.65543], [22.80261, 49.69098], [22.83179, 49.69875], [22.99329, 49.84249], [23.28221, 50.0957], [23.67635, 50.33385], [23.71382, 50.38248], [23.79445, 50.40481], [23.99563, 50.41289], [24.03668, 50.44507], [24.07048, 50.5071], [24.0996, 50.60752], [24.0595, 50.71625], [23.95925, 50.79271], [23.99254, 50.83847], [24.0952, 50.83262], [24.14524, 50.86128], [24.04576, 50.90196], [23.92217, 51.00836], [23.90376, 51.07697], [23.80678, 51.18405], [23.63858, 51.32182], [23.69905, 51.40871], [23.62751, 51.50512], [23.56236, 51.53673], [23.57053, 51.55938], [23.53198, 51.74298], [23.62691, 51.78208], [23.61523, 51.92066], [23.68733, 51.9906], [23.64066, 52.07626], [23.61, 52.11264], [23.54314, 52.12148], [23.47859, 52.18215], [23.20071, 52.22848], [23.18196, 52.28812], [23.34141, 52.44845], [23.45112, 52.53774], [23.58296, 52.59868], [23.73615, 52.6149], [23.93763, 52.71332], [23.91805, 52.94016], [23.94689, 52.95919], [23.92184, 53.02079], [23.87548, 53.0831], [23.91393, 53.16469], [23.85657, 53.22923], [23.81995, 53.24131], [23.62004, 53.60942], [23.51284, 53.95052], [23.48261, 53.98855], [23.52702, 54.04622], [23.49196, 54.14764], [23.45223, 54.17775], [23.42418, 54.17911], [23.39525, 54.21672], [23.3494, 54.25155], [23.24656, 54.25701], [23.15938, 54.29894], [23.15526, 54.31076], [23.13905, 54.31567], [23.104, 54.29794], [23.04323, 54.31567], [23.05726, 54.34565], [22.99649, 54.35927], [23.00584, 54.38514], [22.83756, 54.40827], [22.79705, 54.36264], [21.41123, 54.32395], [20.63871, 54.3706], [19.8038, 54.44203], [19.64312, 54.45423], [18.57853, 55.25302]]]] } },
    { type: "Feature", properties: { iso1A2: "PM", iso1A3: "SPM", iso1N3: "666", wikidata: "Q34617", nameEn: "Saint Pierre and Miquelon", country: "FR", groups: ["EU", "Q1451600", "021", "003", "019", "UN"], callingCodes: ["508"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-56.72993, 46.65575], [-55.90758, 46.6223], [-56.27503, 47.39728], [-56.72993, 46.65575]]]] } },
    { type: "Feature", properties: { iso1A2: "PN", iso1A3: "PCN", iso1N3: "612", wikidata: "Q35672", nameEn: "Pitcairn Islands", country: "GB", groups: ["BOTS", "061", "009", "UN"], driveSide: "left", callingCodes: ["64"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-133.59543, -28.4709], [-122.0366, -24.55017], [-133.61511, -21.93325], [-133.59543, -28.4709]]]] } },
    { type: "Feature", properties: { iso1A2: "PR", iso1A3: "PRI", iso1N3: "630", wikidata: "Q1183", nameEn: "Puerto Rico", aliases: ["US-PR"], country: "US", groups: ["Q1352230", "029", "003", "419", "019", "UN"], roadSpeedUnit: "mph", callingCodes: ["1 787", "1 939"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-65.27974, 17.56928], [-65.02435, 18.73231], [-67.99519, 18.97186], [-68.23894, 17.84663], [-65.27974, 17.56928]]]] } },
    { type: "Feature", properties: { iso1A2: "PS", iso1A3: "PSE", iso1N3: "275", wikidata: "Q219060", nameEn: "Palestine" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "PT", iso1A3: "PRT", iso1N3: "620", wikidata: "Q45", nameEn: "Portugal" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "PW", iso1A3: "PLW", iso1N3: "585", wikidata: "Q695", nameEn: "Palau", groups: ["057", "009", "UN"], roadSpeedUnit: "mph", callingCodes: ["680"] }, geometry: { type: "MultiPolygon", coordinates: [[[[128.97621, 3.08804], [136.39296, 1.54187], [136.04605, 12.45908], [128.97621, 3.08804]]]] } },
    { type: "Feature", properties: { iso1A2: "PY", iso1A3: "PRY", iso1N3: "600", wikidata: "Q733", nameEn: "Paraguay", groups: ["005", "419", "019", "UN"], callingCodes: ["595"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-58.16225, -20.16193], [-58.23216, -19.80058], [-59.06965, -19.29148], [-60.00638, -19.2981], [-61.73723, -19.63958], [-61.93912, -20.10053], [-62.26883, -20.55311], [-62.2757, -21.06657], [-62.64455, -22.25091], [-62.51761, -22.37684], [-62.22768, -22.55807], [-61.9756, -23.0507], [-61.0782, -23.62932], [-60.99754, -23.80934], [-60.28163, -24.04436], [-60.03367, -24.00701], [-59.45482, -24.34787], [-59.33886, -24.49935], [-58.33055, -24.97099], [-58.25492, -24.92528], [-57.80821, -25.13863], [-57.57431, -25.47269], [-57.87176, -25.93604], [-58.1188, -26.16704], [-58.3198, -26.83443], [-58.65321, -27.14028], [-58.59549, -27.29973], [-58.04205, -27.2387], [-56.85337, -27.5165], [-56.18313, -27.29851], [-55.89195, -27.3467], [-55.74475, -27.44485], [-55.59094, -27.32444], [-55.62322, -27.1941], [-55.39611, -26.97679], [-55.25243, -26.93808], [-55.16948, -26.96068], [-55.06351, -26.80195], [-55.00584, -26.78754], [-54.80868, -26.55669], [-54.70732, -26.45099], [-54.69333, -26.37705], [-54.67359, -25.98607], [-54.60664, -25.9691], [-54.62063, -25.91213], [-54.59398, -25.59224], [-54.59509, -25.53696], [-54.60196, -25.48397], [-54.62033, -25.46026], [-54.4423, -25.13381], [-54.28207, -24.07305], [-54.32807, -24.01865], [-54.6238, -23.83078], [-55.02691, -23.97317], [-55.0518, -23.98666], [-55.12292, -23.99669], [-55.41784, -23.9657], [-55.44117, -23.9185], [-55.43585, -23.87157], [-55.5555, -23.28237], [-55.52288, -23.2595], [-55.5446, -23.22811], [-55.63849, -22.95122], [-55.62493, -22.62765], [-55.68742, -22.58407], [-55.6986, -22.56268], [-55.72366, -22.5519], [-55.741, -22.52018], [-55.74941, -22.46436], [-55.8331, -22.29008], [-56.23206, -22.25347], [-56.45893, -22.08072], [-56.5212, -22.11556], [-56.6508, -22.28387], [-57.98625, -22.09157], [-57.94642, -21.73799], [-57.88239, -21.6868], [-57.93492, -21.65505], [-57.84536, -20.93155], [-58.16225, -20.16193]]]] } },
    { type: "Feature", properties: { iso1A2: "QA", iso1A3: "QAT", iso1N3: "634", wikidata: "Q846", nameEn: "Qatar", groups: ["145", "142", "UN"], callingCodes: ["974"] }, geometry: { type: "MultiPolygon", coordinates: [[[[50.92992, 24.54396], [51.09638, 24.46907], [51.29972, 24.50747], [51.39468, 24.62785], [51.58834, 24.66608], [51.83108, 24.71675], [51.83682, 26.70231], [50.93865, 26.30758], [50.81266, 25.88946], [50.86149, 25.6965], [50.7801, 25.595], [50.80824, 25.54641], [50.57069, 25.57887], [50.8133, 24.74049], [50.92992, 24.54396]]]] } },
    { type: "Feature", properties: { iso1A2: "RE", iso1A3: "REU", iso1N3: "638", wikidata: "Q17070", nameEn: "R\xE9union", country: "FR", groups: ["Q3320166", "EU", "014", "202", "002", "UN"], callingCodes: ["262"] }, geometry: { type: "MultiPolygon", coordinates: [[[[53.37984, -21.23941], [56.73473, -21.9174], [56.62373, -20.2711], [53.37984, -21.23941]]]] } },
    { type: "Feature", properties: { iso1A2: "RO", iso1A3: "ROU", iso1N3: "642", wikidata: "Q218", nameEn: "Romania", groups: ["EU", "151", "150", "UN"], callingCodes: ["40"] }, geometry: { type: "MultiPolygon", coordinates: [[[[27.15622, 47.98538], [27.02985, 48.09083], [27.04118, 48.12522], [26.96119, 48.13003], [26.98042, 48.15752], [26.94265, 48.1969], [26.87708, 48.19919], [26.81161, 48.25049], [26.62823, 48.25804], [26.55202, 48.22445], [26.33504, 48.18418], [26.17711, 47.99246], [26.05901, 47.9897], [25.77723, 47.93919], [25.63878, 47.94924], [25.23778, 47.89403], [25.11144, 47.75203], [24.88896, 47.7234], [24.81893, 47.82031], [24.70632, 47.84428], [24.61994, 47.95062], [24.43578, 47.97131], [24.34926, 47.9244], [24.22566, 47.90231], [24.11281, 47.91487], [24.06466, 47.95317], [24.02999, 47.95087], [24.00801, 47.968], [23.98553, 47.96076], [23.96337, 47.96672], [23.94192, 47.94868], [23.89352, 47.94512], [23.8602, 47.9329], [23.80904, 47.98142], [23.75188, 47.99705], [23.66262, 47.98786], [23.63894, 48.00293], [23.5653, 48.00499], [23.52803, 48.01818], [23.4979, 47.96858], [23.33577, 48.0237], [23.27397, 48.08245], [23.15999, 48.12188], [23.1133, 48.08061], [23.08858, 48.00716], [23.0158, 47.99338], [22.92241, 48.02002], [22.94301, 47.96672], [22.89849, 47.95851], [22.77991, 47.87211], [22.76617, 47.8417], [22.67247, 47.7871], [22.46559, 47.76583], [22.41979, 47.7391], [22.31816, 47.76126], [22.00917, 47.50492], [22.03389, 47.42508], [22.01055, 47.37767], [21.94463, 47.38046], [21.78395, 47.11104], [21.648, 47.03902], [21.68645, 46.99595], [21.59581, 46.91628], [21.59307, 46.86935], [21.52028, 46.84118], [21.48935, 46.7577], [21.5151, 46.72147], [21.43926, 46.65109], [21.33214, 46.63035], [21.26929, 46.4993], [21.28061, 46.44941], [21.16872, 46.30118], [21.06572, 46.24897], [20.86797, 46.28884], [20.74574, 46.25467], [20.76085, 46.21002], [20.63863, 46.12728], [20.49718, 46.18721], [20.45377, 46.14405], [20.35573, 46.16629], [20.28324, 46.1438], [20.26068, 46.12332], [20.35862, 45.99356], [20.54818, 45.89939], [20.65645, 45.82801], [20.70069, 45.7493], [20.77416, 45.75601], [20.78446, 45.78522], [20.82364, 45.77738], [20.80361, 45.65875], [20.76798, 45.60969], [20.83321, 45.53567], [20.77217, 45.49788], [20.86026, 45.47295], [20.87948, 45.42743], [21.09894, 45.30144], [21.17612, 45.32566], [21.20392, 45.2677], [21.29398, 45.24148], [21.48278, 45.19557], [21.51299, 45.15345], [21.4505, 45.04294], [21.35855, 45.01941], [21.54938, 44.9327], [21.56328, 44.89502], [21.48202, 44.87199], [21.44013, 44.87613], [21.35643, 44.86364], [21.38802, 44.78133], [21.55007, 44.77304], [21.60019, 44.75208], [21.61942, 44.67059], [21.67504, 44.67107], [21.71692, 44.65349], [21.7795, 44.66165], [21.99364, 44.63395], [22.08016, 44.49844], [22.13234, 44.47444], [22.18315, 44.48179], [22.30844, 44.6619], [22.45301, 44.7194], [22.61917, 44.61489], [22.69196, 44.61587], [22.76749, 44.54446], [22.70981, 44.51852], [22.61368, 44.55719], [22.56493, 44.53419], [22.54021, 44.47836], [22.45436, 44.47258], [22.56012, 44.30712], [22.68166, 44.28206], [22.67173, 44.21564], [23.04988, 44.07694], [23.01674, 44.01946], [22.87873, 43.9844], [22.83753, 43.88055], [22.85314, 43.84452], [23.05288, 43.79494], [23.26772, 43.84843], [23.4507, 43.84936], [23.61687, 43.79289], [23.73978, 43.80627], [24.18149, 43.68218], [24.35364, 43.70211], [24.50264, 43.76314], [24.62281, 43.74082], [24.73542, 43.68523], [24.96682, 43.72693], [25.10718, 43.6831], [25.17144, 43.70261], [25.39528, 43.61866], [25.72792, 43.69263], [25.94911, 43.85745], [26.05584, 43.90925], [26.10115, 43.96908], [26.38764, 44.04356], [26.62712, 44.05698], [26.95141, 44.13555], [27.26845, 44.12602], [27.39757, 44.0141], [27.60834, 44.01206], [27.64542, 44.04958], [27.73468, 43.95326], [27.92008, 44.00761], [27.99558, 43.84193], [28.23293, 43.76], [29.24336, 43.70874], [30.04414, 45.08461], [29.69272, 45.19227], [29.65428, 45.25629], [29.68175, 45.26885], [29.59798, 45.38857], [29.42632, 45.44545], [29.24779, 45.43388], [28.96077, 45.33164], [28.94292, 45.28045], [28.81383, 45.3384], [28.78911, 45.24179], [28.71358, 45.22631], [28.5735, 45.24759], [28.34554, 45.32102], [28.28504, 45.43907], [28.21139, 45.46895], [28.18741, 45.47358], [28.08927, 45.6051], [28.16568, 45.6421], [28.13111, 45.92819], [28.08612, 46.01105], [28.13684, 46.18099], [28.10937, 46.22852], [28.19864, 46.31869], [28.18902, 46.35283], [28.25769, 46.43334], [28.22281, 46.50481], [28.24808, 46.64305], [28.12173, 46.82283], [28.09095, 46.97621], [27.81892, 47.1381], [27.73172, 47.29248], [27.68706, 47.28962], [27.60263, 47.32507], [27.55731, 47.46637], [27.47942, 47.48113], [27.3979, 47.59473], [27.32202, 47.64009], [27.25519, 47.71366], [27.29069, 47.73722], [27.1618, 47.92391], [27.15622, 47.98538]]]] } },
    { type: "Feature", properties: { iso1A2: "RS", iso1A3: "SRB", iso1N3: "688", wikidata: "Q403", nameEn: "Serbia", groups: ["039", "150", "UN"], callingCodes: ["381"] }, geometry: { type: "MultiPolygon", coordinates: [[[[19.66007, 46.19005], [19.56113, 46.16824], [19.52473, 46.1171], [19.28826, 45.99694], [19.14543, 45.9998], [19.10388, 46.04015], [19.0791, 45.96458], [19.01284, 45.96529], [18.99712, 45.93537], [18.81394, 45.91329], [18.85783, 45.85493], [18.90305, 45.71863], [18.96691, 45.66731], [18.88776, 45.57253], [18.94562, 45.53712], [19.07471, 45.53086], [19.08364, 45.48804], [18.99918, 45.49333], [18.97446, 45.37528], [19.10774, 45.29547], [19.28208, 45.23813], [19.41941, 45.23475], [19.43589, 45.17137], [19.19144, 45.17863], [19.14063, 45.12972], [19.07952, 45.14668], [19.1011, 45.01191], [19.05205, 44.97692], [19.15573, 44.95409], [19.06853, 44.89915], [19.02871, 44.92541], [18.98957, 44.90645], [19.01994, 44.85493], [19.18183, 44.92055], [19.36722, 44.88164], [19.32543, 44.74058], [19.26388, 44.65412], [19.16699, 44.52197], [19.13369, 44.52521], [19.12278, 44.50132], [19.14837, 44.45253], [19.14681, 44.41463], [19.11785, 44.40313], [19.10749, 44.39421], [19.10704, 44.38249], [19.10365, 44.37795], [19.10298, 44.36924], [19.11865, 44.36712], [19.1083, 44.3558], [19.11547, 44.34218], [19.13556, 44.338], [19.13332, 44.31492], [19.16741, 44.28648], [19.18328, 44.28383], [19.20508, 44.2917], [19.23306, 44.26097], [19.26945, 44.26957], [19.32464, 44.27185], [19.34773, 44.23244], [19.3588, 44.18353], [19.40927, 44.16722], [19.43905, 44.13088], [19.47338, 44.15034], [19.48386, 44.14332], [19.47321, 44.1193], [19.51167, 44.08158], [19.55999, 44.06894], [19.57467, 44.04716], [19.61991, 44.05254], [19.61836, 44.01464], [19.56498, 43.99922], [19.52515, 43.95573], [19.38439, 43.96611], [19.24363, 44.01502], [19.23465, 43.98764], [19.3986, 43.79668], [19.5176, 43.71403], [19.50455, 43.58385], [19.42696, 43.57987], [19.41941, 43.54056], [19.36653, 43.60921], [19.33426, 43.58833], [19.2553, 43.5938], [19.24774, 43.53061], [19.22807, 43.5264], [19.22229, 43.47926], [19.44315, 43.38846], [19.48171, 43.32644], [19.52962, 43.31623], [19.54598, 43.25158], [19.62661, 43.2286], [19.64063, 43.19027], [19.76918, 43.16044], [19.79255, 43.11951], [19.92576, 43.08539], [19.96549, 43.11098], [19.98887, 43.0538], [20.04729, 43.02732], [20.05431, 42.99571], [20.12325, 42.96237], [20.14896, 42.99058], [20.16415, 42.97177], [20.34528, 42.90676], [20.35692, 42.8335], [20.40594, 42.84853], [20.43734, 42.83157], [20.53484, 42.8885], [20.48692, 42.93208], [20.59929, 43.01067], [20.64557, 43.00826], [20.69515, 43.09641], [20.59929, 43.20492], [20.68688, 43.21335], [20.73811, 43.25068], [20.82145, 43.26769], [20.88685, 43.21697], [20.83727, 43.17842], [20.96287, 43.12416], [21.00749, 43.13984], [21.05378, 43.10707], [21.08952, 43.13471], [21.14465, 43.11089], [21.16734, 42.99694], [21.2041, 43.02277], [21.23877, 43.00848], [21.23534, 42.95523], [21.2719, 42.8994], [21.32974, 42.90424], [21.36941, 42.87397], [21.44047, 42.87276], [21.39045, 42.74888], [21.47498, 42.74695], [21.59154, 42.72643], [21.58755, 42.70418], [21.6626, 42.67813], [21.75025, 42.70125], [21.79413, 42.65923], [21.75672, 42.62695], [21.7327, 42.55041], [21.70522, 42.54176], [21.7035, 42.51899], [21.62556, 42.45106], [21.64209, 42.41081], [21.62887, 42.37664], [21.59029, 42.38042], [21.57021, 42.3647], [21.53467, 42.36809], [21.5264, 42.33634], [21.56772, 42.30946], [21.58992, 42.25915], [21.70111, 42.23789], [21.77176, 42.2648], [21.84654, 42.3247], [21.91595, 42.30392], [21.94405, 42.34669], [22.02908, 42.29848], [22.16384, 42.32103], [22.29605, 42.37477], [22.29275, 42.34913], [22.34773, 42.31725], [22.45919, 42.33822], [22.47498, 42.3915], [22.51961, 42.3991], [22.55669, 42.50144], [22.43983, 42.56851], [22.4997, 42.74144], [22.43309, 42.82057], [22.54302, 42.87774], [22.74826, 42.88701], [22.78397, 42.98253], [22.89521, 43.03625], [22.98104, 43.11199], [23.00806, 43.19279], [22.89727, 43.22417], [22.82036, 43.33665], [22.53397, 43.47225], [22.47582, 43.6558], [22.41043, 43.69566], [22.35558, 43.81281], [22.41449, 44.00514], [22.61688, 44.06534], [22.61711, 44.16938], [22.67173, 44.21564], [22.68166, 44.28206], [22.56012, 44.30712], [22.45436, 44.47258], [22.54021, 44.47836], [22.56493, 44.53419], [22.61368, 44.55719], [22.70981, 44.51852], [22.76749, 44.54446], [22.69196, 44.61587], [22.61917, 44.61489], [22.45301, 44.7194], [22.30844, 44.6619], [22.18315, 44.48179], [22.13234, 44.47444], [22.08016, 44.49844], [21.99364, 44.63395], [21.7795, 44.66165], [21.71692, 44.65349], [21.67504, 44.67107], [21.61942, 44.67059], [21.60019, 44.75208], [21.55007, 44.77304], [21.38802, 44.78133], [21.35643, 44.86364], [21.44013, 44.87613], [21.48202, 44.87199], [21.56328, 44.89502], [21.54938, 44.9327], [21.35855, 45.01941], [21.4505, 45.04294], [21.51299, 45.15345], [21.48278, 45.19557], [21.29398, 45.24148], [21.20392, 45.2677], [21.17612, 45.32566], [21.09894, 45.30144], [20.87948, 45.42743], [20.86026, 45.47295], [20.77217, 45.49788], [20.83321, 45.53567], [20.76798, 45.60969], [20.80361, 45.65875], [20.82364, 45.77738], [20.78446, 45.78522], [20.77416, 45.75601], [20.70069, 45.7493], [20.65645, 45.82801], [20.54818, 45.89939], [20.35862, 45.99356], [20.26068, 46.12332], [20.09713, 46.17315], [20.03533, 46.14509], [20.01816, 46.17696], [19.93508, 46.17553], [19.81491, 46.1313], [19.66007, 46.19005]]]] } },
    { type: "Feature", properties: { iso1A2: "RU", iso1A3: "RUS", iso1N3: "643", wikidata: "Q159", nameEn: "Russia" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "RW", iso1A3: "RWA", iso1N3: "646", wikidata: "Q1037", nameEn: "Rwanda", groups: ["014", "202", "002", "UN"], callingCodes: ["250"] }, geometry: { type: "MultiPolygon", coordinates: [[[[30.47194, -1.0555], [30.35212, -1.06896], [30.16369, -1.34303], [29.912, -1.48269], [29.82657, -1.31187], [29.59061, -1.39016], [29.53062, -1.40499], [29.45038, -1.5054], [29.36322, -1.50887], [29.24323, -1.66826], [29.24458, -1.69663], [29.11847, -1.90576], [29.17562, -2.12278], [29.105, -2.27043], [29.00051, -2.29001], [28.95642, -2.37321], [28.89601, -2.37321], [28.86826, -2.41888], [28.86846, -2.44866], [28.89132, -2.47557], [28.89342, -2.49017], [28.88846, -2.50493], [28.87497, -2.50887], [28.86209, -2.5231], [28.86193, -2.53185], [28.87943, -2.55165], [28.89288, -2.55848], [28.90226, -2.62385], [28.89793, -2.66111], [28.94346, -2.69124], [29.00357, -2.70596], [29.04081, -2.7416], [29.0562, -2.58632], [29.32234, -2.6483], [29.36805, -2.82933], [29.88237, -2.75105], [29.95911, -2.33348], [30.14034, -2.43626], [30.42933, -2.31064], [30.54501, -2.41404], [30.83915, -2.35795], [30.89303, -2.08223], [30.80802, -1.91477], [30.84079, -1.64652], [30.71974, -1.43244], [30.57123, -1.33264], [30.50889, -1.16412], [30.45116, -1.10641], [30.47194, -1.0555]]]] } },
    { type: "Feature", properties: { iso1A2: "SA", iso1A3: "SAU", iso1N3: "682", wikidata: "Q851", nameEn: "Saudi Arabia", groups: ["145", "142", "UN"], callingCodes: ["966"] }, geometry: { type: "MultiPolygon", coordinates: [[[[40.01521, 32.05667], [39.29903, 32.23259], [38.99233, 31.99721], [36.99791, 31.50081], [37.99354, 30.49998], [37.66395, 30.33245], [37.4971, 29.99949], [36.75083, 29.86903], [36.50005, 29.49696], [36.07081, 29.18469], [34.8812, 29.36878], [34.4454, 27.91479], [37.8565, 22.00903], [39.63762, 18.37348], [40.99158, 15.81743], [42.15205, 16.40211], [42.76801, 16.40371], [42.94625, 16.39721], [42.94351, 16.49467], [42.97215, 16.51093], [43.11601, 16.53166], [43.15274, 16.67248], [43.22066, 16.65179], [43.21325, 16.74416], [43.25857, 16.75304], [43.26303, 16.79479], [43.24801, 16.80613], [43.22956, 16.80613], [43.22012, 16.83932], [43.18338, 16.84852], [43.1398, 16.90696], [43.19328, 16.94703], [43.1813, 16.98438], [43.18233, 17.02673], [43.23967, 17.03428], [43.17787, 17.14717], [43.20156, 17.25901], [43.32653, 17.31179], [43.22533, 17.38343], [43.29185, 17.53224], [43.43005, 17.56148], [43.70631, 17.35762], [44.50126, 17.47475], [46.31018, 17.20464], [46.76494, 17.29151], [47.00571, 16.94765], [47.48245, 17.10808], [47.58351, 17.50366], [48.19996, 18.20584], [49.04884, 18.59899], [52.00311, 19.00083], [54.99756, 20.00083], [55.66469, 21.99658], [55.2137, 22.71065], [55.13599, 22.63334], [52.56622, 22.94341], [51.59617, 24.12041], [51.58871, 24.27256], [51.41644, 24.39615], [51.58834, 24.66608], [51.39468, 24.62785], [51.29972, 24.50747], [51.09638, 24.46907], [50.92992, 24.54396], [50.8133, 24.74049], [50.57069, 25.57887], [50.302, 25.87592], [50.26923, 26.08243], [50.38162, 26.53976], [50.71771, 26.73086], [50.37726, 27.89227], [49.98877, 27.87827], [49.00421, 28.81495], [48.42991, 28.53628], [47.70561, 28.5221], [47.59863, 28.66798], [47.58376, 28.83382], [47.46202, 29.0014], [46.5527, 29.10283], [46.42415, 29.05947], [44.72255, 29.19736], [42.97796, 30.48295], [42.97601, 30.72204], [40.01521, 32.05667]]]] } },
    { type: "Feature", properties: { iso1A2: "SB", iso1A3: "SLB", iso1N3: "090", wikidata: "Q685", nameEn: "Solomon Islands", groups: ["054", "009", "UN"], driveSide: "left", callingCodes: ["677"] }, geometry: { type: "MultiPolygon", coordinates: [[[[172.71443, -12.01327], [160.43769, -4.17974], [156.03296, -6.55528], [156.03993, -6.65703], [155.92557, -6.84664], [155.69784, -6.92661], [155.60735, -6.92266], [154.74815, -7.33315], [156.73836, -14.50464], [172.71443, -12.01327]]]] } },
    { type: "Feature", properties: { iso1A2: "SC", iso1A3: "SYC", iso1N3: "690", wikidata: "Q1042", nameEn: "Seychelles", groups: ["014", "202", "002", "UN"], driveSide: "left", callingCodes: ["248"] }, geometry: { type: "MultiPolygon", coordinates: [[[[43.75112, -10.38913], [54.83239, -10.93575], [66.3222, 5.65313], [43.75112, -10.38913]]]] } },
    { type: "Feature", properties: { iso1A2: "SD", iso1A3: "SDN", iso1N3: "729", wikidata: "Q1049", nameEn: "Sudan", groups: ["015", "002", "UN"], callingCodes: ["249"] }, geometry: { type: "MultiPolygon", coordinates: [[[[37.8565, 22.00903], [34.0765, 22.00501], [33.99686, 21.76784], [33.57251, 21.72406], [33.17563, 22.00405], [24.99885, 21.99535], [24.99794, 19.99661], [23.99715, 20.00038], [23.99539, 19.49944], [23.99997, 15.69575], [23.62785, 15.7804], [23.38812, 15.69649], [23.10792, 15.71297], [22.93201, 15.55107], [22.92579, 15.47007], [22.99584, 15.40105], [22.99584, 15.22989], [22.66115, 14.86308], [22.70474, 14.69149], [22.38562, 14.58907], [22.44944, 14.24986], [22.55997, 14.23024], [22.5553, 14.11704], [22.22995, 13.96754], [22.08674, 13.77863], [22.29689, 13.3731], [22.1599, 13.19281], [22.02914, 13.13976], [21.94819, 13.05637], [21.81432, 12.81362], [21.89371, 12.68001], [21.98711, 12.63292], [22.15679, 12.66634], [22.22684, 12.74682], [22.46345, 12.61925], [22.38873, 12.45514], [22.50548, 12.16769], [22.48369, 12.02766], [22.64092, 12.07485], [22.54907, 11.64372], [22.7997, 11.40424], [22.93124, 11.41645], [22.97249, 11.21955], [22.87758, 10.91915], [23.02221, 10.69235], [23.3128, 10.45214], [23.67164, 9.86923], [23.69155, 9.67566], [24.09319, 9.66572], [24.12744, 9.73784], [24.49389, 9.79962], [24.84653, 9.80643], [24.97739, 9.9081], [25.05688, 10.06776], [25.0918, 10.33718], [25.78141, 10.42599], [25.93163, 10.38159], [25.93241, 10.17941], [26.21338, 9.91545], [26.35815, 9.57946], [26.70685, 9.48735], [27.14427, 9.62858], [27.90704, 9.61323], [28.99983, 9.67155], [29.06988, 9.74826], [29.53844, 9.75133], [29.54, 10.07949], [29.94629, 10.29245], [30.00389, 10.28633], [30.53005, 9.95992], [30.82893, 9.71451], [30.84605, 9.7498], [31.28504, 9.75287], [31.77539, 10.28939], [31.99177, 10.65065], [32.46967, 11.04662], [32.39358, 11.18207], [32.39578, 11.70208], [32.10079, 11.95203], [32.73921, 11.95203], [32.73921, 12.22757], [33.25876, 12.22111], [33.13988, 11.43248], [33.26977, 10.83632], [33.24645, 10.77913], [33.52294, 10.64382], [33.66604, 10.44254], [33.80913, 10.32994], [33.90159, 10.17179], [33.96984, 10.15446], [33.99185, 9.99623], [33.96323, 9.80972], [33.9082, 9.762], [33.87958, 9.49937], [34.10229, 9.50238], [34.08717, 9.55243], [34.13186, 9.7492], [34.20484, 9.9033], [34.22718, 10.02506], [34.32102, 10.11599], [34.34783, 10.23914], [34.2823, 10.53508], [34.4372, 10.781], [34.59062, 10.89072], [34.77383, 10.74588], [34.77532, 10.69027], [34.86618, 10.74588], [34.86916, 10.78832], [34.97491, 10.86147], [34.97789, 10.91559], [34.93172, 10.95946], [35.01215, 11.19626], [34.95704, 11.24448], [35.09556, 11.56278], [35.05832, 11.71158], [35.11492, 11.85156], [35.24302, 11.91132], [35.70476, 12.67101], [36.01458, 12.72478], [36.14268, 12.70879], [36.16651, 12.88019], [36.13374, 12.92665], [36.24545, 13.36759], [36.38993, 13.56459], [36.48824, 13.83954], [36.44653, 13.95666], [36.54376, 14.25597], [36.44337, 15.14963], [36.54276, 15.23478], [36.69761, 15.75323], [36.76371, 15.80831], [36.92193, 16.23451], [36.99777, 17.07172], [37.42694, 17.04041], [37.50967, 17.32199], [38.13362, 17.53906], [38.37133, 17.66269], [38.45916, 17.87167], [38.57727, 17.98125], [39.63762, 18.37348], [37.8565, 22.00903]]]] } },
    { type: "Feature", properties: { iso1A2: "SE", iso1A3: "SWE", iso1N3: "752", wikidata: "Q34", nameEn: "Sweden", groups: ["EU", "154", "150", "UN"], callingCodes: ["46"] }, geometry: { type: "MultiPolygon", coordinates: [[[[24.15791, 65.85385], [23.90497, 66.15802], [23.71339, 66.21299], [23.64982, 66.30603], [23.67591, 66.3862], [23.63776, 66.43568], [23.85959, 66.56434], [23.89488, 66.772], [23.98059, 66.79585], [23.98563, 66.84149], [23.56214, 67.17038], [23.58735, 67.20752], [23.54701, 67.25435], [23.75372, 67.29914], [23.75372, 67.43688], [23.39577, 67.46974], [23.54701, 67.59306], [23.45627, 67.85297], [23.65793, 67.9497], [23.40081, 68.05545], [23.26469, 68.15134], [23.15377, 68.14759], [23.10336, 68.26551], [22.73028, 68.40881], [22.00429, 68.50692], [21.03001, 68.88969], [20.90649, 68.89696], [20.85104, 68.93142], [20.91658, 68.96764], [20.78802, 69.03087], [20.55258, 69.06069], [20.0695, 69.04469], [20.28444, 68.93283], [20.33435, 68.80174], [20.22027, 68.67246], [19.95647, 68.55546], [20.22027, 68.48759], [19.93508, 68.35911], [18.97255, 68.52416], [18.63032, 68.50849], [18.39503, 68.58672], [18.1241, 68.53721], [18.13836, 68.20874], [17.90787, 67.96537], [17.30416, 68.11591], [16.7409, 67.91037], [16.38441, 67.52923], [16.12774, 67.52106], [16.09922, 67.4364], [16.39154, 67.21653], [16.35589, 67.06419], [15.37197, 66.48217], [15.49318, 66.28509], [15.05113, 66.15572], [14.53778, 66.12399], [14.50926, 65.31786], [13.64276, 64.58402], [14.11117, 64.46674], [14.16051, 64.18725], [13.98222, 64.00953], [13.23411, 64.09087], [12.74105, 64.02171], [12.14928, 63.59373], [12.19919, 63.47935], [11.98529, 63.27487], [12.19919, 63.00104], [12.07085, 62.6297], [12.29187, 62.25699], [12.14746, 61.7147], [12.40595, 61.57226], [12.57707, 61.56547], [12.86939, 61.35427], [12.69115, 61.06584], [12.2277, 61.02442], [12.59133, 60.50559], [12.52003, 60.13846], [12.36317, 59.99259], [12.15641, 59.8926], [11.87121, 59.86039], [11.92112, 59.69531], [11.69297, 59.59442], [11.8213, 59.24985], [11.65732, 58.90177], [11.45199, 58.89604], [11.4601, 58.99022], [11.34459, 59.11672], [11.15367, 59.07862], [11.08911, 58.98745], [10.64958, 58.89391], [10.40861, 58.38489], [12.16597, 56.60205], [12.07466, 56.29488], [12.65312, 56.04345], [12.6372, 55.91371], [12.88472, 55.63369], [12.60345, 55.42675], [12.84405, 55.13257], [14.28399, 55.1553], [14.89259, 55.5623], [15.79951, 55.54655], [19.64795, 57.06466], [19.84909, 57.57876], [20.5104, 59.15546], [19.08191, 60.19152], [19.23413, 60.61414], [20.15877, 63.06556], [24.14112, 65.39731], [24.15107, 65.81427], [24.14798, 65.83466], [24.15791, 65.85385]]]] } },
    { type: "Feature", properties: { iso1A2: "SG", iso1A3: "SGP", iso1N3: "702", wikidata: "Q334", nameEn: "Singapore", groups: ["035", "142", "UN"], driveSide: "left", callingCodes: ["65"] }, geometry: { type: "MultiPolygon", coordinates: [[[[104.00131, 1.42405], [103.93384, 1.42926], [103.89565, 1.42841], [103.86383, 1.46288], [103.81181, 1.47953], [103.76395, 1.45183], [103.74161, 1.4502], [103.7219, 1.46108], [103.67468, 1.43166], [103.62738, 1.35255], [103.56591, 1.19719], [103.66049, 1.18825], [103.74084, 1.12902], [104.03085, 1.26954], [104.12282, 1.27714], [104.08072, 1.35998], [104.09162, 1.39694], [104.08871, 1.42015], [104.07348, 1.43322], [104.04622, 1.44691], [104.02277, 1.4438], [104.00131, 1.42405]]]] } },
    { type: "Feature", properties: { iso1A2: "SH", iso1A3: "SHN", iso1N3: "654", wikidata: "Q192184", nameEn: "Saint Helena, Ascension and Tristan da Cunha", country: "GB" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "SI", iso1A3: "SVN", iso1N3: "705", wikidata: "Q215", nameEn: "Slovenia", groups: ["EU", "039", "150", "UN"], callingCodes: ["386"] }, geometry: { type: "MultiPolygon", coordinates: [[[[16.50139, 46.56684], [16.39217, 46.63673], [16.38594, 46.6549], [16.41863, 46.66238], [16.42641, 46.69228], [16.37816, 46.69975], [16.30966, 46.7787], [16.31303, 46.79838], [16.3408, 46.80641], [16.34547, 46.83836], [16.2941, 46.87137], [16.2365, 46.87775], [16.21892, 46.86961], [16.15711, 46.85434], [16.14365, 46.8547], [16.10983, 46.867], [16.05786, 46.83927], [15.99054, 46.82772], [15.99126, 46.78199], [15.98432, 46.74991], [15.99769, 46.7266], [16.02808, 46.71094], [16.04347, 46.68694], [16.04036, 46.6549], [15.99988, 46.67947], [15.98512, 46.68463], [15.94864, 46.68769], [15.87691, 46.7211], [15.8162, 46.71897], [15.78518, 46.70712], [15.76771, 46.69863], [15.73823, 46.70011], [15.72279, 46.69548], [15.69523, 46.69823], [15.67411, 46.70735], [15.6543, 46.70616], [15.6543, 46.69228], [15.6365, 46.6894], [15.63255, 46.68069], [15.62317, 46.67947], [15.59826, 46.68908], [15.54533, 46.66985], [15.55333, 46.64988], [15.54431, 46.6312], [15.46906, 46.61321], [15.45514, 46.63697], [15.41235, 46.65556], [15.23711, 46.63994], [15.14215, 46.66131], [15.01451, 46.641], [14.98024, 46.6009], [14.96002, 46.63459], [14.92283, 46.60848], [14.87129, 46.61], [14.86419, 46.59411], [14.83549, 46.56614], [14.81836, 46.51046], [14.72185, 46.49974], [14.66892, 46.44936], [14.5942, 46.43434], [14.56463, 46.37208], [14.52176, 46.42617], [14.45877, 46.41717], [14.42608, 46.44614], [14.314, 46.43327], [14.28326, 46.44315], [14.15989, 46.43327], [14.12097, 46.47724], [14.04002, 46.49117], [14.00422, 46.48474], [13.89837, 46.52331], [13.7148, 46.5222], [13.68684, 46.43881], [13.59777, 46.44137], [13.5763, 46.42613], [13.5763, 46.40915], [13.47019, 46.3621], [13.43418, 46.35992], [13.44808, 46.33507], [13.37671, 46.29668], [13.42218, 46.20758], [13.47587, 46.22725], [13.56114, 46.2054], [13.56682, 46.18703], [13.64451, 46.18966], [13.66472, 46.17392], [13.64053, 46.13587], [13.57072, 46.09022], [13.50104, 46.05986], [13.49568, 46.04839], [13.50998, 46.04498], [13.49702, 46.01832], [13.47474, 46.00546], [13.50104, 45.98078], [13.52963, 45.96588], [13.56759, 45.96991], [13.58903, 45.99009], [13.62074, 45.98388], [13.63458, 45.98947], [13.64307, 45.98326], [13.6329, 45.94894], [13.63815, 45.93607], [13.61931, 45.91782], [13.60857, 45.89907], [13.59565, 45.89446], [13.58644, 45.88173], [13.57563, 45.8425], [13.58858, 45.83503], [13.59784, 45.8072], [13.66986, 45.79955], [13.8235, 45.7176], [13.83332, 45.70855], [13.83422, 45.68703], [13.87933, 45.65207], [13.9191, 45.6322], [13.8695, 45.60835], [13.86771, 45.59898], [13.84106, 45.58185], [13.78445, 45.5825], [13.74587, 45.59811], [13.7198, 45.59352], [13.6076, 45.64761], [13.45644, 45.59464], [13.56979, 45.4895], [13.62902, 45.45898], [13.67398, 45.4436], [13.7785, 45.46787], [13.81742, 45.43729], [13.88124, 45.42637], [13.90771, 45.45149], [13.97309, 45.45258], [13.99488, 45.47551], [13.96063, 45.50825], [14.00578, 45.52352], [14.07116, 45.48752], [14.20348, 45.46896], [14.22371, 45.50388], [14.24239, 45.50607], [14.26611, 45.48239], [14.27681, 45.4902], [14.32487, 45.47142], [14.36693, 45.48642], [14.49769, 45.54424], [14.5008, 45.60852], [14.53816, 45.6205], [14.57397, 45.67165], [14.60977, 45.66403], [14.59576, 45.62812], [14.69694, 45.57366], [14.68605, 45.53006], [14.71718, 45.53442], [14.80124, 45.49515], [14.81992, 45.45913], [14.90554, 45.47769], [14.92266, 45.52788], [15.02385, 45.48533], [15.05187, 45.49079], [15.16862, 45.42309], [15.27758, 45.46678], [15.33051, 45.45258], [15.38188, 45.48752], [15.30249, 45.53224], [15.29837, 45.5841], [15.27747, 45.60504], [15.31027, 45.6303], [15.34695, 45.63382], [15.34214, 45.64702], [15.38952, 45.63682], [15.4057, 45.64727], [15.34919, 45.71623], [15.30872, 45.69014], [15.25423, 45.72275], [15.40836, 45.79491], [15.47531, 45.79802], [15.47325, 45.8253], [15.52234, 45.82195], [15.57952, 45.84953], [15.64185, 45.82915], [15.66662, 45.84085], [15.70411, 45.8465], [15.68232, 45.86819], [15.68383, 45.88867], [15.67967, 45.90455], [15.70636, 45.92116], [15.70327, 46.00015], [15.71246, 46.01196], [15.72977, 46.04682], [15.62317, 46.09103], [15.6083, 46.11992], [15.59909, 46.14761], [15.64904, 46.19229], [15.6434, 46.21396], [15.67395, 46.22478], [15.75436, 46.21969], [15.75479, 46.20336], [15.78817, 46.21719], [15.79284, 46.25811], [15.97965, 46.30652], [16.07616, 46.3463], [16.07314, 46.36458], [16.05065, 46.3833], [16.05281, 46.39141], [16.14859, 46.40547], [16.18824, 46.38282], [16.30233, 46.37837], [16.30162, 46.40437], [16.27329, 46.41467], [16.27398, 46.42875], [16.25124, 46.48067], [16.23961, 46.49653], [16.26759, 46.50566], [16.26733, 46.51505], [16.29793, 46.5121], [16.37193, 46.55008], [16.38771, 46.53608], [16.44036, 46.5171], [16.5007, 46.49644], [16.52604, 46.47831], [16.59527, 46.47524], [16.52604, 46.5051], [16.52885, 46.53303], [16.50139, 46.56684]]]] } },
    { type: "Feature", properties: { iso1A2: "SJ", iso1A3: "SJM", iso1N3: "744", wikidata: "Q842829", nameEn: "Svalbard and Jan Mayen", country: "NO" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "SK", iso1A3: "SVK", iso1N3: "703", wikidata: "Q214", nameEn: "Slovakia", groups: ["EU", "151", "150", "UN"], callingCodes: ["421"] }, geometry: { type: "MultiPolygon", coordinates: [[[[19.82237, 49.27806], [19.78581, 49.41701], [19.72127, 49.39288], [19.6375, 49.40897], [19.64162, 49.45184], [19.57845, 49.46077], [19.53313, 49.52856], [19.52626, 49.57311], [19.45348, 49.61583], [19.37795, 49.574], [19.36009, 49.53747], [19.25435, 49.53391], [19.18019, 49.41165], [18.9742, 49.39557], [18.97283, 49.49914], [18.94536, 49.52143], [18.84521, 49.51672], [18.74761, 49.492], [18.67757, 49.50895], [18.6144, 49.49824], [18.57183, 49.51162], [18.53063, 49.49022], [18.54848, 49.47059], [18.44686, 49.39467], [18.4084, 49.40003], [18.4139, 49.36517], [18.36446, 49.3267], [18.18456, 49.28909], [18.15022, 49.24518], [18.1104, 49.08624], [18.06885, 49.03157], [17.91814, 49.01784], [17.87831, 48.92679], [17.77944, 48.92318], [17.73126, 48.87885], [17.7094, 48.86721], [17.5295, 48.81117], [17.45671, 48.85004], [17.3853, 48.80936], [17.29054, 48.85546], [17.19355, 48.87602], [17.11202, 48.82925], [17.00215, 48.70887], [16.93955, 48.60371], [16.94611, 48.53614], [16.85204, 48.44968], [16.8497, 48.38321], [16.83588, 48.3844], [16.83317, 48.38138], [16.84243, 48.35258], [16.90903, 48.32519], [16.89461, 48.31332], [16.97701, 48.17385], [17.02919, 48.13996], [17.05735, 48.14179], [17.09168, 48.09366], [17.07039, 48.0317], [17.16001, 48.00636], [17.23699, 48.02094], [17.71215, 47.7548], [18.02938, 47.75665], [18.29305, 47.73541], [18.56496, 47.76588], [18.66521, 47.76772], [18.74074, 47.8157], [18.8506, 47.82308], [18.76821, 47.87469], [18.76134, 47.97499], [18.82176, 48.04206], [19.01952, 48.07052], [19.23924, 48.0595], [19.28182, 48.08336], [19.47957, 48.09437], [19.52489, 48.19791], [19.63338, 48.25006], [19.92452, 48.1283], [20.24312, 48.2784], [20.29943, 48.26104], [20.5215, 48.53336], [20.83248, 48.5824], [21.11516, 48.49546], [21.44063, 48.58456], [21.6068, 48.50365], [21.67134, 48.3989], [21.72525, 48.34628], [21.8279, 48.33321], [21.83339, 48.36242], [22.14689, 48.4005], [22.16023, 48.56548], [22.21379, 48.6218], [22.34151, 48.68893], [22.42934, 48.92857], [22.48296, 48.99172], [22.54338, 49.01424], [22.56155, 49.08865], [22.04427, 49.22136], [21.96385, 49.3437], [21.82927, 49.39467], [21.77983, 49.35443], [21.62328, 49.4447], [21.43376, 49.41433], [21.27858, 49.45988], [21.19756, 49.4054], [21.12477, 49.43666], [21.041, 49.41791], [21.09799, 49.37176], [20.98733, 49.30774], [20.9229, 49.29626], [20.77971, 49.35383], [20.72274, 49.41813], [20.61666, 49.41791], [20.5631, 49.375], [20.46422, 49.41612], [20.39939, 49.3896], [20.31728, 49.39914], [20.31453, 49.34817], [20.21977, 49.35265], [20.13738, 49.31685], [20.08238, 49.1813], [19.98494, 49.22904], [19.90529, 49.23532], [19.86409, 49.19316], [19.75286, 49.20751], [19.82237, 49.27806]]]] } },
    { type: "Feature", properties: { iso1A2: "SL", iso1A3: "SLE", iso1N3: "694", wikidata: "Q1044", nameEn: "Sierra Leone", groups: ["011", "202", "002", "UN"], callingCodes: ["232"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-10.27575, 8.48711], [-10.37257, 8.48941], [-10.54891, 8.31174], [-10.63934, 8.35326], [-10.70565, 8.29235], [-10.61422, 8.5314], [-10.47707, 8.67669], [-10.56197, 8.81225], [-10.5783, 9.06386], [-10.74484, 9.07998], [-10.6534, 9.29919], [-11.2118, 10.00098], [-11.89624, 9.99763], [-11.91023, 9.93927], [-12.12634, 9.87203], [-12.24262, 9.92386], [-12.47254, 9.86834], [-12.76788, 9.3133], [-12.94095, 9.26335], [-13.08953, 9.0409], [-13.18586, 9.0925], [-13.29911, 9.04245], [-14.36218, 8.64107], [-12.15048, 6.15992], [-11.50429, 6.92704], [-11.4027, 6.97746], [-11.29417, 7.21576], [-10.60422, 7.7739], [-10.60492, 8.04072], [-10.57523, 8.04829], [-10.51554, 8.1393], [-10.45023, 8.15627], [-10.35227, 8.15223], [-10.29839, 8.21283], [-10.31635, 8.28554], [-10.30084, 8.30008], [-10.27575, 8.48711]]]] } },
    { type: "Feature", properties: { iso1A2: "SM", iso1A3: "SMR", iso1N3: "674", wikidata: "Q238", nameEn: "San Marino", groups: ["039", "150", "UN"], callingCodes: ["378"] }, geometry: { type: "MultiPolygon", coordinates: [[[[12.45648, 43.89369], [12.48771, 43.89706], [12.49429, 43.90973], [12.49247, 43.91774], [12.49724, 43.92248], [12.50269, 43.92363], [12.50496, 43.93017], [12.51553, 43.94096], [12.51427, 43.94897], [12.50655, 43.95796], [12.50875, 43.96198], [12.50622, 43.97131], [12.51109, 43.97201], [12.51064, 43.98165], [12.5154, 43.98508], [12.51463, 43.99122], [12.50678, 43.99113], [12.49406, 43.98492], [12.47853, 43.98052], [12.46205, 43.97463], [12.44684, 43.96597], [12.43662, 43.95698], [12.42005, 43.9578], [12.41414, 43.95273], [12.40415, 43.95485], [12.40506, 43.94325], [12.41165, 43.93769], [12.41551, 43.92984], [12.40733, 43.92379], [12.41233, 43.90956], [12.40935, 43.9024], [12.41641, 43.89991], [12.44184, 43.90498], [12.45648, 43.89369]]]] } },
    { type: "Feature", properties: { iso1A2: "SN", iso1A3: "SEN", iso1N3: "686", wikidata: "Q1041", nameEn: "Senegal", groups: ["011", "202", "002", "UN"], callingCodes: ["221"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-14.32144, 16.61495], [-15.00557, 16.64997], [-15.6509, 16.50315], [-16.27016, 16.51565], [-16.4429, 16.20605], [-16.44814, 16.09753], [-16.48967, 16.0496], [-16.50854, 16.09032], [-17.15288, 16.07139], [-18.35085, 14.63444], [-17.43598, 13.59273], [-15.47902, 13.58758], [-15.36504, 13.79313], [-14.93719, 13.80173], [-14.34721, 13.46578], [-13.8955, 13.59126], [-13.79409, 13.34472], [-14.36795, 13.23033], [-15.14917, 13.57989], [-15.26908, 13.37768], [-15.80478, 13.34832], [-15.80355, 13.16729], [-16.69343, 13.16791], [-16.74676, 13.06025], [-17.43966, 13.04579], [-17.4623, 11.92379], [-16.70562, 12.34803], [-16.38191, 12.36449], [-16.20591, 12.46157], [-15.67302, 12.42974], [-15.17582, 12.6847], [-13.70523, 12.68013], [-13.05296, 12.64003], [-13.06603, 12.49342], [-12.87336, 12.51892], [-12.35415, 12.32758], [-11.91331, 12.42008], [-11.46267, 12.44559], [-11.37536, 12.40788], [-11.39935, 12.97808], [-11.63025, 13.39174], [-11.83345, 13.33333], [-12.06897, 13.71049], [-11.93043, 13.84505], [-12.23936, 14.76324], [-13.11029, 15.52116], [-13.43135, 16.09022], [-13.80075, 16.13961], [-14.32144, 16.61495]]]] } },
    { type: "Feature", properties: { iso1A2: "SO", iso1A3: "SOM", iso1N3: "706", wikidata: "Q1045", nameEn: "Somalia", groups: ["014", "202", "002", "UN"], callingCodes: ["252"] }, geometry: { type: "MultiPolygon", coordinates: [[[[51.12877, 12.56479], [43.90659, 12.3823], [42.95776, 10.98533], [42.69452, 10.62672], [42.87643, 10.18441], [43.0937, 9.90579], [43.23518, 9.84605], [43.32613, 9.59205], [44.19222, 8.93028], [46.99339, 7.9989], [47.92477, 8.00111], [47.97917, 8.00124], [44.98104, 4.91821], [44.02436, 4.9451], [43.40263, 4.79289], [43.04177, 4.57923], [42.97746, 4.44032], [42.84526, 4.28357], [42.55853, 4.20518], [42.07619, 4.17667], [41.89488, 3.97375], [41.31368, 3.14314], [40.98767, 2.82959], [41.00099, -0.83068], [41.56, -1.59812], [41.56362, -1.66375], [41.75542, -1.85308], [57.49095, 8.14549], [51.12877, 12.56479]]]] } },
    { type: "Feature", properties: { iso1A2: "SR", iso1A3: "SUR", iso1N3: "740", wikidata: "Q730", nameEn: "Suriname", groups: ["005", "419", "019", "UN"], driveSide: "left", callingCodes: ["597"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-54.26916, 5.26909], [-54.01877, 5.52789], [-54.01074, 5.68785], [-53.7094, 6.2264], [-56.84822, 6.73257], [-57.31629, 5.33714], [-57.22536, 5.15605], [-57.37442, 5.0208], [-57.8699, 4.89394], [-58.0307, 3.95513], [-57.35891, 3.32121], [-56.70519, 2.02964], [-56.55439, 2.02003], [-56.47045, 1.95135], [-55.99278, 1.83137], [-55.89863, 1.89861], [-55.92159, 2.05236], [-56.13054, 2.27723], [-55.96292, 2.53188], [-55.71493, 2.40342], [-55.01919, 2.564], [-54.6084, 2.32856], [-54.42864, 2.42442], [-54.28534, 2.67798], [-53.9849, 3.58697], [-53.98914, 3.627], [-54.05128, 3.63557], [-54.19367, 3.84387], [-54.38444, 4.13222], [-54.4717, 4.91964], [-54.26916, 5.26909]]]] } },
    { type: "Feature", properties: { iso1A2: "SS", iso1A3: "SSD", iso1N3: "728", wikidata: "Q958", nameEn: "South Sudan", groups: ["014", "202", "002", "UN"], callingCodes: ["211"] }, geometry: { type: "MultiPolygon", coordinates: [[[[34.10229, 9.50238], [33.87958, 9.49937], [33.9082, 9.762], [33.96323, 9.80972], [33.99185, 9.99623], [33.96984, 10.15446], [33.90159, 10.17179], [33.80913, 10.32994], [33.66604, 10.44254], [33.52294, 10.64382], [33.24645, 10.77913], [33.26977, 10.83632], [33.13988, 11.43248], [33.25876, 12.22111], [32.73921, 12.22757], [32.73921, 11.95203], [32.10079, 11.95203], [32.39578, 11.70208], [32.39358, 11.18207], [32.46967, 11.04662], [31.99177, 10.65065], [31.77539, 10.28939], [31.28504, 9.75287], [30.84605, 9.7498], [30.82893, 9.71451], [30.53005, 9.95992], [30.00389, 10.28633], [29.94629, 10.29245], [29.54, 10.07949], [29.53844, 9.75133], [29.06988, 9.74826], [28.99983, 9.67155], [27.90704, 9.61323], [27.14427, 9.62858], [26.70685, 9.48735], [26.35815, 9.57946], [26.21338, 9.91545], [25.93241, 10.17941], [25.93163, 10.38159], [25.78141, 10.42599], [25.0918, 10.33718], [25.05688, 10.06776], [24.97739, 9.9081], [24.84653, 9.80643], [24.49389, 9.79962], [24.12744, 9.73784], [24.09319, 9.66572], [23.69155, 9.67566], [23.62179, 9.53823], [23.64981, 9.44303], [23.64358, 9.28637], [23.56263, 9.19418], [23.4848, 9.16959], [23.44744, 8.99128], [23.59065, 8.99743], [23.51905, 8.71749], [24.25691, 8.69288], [24.13238, 8.36959], [24.35965, 8.26177], [24.85156, 8.16933], [24.98855, 7.96588], [25.25319, 7.8487], [25.29214, 7.66675], [25.20649, 7.61115], [25.20337, 7.50312], [25.35281, 7.42595], [25.37461, 7.33024], [25.90076, 7.09549], [26.38022, 6.63493], [26.32729, 6.36272], [26.58259, 6.1987], [26.51721, 6.09655], [27.22705, 5.71254], [27.22705, 5.62889], [27.28621, 5.56382], [27.23017, 5.37167], [27.26886, 5.25876], [27.44012, 5.07349], [27.56656, 4.89375], [27.65462, 4.89375], [27.76469, 4.79284], [27.79551, 4.59976], [28.20719, 4.35614], [28.6651, 4.42638], [28.8126, 4.48784], [29.03054, 4.48784], [29.22207, 4.34297], [29.43341, 4.50101], [29.49726, 4.7007], [29.82087, 4.56246], [29.79666, 4.37809], [30.06964, 4.13221], [30.1621, 4.10586], [30.22374, 3.93896], [30.27658, 3.95653], [30.47691, 3.83353], [30.55396, 3.84451], [30.57378, 3.74567], [30.56277, 3.62703], [30.78512, 3.67097], [30.80713, 3.60506], [30.85997, 3.5743], [30.85153, 3.48867], [30.97601, 3.693], [31.16666, 3.79853], [31.29476, 3.8015], [31.50478, 3.67814], [31.50776, 3.63652], [31.72075, 3.74354], [31.81459, 3.82083], [31.86821, 3.78664], [31.96205, 3.6499], [31.95907, 3.57408], [32.05187, 3.589], [32.08491, 3.56287], [32.08866, 3.53543], [32.19888, 3.50867], [32.20782, 3.6053], [32.41337, 3.748], [32.72021, 3.77327], [32.89746, 3.81339], [33.02852, 3.89296], [33.18356, 3.77812], [33.51264, 3.75068], [33.9873, 4.23316], [34.47601, 4.72162], [35.34151, 5.02364], [35.30992, 4.90402], [35.47843, 4.91872], [35.42366, 4.76969], [35.51424, 4.61643], [35.9419, 4.61933], [35.82118, 4.77382], [35.81968, 5.10757], [35.8576, 5.33413], [35.50792, 5.42431], [35.29938, 5.34042], [35.31188, 5.50106], [35.13058, 5.62118], [35.12611, 5.68937], [35.00546, 5.89387], [34.96227, 6.26415], [35.01738, 6.46991], [34.87736, 6.60161], [34.77459, 6.5957], [34.65096, 6.72589], [34.53776, 6.74808], [34.53925, 6.82794], [34.47669, 6.91076], [34.35753, 6.91963], [34.19369, 7.04382], [34.19369, 7.12807], [34.01495, 7.25664], [34.03878, 7.27437], [34.02984, 7.36449], [33.87642, 7.5491], [33.71407, 7.65983], [33.44745, 7.7543], [33.32531, 7.71297], [33.24637, 7.77939], [33.04944, 7.78989], [33.0006, 7.90333], [33.08401, 8.05822], [33.18083, 8.13047], [33.1853, 8.29264], [33.19721, 8.40317], [33.3119, 8.45474], [33.54575, 8.47094], [33.66938, 8.44442], [33.71407, 8.3678], [33.87195, 8.41938], [33.89579, 8.4842], [34.01346, 8.50041], [34.14453, 8.60204], [34.14304, 9.04654], [34.10229, 9.50238]]]] } },
    { type: "Feature", properties: { iso1A2: "ST", iso1A3: "STP", iso1N3: "678", wikidata: "Q1039", nameEn: "S\xE3o Tom\xE9 and Principe", groups: ["017", "202", "002", "UN"], callingCodes: ["239"] }, geometry: { type: "MultiPolygon", coordinates: [[[[4.34149, 1.91417], [6.6507, -0.28606], [7.9035, 1.92304], [4.34149, 1.91417]]]] } },
    { type: "Feature", properties: { iso1A2: "SV", iso1A3: "SLV", iso1N3: "222", wikidata: "Q792", nameEn: "El Salvador", groups: ["013", "003", "419", "019", "UN"], callingCodes: ["503"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-89.34776, 14.43013], [-89.39028, 14.44561], [-89.57441, 14.41637], [-89.58814, 14.33165], [-89.50614, 14.26084], [-89.52397, 14.22628], [-89.61844, 14.21937], [-89.70756, 14.1537], [-89.75569, 14.07073], [-89.73251, 14.04133], [-89.76103, 14.02923], [-89.81807, 14.07073], [-89.88937, 14.0396], [-90.10505, 13.85104], [-90.11344, 13.73679], [-90.55276, 12.8866], [-88.11443, 12.63306], [-87.7346, 13.13228], [-87.55124, 13.12523], [-87.69751, 13.25228], [-87.73714, 13.32715], [-87.80177, 13.35689], [-87.84675, 13.41078], [-87.83467, 13.44655], [-87.77354, 13.45767], [-87.73841, 13.44169], [-87.72115, 13.46083], [-87.71657, 13.50577], [-87.78148, 13.52906], [-87.73106, 13.75443], [-87.68821, 13.80829], [-87.7966, 13.91353], [-88.00331, 13.86948], [-88.07641, 13.98447], [-88.23018, 13.99915], [-88.25791, 13.91108], [-88.48982, 13.86458], [-88.49738, 13.97224], [-88.70661, 14.04317], [-88.73182, 14.10919], [-88.815, 14.11652], [-88.85785, 14.17763], [-88.94608, 14.20207], [-89.04187, 14.33644], [-89.34776, 14.43013]]]] } },
    { type: "Feature", properties: { iso1A2: "SX", iso1A3: "SXM", iso1N3: "534", wikidata: "Q26273", nameEn: "Sint Maarten", aliases: ["NL-SX"], country: "NL", groups: ["Q1451600", "029", "003", "419", "019", "UN"], callingCodes: ["1 721"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-63.33064, 17.9615], [-63.1055, 17.86651], [-62.93924, 18.02904], [-63.02323, 18.05757], [-63.04039, 18.05619], [-63.0579, 18.06614], [-63.07759, 18.04943], [-63.09686, 18.04608], [-63.11042, 18.05339], [-63.13502, 18.05445], [-63.33064, 17.9615]]]] } },
    { type: "Feature", properties: { iso1A2: "SY", iso1A3: "SYR", iso1N3: "760", wikidata: "Q858", nameEn: "Syria", groups: ["145", "142", "UN"], callingCodes: ["963"] }, geometry: { type: "MultiPolygon", coordinates: [[[[42.23683, 37.2863], [42.21548, 37.28026], [42.20454, 37.28715], [42.22381, 37.30238], [42.22257, 37.31395], [42.2112, 37.32491], [42.19301, 37.31323], [42.18225, 37.28569], [42.00894, 37.17209], [41.515, 37.08084], [41.21937, 37.07665], [40.90856, 37.13147], [40.69136, 37.0996], [39.81589, 36.75538], [39.21538, 36.66834], [39.03217, 36.70911], [38.74042, 36.70629], [38.55908, 36.84429], [38.38859, 36.90064], [38.21064, 36.91842], [37.81974, 36.76055], [37.68048, 36.75065], [37.49103, 36.66904], [37.47253, 36.63243], [37.21988, 36.6736], [37.16177, 36.66069], [37.10894, 36.6704], [37.08279, 36.63495], [37.02088, 36.66422], [37.01647, 36.69512], [37.04619, 36.71101], [37.04399, 36.73483], [36.99886, 36.74012], [36.99557, 36.75997], [36.66727, 36.82901], [36.61581, 36.74629], [36.62681, 36.71189], [36.57398, 36.65186], [36.58829, 36.58295], [36.54206, 36.49539], [36.6081, 36.33772], [36.65653, 36.33861], [36.68672, 36.23677], [36.6125, 36.22592], [36.50463, 36.2419], [36.4617, 36.20461], [36.39206, 36.22088], [36.37474, 36.01163], [36.33956, 35.98687], [36.30099, 36.00985], [36.28338, 36.00273], [36.29769, 35.96086], [36.27678, 35.94839], [36.25366, 35.96264], [36.19973, 35.95195], [36.17441, 35.92076], [36.1623, 35.80925], [36.14029, 35.81015], [36.13919, 35.83692], [36.11827, 35.85923], [35.99829, 35.88242], [36.01844, 35.92403], [36.00514, 35.94113], [35.98499, 35.94107], [35.931, 35.92109], [35.51152, 36.10954], [35.48515, 34.70851], [35.97386, 34.63322], [35.98718, 34.64977], [36.29165, 34.62991], [36.32399, 34.69334], [36.35135, 34.68516], [36.35384, 34.65447], [36.42941, 34.62505], [36.46003, 34.6378], [36.45299, 34.59438], [36.41429, 34.61175], [36.39846, 34.55672], [36.3369, 34.52629], [36.34745, 34.5002], [36.4442, 34.50165], [36.46179, 34.46541], [36.55853, 34.41609], [36.53039, 34.3798], [36.56556, 34.31881], [36.60778, 34.31009], [36.58667, 34.27667], [36.59195, 34.2316], [36.62537, 34.20251], [36.5128, 34.09916], [36.50576, 34.05982], [36.41078, 34.05253], [36.28589, 33.91981], [36.38263, 33.86579], [36.3967, 33.83365], [36.14517, 33.85118], [36.06778, 33.82927], [35.9341, 33.6596], [36.05723, 33.57904], [35.94465, 33.52774], [35.94816, 33.47886], [35.88668, 33.43183], [35.82577, 33.40479], [35.81324, 33.36354], [35.77477, 33.33609], [35.813, 33.3172], [35.77513, 33.27342], [35.81295, 33.24841], [35.81647, 33.2028], [35.83846, 33.19397], [35.84285, 33.16673], [35.81911, 33.1336], [35.81911, 33.11077], [35.84802, 33.1031], [35.87188, 32.98028], [35.89298, 32.9456], [35.87012, 32.91976], [35.84021, 32.8725], [35.83758, 32.82817], [35.78745, 32.77938], [35.75983, 32.74803], [35.88405, 32.71321], [35.93307, 32.71966], [35.96633, 32.66237], [36.02239, 32.65911], [36.08074, 32.51463], [36.20379, 32.52751], [36.20875, 32.49529], [36.23948, 32.50108], [36.40959, 32.37908], [36.83946, 32.31293], [38.79171, 33.37328], [40.64314, 34.31604], [40.97676, 34.39788], [41.12388, 34.65742], [41.2345, 34.80049], [41.21654, 35.1508], [41.26569, 35.42708], [41.38184, 35.62502], [41.37027, 35.84095], [41.2564, 36.06012], [41.28864, 36.35368], [41.40058, 36.52502], [41.81736, 36.58782], [42.36697, 37.0627], [42.35724, 37.10998], [42.32313, 37.17814], [42.34735, 37.22548], [42.2824, 37.2798], [42.26039, 37.27017], [42.23683, 37.2863]]]] } },
    { type: "Feature", properties: { iso1A2: "SZ", iso1A3: "SWZ", iso1N3: "748", wikidata: "Q1050", nameEn: "Eswatini", aliases: ["Swaziland"], groups: ["018", "202", "002", "UN"], driveSide: "left", callingCodes: ["268"] }, geometry: { type: "MultiPolygon", coordinates: [[[[31.86881, -25.99973], [31.4175, -25.71886], [31.31237, -25.7431], [31.13073, -25.91558], [30.95819, -26.26303], [30.78927, -26.48271], [30.81101, -26.84722], [30.88826, -26.79622], [30.97757, -26.92706], [30.96088, -27.0245], [31.15027, -27.20151], [31.49834, -27.31549], [31.97592, -27.31675], [31.97463, -27.11057], [32.00893, -26.8096], [32.09664, -26.80721], [32.13315, -26.84345], [32.13409, -26.5317], [32.07352, -26.40185], [32.10435, -26.15656], [32.08599, -26.00978], [32.00916, -25.999], [31.974, -25.95387], [31.86881, -25.99973]]]] } },
    { type: "Feature", properties: { iso1A2: "TA", iso1A3: "TAA", wikidata: "Q220982", nameEn: "Tristan da Cunha", aliases: ["SH-TA"], country: "GB", groups: ["SH", "BOTS", "011", "202", "002", "UN"], isoStatus: "excRes", driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["290 8", "44 20"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-13.38232, -34.07258], [-16.67337, -41.9188], [-5.88482, -41.4829], [-13.38232, -34.07258]]]] } },
    { type: "Feature", properties: { iso1A2: "TC", iso1A3: "TCA", iso1N3: "796", wikidata: "Q18221", nameEn: "Turks and Caicos Islands", country: "GB", groups: ["BOTS", "029", "003", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["1 649"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-71.70065, 25.7637], [-72.98446, 20.4801], [-69.80718, 21.35956], [-71.70065, 25.7637]]]] } },
    { type: "Feature", properties: { iso1A2: "TD", iso1A3: "TCD", iso1N3: "148", wikidata: "Q657", nameEn: "Chad", groups: ["017", "202", "002", "UN"], callingCodes: ["235"] }, geometry: { type: "MultiPolygon", coordinates: [[[[23.99539, 19.49944], [15.99566, 23.49639], [14.99751, 23.00539], [15.19692, 21.99339], [15.20213, 21.49365], [15.28332, 21.44557], [15.62515, 20.95395], [15.57248, 20.92138], [15.55382, 20.86507], [15.56004, 20.79488], [15.59841, 20.74039], [15.6721, 20.70069], [15.99632, 20.35364], [15.75098, 19.93002], [15.6032, 18.77402], [15.50373, 16.89649], [14.37425, 15.72591], [13.86301, 15.04043], [13.78991, 14.87519], [13.809, 14.72915], [13.67878, 14.64013], [13.68573, 14.55276], [13.48259, 14.46704], [13.47559, 14.40881], [13.6302, 13.71094], [14.08251, 13.0797], [14.46881, 13.08259], [14.56101, 12.91036], [14.55058, 12.78256], [14.83314, 12.62963], [14.90827, 12.3269], [14.89019, 12.16593], [14.96952, 12.0925], [15.00146, 12.1223], [15.0349, 12.10698], [15.05786, 12.0608], [15.04808, 11.8731], [15.11579, 11.79313], [15.06595, 11.71126], [15.13149, 11.5537], [15.0585, 11.40481], [15.10021, 11.04101], [15.04957, 11.02347], [15.09127, 10.87431], [15.06737, 10.80921], [15.15532, 10.62846], [15.14936, 10.53915], [15.23724, 10.47764], [15.30874, 10.31063], [15.50535, 10.1098], [15.68761, 9.99344], [15.41408, 9.92876], [15.24618, 9.99246], [15.14043, 9.99246], [15.05999, 9.94845], [14.95722, 9.97926], [14.80082, 9.93818], [14.4673, 10.00264], [14.20411, 10.00055], [14.1317, 9.82413], [14.01793, 9.73169], [13.97544, 9.6365], [14.37094, 9.2954], [14.35707, 9.19611], [14.83566, 8.80557], [15.09484, 8.65982], [15.20426, 8.50892], [15.50743, 7.79302], [15.59272, 7.7696], [15.56964, 7.58936], [15.49743, 7.52179], [15.73118, 7.52006], [15.79942, 7.44149], [16.40703, 7.68809], [16.41583, 7.77971], [16.58315, 7.88657], [16.59415, 7.76444], [16.658, 7.75353], [16.6668, 7.67281], [16.8143, 7.53971], [17.67288, 7.98905], [17.93926, 7.95853], [18.02731, 8.01085], [18.6085, 8.05009], [18.64153, 8.08714], [18.62612, 8.14163], [18.67455, 8.22226], [18.79783, 8.25929], [19.11044, 8.68172], [18.86388, 8.87971], [19.06421, 9.00367], [20.36748, 9.11019], [20.82979, 9.44696], [21.26348, 9.97642], [21.34934, 9.95907], [21.52766, 10.2105], [21.63553, 10.217], [21.71479, 10.29932], [21.72139, 10.64136], [22.45889, 11.00246], [22.87758, 10.91915], [22.97249, 11.21955], [22.93124, 11.41645], [22.7997, 11.40424], [22.54907, 11.64372], [22.64092, 12.07485], [22.48369, 12.02766], [22.50548, 12.16769], [22.38873, 12.45514], [22.46345, 12.61925], [22.22684, 12.74682], [22.15679, 12.66634], [21.98711, 12.63292], [21.89371, 12.68001], [21.81432, 12.81362], [21.94819, 13.05637], [22.02914, 13.13976], [22.1599, 13.19281], [22.29689, 13.3731], [22.08674, 13.77863], [22.22995, 13.96754], [22.5553, 14.11704], [22.55997, 14.23024], [22.44944, 14.24986], [22.38562, 14.58907], [22.70474, 14.69149], [22.66115, 14.86308], [22.99584, 15.22989], [22.99584, 15.40105], [22.92579, 15.47007], [22.93201, 15.55107], [23.10792, 15.71297], [23.38812, 15.69649], [23.62785, 15.7804], [23.99997, 15.69575], [23.99539, 19.49944]]]] } },
    { type: "Feature", properties: { iso1A2: "TF", iso1A3: "ATF", iso1N3: "260", wikidata: "Q129003", nameEn: "French Southern Territories", country: "FR", groups: ["EU", "UN"] }, geometry: null },
    { type: "Feature", properties: { iso1A2: "TG", iso1A3: "TGO", iso1N3: "768", wikidata: "Q945", nameEn: "Togo", groups: ["011", "202", "002", "UN"], callingCodes: ["228"] }, geometry: { type: "MultiPolygon", coordinates: [[[[0.50388, 11.01011], [-0.13493, 11.14075], [-0.14462, 11.10811], [-0.05733, 11.08628], [-0.0275, 11.11202], [-514e-5, 11.10763], [342e-5, 11.08317], [0.02395, 11.06229], [0.03355, 10.9807], [-63e-4, 10.96417], [-908e-5, 10.91644], [-0.02685, 10.8783], [-0.0228, 10.81916], [-0.07183, 10.76794], [-0.07327, 10.71845], [-0.09141, 10.7147], [-0.05945, 10.63458], [0.12886, 10.53149], [0.18846, 10.4096], [0.29453, 10.41546], [0.33028, 10.30408], [0.39584, 10.31112], [0.35293, 10.09412], [0.41371, 10.06361], [0.41252, 10.02018], [0.36366, 10.03309], [0.32075, 9.72781], [0.34816, 9.71607], [0.34816, 9.66907], [0.32313, 9.6491], [0.28261, 9.69022], [0.26712, 9.66437], [0.29334, 9.59387], [0.36008, 9.6256], [0.38153, 9.58682], [0.23851, 9.57389], [0.2409, 9.52335], [0.30406, 9.521], [0.31241, 9.50337], [0.2254, 9.47869], [0.25758, 9.42696], [0.33148, 9.44812], [0.36485, 9.49749], [0.49118, 9.48339], [0.56388, 9.40697], [0.45424, 9.04581], [0.52455, 8.87746], [0.37319, 8.75262], [0.47211, 8.59945], [0.64731, 8.48866], [0.73432, 8.29529], [0.63897, 8.25873], [0.5913, 8.19622], [0.61156, 8.18324], [0.6056, 8.13959], [0.58891, 8.12779], [0.62943, 7.85751], [0.58295, 7.62368], [0.51979, 7.58706], [0.52455, 7.45354], [0.57223, 7.39326], [0.62943, 7.41099], [0.65327, 7.31643], [0.59606, 7.01252], [0.52217, 6.9723], [0.52098, 6.94391], [0.56508, 6.92971], [0.52853, 6.82921], [0.57406, 6.80348], [0.58176, 6.76049], [0.6497, 6.73682], [0.63659, 6.63857], [0.74862, 6.56517], [0.71048, 6.53083], [0.89283, 6.33779], [0.99652, 6.33779], [1.03108, 6.24064], [1.05969, 6.22998], [1.09187, 6.17074], [1.19966, 6.17069], [1.19771, 6.11522], [1.27574, 5.93551], [1.67336, 6.02702], [1.62913, 6.24075], [1.79826, 6.28221], [1.76906, 6.43189], [1.58105, 6.68619], [1.61812, 6.74843], [1.55877, 6.99737], [1.64249, 6.99562], [1.61838, 9.0527], [1.5649, 9.16941], [1.41746, 9.3226], [1.33675, 9.54765], [1.36624, 9.5951], [1.35507, 9.99525], [0.77666, 10.37665], [0.80358, 10.71459], [0.8804, 10.803], [0.91245, 10.99597], [0.66104, 10.99964], [0.4958, 10.93269], [0.50521, 10.98035], [0.48852, 10.98561], [0.50388, 11.01011]]]] } },
    { type: "Feature", properties: { iso1A2: "TH", iso1A3: "THA", iso1N3: "764", wikidata: "Q869", nameEn: "Thailand", groups: ["035", "142", "UN"], driveSide: "left", callingCodes: ["66"] }, geometry: { type: "MultiPolygon", coordinates: [[[[100.08404, 20.36626], [99.95721, 20.46301], [99.91616, 20.44986], [99.90499, 20.4487], [99.89692, 20.44789], [99.89301, 20.44311], [99.89168, 20.44548], [99.88451, 20.44596], [99.88211, 20.44488], [99.86383, 20.44371], [99.81096, 20.33687], [99.68255, 20.32077], [99.46008, 20.39673], [99.46077, 20.36198], [99.5569, 20.20676], [99.52943, 20.14811], [99.416, 20.08614], [99.20328, 20.12877], [99.0735, 20.10298], [98.98679, 19.7419], [98.83661, 19.80931], [98.56065, 19.67807], [98.51182, 19.71303], [98.24884, 19.67876], [98.13829, 19.78541], [98.03314, 19.80941], [98.04364, 19.65755], [97.84715, 19.55782], [97.88423, 19.5041], [97.78769, 19.39429], [97.84186, 19.29526], [97.78606, 19.26769], [97.84024, 19.22217], [97.83479, 19.09972], [97.73797, 19.04261], [97.73654, 18.9812], [97.66487, 18.9371], [97.73836, 18.88478], [97.76752, 18.58097], [97.5258, 18.4939], [97.36444, 18.57138], [97.34522, 18.54596], [97.50383, 18.26844], [97.56219, 18.33885], [97.64116, 18.29778], [97.60841, 18.23846], [97.73723, 17.97912], [97.66794, 17.88005], [97.76407, 17.71595], [97.91829, 17.54504], [98.11185, 17.36829], [98.10439, 17.33847], [98.34566, 17.04822], [98.39441, 17.06266], [98.52624, 16.89979], [98.49603, 16.8446], [98.53833, 16.81934], [98.46994, 16.73613], [98.50253, 16.7139], [98.49713, 16.69022], [98.51043, 16.70107], [98.51579, 16.69433], [98.51472, 16.68521], [98.51833, 16.676], [98.51113, 16.64503], [98.5695, 16.62826], [98.57912, 16.55983], [98.63817, 16.47424], [98.68074, 16.27068], [98.84485, 16.42354], [98.92656, 16.36425], [98.8376, 16.11706], [98.69585, 16.13353], [98.57019, 16.04578], [98.59853, 15.87197], [98.541, 15.65406], [98.58598, 15.46821], [98.56027, 15.33471], [98.4866, 15.39154], [98.39351, 15.34177], [98.41906, 15.27103], [98.40522, 15.25268], [98.30446, 15.30667], [98.22, 15.21327], [98.18821, 15.13125], [98.24874, 14.83013], [98.56762, 14.37701], [98.97356, 14.04868], [99.16695, 13.72621], [99.20617, 13.20575], [99.12225, 13.19847], [99.10646, 13.05804], [99.18748, 12.9898], [99.18905, 12.84799], [99.29254, 12.68921], [99.409, 12.60603], [99.47519, 12.1353], [99.56445, 12.14805], [99.53424, 12.02317], [99.64891, 11.82699], [99.64108, 11.78948], [99.5672, 11.62732], [99.47598, 11.62434], [99.39485, 11.3925], [99.31573, 11.32081], [99.32756, 11.28545], [99.06938, 10.94857], [99.02337, 10.97217], [98.99701, 10.92962], [99.0069, 10.85485], [98.86819, 10.78336], [98.78511, 10.68351], [98.77275, 10.62548], [98.81944, 10.52761], [98.7391, 10.31488], [98.55174, 9.92804], [98.52291, 9.92389], [98.47298, 9.95782], [98.33094, 9.91973], [98.12555, 9.44056], [97.63455, 9.60854], [97.19814, 8.18901], [99.31854, 5.99868], [99.50117, 6.44501], [99.91873, 6.50233], [100.0756, 6.4045], [100.12, 6.42105], [100.19511, 6.72559], [100.29651, 6.68439], [100.30828, 6.66462], [100.31618, 6.66781], [100.31884, 6.66423], [100.32671, 6.66526], [100.32607, 6.65933], [100.31929, 6.65413], [100.35413, 6.54932], [100.41152, 6.52299], [100.41791, 6.5189], [100.42351, 6.51762], [100.43027, 6.52389], [100.66986, 6.45086], [100.74361, 6.50811], [100.74822, 6.46231], [100.81045, 6.45086], [100.85884, 6.24929], [101.10313, 6.25617], [101.12618, 6.19431], [101.06165, 6.14161], [101.12388, 6.11411], [101.087, 5.9193], [101.02708, 5.91013], [100.98815, 5.79464], [101.14062, 5.61613], [101.25755, 5.71065], [101.25524, 5.78633], [101.58019, 5.93534], [101.69773, 5.75881], [101.75074, 5.79091], [101.80144, 5.74505], [101.89188, 5.8386], [101.91776, 5.84269], [101.92819, 5.85511], [101.94712, 5.98421], [101.9714, 6.00575], [101.97114, 6.01992], [101.99209, 6.04075], [102.01835, 6.05407], [102.09182, 6.14161], [102.07732, 6.193], [102.08127, 6.22679], [102.09086, 6.23546], [102.46318, 7.22462], [102.47649, 9.66162], [102.52395, 11.25257], [102.91449, 11.65512], [102.90973, 11.75613], [102.83957, 11.8519], [102.78427, 11.98746], [102.77026, 12.06815], [102.70176, 12.1686], [102.73134, 12.37091], [102.78116, 12.40284], [102.7796, 12.43781], [102.57567, 12.65358], [102.51963, 12.66117], [102.4994, 12.71736], [102.53053, 12.77506], [102.49335, 12.92711], [102.48694, 12.97537], [102.52275, 12.99813], [102.46011, 13.08057], [102.43422, 13.09061], [102.36146, 13.26006], [102.36001, 13.31142], [102.34611, 13.35618], [102.35692, 13.38274], [102.35563, 13.47307], [102.361, 13.50551], [102.33828, 13.55613], [102.36859, 13.57488], [102.44601, 13.5637], [102.5358, 13.56933], [102.57573, 13.60461], [102.62483, 13.60883], [102.58635, 13.6286], [102.5481, 13.6589], [102.56848, 13.69366], [102.72727, 13.77806], [102.77864, 13.93374], [102.91251, 14.01531], [102.93275, 14.19044], [103.16469, 14.33075], [103.39353, 14.35639], [103.53518, 14.42575], [103.71109, 14.4348], [103.70175, 14.38052], [103.93836, 14.3398], [104.27616, 14.39861], [104.55014, 14.36091], [104.69335, 14.42726], [104.97667, 14.38806], [105.02804, 14.23722], [105.08408, 14.20402], [105.14012, 14.23873], [105.17748, 14.34432], [105.20894, 14.34967], [105.43783, 14.43865], [105.53864, 14.55731], [105.5121, 14.80802], [105.61162, 15.00037], [105.46661, 15.13132], [105.58043, 15.32724], [105.50662, 15.32054], [105.4692, 15.33709], [105.47635, 15.3796], [105.58191, 15.41031], [105.60446, 15.53301], [105.61756, 15.68792], [105.46573, 15.74742], [105.42285, 15.76971], [105.37959, 15.84074], [105.34115, 15.92737], [105.38508, 15.987], [105.42001, 16.00657], [105.06204, 16.09792], [105.00262, 16.25627], [104.88057, 16.37311], [104.73349, 16.565], [104.76099, 16.69302], [104.7397, 16.81005], [104.76442, 16.84752], [104.7373, 16.91125], [104.73712, 17.01404], [104.80716, 17.19025], [104.80061, 17.39367], [104.69867, 17.53038], [104.45404, 17.66788], [104.35432, 17.82871], [104.2757, 17.86139], [104.21776, 17.99335], [104.10927, 18.10826], [104.06533, 18.21656], [103.97725, 18.33631], [103.93916, 18.33914], [103.85642, 18.28666], [103.82449, 18.33979], [103.699, 18.34125], [103.60957, 18.40528], [103.47773, 18.42841], [103.41044, 18.4486], [103.30977, 18.4341], [103.24779, 18.37807], [103.23818, 18.34875], [103.29757, 18.30475], [103.17093, 18.2618], [103.14994, 18.23172], [103.1493, 18.17799], [103.07343, 18.12351], [103.07823, 18.03833], [103.0566, 18.00144], [103.01998, 17.97095], [102.9912, 17.9949], [102.95812, 18.0054], [102.86323, 17.97531], [102.81988, 17.94233], [102.79044, 17.93612], [102.75954, 17.89561], [102.68538, 17.86653], [102.67543, 17.84529], [102.69946, 17.81686], [102.68194, 17.80151], [102.59485, 17.83537], [102.5896, 17.84889], [102.61432, 17.92273], [102.60971, 17.95411], [102.59234, 17.96127], [102.45523, 17.97106], [102.11359, 18.21532], [101.88485, 18.02474], [101.78087, 18.07559], [101.72294, 17.92867], [101.44667, 17.7392], [101.15108, 17.47586], [100.96541, 17.57926], [101.02185, 17.87637], [101.1793, 18.0544], [101.19118, 18.2125], [101.15108, 18.25624], [101.18227, 18.34367], [101.06047, 18.43247], [101.27585, 18.68875], [101.22832, 18.73377], [101.25803, 18.89545], [101.35606, 19.04716], [101.261, 19.12717], [101.24911, 19.33334], [101.20604, 19.35296], [101.21347, 19.46223], [101.26991, 19.48324], [101.26545, 19.59242], [101.08928, 19.59748], [100.90302, 19.61901], [100.77231, 19.48324], [100.64606, 19.55884], [100.58219, 19.49164], [100.49604, 19.53504], [100.398, 19.75047], [100.5094, 19.87904], [100.58808, 20.15791], [100.55218, 20.17741], [100.51052, 20.14928], [100.47567, 20.19133], [100.4537, 20.19971], [100.44992, 20.23644], [100.41473, 20.25625], [100.37439, 20.35156], [100.33383, 20.4028], [100.25769, 20.3992], [100.22076, 20.31598], [100.16668, 20.2986], [100.1712, 20.24324], [100.11785, 20.24787], [100.09337, 20.26293], [100.09999, 20.31614], [100.08404, 20.36626]]]] } },
    { type: "Feature", properties: { iso1A2: "TJ", iso1A3: "TJK", iso1N3: "762", wikidata: "Q863", nameEn: "Tajikistan", groups: ["143", "142", "UN"], callingCodes: ["992"] }, geometry: { type: "MultiPolygon", coordinates: [[[[70.45251, 41.04438], [70.38028, 41.02014], [70.36655, 40.90296], [69.69434, 40.62615], [69.59441, 40.70181], [69.53021, 40.77621], [69.38327, 40.7918], [69.32834, 40.70233], [69.3455, 40.57988], [69.2643, 40.57506], [69.21063, 40.54469], [69.27066, 40.49274], [69.28525, 40.41894], [69.30774, 40.36102], [69.33794, 40.34819], [69.32833, 40.29794], [69.30808, 40.2821], [69.24817, 40.30357], [69.25229, 40.26362], [69.30104, 40.24502], [69.30448, 40.18774], [69.2074, 40.21488], [69.15659, 40.2162], [69.04544, 40.22904], [68.85832, 40.20885], [68.84357, 40.18604], [68.79276, 40.17555], [68.77902, 40.20492], [68.5332, 40.14826], [68.52771, 40.11676], [68.62796, 40.07789], [69.01523, 40.15771], [69.01935, 40.11466], [68.96579, 40.06949], [68.84906, 40.04952], [68.93695, 39.91167], [68.88889, 39.87163], [68.63071, 39.85265], [68.61972, 39.68905], [68.54166, 39.53929], [68.12053, 39.56317], [67.70992, 39.66156], [67.62889, 39.60234], [67.44899, 39.57799], [67.46547, 39.53564], [67.39681, 39.52505], [67.46822, 39.46146], [67.45998, 39.315], [67.36522, 39.31287], [67.33226, 39.23739], [67.67833, 39.14479], [67.68915, 39.00775], [68.09704, 39.02589], [68.19743, 38.85985], [68.06948, 38.82115], [68.12877, 38.73677], [68.05598, 38.71641], [68.0807, 38.64136], [68.05873, 38.56087], [68.11366, 38.47169], [68.06274, 38.39435], [68.13289, 38.40822], [68.40343, 38.19484], [68.27159, 37.91477], [68.12635, 37.93], [67.81566, 37.43107], [67.8474, 37.31594], [67.78329, 37.1834], [67.7803, 37.08978], [67.87917, 37.0591], [68.02194, 36.91923], [68.18542, 37.02074], [68.27605, 37.00977], [68.29253, 37.10621], [68.41201, 37.10402], [68.41888, 37.13906], [68.61851, 37.19815], [68.6798, 37.27906], [68.81438, 37.23862], [68.80889, 37.32494], [68.91189, 37.26704], [68.88168, 37.33368], [68.96407, 37.32603], [69.03274, 37.25174], [69.25152, 37.09426], [69.39529, 37.16752], [69.45022, 37.23315], [69.36645, 37.40462], [69.44954, 37.4869], [69.51888, 37.5844], [69.80041, 37.5746], [69.84435, 37.60616], [69.93362, 37.61378], [69.95971, 37.5659], [70.15015, 37.52519], [70.28243, 37.66706], [70.27694, 37.81258], [70.1863, 37.84296], [70.17206, 37.93276], [70.4898, 38.12546], [70.54673, 38.24541], [70.60407, 38.28046], [70.61526, 38.34774], [70.64966, 38.34999], [70.69189, 38.37031], [70.6761, 38.39144], [70.67438, 38.40597], [70.69807, 38.41861], [70.72485, 38.4131], [70.75455, 38.4252], [70.77132, 38.45548], [70.78581, 38.45502], [70.78702, 38.45031], [70.79766, 38.44944], [70.80521, 38.44447], [70.81697, 38.44507], [70.82538, 38.45394], [70.84376, 38.44688], [70.88719, 38.46826], [70.92728, 38.43021], [70.98693, 38.48862], [71.03545, 38.44779], [71.0556, 38.40176], [71.09542, 38.42517], [71.10592, 38.42077], [71.10957, 38.40671], [71.1451, 38.40106], [71.21291, 38.32797], [71.33114, 38.30339], [71.33869, 38.27335], [71.37803, 38.25641], [71.36444, 38.15358], [71.29878, 38.04429], [71.28922, 38.01272], [71.27622, 37.99946], [71.27278, 37.96496], [71.24969, 37.93031], [71.2809, 37.91995], [71.296, 37.93403], [71.32871, 37.88564], [71.51565, 37.95349], [71.58843, 37.92425], [71.59255, 37.79956], [71.55752, 37.78677], [71.54324, 37.77104], [71.53053, 37.76534], [71.55234, 37.73209], [71.54186, 37.69691], [71.51972, 37.61945], [71.5065, 37.60912], [71.49693, 37.53527], [71.50616, 37.50733], [71.5256, 37.47971], [71.49612, 37.4279], [71.47685, 37.40281], [71.4862, 37.33405], [71.49821, 37.31975], [71.50674, 37.31502], [71.48536, 37.26017], [71.4824, 37.24921], [71.48339, 37.23937], [71.47386, 37.2269], [71.4555, 37.21418], [71.4494, 37.18137], [71.44127, 37.11856], [71.43097, 37.05855], [71.45578, 37.03094], [71.46923, 36.99925], [71.48481, 36.93218], [71.51502, 36.89128], [71.57195, 36.74943], [71.67083, 36.67346], [71.83229, 36.68084], [72.31676, 36.98115], [72.54095, 37.00007], [72.66381, 37.02014], [72.79693, 37.22222], [73.06884, 37.31729], [73.29633, 37.46495], [73.77197, 37.4417], [73.76647, 37.33913], [73.61129, 37.27469], [73.64974, 37.23643], [73.82552, 37.22659], [73.8564, 37.26158], [74.20308, 37.34208], [74.23339, 37.41116], [74.41055, 37.3948], [74.56161, 37.37734], [74.68383, 37.3948], [74.8294, 37.3435], [74.88887, 37.23275], [75.12328, 37.31839], [75.09719, 37.37297], [75.15899, 37.41443], [75.06011, 37.52779], [74.94338, 37.55501], [74.8912, 37.67576], [75.00935, 37.77486], [74.92416, 37.83428], [74.9063, 38.03033], [74.82665, 38.07359], [74.80331, 38.19889], [74.69894, 38.22155], [74.69619, 38.42947], [74.51217, 38.47034], [74.17022, 38.65504], [73.97933, 38.52945], [73.79806, 38.61106], [73.80656, 38.66449], [73.7033, 38.84782], [73.7445, 38.93867], [73.82964, 38.91517], [73.81728, 39.04007], [73.75823, 39.023], [73.60638, 39.24534], [73.54572, 39.27567], [73.55396, 39.3543], [73.5004, 39.38402], [73.59241, 39.40843], [73.59831, 39.46425], [73.45096, 39.46677], [73.31912, 39.38615], [73.18454, 39.35536], [72.85934, 39.35116], [72.62027, 39.39696], [72.33173, 39.33093], [72.23834, 39.17248], [72.17242, 39.2661], [72.09689, 39.26823], [72.04059, 39.36704], [71.90601, 39.27674], [71.79202, 39.27355], [71.7522, 39.32031], [71.80164, 39.40631], [71.76816, 39.45456], [71.62688, 39.44056], [71.5517, 39.45722], [71.55856, 39.57588], [71.49814, 39.61397], [71.08752, 39.50704], [71.06418, 39.41586], [70.7854, 39.38933], [70.64087, 39.58792], [70.44757, 39.60128], [70.2869, 39.53141], [70.11111, 39.58223], [69.87491, 39.53882], [69.68677, 39.59281], [69.3594, 39.52516], [69.26938, 39.8127], [69.35649, 40.01994], [69.43134, 39.98431], [69.43557, 39.92877], [69.53615, 39.93991], [69.5057, 40.03277], [69.53855, 40.0887], [69.53794, 40.11833], [69.55555, 40.12296], [69.57615, 40.10524], [69.64704, 40.12165], [69.67001, 40.10639], [70.01283, 40.23288], [70.58297, 40.00891], [70.57384, 39.99394], [70.47557, 39.93216], [70.55033, 39.96619], [70.58912, 39.95211], [70.65946, 39.9878], [70.65827, 40.0981], [70.7928, 40.12797], [70.80495, 40.16813], [70.9818, 40.22392], [70.8607, 40.217], [70.62342, 40.17396], [70.56394, 40.26421], [70.57149, 40.3442], [70.37511, 40.38605], [70.32626, 40.45174], [70.49871, 40.52503], [70.80009, 40.72825], [70.45251, 41.04438]]], [[[70.68112, 40.90612], [70.6158, 40.97661], [70.56077, 41.00642], [70.54223, 40.98787], [70.57501, 40.98941], [70.6721, 40.90555], [70.68112, 40.90612]]], [[[70.74189, 39.86319], [70.53651, 39.89155], [70.52631, 39.86989], [70.54998, 39.85137], [70.59667, 39.83542], [70.63105, 39.77923], [70.74189, 39.86319]]]] } },
    { type: "Feature", properties: { iso1A2: "TK", iso1A3: "TKL", iso1N3: "772", wikidata: "Q36823", nameEn: "Tokelau", country: "NZ", groups: ["061", "009", "UN"], driveSide: "left", callingCodes: ["690"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-168.251, -9.44289], [-174.18635, -7.80441], [-174.17993, -10.13616], [-168.251, -9.44289]]]] } },
    { type: "Feature", properties: { iso1A2: "TL", iso1A3: "TLS", iso1N3: "626", wikidata: "Q574", nameEn: "East Timor", aliases: ["Timor-Leste", "TP"], groups: ["035", "142", "UN"], driveSide: "left", callingCodes: ["670"] }, geometry: { type: "MultiPolygon", coordinates: [[[[124.46701, -9.13002], [124.94011, -8.85617], [124.97742, -9.08128], [125.11764, -8.96359], [125.18632, -9.03142], [125.18907, -9.16434], [125.09434, -9.19669], [125.04044, -9.17093], [124.97892, -9.19281], [125.09025, -9.46406], [125.68138, -9.85176], [127.55165, -9.05052], [127.42116, -8.22471], [125.87691, -8.31789], [125.58506, -7.95311], [124.92337, -8.75859], [124.33472, -9.11416], [124.04628, -9.22671], [124.04286, -9.34243], [124.10539, -9.41206], [124.14517, -9.42324], [124.21247, -9.36904], [124.28115, -9.42189], [124.28115, -9.50453], [124.3535, -9.48493], [124.35258, -9.43002], [124.38554, -9.3582], [124.45971, -9.30263], [124.46701, -9.13002]]]] } },
    { type: "Feature", properties: { iso1A2: "TM", iso1A3: "TKM", iso1N3: "795", wikidata: "Q874", nameEn: "Turkmenistan", groups: ["143", "142", "UN"], callingCodes: ["993"] }, geometry: { type: "MultiPolygon", coordinates: [[[[60.5078, 41.21694], [60.06581, 41.4363], [60.18117, 41.60082], [60.06032, 41.76287], [60.08504, 41.80997], [60.33223, 41.75058], [59.95046, 41.97966], [60.0356, 42.01028], [60.04659, 42.08982], [59.96419, 42.1428], [60.00539, 42.212], [59.94633, 42.27655], [59.4341, 42.29738], [59.2955, 42.37064], [59.17317, 42.52248], [58.93422, 42.5407], [58.6266, 42.79314], [58.57991, 42.64988], [58.27504, 42.69632], [58.14321, 42.62159], [58.29427, 42.56497], [58.51674, 42.30348], [58.40688, 42.29535], [58.3492, 42.43335], [57.99214, 42.50021], [57.90975, 42.4374], [57.92897, 42.24047], [57.84932, 42.18555], [57.6296, 42.16519], [57.30275, 42.14076], [57.03633, 41.92043], [56.96218, 41.80383], [57.03359, 41.41777], [57.13796, 41.36625], [57.03423, 41.25435], [56.00314, 41.32584], [55.45471, 41.25609], [54.95182, 41.92424], [54.20635, 42.38477], [52.97575, 42.1308], [52.47884, 41.78034], [52.26048, 41.69249], [51.7708, 40.29239], [53.89734, 37.3464], [54.24565, 37.32047], [54.36211, 37.34912], [54.58664, 37.45809], [54.67247, 37.43532], [54.77822, 37.51597], [54.81804, 37.61285], [54.77684, 37.62264], [54.851, 37.75739], [55.13412, 37.94705], [55.44152, 38.08564], [55.76561, 38.12238], [55.97847, 38.08024], [56.33278, 38.08132], [56.32454, 38.18502], [56.43303, 38.26054], [56.62255, 38.24005], [56.73928, 38.27887], [57.03453, 38.18717], [57.21169, 38.28965], [57.37236, 38.09321], [57.35042, 37.98546], [57.79534, 37.89299], [58.21399, 37.77281], [58.22999, 37.6856], [58.39959, 37.63134], [58.47786, 37.6433], [58.5479, 37.70526], [58.6921, 37.64548], [58.9338, 37.67374], [59.22905, 37.51161], [59.33507, 37.53146], [59.39797, 37.47892], [59.39385, 37.34257], [59.55178, 37.13594], [59.74678, 37.12499], [60.00768, 37.04102], [60.34767, 36.63214], [61.14516, 36.64644], [61.18187, 36.55348], [61.1393, 36.38782], [61.22719, 36.12759], [61.12007, 35.95992], [61.22444, 35.92879], [61.26152, 35.80749], [61.22719, 35.67038], [61.27371, 35.61482], [61.58742, 35.43803], [61.77693, 35.41341], [61.97743, 35.4604], [62.05709, 35.43803], [62.15871, 35.33278], [62.29191, 35.25964], [62.29878, 35.13312], [62.48006, 35.28796], [62.62288, 35.22067], [62.74098, 35.25432], [62.90853, 35.37086], [63.0898, 35.43131], [63.12276, 35.53196], [63.10079, 35.63024], [63.23262, 35.67487], [63.10318, 35.81782], [63.12276, 35.86208], [63.29579, 35.85985], [63.53475, 35.90881], [63.56496, 35.95106], [63.98519, 36.03773], [64.05385, 36.10433], [64.43288, 36.24401], [64.57295, 36.34362], [64.62514, 36.44311], [64.61141, 36.6351], [64.97945, 37.21913], [65.51778, 37.23881], [65.64263, 37.34388], [65.64137, 37.45061], [65.72274, 37.55438], [66.30993, 37.32409], [66.55743, 37.35409], [66.52303, 37.39827], [66.65761, 37.45497], [66.52852, 37.58568], [66.53676, 37.80084], [66.67684, 37.96776], [66.56697, 38.0435], [66.41042, 38.02403], [66.24013, 38.16238], [65.83913, 38.25733], [65.55873, 38.29052], [64.32576, 38.98691], [64.19086, 38.95561], [63.70778, 39.22349], [63.6913, 39.27666], [62.43337, 39.98528], [62.34273, 40.43206], [62.11751, 40.58242], [61.87856, 41.12257], [61.4446, 41.29407], [61.39732, 41.19873], [61.33199, 41.14946], [61.22212, 41.14946], [61.03261, 41.25691], [60.5078, 41.21694]]]] } },
    { type: "Feature", properties: { iso1A2: "TN", iso1A3: "TUN", iso1N3: "788", wikidata: "Q948", nameEn: "Tunisia", groups: ["015", "002", "UN"], callingCodes: ["216"] }, geometry: { type: "MultiPolygon", coordinates: [[[[11.2718, 37.6713], [7.89009, 38.19924], [8.59123, 37.14286], [8.64044, 36.9401], [8.62972, 36.86499], [8.67706, 36.8364], [8.57613, 36.78062], [8.46537, 36.7706], [8.47609, 36.66607], [8.16167, 36.48817], [8.18936, 36.44939], [8.40731, 36.42208], [8.2626, 35.91733], [8.26472, 35.73669], [8.35371, 35.66373], [8.36086, 35.47774], [8.30329, 35.29884], [8.47318, 35.23376], [8.3555, 35.10007], [8.30727, 34.95378], [8.25189, 34.92009], [8.29655, 34.72798], [8.20482, 34.57575], [7.86264, 34.3987], [7.81242, 34.21841], [7.74207, 34.16492], [7.66174, 34.20167], [7.52851, 34.06493], [7.54088, 33.7726], [7.73687, 33.42114], [7.83028, 33.18851], [8.11433, 33.10175], [8.1179, 33.05086], [8.31895, 32.83483], [8.35999, 32.50101], [9.07483, 32.07865], [9.55544, 30.23971], [9.76848, 30.34366], [9.88152, 30.34074], [10.29516, 30.90337], [10.12239, 31.42098], [10.31364, 31.72648], [10.48497, 31.72956], [10.62788, 31.96629], [10.7315, 31.97235], [11.04234, 32.2145], [11.53898, 32.4138], [11.57828, 32.48013], [11.46037, 32.6307], [11.51549, 33.09826], [11.55852, 33.1409], [11.58941, 33.36891], [11.2718, 37.6713]]]] } },
    { type: "Feature", properties: { iso1A2: "TO", iso1A3: "TON", iso1N3: "776", wikidata: "Q678", nameEn: "Tonga", groups: ["061", "009", "UN"], driveSide: "left", callingCodes: ["676"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-176.74538, -22.89767], [-180, -22.90585], [-180, -24.21376], [-173.10761, -24.19665], [-173.13438, -14.94228], [-176.76826, -14.95183], [-176.74538, -22.89767]]]] } },
    { type: "Feature", properties: { iso1A2: "TR", iso1A3: "TUR", iso1N3: "792", wikidata: "Q43", nameEn: "Turkey", groups: ["145", "142", "UN"], callingCodes: ["90"] }, geometry: { type: "MultiPolygon", coordinates: [[[[41.54366, 41.52185], [40.89217, 41.72528], [34.8305, 42.4581], [28.32297, 41.98371], [28.02971, 41.98066], [27.91479, 41.97902], [27.83492, 41.99709], [27.81235, 41.94803], [27.69949, 41.97515], [27.55191, 41.90928], [27.52379, 41.93756], [27.45478, 41.96591], [27.27411, 42.10409], [27.22376, 42.10152], [27.19251, 42.06028], [27.08486, 42.08735], [27.03277, 42.0809], [26.95638, 42.00741], [26.79143, 41.97386], [26.62996, 41.97644], [26.56051, 41.92995], [26.57961, 41.90024], [26.53968, 41.82653], [26.36952, 41.82265], [26.33589, 41.76802], [26.32952, 41.73637], [26.35957, 41.71149], [26.47958, 41.67037], [26.5209, 41.62592], [26.59196, 41.60491], [26.59742, 41.48058], [26.61767, 41.42281], [26.62997, 41.34613], [26.5837, 41.32131], [26.5209, 41.33993], [26.39861, 41.25053], [26.32259, 41.24929], [26.31928, 41.07386], [26.3606, 41.02027], [26.33297, 40.98388], [26.35894, 40.94292], [26.32259, 40.94042], [26.28623, 40.93005], [26.29441, 40.89119], [26.26169, 40.9168], [26.20856, 40.86048], [26.21351, 40.83298], [26.15685, 40.80709], [26.12854, 40.77339], [26.12495, 40.74283], [26.08638, 40.73214], [26.0754, 40.72772], [26.03489, 40.73051], [25.94795, 40.72797], [26.04292, 40.3958], [25.61285, 40.17161], [25.94257, 39.39358], [26.43357, 39.43096], [26.70773, 39.0312], [26.61814, 38.81372], [26.21136, 38.65436], [26.32173, 38.48731], [26.24183, 38.44695], [26.21136, 38.17558], [27.05537, 37.9131], [27.16428, 37.72343], [26.99377, 37.69034], [26.95583, 37.64989], [27.14757, 37.32], [27.20312, 36.94571], [27.45627, 36.9008], [27.24613, 36.71622], [27.46117, 36.53789], [27.89482, 36.69898], [27.95037, 36.46155], [28.23708, 36.56812], [29.30783, 36.01033], [29.48192, 36.18377], [29.61002, 36.1731], [29.61805, 36.14179], [29.69611, 36.10365], [29.73302, 35.92555], [32.82353, 35.70297], [35.51152, 36.10954], [35.931, 35.92109], [35.98499, 35.94107], [36.00514, 35.94113], [36.01844, 35.92403], [35.99829, 35.88242], [36.11827, 35.85923], [36.13919, 35.83692], [36.14029, 35.81015], [36.1623, 35.80925], [36.17441, 35.92076], [36.19973, 35.95195], [36.25366, 35.96264], [36.27678, 35.94839], [36.29769, 35.96086], [36.28338, 36.00273], [36.30099, 36.00985], [36.33956, 35.98687], [36.37474, 36.01163], [36.39206, 36.22088], [36.4617, 36.20461], [36.50463, 36.2419], [36.6125, 36.22592], [36.68672, 36.23677], [36.65653, 36.33861], [36.6081, 36.33772], [36.54206, 36.49539], [36.58829, 36.58295], [36.57398, 36.65186], [36.62681, 36.71189], [36.61581, 36.74629], [36.66727, 36.82901], [36.99557, 36.75997], [36.99886, 36.74012], [37.04399, 36.73483], [37.04619, 36.71101], [37.01647, 36.69512], [37.02088, 36.66422], [37.08279, 36.63495], [37.10894, 36.6704], [37.16177, 36.66069], [37.21988, 36.6736], [37.47253, 36.63243], [37.49103, 36.66904], [37.68048, 36.75065], [37.81974, 36.76055], [38.21064, 36.91842], [38.38859, 36.90064], [38.55908, 36.84429], [38.74042, 36.70629], [39.03217, 36.70911], [39.21538, 36.66834], [39.81589, 36.75538], [40.69136, 37.0996], [40.90856, 37.13147], [41.21937, 37.07665], [41.515, 37.08084], [42.00894, 37.17209], [42.18225, 37.28569], [42.19301, 37.31323], [42.2112, 37.32491], [42.22257, 37.31395], [42.22381, 37.30238], [42.20454, 37.28715], [42.21548, 37.28026], [42.23683, 37.2863], [42.26039, 37.27017], [42.2824, 37.2798], [42.34735, 37.22548], [42.32313, 37.17814], [42.35724, 37.10998], [42.56725, 37.14878], [42.78887, 37.38615], [42.93705, 37.32015], [43.11403, 37.37436], [43.30083, 37.30629], [43.33508, 37.33105], [43.50787, 37.24436], [43.56702, 37.25675], [43.63085, 37.21957], [43.7009, 37.23692], [43.8052, 37.22825], [43.82699, 37.19477], [43.84878, 37.22205], [43.90949, 37.22453], [44.02002, 37.33229], [44.13521, 37.32486], [44.2613, 37.25055], [44.27998, 37.16501], [44.22239, 37.15756], [44.18503, 37.09551], [44.25975, 36.98119], [44.30645, 36.97373], [44.35937, 37.02843], [44.35315, 37.04955], [44.38117, 37.05825], [44.42631, 37.05825], [44.63179, 37.19229], [44.76698, 37.16162], [44.78319, 37.1431], [44.7868, 37.16644], [44.75986, 37.21549], [44.81021, 37.2915], [44.58449, 37.45018], [44.61401, 37.60165], [44.56887, 37.6429], [44.62096, 37.71985], [44.55498, 37.783], [44.45948, 37.77065], [44.3883, 37.85433], [44.22509, 37.88859], [44.42476, 38.25763], [44.50115, 38.33939], [44.44386, 38.38295], [44.38309, 38.36117], [44.3119, 38.37887], [44.3207, 38.49799], [44.32058, 38.62752], [44.28065, 38.6465], [44.26155, 38.71427], [44.30322, 38.81581], [44.18863, 38.93881], [44.20946, 39.13975], [44.1043, 39.19842], [44.03667, 39.39223], [44.22452, 39.4169], [44.29818, 39.378], [44.37921, 39.4131], [44.42832, 39.4131], [44.41849, 39.56659], [44.48111, 39.61579], [44.47298, 39.68788], [44.6137, 39.78393], [44.65422, 39.72163], [44.71806, 39.71124], [44.81043, 39.62677], [44.80977, 39.65768], [44.75779, 39.7148], [44.61845, 39.8281], [44.46635, 39.97733], [44.26973, 40.04866], [44.1778, 40.02845], [44.1057, 40.03555], [43.92307, 40.01787], [43.65688, 40.11199], [43.65221, 40.14889], [43.71136, 40.16673], [43.59928, 40.34019], [43.60862, 40.43267], [43.54791, 40.47413], [43.63664, 40.54159], [43.7425, 40.66805], [43.74872, 40.7365], [43.67712, 40.84846], [43.67712, 40.93084], [43.58683, 40.98961], [43.47319, 41.02251], [43.44984, 41.0988], [43.4717, 41.12611], [43.44973, 41.17666], [43.36118, 41.2028], [43.23096, 41.17536], [43.1945, 41.25242], [43.13373, 41.25503], [43.21707, 41.30331], [43.02956, 41.37891], [42.8785, 41.50516], [42.84899, 41.47265], [42.78995, 41.50126], [42.84471, 41.58912], [42.72794, 41.59714], [42.59202, 41.58183], [42.51772, 41.43606], [42.26387, 41.49346], [41.95134, 41.52466], [41.81939, 41.43621], [41.7124, 41.47417], [41.7148, 41.4932], [41.54366, 41.52185]]]] } },
    { type: "Feature", properties: { iso1A2: "TT", iso1A3: "TTO", iso1N3: "780", wikidata: "Q754", nameEn: "Trinidad and Tobago", groups: ["029", "003", "419", "019", "UN"], driveSide: "left", callingCodes: ["1 868"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-61.62505, 11.18974], [-62.08693, 10.04435], [-60.89962, 9.81445], [-60.07172, 11.77667], [-61.62505, 11.18974]]]] } },
    { type: "Feature", properties: { iso1A2: "TV", iso1A3: "TUV", iso1N3: "798", wikidata: "Q672", nameEn: "Tuvalu", groups: ["061", "009", "UN"], driveSide: "left", callingCodes: ["688"] }, geometry: { type: "MultiPolygon", coordinates: [[[[174, -5], [174, -11.5], [179.99999, -11.5], [179.99999, -5], [174, -5]]]] } },
    { type: "Feature", properties: { iso1A2: "TW", iso1A3: "TWN", iso1N3: "158", wikidata: "Q865", nameEn: "Taiwan", aliases: ["RC"], groups: ["030", "142"], callingCodes: ["886"] }, geometry: { type: "MultiPolygon", coordinates: [[[[121.8109, 21.77688], [122.26612, 25.98197], [120.5128, 26.536], [120.0693, 26.3959], [119.78816, 26.2348], [119.98511, 25.37624], [119.42295, 25.0886], [118.6333, 24.46259], [118.42453, 24.54644], [118.35291, 24.51645], [118.28244, 24.51231], [118.11703, 24.39734], [120.69238, 21.52331], [121.8109, 21.77688]]]] } },
    { type: "Feature", properties: { iso1A2: "TZ", iso1A3: "TZA", iso1N3: "834", wikidata: "Q924", nameEn: "Tanzania", groups: ["014", "202", "002", "UN"], driveSide: "left", callingCodes: ["255"] }, geometry: { type: "MultiPolygon", coordinates: [[[[30.80408, -0.99911], [30.76635, -0.9852], [30.70631, -1.01175], [30.64166, -1.06601], [30.47194, -1.0555], [30.45116, -1.10641], [30.50889, -1.16412], [30.57123, -1.33264], [30.71974, -1.43244], [30.84079, -1.64652], [30.80802, -1.91477], [30.89303, -2.08223], [30.83915, -2.35795], [30.54501, -2.41404], [30.41789, -2.66266], [30.52747, -2.65841], [30.40662, -2.86151], [30.4987, -2.9573], [30.57926, -2.89791], [30.6675, -2.98987], [30.83823, -2.97837], [30.84165, -3.25152], [30.45915, -3.56532], [30.22042, -4.01738], [30.03323, -4.26631], [29.88172, -4.35743], [29.82885, -4.36153], [29.77289, -4.41733], [29.75109, -4.45836], [29.63827, -4.44681], [29.43673, -4.44845], [29.52552, -6.2731], [30.2567, -7.14121], [30.79243, -8.27382], [31.00796, -8.58615], [31.37533, -8.60769], [31.57147, -8.70619], [31.57147, -8.81388], [31.71158, -8.91386], [31.81587, -8.88618], [31.94663, -8.93846], [31.94196, -9.02303], [31.98866, -9.07069], [32.08206, -9.04609], [32.16146, -9.05993], [32.25486, -9.13371], [32.43543, -9.11988], [32.49147, -9.14754], [32.53661, -9.24281], [32.75611, -9.28583], [32.76233, -9.31963], [32.95389, -9.40138], [32.99397, -9.36712], [33.14925, -9.49322], [33.31581, -9.48554], [33.48052, -9.62442], [33.76677, -9.58516], [33.93298, -9.71647], [33.9638, -9.62206], [33.95829, -9.54066], [34.03865, -9.49398], [34.54499, -10.0678], [34.51911, -10.12279], [34.57581, -10.56271], [34.65946, -10.6828], [34.67047, -10.93796], [34.61161, -11.01611], [34.63305, -11.11731], [34.79375, -11.32245], [34.91153, -11.39799], [34.96296, -11.57354], [35.63599, -11.55927], [35.82767, -11.41081], [36.19094, -11.57593], [36.19094, -11.70008], [36.62068, -11.72884], [36.80309, -11.56836], [37.3936, -11.68949], [37.76614, -11.53352], [37.8388, -11.3123], [37.93618, -11.26228], [38.21598, -11.27289], [38.47258, -11.4199], [38.88996, -11.16978], [39.24395, -11.17433], [39.58249, -10.96043], [40.00295, -10.80255], [40.44265, -10.4618], [40.74206, -10.25691], [40.14328, -4.64201], [39.62121, -4.68136], [39.44306, -4.93877], [39.21631, -4.67835], [37.81321, -3.69179], [37.75036, -3.54243], [37.63099, -3.50723], [37.5903, -3.42735], [37.71745, -3.304], [37.67199, -3.06222], [34.0824, -1.02264], [34.03084, -1.05101], [34.02286, -1.00779], [33.93107, -0.99298], [30.80408, -0.99911]]]] } },
    { type: "Feature", properties: { iso1A2: "UA", iso1A3: "UKR", iso1N3: "804", wikidata: "Q212", nameEn: "Ukraine", groups: ["151", "150", "UN"], callingCodes: ["380"] }, geometry: { type: "MultiPolygon", coordinates: [[[[33.57318, 46.10317], [33.61467, 46.13561], [33.63854, 46.14147], [33.61517, 46.22615], [33.646, 46.23028], [33.74047, 46.18555], [33.79715, 46.20482], [33.85234, 46.19863], [33.91549, 46.15938], [34.05272, 46.10838], [34.07311, 46.11769], [34.12929, 46.10494], [34.181, 46.06804], [34.25111, 46.0532], [34.33912, 46.06114], [34.41221, 46.00245], [34.44155, 45.95995], [34.48729, 45.94267], [34.52011, 45.95097], [34.55889, 45.99347], [34.60861, 45.99347], [34.66679, 45.97136], [34.75479, 45.90705], [34.80153, 45.90047], [34.79905, 45.81009], [34.96015, 45.75634], [35.23066, 45.79231], [37.62608, 46.82615], [38.12112, 46.86078], [38.3384, 46.98085], [38.22955, 47.12069], [38.23049, 47.2324], [38.32112, 47.2585], [38.33074, 47.30508], [38.22225, 47.30788], [38.28954, 47.39255], [38.28679, 47.53552], [38.35062, 47.61631], [38.76379, 47.69346], [38.79628, 47.81109], [38.87979, 47.87719], [39.73935, 47.82876], [39.82213, 47.96396], [39.77544, 48.04206], [39.88256, 48.04482], [39.83724, 48.06501], [39.94847, 48.22811], [40.00752, 48.22445], [39.99241, 48.31768], [39.97325, 48.31399], [39.9693, 48.29904], [39.95248, 48.29972], [39.91465, 48.26743], [39.90041, 48.3049], [39.84273, 48.30947], [39.84136, 48.33321], [39.94847, 48.35055], [39.88794, 48.44226], [39.86196, 48.46633], [39.84548, 48.57821], [39.79764, 48.58668], [39.67226, 48.59368], [39.71765, 48.68673], [39.73104, 48.7325], [39.79466, 48.83739], [39.97182, 48.79398], [40.08168, 48.87443], [40.03636, 48.91957], [39.98967, 48.86901], [39.78368, 48.91596], [39.74874, 48.98675], [39.72649, 48.9754], [39.71353, 48.98959], [39.6683, 48.99454], [39.6836, 49.05121], [39.93437, 49.05709], [40.01988, 49.1761], [40.22176, 49.25683], [40.18331, 49.34996], [40.14912, 49.37681], [40.1141, 49.38798], [40.03087, 49.45452], [40.03636, 49.52321], [40.16683, 49.56865], [40.13249, 49.61672], [39.84548, 49.56064], [39.65047, 49.61761], [39.59142, 49.73758], [39.44496, 49.76067], [39.27968, 49.75976], [39.1808, 49.88911], [38.9391, 49.79524], [38.90477, 49.86787], [38.73311, 49.90238], [38.68677, 50.00904], [38.65688, 49.97176], [38.35408, 50.00664], [38.32524, 50.08866], [38.18517, 50.08161], [38.21675, 49.98104], [38.02999, 49.90592], [38.02999, 49.94482], [37.90776, 50.04194], [37.79515, 50.08425], [37.75807, 50.07896], [37.61113, 50.21976], [37.62879, 50.24481], [37.62486, 50.29966], [37.47243, 50.36277], [37.48204, 50.46079], [37.08468, 50.34935], [36.91762, 50.34963], [36.69377, 50.26982], [36.64571, 50.218], [36.56655, 50.2413], [36.58371, 50.28563], [36.47817, 50.31457], [36.30101, 50.29088], [36.20763, 50.3943], [36.06893, 50.45205], [35.8926, 50.43829], [35.80388, 50.41356], [35.73659, 50.35489], [35.61711, 50.35707], [35.58003, 50.45117], [35.47463, 50.49247], [35.39464, 50.64751], [35.48116, 50.66405], [35.47704, 50.77274], [35.41367, 50.80227], [35.39307, 50.92145], [35.32598, 50.94524], [35.40837, 51.04119], [35.31774, 51.08434], [35.20375, 51.04723], [35.12685, 51.16191], [35.14058, 51.23162], [34.97304, 51.2342], [34.82472, 51.17483], [34.6874, 51.18], [34.6613, 51.25053], [34.38802, 51.2746], [34.31661, 51.23936], [34.23009, 51.26429], [34.33446, 51.363], [34.22048, 51.4187], [34.30562, 51.5205], [34.17599, 51.63253], [34.07765, 51.67065], [34.42922, 51.72852], [34.41136, 51.82793], [34.09413, 52.00835], [34.11199, 52.14087], [34.05239, 52.20132], [33.78789, 52.37204], [33.55718, 52.30324], [33.48027, 52.31499], [33.51323, 52.35779], [33.18913, 52.3754], [32.89937, 52.2461], [32.85405, 52.27888], [32.69475, 52.25535], [32.54781, 52.32423], [32.3528, 52.32842], [32.38988, 52.24946], [32.33083, 52.23685], [32.34044, 52.1434], [32.2777, 52.10266], [32.23331, 52.08085], [32.08813, 52.03319], [31.92159, 52.05144], [31.96141, 52.08015], [31.85018, 52.11305], [31.81722, 52.09955], [31.7822, 52.11406], [31.38326, 52.12991], [31.25142, 52.04131], [31.13332, 52.1004], [30.95589, 52.07775], [30.90897, 52.00699], [30.76443, 51.89739], [30.68804, 51.82806], [30.51946, 51.59649], [30.64992, 51.35014], [30.56203, 51.25655], [30.36153, 51.33984], [30.34642, 51.42555], [30.17888, 51.51025], [29.77376, 51.4461], [29.7408, 51.53417], [29.54372, 51.48372], [29.49773, 51.39814], [29.42357, 51.4187], [29.32881, 51.37843], [29.25191, 51.49828], [29.25603, 51.57089], [29.20659, 51.56918], [29.16402, 51.64679], [29.1187, 51.65872], [28.99098, 51.56833], [28.95528, 51.59222], [28.81795, 51.55552], [28.76027, 51.48802], [28.78224, 51.45294], [28.75615, 51.41442], [28.73143, 51.46236], [28.69161, 51.44695], [28.64429, 51.5664], [28.47051, 51.59734], [28.37592, 51.54505], [28.23452, 51.66988], [28.10658, 51.57857], [27.95827, 51.56065], [27.91844, 51.61952], [27.85253, 51.62293], [27.76052, 51.47604], [27.67125, 51.50854], [27.71932, 51.60672], [27.55727, 51.63486], [27.51058, 51.5854], [27.47212, 51.61184], [27.24828, 51.60161], [27.26613, 51.65957], [27.20948, 51.66713], [27.20602, 51.77291], [26.99422, 51.76933], [26.9489, 51.73788], [26.80043, 51.75777], [26.69759, 51.82284], [26.46962, 51.80501], [26.39367, 51.87315], [26.19084, 51.86781], [26.00408, 51.92967], [25.83217, 51.92587], [25.80574, 51.94556], [25.73673, 51.91973], [25.46163, 51.92205], [25.20228, 51.97143], [24.98784, 51.91273], [24.37123, 51.88222], [24.29021, 51.80841], [24.3163, 51.75063], [24.13075, 51.66979], [23.99907, 51.58369], [23.8741, 51.59734], [23.91118, 51.63316], [23.7766, 51.66809], [23.60906, 51.62122], [23.6736, 51.50255], [23.62751, 51.50512], [23.69905, 51.40871], [23.63858, 51.32182], [23.80678, 51.18405], [23.90376, 51.07697], [23.92217, 51.00836], [24.04576, 50.90196], [24.14524, 50.86128], [24.0952, 50.83262], [23.99254, 50.83847], [23.95925, 50.79271], [24.0595, 50.71625], [24.0996, 50.60752], [24.07048, 50.5071], [24.03668, 50.44507], [23.99563, 50.41289], [23.79445, 50.40481], [23.71382, 50.38248], [23.67635, 50.33385], [23.28221, 50.0957], [22.99329, 49.84249], [22.83179, 49.69875], [22.80261, 49.69098], [22.78304, 49.65543], [22.64534, 49.53094], [22.69444, 49.49378], [22.748, 49.32759], [22.72009, 49.20288], [22.86336, 49.10513], [22.89122, 49.00725], [22.56155, 49.08865], [22.54338, 49.01424], [22.48296, 48.99172], [22.42934, 48.92857], [22.34151, 48.68893], [22.21379, 48.6218], [22.16023, 48.56548], [22.14689, 48.4005], [22.2083, 48.42534], [22.38133, 48.23726], [22.49806, 48.25189], [22.59007, 48.15121], [22.58733, 48.10813], [22.66835, 48.09162], [22.73427, 48.12005], [22.81804, 48.11363], [22.87847, 48.04665], [22.84276, 47.98602], [22.89849, 47.95851], [22.94301, 47.96672], [22.92241, 48.02002], [23.0158, 47.99338], [23.08858, 48.00716], [23.1133, 48.08061], [23.15999, 48.12188], [23.27397, 48.08245], [23.33577, 48.0237], [23.4979, 47.96858], [23.52803, 48.01818], [23.5653, 48.00499], [23.63894, 48.00293], [23.66262, 47.98786], [23.75188, 47.99705], [23.80904, 47.98142], [23.8602, 47.9329], [23.89352, 47.94512], [23.94192, 47.94868], [23.96337, 47.96672], [23.98553, 47.96076], [24.00801, 47.968], [24.02999, 47.95087], [24.06466, 47.95317], [24.11281, 47.91487], [24.22566, 47.90231], [24.34926, 47.9244], [24.43578, 47.97131], [24.61994, 47.95062], [24.70632, 47.84428], [24.81893, 47.82031], [24.88896, 47.7234], [25.11144, 47.75203], [25.23778, 47.89403], [25.63878, 47.94924], [25.77723, 47.93919], [26.05901, 47.9897], [26.17711, 47.99246], [26.33504, 48.18418], [26.55202, 48.22445], [26.62823, 48.25804], [26.6839, 48.35828], [26.79239, 48.29071], [26.82809, 48.31629], [26.71274, 48.40388], [26.85556, 48.41095], [26.93384, 48.36558], [27.03821, 48.37653], [27.0231, 48.42485], [27.08078, 48.43214], [27.13434, 48.37288], [27.27855, 48.37534], [27.32159, 48.4434], [27.37604, 48.44398], [27.37741, 48.41026], [27.44333, 48.41209], [27.46942, 48.454], [27.5889, 48.49224], [27.59027, 48.46311], [27.6658, 48.44034], [27.74422, 48.45926], [27.79225, 48.44244], [27.81902, 48.41874], [27.87533, 48.4037], [27.88391, 48.36699], [27.95883, 48.32368], [28.04527, 48.32661], [28.09873, 48.3124], [28.07504, 48.23494], [28.17666, 48.25963], [28.19314, 48.20749], [28.2856, 48.23202], [28.32508, 48.23384], [28.35519, 48.24957], [28.36996, 48.20543], [28.34912, 48.1787], [28.30586, 48.1597], [28.30609, 48.14018], [28.34009, 48.13147], [28.38712, 48.17567], [28.43701, 48.15832], [28.42454, 48.12047], [28.48428, 48.0737], [28.53921, 48.17453], [28.69896, 48.13106], [28.85232, 48.12506], [28.8414, 48.03392], [28.9306, 47.96255], [29.1723, 47.99013], [29.19839, 47.89261], [29.27804, 47.88893], [29.20663, 47.80367], [29.27255, 47.79953], [29.22242, 47.73607], [29.22414, 47.60012], [29.11743, 47.55001], [29.18603, 47.43387], [29.3261, 47.44664], [29.39889, 47.30179], [29.47854, 47.30366], [29.48678, 47.36043], [29.5733, 47.36508], [29.59665, 47.25521], [29.54996, 47.24962], [29.57696, 47.13581], [29.49732, 47.12878], [29.53044, 47.07851], [29.61038, 47.09932], [29.62137, 47.05069], [29.57056, 46.94766], [29.72986, 46.92234], [29.75458, 46.8604], [29.87405, 46.88199], [29.98814, 46.82358], [29.94522, 46.80055], [29.9743, 46.75325], [29.94409, 46.56002], [29.88916, 46.54302], [30.02511, 46.45132], [30.16794, 46.40967], [30.09103, 46.38694], [29.94114, 46.40114], [29.88329, 46.35851], [29.74496, 46.45605], [29.66359, 46.4215], [29.6763, 46.36041], [29.5939, 46.35472], [29.49914, 46.45889], [29.35357, 46.49505], [29.24886, 46.37912], [29.23547, 46.55435], [29.02409, 46.49582], [29.01241, 46.46177], [28.9306, 46.45699], [29.004, 46.31495], [28.98478, 46.31803], [28.94953, 46.25852], [29.06656, 46.19716], [28.94643, 46.09176], [29.00613, 46.04962], [28.98004, 46.00385], [28.74383, 45.96664], [28.78503, 45.83475], [28.69852, 45.81753], [28.70401, 45.78019], [28.52823, 45.73803], [28.47879, 45.66994], [28.51587, 45.6613], [28.54196, 45.58062], [28.49252, 45.56716], [28.51449, 45.49982], [28.43072, 45.48538], [28.41836, 45.51715], [28.30201, 45.54744], [28.21139, 45.46895], [28.28504, 45.43907], [28.34554, 45.32102], [28.5735, 45.24759], [28.71358, 45.22631], [28.78911, 45.24179], [28.81383, 45.3384], [28.94292, 45.28045], [28.96077, 45.33164], [29.24779, 45.43388], [29.42632, 45.44545], [29.59798, 45.38857], [29.68175, 45.26885], [29.65428, 45.25629], [29.69272, 45.19227], [30.04414, 45.08461], [31.62627, 45.50633], [33.54017, 46.0123], [33.59087, 46.06013], [33.57318, 46.10317]]]] } },
    { type: "Feature", properties: { iso1A2: "UG", iso1A3: "UGA", iso1N3: "800", wikidata: "Q1036", nameEn: "Uganda", groups: ["014", "202", "002", "UN"], driveSide: "left", callingCodes: ["256"] }, geometry: { type: "MultiPolygon", coordinates: [[[[33.93107, -0.99298], [33.9264, -0.54188], [33.98449, -0.13079], [33.90936, 0.10581], [34.10067, 0.36372], [34.08727, 0.44713], [34.11408, 0.48884], [34.13493, 0.58118], [34.20196, 0.62289], [34.27345, 0.63182], [34.31516, 0.75693], [34.40041, 0.80266], [34.43349, 0.85254], [34.52369, 1.10692], [34.57427, 1.09868], [34.58029, 1.14712], [34.67562, 1.21265], [34.80223, 1.22754], [34.82606, 1.26626], [34.82606, 1.30944], [34.7918, 1.36752], [34.87819, 1.5596], [34.92734, 1.56109], [34.9899, 1.6668], [34.98692, 1.97348], [34.90947, 2.42447], [34.95267, 2.47209], [34.77244, 2.70272], [34.78137, 2.76223], [34.73967, 2.85447], [34.65774, 2.8753], [34.60114, 2.93034], [34.56242, 3.11478], [34.45815, 3.18319], [34.40006, 3.37949], [34.41794, 3.44342], [34.39112, 3.48802], [34.44922, 3.51627], [34.45815, 3.67385], [34.15429, 3.80464], [34.06046, 4.15235], [33.9873, 4.23316], [33.51264, 3.75068], [33.18356, 3.77812], [33.02852, 3.89296], [32.89746, 3.81339], [32.72021, 3.77327], [32.41337, 3.748], [32.20782, 3.6053], [32.19888, 3.50867], [32.08866, 3.53543], [32.08491, 3.56287], [32.05187, 3.589], [31.95907, 3.57408], [31.96205, 3.6499], [31.86821, 3.78664], [31.81459, 3.82083], [31.72075, 3.74354], [31.50776, 3.63652], [31.50478, 3.67814], [31.29476, 3.8015], [31.16666, 3.79853], [30.97601, 3.693], [30.85153, 3.48867], [30.94081, 3.50847], [30.93486, 3.40737], [30.84251, 3.26908], [30.77101, 3.04897], [30.8574, 2.9508], [30.8857, 2.83923], [30.75612, 2.5863], [30.74271, 2.43601], [30.83059, 2.42559], [30.91102, 2.33332], [30.96911, 2.41071], [31.06593, 2.35862], [31.07934, 2.30207], [31.12104, 2.27676], [31.1985, 2.29462], [31.20148, 2.2217], [31.28042, 2.17853], [31.30127, 2.11006], [30.48503, 1.21675], [30.24671, 1.14974], [30.22139, 0.99635], [30.1484, 0.89805], [29.98307, 0.84295], [29.95477, 0.64486], [29.97413, 0.52124], [29.87284, 0.39166], [29.81922, 0.16824], [29.77454, 0.16675], [29.7224, 0.07291], [29.72687, -0.08051], [29.65091, -0.46777], [29.67474, -0.47969], [29.67176, -0.55714], [29.62708, -0.71055], [29.63006, -0.8997], [29.58388, -0.89821], [29.59061, -1.39016], [29.82657, -1.31187], [29.912, -1.48269], [30.16369, -1.34303], [30.35212, -1.06896], [30.47194, -1.0555], [30.64166, -1.06601], [30.70631, -1.01175], [30.76635, -0.9852], [30.80408, -0.99911], [33.93107, -0.99298]]]] } },
    { type: "Feature", properties: { iso1A2: "UM", iso1A3: "UMI", iso1N3: "581", wikidata: "Q16645", nameEn: "United States Minor Outlying Islands", country: "US" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "UN", wikidata: "Q1065", nameEn: "United Nations", level: "unitedNations", isoStatus: "excRes" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "US", iso1A3: "USA", iso1N3: "840", wikidata: "Q30", nameEn: "United States of America" }, geometry: null },
    { type: "Feature", properties: { iso1A2: "UY", iso1A3: "URY", iso1N3: "858", wikidata: "Q77", nameEn: "Uruguay", groups: ["005", "419", "019", "UN"], callingCodes: ["598"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-57.65132, -30.19229], [-57.61478, -30.25165], [-57.64859, -30.35095], [-57.89115, -30.49572], [-57.8024, -30.77193], [-57.89476, -30.95994], [-57.86729, -31.06352], [-57.9908, -31.34924], [-57.98127, -31.3872], [-58.07569, -31.44916], [-58.0023, -31.53084], [-58.00076, -31.65016], [-58.20252, -31.86966], [-58.10036, -32.25338], [-58.22362, -32.52416], [-58.1224, -32.98842], [-58.40475, -33.11777], [-58.44442, -33.84033], [-58.34425, -34.15035], [-57.83001, -34.69099], [-54.78916, -36.21945], [-52.83257, -34.01481], [-53.37138, -33.74313], [-53.39593, -33.75169], [-53.44031, -33.69344], [-53.52794, -33.68908], [-53.53459, -33.16843], [-53.1111, -32.71147], [-53.37671, -32.57005], [-53.39572, -32.58596], [-53.76024, -32.0751], [-54.17384, -31.86168], [-55.50821, -30.91349], [-55.50841, -30.9027], [-55.51862, -30.89828], [-55.52712, -30.89997], [-55.53276, -30.90218], [-55.53431, -30.89714], [-55.54572, -30.89051], [-55.55218, -30.88193], [-55.55373, -30.8732], [-55.5634, -30.8686], [-55.58866, -30.84117], [-55.87388, -31.05053], [-56.4619, -30.38457], [-56.4795, -30.3899], [-56.49267, -30.39471], [-56.90236, -30.02578], [-57.22502, -30.26121], [-57.65132, -30.19229]]]] } },
    { type: "Feature", properties: { iso1A2: "UZ", iso1A3: "UZB", iso1N3: "860", wikidata: "Q265", nameEn: "Uzbekistan", groups: ["143", "142", "UN"], callingCodes: ["998"] }, geometry: { type: "MultiPolygon", coordinates: [[[[65.85194, 42.85481], [65.53277, 43.31856], [65.18666, 43.48835], [64.96464, 43.74748], [64.53885, 43.56941], [63.34656, 43.64003], [62.01711, 43.51008], [61.01475, 44.41383], [58.59711, 45.58671], [55.97842, 44.99622], [55.97832, 44.99622], [55.97822, 44.99617], [55.97811, 44.99617], [55.97801, 44.99612], [55.97801, 44.99607], [55.97791, 44.99607], [55.9778, 44.99607], [55.9777, 44.99601], [55.9777, 44.99596], [55.9776, 44.99591], [55.97749, 44.99591], [55.97739, 44.99591], [55.97739, 44.99586], [55.97729, 44.99586], [55.97718, 44.99581], [55.97708, 44.99576], [55.97698, 44.9957], [55.97698, 44.99565], [55.97687, 44.9956], [55.97677, 44.9956], [55.97677, 44.99555], [55.97677, 44.9955], [55.97667, 44.99545], [55.97656, 44.99539], [55.97646, 44.99534], [55.97646, 44.99529], [55.97636, 44.99524], [55.97636, 44.99519], [55.97625, 44.99514], [55.97615, 44.99508], [55.97615, 44.99503], [55.97615, 44.99498], [55.97615, 44.99493], [55.97615, 44.99483], [55.97615, 44.99477], [55.97605, 44.99477], [55.97605, 44.99467], [55.97605, 44.99462], [55.97605, 44.99457], [55.97605, 44.99452], [55.97594, 44.99446], [55.97584, 44.99441], [55.97584, 44.99436], [55.97584, 44.99431], [55.97584, 44.99426], [55.97584, 44.99421], [55.97584, 44.99415], [55.97584, 44.99405], [55.97584, 44.994], [55.97584, 44.9939], [55.97584, 44.99384], [55.97584, 44.99374], [55.97584, 44.99369], [55.97584, 44.99359], [55.97584, 44.99353], [55.97584, 44.99348], [55.97584, 44.99343], [55.97584, 44.99338], [55.97584, 44.99328], [55.97584, 44.99322], [56.00314, 41.32584], [57.03423, 41.25435], [57.13796, 41.36625], [57.03359, 41.41777], [56.96218, 41.80383], [57.03633, 41.92043], [57.30275, 42.14076], [57.6296, 42.16519], [57.84932, 42.18555], [57.92897, 42.24047], [57.90975, 42.4374], [57.99214, 42.50021], [58.3492, 42.43335], [58.40688, 42.29535], [58.51674, 42.30348], [58.29427, 42.56497], [58.14321, 42.62159], [58.27504, 42.69632], [58.57991, 42.64988], [58.6266, 42.79314], [58.93422, 42.5407], [59.17317, 42.52248], [59.2955, 42.37064], [59.4341, 42.29738], [59.94633, 42.27655], [60.00539, 42.212], [59.96419, 42.1428], [60.04659, 42.08982], [60.0356, 42.01028], [59.95046, 41.97966], [60.33223, 41.75058], [60.08504, 41.80997], [60.06032, 41.76287], [60.18117, 41.60082], [60.06581, 41.4363], [60.5078, 41.21694], [61.03261, 41.25691], [61.22212, 41.14946], [61.33199, 41.14946], [61.39732, 41.19873], [61.4446, 41.29407], [61.87856, 41.12257], [62.11751, 40.58242], [62.34273, 40.43206], [62.43337, 39.98528], [63.6913, 39.27666], [63.70778, 39.22349], [64.19086, 38.95561], [64.32576, 38.98691], [65.55873, 38.29052], [65.83913, 38.25733], [66.24013, 38.16238], [66.41042, 38.02403], [66.56697, 38.0435], [66.67684, 37.96776], [66.53676, 37.80084], [66.52852, 37.58568], [66.65761, 37.45497], [66.52303, 37.39827], [66.55743, 37.35409], [66.64699, 37.32958], [66.95598, 37.40162], [67.08232, 37.35469], [67.13039, 37.27168], [67.2224, 37.24545], [67.2581, 37.17216], [67.51868, 37.26102], [67.78329, 37.1834], [67.8474, 37.31594], [67.81566, 37.43107], [68.12635, 37.93], [68.27159, 37.91477], [68.40343, 38.19484], [68.13289, 38.40822], [68.06274, 38.39435], [68.11366, 38.47169], [68.05873, 38.56087], [68.0807, 38.64136], [68.05598, 38.71641], [68.12877, 38.73677], [68.06948, 38.82115], [68.19743, 38.85985], [68.09704, 39.02589], [67.68915, 39.00775], [67.67833, 39.14479], [67.33226, 39.23739], [67.36522, 39.31287], [67.45998, 39.315], [67.46822, 39.46146], [67.39681, 39.52505], [67.46547, 39.53564], [67.44899, 39.57799], [67.62889, 39.60234], [67.70992, 39.66156], [68.12053, 39.56317], [68.54166, 39.53929], [68.61972, 39.68905], [68.63071, 39.85265], [68.88889, 39.87163], [68.93695, 39.91167], [68.84906, 40.04952], [68.96579, 40.06949], [69.01935, 40.11466], [69.01523, 40.15771], [68.62796, 40.07789], [68.52771, 40.11676], [68.5332, 40.14826], [68.77902, 40.20492], [68.79276, 40.17555], [68.84357, 40.18604], [68.85832, 40.20885], [69.04544, 40.22904], [69.15659, 40.2162], [69.2074, 40.21488], [69.30448, 40.18774], [69.30104, 40.24502], [69.25229, 40.26362], [69.24817, 40.30357], [69.30808, 40.2821], [69.32833, 40.29794], [69.33794, 40.34819], [69.30774, 40.36102], [69.28525, 40.41894], [69.27066, 40.49274], [69.21063, 40.54469], [69.2643, 40.57506], [69.3455, 40.57988], [69.32834, 40.70233], [69.38327, 40.7918], [69.53021, 40.77621], [69.59441, 40.70181], [69.69434, 40.62615], [70.36655, 40.90296], [70.38028, 41.02014], [70.45251, 41.04438], [70.80009, 40.72825], [70.49871, 40.52503], [70.32626, 40.45174], [70.37511, 40.38605], [70.57149, 40.3442], [70.56394, 40.26421], [70.62342, 40.17396], [70.8607, 40.217], [70.9818, 40.22392], [70.95789, 40.28761], [71.05901, 40.28765], [71.13042, 40.34106], [71.36663, 40.31593], [71.4246, 40.28619], [71.51215, 40.26943], [71.51549, 40.22986], [71.61725, 40.20615], [71.61931, 40.26775], [71.68386, 40.26984], [71.70569, 40.20391], [71.69621, 40.18492], [71.71719, 40.17886], [71.73054, 40.14818], [71.82646, 40.21872], [71.85002, 40.25647], [72.05464, 40.27586], [71.96401, 40.31907], [72.18648, 40.49893], [72.24368, 40.46091], [72.40346, 40.4007], [72.44191, 40.48222], [72.41513, 40.50856], [72.38384, 40.51535], [72.41714, 40.55736], [72.34406, 40.60144], [72.40517, 40.61917], [72.47795, 40.5532], [72.66713, 40.5219], [72.66713, 40.59076], [72.69579, 40.59778], [72.73995, 40.58409], [72.74768, 40.58051], [72.74862, 40.57131], [72.75982, 40.57273], [72.74894, 40.59592], [72.74866, 40.60873], [72.80137, 40.67856], [72.84754, 40.67229], [72.85372, 40.7116], [72.8722, 40.71111], [72.93296, 40.73089], [72.99133, 40.76457], [73.0612, 40.76678], [73.13412, 40.79122], [73.13267, 40.83512], [73.01869, 40.84681], [72.94454, 40.8094], [72.84291, 40.85512], [72.68157, 40.84942], [72.59136, 40.86947], [72.55109, 40.96046], [72.48742, 40.97136], [72.45206, 41.03018], [72.38511, 41.02785], [72.36138, 41.04384], [72.34757, 41.06104], [72.34026, 41.04539], [72.324, 41.03381], [72.18339, 40.99571], [72.17594, 41.02377], [72.21061, 41.05607], [72.1792, 41.10621], [72.14864, 41.13363], [72.17594, 41.15522], [72.16433, 41.16483], [72.10745, 41.15483], [72.07249, 41.11739], [71.85964, 41.19081], [71.91457, 41.2982], [71.83914, 41.3546], [71.76625, 41.4466], [71.71132, 41.43012], [71.73054, 41.54713], [71.65914, 41.49599], [71.6787, 41.42111], [71.57227, 41.29175], [71.46688, 41.31883], [71.43814, 41.19644], [71.46148, 41.13958], [71.40198, 41.09436], [71.34877, 41.16807], [71.27187, 41.11015], [71.25813, 41.18796], [71.11806, 41.15359], [71.02193, 41.19494], [70.9615, 41.16393], [70.86263, 41.23833], [70.77885, 41.24813], [70.78572, 41.36419], [70.67586, 41.47953], [70.48909, 41.40335], [70.17682, 41.5455], [70.69777, 41.92554], [71.28719, 42.18033], [71.13263, 42.28356], [70.94483, 42.26238], [69.49545, 41.545], [69.45751, 41.56863], [69.39485, 41.51518], [69.45081, 41.46246], [69.37468, 41.46555], [69.35554, 41.47211], [69.29778, 41.43673], [69.25059, 41.46693], [69.23332, 41.45847], [69.22671, 41.46298], [69.20439, 41.45391], [69.18528, 41.45175], [69.17701, 41.43769], [69.15137, 41.43078], [69.05006, 41.36183], [69.01308, 41.22804], [68.7217, 41.05025], [68.73945, 40.96989], [68.65662, 40.93861], [68.62221, 41.03019], [68.49983, 40.99669], [68.58444, 40.91447], [68.63, 40.59358], [68.49983, 40.56437], [67.96736, 40.83798], [68.1271, 41.0324], [68.08273, 41.08148], [67.98511, 41.02794], [67.9644, 41.14611], [66.69129, 41.1311], [66.53302, 41.87388], [66.00546, 41.94455], [66.09482, 42.93426], [65.85194, 42.85481]], [[70.68112, 40.90612], [70.6721, 40.90555], [70.57501, 40.98941], [70.54223, 40.98787], [70.56077, 41.00642], [70.6158, 40.97661], [70.68112, 40.90612]]], [[[71.21139, 40.03369], [71.12218, 40.03052], [71.06305, 40.1771], [71.00236, 40.18154], [71.01035, 40.05481], [71.11037, 40.01984], [71.11668, 39.99291], [71.09063, 39.99], [71.10501, 39.95568], [71.04979, 39.89808], [71.10531, 39.91354], [71.16101, 39.88423], [71.23067, 39.93581], [71.1427, 39.95026], [71.21139, 40.03369]]], [[[71.86463, 39.98598], [71.78838, 40.01404], [71.71511, 39.96348], [71.7504, 39.93701], [71.84316, 39.95582], [71.86463, 39.98598]]]] } },
    { type: "Feature", properties: { iso1A2: "VA", iso1A3: "VAT", iso1N3: "336", wikidata: "Q237", nameEn: "Vatican City", aliases: ["Holy See"], groups: ["039", "150"], callingCodes: ["379", "39 06"] }, geometry: { type: "MultiPolygon", coordinates: [[[[12.45181, 41.90056], [12.45446, 41.90028], [12.45435, 41.90143], [12.45626, 41.90172], [12.45691, 41.90125], [12.4577, 41.90115], [12.45834, 41.90174], [12.45826, 41.90281], [12.45755, 41.9033], [12.45762, 41.9058], [12.45561, 41.90629], [12.45543, 41.90738], [12.45091, 41.90625], [12.44984, 41.90545], [12.44815, 41.90326], [12.44582, 41.90194], [12.44834, 41.90095], [12.45181, 41.90056]]]] } },
    { type: "Feature", properties: { iso1A2: "VC", iso1A3: "VCT", iso1N3: "670", wikidata: "Q757", nameEn: "St. Vincent and the Grenadines", aliases: ["WV"], groups: ["029", "003", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", callingCodes: ["1 784"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-62.64026, 12.69984], [-59.94058, 12.34011], [-61.69315, 14.26451], [-62.64026, 12.69984]]]] } },
    { type: "Feature", properties: { iso1A2: "VE", iso1A3: "VEN", iso1N3: "862", wikidata: "Q717", nameEn: "Venezuela", aliases: ["YV"], groups: ["005", "419", "019", "UN"], callingCodes: ["58"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-71.22331, 13.01387], [-70.92579, 11.96275], [-71.3275, 11.85], [-71.9675, 11.65536], [-72.24983, 11.14138], [-72.4767, 11.1117], [-72.88002, 10.44309], [-72.98085, 9.85253], [-73.36905, 9.16636], [-73.02119, 9.27584], [-72.94052, 9.10663], [-72.77415, 9.10165], [-72.65474, 8.61428], [-72.4042, 8.36513], [-72.36987, 8.19976], [-72.35163, 8.01163], [-72.39137, 8.03534], [-72.47213, 7.96106], [-72.48801, 7.94329], [-72.48183, 7.92909], [-72.47042, 7.92306], [-72.45806, 7.91141], [-72.46183, 7.90682], [-72.44454, 7.86031], [-72.46763, 7.79518], [-72.47827, 7.65604], [-72.45321, 7.57232], [-72.47415, 7.48928], [-72.43132, 7.40034], [-72.19437, 7.37034], [-72.04895, 7.03837], [-71.82441, 7.04314], [-71.44118, 7.02116], [-71.42212, 7.03854], [-71.37234, 7.01588], [-71.03941, 6.98163], [-70.7596, 7.09799], [-70.10716, 6.96516], [-69.41843, 6.1072], [-67.60654, 6.2891], [-67.4625, 6.20625], [-67.43513, 5.98835], [-67.58558, 5.84537], [-67.63914, 5.64963], [-67.59141, 5.5369], [-67.83341, 5.31104], [-67.85358, 4.53249], [-67.62671, 3.74303], [-67.50067, 3.75812], [-67.30945, 3.38393], [-67.85862, 2.86727], [-67.85862, 2.79173], [-67.65696, 2.81691], [-67.21967, 2.35778], [-66.85795, 1.22998], [-66.28507, 0.74585], [-65.6727, 1.01353], [-65.50158, 0.92086], [-65.57288, 0.62856], [-65.11657, 1.12046], [-64.38932, 1.5125], [-64.34654, 1.35569], [-64.08274, 1.64792], [-64.06135, 1.94722], [-63.39827, 2.16098], [-63.39114, 2.4317], [-64.0257, 2.48156], [-64.02908, 2.79797], [-64.48379, 3.7879], [-64.84028, 4.24665], [-64.72977, 4.28931], [-64.57648, 4.12576], [-64.14512, 4.12932], [-63.99183, 3.90172], [-63.86082, 3.94796], [-63.70218, 3.91417], [-63.67099, 4.01731], [-63.50611, 3.83592], [-63.42233, 3.89995], [-63.4464, 3.9693], [-63.21111, 3.96219], [-62.98296, 3.59935], [-62.7655, 3.73099], [-62.74411, 4.03331], [-62.57656, 4.04754], [-62.44822, 4.18621], [-62.13094, 4.08309], [-61.54629, 4.2822], [-61.48569, 4.43149], [-61.29675, 4.44216], [-61.31457, 4.54167], [-61.15703, 4.49839], [-60.98303, 4.54167], [-60.86539, 4.70512], [-60.5802, 4.94312], [-60.73204, 5.20931], [-61.4041, 5.95304], [-61.15058, 6.19558], [-61.20762, 6.58174], [-61.13632, 6.70922], [-60.54873, 6.8631], [-60.39419, 6.94847], [-60.28074, 7.1162], [-60.44116, 7.20817], [-60.54098, 7.14804], [-60.63367, 7.25061], [-60.59802, 7.33194], [-60.71923, 7.55817], [-60.64793, 7.56877], [-60.51959, 7.83373], [-60.38056, 7.8302], [-60.02407, 8.04557], [-59.97059, 8.20791], [-59.83156, 8.23261], [-59.80661, 8.28906], [-59.85562, 8.35213], [-59.98508, 8.53046], [-59.54058, 8.6862], [-60.89962, 9.81445], [-62.08693, 10.04435], [-61.62505, 11.18974], [-63.73917, 11.92623], [-63.19938, 16.44103], [-67.89186, 12.4116], [-68.01417, 11.77722], [-68.33524, 11.78151], [-68.99639, 11.79035], [-71.22331, 13.01387]]]] } },
    { type: "Feature", properties: { iso1A2: "VG", iso1A3: "VGB", iso1N3: "092", wikidata: "Q25305", nameEn: "British Virgin Islands", country: "GB", groups: ["BOTS", "029", "003", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["1 284"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-64.47127, 17.55688], [-63.88746, 19.15706], [-65.02435, 18.73231], [-64.86027, 18.39056], [-64.64673, 18.36549], [-64.47127, 17.55688]]]] } },
    { type: "Feature", properties: { iso1A2: "VI", iso1A3: "VIR", iso1N3: "850", wikidata: "Q11703", nameEn: "United States Virgin Islands", aliases: ["US-VI"], country: "US", groups: ["Q1352230", "029", "003", "419", "019", "UN"], driveSide: "left", roadSpeedUnit: "mph", roadHeightUnit: "ft", callingCodes: ["1 340"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-65.02435, 18.73231], [-65.27974, 17.56928], [-64.47127, 17.55688], [-64.64673, 18.36549], [-64.86027, 18.39056], [-65.02435, 18.73231]]]] } },
    { type: "Feature", properties: { iso1A2: "VN", iso1A3: "VNM", iso1N3: "704", wikidata: "Q881", nameEn: "Vietnam", groups: ["035", "142", "UN"], callingCodes: ["84"] }, geometry: { type: "MultiPolygon", coordinates: [[[[108.10003, 21.47338], [108.0569, 21.53604], [108.02926, 21.54997], [107.97932, 21.54503], [107.97383, 21.53961], [107.97074, 21.54072], [107.96774, 21.53601], [107.95232, 21.5388], [107.92652, 21.58906], [107.90006, 21.5905], [107.86114, 21.65128], [107.80355, 21.66141], [107.66967, 21.60787], [107.56537, 21.61945], [107.54047, 21.5934], [107.49065, 21.59774], [107.49532, 21.62958], [107.47197, 21.6672], [107.41593, 21.64839], [107.38636, 21.59774], [107.35989, 21.60063], [107.35834, 21.6672], [107.29296, 21.74674], [107.24625, 21.7077], [107.20734, 21.71493], [107.10771, 21.79879], [107.02615, 21.81981], [107.00964, 21.85948], [107.06101, 21.88982], [107.05634, 21.92303], [106.99252, 21.95191], [106.97228, 21.92592], [106.92714, 21.93459], [106.9178, 21.97357], [106.81038, 21.97934], [106.74345, 22.00965], [106.72551, 21.97923], [106.69276, 21.96013], [106.68274, 21.99811], [106.70142, 22.02409], [106.6983, 22.15102], [106.67495, 22.1885], [106.69986, 22.22309], [106.6516, 22.33977], [106.55976, 22.34841], [106.57221, 22.37], [106.55665, 22.46498], [106.58395, 22.474], [106.61269, 22.60301], [106.65316, 22.5757], [106.71698, 22.58432], [106.72321, 22.63606], [106.76293, 22.73491], [106.82404, 22.7881], [106.83685, 22.8098], [106.81271, 22.8226], [106.78422, 22.81532], [106.71128, 22.85982], [106.71387, 22.88296], [106.6734, 22.89587], [106.6516, 22.86862], [106.60179, 22.92884], [106.55976, 22.92311], [106.51306, 22.94891], [106.49749, 22.91164], [106.34961, 22.86718], [106.27022, 22.87722], [106.19705, 22.98475], [106.00179, 22.99049], [105.99568, 22.94178], [105.90119, 22.94168], [105.8726, 22.92756], [105.72382, 23.06641], [105.57594, 23.075], [105.56037, 23.16806], [105.49966, 23.20669], [105.42805, 23.30824], [105.40782, 23.28107], [105.32376, 23.39684], [105.22569, 23.27249], [105.17276, 23.28679], [105.11672, 23.25247], [105.07002, 23.26248], [104.98712, 23.19176], [104.96532, 23.20463], [104.9486, 23.17235], [104.91435, 23.18666], [104.87992, 23.17141], [104.87382, 23.12854], [104.79478, 23.12934], [104.8334, 23.01484], [104.86765, 22.95178], [104.84942, 22.93631], [104.77114, 22.90017], [104.72755, 22.81984], [104.65283, 22.83419], [104.60457, 22.81841], [104.58122, 22.85571], [104.47225, 22.75813], [104.35593, 22.69353], [104.25683, 22.76534], [104.27084, 22.8457], [104.11384, 22.80363], [104.03734, 22.72945], [104.01088, 22.51823], [103.99247, 22.51958], [103.97384, 22.50634], [103.96783, 22.51173], [103.96352, 22.50584], [103.95191, 22.5134], [103.94513, 22.52553], [103.93286, 22.52703], [103.87904, 22.56683], [103.64506, 22.79979], [103.56255, 22.69499], [103.57812, 22.65764], [103.52675, 22.59155], [103.43646, 22.70648], [103.43179, 22.75816], [103.32282, 22.8127], [103.28079, 22.68063], [103.18895, 22.64471], [103.15782, 22.59873], [103.17961, 22.55705], [103.07843, 22.50097], [103.0722, 22.44775], [102.9321, 22.48659], [102.8636, 22.60735], [102.60675, 22.73376], [102.57095, 22.7036], [102.51802, 22.77969], [102.46665, 22.77108], [102.42618, 22.69212], [102.38415, 22.67919], [102.41061, 22.64184], [102.25339, 22.4607], [102.26428, 22.41321], [102.16621, 22.43336], [102.14099, 22.40092], [102.18712, 22.30403], [102.51734, 22.02676], [102.49092, 21.99002], [102.62301, 21.91447], [102.67145, 21.65894], [102.74189, 21.66713], [102.82115, 21.73667], [102.81894, 21.83888], [102.85637, 21.84501], [102.86077, 21.71213], [102.97965, 21.74076], [102.98846, 21.58936], [102.86297, 21.4255], [102.94223, 21.46034], [102.88939, 21.3107], [102.80794, 21.25736], [102.89825, 21.24707], [102.97745, 21.05821], [103.03469, 21.05821], [103.12055, 20.89994], [103.21497, 20.89832], [103.38032, 20.79501], [103.45737, 20.82382], [103.68633, 20.66324], [103.73478, 20.6669], [103.82282, 20.8732], [103.98024, 20.91531], [104.11121, 20.96779], [104.27412, 20.91433], [104.63957, 20.6653], [104.38199, 20.47155], [104.40621, 20.3849], [104.47886, 20.37459], [104.66158, 20.47774], [104.72102, 20.40554], [104.62195, 20.36633], [104.61315, 20.24452], [104.86852, 20.14121], [104.91695, 20.15567], [104.9874, 20.09573], [104.8465, 19.91783], [104.8355, 19.80395], [104.68359, 19.72729], [104.64837, 19.62365], [104.53169, 19.61743], [104.41281, 19.70035], [104.23229, 19.70242], [104.06498, 19.66926], [104.05617, 19.61743], [104.10832, 19.51575], [104.06058, 19.43484], [103.87125, 19.31854], [104.5361, 18.97747], [104.64617, 18.85668], [105.12829, 18.70453], [105.19654, 18.64196], [105.1327, 18.58355], [105.10408, 18.43533], [105.15942, 18.38691], [105.38366, 18.15315], [105.46292, 18.22008], [105.64784, 17.96687], [105.60381, 17.89356], [105.76612, 17.67147], [105.85744, 17.63221], [106.09019, 17.36399], [106.18991, 17.28227], [106.24444, 17.24714], [106.29287, 17.3018], [106.31929, 17.20509], [106.43597, 17.01362], [106.50862, 16.9673], [106.55045, 17.0031], [106.54824, 16.92729], [106.51963, 16.92097], [106.52183, 16.87884], [106.55265, 16.86831], [106.55485, 16.68704], [106.59013, 16.62259], [106.58267, 16.6012], [106.61477, 16.60713], [106.66052, 16.56892], [106.65832, 16.47816], [106.74418, 16.41904], [106.84104, 16.55415], [106.88727, 16.52671], [106.88067, 16.43594], [106.96638, 16.34938], [106.97385, 16.30204], [107.02597, 16.31132], [107.09091, 16.3092], [107.15035, 16.26271], [107.14595, 16.17816], [107.25822, 16.13587], [107.33968, 16.05549], [107.44975, 16.08511], [107.46296, 16.01106], [107.39471, 15.88829], [107.34188, 15.89464], [107.21419, 15.83747], [107.21859, 15.74638], [107.27143, 15.71459], [107.27583, 15.62769], [107.34408, 15.62345], [107.3815, 15.49832], [107.50699, 15.48771], [107.53341, 15.40496], [107.62367, 15.42193], [107.60605, 15.37524], [107.62587, 15.2266], [107.58844, 15.20111], [107.61926, 15.13949], [107.61486, 15.0566], [107.46516, 15.00982], [107.48277, 14.93751], [107.59285, 14.87795], [107.51579, 14.79282], [107.54361, 14.69092], [107.55371, 14.628], [107.52102, 14.59034], [107.52569, 14.54665], [107.48521, 14.40346], [107.44941, 14.41552], [107.39493, 14.32655], [107.40427, 14.24509], [107.33577, 14.11832], [107.37158, 14.07906], [107.35757, 14.02319], [107.38247, 13.99147], [107.44318, 13.99751], [107.46498, 13.91593], [107.45252, 13.78897], [107.53503, 13.73908], [107.61909, 13.52577], [107.62843, 13.3668], [107.49144, 13.01215], [107.49611, 12.88926], [107.55993, 12.7982], [107.5755, 12.52177], [107.55059, 12.36824], [107.4463, 12.29373], [107.42917, 12.24657], [107.34511, 12.33327], [107.15831, 12.27547], [106.99953, 12.08983], [106.92325, 12.06548], [106.79405, 12.0807], [106.70687, 11.96956], [106.4111, 11.97413], [106.4687, 11.86751], [106.44068, 11.86294], [106.44535, 11.8279], [106.41577, 11.76999], [106.45158, 11.68616], [106.44691, 11.66787], [106.37219, 11.69836], [106.30525, 11.67549], [106.26478, 11.72122], [106.18539, 11.75171], [106.13158, 11.73283], [106.06708, 11.77761], [106.02038, 11.77457], [106.00792, 11.7197], [105.95188, 11.63738], [105.88962, 11.67854], [105.8507, 11.66635], [105.80867, 11.60536], [105.81645, 11.56876], [105.87328, 11.55953], [105.88962, 11.43605], [105.86782, 11.28343], [106.10444, 11.07879], [106.1527, 11.10476], [106.1757, 11.07301], [106.20095, 10.97795], [106.14301, 10.98176], [106.18539, 10.79451], [106.06708, 10.8098], [105.94535, 10.9168], [105.93403, 10.83853], [105.84603, 10.85873], [105.86376, 10.89839], [105.77751, 11.03671], [105.50045, 10.94586], [105.42884, 10.96878], [105.34011, 10.86179], [105.11449, 10.96332], [105.08326, 10.95656], [105.02722, 10.89236], [105.09571, 10.72722], [104.95094, 10.64003], [104.87933, 10.52833], [104.59018, 10.53073], [104.49869, 10.4057], [104.47963, 10.43046], [104.43778, 10.42386], [103.99198, 10.48391], [102.47649, 9.66162], [104.81582, 8.03101], [109.55486, 8.10026], [111.60491, 13.57105], [108.00365, 17.98159], [108.10003, 21.47338]]]] } },
    { type: "Feature", properties: { iso1A2: "VU", iso1A3: "VUT", iso1N3: "548", wikidata: "Q686", nameEn: "Vanuatu", groups: ["054", "009", "UN"], callingCodes: ["678"] }, geometry: { type: "MultiPolygon", coordinates: [[[[156.73836, -14.50464], [174.245, -23.1974], [172.71443, -12.01327], [156.73836, -14.50464]]]] } },
    { type: "Feature", properties: { iso1A2: "WF", iso1A3: "WLF", iso1N3: "876", wikidata: "Q35555", nameEn: "Wallis and Futuna", country: "FR", groups: ["EU", "Q1451600", "061", "009", "UN"], callingCodes: ["681"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-178.66551, -14.32452], [-176.76826, -14.95183], [-175.59809, -12.61507], [-178.66551, -14.32452]]]] } },
    { type: "Feature", properties: { iso1A2: "WS", iso1A3: "WSM", iso1N3: "882", wikidata: "Q683", nameEn: "Samoa", groups: ["061", "009", "UN"], driveSide: "left", callingCodes: ["685"] }, geometry: { type: "MultiPolygon", coordinates: [[[[-173.74402, -14.26669], [-170.99605, -15.1275], [-171.39864, -10.21587], [-173.74402, -14.26669]]]] } },
    { type: "Feature", properties: { iso1A2: "XK", iso1A3: "XKX", wikidata: "Q1246", nameEn: "Kosovo", aliases: ["KV"], groups: ["039", "150"], isoStatus: "usrAssn", callingCodes: ["383"] }, geometry: { type: "MultiPolygon", coordinates: [[[[21.39045, 42.74888], [21.44047, 42.87276], [21.36941, 42.87397], [21.32974, 42.90424], [21.2719, 42.8994], [21.23534, 42.95523], [21.23877, 43.00848], [21.2041, 43.02277], [21.16734, 42.99694], [21.14465, 43.11089], [21.08952, 43.13471], [21.05378, 43.10707], [21.00749, 43.13984], [20.96287, 43.12416], [20.83727, 43.17842], [20.88685, 43.21697], [20.82145, 43.26769], [20.73811, 43.25068], [20.68688, 43.21335], [20.59929, 43.20492], [20.69515, 43.09641], [20.64557, 43.00826], [20.59929, 43.01067], [20.48692, 42.93208], [20.53484, 42.8885], [20.43734, 42.83157], [20.40594, 42.84853], [20.35692, 42.8335], [20.27869, 42.81945], [20.2539, 42.76245], [20.04898, 42.77701], [20.02088, 42.74789], [20.02915, 42.71147], [20.0969, 42.65559], [20.07761, 42.55582], [20.17127, 42.50469], [20.21797, 42.41237], [20.24399, 42.32168], [20.34479, 42.32656], [20.3819, 42.3029], [20.48857, 42.25444], [20.56955, 42.12097], [20.55633, 42.08173], [20.59434, 42.03879], [20.63069, 41.94913], [20.57946, 41.91593], [20.59524, 41.8818], [20.68523, 41.85318], [20.76786, 41.91839], [20.75464, 42.05229], [21.11491, 42.20794], [21.16614, 42.19815], [21.22728, 42.08909], [21.31983, 42.10993], [21.29913, 42.13954], [21.30496, 42.1418], [21.38428, 42.24465], [21.43882, 42.23609], [21.43882, 42.2789], [21.50823, 42.27156], [21.52145, 42.24465], [21.58992, 42.25915], [21.56772, 42.30946], [21.5264, 42.33634], [21.53467, 42.36809], [21.57021, 42.3647], [21.59029, 42.38042], [21.62887, 42.37664], [21.64209, 42.41081], [21.62556, 42.45106], [21.7035, 42.51899], [21.70522, 42.54176], [21.7327, 42.55041], [21.75672, 42.62695], [21.79413, 42.65923], [21.75025, 42.70125], [21.6626, 42.67813], [21.58755, 42.70418], [21.59154, 42.72643], [21.47498, 42.74695], [21.39045, 42.74888]]]] } },
    { type: "Feature", properties: { iso1A2: "YE", iso1A3: "YEM", iso1N3: "887", wikidata: "Q805", nameEn: "Yemen", groups: ["145", "142", "UN"], callingCodes: ["967"] }, geometry: { type: "MultiPolygon", coordinates: [[[[57.49095, 8.14549], [52.81185, 17.28568], [52.74267, 17.29519], [52.78009, 17.35124], [52.00311, 19.00083], [49.04884, 18.59899], [48.19996, 18.20584], [47.58351, 17.50366], [47.48245, 17.10808], [47.00571, 16.94765], [46.76494, 17.29151], [46.31018, 17.20464], [44.50126, 17.47475], [43.70631, 17.35762], [43.43005, 17.56148], [43.29185, 17.53224], [43.22533, 17.38343], [43.32653, 17.31179], [43.20156, 17.25901], [43.17787, 17.14717], [43.23967, 17.03428], [43.18233, 17.02673], [43.1813, 16.98438], [43.19328, 16.94703], [43.1398, 16.90696], [43.18338, 16.84852], [43.22012, 16.83932], [43.22956, 16.80613], [43.24801, 16.80613], [43.26303, 16.79479], [43.25857, 16.75304], [43.21325, 16.74416], [43.22066, 16.65179], [43.15274, 16.67248], [43.11601, 16.53166], [42.97215, 16.51093], [42.94351, 16.49467], [42.94625, 16.39721], [42.76801, 16.40371], [42.15205, 16.40211], [40.99158, 15.81743], [43.29075, 12.79154], [43.32909, 12.59711], [43.90659, 12.3823], [51.12877, 12.56479], [57.49095, 8.14549]]]] } },
    { type: "Feature", properties: { iso1A2: "YT", iso1A3: "MYT", iso1N3: "175", wikidata: "Q17063", nameEn: "Mayotte", country: "FR", groups: ["Q3320166", "EU", "014", "202", "002", "UN"], callingCodes: ["262"] }, geometry: { type: "MultiPolygon", coordinates: [[[[43.28731, -13.97126], [45.54824, -13.22353], [45.4971, -11.75965], [43.28731, -13.97126]]]] } },
    { type: "Feature", properties: { iso1A2: "ZA", iso1A3: "ZAF", iso1N3: "710", wikidata: "Q258", nameEn: "South Africa", groups: ["018", "202", "002", "UN"], driveSide: "left", callingCodes: ["27"] }, geometry: { type: "MultiPolygon", coordinates: [[[[31.30611, -22.422], [31.16344, -22.32599], [31.08932, -22.34884], [30.86696, -22.28907], [30.6294, -22.32599], [30.48686, -22.31368], [30.38614, -22.34533], [30.28351, -22.35587], [30.2265, -22.2961], [30.13147, -22.30841], [29.92242, -22.19408], [29.76848, -22.14128], [29.64609, -22.12917], [29.37703, -22.19581], [29.21955, -22.17771], [29.18974, -22.18599], [29.15268, -22.21399], [29.10881, -22.21202], [29.0151, -22.22907], [28.91889, -22.44299], [28.63287, -22.55887], [28.34874, -22.5694], [28.04562, -22.8394], [28.04752, -22.90243], [27.93729, -22.96194], [27.93539, -23.04941], [27.74154, -23.2137], [27.6066, -23.21894], [27.52393, -23.37952], [27.33768, -23.40917], [26.99749, -23.65486], [26.84165, -24.24885], [26.51667, -24.47219], [26.46346, -24.60358], [26.39409, -24.63468], [25.8515, -24.75727], [25.84295, -24.78661], [25.88571, -24.87802], [25.72702, -25.25503], [25.69661, -25.29284], [25.6643, -25.4491], [25.58543, -25.6343], [25.33076, -25.76616], [25.12266, -25.75931], [25.01718, -25.72507], [24.8946, -25.80723], [24.67319, -25.81749], [24.44703, -25.73021], [24.36531, -25.773], [24.18287, -25.62916], [23.9244, -25.64286], [23.47588, -25.29971], [23.03497, -25.29971], [22.86012, -25.50572], [22.70808, -25.99186], [22.56365, -26.19668], [22.41921, -26.23078], [22.21206, -26.3773], [22.06192, -26.61882], [21.90703, -26.66808], [21.83291, -26.65959], [21.77114, -26.69015], [21.7854, -26.79199], [21.69322, -26.86152], [21.37869, -26.82083], [21.13353, -26.86661], [20.87031, -26.80047], [20.68596, -26.9039], [20.63275, -26.78181], [20.61754, -26.4692], [20.86081, -26.14892], [20.64795, -25.47827], [20.29826, -24.94869], [20.03678, -24.81004], [20.02809, -24.78725], [19.99817, -24.76768], [19.99882, -28.42622], [18.99885, -28.89165], [17.4579, -28.68718], [17.15405, -28.08573], [16.90446, -28.057], [16.59922, -28.53246], [16.46592, -28.57126], [16.45332, -28.63117], [12.51595, -32.27486], [38.88176, -48.03306], [34.51034, -26.91792], [32.35222, -26.86027], [32.29584, -26.852], [32.22302, -26.84136], [32.19409, -26.84032], [32.13315, -26.84345], [32.09664, -26.80721], [32.00893, -26.8096], [31.97463, -27.11057], [31.97592, -27.31675], [31.49834, -27.31549], [31.15027, -27.20151], [30.96088, -27.0245], [30.97757, -26.92706], [30.88826, -26.79622], [30.81101, -26.84722], [30.78927, -26.48271], [30.95819, -26.26303], [31.13073, -25.91558], [31.31237, -25.7431], [31.4175, -25.71886], [31.86881, -25.99973], [31.974, -25.95387], [31.92649, -25.84216], [32.00631, -25.65044], [31.97875, -25.46356], [32.01676, -25.38117], [32.03196, -25.10785], [31.9835, -24.29983], [31.90368, -24.18892], [31.87707, -23.95293], [31.77445, -23.90082], [31.70223, -23.72695], [31.67942, -23.60858], [31.56539, -23.47268], [31.55779, -23.176], [31.30611, -22.422]], [[29.33204, -29.45598], [29.28545, -29.58456], [29.12553, -29.76266], [29.16548, -29.91706], [28.9338, -30.05072], [28.80222, -30.10579], [28.68627, -30.12885], [28.399, -30.1592], [28.2319, -30.28476], [28.12073, -30.68072], [27.74814, -30.60635], [27.69467, -30.55862], [27.67819, -30.53437], [27.6521, -30.51707], [27.62137, -30.50509], [27.56781, -30.44562], [27.56901, -30.42504], [27.45452, -30.32239], [27.38108, -30.33456], [27.36649, -30.27246], [27.37293, -30.19401], [27.40778, -30.14577], [27.32555, -30.14785], [27.29603, -30.05473], [27.22719, -30.00718], [27.09489, -29.72796], [27.01016, -29.65439], [27.33464, -29.48161], [27.4358, -29.33465], [27.47254, -29.31968], [27.45125, -29.29708], [27.48679, -29.29349], [27.54258, -29.25575], [27.5158, -29.2261], [27.55974, -29.18954], [27.75458, -28.89839], [27.8907, -28.91612], [27.88933, -28.88156], [27.9392, -28.84864], [27.98675, -28.8787], [28.02503, -28.85991], [28.1317, -28.7293], [28.2348, -28.69471], [28.30518, -28.69531], [28.40612, -28.6215], [28.65091, -28.57025], [28.68043, -28.58744], [29.40524, -29.21246], [29.44883, -29.3772], [29.33204, -29.45598]]]] } },
    { type: "Feature", properties: { iso1A2: "ZM", iso1A3: "ZMB", iso1N3: "894", wikidata: "Q953", nameEn: "Zambia", groups: ["014", "202", "002", "UN"], driveSide: "left", callingCodes: ["260"] }, geometry: { type: "MultiPolygon", coordinates: [[[[32.95389, -9.40138], [32.76233, -9.31963], [32.75611, -9.28583], [32.53661, -9.24281], [32.49147, -9.14754], [32.43543, -9.11988], [32.25486, -9.13371], [32.16146, -9.05993], [32.08206, -9.04609], [31.98866, -9.07069], [31.94196, -9.02303], [31.94663, -8.93846], [31.81587, -8.88618], [31.71158, -8.91386], [31.57147, -8.81388], [31.57147, -8.70619], [31.37533, -8.60769], [31.00796, -8.58615], [30.79243, -8.27382], [28.88917, -8.4831], [28.9711, -8.66935], [28.38526, -9.23393], [28.36562, -9.30091], [28.52636, -9.35379], [28.51627, -9.44726], [28.56208, -9.49122], [28.68532, -9.78], [28.62795, -9.92942], [28.65032, -10.65133], [28.37241, -11.57848], [28.48357, -11.87532], [29.18592, -12.37921], [29.4992, -12.43843], [29.48404, -12.23604], [29.8139, -12.14898], [29.81551, -13.44683], [29.65078, -13.41844], [29.60531, -13.21685], [29.01918, -13.41353], [28.33199, -12.41375], [27.59932, -12.22123], [27.21025, -11.76157], [27.22541, -11.60323], [27.04351, -11.61312], [26.88687, -12.01868], [26.01777, -11.91488], [25.33058, -11.65767], [25.34069, -11.19707], [24.42612, -11.44975], [24.34528, -11.06816], [24.00027, -10.89356], [24.02603, -11.15368], [23.98804, -12.13149], [24.06672, -12.29058], [23.90937, -12.844], [24.03339, -12.99091], [21.97988, -13.00148], [22.00323, -16.18028], [22.17217, -16.50269], [23.20038, -17.47563], [23.47474, -17.62877], [24.23619, -17.47489], [24.32811, -17.49082], [24.38712, -17.46818], [24.5621, -17.52963], [24.70864, -17.49501], [25.00198, -17.58221], [25.26433, -17.79571], [25.51646, -17.86232], [25.6827, -17.81987], [25.85738, -17.91403], [25.85892, -17.97726], [26.08925, -17.98168], [26.0908, -17.93021], [26.21601, -17.88608], [26.55918, -17.99638], [26.68403, -18.07411], [26.74314, -18.0199], [26.89926, -17.98756], [27.14196, -17.81398], [27.30736, -17.60487], [27.61377, -17.34378], [27.62795, -17.24365], [27.83141, -16.96274], [28.73725, -16.5528], [28.76199, -16.51575], [28.81454, -16.48611], [28.8501, -16.04537], [28.9243, -15.93987], [29.01298, -15.93805], [29.21955, -15.76589], [29.4437, -15.68702], [29.8317, -15.6126], [30.35574, -15.6513], [30.41902, -15.62269], [30.22098, -14.99447], [33.24249, -14.00019], [33.16749, -13.93992], [33.07568, -13.98447], [33.02977, -14.05022], [32.99042, -13.95689], [32.88985, -13.82956], [32.79015, -13.80755], [32.76962, -13.77224], [32.84528, -13.71576], [32.7828, -13.64805], [32.68654, -13.64268], [32.66468, -13.60019], [32.68436, -13.55769], [32.73683, -13.57682], [32.84176, -13.52794], [32.86113, -13.47292], [33.0078, -13.19492], [32.98289, -13.12671], [33.02181, -12.88707], [32.96733, -12.88251], [32.94397, -12.76868], [33.05917, -12.59554], [33.18837, -12.61377], [33.28177, -12.54692], [33.37517, -12.54085], [33.54485, -12.35996], [33.47636, -12.32498], [33.3705, -12.34931], [33.25998, -12.14242], [33.33937, -11.91252], [33.32692, -11.59248], [33.24252, -11.59302], [33.23663, -11.40637], [33.29267, -11.43536], [33.29267, -11.3789], [33.39697, -11.15296], [33.25998, -10.88862], [33.28022, -10.84428], [33.47636, -10.78465], [33.70675, -10.56896], [33.54797, -10.36077], [33.53863, -10.20148], [33.31297, -10.05133], [33.37902, -9.9104], [33.36581, -9.81063], [33.31517, -9.82364], [33.2095, -9.61099], [33.12144, -9.58929], [33.10163, -9.66525], [33.05485, -9.61316], [33.00256, -9.63053], [33.00476, -9.5133], [32.95389, -9.40138]]]] } },
    { type: "Feature", properties: { iso1A2: "ZW", iso1A3: "ZWE", iso1N3: "716", wikidata: "Q954", nameEn: "Zimbabwe", groups: ["014", "202", "002", "UN"], driveSide: "left", callingCodes: ["263"] }, geometry: { type: "MultiPolygon", coordinates: [[[[30.41902, -15.62269], [30.35574, -15.6513], [29.8317, -15.6126], [29.4437, -15.68702], [29.21955, -15.76589], [29.01298, -15.93805], [28.9243, -15.93987], [28.8501, -16.04537], [28.81454, -16.48611], [28.76199, -16.51575], [28.73725, -16.5528], [27.83141, -16.96274], [27.62795, -17.24365], [27.61377, -17.34378], [27.30736, -17.60487], [27.14196, -17.81398], [26.89926, -17.98756], [26.74314, -18.0199], [26.68403, -18.07411], [26.55918, -17.99638], [26.21601, -17.88608], [26.0908, -17.93021], [26.08925, -17.98168], [25.85892, -17.97726], [25.85738, -17.91403], [25.6827, -17.81987], [25.51646, -17.86232], [25.26433, -17.79571], [25.23909, -17.90832], [25.31799, -18.07091], [25.39972, -18.12691], [25.53465, -18.39041], [25.68859, -18.56165], [25.79217, -18.6355], [25.82353, -18.82808], [25.94326, -18.90362], [25.99837, -19.02943], [25.96226, -19.08152], [26.17227, -19.53709], [26.72246, -19.92707], [27.21278, -20.08244], [27.29831, -20.28935], [27.28865, -20.49873], [27.69361, -20.48531], [27.72972, -20.51735], [27.69171, -21.08409], [27.91407, -21.31621], [28.01669, -21.57624], [28.29416, -21.59037], [28.49942, -21.66634], [28.58114, -21.63455], [29.07763, -21.81877], [29.04023, -21.85864], [29.02191, -21.90647], [29.02191, -21.95665], [29.04108, -22.00563], [29.08495, -22.04867], [29.14501, -22.07275], [29.1974, -22.07472], [29.24648, -22.05967], [29.3533, -22.18363], [29.37703, -22.19581], [29.64609, -22.12917], [29.76848, -22.14128], [29.92242, -22.19408], [30.13147, -22.30841], [30.2265, -22.2961], [30.28351, -22.35587], [30.38614, -22.34533], [30.48686, -22.31368], [30.6294, -22.32599], [30.86696, -22.28907], [31.08932, -22.34884], [31.16344, -22.32599], [31.30611, -22.422], [31.38336, -22.36919], [32.41234, -21.31246], [32.48236, -21.32873], [32.37115, -21.133], [32.51644, -20.91929], [32.48122, -20.63319], [32.55167, -20.56312], [32.66174, -20.56106], [32.85987, -20.27841], [32.85987, -20.16686], [32.93032, -20.03868], [33.01178, -20.02007], [33.06461, -19.77787], [32.95013, -19.67219], [32.84666, -19.68462], [32.84446, -19.48343], [32.78282, -19.47513], [32.77966, -19.36098], [32.85107, -19.29238], [32.87088, -19.09279], [32.84006, -19.0262], [32.72118, -19.02204], [32.69917, -18.94293], [32.73439, -18.92628], [32.70137, -18.84712], [32.82465, -18.77419], [32.9017, -18.7992], [32.95013, -18.69079], [32.88629, -18.58023], [32.88629, -18.51344], [33.02278, -18.4696], [33.03159, -18.35054], [32.94133, -17.99705], [33.0492, -17.60298], [32.98536, -17.55891], [32.96554, -17.48964], [33.0426, -17.3468], [33.00517, -17.30477], [32.96554, -17.11971], [32.84113, -16.92259], [32.91051, -16.89446], [32.97655, -16.70689], [32.78943, -16.70267], [32.69917, -16.66893], [32.71017, -16.59932], [32.42838, -16.4727], [32.28529, -16.43892], [32.02772, -16.43892], [31.91324, -16.41569], [31.90223, -16.34388], [31.67988, -16.19595], [31.42451, -16.15154], [31.30563, -16.01193], [31.13171, -15.98019], [30.97761, -16.05848], [30.91597, -15.99924], [30.42568, -15.9962], [30.41902, -15.62269]]]] } }
  ] };
  var borders = borders_default;
  var _whichPolygon = {};
  var _featuresByCode = {};
  var idFilterRegex = /(?=(?!^(and|the|of|el|la|de)$))(\b(and|the|of|el|la|de)\b)|[-_ .,'()&[\]/]/gi;
  function canonicalID(id2) {
    const s2 = id2 || "";
    if (s2.charAt(0) === ".") {
      return s2.toUpperCase();
    } else {
      return s2.replace(idFilterRegex, "").toUpperCase();
    }
  }
  var levels = [
    "subterritory",
    "territory",
    "subcountryGroup",
    "country",
    "sharedLandform",
    "intermediateRegion",
    "subregion",
    "region",
    "subunion",
    "union",
    "unitedNations",
    "world"
  ];
  loadDerivedDataAndCaches(borders);
  function loadDerivedDataAndCaches(borders2) {
    const identifierProps = ["iso1A2", "iso1A3", "m49", "wikidata", "emojiFlag", "ccTLD", "nameEn"];
    let geometryFeatures = [];
    for (const feature22 of borders2.features) {
      const props = feature22.properties;
      props.id = props.iso1A2 || props.m49 || props.wikidata;
      loadM49(feature22);
      loadTLD(feature22);
      loadIsoStatus(feature22);
      loadLevel(feature22);
      loadGroups(feature22);
      loadFlag(feature22);
      cacheFeatureByIDs(feature22);
      if (feature22.geometry) {
        geometryFeatures.push(feature22);
      }
    }
    for (const feature22 of borders2.features) {
      feature22.properties.groups = feature22.properties.groups.map((groupID) => {
        return _featuresByCode[groupID].properties.id;
      });
      loadMembersForGroupsOf(feature22);
    }
    for (const feature22 of borders2.features) {
      loadRoadSpeedUnit(feature22);
      loadRoadHeightUnit(feature22);
      loadDriveSide(feature22);
      loadCallingCodes(feature22);
      loadGroupGroups(feature22);
    }
    for (const feature22 of borders2.features) {
      feature22.properties.groups.sort((groupID1, groupID2) => {
        return levels.indexOf(_featuresByCode[groupID1].properties.level) - levels.indexOf(_featuresByCode[groupID2].properties.level);
      });
      if (feature22.properties.members) {
        feature22.properties.members.sort((id1, id2) => {
          const diff = levels.indexOf(_featuresByCode[id1].properties.level) - levels.indexOf(_featuresByCode[id2].properties.level);
          if (diff === 0) {
            return borders2.features.indexOf(_featuresByCode[id1]) - borders2.features.indexOf(_featuresByCode[id2]);
          }
          return diff;
        });
      }
    }
    const geometryOnlyCollection = {
      type: "FeatureCollection",
      features: geometryFeatures
    };
    _whichPolygon = (0, import_which_polygon.default)(geometryOnlyCollection);
    function loadGroups(feature22) {
      const props = feature22.properties;
      if (!props.groups) {
        props.groups = [];
      }
      if (feature22.geometry && props.country) {
        props.groups.push(props.country);
      }
      if (props.m49 !== "001") {
        props.groups.push("001");
      }
    }
    function loadM49(feature22) {
      const props = feature22.properties;
      if (!props.m49 && props.iso1N3) {
        props.m49 = props.iso1N3;
      }
    }
    function loadTLD(feature22) {
      const props = feature22.properties;
      if (props.level === "unitedNations")
        return;
      if (!props.ccTLD && props.iso1A2) {
        props.ccTLD = "." + props.iso1A2.toLowerCase();
      }
    }
    function loadIsoStatus(feature22) {
      const props = feature22.properties;
      if (!props.isoStatus && props.iso1A2) {
        props.isoStatus = "official";
      }
    }
    function loadLevel(feature22) {
      const props = feature22.properties;
      if (props.level)
        return;
      if (!props.country) {
        props.level = "country";
      } else if (!props.iso1A2 || props.isoStatus === "official") {
        props.level = "territory";
      } else {
        props.level = "subterritory";
      }
    }
    function loadGroupGroups(feature22) {
      const props = feature22.properties;
      if (feature22.geometry || !props.members)
        return;
      const featureLevelIndex = levels.indexOf(props.level);
      let sharedGroups = [];
      props.members.forEach((memberID, index) => {
        const member = _featuresByCode[memberID];
        const memberGroups = member.properties.groups.filter((groupID) => {
          return groupID !== feature22.properties.id && featureLevelIndex < levels.indexOf(_featuresByCode[groupID].properties.level);
        });
        if (index === 0) {
          sharedGroups = memberGroups;
        } else {
          sharedGroups = sharedGroups.filter((groupID) => memberGroups.indexOf(groupID) !== -1);
        }
      });
      props.groups = props.groups.concat(
        sharedGroups.filter((groupID) => props.groups.indexOf(groupID) === -1)
      );
      for (const groupID of sharedGroups) {
        const groupFeature = _featuresByCode[groupID];
        if (groupFeature.properties.members.indexOf(props.id) === -1) {
          groupFeature.properties.members.push(props.id);
        }
      }
    }
    function loadRoadSpeedUnit(feature22) {
      const props = feature22.properties;
      if (feature22.geometry) {
        if (!props.roadSpeedUnit)
          props.roadSpeedUnit = "km/h";
      } else if (props.members) {
        const vals = Array.from(
          new Set(
            props.members.map((id2) => {
              const member = _featuresByCode[id2];
              if (member.geometry)
                return member.properties.roadSpeedUnit || "km/h";
            }).filter(Boolean)
          )
        );
        if (vals.length === 1)
          props.roadSpeedUnit = vals[0];
      }
    }
    function loadRoadHeightUnit(feature22) {
      const props = feature22.properties;
      if (feature22.geometry) {
        if (!props.roadHeightUnit)
          props.roadHeightUnit = "m";
      } else if (props.members) {
        const vals = Array.from(
          new Set(
            props.members.map((id2) => {
              const member = _featuresByCode[id2];
              if (member.geometry)
                return member.properties.roadHeightUnit || "m";
            }).filter(Boolean)
          )
        );
        if (vals.length === 1)
          props.roadHeightUnit = vals[0];
      }
    }
    function loadDriveSide(feature22) {
      const props = feature22.properties;
      if (feature22.geometry) {
        if (!props.driveSide)
          props.driveSide = "right";
      } else if (props.members) {
        const vals = Array.from(
          new Set(
            props.members.map((id2) => {
              const member = _featuresByCode[id2];
              if (member.geometry)
                return member.properties.driveSide || "right";
            }).filter(Boolean)
          )
        );
        if (vals.length === 1)
          props.driveSide = vals[0];
      }
    }
    function loadCallingCodes(feature22) {
      const props = feature22.properties;
      if (!feature22.geometry && props.members) {
        props.callingCodes = Array.from(
          new Set(
            props.members.reduce((array2, id2) => {
              const member = _featuresByCode[id2];
              if (member.geometry && member.properties.callingCodes) {
                return array2.concat(member.properties.callingCodes);
              }
              return array2;
            }, [])
          )
        );
      }
    }
    function loadFlag(feature22) {
      if (!feature22.properties.iso1A2)
        return;
      const flag = feature22.properties.iso1A2.replace(/./g, function(char) {
        return String.fromCodePoint(char.charCodeAt(0) + 127397);
      });
      feature22.properties.emojiFlag = flag;
    }
    function loadMembersForGroupsOf(feature22) {
      for (const groupID of feature22.properties.groups) {
        const groupFeature = _featuresByCode[groupID];
        if (!groupFeature.properties.members) {
          groupFeature.properties.members = [];
        }
        groupFeature.properties.members.push(feature22.properties.id);
      }
    }
    function cacheFeatureByIDs(feature22) {
      let ids = [];
      for (const prop of identifierProps) {
        const id2 = feature22.properties[prop];
        if (id2) {
          ids.push(id2);
        }
      }
      for (const alias of feature22.properties.aliases || []) {
        ids.push(alias);
      }
      for (const id2 of ids) {
        const cid = canonicalID(id2);
        _featuresByCode[cid] = feature22;
      }
    }
  }
  function locArray(loc) {
    if (Array.isArray(loc)) {
      return loc;
    } else if (loc.coordinates) {
      return loc.coordinates;
    }
    return loc.geometry.coordinates;
  }
  function smallestFeature(loc) {
    const query = locArray(loc);
    const featureProperties = _whichPolygon(query);
    if (!featureProperties)
      return null;
    return _featuresByCode[featureProperties.id];
  }
  function countryFeature(loc) {
    const feature22 = smallestFeature(loc);
    if (!feature22)
      return null;
    const countryCode = feature22.properties.country || feature22.properties.iso1A2;
    return _featuresByCode[countryCode] || null;
  }
  var defaultOpts = {
    level: void 0,
    maxLevel: void 0,
    withProp: void 0
  };
  function featureForLoc(loc, opts) {
    const targetLevel = opts.level || "country";
    const maxLevel = opts.maxLevel || "world";
    const withProp = opts.withProp;
    const targetLevelIndex = levels.indexOf(targetLevel);
    if (targetLevelIndex === -1)
      return null;
    const maxLevelIndex = levels.indexOf(maxLevel);
    if (maxLevelIndex === -1)
      return null;
    if (maxLevelIndex < targetLevelIndex)
      return null;
    if (targetLevel === "country") {
      const fastFeature = countryFeature(loc);
      if (fastFeature) {
        if (!withProp || fastFeature.properties[withProp]) {
          return fastFeature;
        }
      }
    }
    const features = featuresContaining(loc);
    const match = features.find((feature22) => {
      let levelIndex = levels.indexOf(feature22.properties.level);
      if (feature22.properties.level === targetLevel || // if no feature exists at the target level, return the first feature at the next level up
      levelIndex > targetLevelIndex && levelIndex <= maxLevelIndex) {
        if (!withProp || feature22.properties[withProp]) {
          return feature22;
        }
      }
      return false;
    });
    return match || null;
  }
  function featureForID(id2) {
    let stringID;
    if (typeof id2 === "number") {
      stringID = id2.toString();
      if (stringID.length === 1) {
        stringID = "00" + stringID;
      } else if (stringID.length === 2) {
        stringID = "0" + stringID;
      }
    } else {
      stringID = canonicalID(id2);
    }
    return _featuresByCode[stringID] || null;
  }
  function smallestFeaturesForBbox(bbox2) {
    return _whichPolygon.bbox(bbox2).map((props) => _featuresByCode[props.id]);
  }
  function smallestOrMatchingFeature(query) {
    if (typeof query === "object") {
      return smallestFeature(query);
    }
    return featureForID(query);
  }
  function feature(query, opts = defaultOpts) {
    if (typeof query === "object") {
      return featureForLoc(query, opts);
    }
    return featureForID(query);
  }
  function iso1A2Code(query, opts = defaultOpts) {
    opts.withProp = "iso1A2";
    const match = feature(query, opts);
    if (!match)
      return null;
    return match.properties.iso1A2 || null;
  }
  function propertiesForQuery(query, property) {
    const features = featuresContaining(query, false);
    return features.map((feature22) => feature22.properties[property]).filter(Boolean);
  }
  function iso1A2Codes(query) {
    return propertiesForQuery(query, "iso1A2");
  }
  function featuresContaining(query, strict) {
    let matchingFeatures;
    if (Array.isArray(query) && query.length === 4) {
      matchingFeatures = smallestFeaturesForBbox(query);
    } else {
      const smallestOrMatching = smallestOrMatchingFeature(query);
      matchingFeatures = smallestOrMatching ? [smallestOrMatching] : [];
    }
    if (!matchingFeatures.length)
      return [];
    let returnFeatures;
    if (!strict || typeof query === "object") {
      returnFeatures = matchingFeatures.slice();
    } else {
      returnFeatures = [];
    }
    for (const feature22 of matchingFeatures) {
      const properties = feature22.properties;
      for (const groupID of properties.groups) {
        const groupFeature = _featuresByCode[groupID];
        if (returnFeatures.indexOf(groupFeature) === -1) {
          returnFeatures.push(groupFeature);
        }
      }
    }
    return returnFeatures;
  }
  function featuresIn(id2, strict) {
    const feature22 = featureForID(id2);
    if (!feature22)
      return [];
    let features = [];
    if (!strict) {
      features.push(feature22);
    }
    const properties = feature22.properties;
    for (const memberID of properties.members || []) {
      features.push(_featuresByCode[memberID]);
    }
    return features;
  }
  function aggregateFeature(id2) {
    var _a2;
    const features = featuresIn(id2, false);
    if (features.length === 0)
      return null;
    let aggregateCoordinates = [];
    for (const feature22 of features) {
      if (((_a2 = feature22.geometry) == null ? void 0 : _a2.type) === "MultiPolygon" && feature22.geometry.coordinates) {
        aggregateCoordinates = aggregateCoordinates.concat(feature22.geometry.coordinates);
      }
    }
    return {
      type: "Feature",
      properties: features[0].properties,
      geometry: {
        type: "MultiPolygon",
        coordinates: aggregateCoordinates
      }
    };
  }
  function roadSpeedUnit(query) {
    const feature22 = smallestOrMatchingFeature(query);
    return feature22 && feature22.properties.roadSpeedUnit || null;
  }
  function roadHeightUnit(query) {
    const feature22 = smallestOrMatchingFeature(query);
    return feature22 && feature22.properties.roadHeightUnit || null;
  }

  // node_modules/polyclip-ts/dist/constant.js
  var constant_default5 = (x2) => {
    return () => {
      return x2;
    };
  };

  // node_modules/polyclip-ts/dist/compare.js
  var compare_default = (eps) => {
    const almostEqual = eps ? (a2, b2) => b2.minus(a2).abs().isLessThanOrEqualTo(eps) : constant_default5(false);
    return (a2, b2) => {
      if (almostEqual(a2, b2))
        return 0;
      return a2.comparedTo(b2);
    };
  };

  // node_modules/polyclip-ts/dist/orient.js
  function orient_default(eps) {
    const almostCollinear = eps ? (area2, ax, ay, cx, cy) => area2.exponentiatedBy(2).isLessThanOrEqualTo(cx.minus(ax).exponentiatedBy(2).plus(cy.minus(ay).exponentiatedBy(2)).times(eps)) : constant_default5(false);
    return (a2, b2, c2) => {
      const ax = a2.x, ay = a2.y, cx = c2.x, cy = c2.y;
      const area2 = ay.minus(cy).times(b2.x.minus(cx)).minus(ax.minus(cx).times(b2.y.minus(cy)));
      if (almostCollinear(area2, ax, ay, cx, cy))
        return 0;
      return area2.comparedTo(0);
    };
  }

  // node_modules/bignumber.js/bignumber.mjs
  var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
  var mathceil = Math.ceil;
  var mathfloor = Math.floor;
  var bignumberError = "[BigNumber Error] ";
  var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
  var BASE = 1e14;
  var LOG_BASE = 14;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
  var SQRT_BASE = 1e7;
  var MAX = 1e9;
  function clone(configObject) {
    var div, convertBase, parseNumeric2, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
      prefix: "",
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ",",
      decimalSeparator: ".",
      fractionGroupSize: 0,
      fractionGroupSeparator: "\xA0",
      // non-breaking space
      suffix: ""
    }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
    function BigNumber2(v2, b2) {
      var alphabet, c2, caseChanged, e3, i3, isNum, len, str, x2 = this;
      if (!(x2 instanceof BigNumber2))
        return new BigNumber2(v2, b2);
      if (b2 == null) {
        if (v2 && v2._isBigNumber === true) {
          x2.s = v2.s;
          if (!v2.c || v2.e > MAX_EXP) {
            x2.c = x2.e = null;
          } else if (v2.e < MIN_EXP) {
            x2.c = [x2.e = 0];
          } else {
            x2.e = v2.e;
            x2.c = v2.c.slice();
          }
          return;
        }
        if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
          x2.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
          if (v2 === ~~v2) {
            for (e3 = 0, i3 = v2; i3 >= 10; i3 /= 10, e3++)
              ;
            if (e3 > MAX_EXP) {
              x2.c = x2.e = null;
            } else {
              x2.e = e3;
              x2.c = [v2];
            }
            return;
          }
          str = String(v2);
        } else {
          if (!isNumeric.test(str = String(v2)))
            return parseNumeric2(x2, str, isNum);
          x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }
        if ((e3 = str.indexOf(".")) > -1)
          str = str.replace(".", "");
        if ((i3 = str.search(/e/i)) > 0) {
          if (e3 < 0)
            e3 = i3;
          e3 += +str.slice(i3 + 1);
          str = str.substring(0, i3);
        } else if (e3 < 0) {
          e3 = str.length;
        }
      } else {
        intCheck(b2, 2, ALPHABET.length, "Base");
        if (b2 == 10 && alphabetHasNormalDecimalDigits) {
          x2 = new BigNumber2(v2);
          return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
        }
        str = String(v2);
        if (isNum = typeof v2 == "number") {
          if (v2 * 0 != 0)
            return parseNumeric2(x2, str, isNum, b2);
          x2.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
          if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
            throw Error(tooManyDigits + v2);
          }
        } else {
          x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }
        alphabet = ALPHABET.slice(0, b2);
        e3 = i3 = 0;
        for (len = str.length; i3 < len; i3++) {
          if (alphabet.indexOf(c2 = str.charAt(i3)) < 0) {
            if (c2 == ".") {
              if (i3 > e3) {
                e3 = len;
                continue;
              }
            } else if (!caseChanged) {
              if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i3 = -1;
                e3 = 0;
                continue;
              }
            }
            return parseNumeric2(x2, String(v2), isNum, b2);
          }
        }
        isNum = false;
        str = convertBase(str, b2, 10, x2.s);
        if ((e3 = str.indexOf(".")) > -1)
          str = str.replace(".", "");
        else
          e3 = str.length;
      }
      for (i3 = 0; str.charCodeAt(i3) === 48; i3++)
        ;
      for (len = str.length; str.charCodeAt(--len) === 48; )
        ;
      if (str = str.slice(i3, ++len)) {
        len -= i3;
        if (isNum && BigNumber2.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
          throw Error(tooManyDigits + x2.s * v2);
        }
        if ((e3 = e3 - i3 - 1) > MAX_EXP) {
          x2.c = x2.e = null;
        } else if (e3 < MIN_EXP) {
          x2.c = [x2.e = 0];
        } else {
          x2.e = e3;
          x2.c = [];
          i3 = (e3 + 1) % LOG_BASE;
          if (e3 < 0)
            i3 += LOG_BASE;
          if (i3 < len) {
            if (i3)
              x2.c.push(+str.slice(0, i3));
            for (len -= LOG_BASE; i3 < len; ) {
              x2.c.push(+str.slice(i3, i3 += LOG_BASE));
            }
            i3 = LOG_BASE - (str = str.slice(i3)).length;
          } else {
            i3 -= len;
          }
          for (; i3--; str += "0")
            ;
          x2.c.push(+str);
        }
      } else {
        x2.c = [x2.e = 0];
      }
    }
    BigNumber2.clone = clone;
    BigNumber2.ROUND_UP = 0;
    BigNumber2.ROUND_DOWN = 1;
    BigNumber2.ROUND_CEIL = 2;
    BigNumber2.ROUND_FLOOR = 3;
    BigNumber2.ROUND_HALF_UP = 4;
    BigNumber2.ROUND_HALF_DOWN = 5;
    BigNumber2.ROUND_HALF_EVEN = 6;
    BigNumber2.ROUND_HALF_CEIL = 7;
    BigNumber2.ROUND_HALF_FLOOR = 8;
    BigNumber2.EUCLID = 9;
    BigNumber2.config = BigNumber2.set = function(obj) {
      var p2, v2;
      if (obj != null) {
        if (typeof obj == "object") {
          if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
            v2 = obj[p2];
            intCheck(v2, 0, MAX, p2);
            DECIMAL_PLACES = v2;
          }
          if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
            v2 = obj[p2];
            intCheck(v2, 0, 8, p2);
            ROUNDING_MODE = v2;
          }
          if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
            v2 = obj[p2];
            if (v2 && v2.pop) {
              intCheck(v2[0], -MAX, 0, p2);
              intCheck(v2[1], 0, MAX, p2);
              TO_EXP_NEG = v2[0];
              TO_EXP_POS = v2[1];
            } else {
              intCheck(v2, -MAX, MAX, p2);
              TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
            }
          }
          if (obj.hasOwnProperty(p2 = "RANGE")) {
            v2 = obj[p2];
            if (v2 && v2.pop) {
              intCheck(v2[0], -MAX, -1, p2);
              intCheck(v2[1], 1, MAX, p2);
              MIN_EXP = v2[0];
              MAX_EXP = v2[1];
            } else {
              intCheck(v2, -MAX, MAX, p2);
              if (v2) {
                MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
              } else {
                throw Error(bignumberError + p2 + " cannot be zero: " + v2);
              }
            }
          }
          if (obj.hasOwnProperty(p2 = "CRYPTO")) {
            v2 = obj[p2];
            if (v2 === !!v2) {
              if (v2) {
                if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v2;
                } else {
                  CRYPTO = !v2;
                  throw Error(bignumberError + "crypto unavailable");
                }
              } else {
                CRYPTO = v2;
              }
            } else {
              throw Error(bignumberError + p2 + " not true or false: " + v2);
            }
          }
          if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
            v2 = obj[p2];
            intCheck(v2, 0, 9, p2);
            MODULO_MODE = v2;
          }
          if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
            v2 = obj[p2];
            intCheck(v2, 0, MAX, p2);
            POW_PRECISION = v2;
          }
          if (obj.hasOwnProperty(p2 = "FORMAT")) {
            v2 = obj[p2];
            if (typeof v2 == "object")
              FORMAT = v2;
            else
              throw Error(bignumberError + p2 + " not an object: " + v2);
          }
          if (obj.hasOwnProperty(p2 = "ALPHABET")) {
            v2 = obj[p2];
            if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
              alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
              ALPHABET = v2;
            } else {
              throw Error(bignumberError + p2 + " invalid: " + v2);
            }
          }
        } else {
          throw Error(bignumberError + "Object expected: " + obj);
        }
      }
      return {
        DECIMAL_PLACES,
        ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO,
        MODULO_MODE,
        POW_PRECISION,
        FORMAT,
        ALPHABET
      };
    };
    BigNumber2.isBigNumber = function(v2) {
      if (!v2 || v2._isBigNumber !== true)
        return false;
      if (!BigNumber2.DEBUG)
        return true;
      var i3, n3, c2 = v2.c, e3 = v2.e, s2 = v2.s;
      out:
        if ({}.toString.call(c2) == "[object Array]") {
          if ((s2 === 1 || s2 === -1) && e3 >= -MAX && e3 <= MAX && e3 === mathfloor(e3)) {
            if (c2[0] === 0) {
              if (e3 === 0 && c2.length === 1)
                return true;
              break out;
            }
            i3 = (e3 + 1) % LOG_BASE;
            if (i3 < 1)
              i3 += LOG_BASE;
            if (String(c2[0]).length == i3) {
              for (i3 = 0; i3 < c2.length; i3++) {
                n3 = c2[i3];
                if (n3 < 0 || n3 >= BASE || n3 !== mathfloor(n3))
                  break out;
              }
              if (n3 !== 0)
                return true;
            }
          }
        } else if (c2 === null && e3 === null && (s2 === null || s2 === 1 || s2 === -1)) {
          return true;
        }
      throw Error(bignumberError + "Invalid BigNumber: " + v2);
    };
    BigNumber2.maximum = BigNumber2.max = function() {
      return maxOrMin(arguments, -1);
    };
    BigNumber2.minimum = BigNumber2.min = function() {
      return maxOrMin(arguments, 1);
    };
    BigNumber2.random = function() {
      var pow2_53 = 9007199254740992;
      var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
        return mathfloor(Math.random() * pow2_53);
      } : function() {
        return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
      };
      return function(dp) {
        var a2, b2, e3, k2, v2, i3 = 0, c2 = [], rand = new BigNumber2(ONE);
        if (dp == null)
          dp = DECIMAL_PLACES;
        else
          intCheck(dp, 0, MAX);
        k2 = mathceil(dp / LOG_BASE);
        if (CRYPTO) {
          if (crypto.getRandomValues) {
            a2 = crypto.getRandomValues(new Uint32Array(k2 *= 2));
            for (; i3 < k2; ) {
              v2 = a2[i3] * 131072 + (a2[i3 + 1] >>> 11);
              if (v2 >= 9e15) {
                b2 = crypto.getRandomValues(new Uint32Array(2));
                a2[i3] = b2[0];
                a2[i3 + 1] = b2[1];
              } else {
                c2.push(v2 % 1e14);
                i3 += 2;
              }
            }
            i3 = k2 / 2;
          } else if (crypto.randomBytes) {
            a2 = crypto.randomBytes(k2 *= 7);
            for (; i3 < k2; ) {
              v2 = (a2[i3] & 31) * 281474976710656 + a2[i3 + 1] * 1099511627776 + a2[i3 + 2] * 4294967296 + a2[i3 + 3] * 16777216 + (a2[i3 + 4] << 16) + (a2[i3 + 5] << 8) + a2[i3 + 6];
              if (v2 >= 9e15) {
                crypto.randomBytes(7).copy(a2, i3);
              } else {
                c2.push(v2 % 1e14);
                i3 += 7;
              }
            }
            i3 = k2 / 7;
          } else {
            CRYPTO = false;
            throw Error(bignumberError + "crypto unavailable");
          }
        }
        if (!CRYPTO) {
          for (; i3 < k2; ) {
            v2 = random53bitInt();
            if (v2 < 9e15)
              c2[i3++] = v2 % 1e14;
          }
        }
        k2 = c2[--i3];
        dp %= LOG_BASE;
        if (k2 && dp) {
          v2 = POWS_TEN[LOG_BASE - dp];
          c2[i3] = mathfloor(k2 / v2) * v2;
        }
        for (; c2[i3] === 0; c2.pop(), i3--)
          ;
        if (i3 < 0) {
          c2 = [e3 = 0];
        } else {
          for (e3 = -1; c2[0] === 0; c2.splice(0, 1), e3 -= LOG_BASE)
            ;
          for (i3 = 1, v2 = c2[0]; v2 >= 10; v2 /= 10, i3++)
            ;
          if (i3 < LOG_BASE)
            e3 -= LOG_BASE - i3;
        }
        rand.e = e3;
        rand.c = c2;
        return rand;
      };
    }();
    BigNumber2.sum = function() {
      var i3 = 1, args = arguments, sum = new BigNumber2(args[0]);
      for (; i3 < args.length; )
        sum = sum.plus(args[i3++]);
      return sum;
    };
    convertBase = /* @__PURE__ */ function() {
      var decimal = "0123456789";
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j2, arr = [0], arrL, i3 = 0, len = str.length;
        for (; i3 < len; ) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
            ;
          arr[0] += alphabet.indexOf(str.charAt(i3++));
          for (j2 = 0; j2 < arr.length; j2++) {
            if (arr[j2] > baseOut - 1) {
              if (arr[j2 + 1] == null)
                arr[j2 + 1] = 0;
              arr[j2 + 1] += arr[j2] / baseOut | 0;
              arr[j2] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }
      return function(str, baseIn, baseOut, sign2, callerIsToString) {
        var alphabet, d2, e3, k2, r2, x2, xc, y2, i3 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
        if (i3 >= 0) {
          k2 = POW_PRECISION;
          POW_PRECISION = 0;
          str = str.replace(".", "");
          y2 = new BigNumber2(baseIn);
          x2 = y2.pow(str.length - i3);
          POW_PRECISION = k2;
          y2.c = toBaseOut(
            toFixedPoint(coeffToString(x2.c), x2.e, "0"),
            10,
            baseOut,
            decimal
          );
          y2.e = y2.c.length;
        }
        xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
        e3 = k2 = xc.length;
        for (; xc[--k2] == 0; xc.pop())
          ;
        if (!xc[0])
          return alphabet.charAt(0);
        if (i3 < 0) {
          --e3;
        } else {
          x2.c = xc;
          x2.e = e3;
          x2.s = sign2;
          x2 = div(x2, y2, dp, rm, baseOut);
          xc = x2.c;
          r2 = x2.r;
          e3 = x2.e;
        }
        d2 = e3 + dp + 1;
        i3 = xc[d2];
        k2 = baseOut / 2;
        r2 = r2 || d2 < 0 || xc[d2 + 1] != null;
        r2 = rm < 4 ? (i3 != null || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i3 > k2 || i3 == k2 && (rm == 4 || r2 || rm == 6 && xc[d2 - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
        if (d2 < 1 || !xc[0]) {
          str = r2 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {
          xc.length = d2;
          if (r2) {
            for (--baseOut; ++xc[--d2] > baseOut; ) {
              xc[d2] = 0;
              if (!d2) {
                ++e3;
                xc = [1].concat(xc);
              }
            }
          }
          for (k2 = xc.length; !xc[--k2]; )
            ;
          for (i3 = 0, str = ""; i3 <= k2; str += alphabet.charAt(xc[i3++]))
            ;
          str = toFixedPoint(str, e3, alphabet.charAt(0));
        }
        return str;
      };
    }();
    div = /* @__PURE__ */ function() {
      function multiply(x2, k2, base) {
        var m2, temp, xlo, xhi, carry = 0, i3 = x2.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
        for (x2 = x2.slice(); i3--; ) {
          xlo = x2[i3] % SQRT_BASE;
          xhi = x2[i3] / SQRT_BASE | 0;
          m2 = khi * xlo + xhi * klo;
          temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
          carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
          x2[i3] = temp % base;
        }
        if (carry)
          x2 = [carry].concat(x2);
        return x2;
      }
      function compare2(a2, b2, aL, bL) {
        var i3, cmp;
        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {
          for (i3 = cmp = 0; i3 < aL; i3++) {
            if (a2[i3] != b2[i3]) {
              cmp = a2[i3] > b2[i3] ? 1 : -1;
              break;
            }
          }
        }
        return cmp;
      }
      function subtract(a2, b2, aL, base) {
        var i3 = 0;
        for (; aL--; ) {
          a2[aL] -= i3;
          i3 = a2[aL] < b2[aL] ? 1 : 0;
          a2[aL] = i3 * base + a2[aL] - b2[aL];
        }
        for (; !a2[0] && a2.length > 1; a2.splice(0, 1))
          ;
      }
      return function(x2, y2, dp, rm, base) {
        var cmp, e3, i3, more, n3, prod, prodL, q2, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x2.s == y2.s ? 1 : -1, xc = x2.c, yc = y2.c;
        if (!xc || !xc[0] || !yc || !yc[0]) {
          return new BigNumber2(
            // Return NaN if either NaN, or both Infinity or 0.
            !x2.s || !y2.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
              // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
              xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
            )
          );
        }
        q2 = new BigNumber2(s2);
        qc = q2.c = [];
        e3 = x2.e - y2.e;
        s2 = dp + e3 + 1;
        if (!base) {
          base = BASE;
          e3 = bitFloor(x2.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
          s2 = s2 / LOG_BASE | 0;
        }
        for (i3 = 0; yc[i3] == (xc[i3] || 0); i3++)
          ;
        if (yc[i3] > (xc[i3] || 0))
          e3--;
        if (s2 < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i3 = 0;
          s2 += 2;
          n3 = mathfloor(base / (yc[0] + 1));
          if (n3 > 1) {
            yc = multiply(yc, n3, base);
            xc = multiply(xc, n3, base);
            yL = yc.length;
            xL = xc.length;
          }
          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;
          for (; remL < yL; rem[remL++] = 0)
            ;
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2)
            yc0++;
          do {
            n3 = 0;
            cmp = compare2(yc, rem, yL, remL);
            if (cmp < 0) {
              rem0 = rem[0];
              if (yL != remL)
                rem0 = rem0 * base + (rem[1] || 0);
              n3 = mathfloor(rem0 / yc0);
              if (n3 > 1) {
                if (n3 >= base)
                  n3 = base - 1;
                prod = multiply(yc, n3, base);
                prodL = prod.length;
                remL = rem.length;
                while (compare2(prod, rem, prodL, remL) == 1) {
                  n3--;
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {
                if (n3 == 0) {
                  cmp = n3 = 1;
                }
                prod = yc.slice();
                prodL = prod.length;
              }
              if (prodL < remL)
                prod = [0].concat(prod);
              subtract(rem, prod, remL, base);
              remL = rem.length;
              if (cmp == -1) {
                while (compare2(yc, rem, yL, remL) < 1) {
                  n3++;
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n3++;
              rem = [0];
            }
            qc[i3++] = n3;
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s2--);
          more = rem[0] != null;
          if (!qc[0])
            qc.splice(0, 1);
        }
        if (base == BASE) {
          for (i3 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i3++)
            ;
          round(q2, dp + (q2.e = i3 + e3 * LOG_BASE - 1) + 1, rm, more);
        } else {
          q2.e = e3;
          q2.r = +more;
        }
        return q2;
      };
    }();
    function format2(n3, i3, rm, id2) {
      var c0, e3, ne2, len, str;
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      if (!n3.c)
        return n3.toString();
      c0 = n3.c[0];
      ne2 = n3.e;
      if (i3 == null) {
        str = coeffToString(n3.c);
        str = id2 == 1 || id2 == 2 && (ne2 <= TO_EXP_NEG || ne2 >= TO_EXP_POS) ? toExponential(str, ne2) : toFixedPoint(str, ne2, "0");
      } else {
        n3 = round(new BigNumber2(n3), i3, rm);
        e3 = n3.e;
        str = coeffToString(n3.c);
        len = str.length;
        if (id2 == 1 || id2 == 2 && (i3 <= e3 || e3 <= TO_EXP_NEG)) {
          for (; len < i3; str += "0", len++)
            ;
          str = toExponential(str, e3);
        } else {
          i3 -= ne2;
          str = toFixedPoint(str, e3, "0");
          if (e3 + 1 > len) {
            if (--i3 > 0)
              for (str += "."; i3--; str += "0")
                ;
          } else {
            i3 += e3 - len;
            if (i3 > 0) {
              if (e3 + 1 == len)
                str += ".";
              for (; i3--; str += "0")
                ;
            }
          }
        }
      }
      return n3.s < 0 && c0 ? "-" + str : str;
    }
    function maxOrMin(args, n3) {
      var k2, y2, i3 = 1, x2 = new BigNumber2(args[0]);
      for (; i3 < args.length; i3++) {
        y2 = new BigNumber2(args[i3]);
        if (!y2.s || (k2 = compare(x2, y2)) === n3 || k2 === 0 && x2.s === n3) {
          x2 = y2;
        }
      }
      return x2;
    }
    function normalise(n3, c2, e3) {
      var i3 = 1, j2 = c2.length;
      for (; !c2[--j2]; c2.pop())
        ;
      for (j2 = c2[0]; j2 >= 10; j2 /= 10, i3++)
        ;
      if ((e3 = i3 + e3 * LOG_BASE - 1) > MAX_EXP) {
        n3.c = n3.e = null;
      } else if (e3 < MIN_EXP) {
        n3.c = [n3.e = 0];
      } else {
        n3.e = e3;
        n3.c = c2;
      }
      return n3;
    }
    parseNumeric2 = /* @__PURE__ */ function() {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
      return function(x2, str, isNum, b2) {
        var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
        if (isInfinityOrNaN.test(s2)) {
          x2.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
        } else {
          if (!isNum) {
            s2 = s2.replace(basePrefix, function(m2, p1, p2) {
              base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
              return !b2 || b2 == base ? p1 : m2;
            });
            if (b2) {
              base = b2;
              s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
            }
            if (str != s2)
              return new BigNumber2(s2, base);
          }
          if (BigNumber2.DEBUG) {
            throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
          }
          x2.s = null;
        }
        x2.c = x2.e = null;
      };
    }();
    function round(x2, sd, rm, r2) {
      var d2, i3, j2, k2, n3, ni, rd, xc = x2.c, pows10 = POWS_TEN;
      if (xc) {
        out: {
          for (d2 = 1, k2 = xc[0]; k2 >= 10; k2 /= 10, d2++)
            ;
          i3 = sd - d2;
          if (i3 < 0) {
            i3 += LOG_BASE;
            j2 = sd;
            n3 = xc[ni = 0];
            rd = mathfloor(n3 / pows10[d2 - j2 - 1] % 10);
          } else {
            ni = mathceil((i3 + 1) / LOG_BASE);
            if (ni >= xc.length) {
              if (r2) {
                for (; xc.length <= ni; xc.push(0))
                  ;
                n3 = rd = 0;
                d2 = 1;
                i3 %= LOG_BASE;
                j2 = i3 - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n3 = k2 = xc[ni];
              for (d2 = 1; k2 >= 10; k2 /= 10, d2++)
                ;
              i3 %= LOG_BASE;
              j2 = i3 - LOG_BASE + d2;
              rd = j2 < 0 ? 0 : mathfloor(n3 / pows10[d2 - j2 - 1] % 10);
            }
          }
          r2 = r2 || sd < 0 || // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
          xc[ni + 1] != null || (j2 < 0 ? n3 : n3 % pows10[d2 - j2 - 1]);
          r2 = rm < 4 ? (rd || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r2 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
          (i3 > 0 ? j2 > 0 ? n3 / pows10[d2 - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
          if (sd < 1 || !xc[0]) {
            xc.length = 0;
            if (r2) {
              sd -= x2.e + 1;
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x2.e = -sd || 0;
            } else {
              xc[0] = x2.e = 0;
            }
            return x2;
          }
          if (i3 == 0) {
            xc.length = ni;
            k2 = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k2 = pows10[LOG_BASE - i3];
            xc[ni] = j2 > 0 ? mathfloor(n3 / pows10[d2 - j2] % pows10[j2]) * k2 : 0;
          }
          if (r2) {
            for (; ; ) {
              if (ni == 0) {
                for (i3 = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i3++)
                  ;
                j2 = xc[0] += k2;
                for (k2 = 1; j2 >= 10; j2 /= 10, k2++)
                  ;
                if (i3 != k2) {
                  x2.e++;
                  if (xc[0] == BASE)
                    xc[0] = 1;
                }
                break;
              } else {
                xc[ni] += k2;
                if (xc[ni] != BASE)
                  break;
                xc[ni--] = 0;
                k2 = 1;
              }
            }
          }
          for (i3 = xc.length; xc[--i3] === 0; xc.pop())
            ;
        }
        if (x2.e > MAX_EXP) {
          x2.c = x2.e = null;
        } else if (x2.e < MIN_EXP) {
          x2.c = [x2.e = 0];
        }
      }
      return x2;
    }
    function valueOf(n3) {
      var str, e3 = n3.e;
      if (e3 === null)
        return n3.toString();
      str = coeffToString(n3.c);
      str = e3 <= TO_EXP_NEG || e3 >= TO_EXP_POS ? toExponential(str, e3) : toFixedPoint(str, e3, "0");
      return n3.s < 0 ? "-" + str : str;
    }
    P2.absoluteValue = P2.abs = function() {
      var x2 = new BigNumber2(this);
      if (x2.s < 0)
        x2.s = 1;
      return x2;
    };
    P2.comparedTo = function(y2, b2) {
      return compare(this, new BigNumber2(y2, b2));
    };
    P2.decimalPlaces = P2.dp = function(dp, rm) {
      var c2, n3, v2, x2 = this;
      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(new BigNumber2(x2), dp + x2.e + 1, rm);
      }
      if (!(c2 = x2.c))
        return null;
      n3 = ((v2 = c2.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
      if (v2 = c2[v2])
        for (; v2 % 10 == 0; v2 /= 10, n3--)
          ;
      if (n3 < 0)
        n3 = 0;
      return n3;
    };
    P2.dividedBy = P2.div = function(y2, b2) {
      return div(this, new BigNumber2(y2, b2), DECIMAL_PLACES, ROUNDING_MODE);
    };
    P2.dividedToIntegerBy = P2.idiv = function(y2, b2) {
      return div(this, new BigNumber2(y2, b2), 0, 1);
    };
    P2.exponentiatedBy = P2.pow = function(n3, m2) {
      var half, isModExp, i3, k2, more, nIsBig, nIsNeg, nIsOdd, y2, x2 = this;
      n3 = new BigNumber2(n3);
      if (n3.c && !n3.isInteger()) {
        throw Error(bignumberError + "Exponent not an integer: " + valueOf(n3));
      }
      if (m2 != null)
        m2 = new BigNumber2(m2);
      nIsBig = n3.e > 14;
      if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n3.c || !n3.c[0]) {
        y2 = new BigNumber2(Math.pow(+valueOf(x2), nIsBig ? n3.s * (2 - isOdd(n3)) : +valueOf(n3)));
        return m2 ? y2.mod(m2) : y2;
      }
      nIsNeg = n3.s < 0;
      if (m2) {
        if (m2.c ? !m2.c[0] : !m2.s)
          return new BigNumber2(NaN);
        isModExp = !nIsNeg && x2.isInteger() && m2.isInteger();
        if (isModExp)
          x2 = x2.mod(m2);
      } else if (n3.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
        k2 = x2.s < 0 && isOdd(n3) ? -0 : 0;
        if (x2.e > -1)
          k2 = 1 / k2;
        return new BigNumber2(nIsNeg ? 1 / k2 : k2);
      } else if (POW_PRECISION) {
        k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
      }
      if (nIsBig) {
        half = new BigNumber2(0.5);
        if (nIsNeg)
          n3.s = 1;
        nIsOdd = isOdd(n3);
      } else {
        i3 = Math.abs(+valueOf(n3));
        nIsOdd = i3 % 2;
      }
      y2 = new BigNumber2(ONE);
      for (; ; ) {
        if (nIsOdd) {
          y2 = y2.times(x2);
          if (!y2.c)
            break;
          if (k2) {
            if (y2.c.length > k2)
              y2.c.length = k2;
          } else if (isModExp) {
            y2 = y2.mod(m2);
          }
        }
        if (i3) {
          i3 = mathfloor(i3 / 2);
          if (i3 === 0)
            break;
          nIsOdd = i3 % 2;
        } else {
          n3 = n3.times(half);
          round(n3, n3.e + 1, 1);
          if (n3.e > 14) {
            nIsOdd = isOdd(n3);
          } else {
            i3 = +valueOf(n3);
            if (i3 === 0)
              break;
            nIsOdd = i3 % 2;
          }
        }
        x2 = x2.times(x2);
        if (k2) {
          if (x2.c && x2.c.length > k2)
            x2.c.length = k2;
        } else if (isModExp) {
          x2 = x2.mod(m2);
        }
      }
      if (isModExp)
        return y2;
      if (nIsNeg)
        y2 = ONE.div(y2);
      return m2 ? y2.mod(m2) : k2 ? round(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
    };
    P2.integerValue = function(rm) {
      var n3 = new BigNumber2(this);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(n3, n3.e + 1, rm);
    };
    P2.isEqualTo = P2.eq = function(y2, b2) {
      return compare(this, new BigNumber2(y2, b2)) === 0;
    };
    P2.isFinite = function() {
      return !!this.c;
    };
    P2.isGreaterThan = P2.gt = function(y2, b2) {
      return compare(this, new BigNumber2(y2, b2)) > 0;
    };
    P2.isGreaterThanOrEqualTo = P2.gte = function(y2, b2) {
      return (b2 = compare(this, new BigNumber2(y2, b2))) === 1 || b2 === 0;
    };
    P2.isInteger = function() {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };
    P2.isLessThan = P2.lt = function(y2, b2) {
      return compare(this, new BigNumber2(y2, b2)) < 0;
    };
    P2.isLessThanOrEqualTo = P2.lte = function(y2, b2) {
      return (b2 = compare(this, new BigNumber2(y2, b2))) === -1 || b2 === 0;
    };
    P2.isNaN = function() {
      return !this.s;
    };
    P2.isNegative = function() {
      return this.s < 0;
    };
    P2.isPositive = function() {
      return this.s > 0;
    };
    P2.isZero = function() {
      return !!this.c && this.c[0] == 0;
    };
    P2.minus = function(y2, b2) {
      var i3, j2, t2, xLTy, x2 = this, a2 = x2.s;
      y2 = new BigNumber2(y2, b2);
      b2 = y2.s;
      if (!a2 || !b2)
        return new BigNumber2(NaN);
      if (a2 != b2) {
        y2.s = -b2;
        return x2.plus(y2);
      }
      var xe2 = x2.e / LOG_BASE, ye2 = y2.e / LOG_BASE, xc = x2.c, yc = y2.c;
      if (!xe2 || !ye2) {
        if (!xc || !yc)
          return xc ? (y2.s = -b2, y2) : new BigNumber2(yc ? x2 : NaN);
        if (!xc[0] || !yc[0]) {
          return yc[0] ? (y2.s = -b2, y2) : new BigNumber2(xc[0] ? x2 : (
            // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
            ROUNDING_MODE == 3 ? -0 : 0
          ));
        }
      }
      xe2 = bitFloor(xe2);
      ye2 = bitFloor(ye2);
      xc = xc.slice();
      if (a2 = xe2 - ye2) {
        if (xLTy = a2 < 0) {
          a2 = -a2;
          t2 = xc;
        } else {
          ye2 = xe2;
          t2 = yc;
        }
        t2.reverse();
        for (b2 = a2; b2--; t2.push(0))
          ;
        t2.reverse();
      } else {
        j2 = (xLTy = (a2 = xc.length) < (b2 = yc.length)) ? a2 : b2;
        for (a2 = b2 = 0; b2 < j2; b2++) {
          if (xc[b2] != yc[b2]) {
            xLTy = xc[b2] < yc[b2];
            break;
          }
        }
      }
      if (xLTy) {
        t2 = xc;
        xc = yc;
        yc = t2;
        y2.s = -y2.s;
      }
      b2 = (j2 = yc.length) - (i3 = xc.length);
      if (b2 > 0)
        for (; b2--; xc[i3++] = 0)
          ;
      b2 = BASE - 1;
      for (; j2 > a2; ) {
        if (xc[--j2] < yc[j2]) {
          for (i3 = j2; i3 && !xc[--i3]; xc[i3] = b2)
            ;
          --xc[i3];
          xc[j2] += BASE;
        }
        xc[j2] -= yc[j2];
      }
      for (; xc[0] == 0; xc.splice(0, 1), --ye2)
        ;
      if (!xc[0]) {
        y2.s = ROUNDING_MODE == 3 ? -1 : 1;
        y2.c = [y2.e = 0];
        return y2;
      }
      return normalise(y2, xc, ye2);
    };
    P2.modulo = P2.mod = function(y2, b2) {
      var q2, s2, x2 = this;
      y2 = new BigNumber2(y2, b2);
      if (!x2.c || !y2.s || y2.c && !y2.c[0]) {
        return new BigNumber2(NaN);
      } else if (!y2.c || x2.c && !x2.c[0]) {
        return new BigNumber2(x2);
      }
      if (MODULO_MODE == 9) {
        s2 = y2.s;
        y2.s = 1;
        q2 = div(x2, y2, 0, 3);
        y2.s = s2;
        q2.s *= s2;
      } else {
        q2 = div(x2, y2, 0, MODULO_MODE);
      }
      y2 = x2.minus(q2.times(y2));
      if (!y2.c[0] && MODULO_MODE == 1)
        y2.s = x2.s;
      return y2;
    };
    P2.multipliedBy = P2.times = function(y2, b2) {
      var c2, e3, i3, j2, k2, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x2 = this, xc = x2.c, yc = (y2 = new BigNumber2(y2, b2)).c;
      if (!xc || !yc || !xc[0] || !yc[0]) {
        if (!x2.s || !y2.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y2.c = y2.e = y2.s = null;
        } else {
          y2.s *= x2.s;
          if (!xc || !yc) {
            y2.c = y2.e = null;
          } else {
            y2.c = [0];
            y2.e = 0;
          }
        }
        return y2;
      }
      e3 = bitFloor(x2.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
      y2.s *= x2.s;
      xcL = xc.length;
      ycL = yc.length;
      if (xcL < ycL) {
        zc = xc;
        xc = yc;
        yc = zc;
        i3 = xcL;
        xcL = ycL;
        ycL = i3;
      }
      for (i3 = xcL + ycL, zc = []; i3--; zc.push(0))
        ;
      base = BASE;
      sqrtBase = SQRT_BASE;
      for (i3 = ycL; --i3 >= 0; ) {
        c2 = 0;
        ylo = yc[i3] % sqrtBase;
        yhi = yc[i3] / sqrtBase | 0;
        for (k2 = xcL, j2 = i3 + k2; j2 > i3; ) {
          xlo = xc[--k2] % sqrtBase;
          xhi = xc[k2] / sqrtBase | 0;
          m2 = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc[j2] + c2;
          c2 = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
          zc[j2--] = xlo % base;
        }
        zc[j2] = c2;
      }
      if (c2) {
        ++e3;
      } else {
        zc.splice(0, 1);
      }
      return normalise(y2, zc, e3);
    };
    P2.negated = function() {
      var x2 = new BigNumber2(this);
      x2.s = -x2.s || null;
      return x2;
    };
    P2.plus = function(y2, b2) {
      var t2, x2 = this, a2 = x2.s;
      y2 = new BigNumber2(y2, b2);
      b2 = y2.s;
      if (!a2 || !b2)
        return new BigNumber2(NaN);
      if (a2 != b2) {
        y2.s = -b2;
        return x2.minus(y2);
      }
      var xe2 = x2.e / LOG_BASE, ye2 = y2.e / LOG_BASE, xc = x2.c, yc = y2.c;
      if (!xe2 || !ye2) {
        if (!xc || !yc)
          return new BigNumber2(a2 / 0);
        if (!xc[0] || !yc[0])
          return yc[0] ? y2 : new BigNumber2(xc[0] ? x2 : a2 * 0);
      }
      xe2 = bitFloor(xe2);
      ye2 = bitFloor(ye2);
      xc = xc.slice();
      if (a2 = xe2 - ye2) {
        if (a2 > 0) {
          ye2 = xe2;
          t2 = yc;
        } else {
          a2 = -a2;
          t2 = xc;
        }
        t2.reverse();
        for (; a2--; t2.push(0))
          ;
        t2.reverse();
      }
      a2 = xc.length;
      b2 = yc.length;
      if (a2 - b2 < 0) {
        t2 = yc;
        yc = xc;
        xc = t2;
        b2 = a2;
      }
      for (a2 = 0; b2; ) {
        a2 = (xc[--b2] = xc[b2] + yc[b2] + a2) / BASE | 0;
        xc[b2] = BASE === xc[b2] ? 0 : xc[b2] % BASE;
      }
      if (a2) {
        xc = [a2].concat(xc);
        ++ye2;
      }
      return normalise(y2, xc, ye2);
    };
    P2.precision = P2.sd = function(sd, rm) {
      var c2, n3, v2, x2 = this;
      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(new BigNumber2(x2), sd, rm);
      }
      if (!(c2 = x2.c))
        return null;
      v2 = c2.length - 1;
      n3 = v2 * LOG_BASE + 1;
      if (v2 = c2[v2]) {
        for (; v2 % 10 == 0; v2 /= 10, n3--)
          ;
        for (v2 = c2[0]; v2 >= 10; v2 /= 10, n3++)
          ;
      }
      if (sd && x2.e + 1 > n3)
        n3 = x2.e + 1;
      return n3;
    };
    P2.shiftedBy = function(k2) {
      intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times("1e" + k2);
    };
    P2.squareRoot = P2.sqrt = function() {
      var m2, n3, r2, rep, t2, x2 = this, c2 = x2.c, s2 = x2.s, e3 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
      if (s2 !== 1 || !c2 || !c2[0]) {
        return new BigNumber2(!s2 || s2 < 0 && (!c2 || c2[0]) ? NaN : c2 ? x2 : 1 / 0);
      }
      s2 = Math.sqrt(+valueOf(x2));
      if (s2 == 0 || s2 == 1 / 0) {
        n3 = coeffToString(c2);
        if ((n3.length + e3) % 2 == 0)
          n3 += "0";
        s2 = Math.sqrt(+n3);
        e3 = bitFloor((e3 + 1) / 2) - (e3 < 0 || e3 % 2);
        if (s2 == 1 / 0) {
          n3 = "5e" + e3;
        } else {
          n3 = s2.toExponential();
          n3 = n3.slice(0, n3.indexOf("e") + 1) + e3;
        }
        r2 = new BigNumber2(n3);
      } else {
        r2 = new BigNumber2(s2 + "");
      }
      if (r2.c[0]) {
        e3 = r2.e;
        s2 = e3 + dp;
        if (s2 < 3)
          s2 = 0;
        for (; ; ) {
          t2 = r2;
          r2 = half.times(t2.plus(div(x2, t2, dp, 1)));
          if (coeffToString(t2.c).slice(0, s2) === (n3 = coeffToString(r2.c)).slice(0, s2)) {
            if (r2.e < e3)
              --s2;
            n3 = n3.slice(s2 - 3, s2 + 1);
            if (n3 == "9999" || !rep && n3 == "4999") {
              if (!rep) {
                round(t2, t2.e + DECIMAL_PLACES + 2, 0);
                if (t2.times(t2).eq(x2)) {
                  r2 = t2;
                  break;
                }
              }
              dp += 4;
              s2 += 4;
              rep = 1;
            } else {
              if (!+n3 || !+n3.slice(1) && n3.charAt(0) == "5") {
                round(r2, r2.e + DECIMAL_PLACES + 2, 1);
                m2 = !r2.times(r2).eq(x2);
              }
              break;
            }
          }
        }
      }
      return round(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
    };
    P2.toExponential = function(dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format2(this, dp, rm, 1);
    };
    P2.toFixed = function(dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format2(this, dp, rm);
    };
    P2.toFormat = function(dp, rm, format3) {
      var str, x2 = this;
      if (format3 == null) {
        if (dp != null && rm && typeof rm == "object") {
          format3 = rm;
          rm = null;
        } else if (dp && typeof dp == "object") {
          format3 = dp;
          dp = rm = null;
        } else {
          format3 = FORMAT;
        }
      } else if (typeof format3 != "object") {
        throw Error(bignumberError + "Argument not an object: " + format3);
      }
      str = x2.toFixed(dp, rm);
      if (x2.c) {
        var i3, arr = str.split("."), g1 = +format3.groupSize, g22 = +format3.secondaryGroupSize, groupSeparator = format3.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
        if (g22) {
          i3 = g1;
          g1 = g22;
          g22 = i3;
          len -= i3;
        }
        if (g1 > 0 && len > 0) {
          i3 = len % g1 || g1;
          intPart = intDigits.substr(0, i3);
          for (; i3 < len; i3 += g1)
            intPart += groupSeparator + intDigits.substr(i3, g1);
          if (g22 > 0)
            intPart += groupSeparator + intDigits.slice(i3);
          if (isNeg)
            intPart = "-" + intPart;
        }
        str = fractionPart ? intPart + (format3.decimalSeparator || "") + ((g22 = +format3.fractionGroupSize) ? fractionPart.replace(
          new RegExp("\\d{" + g22 + "}\\B", "g"),
          "$&" + (format3.fractionGroupSeparator || "")
        ) : fractionPart) : intPart;
      }
      return (format3.prefix || "") + str + (format3.suffix || "");
    };
    P2.toFraction = function(md) {
      var d2, d0, d1, d22, e3, exp2, n3, n0, n1, q2, r2, s2, x2 = this, xc = x2.c;
      if (md != null) {
        n3 = new BigNumber2(md);
        if (!n3.isInteger() && (n3.c || n3.s !== 1) || n3.lt(ONE)) {
          throw Error(bignumberError + "Argument " + (n3.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n3));
        }
      }
      if (!xc)
        return new BigNumber2(x2);
      d2 = new BigNumber2(ONE);
      n1 = d0 = new BigNumber2(ONE);
      d1 = n0 = new BigNumber2(ONE);
      s2 = coeffToString(xc);
      e3 = d2.e = s2.length - x2.e - 1;
      d2.c[0] = POWS_TEN[(exp2 = e3 % LOG_BASE) < 0 ? LOG_BASE + exp2 : exp2];
      md = !md || n3.comparedTo(d2) > 0 ? e3 > 0 ? d2 : n1 : n3;
      exp2 = MAX_EXP;
      MAX_EXP = 1 / 0;
      n3 = new BigNumber2(s2);
      n0.c[0] = 0;
      for (; ; ) {
        q2 = div(n3, d2, 0, 1);
        d22 = d0.plus(q2.times(d1));
        if (d22.comparedTo(md) == 1)
          break;
        d0 = d1;
        d1 = d22;
        n1 = n0.plus(q2.times(d22 = n1));
        n0 = d22;
        d2 = n3.minus(q2.times(d22 = d2));
        n3 = d22;
      }
      d22 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d22.times(n1));
      d0 = d0.plus(d22.times(d1));
      n0.s = n1.s = x2.s;
      e3 = e3 * 2;
      r2 = div(n1, d1, e3, ROUNDING_MODE).minus(x2).abs().comparedTo(
        div(n0, d0, e3, ROUNDING_MODE).minus(x2).abs()
      ) < 1 ? [n1, d1] : [n0, d0];
      MAX_EXP = exp2;
      return r2;
    };
    P2.toNumber = function() {
      return +valueOf(this);
    };
    P2.toPrecision = function(sd, rm) {
      if (sd != null)
        intCheck(sd, 1, MAX);
      return format2(this, sd, rm, 2);
    };
    P2.toString = function(b2) {
      var str, n3 = this, s2 = n3.s, e3 = n3.e;
      if (e3 === null) {
        if (s2) {
          str = "Infinity";
          if (s2 < 0)
            str = "-" + str;
        } else {
          str = "NaN";
        }
      } else {
        if (b2 == null) {
          str = e3 <= TO_EXP_NEG || e3 >= TO_EXP_POS ? toExponential(coeffToString(n3.c), e3) : toFixedPoint(coeffToString(n3.c), e3, "0");
        } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
          n3 = round(new BigNumber2(n3), DECIMAL_PLACES + e3 + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n3.c), n3.e, "0");
        } else {
          intCheck(b2, 2, ALPHABET.length, "Base");
          str = convertBase(toFixedPoint(coeffToString(n3.c), e3, "0"), 10, b2, s2, true);
        }
        if (s2 < 0 && n3.c[0])
          str = "-" + str;
      }
      return str;
    };
    P2.valueOf = P2.toJSON = function() {
      return valueOf(this);
    };
    P2._isBigNumber = true;
    P2[Symbol.toStringTag] = "BigNumber";
    P2[Symbol.for("nodejs.util.inspect.custom")] = P2.valueOf;
    if (configObject != null)
      BigNumber2.set(configObject);
    return BigNumber2;
  }
  function bitFloor(n3) {
    var i3 = n3 | 0;
    return n3 > 0 || n3 === i3 ? i3 : i3 - 1;
  }
  function coeffToString(a2) {
    var s2, z2, i3 = 1, j2 = a2.length, r2 = a2[0] + "";
    for (; i3 < j2; ) {
      s2 = a2[i3++] + "";
      z2 = LOG_BASE - s2.length;
      for (; z2--; s2 = "0" + s2)
        ;
      r2 += s2;
    }
    for (j2 = r2.length; r2.charCodeAt(--j2) === 48; )
      ;
    return r2.slice(0, j2 + 1 || 1);
  }
  function compare(x2, y2) {
    var a2, b2, xc = x2.c, yc = y2.c, i3 = x2.s, j2 = y2.s, k2 = x2.e, l2 = y2.e;
    if (!i3 || !j2)
      return null;
    a2 = xc && !xc[0];
    b2 = yc && !yc[0];
    if (a2 || b2)
      return a2 ? b2 ? 0 : -j2 : i3;
    if (i3 != j2)
      return i3;
    a2 = i3 < 0;
    b2 = k2 == l2;
    if (!xc || !yc)
      return b2 ? 0 : !xc ^ a2 ? 1 : -1;
    if (!b2)
      return k2 > l2 ^ a2 ? 1 : -1;
    j2 = (k2 = xc.length) < (l2 = yc.length) ? k2 : l2;
    for (i3 = 0; i3 < j2; i3++)
      if (xc[i3] != yc[i3])
        return xc[i3] > yc[i3] ^ a2 ? 1 : -1;
    return k2 == l2 ? 0 : k2 > l2 ^ a2 ? 1 : -1;
  }
  function intCheck(n3, min3, max3, name) {
    if (n3 < min3 || n3 > max3 || n3 !== mathfloor(n3)) {
      throw Error(bignumberError + (name || "Argument") + (typeof n3 == "number" ? n3 < min3 || n3 > max3 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n3));
    }
  }
  function isOdd(n3) {
    var k2 = n3.c.length - 1;
    return bitFloor(n3.e / LOG_BASE) == k2 && n3.c[k2] % 2 != 0;
  }
  function toExponential(str, e3) {
    return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e3 < 0 ? "e" : "e+") + e3;
  }
  function toFixedPoint(str, e3, z2) {
    var len, zs;
    if (e3 < 0) {
      for (zs = z2 + "."; ++e3; zs += z2)
        ;
      str = zs + str;
    } else {
      len = str.length;
      if (++e3 > len) {
        for (zs = z2, e3 -= len; --e3; zs += z2)
          ;
        str += zs;
      } else if (e3 < len) {
        str = str.slice(0, e3) + "." + str.slice(e3);
      }
    }
    return str;
  }
  var BigNumber = clone();
  var bignumber_default = BigNumber;

  // node_modules/splaytree-ts/dist/index.js
  var SplayTreeNode = class {
    constructor(key) {
      __publicField(this, "key");
      __publicField(this, "left", null);
      __publicField(this, "right", null);
      this.key = key;
    }
  };
  var SplayTreeSetNode = class extends SplayTreeNode {
    constructor(key) {
      super(key);
    }
  };
  var SplayTree = class {
    constructor() {
      __publicField(this, "size", 0);
      __publicField(this, "modificationCount", 0);
      __publicField(this, "splayCount", 0);
    }
    splay(key) {
      const root3 = this.root;
      if (root3 == null) {
        this.compare(key, key);
        return -1;
      }
      let right = null;
      let newTreeRight = null;
      let left = null;
      let newTreeLeft = null;
      let current = root3;
      const compare2 = this.compare;
      let comp;
      while (true) {
        comp = compare2(current.key, key);
        if (comp > 0) {
          let currentLeft = current.left;
          if (currentLeft == null)
            break;
          comp = compare2(currentLeft.key, key);
          if (comp > 0) {
            current.left = currentLeft.right;
            currentLeft.right = current;
            current = currentLeft;
            currentLeft = current.left;
            if (currentLeft == null)
              break;
          }
          if (right == null) {
            newTreeRight = current;
          } else {
            right.left = current;
          }
          right = current;
          current = currentLeft;
        } else if (comp < 0) {
          let currentRight = current.right;
          if (currentRight == null)
            break;
          comp = compare2(currentRight.key, key);
          if (comp < 0) {
            current.right = currentRight.left;
            currentRight.left = current;
            current = currentRight;
            currentRight = current.right;
            if (currentRight == null)
              break;
          }
          if (left == null) {
            newTreeLeft = current;
          } else {
            left.right = current;
          }
          left = current;
          current = currentRight;
        } else {
          break;
        }
      }
      if (left != null) {
        left.right = current.left;
        current.left = newTreeLeft;
      }
      if (right != null) {
        right.left = current.right;
        current.right = newTreeRight;
      }
      if (this.root !== current) {
        this.root = current;
        this.splayCount++;
      }
      return comp;
    }
    splayMin(node) {
      let current = node;
      let nextLeft = current.left;
      while (nextLeft != null) {
        const left = nextLeft;
        current.left = left.right;
        left.right = current;
        current = left;
        nextLeft = current.left;
      }
      return current;
    }
    splayMax(node) {
      let current = node;
      let nextRight = current.right;
      while (nextRight != null) {
        const right = nextRight;
        current.right = right.left;
        right.left = current;
        current = right;
        nextRight = current.right;
      }
      return current;
    }
    _delete(key) {
      if (this.root == null)
        return null;
      const comp = this.splay(key);
      if (comp != 0)
        return null;
      let root3 = this.root;
      const result = root3;
      const left = root3.left;
      this.size--;
      if (left == null) {
        this.root = root3.right;
      } else {
        const right = root3.right;
        root3 = this.splayMax(left);
        root3.right = right;
        this.root = root3;
      }
      this.modificationCount++;
      return result;
    }
    addNewRoot(node, comp) {
      this.size++;
      this.modificationCount++;
      const root3 = this.root;
      if (root3 == null) {
        this.root = node;
        return;
      }
      if (comp < 0) {
        node.left = root3;
        node.right = root3.right;
        root3.right = null;
      } else {
        node.right = root3;
        node.left = root3.left;
        root3.left = null;
      }
      this.root = node;
    }
    _first() {
      const root3 = this.root;
      if (root3 == null)
        return null;
      this.root = this.splayMin(root3);
      return this.root;
    }
    _last() {
      const root3 = this.root;
      if (root3 == null)
        return null;
      this.root = this.splayMax(root3);
      return this.root;
    }
    clear() {
      this.root = null;
      this.size = 0;
      this.modificationCount++;
    }
    has(key) {
      return this.validKey(key) && this.splay(key) == 0;
    }
    defaultCompare() {
      return (a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
    }
    wrap() {
      return {
        getRoot: () => {
          return this.root;
        },
        setRoot: (root3) => {
          this.root = root3;
        },
        getSize: () => {
          return this.size;
        },
        getModificationCount: () => {
          return this.modificationCount;
        },
        getSplayCount: () => {
          return this.splayCount;
        },
        setSplayCount: (count) => {
          this.splayCount = count;
        },
        splay: (key) => {
          return this.splay(key);
        },
        has: (key) => {
          return this.has(key);
        }
      };
    }
  };
  var _a;
  var _SplayTreeSet = class _SplayTreeSet extends SplayTree {
    constructor(compare2, isValidKey) {
      super();
      __publicField(this, "root", null);
      __publicField(this, "compare");
      __publicField(this, "validKey");
      __publicField(this, _a, "[object Set]");
      this.compare = compare2 != null ? compare2 : this.defaultCompare();
      this.validKey = isValidKey != null ? isValidKey : (v2) => v2 != null && v2 != void 0;
    }
    delete(element) {
      if (!this.validKey(element))
        return false;
      return this._delete(element) != null;
    }
    deleteAll(elements) {
      for (const element of elements) {
        this.delete(element);
      }
    }
    forEach(f2) {
      const nodes = this[Symbol.iterator]();
      let result;
      while (result = nodes.next(), !result.done) {
        f2(result.value, result.value, this);
      }
    }
    add(element) {
      const compare2 = this.splay(element);
      if (compare2 != 0)
        this.addNewRoot(new SplayTreeSetNode(element), compare2);
      return this;
    }
    addAndReturn(element) {
      const compare2 = this.splay(element);
      if (compare2 != 0)
        this.addNewRoot(new SplayTreeSetNode(element), compare2);
      return this.root.key;
    }
    addAll(elements) {
      for (const element of elements) {
        this.add(element);
      }
    }
    isEmpty() {
      return this.root == null;
    }
    isNotEmpty() {
      return this.root != null;
    }
    single() {
      if (this.size == 0)
        throw "Bad state: No element";
      if (this.size > 1)
        throw "Bad state: Too many element";
      return this.root.key;
    }
    first() {
      if (this.size == 0)
        throw "Bad state: No element";
      return this._first().key;
    }
    last() {
      if (this.size == 0)
        throw "Bad state: No element";
      return this._last().key;
    }
    lastBefore(element) {
      if (element == null)
        throw "Invalid arguments(s)";
      if (this.root == null)
        return null;
      const comp = this.splay(element);
      if (comp < 0)
        return this.root.key;
      let node = this.root.left;
      if (node == null)
        return null;
      let nodeRight = node.right;
      while (nodeRight != null) {
        node = nodeRight;
        nodeRight = node.right;
      }
      return node.key;
    }
    firstAfter(element) {
      if (element == null)
        throw "Invalid arguments(s)";
      if (this.root == null)
        return null;
      const comp = this.splay(element);
      if (comp > 0)
        return this.root.key;
      let node = this.root.right;
      if (node == null)
        return null;
      let nodeLeft = node.left;
      while (nodeLeft != null) {
        node = nodeLeft;
        nodeLeft = node.left;
      }
      return node.key;
    }
    retainAll(elements) {
      const retainSet = new _SplayTreeSet(this.compare, this.validKey);
      const modificationCount = this.modificationCount;
      for (const object of elements) {
        if (modificationCount != this.modificationCount) {
          throw "Concurrent modification during iteration.";
        }
        if (this.validKey(object) && this.splay(object) == 0) {
          retainSet.add(this.root.key);
        }
      }
      if (retainSet.size != this.size) {
        this.root = retainSet.root;
        this.size = retainSet.size;
        this.modificationCount++;
      }
    }
    lookup(object) {
      if (!this.validKey(object))
        return null;
      const comp = this.splay(object);
      if (comp != 0)
        return null;
      return this.root.key;
    }
    intersection(other) {
      const result = new _SplayTreeSet(this.compare, this.validKey);
      for (const element of this) {
        if (other.has(element))
          result.add(element);
      }
      return result;
    }
    difference(other) {
      const result = new _SplayTreeSet(this.compare, this.validKey);
      for (const element of this) {
        if (!other.has(element))
          result.add(element);
      }
      return result;
    }
    union(other) {
      const u2 = this.clone();
      u2.addAll(other);
      return u2;
    }
    clone() {
      const set4 = new _SplayTreeSet(this.compare, this.validKey);
      set4.size = this.size;
      set4.root = this.copyNode(this.root);
      return set4;
    }
    copyNode(node) {
      if (node == null)
        return null;
      function copyChildren(node2, dest) {
        let left;
        let right;
        do {
          left = node2.left;
          right = node2.right;
          if (left != null) {
            const newLeft = new SplayTreeSetNode(left.key);
            dest.left = newLeft;
            copyChildren(left, newLeft);
          }
          if (right != null) {
            const newRight = new SplayTreeSetNode(right.key);
            dest.right = newRight;
            node2 = right;
            dest = newRight;
          }
        } while (right != null);
      }
      const result = new SplayTreeSetNode(node.key);
      copyChildren(node, result);
      return result;
    }
    toSet() {
      return this.clone();
    }
    entries() {
      return new SplayTreeSetEntryIterableIterator(this.wrap());
    }
    keys() {
      return this[Symbol.iterator]();
    }
    values() {
      return this[Symbol.iterator]();
    }
    [Symbol.iterator]() {
      return new SplayTreeKeyIterableIterator(this.wrap());
    }
  };
  _a = Symbol.toStringTag;
  var SplayTreeSet = _SplayTreeSet;
  var SplayTreeIterableIterator = class {
    constructor(tree) {
      __publicField(this, "tree");
      __publicField(this, "path", new Array());
      __publicField(this, "modificationCount", null);
      __publicField(this, "splayCount");
      this.tree = tree;
      this.splayCount = tree.getSplayCount();
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      if (this.moveNext())
        return { done: false, value: this.current() };
      return { done: true, value: null };
    }
    current() {
      if (!this.path.length)
        return null;
      const node = this.path[this.path.length - 1];
      return this.getValue(node);
    }
    rebuildPath(key) {
      this.path.splice(0, this.path.length);
      this.tree.splay(key);
      this.path.push(this.tree.getRoot());
      this.splayCount = this.tree.getSplayCount();
    }
    findLeftMostDescendent(node) {
      while (node != null) {
        this.path.push(node);
        node = node.left;
      }
    }
    moveNext() {
      if (this.modificationCount != this.tree.getModificationCount()) {
        if (this.modificationCount == null) {
          this.modificationCount = this.tree.getModificationCount();
          let node2 = this.tree.getRoot();
          while (node2 != null) {
            this.path.push(node2);
            node2 = node2.left;
          }
          return this.path.length > 0;
        }
        throw "Concurrent modification during iteration.";
      }
      if (!this.path.length)
        return false;
      if (this.splayCount != this.tree.getSplayCount()) {
        this.rebuildPath(this.path[this.path.length - 1].key);
      }
      let node = this.path[this.path.length - 1];
      let next = node.right;
      if (next != null) {
        while (next != null) {
          this.path.push(next);
          next = next.left;
        }
        return true;
      }
      this.path.pop();
      while (this.path.length && this.path[this.path.length - 1].right === node) {
        node = this.path.pop();
      }
      return this.path.length > 0;
    }
  };
  var SplayTreeKeyIterableIterator = class extends SplayTreeIterableIterator {
    getValue(node) {
      return node.key;
    }
  };
  var SplayTreeSetEntryIterableIterator = class extends SplayTreeIterableIterator {
    getValue(node) {
      return [node.key, node.key];
    }
  };

  // node_modules/polyclip-ts/dist/identity.js
  var identity_default3 = (x2) => {
    return x2;
  };

  // node_modules/polyclip-ts/dist/snap.js
  var snap_default = (eps) => {
    if (eps) {
      const xTree = new SplayTreeSet(compare_default(eps));
      const yTree = new SplayTreeSet(compare_default(eps));
      const snapCoord = (coord2, tree) => {
        return tree.addAndReturn(coord2);
      };
      const snap = (v2) => {
        return {
          x: snapCoord(v2.x, xTree),
          y: snapCoord(v2.y, yTree)
        };
      };
      snap({ x: new bignumber_default(0), y: new bignumber_default(0) });
      return snap;
    }
    return identity_default3;
  };

  // node_modules/polyclip-ts/dist/precision.js
  var set3 = (eps) => {
    return {
      set: (eps2) => {
        precision = set3(eps2);
      },
      reset: () => set3(eps),
      compare: compare_default(eps),
      snap: snap_default(eps),
      orient: orient_default(eps)
    };
  };
  var precision = set3();

  // node_modules/polyclip-ts/dist/bbox.js
  var isInBbox = (bbox2, point2) => {
    return bbox2.ll.x.isLessThanOrEqualTo(point2.x) && point2.x.isLessThanOrEqualTo(bbox2.ur.x) && bbox2.ll.y.isLessThanOrEqualTo(point2.y) && point2.y.isLessThanOrEqualTo(bbox2.ur.y);
  };
  var getBboxOverlap = (b1, b2) => {
    if (b2.ur.x.isLessThan(b1.ll.x) || b1.ur.x.isLessThan(b2.ll.x) || b2.ur.y.isLessThan(b1.ll.y) || b1.ur.y.isLessThan(b2.ll.y))
      return null;
    const lowerX = b1.ll.x.isLessThan(b2.ll.x) ? b2.ll.x : b1.ll.x;
    const upperX = b1.ur.x.isLessThan(b2.ur.x) ? b1.ur.x : b2.ur.x;
    const lowerY = b1.ll.y.isLessThan(b2.ll.y) ? b2.ll.y : b1.ll.y;
    const upperY = b1.ur.y.isLessThan(b2.ur.y) ? b1.ur.y : b2.ur.y;
    return { ll: { x: lowerX, y: lowerY }, ur: { x: upperX, y: upperY } };
  };

  // node_modules/polyclip-ts/dist/vector.js
  var crossProduct = (a2, b2) => a2.x.times(b2.y).minus(a2.y.times(b2.x));
  var dotProduct = (a2, b2) => a2.x.times(b2.x).plus(a2.y.times(b2.y));
  var length = (v2) => dotProduct(v2, v2).sqrt();
  var sineOfAngle = (pShared, pBase, pAngle) => {
    const vBase = { x: pBase.x.minus(pShared.x), y: pBase.y.minus(pShared.y) };
    const vAngle = { x: pAngle.x.minus(pShared.x), y: pAngle.y.minus(pShared.y) };
    return crossProduct(vAngle, vBase).div(length(vAngle)).div(length(vBase));
  };
  var cosineOfAngle = (pShared, pBase, pAngle) => {
    const vBase = { x: pBase.x.minus(pShared.x), y: pBase.y.minus(pShared.y) };
    const vAngle = { x: pAngle.x.minus(pShared.x), y: pAngle.y.minus(pShared.y) };
    return dotProduct(vAngle, vBase).div(length(vAngle)).div(length(vBase));
  };
  var horizontalIntersection = (pt2, v2, y2) => {
    if (v2.y.isZero())
      return null;
    return { x: pt2.x.plus(v2.x.div(v2.y).times(y2.minus(pt2.y))), y: y2 };
  };
  var verticalIntersection = (pt2, v2, x2) => {
    if (v2.x.isZero())
      return null;
    return { x: x2, y: pt2.y.plus(v2.y.div(v2.x).times(x2.minus(pt2.x))) };
  };
  var intersection = (pt1, v1, pt2, v2) => {
    if (v1.x.isZero())
      return verticalIntersection(pt2, v2, pt1.x);
    if (v2.x.isZero())
      return verticalIntersection(pt1, v1, pt2.x);
    if (v1.y.isZero())
      return horizontalIntersection(pt2, v2, pt1.y);
    if (v2.y.isZero())
      return horizontalIntersection(pt1, v1, pt2.y);
    const kross = crossProduct(v1, v2);
    if (kross.isZero())
      return null;
    const ve2 = { x: pt2.x.minus(pt1.x), y: pt2.y.minus(pt1.y) };
    const d1 = crossProduct(ve2, v1).div(kross);
    const d2 = crossProduct(ve2, v2).div(kross);
    const x12 = pt1.x.plus(d2.times(v1.x)), x2 = pt2.x.plus(d1.times(v2.x));
    const y12 = pt1.y.plus(d2.times(v1.y)), y2 = pt2.y.plus(d1.times(v2.y));
    const x3 = x12.plus(x2).div(2);
    const y3 = y12.plus(y2).div(2);
    return { x: x3, y: y3 };
  };

  // node_modules/polyclip-ts/dist/sweep-event.js
  var SweepEvent = class _SweepEvent {
    // Warning: 'point' input will be modified and re-used (for performance)
    constructor(point2, isLeft) {
      __publicField(this, "point");
      __publicField(this, "isLeft");
      __publicField(this, "segment");
      __publicField(this, "otherSE");
      __publicField(this, "consumedBy");
      if (point2.events === void 0)
        point2.events = [this];
      else
        point2.events.push(this);
      this.point = point2;
      this.isLeft = isLeft;
    }
    // for ordering sweep events in the sweep event queue
    static compare(a2, b2) {
      const ptCmp = _SweepEvent.comparePoints(a2.point, b2.point);
      if (ptCmp !== 0)
        return ptCmp;
      if (a2.point !== b2.point)
        a2.link(b2);
      if (a2.isLeft !== b2.isLeft)
        return a2.isLeft ? 1 : -1;
      return Segment.compare(a2.segment, b2.segment);
    }
    // for ordering points in sweep line order
    static comparePoints(aPt, bPt) {
      if (aPt.x.isLessThan(bPt.x))
        return -1;
      if (aPt.x.isGreaterThan(bPt.x))
        return 1;
      if (aPt.y.isLessThan(bPt.y))
        return -1;
      if (aPt.y.isGreaterThan(bPt.y))
        return 1;
      return 0;
    }
    link(other) {
      if (other.point === this.point) {
        throw new Error("Tried to link already linked events");
      }
      const otherEvents = other.point.events;
      for (let i3 = 0, iMax = otherEvents.length; i3 < iMax; i3++) {
        const evt = otherEvents[i3];
        this.point.events.push(evt);
        evt.point = this.point;
      }
      this.checkForConsuming();
    }
    /* Do a pass over our linked events and check to see if any pair
     * of segments match, and should be consumed. */
    checkForConsuming() {
      const numEvents = this.point.events.length;
      for (let i3 = 0; i3 < numEvents; i3++) {
        const evt1 = this.point.events[i3];
        if (evt1.segment.consumedBy !== void 0)
          continue;
        for (let j2 = i3 + 1; j2 < numEvents; j2++) {
          const evt2 = this.point.events[j2];
          if (evt2.consumedBy !== void 0)
            continue;
          if (evt1.otherSE.point.events !== evt2.otherSE.point.events)
            continue;
          evt1.segment.consume(evt2.segment);
        }
      }
    }
    getAvailableLinkedEvents() {
      const events = [];
      for (let i3 = 0, iMax = this.point.events.length; i3 < iMax; i3++) {
        const evt = this.point.events[i3];
        if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
          events.push(evt);
        }
      }
      return events;
    }
    /**
     * Returns a comparator function for sorting linked events that will
     * favor the event that will give us the smallest left-side angle.
     * All ring construction starts as low as possible heading to the right,
     * so by always turning left as sharp as possible we'll get polygons
     * without uncessary loops & holes.
     *
     * The comparator function has a compute cache such that it avoids
     * re-computing already-computed values.
     */
    getLeftmostComparator(baseEvent) {
      const cache = /* @__PURE__ */ new Map();
      const fillCache = (linkedEvent) => {
        const nextEvent = linkedEvent.otherSE;
        cache.set(linkedEvent, {
          sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),
          cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)
        });
      };
      return (a2, b2) => {
        if (!cache.has(a2))
          fillCache(a2);
        if (!cache.has(b2))
          fillCache(b2);
        const { sine: asine, cosine: acosine } = cache.get(a2);
        const { sine: bsine, cosine: bcosine } = cache.get(b2);
        if (asine.isGreaterThanOrEqualTo(0) && bsine.isGreaterThanOrEqualTo(0)) {
          if (acosine.isLessThan(bcosine))
            return 1;
          if (acosine.isGreaterThan(bcosine))
            return -1;
          return 0;
        }
        if (asine.isLessThan(0) && bsine.isLessThan(0)) {
          if (acosine.isLessThan(bcosine))
            return -1;
          if (acosine.isGreaterThan(bcosine))
            return 1;
          return 0;
        }
        if (bsine.isLessThan(asine))
          return -1;
        if (bsine.isGreaterThan(asine))
          return 1;
        return 0;
      };
    }
  };

  // node_modules/polyclip-ts/dist/segment.js
  var segmentId = 0;
  var Segment = class _Segment {
    /* Warning: a reference to ringWindings input will be stored,
     *  and possibly will be later modified */
    constructor(leftSE, rightSE, rings, windings) {
      __publicField(this, "id");
      __publicField(this, "leftSE");
      __publicField(this, "rightSE");
      __publicField(this, "rings");
      __publicField(this, "windings");
      __publicField(this, "ringOut");
      __publicField(this, "consumedBy");
      __publicField(this, "prev");
      __publicField(this, "_prevInResult");
      __publicField(this, "_beforeState");
      __publicField(this, "_afterState");
      __publicField(this, "_isInResult");
      this.id = ++segmentId;
      this.leftSE = leftSE;
      leftSE.segment = this;
      leftSE.otherSE = rightSE;
      this.rightSE = rightSE;
      rightSE.segment = this;
      rightSE.otherSE = leftSE;
      this.rings = rings;
      this.windings = windings;
    }
    /* This compare() function is for ordering segments in the sweep
     * line tree, and does so according to the following criteria:
     *
     * Consider the vertical line that lies an infinestimal step to the
     * right of the right-more of the two left endpoints of the input
     * segments. Imagine slowly moving a point up from negative infinity
     * in the increasing y direction. Which of the two segments will that
     * point intersect first? That segment comes 'before' the other one.
     *
     * If neither segment would be intersected by such a line, (if one
     * or more of the segments are vertical) then the line to be considered
     * is directly on the right-more of the two left inputs.
     */
    static compare(a2, b2) {
      const alx = a2.leftSE.point.x;
      const blx = b2.leftSE.point.x;
      const arx = a2.rightSE.point.x;
      const brx = b2.rightSE.point.x;
      if (brx.isLessThan(alx))
        return 1;
      if (arx.isLessThan(blx))
        return -1;
      const aly = a2.leftSE.point.y;
      const bly = b2.leftSE.point.y;
      const ary = a2.rightSE.point.y;
      const bry = b2.rightSE.point.y;
      if (alx.isLessThan(blx)) {
        if (bly.isLessThan(aly) && bly.isLessThan(ary))
          return 1;
        if (bly.isGreaterThan(aly) && bly.isGreaterThan(ary))
          return -1;
        const aCmpBLeft = a2.comparePoint(b2.leftSE.point);
        if (aCmpBLeft < 0)
          return 1;
        if (aCmpBLeft > 0)
          return -1;
        const bCmpARight = b2.comparePoint(a2.rightSE.point);
        if (bCmpARight !== 0)
          return bCmpARight;
        return -1;
      }
      if (alx.isGreaterThan(blx)) {
        if (aly.isLessThan(bly) && aly.isLessThan(bry))
          return -1;
        if (aly.isGreaterThan(bly) && aly.isGreaterThan(bry))
          return 1;
        const bCmpALeft = b2.comparePoint(a2.leftSE.point);
        if (bCmpALeft !== 0)
          return bCmpALeft;
        const aCmpBRight = a2.comparePoint(b2.rightSE.point);
        if (aCmpBRight < 0)
          return 1;
        if (aCmpBRight > 0)
          return -1;
        return 1;
      }
      if (aly.isLessThan(bly))
        return -1;
      if (aly.isGreaterThan(bly))
        return 1;
      if (arx.isLessThan(brx)) {
        const bCmpARight = b2.comparePoint(a2.rightSE.point);
        if (bCmpARight !== 0)
          return bCmpARight;
      }
      if (arx.isGreaterThan(brx)) {
        const aCmpBRight = a2.comparePoint(b2.rightSE.point);
        if (aCmpBRight < 0)
          return 1;
        if (aCmpBRight > 0)
          return -1;
      }
      if (!arx.eq(brx)) {
        const ay = ary.minus(aly);
        const ax = arx.minus(alx);
        const by = bry.minus(bly);
        const bx = brx.minus(blx);
        if (ay.isGreaterThan(ax) && by.isLessThan(bx))
          return 1;
        if (ay.isLessThan(ax) && by.isGreaterThan(bx))
          return -1;
      }
      if (arx.isGreaterThan(brx))
        return 1;
      if (arx.isLessThan(brx))
        return -1;
      if (ary.isLessThan(bry))
        return -1;
      if (ary.isGreaterThan(bry))
        return 1;
      if (a2.id < b2.id)
        return -1;
      if (a2.id > b2.id)
        return 1;
      return 0;
    }
    static fromRing(pt1, pt2, ring) {
      let leftPt, rightPt, winding;
      const cmpPts = SweepEvent.comparePoints(pt1, pt2);
      if (cmpPts < 0) {
        leftPt = pt1;
        rightPt = pt2;
        winding = 1;
      } else if (cmpPts > 0) {
        leftPt = pt2;
        rightPt = pt1;
        winding = -1;
      } else
        throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));
      const leftSE = new SweepEvent(leftPt, true);
      const rightSE = new SweepEvent(rightPt, false);
      return new _Segment(leftSE, rightSE, [ring], [winding]);
    }
    /* When a segment is split, the rightSE is replaced with a new sweep event */
    replaceRightSE(newRightSE) {
      this.rightSE = newRightSE;
      this.rightSE.segment = this;
      this.rightSE.otherSE = this.leftSE;
      this.leftSE.otherSE = this.rightSE;
    }
    bbox() {
      const y12 = this.leftSE.point.y;
      const y2 = this.rightSE.point.y;
      return {
        ll: { x: this.leftSE.point.x, y: y12.isLessThan(y2) ? y12 : y2 },
        ur: { x: this.rightSE.point.x, y: y12.isGreaterThan(y2) ? y12 : y2 }
      };
    }
    /* A vector from the left point to the right */
    vector() {
      return {
        x: this.rightSE.point.x.minus(this.leftSE.point.x),
        y: this.rightSE.point.y.minus(this.leftSE.point.y)
      };
    }
    isAnEndpoint(pt2) {
      return pt2.x.eq(this.leftSE.point.x) && pt2.y.eq(this.leftSE.point.y) || pt2.x.eq(this.rightSE.point.x) && pt2.y.eq(this.rightSE.point.y);
    }
    /* Compare this segment with a point.
     *
     * A point P is considered to be colinear to a segment if there
     * exists a distance D such that if we travel along the segment
     * from one * endpoint towards the other a distance D, we find
     * ourselves at point P.
     *
     * Return value indicates:
     *
     *   1: point lies above the segment (to the left of vertical)
     *   0: point is colinear to segment
     *  -1: point lies below the segment (to the right of vertical)
     */
    comparePoint(point2) {
      return precision.orient(this.leftSE.point, point2, this.rightSE.point);
    }
    /**
     * Given another segment, returns the first non-trivial intersection
     * between the two segments (in terms of sweep line ordering), if it exists.
     *
     * A 'non-trivial' intersection is one that will cause one or both of the
     * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
     *
     *   * endpoint of segA with endpoint of segB --> trivial
     *   * endpoint of segA with point along segB --> non-trivial
     *   * endpoint of segB with point along segA --> non-trivial
     *   * point along segA with point along segB --> non-trivial
     *
     * If no non-trivial intersection exists, return null
     * Else, return null.
     */
    getIntersection(other) {
      const tBbox = this.bbox();
      const oBbox = other.bbox();
      const bboxOverlap = getBboxOverlap(tBbox, oBbox);
      if (bboxOverlap === null)
        return null;
      const tlp = this.leftSE.point;
      const trp = this.rightSE.point;
      const olp = other.leftSE.point;
      const orp = other.rightSE.point;
      const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
      const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
      const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
      const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
      if (touchesThisLSE && touchesOtherLSE) {
        if (touchesThisRSE && !touchesOtherRSE)
          return trp;
        if (!touchesThisRSE && touchesOtherRSE)
          return orp;
        return null;
      }
      if (touchesThisLSE) {
        if (touchesOtherRSE) {
          if (tlp.x.eq(orp.x) && tlp.y.eq(orp.y))
            return null;
        }
        return tlp;
      }
      if (touchesOtherLSE) {
        if (touchesThisRSE) {
          if (trp.x.eq(olp.x) && trp.y.eq(olp.y))
            return null;
        }
        return olp;
      }
      if (touchesThisRSE && touchesOtherRSE)
        return null;
      if (touchesThisRSE)
        return trp;
      if (touchesOtherRSE)
        return orp;
      const pt2 = intersection(tlp, this.vector(), olp, other.vector());
      if (pt2 === null)
        return null;
      if (!isInBbox(bboxOverlap, pt2))
        return null;
      return precision.snap(pt2);
    }
    /**
     * Split the given segment into multiple segments on the given points.
     *  * Each existing segment will retain its leftSE and a new rightSE will be
     *    generated for it.
     *  * A new segment will be generated which will adopt the original segment's
     *    rightSE, and a new leftSE will be generated for it.
     *  * If there are more than two points given to split on, new segments
     *    in the middle will be generated with new leftSE and rightSE's.
     *  * An array of the newly generated SweepEvents will be returned.
     *
     * Warning: input array of points is modified
     */
    split(point2) {
      const newEvents = [];
      const alreadyLinked = point2.events !== void 0;
      const newLeftSE = new SweepEvent(point2, true);
      const newRightSE = new SweepEvent(point2, false);
      const oldRightSE = this.rightSE;
      this.replaceRightSE(newRightSE);
      newEvents.push(newRightSE);
      newEvents.push(newLeftSE);
      const newSeg = new _Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
      if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
        newSeg.swapEvents();
      }
      if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
        this.swapEvents();
      }
      if (alreadyLinked) {
        newLeftSE.checkForConsuming();
        newRightSE.checkForConsuming();
      }
      return newEvents;
    }
    /* Swap which event is left and right */
    swapEvents() {
      const tmpEvt = this.rightSE;
      this.rightSE = this.leftSE;
      this.leftSE = tmpEvt;
      this.leftSE.isLeft = true;
      this.rightSE.isLeft = false;
      for (let i3 = 0, iMax = this.windings.length; i3 < iMax; i3++) {
        this.windings[i3] *= -1;
      }
    }
    /* Consume another segment. We take their rings under our wing
     * and mark them as consumed. Use for perfectly overlapping segments */
    consume(other) {
      let consumer = this;
      let consumee = other;
      while (consumer.consumedBy)
        consumer = consumer.consumedBy;
      while (consumee.consumedBy)
        consumee = consumee.consumedBy;
      const cmp = _Segment.compare(consumer, consumee);
      if (cmp === 0)
        return;
      if (cmp > 0) {
        const tmp = consumer;
        consumer = consumee;
        consumee = tmp;
      }
      if (consumer.prev === consumee) {
        const tmp = consumer;
        consumer = consumee;
        consumee = tmp;
      }
      for (let i3 = 0, iMax = consumee.rings.length; i3 < iMax; i3++) {
        const ring = consumee.rings[i3];
        const winding = consumee.windings[i3];
        const index = consumer.rings.indexOf(ring);
        if (index === -1) {
          consumer.rings.push(ring);
          consumer.windings.push(winding);
        } else
          consumer.windings[index] += winding;
      }
      consumee.rings = null;
      consumee.windings = null;
      consumee.consumedBy = consumer;
      consumee.leftSE.consumedBy = consumer.leftSE;
      consumee.rightSE.consumedBy = consumer.rightSE;
    }
    /* The first segment previous segment chain that is in the result */
    prevInResult() {
      if (this._prevInResult !== void 0)
        return this._prevInResult;
      if (!this.prev)
        this._prevInResult = null;
      else if (this.prev.isInResult())
        this._prevInResult = this.prev;
      else
        this._prevInResult = this.prev.prevInResult();
      return this._prevInResult;
    }
    beforeState() {
      if (this._beforeState !== void 0)
        return this._beforeState;
      if (!this.prev)
        this._beforeState = {
          rings: [],
          windings: [],
          multiPolys: []
        };
      else {
        const seg = this.prev.consumedBy || this.prev;
        this._beforeState = seg.afterState();
      }
      return this._beforeState;
    }
    afterState() {
      if (this._afterState !== void 0)
        return this._afterState;
      const beforeState = this.beforeState();
      this._afterState = {
        rings: beforeState.rings.slice(0),
        windings: beforeState.windings.slice(0),
        multiPolys: []
      };
      const ringsAfter = this._afterState.rings;
      const windingsAfter = this._afterState.windings;
      const mpsAfter = this._afterState.multiPolys;
      for (let i3 = 0, iMax = this.rings.length; i3 < iMax; i3++) {
        const ring = this.rings[i3];
        const winding = this.windings[i3];
        const index = ringsAfter.indexOf(ring);
        if (index === -1) {
          ringsAfter.push(ring);
          windingsAfter.push(winding);
        } else
          windingsAfter[index] += winding;
      }
      const polysAfter = [];
      const polysExclude = [];
      for (let i3 = 0, iMax = ringsAfter.length; i3 < iMax; i3++) {
        if (windingsAfter[i3] === 0)
          continue;
        const ring = ringsAfter[i3];
        const poly = ring.poly;
        if (polysExclude.indexOf(poly) !== -1)
          continue;
        if (ring.isExterior)
          polysAfter.push(poly);
        else {
          if (polysExclude.indexOf(poly) === -1)
            polysExclude.push(poly);
          const index = polysAfter.indexOf(ring.poly);
          if (index !== -1)
            polysAfter.splice(index, 1);
        }
      }
      for (let i3 = 0, iMax = polysAfter.length; i3 < iMax; i3++) {
        const mp = polysAfter[i3].multiPoly;
        if (mpsAfter.indexOf(mp) === -1)
          mpsAfter.push(mp);
      }
      return this._afterState;
    }
    /* Is this segment part of the final result? */
    isInResult() {
      if (this.consumedBy)
        return false;
      if (this._isInResult !== void 0)
        return this._isInResult;
      const mpsBefore = this.beforeState().multiPolys;
      const mpsAfter = this.afterState().multiPolys;
      switch (operation_default.type) {
        case "union": {
          const noBefores = mpsBefore.length === 0;
          const noAfters = mpsAfter.length === 0;
          this._isInResult = noBefores !== noAfters;
          break;
        }
        case "intersection": {
          let least;
          let most;
          if (mpsBefore.length < mpsAfter.length) {
            least = mpsBefore.length;
            most = mpsAfter.length;
          } else {
            least = mpsAfter.length;
            most = mpsBefore.length;
          }
          this._isInResult = most === operation_default.numMultiPolys && least < most;
          break;
        }
        case "xor": {
          const diff = Math.abs(mpsBefore.length - mpsAfter.length);
          this._isInResult = diff % 2 === 1;
          break;
        }
        case "difference": {
          const isJustSubject = (mps) => mps.length === 1 && mps[0].isSubject;
          this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
          break;
        }
      }
      return this._isInResult;
    }
  };

  // node_modules/polyclip-ts/dist/geom-in.js
  var RingIn = class {
    constructor(geomRing, poly, isExterior) {
      __publicField(this, "poly");
      __publicField(this, "isExterior");
      __publicField(this, "segments");
      __publicField(this, "bbox");
      if (!Array.isArray(geomRing) || geomRing.length === 0) {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      this.poly = poly;
      this.isExterior = isExterior;
      this.segments = [];
      if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      const firstPoint = precision.snap({ x: new bignumber_default(geomRing[0][0]), y: new bignumber_default(geomRing[0][1]) });
      this.bbox = {
        ll: { x: firstPoint.x, y: firstPoint.y },
        ur: { x: firstPoint.x, y: firstPoint.y }
      };
      let prevPoint = firstPoint;
      for (let i3 = 1, iMax = geomRing.length; i3 < iMax; i3++) {
        if (typeof geomRing[i3][0] !== "number" || typeof geomRing[i3][1] !== "number") {
          throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        const point2 = precision.snap({ x: new bignumber_default(geomRing[i3][0]), y: new bignumber_default(geomRing[i3][1]) });
        if (point2.x.eq(prevPoint.x) && point2.y.eq(prevPoint.y))
          continue;
        this.segments.push(Segment.fromRing(prevPoint, point2, this));
        if (point2.x.isLessThan(this.bbox.ll.x))
          this.bbox.ll.x = point2.x;
        if (point2.y.isLessThan(this.bbox.ll.y))
          this.bbox.ll.y = point2.y;
        if (point2.x.isGreaterThan(this.bbox.ur.x))
          this.bbox.ur.x = point2.x;
        if (point2.y.isGreaterThan(this.bbox.ur.y))
          this.bbox.ur.y = point2.y;
        prevPoint = point2;
      }
      if (!firstPoint.x.eq(prevPoint.x) || !firstPoint.y.eq(prevPoint.y)) {
        this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
      }
    }
    getSweepEvents() {
      const sweepEvents = [];
      for (let i3 = 0, iMax = this.segments.length; i3 < iMax; i3++) {
        const segment = this.segments[i3];
        sweepEvents.push(segment.leftSE);
        sweepEvents.push(segment.rightSE);
      }
      return sweepEvents;
    }
  };
  var PolyIn = class {
    constructor(geomPoly, multiPoly) {
      __publicField(this, "multiPoly");
      __publicField(this, "exteriorRing");
      __publicField(this, "interiorRings");
      __publicField(this, "bbox");
      if (!Array.isArray(geomPoly)) {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      this.exteriorRing = new RingIn(geomPoly[0], this, true);
      this.bbox = {
        ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },
        ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y }
      };
      this.interiorRings = [];
      for (let i3 = 1, iMax = geomPoly.length; i3 < iMax; i3++) {
        const ring = new RingIn(geomPoly[i3], this, false);
        if (ring.bbox.ll.x.isLessThan(this.bbox.ll.x))
          this.bbox.ll.x = ring.bbox.ll.x;
        if (ring.bbox.ll.y.isLessThan(this.bbox.ll.y))
          this.bbox.ll.y = ring.bbox.ll.y;
        if (ring.bbox.ur.x.isGreaterThan(this.bbox.ur.x))
          this.bbox.ur.x = ring.bbox.ur.x;
        if (ring.bbox.ur.y.isGreaterThan(this.bbox.ur.y))
          this.bbox.ur.y = ring.bbox.ur.y;
        this.interiorRings.push(ring);
      }
      this.multiPoly = multiPoly;
    }
    getSweepEvents() {
      const sweepEvents = this.exteriorRing.getSweepEvents();
      for (let i3 = 0, iMax = this.interiorRings.length; i3 < iMax; i3++) {
        const ringSweepEvents = this.interiorRings[i3].getSweepEvents();
        for (let j2 = 0, jMax = ringSweepEvents.length; j2 < jMax; j2++) {
          sweepEvents.push(ringSweepEvents[j2]);
        }
      }
      return sweepEvents;
    }
  };
  var MultiPolyIn = class {
    constructor(geom, isSubject) {
      __publicField(this, "isSubject");
      __publicField(this, "polys");
      __publicField(this, "bbox");
      if (!Array.isArray(geom)) {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      try {
        if (typeof geom[0][0][0] === "number")
          geom = [geom];
      } catch (ex) {
      }
      this.polys = [];
      this.bbox = {
        ll: { x: new bignumber_default(Number.POSITIVE_INFINITY), y: new bignumber_default(Number.POSITIVE_INFINITY) },
        ur: { x: new bignumber_default(Number.NEGATIVE_INFINITY), y: new bignumber_default(Number.NEGATIVE_INFINITY) }
      };
      for (let i3 = 0, iMax = geom.length; i3 < iMax; i3++) {
        const poly = new PolyIn(geom[i3], this);
        if (poly.bbox.ll.x.isLessThan(this.bbox.ll.x))
          this.bbox.ll.x = poly.bbox.ll.x;
        if (poly.bbox.ll.y.isLessThan(this.bbox.ll.y))
          this.bbox.ll.y = poly.bbox.ll.y;
        if (poly.bbox.ur.x.isGreaterThan(this.bbox.ur.x))
          this.bbox.ur.x = poly.bbox.ur.x;
        if (poly.bbox.ur.y.isGreaterThan(this.bbox.ur.y))
          this.bbox.ur.y = poly.bbox.ur.y;
        this.polys.push(poly);
      }
      this.isSubject = isSubject;
    }
    getSweepEvents() {
      const sweepEvents = [];
      for (let i3 = 0, iMax = this.polys.length; i3 < iMax; i3++) {
        const polySweepEvents = this.polys[i3].getSweepEvents();
        for (let j2 = 0, jMax = polySweepEvents.length; j2 < jMax; j2++) {
          sweepEvents.push(polySweepEvents[j2]);
        }
      }
      return sweepEvents;
    }
  };

  // node_modules/polyclip-ts/dist/geom-out.js
  var RingOut = class _RingOut {
    constructor(events) {
      __publicField(this, "events");
      __publicField(this, "poly");
      __publicField(this, "_isExteriorRing");
      __publicField(this, "_enclosingRing");
      this.events = events;
      for (let i3 = 0, iMax = events.length; i3 < iMax; i3++) {
        events[i3].segment.ringOut = this;
      }
      this.poly = null;
    }
    /* Given the segments from the sweep line pass, compute & return a series
     * of closed rings from all the segments marked to be part of the result */
    static factory(allSegments) {
      const ringsOut = [];
      for (let i3 = 0, iMax = allSegments.length; i3 < iMax; i3++) {
        const segment = allSegments[i3];
        if (!segment.isInResult() || segment.ringOut)
          continue;
        let prevEvent = null;
        let event = segment.leftSE;
        let nextEvent = segment.rightSE;
        const events = [event];
        const startingPoint = event.point;
        const intersectionLEs = [];
        while (true) {
          prevEvent = event;
          event = nextEvent;
          events.push(event);
          if (event.point === startingPoint)
            break;
          while (true) {
            const availableLEs = event.getAvailableLinkedEvents();
            if (availableLEs.length === 0) {
              const firstPt = events[0].point;
              const lastPt = events[events.length - 1].point;
              throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
            }
            if (availableLEs.length === 1) {
              nextEvent = availableLEs[0].otherSE;
              break;
            }
            let indexLE = null;
            for (let j2 = 0, jMax = intersectionLEs.length; j2 < jMax; j2++) {
              if (intersectionLEs[j2].point === event.point) {
                indexLE = j2;
                break;
              }
            }
            if (indexLE !== null) {
              const intersectionLE = intersectionLEs.splice(indexLE)[0];
              const ringEvents = events.splice(intersectionLE.index);
              ringEvents.unshift(ringEvents[0].otherSE);
              ringsOut.push(new _RingOut(ringEvents.reverse()));
              continue;
            }
            intersectionLEs.push({
              index: events.length,
              point: event.point
            });
            const comparator = event.getLeftmostComparator(prevEvent);
            nextEvent = availableLEs.sort(comparator)[0].otherSE;
            break;
          }
        }
        ringsOut.push(new _RingOut(events));
      }
      return ringsOut;
    }
    getGeom() {
      let prevPt = this.events[0].point;
      const points = [prevPt];
      for (let i3 = 1, iMax = this.events.length - 1; i3 < iMax; i3++) {
        const pt3 = this.events[i3].point;
        const nextPt2 = this.events[i3 + 1].point;
        if (precision.orient(pt3, prevPt, nextPt2) === 0)
          continue;
        points.push(pt3);
        prevPt = pt3;
      }
      if (points.length === 1)
        return null;
      const pt2 = points[0];
      const nextPt = points[1];
      if (precision.orient(pt2, prevPt, nextPt) === 0)
        points.shift();
      points.push(points[0]);
      const step = this.isExteriorRing() ? 1 : -1;
      const iStart = this.isExteriorRing() ? 0 : points.length - 1;
      const iEnd = this.isExteriorRing() ? points.length : -1;
      const orderedPoints = [];
      for (let i3 = iStart; i3 != iEnd; i3 += step)
        orderedPoints.push([points[i3].x.toNumber(), points[i3].y.toNumber()]);
      return orderedPoints;
    }
    isExteriorRing() {
      if (this._isExteriorRing === void 0) {
        const enclosing = this.enclosingRing();
        this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
      }
      return this._isExteriorRing;
    }
    enclosingRing() {
      if (this._enclosingRing === void 0) {
        this._enclosingRing = this._calcEnclosingRing();
      }
      return this._enclosingRing;
    }
    /* Returns the ring that encloses this one, if any */
    _calcEnclosingRing() {
      var _a2, _b;
      let leftMostEvt = this.events[0];
      for (let i3 = 1, iMax = this.events.length; i3 < iMax; i3++) {
        const evt = this.events[i3];
        if (SweepEvent.compare(leftMostEvt, evt) > 0)
          leftMostEvt = evt;
      }
      let prevSeg = leftMostEvt.segment.prevInResult();
      let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
      while (true) {
        if (!prevSeg)
          return null;
        if (!prevPrevSeg)
          return prevSeg.ringOut;
        if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
          if (((_a2 = prevPrevSeg.ringOut) == null ? void 0 : _a2.enclosingRing()) !== prevSeg.ringOut) {
            return prevSeg.ringOut;
          } else
            return (_b = prevSeg.ringOut) == null ? void 0 : _b.enclosingRing();
        }
        prevSeg = prevPrevSeg.prevInResult();
        prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
      }
    }
  };
  var PolyOut = class {
    constructor(exteriorRing) {
      __publicField(this, "exteriorRing");
      __publicField(this, "interiorRings");
      this.exteriorRing = exteriorRing;
      exteriorRing.poly = this;
      this.interiorRings = [];
    }
    addInterior(ring) {
      this.interiorRings.push(ring);
      ring.poly = this;
    }
    getGeom() {
      const geom = [this.exteriorRing.getGeom()];
      if (geom[0] === null)
        return null;
      for (let i3 = 0, iMax = this.interiorRings.length; i3 < iMax; i3++) {
        const ringGeom = this.interiorRings[i3].getGeom();
        if (ringGeom === null)
          continue;
        geom.push(ringGeom);
      }
      return geom;
    }
  };
  var MultiPolyOut = class {
    constructor(rings) {
      __publicField(this, "rings");
      __publicField(this, "polys");
      this.rings = rings;
      this.polys = this._composePolys(rings);
    }
    getGeom() {
      const geom = [];
      for (let i3 = 0, iMax = this.polys.length; i3 < iMax; i3++) {
        const polyGeom = this.polys[i3].getGeom();
        if (polyGeom === null)
          continue;
        geom.push(polyGeom);
      }
      return geom;
    }
    _composePolys(rings) {
      var _a2;
      const polys = [];
      for (let i3 = 0, iMax = rings.length; i3 < iMax; i3++) {
        const ring = rings[i3];
        if (ring.poly)
          continue;
        if (ring.isExteriorRing())
          polys.push(new PolyOut(ring));
        else {
          const enclosingRing = ring.enclosingRing();
          if (!(enclosingRing == null ? void 0 : enclosingRing.poly))
            polys.push(new PolyOut(enclosingRing));
          (_a2 = enclosingRing == null ? void 0 : enclosingRing.poly) == null ? void 0 : _a2.addInterior(ring);
        }
      }
      return polys;
    }
  };

  // node_modules/polyclip-ts/dist/sweep-line.js
  var SweepLine = class {
    constructor(queue, comparator = Segment.compare) {
      __publicField(this, "queue");
      __publicField(this, "tree");
      __publicField(this, "segments");
      this.queue = queue;
      this.tree = new SplayTreeSet(comparator);
      this.segments = [];
    }
    process(event) {
      const segment = event.segment;
      const newEvents = [];
      if (event.consumedBy) {
        if (event.isLeft)
          this.queue.delete(event.otherSE);
        else
          this.tree.delete(segment);
        return newEvents;
      }
      if (event.isLeft)
        this.tree.add(segment);
      let prevSeg = segment;
      let nextSeg = segment;
      do {
        prevSeg = this.tree.lastBefore(prevSeg);
      } while (prevSeg != null && prevSeg.consumedBy != void 0);
      do {
        nextSeg = this.tree.firstAfter(nextSeg);
      } while (nextSeg != null && nextSeg.consumedBy != void 0);
      if (event.isLeft) {
        let prevMySplitter = null;
        if (prevSeg) {
          const prevInter = prevSeg.getIntersection(segment);
          if (prevInter !== null) {
            if (!segment.isAnEndpoint(prevInter))
              prevMySplitter = prevInter;
            if (!prevSeg.isAnEndpoint(prevInter)) {
              const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
              for (let i3 = 0, iMax = newEventsFromSplit.length; i3 < iMax; i3++) {
                newEvents.push(newEventsFromSplit[i3]);
              }
            }
          }
        }
        let nextMySplitter = null;
        if (nextSeg) {
          const nextInter = nextSeg.getIntersection(segment);
          if (nextInter !== null) {
            if (!segment.isAnEndpoint(nextInter))
              nextMySplitter = nextInter;
            if (!nextSeg.isAnEndpoint(nextInter)) {
              const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
              for (let i3 = 0, iMax = newEventsFromSplit.length; i3 < iMax; i3++) {
                newEvents.push(newEventsFromSplit[i3]);
              }
            }
          }
        }
        if (prevMySplitter !== null || nextMySplitter !== null) {
          let mySplitter = null;
          if (prevMySplitter === null)
            mySplitter = nextMySplitter;
          else if (nextMySplitter === null)
            mySplitter = prevMySplitter;
          else {
            const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
            mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
          }
          this.queue.delete(segment.rightSE);
          newEvents.push(segment.rightSE);
          const newEventsFromSplit = segment.split(mySplitter);
          for (let i3 = 0, iMax = newEventsFromSplit.length; i3 < iMax; i3++) {
            newEvents.push(newEventsFromSplit[i3]);
          }
        }
        if (newEvents.length > 0) {
          this.tree.delete(segment);
          newEvents.push(event);
        } else {
          this.segments.push(segment);
          segment.prev = prevSeg;
        }
      } else {
        if (prevSeg && nextSeg) {
          const inter = prevSeg.getIntersection(nextSeg);
          if (inter !== null) {
            if (!prevSeg.isAnEndpoint(inter)) {
              const newEventsFromSplit = this._splitSafely(prevSeg, inter);
              for (let i3 = 0, iMax = newEventsFromSplit.length; i3 < iMax; i3++) {
                newEvents.push(newEventsFromSplit[i3]);
              }
            }
            if (!nextSeg.isAnEndpoint(inter)) {
              const newEventsFromSplit = this._splitSafely(nextSeg, inter);
              for (let i3 = 0, iMax = newEventsFromSplit.length; i3 < iMax; i3++) {
                newEvents.push(newEventsFromSplit[i3]);
              }
            }
          }
        }
        this.tree.delete(segment);
      }
      return newEvents;
    }
    /* Safely split a segment that is currently in the datastructures
     * IE - a segment other than the one that is currently being processed. */
    _splitSafely(seg, pt2) {
      this.tree.delete(seg);
      const rightSE = seg.rightSE;
      this.queue.delete(rightSE);
      const newEvents = seg.split(pt2);
      newEvents.push(rightSE);
      if (seg.consumedBy === void 0)
        this.tree.add(seg);
      return newEvents;
    }
  };

  // node_modules/polyclip-ts/dist/operation.js
  var Operation = class {
    constructor() {
      __publicField(this, "type");
      __publicField(this, "numMultiPolys");
    }
    run(type2, geom, moreGeoms) {
      operation.type = type2;
      const multipolys = [new MultiPolyIn(geom, true)];
      for (let i3 = 0, iMax = moreGeoms.length; i3 < iMax; i3++) {
        multipolys.push(new MultiPolyIn(moreGeoms[i3], false));
      }
      operation.numMultiPolys = multipolys.length;
      if (operation.type === "difference") {
        const subject = multipolys[0];
        let i3 = 1;
        while (i3 < multipolys.length) {
          if (getBboxOverlap(multipolys[i3].bbox, subject.bbox) !== null)
            i3++;
          else
            multipolys.splice(i3, 1);
        }
      }
      if (operation.type === "intersection") {
        for (let i3 = 0, iMax = multipolys.length; i3 < iMax; i3++) {
          const mpA = multipolys[i3];
          for (let j2 = i3 + 1, jMax = multipolys.length; j2 < jMax; j2++) {
            if (getBboxOverlap(mpA.bbox, multipolys[j2].bbox) === null)
              return [];
          }
        }
      }
      const queue = new SplayTreeSet(SweepEvent.compare);
      for (let i3 = 0, iMax = multipolys.length; i3 < iMax; i3++) {
        const sweepEvents = multipolys[i3].getSweepEvents();
        for (let j2 = 0, jMax = sweepEvents.length; j2 < jMax; j2++) {
          queue.add(sweepEvents[j2]);
        }
      }
      const sweepLine = new SweepLine(queue);
      let evt = null;
      if (queue.size != 0) {
        evt = queue.first();
        queue.delete(evt);
      }
      while (evt) {
        const newEvents = sweepLine.process(evt);
        for (let i3 = 0, iMax = newEvents.length; i3 < iMax; i3++) {
          const evt2 = newEvents[i3];
          if (evt2.consumedBy === void 0)
            queue.add(evt2);
        }
        if (queue.size != 0) {
          evt = queue.first();
          queue.delete(evt);
        } else {
          evt = null;
        }
      }
      precision.reset();
      const ringsOut = RingOut.factory(sweepLine.segments);
      const result = new MultiPolyOut(ringsOut);
      return result.getGeom();
    }
  };
  var operation = new Operation();
  var operation_default = operation;

  // node_modules/polyclip-ts/dist/index.js
  var union = (geom, ...moreGeoms) => operation_default.run("union", geom, moreGeoms);
  var difference = (geom, ...moreGeoms) => operation_default.run("difference", geom, moreGeoms);
  var setPrecision = precision.set;

  // node_modules/@rapideditor/location-conflation/index.mjs
  var import_geojson_area = __toESM(require_geojson_area(), 1);
  var import_circle_to_polygon = __toESM(require_circle_to_polygon(), 1);
  var import_geojson_precision = __toESM(require_geojson_precision(), 1);
  var import_json_stringify_pretty_compact = __toESM(require_json_stringify_pretty_compact(), 1);
  var LocationConflation = class {
    // constructor
    //
    // `fc`  Optional FeatureCollection of known features
    //
    // Optionally pass a GeoJSON FeatureCollection of known features which we can refer to later.
    // Each feature must have a filename-like `id`, for example: `something.geojson`
    //
    // {
    //   "type": "FeatureCollection"
    //   "features": [
    //     {
    //       "type": "Feature",
    //       "id": "philly_metro.geojson",
    //       "properties": { … },
    //       "geometry": { … }
    //     }
    //   ]
    // }
    constructor(fc) {
      this._cache = {};
      this.strict = true;
      if (fc && fc.type === "FeatureCollection" && Array.isArray(fc.features)) {
        fc.features.forEach((feature3) => {
          feature3.properties = feature3.properties || {};
          let props = feature3.properties;
          let id2 = feature3.id || props.id;
          if (!id2 || !/^\S+\.geojson$/i.test(id2))
            return;
          id2 = id2.toLowerCase();
          feature3.id = id2;
          props.id = id2;
          if (!props.area) {
            const area = import_geojson_area.default.geometry(feature3.geometry) / 1e6;
            props.area = Number(area.toFixed(2));
          }
          this._cache[id2] = feature3;
        });
      }
      let world = _cloneDeep(feature("Q2"));
      world.geometry = {
        type: "Polygon",
        coordinates: [[[-180, -90], [180, -90], [180, 90], [-180, 90], [-180, -90]]]
      };
      world.id = "Q2";
      world.properties.id = "Q2";
      world.properties.area = import_geojson_area.default.geometry(world.geometry) / 1e6;
      this._cache.Q2 = world;
    }
    // validateLocation
    // `location`  The location to validate
    //
    // Pass a `location` value to validate
    //
    // Returns a result like:
    //   {
    //     type:     'point', 'geojson', or 'countrycoder'
    //     location:  the queried location
    //     id:        the stable identifier for the feature
    //   }
    // or `null` if the location is invalid
    //
    validateLocation(location) {
      if (Array.isArray(location) && (location.length === 2 || location.length === 3)) {
        const lon = location[0];
        const lat = location[1];
        const radius = location[2];
        if (Number.isFinite(lon) && lon >= -180 && lon <= 180 && Number.isFinite(lat) && lat >= -90 && lat <= 90 && (location.length === 2 || Number.isFinite(radius) && radius > 0)) {
          const id2 = "[" + location.toString() + "]";
          return { type: "point", location, id: id2 };
        }
      } else if (typeof location === "string" && /^\S+\.geojson$/i.test(location)) {
        const id2 = location.toLowerCase();
        if (this._cache[id2]) {
          return { type: "geojson", location, id: id2 };
        }
      } else if (typeof location === "string" || typeof location === "number") {
        const feature3 = feature(location);
        if (feature3) {
          const id2 = feature3.properties.wikidata;
          return { type: "countrycoder", location, id: id2 };
        }
      }
      if (this.strict) {
        throw new Error('validateLocation:  Invalid location: "'.concat(location, '".'));
      } else {
        return null;
      }
    }
    // resolveLocation
    // `location`  The location to resolve
    //
    // Pass a `location` value to resolve
    //
    // Returns a result like:
    //   {
    //     type:      'point', 'geojson', or 'countrycoder'
    //     location:  the queried location
    //     id:        a stable identifier for the feature
    //     feature:   the resolved GeoJSON feature
    //   }
    //  or `null` if the location is invalid
    //
    resolveLocation(location) {
      const valid = this.validateLocation(location);
      if (!valid)
        return null;
      const id2 = valid.id;
      if (this._cache[id2]) {
        return Object.assign(valid, { feature: this._cache[id2] });
      }
      if (valid.type === "point") {
        const lon = location[0];
        const lat = location[1];
        const radius = location[2] || 25;
        const EDGES = 10;
        const PRECISION = 3;
        const area = Math.PI * radius * radius;
        const feature3 = this._cache[id2] = (0, import_geojson_precision.default)({
          type: "Feature",
          id: id2,
          properties: { id: id2, area: Number(area.toFixed(2)) },
          geometry: (0, import_circle_to_polygon.default)([lon, lat], radius * 1e3, EDGES)
          // km to m
        }, PRECISION);
        return Object.assign(valid, { feature: feature3 });
      } else if (valid.type === "geojson") {
      } else if (valid.type === "countrycoder") {
        let feature3 = _cloneDeep(feature(id2));
        let props = feature3.properties;
        if (Array.isArray(props.members)) {
          let aggregate = aggregateFeature(id2);
          aggregate.geometry.coordinates = _clip([aggregate], "UNION").geometry.coordinates;
          feature3.geometry = aggregate.geometry;
        }
        if (!props.area) {
          const area = import_geojson_area.default.geometry(feature3.geometry) / 1e6;
          props.area = Number(area.toFixed(2));
        }
        feature3.id = id2;
        props.id = id2;
        this._cache[id2] = feature3;
        return Object.assign(valid, { feature: feature3 });
      }
      if (this.strict) {
        throw new Error("resolveLocation:  Couldn't resolve location \"".concat(location, '".'));
      } else {
        return null;
      }
    }
    // validateLocationSet
    // `locationSet`  the locationSet to validate
    //
    // Pass a locationSet Object to validate like:
    //   {
    //     include: [ Array of locations ],
    //     exclude: [ Array of locations ]
    //   }
    //
    // Returns a result like:
    //   {
    //     type:         'locationset'
    //     locationSet:  the queried locationSet
    //     id:           the stable identifier for the feature
    //   }
    // or `null` if the locationSet is invalid
    //
    validateLocationSet(locationSet) {
      locationSet = locationSet || {};
      const validator = this.validateLocation.bind(this);
      let include = (locationSet.include || []).map(validator).filter(Boolean);
      let exclude = (locationSet.exclude || []).map(validator).filter(Boolean);
      if (!include.length) {
        if (this.strict) {
          throw new Error("validateLocationSet:  LocationSet includes nothing.");
        } else {
          locationSet.include = ["Q2"];
          include = [{ type: "countrycoder", location: "Q2", id: "Q2" }];
        }
      }
      include.sort(_sortLocations);
      let id2 = "+[" + include.map((d2) => d2.id).join(",") + "]";
      if (exclude.length) {
        exclude.sort(_sortLocations);
        id2 += "-[" + exclude.map((d2) => d2.id).join(",") + "]";
      }
      return { type: "locationset", locationSet, id: id2 };
    }
    // resolveLocationSet
    // `locationSet`  the locationSet to resolve
    //
    // Pass a locationSet Object to validate like:
    //   {
    //     include: [ Array of locations ],
    //     exclude: [ Array of locations ]
    //   }
    //
    // Returns a result like:
    //   {
    //     type:         'locationset'
    //     locationSet:  the queried locationSet
    //     id:           the stable identifier for the feature
    //     feature:      the resolved GeoJSON feature
    //   }
    // or `null` if the locationSet is invalid
    //
    resolveLocationSet(locationSet) {
      locationSet = locationSet || {};
      const valid = this.validateLocationSet(locationSet);
      if (!valid)
        return null;
      const id2 = valid.id;
      if (this._cache[id2]) {
        return Object.assign(valid, { feature: this._cache[id2] });
      }
      const resolver = this.resolveLocation.bind(this);
      const includes = (locationSet.include || []).map(resolver).filter(Boolean);
      const excludes = (locationSet.exclude || []).map(resolver).filter(Boolean);
      if (includes.length === 1 && excludes.length === 0) {
        return Object.assign(valid, { feature: includes[0].feature });
      }
      const includeGeoJSON = _clip(includes.map((d2) => d2.feature), "UNION");
      const excludeGeoJSON = _clip(excludes.map((d2) => d2.feature), "UNION");
      let resultGeoJSON = excludeGeoJSON ? _clip([includeGeoJSON, excludeGeoJSON], "DIFFERENCE") : includeGeoJSON;
      const area = import_geojson_area.default.geometry(resultGeoJSON.geometry) / 1e6;
      resultGeoJSON.id = id2;
      resultGeoJSON.properties = { id: id2, area: Number(area.toFixed(2)) };
      this._cache[id2] = resultGeoJSON;
      return Object.assign(valid, { feature: resultGeoJSON });
    }
    // stringify
    // convenience method to prettyStringify the given object
    stringify(obj, options2) {
      return (0, import_json_stringify_pretty_compact.default)(obj, options2);
    }
  };
  function _clip(features, which) {
    if (!Array.isArray(features) || !features.length)
      return null;
    const fn = { UNION: union, DIFFERENCE: difference }[which];
    const args = features.map((feature3) => feature3.geometry.coordinates);
    const coords = fn.apply(null, args);
    return {
      type: "Feature",
      properties: {},
      geometry: {
        type: whichType(coords),
        coordinates: coords
      }
    };
    function whichType(coords2) {
      const a2 = Array.isArray(coords2);
      const b2 = a2 && Array.isArray(coords2[0]);
      const c2 = b2 && Array.isArray(coords2[0][0]);
      const d2 = c2 && Array.isArray(coords2[0][0][0]);
      return d2 ? "MultiPolygon" : "Polygon";
    }
  }
  function _cloneDeep(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  function _sortLocations(a2, b2) {
    const rank = { countrycoder: 1, geojson: 2, point: 3 };
    const aRank = rank[a2.type];
    const bRank = rank[b2.type];
    return aRank > bRank ? 1 : aRank < bRank ? -1 : a2.id.localeCompare(b2.id);
  }

  // modules/core/LocationManager.js
  var import_which_polygon2 = __toESM(require_which_polygon());
  var import_geojson_area2 = __toESM(require_geojson_area());
  var _loco = new LocationConflation();
  var LocationManager = class {
    /**
     * @constructor
     */
    constructor() {
      this._wp = null;
      this._resolved = /* @__PURE__ */ new Map();
      this._knownLocationSets = /* @__PURE__ */ new Map();
      this._locationIncludedIn = /* @__PURE__ */ new Map();
      this._locationExcludedIn = /* @__PURE__ */ new Map();
      const world = { locationSet: { include: ["Q2"] } };
      this._resolveLocationSet(world);
      this._rebuildIndex();
    }
    /**
     * _validateLocationSet
     * Pass an Object with a `locationSet` property.
     * Validates the `locationSet` and sets a `locationSetID` property on the object.
     * To avoid so much computation we only resolve the include and exclude regions, but not the locationSet itself.
     *
     * Use `_resolveLocationSet()` instead if you need to resolve geojson of locationSet, for example to render it.
     * Note: You need to call `_rebuildIndex()` after you're all finished validating the locationSets.
     *
     * @param  `obj`  Object to check, it should have `locationSet` property
     */
    _validateLocationSet(obj) {
      if (obj.locationSetID)
        return;
      try {
        let locationSet = obj.locationSet;
        if (!locationSet) {
          throw new Error("object missing locationSet property");
        }
        if (!locationSet.include) {
          locationSet.include = ["Q2"];
        }
        const locationSetID = _loco.validateLocationSet(locationSet).id;
        obj.locationSetID = locationSetID;
        if (this._knownLocationSets.has(locationSetID))
          return;
        let area = 0;
        (locationSet.include || []).forEach((location) => {
          const locationID = _loco.validateLocation(location).id;
          let geojson = this._resolved.get(locationID);
          if (!geojson) {
            geojson = _loco.resolveLocation(location).feature;
            this._resolved.set(locationID, geojson);
          }
          area += geojson.properties.area;
          let s2 = this._locationIncludedIn.get(locationID);
          if (!s2) {
            s2 = /* @__PURE__ */ new Set();
            this._locationIncludedIn.set(locationID, s2);
          }
          s2.add(locationSetID);
        });
        (locationSet.exclude || []).forEach((location) => {
          const locationID = _loco.validateLocation(location).id;
          let geojson = this._resolved.get(locationID);
          if (!geojson) {
            geojson = _loco.resolveLocation(location).feature;
            this._resolved.set(locationID, geojson);
          }
          area -= geojson.properties.area;
          let s2 = this._locationExcludedIn.get(locationID);
          if (!s2) {
            s2 = /* @__PURE__ */ new Set();
            this._locationExcludedIn.set(locationID, s2);
          }
          s2.add(locationSetID);
        });
        this._knownLocationSets.set(locationSetID, area);
      } catch {
        obj.locationSet = { include: ["Q2"] };
        obj.locationSetID = "+[Q2]";
      }
    }
    /**
     * _resolveLocationSet
     * Does everything that `_validateLocationSet()` does, but then "resolves" the locationSet into GeoJSON.
     * This step is a bit more computationally expensive, so really only needed if you intend to render the shape.
     *
     * Note: You need to call `_rebuildIndex()` after you're all finished validating the locationSets.
     *
     * @param  `obj`  Object to check, it should have `locationSet` property
     */
    _resolveLocationSet(obj) {
      this._validateLocationSet(obj);
      if (this._resolved.has(obj.locationSetID))
        return;
      try {
        const result = _loco.resolveLocationSet(obj.locationSet);
        const locationSetID = result.id;
        obj.locationSetID = locationSetID;
        if (!result.feature.geometry.coordinates.length || !result.feature.properties.area) {
          throw new Error("locationSet ".concat(locationSetID, " resolves to an empty feature."));
        }
        let geojson = JSON.parse(JSON.stringify(result.feature));
        geojson.id = locationSetID;
        geojson.properties.id = locationSetID;
        this._resolved.set(locationSetID, geojson);
      } catch {
        obj.locationSet = { include: ["Q2"] };
        obj.locationSetID = "+[Q2]";
      }
    }
    /**
     * _rebuildIndex
     * Rebuilds the whichPolygon index with whatever features have been resolved into GeoJSON.
     */
    _rebuildIndex() {
      this._wp = (0, import_which_polygon2.default)({ features: [...this._resolved.values()] });
    }
    /**
     * mergeCustomGeoJSON
     * Accepts a FeatureCollection-like object containing custom locations
     * Each feature must have a filename-like `id`, for example: `something.geojson`
     * {
     *   "type": "FeatureCollection"
     *   "features": [
     *     {
     *       "type": "Feature",
     *       "id": "philly_metro.geojson",
     *       "properties": { … },
     *       "geometry": { … }
     *     }
     *   ]
     * }
     *
     * @param  `fc`  FeatureCollection-like Object containing custom locations
     */
    mergeCustomGeoJSON(fc) {
      if (!fc || fc.type !== "FeatureCollection" || !Array.isArray(fc.features))
        return;
      fc.features.forEach((feature3) => {
        feature3.properties = feature3.properties || {};
        let props = feature3.properties;
        let id2 = feature3.id || props.id;
        if (!id2 || !/^\S+\.geojson$/i.test(id2))
          return;
        id2 = id2.toLowerCase();
        feature3.id = id2;
        props.id = id2;
        if (!props.area) {
          const area = import_geojson_area2.default.geometry(feature3.geometry) / 1e6;
          props.area = Number(area.toFixed(2));
        }
        _loco._cache[id2] = feature3;
      });
    }
    /**
     * mergeLocationSets
     * Accepts an Array of Objects containing `locationSet` properties:
     * [
     *  { id: 'preset1', locationSet: {…} },
     *  { id: 'preset2', locationSet: {…} },
     *  …
     * ]
     * After validating, the Objects will be decorated with a `locationSetID` property:
     * [
     *  { id: 'preset1', locationSet: {…}, locationSetID: '+[Q2]' },
     *  { id: 'preset2', locationSet: {…}, locationSetID: '+[Q30]' },
     *  …
     * ]
     *
     * @param  `objects`  Objects to check - they should have `locationSet` property
     * @return  Promise resolved true (this function used to be slow/async, now it's faster and sync)
     */
    mergeLocationSets(objects) {
      if (!Array.isArray(objects))
        return Promise.reject("nothing to do");
      objects.forEach((obj) => this._validateLocationSet(obj));
      this._rebuildIndex();
      return Promise.resolve(objects);
    }
    /**
     * locationSetID
     * Returns a locationSetID for a given locationSet (fallback to `+[Q2]`, world)
     * (The locationSet doesn't necessarily need to be resolved to compute its `id`)
     *
     * @param  `locationSet`  A locationSet Object, e.g. `{ include: ['us'] }`
     * @return  String locationSetID, e.g. `+[Q30]`
     */
    locationSetID(locationSet) {
      let locationSetID;
      try {
        locationSetID = _loco.validateLocationSet(locationSet).id;
      } catch {
        locationSetID = "+[Q2]";
      }
      return locationSetID;
    }
    /**
     * feature
     * Returns the resolved GeoJSON feature for a given locationSetID (fallback to 'world')
     * A GeoJSON feature:
     * {
     *   type: 'Feature',
     *   id: '+[Q30]',
     *   properties: { id: '+[Q30]', area: 21817019.17, … },
     *   geometry: { … }
     * }
     *
     * @param  `locationSetID`  String identifier, e.g. `+[Q30]`
     * @return  GeoJSON object (fallback to world)
     */
    feature(locationSetID = "+[Q2]") {
      const feature3 = this._resolved.get(locationSetID);
      return feature3 || this._resolved.get("+[Q2]");
    }
    /**
     * locationSetsAt
     * Find all the locationSets valid at the given location.
     * Results include the area (in km²) to facilitate sorting.
     *
     * Object of locationSetIDs to areas (in km²)
     * {
     *   "+[Q2]": 511207893.3958111,
     *   "+[Q30]": 21817019.17,
     *   "+[new_jersey.geojson]": 22390.77,
     *   …
     * }
     *
     * @param  `loc`  `[lon,lat]` location to query, e.g. `[-74.4813, 40.7967]`
     * @return  Object of locationSetIDs valid at given location
     */
    locationSetsAt(loc) {
      let result = {};
      const hits = this._wp(loc, true) || [];
      const thiz = this;
      hits.forEach((prop) => {
        if (prop.id[0] !== "+")
          return;
        const locationSetID = prop.id;
        const area = thiz._knownLocationSets.get(locationSetID);
        if (area) {
          result[locationSetID] = area;
        }
      });
      hits.forEach((prop) => {
        if (prop.id[0] === "+")
          return;
        const locationID = prop.id;
        const included = thiz._locationIncludedIn.get(locationID);
        (included || []).forEach((locationSetID) => {
          const area = thiz._knownLocationSets.get(locationSetID);
          if (area) {
            result[locationSetID] = area;
          }
        });
      });
      hits.forEach((prop) => {
        if (prop.id[0] === "+")
          return;
        const locationID = prop.id;
        const excluded = thiz._locationExcludedIn.get(locationID);
        (excluded || []).forEach((locationSetID) => {
          delete result[locationSetID];
        });
      });
      return result;
    }
    // Direct access to the location-conflation resolver
    loco() {
      return _loco;
    }
  };
  var _sharedLocationManager = new LocationManager();

  // node_modules/lodash-es/_freeGlobal.js
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeGlobal_default = freeGlobal;

  // node_modules/lodash-es/_root.js
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal_default || freeSelf || Function("return this")();
  var root_default = root2;

  // node_modules/lodash-es/_Symbol.js
  var Symbol2 = root_default.Symbol;
  var Symbol_default = Symbol2;

  // node_modules/lodash-es/_getRawTag.js
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag2 = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e3) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag2;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var getRawTag_default = getRawTag;

  // node_modules/lodash-es/_objectToString.js
  var objectProto2 = Object.prototype;
  var nativeObjectToString2 = objectProto2.toString;
  function objectToString(value) {
    return nativeObjectToString2.call(value);
  }
  var objectToString_default = objectToString;

  // node_modules/lodash-es/_baseGetTag.js
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
  }
  var baseGetTag_default = baseGetTag;

  // node_modules/lodash-es/isObjectLike.js
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var isObjectLike_default = isObjectLike;

  // node_modules/lodash-es/isSymbol.js
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
  }
  var isSymbol_default = isSymbol;

  // node_modules/lodash-es/_arrayMap.js
  function arrayMap(array2, iteratee) {
    var index = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
    while (++index < length2) {
      result[index] = iteratee(array2[index], index, array2);
    }
    return result;
  }
  var arrayMap_default = arrayMap;

  // node_modules/lodash-es/isArray.js
  var isArray = Array.isArray;
  var isArray_default = isArray;

  // node_modules/lodash-es/_baseToString.js
  var INFINITY = 1 / 0;
  var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
  var symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray_default(value)) {
      return arrayMap_default(value, baseToString) + "";
    }
    if (isSymbol_default(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  var baseToString_default = baseToString;

  // node_modules/lodash-es/_trimmedEndIndex.js
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index = string.length;
    while (index-- && reWhitespace.test(string.charAt(index))) {
    }
    return index;
  }
  var trimmedEndIndex_default = trimmedEndIndex;

  // node_modules/lodash-es/_baseTrim.js
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
  }
  var baseTrim_default = baseTrim;

  // node_modules/lodash-es/isObject.js
  function isObject(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  var isObject_default = isObject;

  // node_modules/lodash-es/toNumber.js
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol_default(value)) {
      return NAN;
    }
    if (isObject_default(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject_default(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim_default(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var toNumber_default = toNumber;

  // node_modules/lodash-es/isFunction.js
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject_default(value)) {
      return false;
    }
    var tag2 = baseGetTag_default(value);
    return tag2 == funcTag || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
  }
  var isFunction_default = isFunction;

  // node_modules/lodash-es/_coreJsData.js
  var coreJsData = root_default["__core-js_shared__"];
  var coreJsData_default = coreJsData;

  // node_modules/lodash-es/_isMasked.js
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var isMasked_default = isMasked;

  // node_modules/lodash-es/_toSource.js
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e3) {
      }
      try {
        return func + "";
      } catch (e3) {
      }
    }
    return "";
  }
  var toSource_default = toSource;

  // node_modules/lodash-es/_baseIsNative.js
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto2 = Function.prototype;
  var objectProto3 = Object.prototype;
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto3.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject_default(value) || isMasked_default(value)) {
      return false;
    }
    var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource_default(value));
  }
  var baseIsNative_default = baseIsNative;

  // node_modules/lodash-es/_getValue.js
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  var getValue_default = getValue;

  // node_modules/lodash-es/_getNative.js
  function getNative(object, key) {
    var value = getValue_default(object, key);
    return baseIsNative_default(value) ? value : void 0;
  }
  var getNative_default = getNative;

  // node_modules/lodash-es/_WeakMap.js
  var WeakMap = getNative_default(root_default, "WeakMap");
  var WeakMap_default = WeakMap;

  // node_modules/lodash-es/_isIndex.js
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length2) {
    var type2 = typeof value;
    length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
    return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  var isIndex_default = isIndex;

  // node_modules/lodash-es/eq.js
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  var eq_default = eq;

  // node_modules/lodash-es/isLength.js
  var MAX_SAFE_INTEGER3 = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER3;
  }
  var isLength_default = isLength;

  // node_modules/lodash-es/isArrayLike.js
  function isArrayLike(value) {
    return value != null && isLength_default(value.length) && !isFunction_default(value);
  }
  var isArrayLike_default = isArrayLike;

  // node_modules/lodash-es/_isPrototype.js
  var objectProto4 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto4;
    return value === proto;
  }
  var isPrototype_default = isPrototype;

  // node_modules/lodash-es/_baseTimes.js
  function baseTimes(n3, iteratee) {
    var index = -1, result = Array(n3);
    while (++index < n3) {
      result[index] = iteratee(index);
    }
    return result;
  }
  var baseTimes_default = baseTimes;

  // node_modules/lodash-es/_baseIsArguments.js
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
  }
  var baseIsArguments_default = baseIsArguments;

  // node_modules/lodash-es/isArguments.js
  var objectProto5 = Object.prototype;
  var hasOwnProperty3 = objectProto5.hasOwnProperty;
  var propertyIsEnumerable = objectProto5.propertyIsEnumerable;
  var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments_default : function(value) {
    return isObjectLike_default(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArguments_default = isArguments;

  // node_modules/lodash-es/stubFalse.js
  function stubFalse() {
    return false;
  }
  var stubFalse_default = stubFalse;

  // node_modules/lodash-es/isBuffer.js
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root_default.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer = nativeIsBuffer || stubFalse_default;
  var isBuffer_default = isBuffer;

  // node_modules/lodash-es/_baseIsTypedArray.js
  var argsTag2 = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag2 = "[object Function]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
  }
  var baseIsTypedArray_default = baseIsTypedArray;

  // node_modules/lodash-es/_baseUnary.js
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  var baseUnary_default = baseUnary;

  // node_modules/lodash-es/_nodeUtil.js
  var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var freeProcess = moduleExports2 && freeGlobal_default.process;
  var nodeUtil = function() {
    try {
      var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e3) {
    }
  }();
  var nodeUtil_default = nodeUtil;

  // node_modules/lodash-es/isTypedArray.js
  var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
  var isTypedArray_default = isTypedArray;

  // node_modules/lodash-es/_arrayLikeKeys.js
  var objectProto6 = Object.prototype;
  var hasOwnProperty4 = objectProto6.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length2 = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex_default(key, length2)))) {
        result.push(key);
      }
    }
    return result;
  }
  var arrayLikeKeys_default = arrayLikeKeys;

  // node_modules/lodash-es/_overArg.js
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  var overArg_default = overArg;

  // node_modules/lodash-es/_nativeKeys.js
  var nativeKeys = overArg_default(Object.keys, Object);
  var nativeKeys_default = nativeKeys;

  // node_modules/lodash-es/_baseKeys.js
  var objectProto7 = Object.prototype;
  var hasOwnProperty5 = objectProto7.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype_default(object)) {
      return nativeKeys_default(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty5.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  var baseKeys_default = baseKeys;

  // node_modules/lodash-es/keys.js
  function keys(object) {
    return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
  }
  var keys_default = keys;

  // node_modules/lodash-es/_nativeCreate.js
  var nativeCreate = getNative_default(Object, "create");
  var nativeCreate_default = nativeCreate;

  // node_modules/lodash-es/_hashClear.js
  function hashClear() {
    this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
    this.size = 0;
  }
  var hashClear_default = hashClear;

  // node_modules/lodash-es/_hashDelete.js
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  var hashDelete_default = hashDelete;

  // node_modules/lodash-es/_hashGet.js
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto8 = Object.prototype;
  var hasOwnProperty6 = objectProto8.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate_default) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty6.call(data, key) ? data[key] : void 0;
  }
  var hashGet_default = hashGet;

  // node_modules/lodash-es/_hashHas.js
  var objectProto9 = Object.prototype;
  var hasOwnProperty7 = objectProto9.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty7.call(data, key);
  }
  var hashHas_default = hashHas;

  // node_modules/lodash-es/_hashSet.js
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  var hashSet_default = hashSet;

  // node_modules/lodash-es/_Hash.js
  function Hash(entries) {
    var index = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length2) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear_default;
  Hash.prototype["delete"] = hashDelete_default;
  Hash.prototype.get = hashGet_default;
  Hash.prototype.has = hashHas_default;
  Hash.prototype.set = hashSet_default;
  var Hash_default = Hash;

  // node_modules/lodash-es/_listCacheClear.js
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  var listCacheClear_default = listCacheClear;

  // node_modules/lodash-es/_assocIndexOf.js
  function assocIndexOf(array2, key) {
    var length2 = array2.length;
    while (length2--) {
      if (eq_default(array2[length2][0], key)) {
        return length2;
      }
    }
    return -1;
  }
  var assocIndexOf_default = assocIndexOf;

  // node_modules/lodash-es/_listCacheDelete.js
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  var listCacheDelete_default = listCacheDelete;

  // node_modules/lodash-es/_listCacheGet.js
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  var listCacheGet_default = listCacheGet;

  // node_modules/lodash-es/_listCacheHas.js
  function listCacheHas(key) {
    return assocIndexOf_default(this.__data__, key) > -1;
  }
  var listCacheHas_default = listCacheHas;

  // node_modules/lodash-es/_listCacheSet.js
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  var listCacheSet_default = listCacheSet;

  // node_modules/lodash-es/_ListCache.js
  function ListCache(entries) {
    var index = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length2) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear_default;
  ListCache.prototype["delete"] = listCacheDelete_default;
  ListCache.prototype.get = listCacheGet_default;
  ListCache.prototype.has = listCacheHas_default;
  ListCache.prototype.set = listCacheSet_default;
  var ListCache_default = ListCache;

  // node_modules/lodash-es/_Map.js
  var Map2 = getNative_default(root_default, "Map");
  var Map_default = Map2;

  // node_modules/lodash-es/_mapCacheClear.js
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash_default(),
      "map": new (Map_default || ListCache_default)(),
      "string": new Hash_default()
    };
  }
  var mapCacheClear_default = mapCacheClear;

  // node_modules/lodash-es/_isKeyable.js
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  var isKeyable_default = isKeyable;

  // node_modules/lodash-es/_getMapData.js
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  var getMapData_default = getMapData;

  // node_modules/lodash-es/_mapCacheDelete.js
  function mapCacheDelete(key) {
    var result = getMapData_default(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  var mapCacheDelete_default = mapCacheDelete;

  // node_modules/lodash-es/_mapCacheGet.js
  function mapCacheGet(key) {
    return getMapData_default(this, key).get(key);
  }
  var mapCacheGet_default = mapCacheGet;

  // node_modules/lodash-es/_mapCacheHas.js
  function mapCacheHas(key) {
    return getMapData_default(this, key).has(key);
  }
  var mapCacheHas_default = mapCacheHas;

  // node_modules/lodash-es/_mapCacheSet.js
  function mapCacheSet(key, value) {
    var data = getMapData_default(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  var mapCacheSet_default = mapCacheSet;

  // node_modules/lodash-es/_MapCache.js
  function MapCache(entries) {
    var index = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length2) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear_default;
  MapCache.prototype["delete"] = mapCacheDelete_default;
  MapCache.prototype.get = mapCacheGet_default;
  MapCache.prototype.has = mapCacheHas_default;
  MapCache.prototype.set = mapCacheSet_default;
  var MapCache_default = MapCache;

  // node_modules/lodash-es/toString.js
  function toString(value) {
    return value == null ? "" : baseToString_default(value);
  }
  var toString_default = toString;

  // node_modules/lodash-es/_arrayPush.js
  function arrayPush(array2, values) {
    var index = -1, length2 = values.length, offset = array2.length;
    while (++index < length2) {
      array2[offset + index] = values[index];
    }
    return array2;
  }
  var arrayPush_default = arrayPush;

  // node_modules/lodash-es/_basePropertyOf.js
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? void 0 : object[key];
    };
  }
  var basePropertyOf_default = basePropertyOf;

  // node_modules/lodash-es/_stackClear.js
  function stackClear() {
    this.__data__ = new ListCache_default();
    this.size = 0;
  }
  var stackClear_default = stackClear;

  // node_modules/lodash-es/_stackDelete.js
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  var stackDelete_default = stackDelete;

  // node_modules/lodash-es/_stackGet.js
  function stackGet(key) {
    return this.__data__.get(key);
  }
  var stackGet_default = stackGet;

  // node_modules/lodash-es/_stackHas.js
  function stackHas(key) {
    return this.__data__.has(key);
  }
  var stackHas_default = stackHas;

  // node_modules/lodash-es/_stackSet.js
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache_default) {
      var pairs2 = data.__data__;
      if (!Map_default || pairs2.length < LARGE_ARRAY_SIZE - 1) {
        pairs2.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache_default(pairs2);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  var stackSet_default = stackSet;

  // node_modules/lodash-es/_Stack.js
  function Stack(entries) {
    var data = this.__data__ = new ListCache_default(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear_default;
  Stack.prototype["delete"] = stackDelete_default;
  Stack.prototype.get = stackGet_default;
  Stack.prototype.has = stackHas_default;
  Stack.prototype.set = stackSet_default;
  var Stack_default = Stack;

  // node_modules/lodash-es/_arrayFilter.js
  function arrayFilter(array2, predicate) {
    var index = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
    while (++index < length2) {
      var value = array2[index];
      if (predicate(value, index, array2)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  var arrayFilter_default = arrayFilter;

  // node_modules/lodash-es/stubArray.js
  function stubArray() {
    return [];
  }
  var stubArray_default = stubArray;

  // node_modules/lodash-es/_getSymbols.js
  var objectProto10 = Object.prototype;
  var propertyIsEnumerable2 = objectProto10.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable2.call(object, symbol);
    });
  };
  var getSymbols_default = getSymbols;

  // node_modules/lodash-es/_baseGetAllKeys.js
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
  }
  var baseGetAllKeys_default = baseGetAllKeys;

  // node_modules/lodash-es/_getAllKeys.js
  function getAllKeys(object) {
    return baseGetAllKeys_default(object, keys_default, getSymbols_default);
  }
  var getAllKeys_default = getAllKeys;

  // node_modules/lodash-es/_DataView.js
  var DataView2 = getNative_default(root_default, "DataView");
  var DataView_default = DataView2;

  // node_modules/lodash-es/_Promise.js
  var Promise2 = getNative_default(root_default, "Promise");
  var Promise_default = Promise2;

  // node_modules/lodash-es/_Set.js
  var Set2 = getNative_default(root_default, "Set");
  var Set_default = Set2;

  // node_modules/lodash-es/_getTag.js
  var mapTag2 = "[object Map]";
  var objectTag2 = "[object Object]";
  var promiseTag = "[object Promise]";
  var setTag2 = "[object Set]";
  var weakMapTag2 = "[object WeakMap]";
  var dataViewTag2 = "[object DataView]";
  var dataViewCtorString = toSource_default(DataView_default);
  var mapCtorString = toSource_default(Map_default);
  var promiseCtorString = toSource_default(Promise_default);
  var setCtorString = toSource_default(Set_default);
  var weakMapCtorString = toSource_default(WeakMap_default);
  var getTag = baseGetTag_default;
  if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
    getTag = function(value) {
      var result = baseGetTag_default(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag2;
          case mapCtorString:
            return mapTag2;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag2;
          case weakMapCtorString:
            return weakMapTag2;
        }
      }
      return result;
    };
  }
  var getTag_default = getTag;

  // node_modules/lodash-es/_Uint8Array.js
  var Uint8Array2 = root_default.Uint8Array;
  var Uint8Array_default = Uint8Array2;

  // node_modules/lodash-es/_setCacheAdd.js
  var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED3);
    return this;
  }
  var setCacheAdd_default = setCacheAdd;

  // node_modules/lodash-es/_setCacheHas.js
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  var setCacheHas_default = setCacheHas;

  // node_modules/lodash-es/_SetCache.js
  function SetCache(values) {
    var index = -1, length2 = values == null ? 0 : values.length;
    this.__data__ = new MapCache_default();
    while (++index < length2) {
      this.add(values[index]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
  SetCache.prototype.has = setCacheHas_default;
  var SetCache_default = SetCache;

  // node_modules/lodash-es/_arraySome.js
  function arraySome(array2, predicate) {
    var index = -1, length2 = array2 == null ? 0 : array2.length;
    while (++index < length2) {
      if (predicate(array2[index], index, array2)) {
        return true;
      }
    }
    return false;
  }
  var arraySome_default = arraySome;

  // node_modules/lodash-es/_cacheHas.js
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  var cacheHas_default = cacheHas;

  // node_modules/lodash-es/_equalArrays.js
  var COMPARE_PARTIAL_FLAG = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array2);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array2;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
    stack.set(array2, other);
    stack.set(other, array2);
    while (++index < arrLength) {
      var arrValue = array2[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome_default(other, function(othValue2, othIndex) {
          if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array2);
    stack["delete"](other);
    return result;
  }
  var equalArrays_default = equalArrays;

  // node_modules/lodash-es/_mapToArray.js
  function mapToArray(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  var mapToArray_default = mapToArray;

  // node_modules/lodash-es/_setToArray.js
  function setToArray(set4) {
    var index = -1, result = Array(set4.size);
    set4.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var setToArray_default = setToArray;

  // node_modules/lodash-es/_equalByTag.js
  var COMPARE_PARTIAL_FLAG2 = 1;
  var COMPARE_UNORDERED_FLAG2 = 2;
  var boolTag2 = "[object Boolean]";
  var dateTag2 = "[object Date]";
  var errorTag2 = "[object Error]";
  var mapTag3 = "[object Map]";
  var numberTag2 = "[object Number]";
  var regexpTag2 = "[object RegExp]";
  var setTag3 = "[object Set]";
  var stringTag2 = "[object String]";
  var symbolTag2 = "[object Symbol]";
  var arrayBufferTag2 = "[object ArrayBuffer]";
  var dataViewTag3 = "[object DataView]";
  var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
  var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function equalByTag(object, other, tag2, bitmask, customizer, equalFunc, stack) {
    switch (tag2) {
      case dataViewTag3:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag2:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
          return false;
        }
        return true;
      case boolTag2:
      case dateTag2:
      case numberTag2:
        return eq_default(+object, +other);
      case errorTag2:
        return object.name == other.name && object.message == other.message;
      case regexpTag2:
      case stringTag2:
        return object == other + "";
      case mapTag3:
        var convert = mapToArray_default;
      case setTag3:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
        convert || (convert = setToArray_default);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG2;
        stack.set(object, other);
        var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag2:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  var equalByTag_default = equalByTag;

  // node_modules/lodash-es/_equalObjects.js
  var COMPARE_PARTIAL_FLAG3 = 1;
  var objectProto11 = Object.prototype;
  var hasOwnProperty8 = objectProto11.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty8.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  var equalObjects_default = equalObjects;

  // node_modules/lodash-es/_baseIsEqualDeep.js
  var COMPARE_PARTIAL_FLAG4 = 1;
  var argsTag3 = "[object Arguments]";
  var arrayTag2 = "[object Array]";
  var objectTag3 = "[object Object]";
  var objectProto12 = Object.prototype;
  var hasOwnProperty9 = objectProto12.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag2 : getTag_default(object), othTag = othIsArr ? arrayTag2 : getTag_default(other);
    objTag = objTag == argsTag3 ? objectTag3 : objTag;
    othTag = othTag == argsTag3 ? objectTag3 : othTag;
    var objIsObj = objTag == objectTag3, othIsObj = othTag == objectTag3, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer_default(object)) {
      if (!isBuffer_default(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack_default());
      return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
      var objIsWrapped = objIsObj && hasOwnProperty9.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty9.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack_default());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack_default());
    return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
  }
  var baseIsEqualDeep_default = baseIsEqualDeep;

  // node_modules/lodash-es/_baseIsEqual.js
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  var baseIsEqual_default = baseIsEqual;

  // node_modules/lodash-es/now.js
  var now2 = function() {
    return root_default.Date.now();
  };
  var now_default = now2;

  // node_modules/lodash-es/debounce.js
  var FUNC_ERROR_TEXT = "Expected a function";
  var nativeMax = Math.max;
  var nativeMin = Math.min;
  function debounce(func, wait, options2) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber_default(wait) || 0;
    if (isObject_default(options2)) {
      leading = !!options2.leading;
      maxing = "maxWait" in options2;
      maxWait = maxing ? nativeMax(toNumber_default(options2.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options2 ? !!options2.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now_default();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now_default());
    }
    function debounced() {
      var time = now_default(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  var debounce_default = debounce;

  // node_modules/lodash-es/_escapeHtmlChar.js
  var htmlEscapes = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var escapeHtmlChar = basePropertyOf_default(htmlEscapes);
  var escapeHtmlChar_default = escapeHtmlChar;

  // node_modules/lodash-es/escape.js
  var reUnescapedHtml = /[&<>"']/g;
  var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
  function escape2(string) {
    string = toString_default(string);
    return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar_default) : string;
  }
  var escape_default = escape2;

  // node_modules/lodash-es/isEqual.js
  function isEqual(value, other) {
    return baseIsEqual_default(value, other);
  }
  var isEqual_default = isEqual;

  // node_modules/lodash-es/isNumber.js
  var numberTag3 = "[object Number]";
  function isNumber(value) {
    return typeof value == "number" || isObjectLike_default(value) && baseGetTag_default(value) == numberTag3;
  }
  var isNumber_default = isNumber;

  // node_modules/lodash-es/throttle.js
  var FUNC_ERROR_TEXT2 = "Expected a function";
  function throttle(func, wait, options2) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT2);
    }
    if (isObject_default(options2)) {
      leading = "leading" in options2 ? !!options2.leading : leading;
      trailing = "trailing" in options2 ? !!options2.trailing : trailing;
    }
    return debounce_default(func, wait, {
      "leading": leading,
      "maxWait": wait,
      "trailing": trailing
    });
  }
  var throttle_default = throttle;

  // node_modules/lodash-es/_unescapeHtmlChar.js
  var htmlUnescapes = {
    "&amp;": "&",
    "&lt;": "<",
    "&gt;": ">",
    "&quot;": '"',
    "&#39;": "'"
  };
  var unescapeHtmlChar = basePropertyOf_default(htmlUnescapes);
  var unescapeHtmlChar_default = unescapeHtmlChar;

  // node_modules/lodash-es/unescape.js
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
  var reHasEscapedHtml = RegExp(reEscapedHtml.source);
  function unescape(string) {
    string = toString_default(string);
    return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar_default) : string;
  }
  var unescape_default = unescape;

  // modules/util/detect.js
  var _detected;
  function utilDetect(refresh2) {
    if (_detected && !refresh2)
      return _detected;
    _detected = {};
    const ua = navigator.userAgent;
    let m2 = null;
    m2 = ua.match(/(edge)\/?\s*(\.?\d+(\.\d+)*)/i);
    if (m2 !== null) {
      _detected.browser = m2[1];
      _detected.version = m2[2];
    }
    if (!_detected.browser) {
      m2 = ua.match(/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/i);
      if (m2 !== null) {
        _detected.browser = "msie";
        _detected.version = m2[1];
      }
    }
    if (!_detected.browser) {
      m2 = ua.match(/(opr)\/?\s*(\.?\d+(\.\d+)*)/i);
      if (m2 !== null) {
        _detected.browser = "Opera";
        _detected.version = m2[2];
      }
    }
    if (!_detected.browser) {
      m2 = ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
      if (m2 !== null) {
        _detected.browser = m2[1];
        _detected.version = m2[2];
        m2 = ua.match(/version\/([\.\d]+)/i);
        if (m2 !== null)
          _detected.version = m2[1];
      }
    }
    if (!_detected.browser) {
      _detected.browser = navigator.appName;
      _detected.version = navigator.appVersion;
    }
    _detected.version = _detected.version.split(/\W/).slice(0, 2).join(".");
    _detected.opera = _detected.browser.toLowerCase() === "opera" && Number(_detected.version) < 15;
    if (_detected.browser.toLowerCase() === "msie") {
      _detected.ie = true;
      _detected.browser = "Internet Explorer";
      _detected.support = false;
    } else {
      _detected.ie = false;
      _detected.support = true;
    }
    _detected.filedrop = window.FileReader && "ondrop" in window;
    if (/Win/.test(ua)) {
      _detected.os = "win";
      _detected.platform = "Windows";
    } else if (/Mac/.test(ua)) {
      _detected.os = "mac";
      _detected.platform = "Macintosh";
    } else if (/X11/.test(ua) || /Linux/.test(ua)) {
      _detected.os = "linux";
      _detected.platform = "Linux";
    } else {
      _detected.os = "win";
      _detected.platform = "Unknown";
    }
    _detected.isMobileWebKit = (/\b(iPad|iPhone|iPod)\b/.test(ua) || // HACK: iPadOS 13+ requests desktop sites by default by using a Mac user agent,
    // so assume any "mac" with multitouch is actually iOS
    navigator.platform === "MacIntel" && "maxTouchPoints" in navigator && navigator.maxTouchPoints > 1) && /WebKit/.test(ua) && !/Edge/.test(ua) && !window.MSStream;
    _detected.browserLocales = Array.from(new Set(
      // remove duplicates
      [navigator.language].concat(navigator.languages || []).concat([
        // old property for backwards compatibility
        navigator.userLanguage
      ]).filter(Boolean)
    ));
    const loc = window.top.location;
    let origin = loc.origin;
    if (!origin) {
      origin = loc.protocol + "//" + loc.hostname + (loc.port ? ":" + loc.port : "");
    }
    _detected.host = origin + loc.pathname;
    return _detected;
  }

  // modules/util/aes.js
  var import_aes_js = __toESM(require_aes_js());
  var DEFAULT_128 = [250, 157, 60, 79, 142, 134, 229, 129, 138, 126, 210, 129, 29, 71, 160, 208];
  function utilAesEncrypt(text, key) {
    key = key || DEFAULT_128;
    const textBytes = import_aes_js.default.utils.utf8.toBytes(text);
    const aesCtr = new import_aes_js.default.ModeOfOperation.ctr(key);
    const encryptedBytes = aesCtr.encrypt(textBytes);
    const encryptedHex = import_aes_js.default.utils.hex.fromBytes(encryptedBytes);
    return encryptedHex;
  }
  function utilAesDecrypt(encryptedHex, key) {
    key = key || DEFAULT_128;
    const encryptedBytes = import_aes_js.default.utils.hex.toBytes(encryptedHex);
    const aesCtr = new import_aes_js.default.ModeOfOperation.ctr(key);
    const decryptedBytes = aesCtr.decrypt(encryptedBytes);
    const text = import_aes_js.default.utils.utf8.fromBytes(decryptedBytes);
    return text;
  }

  // modules/util/clean_tags.js
  function utilCleanTags(tags) {
    var out = {};
    for (var k2 in tags) {
      if (!k2)
        continue;
      var v2 = tags[k2];
      if (v2 !== void 0) {
        out[k2] = cleanValue(k2, v2);
      }
    }
    return out;
    function cleanValue(k3, v3) {
      function keepSpaces(k4) {
        return /_hours|_times|:conditional$/.test(k4);
      }
      function skip(k4) {
        return /^(description|note|fixme|inscription)$/.test(k4);
      }
      if (skip(k3))
        return v3;
      var cleaned = v3.split(";").map(function(s2) {
        return s2.trim();
      }).join(keepSpaces(k3) ? "; " : ";");
      if (k3.indexOf("website") !== -1 || k3.indexOf("email") !== -1 || cleaned.indexOf("http") === 0) {
        cleaned = cleaned.replace(/[\u200B-\u200F\uFEFF]/g, "");
      }
      return cleaned;
    }
  }

  // modules/util/get_set_value.js
  function utilGetSetValue(selection2, value, shouldUpdate) {
    function setValue(value2, shouldUpdate2) {
      function valueNull() {
        delete this.value;
      }
      function valueConstant() {
        if (shouldUpdate2(this.value, value2)) {
          this.value = value2;
        }
      }
      function valueFunction() {
        var x2 = value2.apply(this, arguments);
        if (x2 === null || x2 === void 0) {
          delete this.value;
        } else if (shouldUpdate2(this.value, x2)) {
          this.value = x2;
        }
      }
      return value2 === null || value2 === void 0 ? valueNull : typeof value2 === "function" ? valueFunction : valueConstant;
    }
    if (arguments.length === 1) {
      return selection2.property("value");
    }
    if (shouldUpdate === void 0) {
      shouldUpdate = (a2, b2) => a2 !== b2;
    }
    return selection2.each(setValue(value, shouldUpdate));
  }

  // modules/util/keybinding.js
  function utilKeybinding(namespace) {
    var _keybindings = {};
    function testBindings(d3_event, isCapturing) {
      var didMatch = false;
      var bindings = Object.keys(_keybindings).map(function(id2) {
        return _keybindings[id2];
      });
      var i3, binding;
      for (i3 = 0; i3 < bindings.length; i3++) {
        binding = bindings[i3];
        if (!binding.event.modifiers.shiftKey)
          continue;
        if (!!binding.capture !== isCapturing)
          continue;
        if (matches(d3_event, binding, true)) {
          binding.callback(d3_event);
          didMatch = true;
          break;
        }
      }
      if (didMatch)
        return;
      for (i3 = 0; i3 < bindings.length; i3++) {
        binding = bindings[i3];
        if (binding.event.modifiers.shiftKey)
          continue;
        if (!!binding.capture !== isCapturing)
          continue;
        if (matches(d3_event, binding, false)) {
          binding.callback(d3_event);
          break;
        }
      }
      function matches(d3_event2, binding2, testShift) {
        var event = d3_event2;
        var isMatch = false;
        var tryKeyCode = true;
        if (event.key !== void 0) {
          tryKeyCode = event.key.charCodeAt(0) > 127;
          isMatch = true;
          if (binding2.event.key === void 0) {
            isMatch = false;
          } else if (Array.isArray(binding2.event.key)) {
            if (binding2.event.key.map(function(s2) {
              return s2.toLowerCase();
            }).indexOf(event.key.toLowerCase()) === -1) {
              isMatch = false;
            }
          } else {
            if (event.key.toLowerCase() !== binding2.event.key.toLowerCase()) {
              isMatch = false;
            }
          }
        }
        if (!isMatch && (tryKeyCode || binding2.event.modifiers.altKey)) {
          isMatch = event.keyCode === binding2.event.keyCode;
        }
        if (!isMatch)
          return false;
        if (!(event.ctrlKey && event.altKey)) {
          if (event.ctrlKey !== binding2.event.modifiers.ctrlKey)
            return false;
          if (event.altKey !== binding2.event.modifiers.altKey)
            return false;
        }
        if (event.metaKey !== binding2.event.modifiers.metaKey)
          return false;
        if (testShift && event.shiftKey !== binding2.event.modifiers.shiftKey)
          return false;
        return true;
      }
    }
    function capture(d3_event) {
      testBindings(d3_event, true);
    }
    function bubble(d3_event) {
      var tagName = select_default2(d3_event.target).node().tagName;
      if (tagName === "INPUT" || tagName === "SELECT" || tagName === "TEXTAREA") {
        return;
      }
      testBindings(d3_event, false);
    }
    function keybinding(selection2) {
      selection2 = selection2 || select_default2(document);
      selection2.on("keydown.capture." + namespace, capture, true);
      selection2.on("keydown.bubble." + namespace, bubble, false);
      return keybinding;
    }
    keybinding.unbind = function(selection2) {
      _keybindings = [];
      selection2 = selection2 || select_default2(document);
      selection2.on("keydown.capture." + namespace, null);
      selection2.on("keydown.bubble." + namespace, null);
      return keybinding;
    };
    keybinding.clear = function() {
      _keybindings = {};
      return keybinding;
    };
    keybinding.off = function(codes, capture2) {
      var arr = utilArrayUniq([].concat(codes));
      for (var i3 = 0; i3 < arr.length; i3++) {
        var id2 = arr[i3] + (capture2 ? "-capture" : "-bubble");
        delete _keybindings[id2];
      }
      return keybinding;
    };
    keybinding.on = function(codes, callback, capture2) {
      if (typeof callback !== "function") {
        return keybinding.off(codes, capture2);
      }
      var arr = utilArrayUniq([].concat(codes));
      for (var i3 = 0; i3 < arr.length; i3++) {
        var id2 = arr[i3] + (capture2 ? "-capture" : "-bubble");
        var binding = {
          id: id2,
          capture: capture2,
          callback,
          event: {
            key: void 0,
            // preferred
            keyCode: 0,
            // fallback
            modifiers: {
              shiftKey: false,
              ctrlKey: false,
              altKey: false,
              metaKey: false
            }
          }
        };
        if (_keybindings[id2]) {
          console.warn('warning: duplicate keybinding for "' + id2 + '"');
        }
        _keybindings[id2] = binding;
        var matches = arr[i3].toLowerCase().match(/(?:(?:[^+⇧⌃⌥⌘])+|[⇧⌃⌥⌘]|\+\+|^\+$)/g);
        for (var j2 = 0; j2 < matches.length; j2++) {
          if (matches[j2] === "++")
            matches[j2] = "+";
          if (matches[j2] in utilKeybinding.modifierCodes) {
            var prop = utilKeybinding.modifierProperties[utilKeybinding.modifierCodes[matches[j2]]];
            binding.event.modifiers[prop] = true;
          } else {
            binding.event.key = utilKeybinding.keys[matches[j2]] || matches[j2];
            if (matches[j2] in utilKeybinding.keyCodes) {
              binding.event.keyCode = utilKeybinding.keyCodes[matches[j2]];
            }
          }
        }
      }
      return keybinding;
    };
    return keybinding;
  }
  utilKeybinding.modifierCodes = {
    // Shift key, ⇧
    "\u21E7": 16,
    shift: 16,
    // CTRL key, on Mac: ⌃
    "\u2303": 17,
    ctrl: 17,
    // ALT key, on Mac: ⌥ (Alt)
    "\u2325": 18,
    alt: 18,
    option: 18,
    // META, on Mac: ⌘ (CMD), on Windows (Win), on Linux (Super)
    "\u2318": 91,
    meta: 91,
    cmd: 91,
    "super": 91,
    win: 91
  };
  utilKeybinding.modifierProperties = {
    16: "shiftKey",
    17: "ctrlKey",
    18: "altKey",
    91: "metaKey"
  };
  utilKeybinding.plusKeys = ["plus", "ffplus", "=", "ffequals", "\u2260", "\xB1"];
  utilKeybinding.minusKeys = ["_", "-", "ffminus", "dash", "\u2013", "\u2014"];
  utilKeybinding.keys = {
    // Backspace key, on Mac: ⌫ (Backspace)
    "\u232B": "Backspace",
    backspace: "Backspace",
    // Tab Key, on Mac: ⇥ (Tab), on Windows ⇥⇥
    "\u21E5": "Tab",
    "\u21C6": "Tab",
    tab: "Tab",
    // Return key, ↩
    "\u21A9": "Enter",
    "\u21B5": "Enter",
    "\u23CE": "Enter",
    "return": "Enter",
    enter: "Enter",
    "\u2305": "Enter",
    // Pause/Break key
    "pause": "Pause",
    "pause-break": "Pause",
    // Caps Lock key, ⇪
    "\u21EA": "CapsLock",
    caps: "CapsLock",
    "caps-lock": "CapsLock",
    // Escape key, on Mac: ⎋, on Windows: Esc
    "\u238B": ["Escape", "Esc"],
    escape: ["Escape", "Esc"],
    esc: ["Escape", "Esc"],
    // Space key
    space: [" ", "Spacebar"],
    // Page-Up key, or pgup, on Mac: ↖
    "\u2196": "PageUp",
    pgup: "PageUp",
    "page-up": "PageUp",
    // Page-Down key, or pgdown, on Mac: ↘
    "\u2198": "PageDown",
    pgdown: "PageDown",
    "page-down": "PageDown",
    // END key, on Mac: ⇟
    "\u21DF": "End",
    end: "End",
    // HOME key, on Mac: ⇞
    "\u21DE": "Home",
    home: "Home",
    // Insert key, or ins
    ins: "Insert",
    insert: "Insert",
    // Delete key, on Mac: ⌦ (Delete)
    "\u2326": ["Delete", "Del"],
    del: ["Delete", "Del"],
    "delete": ["Delete", "Del"],
    // Left Arrow Key, or ←
    "\u2190": ["ArrowLeft", "Left"],
    left: ["ArrowLeft", "Left"],
    "arrow-left": ["ArrowLeft", "Left"],
    // Up Arrow Key, or ↑
    "\u2191": ["ArrowUp", "Up"],
    up: ["ArrowUp", "Up"],
    "arrow-up": ["ArrowUp", "Up"],
    // Right Arrow Key, or →
    "\u2192": ["ArrowRight", "Right"],
    right: ["ArrowRight", "Right"],
    "arrow-right": ["ArrowRight", "Right"],
    // Up Arrow Key, or ↓
    "\u2193": ["ArrowDown", "Down"],
    down: ["ArrowDown", "Down"],
    "arrow-down": ["ArrowDown", "Down"],
    // odities, stuff for backward compatibility (browsers and code):
    // Num-Multiply, or *
    "*": ["*", "Multiply"],
    star: ["*", "Multiply"],
    asterisk: ["*", "Multiply"],
    multiply: ["*", "Multiply"],
    // Num-Plus or +
    "+": ["+", "Add"],
    "plus": ["+", "Add"],
    // Num-Subtract, or -
    "-": ["-", "Subtract"],
    subtract: ["-", "Subtract"],
    "dash": ["-", "Subtract"],
    // Semicolon
    semicolon: ";",
    // = or equals
    equals: "=",
    // Comma, or ,
    comma: ",",
    // Period, or ., or full-stop
    period: ".",
    "full-stop": ".",
    // Slash, or /, or forward-slash
    slash: "/",
    "forward-slash": "/",
    // Tick, or `, or back-quote
    tick: "`",
    "back-quote": "`",
    // Open bracket, or [
    "open-bracket": "[",
    // Back slash, or \
    "back-slash": "\\",
    // Close bracket, or ]
    "close-bracket": "]",
    // Apostrophe, or Quote, or '
    quote: "'",
    apostrophe: "'",
    // NUMPAD 0-9
    "num-0": "0",
    "num-1": "1",
    "num-2": "2",
    "num-3": "3",
    "num-4": "4",
    "num-5": "5",
    "num-6": "6",
    "num-7": "7",
    "num-8": "8",
    "num-9": "9",
    // F1-F25
    f1: "F1",
    f2: "F2",
    f3: "F3",
    f4: "F4",
    f5: "F5",
    f6: "F6",
    f7: "F7",
    f8: "F8",
    f9: "F9",
    f10: "F10",
    f11: "F11",
    f12: "F12",
    f13: "F13",
    f14: "F14",
    f15: "F15",
    f16: "F16",
    f17: "F17",
    f18: "F18",
    f19: "F19",
    f20: "F20",
    f21: "F21",
    f22: "F22",
    f23: "F23",
    f24: "F24",
    f25: "F25"
  };
  utilKeybinding.keyCodes = {
    // Backspace key, on Mac: ⌫ (Backspace)
    "\u232B": 8,
    backspace: 8,
    // Tab Key, on Mac: ⇥ (Tab), on Windows ⇥⇥
    "\u21E5": 9,
    "\u21C6": 9,
    tab: 9,
    // Return key, ↩
    "\u21A9": 13,
    "\u21B5": 13,
    "\u23CE": 13,
    "return": 13,
    enter: 13,
    "\u2305": 13,
    // Pause/Break key
    "pause": 19,
    "pause-break": 19,
    // Caps Lock key, ⇪
    "\u21EA": 20,
    caps: 20,
    "caps-lock": 20,
    // Escape key, on Mac: ⎋, on Windows: Esc
    "\u238B": 27,
    escape: 27,
    esc: 27,
    // Space key
    space: 32,
    // Page-Up key, or pgup, on Mac: ↖
    "\u2196": 33,
    pgup: 33,
    "page-up": 33,
    // Page-Down key, or pgdown, on Mac: ↘
    "\u2198": 34,
    pgdown: 34,
    "page-down": 34,
    // END key, on Mac: ⇟
    "\u21DF": 35,
    end: 35,
    // HOME key, on Mac: ⇞
    "\u21DE": 36,
    home: 36,
    // Insert key, or ins
    ins: 45,
    insert: 45,
    // Delete key, on Mac: ⌦ (Delete)
    "\u2326": 46,
    del: 46,
    "delete": 46,
    // Left Arrow Key, or ←
    "\u2190": 37,
    left: 37,
    "arrow-left": 37,
    // Up Arrow Key, or ↑
    "\u2191": 38,
    up: 38,
    "arrow-up": 38,
    // Right Arrow Key, or →
    "\u2192": 39,
    right: 39,
    "arrow-right": 39,
    // Up Arrow Key, or ↓
    "\u2193": 40,
    down: 40,
    "arrow-down": 40,
    // odities, printing characters that come out wrong:
    // Firefox Equals
    "ffequals": 61,
    // Num-Multiply, or *
    "*": 106,
    star: 106,
    asterisk: 106,
    multiply: 106,
    // Num-Plus or +
    "+": 107,
    "plus": 107,
    // Num-Subtract, or -
    "-": 109,
    subtract: 109,
    // Vertical Bar / Pipe
    "|": 124,
    // Firefox Plus
    "ffplus": 171,
    // Firefox Minus
    "ffminus": 173,
    // Semicolon
    ";": 186,
    semicolon: 186,
    // = or equals
    "=": 187,
    "equals": 187,
    // Comma, or ,
    ",": 188,
    comma: 188,
    // Dash / Underscore key
    "dash": 189,
    // Period, or ., or full-stop
    ".": 190,
    period: 190,
    "full-stop": 190,
    // Slash, or /, or forward-slash
    "/": 191,
    slash: 191,
    "forward-slash": 191,
    // Tick, or `, or back-quote
    "`": 192,
    tick: 192,
    "back-quote": 192,
    // Open bracket, or [
    "[": 219,
    "open-bracket": 219,
    // Back slash, or \
    "\\": 220,
    "back-slash": 220,
    // Close bracket, or ]
    "]": 221,
    "close-bracket": 221,
    // Apostrophe, or Quote, or '
    "'": 222,
    quote: 222,
    apostrophe: 222
  };
  var i = 95;
  var n = 0;
  while (++i < 106) {
    utilKeybinding.keyCodes["num-" + n] = i;
    ++n;
  }
  i = 47;
  n = 0;
  while (++i < 58) {
    utilKeybinding.keyCodes[n] = i;
    ++n;
  }
  i = 111;
  n = 1;
  while (++i < 136) {
    utilKeybinding.keyCodes["f" + n] = i;
    ++n;
  }
  i = 64;
  while (++i < 91) {
    utilKeybinding.keyCodes[String.fromCharCode(i).toLowerCase()] = i;
  }

  // modules/util/object.js
  function utilObjectOmit(obj, omitKeys) {
    return Object.keys(obj).reduce(function(result, key) {
      if (omitKeys.indexOf(key) === -1) {
        result[key] = obj[key];
      }
      return result;
    }, {});
  }

  // modules/util/rebind.js
  function utilRebind(target, source) {
    var i3 = 1, n3 = arguments.length, method;
    while (++i3 < n3) {
      target[method = arguments[i3]] = d3_rebind(target, source, source[method]);
    }
    return target;
  }
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }

  // modules/util/session_mutex.js
  function utilSessionMutex(name) {
    var mutex = {};
    var intervalID;
    function renew() {
      var expires = /* @__PURE__ */ new Date();
      expires.setSeconds(expires.getSeconds() + 5);
      document.cookie = name + "=1; expires=" + expires.toUTCString() + "; sameSite=strict";
    }
    mutex.lock = function() {
      if (intervalID)
        return true;
      var cookie = document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + name + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1");
      if (cookie)
        return false;
      renew();
      intervalID = window.setInterval(renew, 4e3);
      return true;
    };
    mutex.unlock = function() {
      if (!intervalID)
        return;
      document.cookie = name + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; sameSite=strict";
      clearInterval(intervalID);
      intervalID = null;
    };
    mutex.locked = function() {
      return !!intervalID;
    };
    return mutex;
  }

  // modules/util/tiler.js
  function utilTiler() {
    var _size = [256, 256];
    var _scale = 256;
    var _tileSize = 256;
    var _zoomExtent = [0, 20];
    var _translate = [_size[0] / 2, _size[1] / 2];
    var _margin = 0;
    var _skipNullIsland = false;
    function clamp3(num, min3, max3) {
      return Math.max(min3, Math.min(num, max3));
    }
    function nearNullIsland(tile) {
      var x2 = tile[0];
      var y2 = tile[1];
      var z2 = tile[2];
      if (z2 >= 7) {
        var center = Math.pow(2, z2 - 1);
        var width = Math.pow(2, z2 - 6);
        var min3 = center - width / 2;
        var max3 = center + width / 2 - 1;
        return x2 >= min3 && x2 <= max3 && y2 >= min3 && y2 <= max3;
      }
      return false;
    }
    function tiler9() {
      var z2 = geoScaleToZoom(_scale / (2 * Math.PI), _tileSize);
      var z0 = clamp3(Math.round(z2), _zoomExtent[0], _zoomExtent[1]);
      var tileMin = 0;
      var tileMax = Math.pow(2, z0) - 1;
      var log2ts = Math.log(_tileSize) * Math.LOG2E;
      var k2 = Math.pow(2, z2 - z0 + log2ts);
      var origin = [
        (_translate[0] - _scale / 2) / k2,
        (_translate[1] - _scale / 2) / k2
      ];
      var cols = range(
        clamp3(Math.floor(-origin[0]) - _margin, tileMin, tileMax + 1),
        clamp3(Math.ceil(_size[0] / k2 - origin[0]) + _margin, tileMin, tileMax + 1)
      );
      var rows = range(
        clamp3(Math.floor(-origin[1]) - _margin, tileMin, tileMax + 1),
        clamp3(Math.ceil(_size[1] / k2 - origin[1]) + _margin, tileMin, tileMax + 1)
      );
      var tiles = [];
      for (var i3 = 0; i3 < rows.length; i3++) {
        var y2 = rows[i3];
        for (var j2 = 0; j2 < cols.length; j2++) {
          var x2 = cols[j2];
          if (i3 >= _margin && i3 <= rows.length - _margin && j2 >= _margin && j2 <= cols.length - _margin) {
            tiles.unshift([x2, y2, z0]);
          } else {
            tiles.push([x2, y2, z0]);
          }
        }
      }
      tiles.translate = origin;
      tiles.scale = k2;
      return tiles;
    }
    tiler9.getTiles = function(projection2) {
      var origin = [
        projection2.scale() * Math.PI - projection2.translate()[0],
        projection2.scale() * Math.PI - projection2.translate()[1]
      ];
      this.size(projection2.clipExtent()[1]).scale(projection2.scale() * 2 * Math.PI).translate(projection2.translate());
      var tiles = tiler9();
      var ts = tiles.scale;
      return tiles.map(function(tile) {
        if (_skipNullIsland && nearNullIsland(tile)) {
          return false;
        }
        var x2 = tile[0] * ts - origin[0];
        var y2 = tile[1] * ts - origin[1];
        return {
          id: tile.toString(),
          xyz: tile,
          extent: geoExtent(
            projection2.invert([x2, y2 + ts]),
            projection2.invert([x2 + ts, y2])
          )
        };
      }).filter(Boolean);
    };
    tiler9.getGeoJSON = function(projection2) {
      var features = tiler9.getTiles(projection2).map(function(tile) {
        return {
          type: "Feature",
          properties: {
            id: tile.id,
            name: tile.id
          },
          geometry: {
            type: "Polygon",
            coordinates: [tile.extent.polygon()]
          }
        };
      });
      return {
        type: "FeatureCollection",
        features
      };
    };
    tiler9.tileSize = function(val) {
      if (!arguments.length)
        return _tileSize;
      _tileSize = val;
      return tiler9;
    };
    tiler9.zoomExtent = function(val) {
      if (!arguments.length)
        return _zoomExtent;
      _zoomExtent = val;
      return tiler9;
    };
    tiler9.size = function(val) {
      if (!arguments.length)
        return _size;
      _size = val;
      return tiler9;
    };
    tiler9.scale = function(val) {
      if (!arguments.length)
        return _scale;
      _scale = val;
      return tiler9;
    };
    tiler9.translate = function(val) {
      if (!arguments.length)
        return _translate;
      _translate = val;
      return tiler9;
    };
    tiler9.margin = function(val) {
      if (!arguments.length)
        return _margin;
      _margin = +val;
      return tiler9;
    };
    tiler9.skipNullIsland = function(val) {
      if (!arguments.length)
        return _skipNullIsland;
      _skipNullIsland = val;
      return tiler9;
    };
    return tiler9;
  }

  // modules/util/trigger_event.js
  function utilTriggerEvent(target, type2, eventProperties) {
    target.each(function() {
      var evt = document.createEvent("HTMLEvents");
      evt.initEvent(type2, true, true);
      for (var prop in eventProperties) {
        evt[prop] = eventProperties[prop];
      }
      this.dispatchEvent(evt);
    });
  }

  // modules/util/units.js
  var OSM_PRECISION = 7;
  function displayLength(m2, isImperial) {
    var d2 = m2 * (isImperial ? 3.28084 : 1);
    var unit2;
    if (isImperial) {
      if (d2 >= 5280) {
        d2 /= 5280;
        unit2 = "miles";
      } else {
        unit2 = "feet";
      }
    } else {
      if (d2 >= 1e3) {
        d2 /= 1e3;
        unit2 = "kilometers";
      } else {
        unit2 = "meters";
      }
    }
    return _t("units." + unit2, {
      quantity: d2.toLocaleString(_mainLocalizer.localeCode(), {
        maximumSignificantDigits: 4
      })
    });
  }
  function displayArea(m2, isImperial) {
    var locale2 = _mainLocalizer.localeCode();
    var d2 = m2 * (isImperial ? 10.7639111056 : 1);
    var d1, d22, area;
    var unit1 = "";
    var unit2 = "";
    if (isImperial) {
      if (d2 >= 6969600) {
        d1 = d2 / 27878400;
        unit1 = "square_miles";
      } else {
        d1 = d2;
        unit1 = "square_feet";
      }
      if (d2 > 4356 && d2 < 4356e4) {
        d22 = d2 / 43560;
        unit2 = "acres";
      }
    } else {
      if (d2 >= 25e4) {
        d1 = d2 / 1e6;
        unit1 = "square_kilometers";
      } else {
        d1 = d2;
        unit1 = "square_meters";
      }
      if (d2 > 1e3 && d2 < 1e7) {
        d22 = d2 / 1e4;
        unit2 = "hectares";
      }
    }
    area = _t("units." + unit1, {
      quantity: d1.toLocaleString(locale2, {
        maximumSignificantDigits: 4
      })
    });
    if (d22) {
      return _t("units.area_pair", {
        area1: area,
        area2: _t("units." + unit2, {
          quantity: d22.toLocaleString(locale2, {
            maximumSignificantDigits: 2
          })
        })
      });
    } else {
      return area;
    }
  }
  function wrap(x2, min3, max3) {
    var d2 = max3 - min3;
    return ((x2 - min3) % d2 + d2) % d2 + min3;
  }
  function clamp(x2, min3, max3) {
    return Math.max(min3, Math.min(x2, max3));
  }
  function roundToDecimal(target, decimalPlace) {
    target = Number(target);
    decimalPlace = Number(decimalPlace);
    const factor = Math.pow(10, decimalPlace);
    return Math.round(target * factor) / factor;
  }
  function displayCoordinate(deg, pos, neg) {
    var displayCoordinate2;
    var locale2 = _mainLocalizer.localeCode();
    var degreesFloor = Math.floor(Math.abs(deg));
    var min3 = (Math.abs(deg) - degreesFloor) * 60;
    var minFloor = Math.floor(min3);
    var sec = (min3 - minFloor) * 60;
    var fix = roundToDecimal(sec, 8);
    var secRounded = roundToDecimal(fix, 0);
    if (secRounded === 60) {
      secRounded = 0;
      minFloor += 1;
      if (minFloor === 60) {
        minFloor = 0;
        degreesFloor += 1;
      }
    }
    displayCoordinate2 = _t("units.arcdegrees", {
      quantity: degreesFloor.toLocaleString(locale2)
    }) + (minFloor !== 0 || secRounded !== 0 ? _t("units.arcminutes", {
      quantity: minFloor.toLocaleString(locale2)
    }) : "") + (secRounded !== 0 ? _t("units.arcseconds", {
      quantity: secRounded.toLocaleString(locale2)
    }) : "");
    if (deg === 0) {
      return displayCoordinate2;
    } else {
      return _t("units.coordinate", {
        coordinate: displayCoordinate2,
        direction: _t("units." + (deg > 0 ? pos : neg))
      });
    }
  }
  function dmsCoordinatePair(coord2) {
    return _t("units.coordinate_pair", {
      latitude: displayCoordinate(clamp(coord2[1], -90, 90), "north", "south"),
      longitude: displayCoordinate(wrap(coord2[0], -180, 180), "east", "west")
    });
  }
  function decimalCoordinatePair(coord2) {
    return _t("units.coordinate_pair", {
      latitude: clamp(coord2[1], -90, 90).toFixed(OSM_PRECISION),
      longitude: wrap(coord2[0], -180, 180).toFixed(OSM_PRECISION)
    });
  }
  function dmsMatcher(q2) {
    const matchers = [
      // D M SS , D M SS  ex: 35 11 10.1 , 136 49 53.8
      {
        condition: /^\s*(-?)\s*(\d+)\s+(\d+)\s+(\d+\.?\d*)\s*\,\s*(-?)\s*(\d+)\s+(\d+)\s+(\d+\.?\d*)\s*$/,
        parser: function(q3) {
          const match = this.condition.exec(q3);
          const lat = +match[2] + +match[3] / 60 + +match[4] / 3600;
          const lng = +match[6] + +match[7] / 60 + +match[8] / 3600;
          const isNegLat = match[1] === "-" ? -lat : lat;
          const isNegLng = match[5] === "-" ? -lng : lng;
          const d2 = [isNegLat, isNegLng];
          return d2;
        }
      },
      // D MM , D MM ex: 35 11.1683 , 136 49.8966
      {
        condition: /^\s*(-?)\s*(\d+)\s+(\d+\.?\d*)\s*\,\s*(-?)\s*(\d+)\s+(\d+\.?\d*)\s*$/,
        parser: function(q3) {
          const match = this.condition.exec(q3);
          const lat = +match[2] + +match[3] / 60;
          const lng = +match[5] + +match[6] / 60;
          const isNegLat = match[1] === "-" ? -lat : lat;
          const isNegLng = match[4] === "-" ? -lng : lng;
          const d2 = [isNegLat, isNegLng];
          return d2;
        }
      }
    ];
    for (const matcher of matchers) {
      if (matcher.condition.test(q2)) {
        return matcher.parser(q2);
      }
    }
    return null;
  }

  // modules/core/localizer.js
  var _mainLocalizer = coreLocalizer();
  var _t = _mainLocalizer.t;
  function coreLocalizer() {
    let localizer = {};
    let _dataLanguages = {};
    let _dataLocales = {};
    let _localeStrings = {};
    let _localeCode = "en-US";
    let _localeCodes = ["en-US", "en"];
    let _languageCode = "en";
    let _textDirection = "ltr";
    let _usesMetric = false;
    let _languageNames = {};
    let _scriptNames = {};
    localizer.localeCode = () => _localeCode;
    localizer.localeCodes = () => _localeCodes;
    localizer.languageCode = () => _languageCode;
    localizer.textDirection = () => _textDirection;
    localizer.usesMetric = () => _usesMetric;
    localizer.languageNames = () => _languageNames;
    localizer.scriptNames = () => _scriptNames;
    let _preferredLocaleCodes = [];
    localizer.preferredLocaleCodes = function(codes) {
      if (!arguments.length)
        return _preferredLocaleCodes;
      if (typeof codes === "string") {
        _preferredLocaleCodes = codes.split(/,|;| /gi).filter(Boolean);
      } else {
        _preferredLocaleCodes = codes;
      }
      return localizer;
    };
    var _loadPromise;
    localizer.ensureLoaded = () => {
      if (_loadPromise)
        return _loadPromise;
      let filesToFetch = [
        "languages",
        // load the list of languages
        "locales"
        // load the list of supported locales
      ];
      const localeDirs = {
        general: "locales",
        tagging: presetsCdnUrl + "dist/translations"
      };
      let fileMap = _mainFileFetcher.fileMap();
      for (let scopeId in localeDirs) {
        const key = "locales_index_".concat(scopeId);
        if (!fileMap[key]) {
          fileMap[key] = localeDirs[scopeId] + "/index.min.json";
        }
        filesToFetch.push(key);
      }
      return _loadPromise = Promise.all(filesToFetch.map((key) => _mainFileFetcher.get(key))).then((results) => {
        _dataLanguages = results[0];
        _dataLocales = results[1];
        let indexes = results.slice(2);
        let requestedLocales = (_preferredLocaleCodes || []).concat(utilDetect().browserLocales).concat(["en"]);
        _localeCodes = localesToUseFrom(requestedLocales);
        _localeCode = _localeCodes[0];
        let loadStringsPromises = [];
        indexes.forEach((index, i3) => {
          const fullCoverageIndex = _localeCodes.findIndex(function(locale2) {
            return index[locale2] && index[locale2].pct === 1;
          });
          _localeCodes.slice(0, fullCoverageIndex + 1).forEach(function(code) {
            let scopeId = Object.keys(localeDirs)[i3];
            let directory = Object.values(localeDirs)[i3];
            if (index[code])
              loadStringsPromises.push(localizer.loadLocale(code, scopeId, directory));
          });
        });
        return Promise.all(loadStringsPromises);
      }).then(() => {
        updateForCurrentLocale();
      }).catch((err) => console.error(err));
    };
    function localesToUseFrom(requestedLocales) {
      let supportedLocales = _dataLocales;
      let toUse = [];
      for (let i3 in requestedLocales) {
        let locale2 = requestedLocales[i3];
        if (supportedLocales[locale2])
          toUse.push(locale2);
        if (locale2.includes("-")) {
          let langPart = locale2.split("-")[0];
          if (supportedLocales[langPart])
            toUse.push(langPart);
        }
      }
      return utilArrayUniq(toUse);
    }
    function updateForCurrentLocale() {
      if (!_localeCode)
        return;
      _languageCode = _localeCode.split("-")[0];
      const currentData = _dataLocales[_localeCode] || _dataLocales[_languageCode];
      const hash = utilStringQs(window.location.hash);
      if (hash.rtl === "true") {
        _textDirection = "rtl";
      } else if (hash.rtl === "false") {
        _textDirection = "ltr";
      } else {
        _textDirection = currentData && currentData.rtl ? "rtl" : "ltr";
      }
      let locale2 = _localeCode;
      if (locale2.toLowerCase() === "en-us")
        locale2 = "en";
      _languageNames = _localeStrings.general[locale2].languageNames || _localeStrings.general[_languageCode].languageNames;
      _scriptNames = _localeStrings.general[locale2].scriptNames || _localeStrings.general[_languageCode].scriptNames;
      _usesMetric = _localeCode.slice(-3).toLowerCase() !== "-us";
    }
    localizer.loadLocale = (locale2, scopeId, directory) => {
      if (locale2.toLowerCase() === "en-us")
        locale2 = "en";
      if (_localeStrings[scopeId] && _localeStrings[scopeId][locale2]) {
        return Promise.resolve(locale2);
      }
      let fileMap = _mainFileFetcher.fileMap();
      const key = "locale_".concat(scopeId, "_").concat(locale2);
      if (!fileMap[key]) {
        fileMap[key] = "".concat(directory, "/").concat(locale2, ".min.json");
      }
      return _mainFileFetcher.get(key).then((d2) => {
        if (!_localeStrings[scopeId])
          _localeStrings[scopeId] = {};
        _localeStrings[scopeId][locale2] = d2[locale2];
        return locale2;
      });
    };
    localizer.pluralRule = function(number3) {
      return pluralRule(number3, _localeCode);
    };
    function pluralRule(number3, localeCode) {
      const rules = "Intl" in window && Intl.PluralRules && new Intl.PluralRules(localeCode);
      if (rules) {
        return rules.select(number3);
      }
      if (number3 === 1)
        return "one";
      return "other";
    }
    localizer.tInfo = function(origStringId, replacements, locale2) {
      let stringId = origStringId.trim();
      let scopeId = "general";
      if (stringId[0] === "_") {
        let split = stringId.split(".");
        scopeId = split[0].slice(1);
        stringId = split.slice(1).join(".");
      }
      locale2 = locale2 || _localeCode;
      let path = stringId.split(".").map((s2) => s2.replace(/<TX_DOT>/g, ".")).reverse();
      let stringsKey = locale2;
      if (stringsKey.toLowerCase() === "en-us")
        stringsKey = "en";
      let result = _localeStrings && _localeStrings[scopeId] && _localeStrings[scopeId][stringsKey];
      while (result !== void 0 && path.length) {
        result = result[path.pop()];
      }
      if (result !== void 0) {
        if (replacements) {
          if (typeof result === "object" && Object.keys(result).length) {
            const number3 = Object.values(replacements).find(function(value) {
              return typeof value === "number";
            });
            if (number3 !== void 0) {
              const rule = pluralRule(number3, locale2);
              if (result[rule]) {
                result = result[rule];
              } else {
                result = Object.values(result)[0];
              }
            }
          }
          if (typeof result === "string") {
            for (let key in replacements) {
              let value = replacements[key];
              if (typeof value === "number") {
                if (value.toLocaleString) {
                  value = value.toLocaleString(locale2, {
                    style: "decimal",
                    useGrouping: true,
                    minimumFractionDigits: 0
                  });
                } else {
                  value = value.toString();
                }
              }
              const token = "{".concat(key, "}");
              const regex = new RegExp(token, "g");
              result = result.replace(regex, value);
            }
          }
        }
        if (typeof result === "string") {
          return {
            text: result,
            locale: locale2
          };
        }
      }
      let index = _localeCodes.indexOf(locale2);
      if (index >= 0 && index < _localeCodes.length - 1) {
        let fallback = _localeCodes[index + 1];
        return localizer.tInfo(origStringId, replacements, fallback);
      }
      if (replacements && "default" in replacements) {
        return {
          text: replacements.default,
          locale: null
        };
      }
      const missing = "Missing ".concat(locale2, " translation: ").concat(origStringId);
      if (typeof console !== "undefined")
        console.error(missing);
      return {
        text: missing,
        locale: "en"
      };
    };
    localizer.hasTextForStringId = function(stringId) {
      return !!localizer.tInfo(stringId, { default: "nothing found" }).locale;
    };
    localizer.t = function(stringId, replacements, locale2) {
      return localizer.tInfo(stringId, replacements, locale2).text;
    };
    localizer.t.html = function(stringId, replacements, locale2) {
      replacements = Object.assign({}, replacements);
      for (var k2 in replacements) {
        if (typeof replacements[k2] === "string") {
          replacements[k2] = escape_default(replacements[k2]);
        }
        if (typeof replacements[k2] === "object" && typeof replacements[k2].html === "string") {
          replacements[k2] = replacements[k2].html;
        }
      }
      const info = localizer.tInfo(stringId, replacements, locale2);
      if (info.text) {
        return '<span class="localized-text" lang="'.concat(info.locale || "und", '">').concat(info.text, "</span>");
      } else {
        return "";
      }
    };
    localizer.t.append = function(stringId, replacements, locale2) {
      const ret = function(selection2) {
        const info = localizer.tInfo(stringId, replacements, locale2);
        return selection2.append("span").attr("class", "localized-text").attr("lang", info.locale || "und").text((replacements && replacements.prefix || "") + info.text + (replacements && replacements.suffix || ""));
      };
      ret.stringId = stringId;
      return ret;
    };
    localizer.languageName = (code, options2) => {
      if (_languageNames && _languageNames[code]) {
        return _languageNames[code];
      }
      if (options2 && options2.localOnly)
        return null;
      const langInfo = _dataLanguages[code];
      if (langInfo) {
        if (langInfo.nativeName) {
          return localizer.t("translate.language_and_code", { language: langInfo.nativeName, code });
        } else if (langInfo.base && langInfo.script) {
          const base = langInfo.base;
          if (_languageNames && _languageNames[base]) {
            const scriptCode = langInfo.script;
            const script = _scriptNames && _scriptNames[scriptCode] || scriptCode;
            return localizer.t("translate.language_and_code", { language: _languageNames[base], code: script });
          } else if (_dataLanguages[base] && _dataLanguages[base].nativeName) {
            return localizer.t("translate.language_and_code", { language: _dataLanguages[base].nativeName, code });
          }
        }
      }
      return code;
    };
    localizer.floatFormatter = (locale2) => {
      if (!("Intl" in window && "NumberFormat" in Intl && "formatToParts" in Intl.NumberFormat.prototype)) {
        return (number3, fractionDigits) => {
          return fractionDigits === void 0 ? number3.toString() : number3.toFixed(fractionDigits);
        };
      } else {
        return (number3, fractionDigits) => number3.toLocaleString(locale2, {
          minimumFractionDigits: fractionDigits,
          maximumFractionDigits: fractionDigits === void 0 ? 20 : fractionDigits
        });
      }
    };
    localizer.floatParser = (locale2) => {
      const polyfill = (string) => +string.trim();
      if (!("Intl" in window && "NumberFormat" in Intl))
        return polyfill;
      const format2 = new Intl.NumberFormat(locale2, { maximumFractionDigits: 20 });
      if (!("formatToParts" in format2))
        return polyfill;
      const parts = format2.formatToParts(-12345.6);
      const numerals = Array.from({ length: 10 }).map((_2, i3) => format2.format(i3));
      const index = new Map(numerals.map((d2, i3) => [d2, i3]));
      const literalPart = parts.find((d2) => d2.type === "literal");
      const literal = literalPart && new RegExp("[".concat(literalPart.value, "]"), "g");
      const groupPart = parts.find((d2) => d2.type === "group");
      const group = groupPart && new RegExp("[".concat(groupPart.value, "]"), "g");
      const decimalPart = parts.find((d2) => d2.type === "decimal");
      const decimal = decimalPart && new RegExp("[".concat(decimalPart.value, "]"));
      const numeral = new RegExp("[".concat(numerals.join(""), "]"), "g");
      const getIndex = (d2) => index.get(d2);
      return (string) => {
        string = string.trim();
        if (literal)
          string = string.replace(literal, "");
        if (group)
          string = string.replace(group, "");
        if (decimal)
          string = string.replace(decimal, ".");
        string = string.replace(numeral, getIndex);
        return string ? +string : NaN;
      };
    };
    localizer.decimalPlaceCounter = (locale2) => {
      var literal, group, decimal;
      if ("Intl" in window && "NumberFormat" in Intl) {
        const format2 = new Intl.NumberFormat(locale2, { maximumFractionDigits: 20 });
        if ("formatToParts" in format2) {
          const parts = format2.formatToParts(-12345.6);
          const literalPart = parts.find((d2) => d2.type === "literal");
          literal = literalPart && new RegExp("[".concat(literalPart.value, "]"), "g");
          const groupPart = parts.find((d2) => d2.type === "group");
          group = groupPart && new RegExp("[".concat(groupPart.value, "]"), "g");
          const decimalPart = parts.find((d2) => d2.type === "decimal");
          decimal = decimalPart && new RegExp("[".concat(decimalPart.value, "]"));
        }
      }
      return (string) => {
        string = string.trim();
        if (literal)
          string = string.replace(literal, "");
        if (group)
          string = string.replace(group, "");
        const parts = string.split(decimal || ".");
        return parts && parts[1] && parts[1].length || 0;
      };
    };
    return localizer;
  }

  // modules/presets/collection.js
  function presetCollection(collection) {
    const MAXRESULTS = 50;
    let _this = {};
    let _memo = {};
    _this.collection = collection;
    _this.item = (id2) => {
      if (_memo[id2])
        return _memo[id2];
      const found = _this.collection.find((d2) => d2.id === id2);
      if (found)
        _memo[id2] = found;
      return found;
    };
    _this.index = (id2) => _this.collection.findIndex((d2) => d2.id === id2);
    _this.matchGeometry = (geometry) => {
      return presetCollection(
        _this.collection.filter((d2) => d2.matchGeometry(geometry))
      );
    };
    _this.matchAllGeometry = (geometries) => {
      return presetCollection(
        _this.collection.filter((d2) => d2 && d2.matchAllGeometry(geometries))
      );
    };
    _this.matchAnyGeometry = (geometries) => {
      return presetCollection(
        _this.collection.filter((d2) => geometries.some((geom) => d2.matchGeometry(geom)))
      );
    };
    _this.fallback = (geometry) => {
      let id2 = geometry;
      if (id2 === "vertex")
        id2 = "point";
      return _this.item(id2);
    };
    _this.search = (value, geometry, loc) => {
      if (!value)
        return _this;
      value = value.toLowerCase().trim();
      function leading(a2) {
        const index = a2.indexOf(value);
        return index === 0 || a2[index - 1] === " ";
      }
      function leadingStrict(a2) {
        const index = a2.indexOf(value);
        return index === 0;
      }
      function sortPresets(nameProp, aliasesProp) {
        return function sortNames(a2, b2) {
          let aCompare = a2[nameProp]();
          let bCompare = b2[nameProp]();
          if (aliasesProp) {
            const findMatchingAlias = (strings) => {
              if (strings.some((s2) => s2 === value)) {
                return strings.find((s2) => s2 === value);
              } else {
                return strings.filter((s2) => s2.includes(value)).sort((a3, b3) => a3.length - b3.length)[0];
              }
            };
            aCompare = findMatchingAlias([aCompare].concat(a2[aliasesProp]()));
            bCompare = findMatchingAlias([bCompare].concat(b2[aliasesProp]()));
          }
          if (value === aCompare)
            return -1;
          if (value === bCompare)
            return 1;
          let i3 = b2.originalScore - a2.originalScore;
          if (i3 !== 0)
            return i3;
          i3 = aCompare.indexOf(value) - bCompare.indexOf(value);
          if (i3 !== 0)
            return i3;
          return aCompare.length - bCompare.length;
        };
      }
      let pool = _this.collection;
      if (Array.isArray(loc)) {
        const validHere = _sharedLocationManager.locationSetsAt(loc);
        pool = pool.filter((a2) => !a2.locationSetID || validHere[a2.locationSetID]);
      }
      const searchable = pool.filter((a2) => a2.searchable !== false && a2.suggestion !== true);
      const suggestions = pool.filter((a2) => a2.suggestion === true);
      const leadingNames = searchable.filter((a2) => leading(a2.searchName()) || a2.searchAliases().some(leading)).sort(sortPresets("searchName", "searchAliases"));
      const leadingSuggestions = suggestions.filter((a2) => leadingStrict(a2.searchName())).sort(sortPresets("searchName"));
      const leadingNamesStripped = searchable.filter((a2) => leading(a2.searchNameStripped()) || a2.searchAliasesStripped().some(leading)).sort(sortPresets("searchNameStripped", "searchAliasesStripped"));
      const leadingSuggestionsStripped = suggestions.filter((a2) => leadingStrict(a2.searchNameStripped())).sort(sortPresets("searchNameStripped"));
      const leadingTerms = searchable.filter((a2) => (a2.terms() || []).some(leading));
      const leadingSuggestionTerms = suggestions.filter((a2) => (a2.terms() || []).some(leading));
      const leadingTagValues = searchable.filter((a2) => Object.values(a2.tags || {}).filter((val) => val !== "*").some(leading));
      const similarName = searchable.map((a2) => ({ preset: a2, dist: utilEditDistance(value, a2.searchName()) })).filter((a2) => a2.dist + Math.min(value.length - a2.preset.searchName().length, 0) < 3).sort((a2, b2) => a2.dist - b2.dist).map((a2) => a2.preset);
      const similarSuggestions = suggestions.map((a2) => ({ preset: a2, dist: utilEditDistance(value, a2.searchName()) })).filter((a2) => a2.dist + Math.min(value.length - a2.preset.searchName().length, 0) < 1).sort((a2, b2) => a2.dist - b2.dist).map((a2) => a2.preset);
      const similarTerms = searchable.filter((a2) => {
        return (a2.terms() || []).some((b2) => {
          return utilEditDistance(value, b2) + Math.min(value.length - b2.length, 0) < 3;
        });
      });
      let leadingTagKeyValues = [];
      if (value.includes("=")) {
        leadingTagKeyValues = searchable.filter((a2) => a2.tags && Object.keys(a2.tags).some((key) => key + "=" + a2.tags[key] === value)).concat(searchable.filter((a2) => a2.tags && Object.keys(a2.tags).some((key) => leading(key + "=" + a2.tags[key]))));
      }
      let results = leadingNames.concat(
        leadingSuggestions,
        leadingNamesStripped,
        leadingSuggestionsStripped,
        leadingTerms,
        leadingSuggestionTerms,
        leadingTagValues,
        similarName,
        similarSuggestions,
        similarTerms,
        leadingTagKeyValues
      ).slice(0, MAXRESULTS - 1);
      if (geometry) {
        if (typeof geometry === "string") {
          results.push(_this.fallback(geometry));
        } else {
          geometry.forEach((geom) => results.push(_this.fallback(geom)));
        }
      }
      return presetCollection(utilArrayUniq(results));
    };
    return _this;
  }

  // modules/presets/category.js
  function presetCategory(categoryID, category, allPresets) {
    let _this = Object.assign({}, category);
    let _searchName;
    let _searchNameStripped;
    _this.id = categoryID;
    _this.members = presetCollection(
      (category.members || []).map((presetID) => allPresets[presetID]).filter(Boolean)
    );
    _this.geometry = _this.members.collection.reduce((acc, preset) => {
      for (let i3 in preset.geometry) {
        const geometry = preset.geometry[i3];
        if (acc.indexOf(geometry) === -1) {
          acc.push(geometry);
        }
      }
      return acc;
    }, []);
    _this.matchGeometry = (geom) => _this.geometry.indexOf(geom) >= 0;
    _this.matchAllGeometry = (geometries) => _this.members.collection.some((preset) => preset.matchAllGeometry(geometries));
    _this.matchScore = () => -1;
    _this.name = () => _t("_tagging.presets.categories.".concat(categoryID, ".name"), { "default": categoryID });
    _this.nameLabel = () => _t.append("_tagging.presets.categories.".concat(categoryID, ".name"), { "default": categoryID });
    _this.terms = () => [];
    _this.searchName = () => {
      if (!_searchName) {
        _searchName = (_this.suggestion ? _this.originalName : _this.name()).toLowerCase();
      }
      return _searchName;
    };
    _this.searchNameStripped = () => {
      if (!_searchNameStripped) {
        _searchNameStripped = _this.searchName();
        if (_searchNameStripped.normalize)
          _searchNameStripped = _searchNameStripped.normalize("NFD");
        _searchNameStripped = _searchNameStripped.replace(/[\u0300-\u036f]/g, "");
      }
      return _searchNameStripped;
    };
    _this.searchAliases = () => [];
    _this.searchAliasesStripped = () => [];
    return _this;
  }

  // modules/presets/field.js
  function presetField(fieldID, field, allFields) {
    allFields = allFields || {};
    let _this = Object.assign({}, field);
    _this.id = fieldID;
    _this.safeid = utilSafeClassName(fieldID);
    _this.matchGeometry = (geom) => !_this.geometry || _this.geometry.indexOf(geom) !== -1;
    _this.matchAllGeometry = (geometries) => {
      return !_this.geometry || geometries.every((geom) => _this.geometry.indexOf(geom) !== -1);
    };
    _this.t = (scope, options2) => _t("_tagging.presets.fields.".concat(fieldID, ".").concat(scope), options2);
    _this.t.html = (scope, options2) => _t.html("_tagging.presets.fields.".concat(fieldID, ".").concat(scope), options2);
    _this.t.append = (scope, options2) => _t.append("_tagging.presets.fields.".concat(fieldID, ".").concat(scope), options2);
    _this.hasTextForStringId = (scope) => _mainLocalizer.hasTextForStringId("_tagging.presets.fields.".concat(fieldID, ".").concat(scope));
    _this.resolveReference = (which) => {
      const referenceRegex = /^\{(.*)\}$/;
      const match = (field[which] || "").match(referenceRegex);
      if (match) {
        const field2 = allFields[match[1]];
        if (field2) {
          return field2;
        }
        console.error("Unable to resolve referenced field: ".concat(match[1]));
      }
      return _this;
    };
    _this.title = () => _this.overrideLabel || _this.resolveReference("label").t("label", { "default": fieldID });
    _this.label = () => _this.overrideLabel ? (selection2) => selection2.text(_this.overrideLabel) : _this.resolveReference("label").t.append("label", { "default": fieldID });
    _this.placeholder = () => _this.resolveReference("placeholder").t("placeholder", { "default": "" });
    _this.originalTerms = (_this.terms || []).join();
    _this.terms = () => _this.resolveReference("label").t("terms", { "default": _this.originalTerms }).toLowerCase().trim().split(/\s*,+\s*/);
    _this.increment = _this.type === "number" ? _this.increment || 1 : void 0;
    return _this;
  }

  // modules/presets/preset.js
  var import_lodash = __toESM(require_lodash());
  function presetPreset(presetID, preset, addable, allFields, allPresets) {
    allFields = allFields || {};
    allPresets = allPresets || {};
    let _this = Object.assign({}, preset);
    let _addable = addable || false;
    let _searchName;
    let _searchNameStripped;
    let _searchAliases;
    let _searchAliasesStripped;
    const referenceRegex = /^\{(.*)\}$/;
    _this.id = presetID;
    _this.safeid = utilSafeClassName(presetID);
    _this.originalTerms = (_this.terms || []).join();
    _this.originalName = _this.name || "";
    _this.originalAliases = (_this.aliases || []).join("\n");
    _this.originalScore = _this.matchScore || 1;
    _this.originalReference = _this.reference || {};
    _this.originalFields = _this.fields || [];
    _this.originalMoreFields = _this.moreFields || [];
    _this.fields = (loc) => resolveFields("fields", loc);
    _this.moreFields = (loc) => resolveFields("moreFields", loc);
    _this.tags = _this.tags || {};
    _this.addTags = _this.addTags || _this.tags;
    _this.removeTags = _this.removeTags || _this.addTags;
    _this.geometry = _this.geometry || [];
    _this.matchGeometry = (geom) => _this.geometry.indexOf(geom) >= 0;
    _this.matchAllGeometry = (geoms) => geoms.every(_this.matchGeometry);
    _this.matchScore = (entityTags) => {
      const tags = _this.tags;
      let seen = {};
      let score = 0;
      for (let k2 in tags) {
        seen[k2] = true;
        if (entityTags[k2] === tags[k2]) {
          score += _this.originalScore;
        } else if (tags[k2] === "*" && k2 in entityTags) {
          score += _this.originalScore / 2;
        } else {
          return -1;
        }
      }
      const addTags = _this.addTags;
      for (let k2 in addTags) {
        if (!seen[k2] && entityTags[k2] === addTags[k2]) {
          score += _this.originalScore;
        }
      }
      if (_this.searchable === false) {
        score *= 0.999;
      }
      return score;
    };
    _this.t = (scope, options2) => {
      const textID = "_tagging.presets.presets.".concat(presetID, ".").concat(scope);
      return _t(textID, options2);
    };
    _this.t.append = (scope, options2) => {
      const textID = "_tagging.presets.presets.".concat(presetID, ".").concat(scope);
      return _t.append(textID, options2);
    };
    function resolveReference(which) {
      const match = (_this[which] || "").match(referenceRegex);
      if (match) {
        const preset2 = allPresets[match[1]];
        if (preset2) {
          return preset2;
        }
        console.error("Unable to resolve referenced preset: ".concat(match[1]));
      }
      return _this;
    }
    _this.name = () => {
      return resolveReference("originalName").t("name", { "default": _this.originalName || presetID });
    };
    _this.nameLabel = () => {
      return resolveReference("originalName").t.append("name", { "default": _this.originalName || presetID });
    };
    _this.subtitle = () => {
      if (_this.suggestion) {
        let path = presetID.split("/");
        path.pop();
        return _t("_tagging.presets.presets." + path.join("/") + ".name");
      }
      return null;
    };
    _this.subtitleLabel = () => {
      if (_this.suggestion) {
        let path = presetID.split("/");
        path.pop();
        return _t.append("_tagging.presets.presets." + path.join("/") + ".name");
      }
      return null;
    };
    _this.aliases = () => {
      return resolveReference("originalName").t("aliases", { "default": _this.originalAliases }).trim().split(/\s*[\r\n]+\s*/);
    };
    _this.terms = () => {
      return resolveReference("originalName").t("terms", { "default": _this.originalTerms }).toLowerCase().trim().split(/\s*,+\s*/);
    };
    _this.searchName = () => {
      if (!_searchName) {
        _searchName = (_this.suggestion ? _this.originalName : _this.name()).toLowerCase();
      }
      return _searchName;
    };
    _this.searchNameStripped = () => {
      if (!_searchNameStripped) {
        _searchNameStripped = stripDiacritics(_this.searchName());
      }
      return _searchNameStripped;
    };
    _this.searchAliases = () => {
      if (!_searchAliases) {
        _searchAliases = _this.aliases().map((alias) => alias.toLowerCase());
      }
      return _searchAliases;
    };
    _this.searchAliasesStripped = () => {
      if (!_searchAliasesStripped) {
        _searchAliasesStripped = _this.searchAliases();
        _searchAliasesStripped = _searchAliasesStripped.map(stripDiacritics);
      }
      return _searchAliasesStripped;
    };
    _this.isFallback = () => {
      const tagCount = Object.keys(_this.tags).length;
      return tagCount === 0 || tagCount === 1 && _this.tags.hasOwnProperty("area");
    };
    _this.addable = function(val) {
      if (!arguments.length)
        return _addable;
      _addable = val;
      return _this;
    };
    _this.reference = () => {
      const qid = _this.tags.wikidata || _this.tags["flag:wikidata"] || _this.tags["brand:wikidata"] || _this.tags["network:wikidata"] || _this.tags["operator:wikidata"];
      if (qid) {
        return { qid };
      }
      let key = _this.originalReference.key || Object.keys(utilObjectOmit(_this.tags, "name"))[0];
      let value = _this.originalReference.value || _this.tags[key];
      if (value === "*") {
        return { key };
      } else {
        return { key, value };
      }
    };
    _this.unsetTags = (tags, geometry, ignoringKeys, skipFieldDefaults, loc) => {
      let removeTags = ignoringKeys ? utilObjectOmit(_this.removeTags, ignoringKeys) : _this.removeTags;
      tags = utilObjectOmit(tags, Object.keys(removeTags));
      if (geometry && !skipFieldDefaults) {
        _this.fields(loc).forEach((field) => {
          if (field.matchGeometry(geometry) && field.key && field.default === tags[field.key] && (!ignoringKeys || ignoringKeys.indexOf(field.key) === -1)) {
            delete tags[field.key];
          }
        });
      }
      delete tags.area;
      return tags;
    };
    _this.setTags = (tags, geometry, skipFieldDefaults, loc) => {
      const addTags = _this.addTags;
      tags = Object.assign({}, tags);
      for (let k2 in addTags) {
        if (addTags[k2] === "*") {
          if (_this.tags[k2] || !tags[k2]) {
            tags[k2] = "yes";
          }
        } else {
          tags[k2] = addTags[k2];
        }
      }
      if (!addTags.hasOwnProperty("area")) {
        delete tags.area;
        if (geometry === "area") {
          let needsAreaTag = true;
          for (let k2 in addTags) {
            if (_this.geometry.indexOf("line") === -1 && k2 in osmAreaKeys || k2 in osmAreaKeysExceptions && addTags[k2] in osmAreaKeysExceptions[k2]) {
              needsAreaTag = false;
              break;
            }
          }
          if (needsAreaTag) {
            tags.area = "yes";
          }
        }
      }
      if (geometry && !skipFieldDefaults) {
        _this.fields(loc).forEach((field) => {
          if (field.matchGeometry(geometry) && field.key && !tags[field.key] && field.default) {
            tags[field.key] = field.default;
          }
        });
      }
      return tags;
    };
    function resolveFields(which, loc) {
      const fieldIDs = which === "fields" ? _this.originalFields : _this.originalMoreFields;
      let resolved = [];
      fieldIDs.forEach((fieldID) => {
        const match = fieldID.match(referenceRegex);
        if (match !== null) {
          resolved = resolved.concat(inheritFields(allPresets[match[1]], which));
        } else if (allFields[fieldID]) {
          resolved.push(allFields[fieldID]);
        } else {
          console.log('Cannot resolve "'.concat(fieldID, '" found in ').concat(_this.id, ".").concat(which));
        }
      });
      if (!resolved.length) {
        const endIndex = _this.id.lastIndexOf("/");
        const parentID = endIndex && _this.id.substring(0, endIndex);
        if (parentID) {
          let parent = allPresets[parentID];
          if (loc) {
            const validHere = _sharedLocationManager.locationSetsAt(loc);
            if ((parent == null ? void 0 : parent.locationSetID) && !validHere[parent.locationSetID]) {
              const candidateIDs = Object.keys(allPresets).filter((k2) => k2.startsWith(parentID));
              parent = allPresets[candidateIDs.find((candidateID) => {
                const candidate = allPresets[candidateID];
                return validHere[candidate.locationSetID] && (0, import_lodash.isEqual)(candidate.tags, parent.tags);
              })];
            }
          }
          resolved = inheritFields(parent, which);
        }
      }
      return utilArrayUniq(resolved);
      function inheritFields(parent, which2) {
        if (!parent)
          return [];
        if (which2 === "fields") {
          return parent.fields().filter(shouldInherit);
        } else if (which2 === "moreFields") {
          return parent.moreFields();
        } else {
          return [];
        }
      }
      function shouldInherit(f2) {
        if (f2.key && _this.tags[f2.key] !== void 0 && // inherit anyway if multiple values are allowed or just a checkbox
        f2.type !== "multiCombo" && f2.type !== "semiCombo" && f2.type !== "manyCombo" && f2.type !== "check")
          return false;
        return true;
      }
    }
    function stripDiacritics(s2) {
      if (s2.normalize)
        s2 = s2.normalize("NFD");
      s2 = s2.replace(/[\u0300-\u036f]/g, "");
      return s2;
    }
    return _this;
  }

  // modules/presets/index.js
  var _mainPresetIndex = presetIndex();
  function presetIndex() {
    const dispatch14 = dispatch_default("favoritePreset", "recentsChange");
    const MAXRECENTS = 30;
    const POINT = presetPreset("point", { name: "Point", tags: {}, geometry: ["point", "vertex"], matchScore: 0.1 });
    const LINE = presetPreset("line", { name: "Line", tags: {}, geometry: ["line"], matchScore: 0.1 });
    const AREA = presetPreset("area", { name: "Area", tags: { area: "yes" }, geometry: ["area"], matchScore: 0.1 });
    const RELATION = presetPreset("relation", { name: "Relation", tags: {}, geometry: ["relation"], matchScore: 0.1 });
    let _this = presetCollection([POINT, LINE, AREA, RELATION]);
    let _presets = { point: POINT, line: LINE, area: AREA, relation: RELATION };
    let _defaults2 = {
      point: presetCollection([POINT]),
      vertex: presetCollection([POINT]),
      line: presetCollection([LINE]),
      area: presetCollection([AREA]),
      relation: presetCollection([RELATION])
    };
    let _fields = {};
    let _categories = {};
    let _universal = [];
    let _addablePresetIDs = null;
    let _recents;
    let _favorites;
    let _geometryIndex = { point: {}, vertex: {}, line: {}, area: {}, relation: {} };
    let _loadPromise;
    _this.ensureLoaded = () => {
      if (_loadPromise)
        return _loadPromise;
      return _loadPromise = Promise.all([
        _mainFileFetcher.get("preset_categories"),
        _mainFileFetcher.get("preset_defaults"),
        _mainFileFetcher.get("preset_presets"),
        _mainFileFetcher.get("preset_fields")
      ]).then((vals) => {
        _this.merge({
          categories: vals[0],
          defaults: vals[1],
          presets: vals[2],
          fields: vals[3]
        });
        osmSetAreaKeys(_this.areaKeys());
        osmSetLineTags(_this.lineTags());
        osmSetPointTags(_this.pointTags());
        osmSetVertexTags(_this.vertexTags());
      });
    };
    _this.merge = (d2) => {
      let newLocationSets = [];
      if (d2.fields) {
        Object.keys(d2.fields).forEach((fieldID) => {
          let f2 = d2.fields[fieldID];
          if (f2) {
            f2 = presetField(fieldID, f2, _fields);
            if (f2.locationSet)
              newLocationSets.push(f2);
            _fields[fieldID] = f2;
          } else {
            delete _fields[fieldID];
          }
        });
      }
      if (d2.presets) {
        Object.keys(d2.presets).forEach((presetID) => {
          let p2 = d2.presets[presetID];
          if (p2) {
            const isAddable = !_addablePresetIDs || _addablePresetIDs.has(presetID);
            p2 = presetPreset(presetID, p2, isAddable, _fields, _presets);
            if (p2.locationSet)
              newLocationSets.push(p2);
            _presets[presetID] = p2;
          } else {
            const existing = _presets[presetID];
            if (existing && !existing.isFallback()) {
              delete _presets[presetID];
            }
          }
        });
      }
      if (d2.categories) {
        Object.keys(d2.categories).forEach((categoryID) => {
          let c2 = d2.categories[categoryID];
          if (c2) {
            c2 = presetCategory(categoryID, c2, _presets);
            if (c2.locationSet)
              newLocationSets.push(c2);
            _categories[categoryID] = c2;
          } else {
            delete _categories[categoryID];
          }
        });
      }
      _this.collection = Object.values(_presets).concat(Object.values(_categories));
      if (d2.defaults) {
        Object.keys(d2.defaults).forEach((geometry) => {
          const def2 = d2.defaults[geometry];
          if (Array.isArray(def2)) {
            _defaults2[geometry] = presetCollection(
              def2.map((id2) => _presets[id2] || _categories[id2]).filter(Boolean)
            );
          } else {
            delete _defaults2[geometry];
          }
        });
      }
      _universal = Object.values(_fields).filter((field) => field.universal);
      _geometryIndex = { point: {}, vertex: {}, line: {}, area: {}, relation: {} };
      _this.collection.forEach((preset) => {
        (preset.geometry || []).forEach((geometry) => {
          let g3 = _geometryIndex[geometry];
          for (let key in preset.tags) {
            g3[key] = g3[key] || {};
            let value = preset.tags[key];
            (g3[key][value] = g3[key][value] || []).push(preset);
          }
        });
      });
      if (d2.featureCollection && Array.isArray(d2.featureCollection.features)) {
        _sharedLocationManager.mergeCustomGeoJSON(d2.featureCollection);
      }
      if (newLocationSets.length) {
        _sharedLocationManager.mergeLocationSets(newLocationSets);
      }
      return _this;
    };
    _this.match = (entity, resolver) => {
      return resolver.transient(entity, "presetMatch", () => {
        let geometry = entity.geometry(resolver);
        if (geometry === "vertex" && entity.isOnAddressLine(resolver)) {
          geometry = "point";
        }
        const entityExtent = entity.extent(resolver);
        return _this.matchTags(entity.tags, geometry, entityExtent.center());
      });
    };
    _this.matchTags = (tags, geometry, loc) => {
      const keyIndex = _geometryIndex[geometry];
      let bestScore = -1;
      let bestMatch;
      let matchCandidates = [];
      for (let k2 in tags) {
        let indexMatches = [];
        let valueIndex = keyIndex[k2];
        if (!valueIndex)
          continue;
        let keyValueMatches = valueIndex[tags[k2]];
        if (keyValueMatches)
          indexMatches.push(...keyValueMatches);
        let keyStarMatches = valueIndex["*"];
        if (keyStarMatches)
          indexMatches.push(...keyStarMatches);
        if (indexMatches.length === 0)
          continue;
        for (let i3 = 0; i3 < indexMatches.length; i3++) {
          const candidate = indexMatches[i3];
          const score = candidate.matchScore(tags);
          if (score === -1) {
            continue;
          }
          matchCandidates.push({ score, candidate });
          if (score > bestScore) {
            bestScore = score;
            bestMatch = candidate;
          }
        }
      }
      if (bestMatch && bestMatch.locationSetID && bestMatch.locationSetID !== "+[Q2]" && Array.isArray(loc)) {
        const validHere = _sharedLocationManager.locationSetsAt(loc);
        if (!validHere[bestMatch.locationSetID]) {
          matchCandidates.sort((a2, b2) => a2.score < b2.score ? 1 : -1);
          for (let i3 = 0; i3 < matchCandidates.length; i3++) {
            const candidateScore = matchCandidates[i3];
            if (!candidateScore.candidate.locationSetID || validHere[candidateScore.candidate.locationSetID]) {
              bestMatch = candidateScore.candidate;
              bestScore = candidateScore.score;
              break;
            }
          }
        }
      }
      if (!bestMatch || bestMatch.isFallback()) {
        for (let k2 in tags) {
          if (/^addr:/.test(k2) && keyIndex["addr:*"] && keyIndex["addr:*"]["*"]) {
            bestMatch = keyIndex["addr:*"]["*"][0];
            break;
          }
        }
      }
      return bestMatch || _this.fallback(geometry);
    };
    _this.allowsVertex = (entity, resolver) => {
      if (entity.type !== "node")
        return false;
      if (Object.keys(entity.tags).length === 0)
        return true;
      return resolver.transient(entity, "vertexMatch", () => {
        if (entity.isOnAddressLine(resolver))
          return true;
        const geometries = osmNodeGeometriesForTags(entity.tags);
        if (geometries.vertex)
          return true;
        if (geometries.point)
          return false;
        return true;
      });
    };
    _this.areaKeys = () => {
      const ignore = {
        barrier: true,
        highway: true,
        footway: true,
        railway: true,
        junction: true,
        type: true
      };
      let areaKeys = {};
      const presets = _this.collection.filter((p2) => !p2.suggestion && !p2.replacement);
      presets.forEach((p2) => {
        const keys2 = p2.tags && Object.keys(p2.tags);
        const key = keys2 && keys2.length && keys2[0];
        if (!key)
          return;
        if (ignore[key])
          return;
        if (p2.geometry.indexOf("area") !== -1) {
          areaKeys[key] = areaKeys[key] || {};
        }
      });
      presets.forEach((p2) => {
        let key;
        for (key in p2.addTags) {
          const value = p2.addTags[key];
          if (key in areaKeys && // probably an area...
          p2.geometry.indexOf("line") !== -1 && // but sometimes a line
          value !== "*") {
            areaKeys[key][value] = true;
          }
        }
      });
      return areaKeys;
    };
    _this.lineTags = () => {
      return _this.collection.filter((lineTags, d2) => {
        if (d2.suggestion || d2.replacement || d2.searchable === false)
          return lineTags;
        const keys2 = d2.tags && Object.keys(d2.tags);
        const key = keys2 && keys2.length && keys2[0];
        if (!key)
          return lineTags;
        if (d2.geometry.indexOf("line") !== -1) {
          lineTags[key] = lineTags[key] || [];
          lineTags[key].push(d2.tags);
        }
        return lineTags;
      }, {});
    };
    _this.pointTags = () => {
      return _this.collection.reduce((pointTags, d2) => {
        if (d2.suggestion || d2.replacement || d2.searchable === false)
          return pointTags;
        const keys2 = d2.tags && Object.keys(d2.tags);
        const key = keys2 && keys2.length && keys2[0];
        if (!key)
          return pointTags;
        if (d2.geometry.indexOf("point") !== -1) {
          pointTags[key] = pointTags[key] || {};
          pointTags[key][d2.tags[key]] = true;
        }
        return pointTags;
      }, {});
    };
    _this.vertexTags = () => {
      return _this.collection.reduce((vertexTags, d2) => {
        if (d2.suggestion || d2.replacement || d2.searchable === false)
          return vertexTags;
        const keys2 = d2.tags && Object.keys(d2.tags);
        const key = keys2 && keys2.length && keys2[0];
        if (!key)
          return vertexTags;
        if (d2.geometry.indexOf("vertex") !== -1) {
          vertexTags[key] = vertexTags[key] || {};
          vertexTags[key][d2.tags[key]] = true;
        }
        return vertexTags;
      }, {});
    };
    _this.field = (id2) => _fields[id2];
    _this.universal = () => _universal;
    _this.defaults = (geometry, n3, startWithRecents, loc, extraPresets) => {
      let recents = [];
      if (startWithRecents) {
        recents = _this.recent().matchGeometry(geometry).collection.slice(0, 4);
      }
      let defaults;
      if (_addablePresetIDs) {
        defaults = Array.from(_addablePresetIDs).map(function(id2) {
          var preset = _this.item(id2);
          if (preset && preset.matchGeometry(geometry))
            return preset;
          return null;
        }).filter(Boolean);
      } else {
        defaults = _defaults2[geometry].collection.concat(_this.fallback(geometry));
      }
      let result = presetCollection(
        utilArrayUniq(recents.concat(defaults).concat(extraPresets || [])).slice(0, n3 - 1)
      );
      if (Array.isArray(loc)) {
        const validHere = _sharedLocationManager.locationSetsAt(loc);
        result.collection = result.collection.filter((a2) => !a2.locationSetID || validHere[a2.locationSetID]);
      }
      return result;
    };
    _this.addablePresetIDs = function(val) {
      if (!arguments.length)
        return _addablePresetIDs;
      if (Array.isArray(val))
        val = new Set(val);
      _addablePresetIDs = val;
      if (_addablePresetIDs) {
        _this.collection.forEach((p2) => {
          if (p2.addable)
            p2.addable(_addablePresetIDs.has(p2.id));
        });
      } else {
        _this.collection.forEach((p2) => {
          if (p2.addable)
            p2.addable(true);
        });
      }
      return _this;
    };
    _this.recent = () => {
      return presetCollection(
        utilArrayUniq(_this.getRecents().map((d2) => d2.preset).filter((d2) => d2.searchable !== false))
      );
    };
    function RibbonItem(preset, source) {
      let item = {};
      item.preset = preset;
      item.source = source;
      item.isFavorite = () => item.source === "favorite";
      item.isRecent = () => item.source === "recent";
      item.matches = (preset2) => item.preset.id === preset2.id;
      item.minified = () => ({ pID: item.preset.id });
      return item;
    }
    function ribbonItemForMinified(d2, source) {
      if (d2 && d2.pID) {
        const preset = _this.item(d2.pID);
        if (!preset)
          return null;
        return RibbonItem(preset, source);
      }
      return null;
    }
    _this.getGenericRibbonItems = () => {
      return ["point", "line", "area"].map((id2) => RibbonItem(_this.item(id2), "generic"));
    };
    _this.getAddable = () => {
      if (!_addablePresetIDs)
        return [];
      return _addablePresetIDs.map((id2) => {
        const preset = _this.item(id2);
        if (preset)
          return RibbonItem(preset, "addable");
        return null;
      }).filter(Boolean);
    };
    function setRecents(items) {
      _recents = items;
      const minifiedItems = items.map((d2) => d2.minified());
      corePreferences("preset_recents", JSON.stringify(minifiedItems));
      dispatch14.call("recentsChange");
    }
    _this.getRecents = () => {
      if (!_recents) {
        _recents = (JSON.parse(corePreferences("preset_recents")) || []).reduce((acc, d2) => {
          let item = ribbonItemForMinified(d2, "recent");
          if (item && item.preset.addable())
            acc.push(item);
          return acc;
        }, []);
      }
      return _recents;
    };
    _this.addRecent = (preset, besidePreset, after) => {
      const recents = _this.getRecents();
      const beforeItem = _this.recentMatching(besidePreset);
      let toIndex = recents.indexOf(beforeItem);
      if (after)
        toIndex += 1;
      const newItem = RibbonItem(preset, "recent");
      recents.splice(toIndex, 0, newItem);
      setRecents(recents);
    };
    _this.removeRecent = (preset) => {
      const item = _this.recentMatching(preset);
      if (item) {
        let items = _this.getRecents();
        items.splice(items.indexOf(item), 1);
        setRecents(items);
      }
    };
    _this.recentMatching = (preset) => {
      const items = _this.getRecents();
      for (let i3 in items) {
        if (items[i3].matches(preset)) {
          return items[i3];
        }
      }
      return null;
    };
    _this.moveItem = (items, fromIndex, toIndex) => {
      if (fromIndex === toIndex || fromIndex < 0 || toIndex < 0 || fromIndex >= items.length || toIndex >= items.length)
        return null;
      items.splice(toIndex, 0, items.splice(fromIndex, 1)[0]);
      return items;
    };
    _this.moveRecent = (item, beforeItem) => {
      const recents = _this.getRecents();
      const fromIndex = recents.indexOf(item);
      const toIndex = recents.indexOf(beforeItem);
      const items = _this.moveItem(recents, fromIndex, toIndex);
      if (items)
        setRecents(items);
    };
    _this.setMostRecent = (preset) => {
      if (preset.searchable === false)
        return;
      let items = _this.getRecents();
      let item = _this.recentMatching(preset);
      if (item) {
        items.splice(items.indexOf(item), 1);
      } else {
        item = RibbonItem(preset, "recent");
      }
      while (items.length >= MAXRECENTS) {
        items.pop();
      }
      items.unshift(item);
      setRecents(items);
    };
    function setFavorites(items) {
      _favorites = items;
      const minifiedItems = items.map((d2) => d2.minified());
      corePreferences("preset_favorites", JSON.stringify(minifiedItems));
      dispatch14.call("favoritePreset");
    }
    _this.addFavorite = (preset, besidePreset, after) => {
      const favorites = _this.getFavorites();
      const beforeItem = _this.favoriteMatching(besidePreset);
      let toIndex = favorites.indexOf(beforeItem);
      if (after)
        toIndex += 1;
      const newItem = RibbonItem(preset, "favorite");
      favorites.splice(toIndex, 0, newItem);
      setFavorites(favorites);
    };
    _this.toggleFavorite = (preset) => {
      const favs = _this.getFavorites();
      const favorite = _this.favoriteMatching(preset);
      if (favorite) {
        favs.splice(favs.indexOf(favorite), 1);
      } else {
        if (favs.length === 10) {
          favs.pop();
        }
        favs.push(RibbonItem(preset, "favorite"));
      }
      setFavorites(favs);
    };
    _this.removeFavorite = (preset) => {
      const item = _this.favoriteMatching(preset);
      if (item) {
        const items = _this.getFavorites();
        items.splice(items.indexOf(item), 1);
        setFavorites(items);
      }
    };
    _this.getFavorites = () => {
      if (!_favorites) {
        let rawFavorites = JSON.parse(corePreferences("preset_favorites"));
        if (!rawFavorites) {
          rawFavorites = [];
          corePreferences("preset_favorites", JSON.stringify(rawFavorites));
        }
        _favorites = rawFavorites.reduce((output, d2) => {
          const item = ribbonItemForMinified(d2, "favorite");
          if (item && item.preset.addable())
            output.push(item);
          return output;
        }, []);
      }
      return _favorites;
    };
    _this.favoriteMatching = (preset) => {
      const favs = _this.getFavorites();
      for (let index in favs) {
        if (favs[index].matches(preset)) {
          return favs[index];
        }
      }
      return null;
    };
    return utilRebind(_this, dispatch14, "on");
  }

  // modules/util/util.js
  function utilTagText(entity) {
    var obj = entity && entity.tags || {};
    return Object.keys(obj).map(function(k2) {
      return k2 + "=" + obj[k2];
    }).join(", ");
  }
  function utilTotalExtent(array2, graph) {
    var extent = geoExtent();
    var val, entity;
    for (var i3 = 0; i3 < array2.length; i3++) {
      val = array2[i3];
      entity = typeof val === "string" ? graph.hasEntity(val) : val;
      if (entity) {
        extent._extend(entity.extent(graph));
      }
    }
    return extent;
  }
  function utilTagDiff(oldTags, newTags) {
    var tagDiff = [];
    var keys2 = utilArrayUnion(Object.keys(oldTags), Object.keys(newTags)).sort();
    keys2.forEach(function(k2) {
      var oldVal = oldTags[k2];
      var newVal = newTags[k2];
      if ((oldVal || oldVal === "") && (newVal === void 0 || newVal !== oldVal)) {
        tagDiff.push({
          type: "-",
          key: k2,
          oldVal,
          newVal,
          display: "- " + k2 + "=" + oldVal
        });
      }
      if ((newVal || newVal === "") && (oldVal === void 0 || newVal !== oldVal)) {
        tagDiff.push({
          type: "+",
          key: k2,
          oldVal,
          newVal,
          display: "+ " + k2 + "=" + newVal
        });
      }
    });
    return tagDiff;
  }
  function utilEntitySelector(ids) {
    return ids.length ? "." + ids.join(",.") : "nothing";
  }
  function utilEntityOrMemberSelector(ids, graph) {
    var seen = new Set(ids);
    ids.forEach(collectShallowDescendants);
    return utilEntitySelector(Array.from(seen));
    function collectShallowDescendants(id2) {
      var entity = graph.hasEntity(id2);
      if (!entity || entity.type !== "relation")
        return;
      entity.members.map(function(member) {
        return member.id;
      }).forEach(function(id3) {
        seen.add(id3);
      });
    }
  }
  function utilEntityOrDeepMemberSelector(ids, graph) {
    return utilEntitySelector(utilEntityAndDeepMemberIDs(ids, graph));
  }
  function utilEntityAndDeepMemberIDs(ids, graph) {
    var seen = /* @__PURE__ */ new Set();
    ids.forEach(collectDeepDescendants);
    return Array.from(seen);
    function collectDeepDescendants(id2) {
      if (seen.has(id2))
        return;
      seen.add(id2);
      var entity = graph.hasEntity(id2);
      if (!entity || entity.type !== "relation")
        return;
      entity.members.map(function(member) {
        return member.id;
      }).forEach(collectDeepDescendants);
    }
  }
  function utilDeepMemberSelector(ids, graph, skipMultipolgonMembers) {
    var idsSet = new Set(ids);
    var seen = /* @__PURE__ */ new Set();
    var returners = /* @__PURE__ */ new Set();
    ids.forEach(collectDeepDescendants);
    return utilEntitySelector(Array.from(returners));
    function collectDeepDescendants(id2) {
      if (seen.has(id2))
        return;
      seen.add(id2);
      if (!idsSet.has(id2)) {
        returners.add(id2);
      }
      var entity = graph.hasEntity(id2);
      if (!entity || entity.type !== "relation")
        return;
      if (skipMultipolgonMembers && entity.isMultipolygon())
        return;
      entity.members.map(function(member) {
        return member.id;
      }).forEach(collectDeepDescendants);
    }
  }
  function utilHighlightEntities(ids, highlighted, context) {
    context.surface().selectAll(utilEntityOrDeepMemberSelector(ids, context.graph())).classed("highlighted", highlighted);
  }
  function utilGetAllNodes(ids, graph) {
    var seen = /* @__PURE__ */ new Set();
    var nodes = /* @__PURE__ */ new Set();
    ids.forEach(collectNodes);
    return Array.from(nodes);
    function collectNodes(id2) {
      if (seen.has(id2))
        return;
      seen.add(id2);
      var entity = graph.hasEntity(id2);
      if (!entity)
        return;
      if (entity.type === "node") {
        nodes.add(entity);
      } else if (entity.type === "way") {
        entity.nodes.forEach(collectNodes);
      } else {
        entity.members.map(function(member) {
          return member.id;
        }).forEach(collectNodes);
      }
    }
  }
  function utilDisplayName(entity) {
    var localizedNameKey = "name:" + _mainLocalizer.languageCode().toLowerCase();
    var name = entity.tags[localizedNameKey] || entity.tags.name || "";
    if (name)
      return name;
    var tags = {
      direction: entity.tags.direction,
      from: entity.tags.from,
      network: entity.tags.cycle_network || entity.tags.network,
      ref: entity.tags.ref,
      to: entity.tags.to,
      via: entity.tags.via
    };
    var keyComponents = [];
    if (tags.network) {
      keyComponents.push("network");
    }
    if (tags.ref) {
      keyComponents.push("ref");
    }
    if (entity.tags.route) {
      if (tags.direction) {
        keyComponents.push("direction");
      } else if (tags.from && tags.to) {
        keyComponents.push("from");
        keyComponents.push("to");
        if (tags.via) {
          keyComponents.push("via");
        }
      }
    }
    if (keyComponents.length) {
      name = _t("inspector.display_name." + keyComponents.join("_"), tags);
    }
    return name;
  }
  function utilDisplayNameForPath(entity) {
    var name = utilDisplayName(entity);
    var isFirefox = utilDetect().browser.toLowerCase().indexOf("firefox") > -1;
    var isNewChromium = Number(utilDetect().version.split(".")[0]) >= 96;
    if (!isFirefox && !isNewChromium && name && rtlRegex.test(name)) {
      name = fixRTLTextForSvg(name);
    }
    return name;
  }
  function utilDisplayType(id2) {
    return {
      n: _t("inspector.node"),
      w: _t("inspector.way"),
      r: _t("inspector.relation")
    }[id2.charAt(0)];
  }
  function utilDisplayLabel(entity, graphOrGeometry, verbose) {
    var result;
    var displayName = utilDisplayName(entity);
    var preset = typeof graphOrGeometry === "string" ? _mainPresetIndex.matchTags(entity.tags, graphOrGeometry) : _mainPresetIndex.match(entity, graphOrGeometry);
    var presetName = preset && (preset.suggestion ? preset.subtitle() : preset.name());
    if (verbose) {
      result = [presetName, displayName].filter(Boolean).join(" ");
    } else {
      result = displayName || presetName;
    }
    return result || utilDisplayType(entity.id);
  }
  function utilEntityRoot(entityType) {
    return {
      node: "n",
      way: "w",
      relation: "r"
    }[entityType];
  }
  function utilCombinedTags(entityIDs, graph) {
    var tags = {};
    var tagCounts = {};
    var allKeys = /* @__PURE__ */ new Set();
    var entities = entityIDs.map(function(entityID) {
      return graph.hasEntity(entityID);
    }).filter(Boolean);
    entities.forEach(function(entity) {
      var keys2 = Object.keys(entity.tags).filter(Boolean);
      keys2.forEach(function(key2) {
        allKeys.add(key2);
      });
    });
    entities.forEach(function(entity) {
      allKeys.forEach(function(key2) {
        var value = entity.tags[key2];
        if (!tags.hasOwnProperty(key2)) {
          tags[key2] = value;
        } else {
          if (!Array.isArray(tags[key2])) {
            if (tags[key2] !== value) {
              tags[key2] = [tags[key2], value];
            }
          } else {
            if (tags[key2].indexOf(value) === -1) {
              tags[key2].push(value);
            }
          }
        }
        var tagHash = key2 + "=" + value;
        if (!tagCounts[tagHash])
          tagCounts[tagHash] = 0;
        tagCounts[tagHash] += 1;
      });
    });
    for (var key in tags) {
      if (!Array.isArray(tags[key]))
        continue;
      tags[key] = tags[key].sort(function(val12, val2) {
        var key2 = key2;
        var count2 = tagCounts[key2 + "=" + val2];
        var count1 = tagCounts[key2 + "=" + val12];
        if (count2 !== count1) {
          return count2 - count1;
        }
        if (val2 && val12) {
          return val12.localeCompare(val2);
        }
        return val12 ? 1 : -1;
      });
    }
    return tags;
  }
  function utilStringQs(str) {
    var i3 = 0;
    while (i3 < str.length && (str[i3] === "?" || str[i3] === "#"))
      i3++;
    str = str.slice(i3);
    return str.split("&").reduce(function(obj, pair3) {
      var parts = pair3.split("=");
      if (parts.length === 2) {
        obj[parts[0]] = null === parts[1] ? "" : decodeURIComponent(parts[1]);
      }
      return obj;
    }, {});
  }
  function utilQsString(obj, noencode) {
    function softEncode(s2) {
      return encodeURIComponent(s2).replace(/(%2F|%3A|%2C|%7B|%7D)/g, decodeURIComponent);
    }
    return Object.keys(obj).sort().map(function(key) {
      return encodeURIComponent(key) + "=" + (noencode ? softEncode(obj[key]) : encodeURIComponent(obj[key]));
    }).join("&");
  }
  function utilPrefixDOMProperty(property) {
    var prefixes2 = ["webkit", "ms", "moz", "o"];
    var i3 = -1;
    var n3 = prefixes2.length;
    var s2 = document.body;
    if (property in s2)
      return property;
    property = property.slice(0, 1).toUpperCase() + property.slice(1);
    while (++i3 < n3) {
      if (prefixes2[i3] + property in s2) {
        return prefixes2[i3] + property;
      }
    }
    return false;
  }
  function utilPrefixCSSProperty(property) {
    var prefixes2 = ["webkit", "ms", "Moz", "O"];
    var i3 = -1;
    var n3 = prefixes2.length;
    var s2 = document.body.style;
    if (property.toLowerCase() in s2) {
      return property.toLowerCase();
    }
    while (++i3 < n3) {
      if (prefixes2[i3] + property in s2) {
        return "-" + prefixes2[i3].toLowerCase() + property.replace(/([A-Z])/g, "-$1").toLowerCase();
      }
    }
    return false;
  }
  var transformProperty;
  function utilSetTransform(el, x2, y2, scale) {
    var prop = transformProperty = transformProperty || utilPrefixCSSProperty("Transform");
    var translate = utilDetect().opera ? "translate(" + x2 + "px," + y2 + "px)" : "translate3d(" + x2 + "px," + y2 + "px,0)";
    return el.style(prop, translate + (scale ? " scale(" + scale + ")" : ""));
  }
  function utilEditDistance(a2, b2) {
    a2 = (0, import_diacritics.remove)(a2.toLowerCase());
    b2 = (0, import_diacritics.remove)(b2.toLowerCase());
    if (a2.length === 0)
      return b2.length;
    if (b2.length === 0)
      return a2.length;
    var matrix = [];
    var i3, j2;
    for (i3 = 0; i3 <= b2.length; i3++) {
      matrix[i3] = [i3];
    }
    for (j2 = 0; j2 <= a2.length; j2++) {
      matrix[0][j2] = j2;
    }
    for (i3 = 1; i3 <= b2.length; i3++) {
      for (j2 = 1; j2 <= a2.length; j2++) {
        if (b2.charAt(i3 - 1) === a2.charAt(j2 - 1)) {
          matrix[i3][j2] = matrix[i3 - 1][j2 - 1];
        } else {
          matrix[i3][j2] = Math.min(
            matrix[i3 - 1][j2 - 1] + 1,
            // substitution
            Math.min(
              matrix[i3][j2 - 1] + 1,
              // insertion
              matrix[i3 - 1][j2] + 1
            )
          );
        }
      }
    }
    return matrix[b2.length][a2.length];
  }
  function utilFastMouse(container) {
    var rect = container.getBoundingClientRect();
    var rectLeft = rect.left;
    var rectTop = rect.top;
    var clientLeft = +container.clientLeft;
    var clientTop = +container.clientTop;
    return function(e3) {
      return [
        e3.clientX - rectLeft - clientLeft,
        e3.clientY - rectTop - clientTop
      ];
    };
  }
  function utilAsyncMap(inputs, func, callback) {
    var remaining = inputs.length;
    var results = [];
    var errors = [];
    inputs.forEach(function(d2, i3) {
      func(d2, function done(err, data) {
        errors[i3] = err;
        results[i3] = data;
        remaining--;
        if (!remaining)
          callback(errors, results);
      });
    });
  }
  function utilWrap(index, length2) {
    if (index < 0) {
      index += Math.ceil(-index / length2) * length2;
    }
    return index % length2;
  }
  function utilFunctor(value) {
    if (typeof value === "function")
      return value;
    return function() {
      return value;
    };
  }
  function utilNoAuto(selection2) {
    var isText = selection2.size() && selection2.node().tagName.toLowerCase() === "textarea";
    return selection2.attr("autocomplete", "new-password").attr("autocorrect", "off").attr("autocapitalize", "off").attr("spellcheck", isText ? "true" : "false");
  }
  function utilHashcode(str) {
    var hash = 0;
    if (str.length === 0) {
      return hash;
    }
    for (var i3 = 0; i3 < str.length; i3++) {
      var char = str.charCodeAt(i3);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash;
  }
  function utilSafeClassName(str) {
    return str.toLowerCase().replace(/[^a-z0-9]+/g, "_");
  }
  function utilUniqueDomId(val) {
    return "ideditor-" + utilSafeClassName(val.toString()) + "-" + (/* @__PURE__ */ new Date()).getTime().toString();
  }
  function utilUnicodeCharsCount(str) {
    return Array.from(str).length;
  }
  function utilUnicodeCharsTruncated(str, limit) {
    return Array.from(str).slice(0, limit).join("");
  }
  function toNumericID(id2) {
    var match = id2.match(/^[cnwr](-?\d+)$/);
    if (match) {
      return parseInt(match[1], 10);
    }
    return NaN;
  }
  function compareNumericIDs(left, right) {
    if (isNaN(left) && isNaN(right))
      return -1;
    if (isNaN(left))
      return 1;
    if (isNaN(right))
      return -1;
    if (Math.sign(left) !== Math.sign(right))
      return -Math.sign(left);
    if (Math.sign(left) < 0)
      return Math.sign(right - left);
    return Math.sign(left - right);
  }
  function utilCompareIDs(left, right) {
    return compareNumericIDs(toNumericID(left), toNumericID(right));
  }
  function utilOldestID(ids) {
    if (ids.length === 0) {
      return void 0;
    }
    var oldestIDIndex = 0;
    var oldestID = toNumericID(ids[0]);
    for (var i3 = 1; i3 < ids.length; i3++) {
      var num = toNumericID(ids[i3]);
      if (compareNumericIDs(oldestID, num) === 1) {
        oldestIDIndex = i3;
        oldestID = num;
      }
    }
    return ids[oldestIDIndex];
  }
  function utilCleanOsmString(val, maxChars) {
    if (val === void 0 || val === null) {
      val = "";
    } else {
      val = val.toString();
    }
    val = val.trim();
    if (val.normalize)
      val = val.normalize("NFC");
    return utilUnicodeCharsTruncated(val, maxChars);
  }

  // modules/osm/entity.js
  function osmEntity(attrs) {
    if (this instanceof osmEntity)
      return;
    if (attrs && attrs.type) {
      return osmEntity[attrs.type].apply(this, arguments);
    } else if (attrs && attrs.id) {
      return osmEntity[osmEntity.id.type(attrs.id)].apply(this, arguments);
    }
    return new osmEntity().initialize(arguments);
  }
  osmEntity.id = function(type2) {
    return osmEntity.id.fromOSM(type2, osmEntity.id.next[type2]--);
  };
  osmEntity.id.next = {
    changeset: -1,
    node: -1,
    way: -1,
    relation: -1
  };
  osmEntity.id.fromOSM = function(type2, id2) {
    return type2[0] + id2;
  };
  osmEntity.id.toOSM = function(id2) {
    var match = id2.match(/^[cnwr](-?\d+)$/);
    if (match) {
      return match[1];
    }
    return "";
  };
  osmEntity.id.type = function(id2) {
    return { "c": "changeset", "n": "node", "w": "way", "r": "relation" }[id2[0]];
  };
  osmEntity.key = function(entity) {
    return entity.id + "v" + (entity.v || 0);
  };
  var _deprecatedTagValuesByKey;
  osmEntity.deprecatedTagValuesByKey = function(dataDeprecated) {
    if (!_deprecatedTagValuesByKey) {
      _deprecatedTagValuesByKey = {};
      dataDeprecated.forEach(function(d2) {
        var oldKeys = Object.keys(d2.old);
        if (oldKeys.length === 1) {
          var oldKey = oldKeys[0];
          var oldValue = d2.old[oldKey];
          if (oldValue !== "*") {
            if (!_deprecatedTagValuesByKey[oldKey]) {
              _deprecatedTagValuesByKey[oldKey] = [oldValue];
            } else {
              _deprecatedTagValuesByKey[oldKey].push(oldValue);
            }
          }
        }
      });
    }
    return _deprecatedTagValuesByKey;
  };
  osmEntity.prototype = {
    tags: {},
    initialize: function(sources) {
      for (var i3 = 0; i3 < sources.length; ++i3) {
        var source = sources[i3];
        for (var prop in source) {
          if (Object.prototype.hasOwnProperty.call(source, prop)) {
            if (source[prop] === void 0) {
              delete this[prop];
            } else {
              this[prop] = source[prop];
            }
          }
        }
      }
      if (!this.id && this.type) {
        this.id = osmEntity.id(this.type);
      }
      if (!this.hasOwnProperty("visible")) {
        this.visible = true;
      }
      if (debug) {
        Object.freeze(this);
        Object.freeze(this.tags);
        if (this.loc)
          Object.freeze(this.loc);
        if (this.nodes)
          Object.freeze(this.nodes);
        if (this.members)
          Object.freeze(this.members);
      }
      return this;
    },
    copy: function(resolver, copies) {
      if (copies[this.id])
        return copies[this.id];
      var copy2 = osmEntity(this, { id: void 0, user: void 0, version: void 0 });
      copies[this.id] = copy2;
      return copy2;
    },
    osmId: function() {
      return osmEntity.id.toOSM(this.id);
    },
    isNew: function() {
      var osmId = osmEntity.id.toOSM(this.id);
      return osmId.length === 0 || osmId[0] === "-";
    },
    update: function(attrs) {
      return osmEntity(this, attrs, { v: 1 + (this.v || 0) });
    },
    mergeTags: function(tags) {
      var merged = Object.assign({}, this.tags);
      var changed = false;
      for (var k2 in tags) {
        var t1 = merged[k2];
        var t2 = tags[k2];
        if (!t1) {
          changed = true;
          merged[k2] = t2;
        } else if (t1 !== t2) {
          changed = true;
          merged[k2] = utilUnicodeCharsTruncated(
            utilArrayUnion(t1.split(/;\s*/), t2.split(/;\s*/)).join(";"),
            255
            // avoid exceeding character limit; see also context.maxCharsForTagValue()
          );
        }
      }
      return changed ? this.update({ tags: merged }) : this;
    },
    intersects: function(extent, resolver) {
      return this.extent(resolver).intersects(extent);
    },
    hasNonGeometryTags: function() {
      return Object.keys(this.tags).some(function(k2) {
        return k2 !== "area";
      });
    },
    hasParentRelations: function(resolver) {
      return resolver.parentRelations(this).length > 0;
    },
    hasInterestingTags: function() {
      return Object.keys(this.tags).some(osmIsInterestingTag);
    },
    isHighwayIntersection: function() {
      return false;
    },
    isDegenerate: function() {
      return true;
    },
    deprecatedTags: function(dataDeprecated) {
      var tags = this.tags;
      if (Object.keys(tags).length === 0)
        return [];
      var deprecated = [];
      dataDeprecated.forEach(function(d2) {
        var oldKeys = Object.keys(d2.old);
        if (d2.replace) {
          var hasExistingValues = Object.keys(d2.replace).some(function(replaceKey) {
            if (!tags[replaceKey] || d2.old[replaceKey])
              return false;
            var replaceValue = d2.replace[replaceKey];
            if (replaceValue === "*")
              return false;
            if (replaceValue === tags[replaceKey])
              return false;
            return true;
          });
          if (hasExistingValues)
            return;
        }
        var matchesDeprecatedTags = oldKeys.every(function(oldKey) {
          if (!tags[oldKey])
            return false;
          if (d2.old[oldKey] === "*")
            return true;
          if (d2.old[oldKey] === tags[oldKey])
            return true;
          var vals = tags[oldKey].split(";").filter(Boolean);
          if (vals.length === 0) {
            return false;
          } else if (vals.length > 1) {
            return vals.indexOf(d2.old[oldKey]) !== -1;
          } else {
            if (tags[oldKey] === d2.old[oldKey]) {
              if (d2.replace && d2.old[oldKey] === d2.replace[oldKey]) {
                var replaceKeys = Object.keys(d2.replace);
                return !replaceKeys.every(function(replaceKey) {
                  return tags[replaceKey] === d2.replace[replaceKey];
                });
              } else {
                return true;
              }
            }
          }
          return false;
        });
        if (matchesDeprecatedTags) {
          deprecated.push(d2);
        }
      });
      return deprecated;
    }
  };

  // modules/osm/lanes.js
  function osmLanes(entity) {
    if (entity.type !== "way")
      return null;
    if (!entity.tags.highway)
      return null;
    var tags = entity.tags;
    var isOneWay = entity.isOneWay();
    var laneCount = getLaneCount(tags, isOneWay);
    var maxspeed = parseMaxspeed(tags);
    var laneDirections = parseLaneDirections(tags, isOneWay, laneCount);
    var forward = laneDirections.forward;
    var backward = laneDirections.backward;
    var bothways = laneDirections.bothways;
    var turnLanes = {};
    turnLanes.unspecified = parseTurnLanes(tags["turn:lanes"]);
    turnLanes.forward = parseTurnLanes(tags["turn:lanes:forward"]);
    turnLanes.backward = parseTurnLanes(tags["turn:lanes:backward"]);
    var maxspeedLanes = {};
    maxspeedLanes.unspecified = parseMaxspeedLanes(tags["maxspeed:lanes"], maxspeed);
    maxspeedLanes.forward = parseMaxspeedLanes(tags["maxspeed:lanes:forward"], maxspeed);
    maxspeedLanes.backward = parseMaxspeedLanes(tags["maxspeed:lanes:backward"], maxspeed);
    var psvLanes = {};
    psvLanes.unspecified = parseMiscLanes(tags["psv:lanes"]);
    psvLanes.forward = parseMiscLanes(tags["psv:lanes:forward"]);
    psvLanes.backward = parseMiscLanes(tags["psv:lanes:backward"]);
    var busLanes = {};
    busLanes.unspecified = parseMiscLanes(tags["bus:lanes"]);
    busLanes.forward = parseMiscLanes(tags["bus:lanes:forward"]);
    busLanes.backward = parseMiscLanes(tags["bus:lanes:backward"]);
    var taxiLanes = {};
    taxiLanes.unspecified = parseMiscLanes(tags["taxi:lanes"]);
    taxiLanes.forward = parseMiscLanes(tags["taxi:lanes:forward"]);
    taxiLanes.backward = parseMiscLanes(tags["taxi:lanes:backward"]);
    var hovLanes = {};
    hovLanes.unspecified = parseMiscLanes(tags["hov:lanes"]);
    hovLanes.forward = parseMiscLanes(tags["hov:lanes:forward"]);
    hovLanes.backward = parseMiscLanes(tags["hov:lanes:backward"]);
    var hgvLanes = {};
    hgvLanes.unspecified = parseMiscLanes(tags["hgv:lanes"]);
    hgvLanes.forward = parseMiscLanes(tags["hgv:lanes:forward"]);
    hgvLanes.backward = parseMiscLanes(tags["hgv:lanes:backward"]);
    var bicyclewayLanes = {};
    bicyclewayLanes.unspecified = parseBicycleWay(tags["bicycleway:lanes"]);
    bicyclewayLanes.forward = parseBicycleWay(tags["bicycleway:lanes:forward"]);
    bicyclewayLanes.backward = parseBicycleWay(tags["bicycleway:lanes:backward"]);
    var lanesObj = {
      forward: [],
      backward: [],
      unspecified: []
    };
    mapToLanesObj(lanesObj, turnLanes, "turnLane");
    mapToLanesObj(lanesObj, maxspeedLanes, "maxspeed");
    mapToLanesObj(lanesObj, psvLanes, "psv");
    mapToLanesObj(lanesObj, busLanes, "bus");
    mapToLanesObj(lanesObj, taxiLanes, "taxi");
    mapToLanesObj(lanesObj, hovLanes, "hov");
    mapToLanesObj(lanesObj, hgvLanes, "hgv");
    mapToLanesObj(lanesObj, bicyclewayLanes, "bicycleway");
    return {
      metadata: {
        count: laneCount,
        oneway: isOneWay,
        forward,
        backward,
        bothways,
        turnLanes,
        maxspeed,
        maxspeedLanes,
        psvLanes,
        busLanes,
        taxiLanes,
        hovLanes,
        hgvLanes,
        bicyclewayLanes
      },
      lanes: lanesObj
    };
  }
  function getLaneCount(tags, isOneWay) {
    var count;
    if (tags.lanes) {
      count = parseInt(tags.lanes, 10);
      if (count > 0) {
        return count;
      }
    }
    switch (tags.highway) {
      case "trunk":
      case "motorway":
        count = isOneWay ? 2 : 4;
        break;
      default:
        count = isOneWay ? 1 : 2;
        break;
    }
    return count;
  }
  function parseMaxspeed(tags) {
    var maxspeed = tags.maxspeed;
    if (!maxspeed)
      return;
    var maxspeedRegex = /^([0-9][\.0-9]+?)(?:[ ]?(?:km\/h|kmh|kph|mph|knots))?$/;
    if (!maxspeedRegex.test(maxspeed))
      return;
    return parseInt(maxspeed, 10);
  }
  function parseLaneDirections(tags, isOneWay, laneCount) {
    var forward = parseInt(tags["lanes:forward"], 10);
    var backward = parseInt(tags["lanes:backward"], 10);
    var bothways = parseInt(tags["lanes:both_ways"], 10) > 0 ? 1 : 0;
    if (parseInt(tags.oneway, 10) === -1) {
      forward = 0;
      bothways = 0;
      backward = laneCount;
    } else if (isOneWay) {
      forward = laneCount;
      bothways = 0;
      backward = 0;
    } else if (isNaN(forward) && isNaN(backward)) {
      backward = Math.floor((laneCount - bothways) / 2);
      forward = laneCount - bothways - backward;
    } else if (isNaN(forward)) {
      if (backward > laneCount - bothways) {
        backward = laneCount - bothways;
      }
      forward = laneCount - bothways - backward;
    } else if (isNaN(backward)) {
      if (forward > laneCount - bothways) {
        forward = laneCount - bothways;
      }
      backward = laneCount - bothways - forward;
    }
    return {
      forward,
      backward,
      bothways
    };
  }
  function parseTurnLanes(tag2) {
    if (!tag2)
      return;
    var validValues = [
      "left",
      "slight_left",
      "sharp_left",
      "through",
      "right",
      "slight_right",
      "sharp_right",
      "reverse",
      "merge_to_left",
      "merge_to_right",
      "none"
    ];
    return tag2.split("|").map(function(s2) {
      if (s2 === "")
        s2 = "none";
      return s2.split(";").map(function(d2) {
        return validValues.indexOf(d2) === -1 ? "unknown" : d2;
      });
    });
  }
  function parseMaxspeedLanes(tag2, maxspeed) {
    if (!tag2)
      return;
    return tag2.split("|").map(function(s2) {
      if (s2 === "none")
        return s2;
      var m2 = parseInt(s2, 10);
      if (s2 === "" || m2 === maxspeed)
        return null;
      return isNaN(m2) ? "unknown" : m2;
    });
  }
  function parseMiscLanes(tag2) {
    if (!tag2)
      return;
    var validValues = [
      "yes",
      "no",
      "designated"
    ];
    return tag2.split("|").map(function(s2) {
      if (s2 === "")
        s2 = "no";
      return validValues.indexOf(s2) === -1 ? "unknown" : s2;
    });
  }
  function parseBicycleWay(tag2) {
    if (!tag2)
      return;
    var validValues = [
      "yes",
      "no",
      "designated",
      "lane"
    ];
    return tag2.split("|").map(function(s2) {
      if (s2 === "")
        s2 = "no";
      return validValues.indexOf(s2) === -1 ? "unknown" : s2;
    });
  }
  function mapToLanesObj(lanesObj, data, key) {
    if (data.forward) {
      data.forward.forEach(function(l2, i3) {
        if (!lanesObj.forward[i3])
          lanesObj.forward[i3] = {};
        lanesObj.forward[i3][key] = l2;
      });
    }
    if (data.backward) {
      data.backward.forEach(function(l2, i3) {
        if (!lanesObj.backward[i3])
          lanesObj.backward[i3] = {};
        lanesObj.backward[i3][key] = l2;
      });
    }
    if (data.unspecified) {
      data.unspecified.forEach(function(l2, i3) {
        if (!lanesObj.unspecified[i3])
          lanesObj.unspecified[i3] = {};
        lanesObj.unspecified[i3][key] = l2;
      });
    }
  }

  // modules/osm/way.js
  function osmWay() {
    if (!(this instanceof osmWay)) {
      return new osmWay().initialize(arguments);
    } else if (arguments.length) {
      this.initialize(arguments);
    }
  }
  osmEntity.way = osmWay;
  osmWay.prototype = Object.create(osmEntity.prototype);
  Object.assign(osmWay.prototype, {
    type: "way",
    nodes: [],
    copy: function(resolver, copies) {
      if (copies[this.id])
        return copies[this.id];
      var copy2 = osmEntity.prototype.copy.call(this, resolver, copies);
      var nodes = this.nodes.map(function(id2) {
        return resolver.entity(id2).copy(resolver, copies).id;
      });
      copy2 = copy2.update({ nodes });
      copies[this.id] = copy2;
      return copy2;
    },
    extent: function(resolver) {
      return resolver.transient(this, "extent", function() {
        var extent = geoExtent();
        for (var i3 = 0; i3 < this.nodes.length; i3++) {
          var node = resolver.hasEntity(this.nodes[i3]);
          if (node) {
            extent._extend(node.extent());
          }
        }
        return extent;
      });
    },
    first: function() {
      return this.nodes[0];
    },
    last: function() {
      return this.nodes[this.nodes.length - 1];
    },
    contains: function(node) {
      return this.nodes.indexOf(node) >= 0;
    },
    affix: function(node) {
      if (this.nodes[0] === node)
        return "prefix";
      if (this.nodes[this.nodes.length - 1] === node)
        return "suffix";
    },
    layer: function() {
      if (isFinite(this.tags.layer)) {
        return Math.max(-10, Math.min(+this.tags.layer, 10));
      }
      if (this.tags.covered === "yes")
        return -1;
      if (this.tags.location === "overground")
        return 1;
      if (this.tags.location === "underground")
        return -1;
      if (this.tags.location === "underwater")
        return -10;
      if (this.tags.power === "line")
        return 10;
      if (this.tags.power === "minor_line")
        return 10;
      if (this.tags.aerialway)
        return 10;
      if (this.tags.bridge)
        return 1;
      if (this.tags.cutting)
        return -1;
      if (this.tags.tunnel)
        return -1;
      if (this.tags.waterway)
        return -1;
      if (this.tags.man_made === "pipeline")
        return -10;
      if (this.tags.boundary)
        return -10;
      return 0;
    },
    // the approximate width of the line based on its tags except its `width` tag
    impliedLineWidthMeters: function() {
      var averageWidths = {
        highway: {
          // width is for single lane
          motorway: 5,
          motorway_link: 5,
          trunk: 4.5,
          trunk_link: 4.5,
          primary: 4,
          secondary: 4,
          tertiary: 4,
          primary_link: 4,
          secondary_link: 4,
          tertiary_link: 4,
          unclassified: 4,
          road: 4,
          living_street: 4,
          bus_guideway: 4,
          busway: 4,
          pedestrian: 4,
          residential: 3.5,
          service: 3.5,
          track: 3,
          cycleway: 2.5,
          bridleway: 2,
          corridor: 2,
          steps: 2,
          path: 1.5,
          footway: 1.5
        },
        railway: {
          // width includes ties and rail bed, not just track gauge
          rail: 2.5,
          light_rail: 2.5,
          tram: 2.5,
          subway: 2.5,
          monorail: 2.5,
          funicular: 2.5,
          disused: 2.5,
          preserved: 2.5,
          miniature: 1.5,
          narrow_gauge: 1.5
        },
        waterway: {
          river: 50,
          canal: 25,
          stream: 5,
          tidal_channel: 5,
          fish_pass: 2.5,
          drain: 2.5,
          ditch: 1.5
        }
      };
      for (var key in averageWidths) {
        if (this.tags[key] && averageWidths[key][this.tags[key]]) {
          var width = averageWidths[key][this.tags[key]];
          if (key === "highway") {
            var laneCount = this.tags.lanes && parseInt(this.tags.lanes, 10);
            if (!laneCount)
              laneCount = this.isOneWay() ? 1 : 2;
            return width * laneCount;
          }
          return width;
        }
      }
      return null;
    },
    isOneWay: function() {
      var values = {
        "yes": true,
        "1": true,
        "-1": true,
        "reversible": true,
        "alternating": true,
        "no": false,
        "0": false
      };
      if (values[this.tags.oneway] !== void 0) {
        return values[this.tags.oneway];
      }
      for (var key in this.tags) {
        if (key in osmOneWayTags && this.tags[key] in osmOneWayTags[key]) {
          return true;
        }
      }
      return false;
    },
    // Some identifier for tag that implies that this way is "sided",
    // i.e. the right side is the 'inside' (e.g. the right side of a
    // natural=cliff is lower).
    sidednessIdentifier: function() {
      for (const realKey in this.tags) {
        const value = this.tags[realKey];
        const key = osmRemoveLifecyclePrefix(realKey);
        if (key in osmRightSideIsInsideTags && value in osmRightSideIsInsideTags[key]) {
          if (osmRightSideIsInsideTags[key][value] === true) {
            return key;
          } else {
            return osmRightSideIsInsideTags[key][value];
          }
        }
      }
      return null;
    },
    isSided: function() {
      if (this.tags.two_sided === "yes") {
        return false;
      }
      return this.sidednessIdentifier() !== null;
    },
    lanes: function() {
      return osmLanes(this);
    },
    isClosed: function() {
      return this.nodes.length > 1 && this.first() === this.last();
    },
    isConvex: function(resolver) {
      if (!this.isClosed() || this.isDegenerate())
        return null;
      var nodes = utilArrayUniq(resolver.childNodes(this));
      var coords = nodes.map(function(n3) {
        return n3.loc;
      });
      var curr = 0;
      var prev = 0;
      for (var i3 = 0; i3 < coords.length; i3++) {
        var o2 = coords[(i3 + 1) % coords.length];
        var a2 = coords[i3];
        var b2 = coords[(i3 + 2) % coords.length];
        var res = geoVecCross(a2, b2, o2);
        curr = res > 0 ? 1 : res < 0 ? -1 : 0;
        if (curr === 0) {
          continue;
        } else if (prev && curr !== prev) {
          return false;
        }
        prev = curr;
      }
      return true;
    },
    // returns an object with the tag that implies this is an area, if any
    tagSuggestingArea: function() {
      return osmTagSuggestingArea(this.tags);
    },
    isArea: function() {
      if (this.tags.area === "yes")
        return true;
      if (!this.isClosed() || this.tags.area === "no")
        return false;
      return this.tagSuggestingArea() !== null;
    },
    isDegenerate: function() {
      return new Set(this.nodes).size < (this.isArea() ? 3 : 2);
    },
    areAdjacent: function(n1, n22) {
      for (var i3 = 0; i3 < this.nodes.length; i3++) {
        if (this.nodes[i3] === n1) {
          if (this.nodes[i3 - 1] === n22)
            return true;
          if (this.nodes[i3 + 1] === n22)
            return true;
        }
      }
      return false;
    },
    geometry: function(graph) {
      return graph.transient(this, "geometry", function() {
        return this.isArea() ? "area" : "line";
      });
    },
    // returns an array of objects representing the segments between the nodes in this way
    segments: function(graph) {
      function segmentExtent(graph2) {
        var n1 = graph2.hasEntity(this.nodes[0]);
        var n22 = graph2.hasEntity(this.nodes[1]);
        return n1 && n22 && geoExtent([
          [
            Math.min(n1.loc[0], n22.loc[0]),
            Math.min(n1.loc[1], n22.loc[1])
          ],
          [
            Math.max(n1.loc[0], n22.loc[0]),
            Math.max(n1.loc[1], n22.loc[1])
          ]
        ]);
      }
      return graph.transient(this, "segments", function() {
        var segments = [];
        for (var i3 = 0; i3 < this.nodes.length - 1; i3++) {
          segments.push({
            id: this.id + "-" + i3,
            wayId: this.id,
            index: i3,
            nodes: [this.nodes[i3], this.nodes[i3 + 1]],
            extent: segmentExtent
          });
        }
        return segments;
      });
    },
    // If this way is not closed, append the beginning node to the end of the nodelist to close it.
    close: function() {
      if (this.isClosed() || !this.nodes.length)
        return this;
      var nodes = this.nodes.slice();
      nodes = nodes.filter(noRepeatNodes);
      nodes.push(nodes[0]);
      return this.update({ nodes });
    },
    // If this way is closed, remove any connector nodes from the end of the nodelist to unclose it.
    unclose: function() {
      if (!this.isClosed())
        return this;
      var nodes = this.nodes.slice();
      var connector = this.first();
      var i3 = nodes.length - 1;
      while (i3 > 0 && nodes.length > 1 && nodes[i3] === connector) {
        nodes.splice(i3, 1);
        i3 = nodes.length - 1;
      }
      nodes = nodes.filter(noRepeatNodes);
      return this.update({ nodes });
    },
    // Adds a node (id) in front of the node which is currently at position index.
    // If index is undefined, the node will be added to the end of the way for linear ways,
    //   or just before the final connecting node for circular ways.
    // Consecutive duplicates are eliminated including existing ones.
    // Circularity is always preserved when adding a node.
    addNode: function(id2, index) {
      var nodes = this.nodes.slice();
      var isClosed = this.isClosed();
      var max3 = isClosed ? nodes.length - 1 : nodes.length;
      if (index === void 0) {
        index = max3;
      }
      if (index < 0 || index > max3) {
        throw new RangeError("index " + index + " out of range 0.." + max3);
      }
      if (isClosed) {
        var connector = this.first();
        var i3 = 1;
        while (i3 < nodes.length && nodes.length > 2 && nodes[i3] === connector) {
          nodes.splice(i3, 1);
          if (index > i3)
            index--;
        }
        i3 = nodes.length - 1;
        while (i3 > 0 && nodes.length > 1 && nodes[i3] === connector) {
          nodes.splice(i3, 1);
          if (index > i3)
            index--;
          i3 = nodes.length - 1;
        }
      }
      nodes.splice(index, 0, id2);
      nodes = nodes.filter(noRepeatNodes);
      if (isClosed && (nodes.length === 1 || nodes[0] !== nodes[nodes.length - 1])) {
        nodes.push(nodes[0]);
      }
      return this.update({ nodes });
    },
    // Replaces the node which is currently at position index with the given node (id).
    // Consecutive duplicates are eliminated including existing ones.
    // Circularity is preserved when updating a node.
    updateNode: function(id2, index) {
      var nodes = this.nodes.slice();
      var isClosed = this.isClosed();
      var max3 = nodes.length - 1;
      if (index === void 0 || index < 0 || index > max3) {
        throw new RangeError("index " + index + " out of range 0.." + max3);
      }
      if (isClosed) {
        var connector = this.first();
        var i3 = 1;
        while (i3 < nodes.length && nodes.length > 2 && nodes[i3] === connector) {
          nodes.splice(i3, 1);
          if (index > i3)
            index--;
        }
        i3 = nodes.length - 1;
        while (i3 > 0 && nodes.length > 1 && nodes[i3] === connector) {
          nodes.splice(i3, 1);
          if (index === i3)
            index = 0;
          i3 = nodes.length - 1;
        }
      }
      nodes.splice(index, 1, id2);
      nodes = nodes.filter(noRepeatNodes);
      if (isClosed && (nodes.length === 1 || nodes[0] !== nodes[nodes.length - 1])) {
        nodes.push(nodes[0]);
      }
      return this.update({ nodes });
    },
    // Replaces each occurrence of node id needle with replacement.
    // Consecutive duplicates are eliminated including existing ones.
    // Circularity is preserved.
    replaceNode: function(needleID, replacementID) {
      var nodes = this.nodes.slice();
      var isClosed = this.isClosed();
      for (var i3 = 0; i3 < nodes.length; i3++) {
        if (nodes[i3] === needleID) {
          nodes[i3] = replacementID;
        }
      }
      nodes = nodes.filter(noRepeatNodes);
      if (isClosed && (nodes.length === 1 || nodes[0] !== nodes[nodes.length - 1])) {
        nodes.push(nodes[0]);
      }
      return this.update({ nodes });
    },
    // Removes each occurrence of node id.
    // Consecutive duplicates are eliminated including existing ones.
    // Circularity is preserved.
    removeNode: function(id2) {
      var nodes = this.nodes.slice();
      var isClosed = this.isClosed();
      nodes = nodes.filter(function(node) {
        return node !== id2;
      }).filter(noRepeatNodes);
      if (isClosed && (nodes.length === 1 || nodes[0] !== nodes[nodes.length - 1])) {
        nodes.push(nodes[0]);
      }
      return this.update({ nodes });
    },
    asJXON: function(changeset_id) {
      var r2 = {
        way: {
          "@id": this.osmId(),
          "@version": this.version || 0,
          nd: this.nodes.map(function(id2) {
            return { keyAttributes: { ref: osmEntity.id.toOSM(id2) } };
          }, this),
          tag: Object.keys(this.tags).map(function(k2) {
            return { keyAttributes: { k: k2, v: this.tags[k2] } };
          }, this)
        }
      };
      if (changeset_id) {
        r2.way["@changeset"] = changeset_id;
      }
      return r2;
    },
    asGeoJSON: function(resolver) {
      return resolver.transient(this, "GeoJSON", function() {
        var coordinates = resolver.childNodes(this).map(function(n3) {
          return n3.loc;
        });
        if (this.isArea() && this.isClosed()) {
          return {
            type: "Polygon",
            coordinates: [coordinates]
          };
        } else {
          return {
            type: "LineString",
            coordinates
          };
        }
      });
    },
    area: function(resolver) {
      return resolver.transient(this, "area", function() {
        var nodes = resolver.childNodes(this);
        var json = {
          type: "Polygon",
          coordinates: [nodes.map(function(n3) {
            return n3.loc;
          })]
        };
        if (!this.isClosed() && nodes.length) {
          json.coordinates[0].push(nodes[0].loc);
        }
        var area = area_default(json);
        if (area > 2 * Math.PI) {
          json.coordinates[0] = json.coordinates[0].reverse();
          area = area_default(json);
        }
        return isNaN(area) ? 0 : area;
      });
    }
  });
  function noRepeatNodes(node, i3, arr) {
    return i3 === 0 || node !== arr[i3 - 1];
  }

  // modules/osm/multipolygon.js
  function osmJoinWays(toJoin, graph) {
    function resolve(member) {
      return graph.childNodes(graph.entity(member.id));
    }
    function reverse(item2) {
      var action = actionReverse(item2.id, { reverseOneway: true });
      sequences.actions.push(action);
      return item2 instanceof osmWay ? action(graph).entity(item2.id) : item2;
    }
    toJoin = toJoin.filter(function(member) {
      return member.type === "way" && graph.hasEntity(member.id);
    });
    var i3;
    var joinAsMembers = true;
    for (i3 = 0; i3 < toJoin.length; i3++) {
      if (toJoin[i3] instanceof osmWay) {
        joinAsMembers = false;
        break;
      }
    }
    var sequences = [];
    sequences.actions = [];
    while (toJoin.length) {
      var item = toJoin.shift();
      var currWays = [item];
      var currNodes = resolve(item).slice();
      while (toJoin.length) {
        var start2 = currNodes[0];
        var end = currNodes[currNodes.length - 1];
        var fn = null;
        var nodes = null;
        for (i3 = 0; i3 < toJoin.length; i3++) {
          item = toJoin[i3];
          nodes = resolve(item);
          if (joinAsMembers && currWays.length === 1 && nodes[0] !== end && nodes[nodes.length - 1] !== end && (nodes[nodes.length - 1] === start2 || nodes[0] === start2)) {
            currWays[0] = reverse(currWays[0]);
            currNodes.reverse();
            start2 = currNodes[0];
            end = currNodes[currNodes.length - 1];
          }
          if (nodes[0] === end) {
            fn = currNodes.push;
            nodes = nodes.slice(1);
            break;
          } else if (nodes[nodes.length - 1] === end) {
            fn = currNodes.push;
            nodes = nodes.slice(0, -1).reverse();
            item = reverse(item);
            break;
          } else if (nodes[nodes.length - 1] === start2) {
            fn = currNodes.unshift;
            nodes = nodes.slice(0, -1);
            break;
          } else if (nodes[0] === start2) {
            fn = currNodes.unshift;
            nodes = nodes.slice(1).reverse();
            item = reverse(item);
            break;
          } else {
            fn = nodes = null;
          }
        }
        if (!nodes) {
          break;
        }
        fn.apply(currWays, [item]);
        fn.apply(currNodes, nodes);
        toJoin.splice(i3, 1);
      }
      currWays.nodes = currNodes;
      sequences.push(currWays);
    }
    return sequences;
  }

  // modules/actions/add_member.js
  function actionAddMember(relationId, member, memberIndex) {
    return function action(graph) {
      var relation = graph.entity(relationId);
      var isPTv2 = /stop|platform/.test(member.role);
      if (member.type === "way" && !isPTv2) {
        graph = addWayMember(relation, graph);
      } else {
        if (isPTv2 && isNaN(memberIndex)) {
          memberIndex = 0;
        }
        graph = graph.replace(relation.addMember(member, memberIndex));
      }
      return graph;
    };
    function addWayMember(relation, graph) {
      var groups, item, i3, j2, k2;
      var PTv2members = [];
      var members = [];
      for (i3 = 0; i3 < relation.members.length; i3++) {
        var m2 = relation.members[i3];
        if (/stop|platform/.test(m2.role)) {
          PTv2members.push(m2);
        } else {
          members.push(m2);
        }
      }
      relation = relation.update({ members });
      groups = utilArrayGroupBy(relation.members, "type");
      groups.way = groups.way || [];
      groups.way.push(member);
      members = withIndex(groups.way);
      var joined = osmJoinWays(members, graph);
      for (i3 = 0; i3 < joined.length; i3++) {
        var segment = joined[i3];
        var nodes = segment.nodes.slice();
        var startIndex = segment[0].index;
        for (j2 = 0; j2 < members.length; j2++) {
          if (members[j2].index === startIndex) {
            break;
          }
        }
        for (k2 = 0; k2 < segment.length; k2++) {
          item = segment[k2];
          var way = graph.entity(item.id);
          if (k2 > 0) {
            if (j2 + k2 >= members.length || item.index !== members[j2 + k2].index) {
              moveMember(members, item.index, j2 + k2);
            }
          }
          nodes.splice(0, way.nodes.length - 1);
        }
      }
      var wayMembers = [];
      for (i3 = 0; i3 < members.length; i3++) {
        item = members[i3];
        if (item.index === -1)
          continue;
        wayMembers.push(utilObjectOmit(item, ["index"]));
      }
      var newMembers = PTv2members.concat(groups.node || [], wayMembers, groups.relation || []);
      return graph.replace(relation.update({ members: newMembers }));
      function moveMember(arr, findIndex, toIndex) {
        var i4;
        for (i4 = 0; i4 < arr.length; i4++) {
          if (arr[i4].index === findIndex) {
            break;
          }
        }
        var item2 = Object.assign({}, arr[i4]);
        arr[i4].index = -1;
        delete item2.index;
        arr.splice(toIndex, 0, item2);
      }
      function withIndex(arr) {
        var result = new Array(arr.length);
        for (var i4 = 0; i4 < arr.length; i4++) {
          result[i4] = Object.assign({}, arr[i4]);
          result[i4].index = i4;
        }
        return result;
      }
    }
  }

  // modules/actions/add_midpoint.js
  function actionAddMidpoint(midpoint, node) {
    return function(graph) {
      graph = graph.replace(node.move(midpoint.loc));
      var parents = utilArrayIntersection(
        graph.parentWays(graph.entity(midpoint.edge[0])),
        graph.parentWays(graph.entity(midpoint.edge[1]))
      );
      parents.forEach(function(way) {
        for (var i3 = 0; i3 < way.nodes.length - 1; i3++) {
          if (geoEdgeEqual([way.nodes[i3], way.nodes[i3 + 1]], midpoint.edge)) {
            graph = graph.replace(graph.entity(way.id).addNode(node.id, i3 + 1));
            return;
          }
        }
      });
      return graph;
    };
  }

  // modules/actions/add_vertex.js
  function actionAddVertex(wayId, nodeId, index) {
    return function(graph) {
      return graph.replace(graph.entity(wayId).addNode(nodeId, index));
    };
  }

  // modules/actions/change_member.js
  function actionChangeMember(relationId, member, memberIndex) {
    return function(graph) {
      return graph.replace(graph.entity(relationId).updateMember(member, memberIndex));
    };
  }

  // modules/actions/change_preset.js
  function actionChangePreset(entityID, oldPreset, newPreset, skipFieldDefaults) {
    return function action(graph) {
      var entity = graph.entity(entityID);
      var geometry = entity.geometry(graph);
      var tags = entity.tags;
      const loc = entity.extent(graph).center();
      var preserveKeys;
      if (newPreset) {
        preserveKeys = [];
        if (newPreset.addTags) {
          preserveKeys = preserveKeys.concat(Object.keys(newPreset.addTags));
        }
        if (oldPreset && !oldPreset.id.startsWith(newPreset.id)) {
          newPreset.fields(loc).concat(newPreset.moreFields(loc)).filter((f2) => f2.matchGeometry(geometry)).map((f2) => f2.key).filter(Boolean).forEach((key) => preserveKeys.push(key));
        }
      }
      if (oldPreset)
        tags = oldPreset.unsetTags(tags, geometry, preserveKeys, false, loc);
      if (newPreset)
        tags = newPreset.setTags(tags, geometry, skipFieldDefaults, loc);
      return graph.replace(entity.update({ tags }));
    };
  }

  // modules/actions/change_tags.js
  function actionChangeTags(entityId, tags) {
    return function(graph) {
      var entity = graph.entity(entityId);
      return graph.replace(entity.update({ tags }));
    };
  }

  // modules/osm/node.js
  var cardinal = {
    north: 0,
    n: 0,
    northnortheast: 22,
    nne: 22,
    northeast: 45,
    ne: 45,
    eastnortheast: 67,
    ene: 67,
    east: 90,
    e: 90,
    eastsoutheast: 112,
    ese: 112,
    southeast: 135,
    se: 135,
    southsoutheast: 157,
    sse: 157,
    south: 180,
    s: 180,
    southsouthwest: 202,
    ssw: 202,
    southwest: 225,
    sw: 225,
    westsouthwest: 247,
    wsw: 247,
    west: 270,
    w: 270,
    westnorthwest: 292,
    wnw: 292,
    northwest: 315,
    nw: 315,
    northnorthwest: 337,
    nnw: 337
  };
  function osmNode() {
    if (!(this instanceof osmNode)) {
      return new osmNode().initialize(arguments);
    } else if (arguments.length) {
      this.initialize(arguments);
    }
  }
  osmEntity.node = osmNode;
  osmNode.prototype = Object.create(osmEntity.prototype);
  Object.assign(osmNode.prototype, {
    type: "node",
    loc: [9999, 9999],
    extent: function() {
      return new geoExtent(this.loc);
    },
    geometry: function(graph) {
      return graph.transient(this, "geometry", function() {
        return graph.isPoi(this) ? "point" : "vertex";
      });
    },
    move: function(loc) {
      return this.update({ loc });
    },
    isDegenerate: function() {
      return !(Array.isArray(this.loc) && this.loc.length === 2 && this.loc[0] >= -180 && this.loc[0] <= 180 && this.loc[1] >= -90 && this.loc[1] <= 90);
    },
    // Inspect tags and geometry to determine which direction(s) this node/vertex points
    directions: function(resolver, projection2) {
      var val;
      var i3;
      if (this.isHighwayIntersection(resolver) && (this.tags.stop || "").toLowerCase() === "all") {
        val = "all";
      } else {
        val = (this.tags.direction || "").toLowerCase();
        var re3 = /:direction$/i;
        var keys2 = Object.keys(this.tags);
        for (i3 = 0; i3 < keys2.length; i3++) {
          if (re3.test(keys2[i3])) {
            val = this.tags[keys2[i3]].toLowerCase();
            break;
          }
        }
      }
      if (val === "")
        return [];
      var values = val.split(";");
      var results = [];
      values.forEach(function(v2) {
        if (cardinal[v2] !== void 0) {
          v2 = cardinal[v2];
        }
        if (v2 !== "" && !isNaN(+v2)) {
          results.push(+v2);
          return;
        }
        var lookBackward = this.tags["traffic_sign:backward"] || v2 === "backward" || v2 === "both" || v2 === "all";
        var lookForward = this.tags["traffic_sign:forward"] || v2 === "forward" || v2 === "both" || v2 === "all";
        if (!lookForward && !lookBackward)
          return;
        var nodeIds = {};
        resolver.parentWays(this).forEach(function(parent) {
          var nodes = parent.nodes;
          for (i3 = 0; i3 < nodes.length; i3++) {
            if (nodes[i3] === this.id) {
              if (lookForward && i3 > 0) {
                nodeIds[nodes[i3 - 1]] = true;
              }
              if (lookBackward && i3 < nodes.length - 1) {
                nodeIds[nodes[i3 + 1]] = true;
              }
            }
          }
        }, this);
        Object.keys(nodeIds).forEach(function(nodeId) {
          results.push(
            geoAngle(this, resolver.entity(nodeId), projection2) * (180 / Math.PI) + 90
          );
        }, this);
      }, this);
      return utilArrayUniq(results);
    },
    isCrossing: function() {
      return this.tags.highway === "crossing" || this.tags.railway && this.tags.railway.indexOf("crossing") !== -1;
    },
    isEndpoint: function(resolver) {
      return resolver.transient(this, "isEndpoint", function() {
        var id2 = this.id;
        return resolver.parentWays(this).filter(function(parent) {
          return !parent.isClosed() && !!parent.affix(id2);
        }).length > 0;
      });
    },
    isConnected: function(resolver) {
      return resolver.transient(this, "isConnected", function() {
        var parents = resolver.parentWays(this);
        if (parents.length > 1) {
          for (var i3 in parents) {
            if (parents[i3].geometry(resolver) === "line" && parents[i3].hasInterestingTags())
              return true;
          }
        } else if (parents.length === 1) {
          var way = parents[0];
          var nodes = way.nodes.slice();
          if (way.isClosed()) {
            nodes.pop();
          }
          return nodes.indexOf(this.id) !== nodes.lastIndexOf(this.id);
        }
        return false;
      });
    },
    parentIntersectionWays: function(resolver) {
      return resolver.transient(this, "parentIntersectionWays", function() {
        return resolver.parentWays(this).filter(function(parent) {
          return (parent.tags.highway || parent.tags.waterway || parent.tags.railway || parent.tags.aeroway) && parent.geometry(resolver) === "line";
        });
      });
    },
    isIntersection: function(resolver) {
      return this.parentIntersectionWays(resolver).length > 1;
    },
    isHighwayIntersection: function(resolver) {
      return resolver.transient(this, "isHighwayIntersection", function() {
        return resolver.parentWays(this).filter(function(parent) {
          return parent.tags.highway && parent.geometry(resolver) === "line";
        }).length > 1;
      });
    },
    isOnAddressLine: function(resolver) {
      return resolver.transient(this, "isOnAddressLine", function() {
        return resolver.parentWays(this).filter(function(parent) {
          return parent.tags.hasOwnProperty("addr:interpolation") && parent.geometry(resolver) === "line";
        }).length > 0;
      });
    },
    asJXON: function(changeset_id) {
      var r2 = {
        node: {
          "@id": this.osmId(),
          "@lon": this.loc[0],
          "@lat": this.loc[1],
          "@version": this.version || 0,
          tag: Object.keys(this.tags).map(function(k2) {
            return { keyAttributes: { k: k2, v: this.tags[k2] } };
          }, this)
        }
      };
      if (changeset_id)
        r2.node["@changeset"] = changeset_id;
      return r2;
    },
    asGeoJSON: function() {
      return {
        type: "Point",
        coordinates: this.loc
      };
    }
  });

  // modules/actions/circularize.js
  function actionCircularize(wayId, projection2, maxAngle) {
    maxAngle = (maxAngle || 20) * Math.PI / 180;
    var action = function(graph, t2) {
      if (t2 === null || !isFinite(t2))
        t2 = 1;
      t2 = Math.min(Math.max(+t2, 0), 1);
      var way = graph.entity(wayId);
      var origNodes = {};
      graph.childNodes(way).forEach(function(node2) {
        if (!origNodes[node2.id])
          origNodes[node2.id] = node2;
      });
      if (!way.isConvex(graph)) {
        graph = action.makeConvex(graph);
      }
      var nodes = utilArrayUniq(graph.childNodes(way));
      var keyNodes = nodes.filter(function(n3) {
        return graph.parentWays(n3).length !== 1;
      });
      var points = nodes.map(function(n3) {
        return projection2(n3.loc);
      });
      var keyPoints = keyNodes.map(function(n3) {
        return projection2(n3.loc);
      });
      var centroid = points.length === 2 ? geoVecInterp(points[0], points[1], 0.5) : centroid_default2(points);
      var radius = median(points, function(p2) {
        return geoVecLength(centroid, p2);
      });
      var sign2 = area_default3(points) > 0 ? 1 : -1;
      var ids, i3, j2, k2;
      if (!keyNodes.length) {
        keyNodes = [nodes[0]];
        keyPoints = [points[0]];
      }
      if (keyNodes.length === 1) {
        var index = nodes.indexOf(keyNodes[0]);
        var oppositeIndex = Math.floor((index + nodes.length / 2) % nodes.length);
        keyNodes.push(nodes[oppositeIndex]);
        keyPoints.push(points[oppositeIndex]);
      }
      for (i3 = 0; i3 < keyPoints.length; i3++) {
        var nextKeyNodeIndex = (i3 + 1) % keyNodes.length;
        var startNode = keyNodes[i3];
        var endNode = keyNodes[nextKeyNodeIndex];
        var startNodeIndex = nodes.indexOf(startNode);
        var endNodeIndex = nodes.indexOf(endNode);
        var numberNewPoints = -1;
        var indexRange = endNodeIndex - startNodeIndex;
        var nearNodes = {};
        var inBetweenNodes = [];
        var startAngle, endAngle, totalAngle, eachAngle;
        var angle2, loc, node, origNode;
        if (indexRange < 0) {
          indexRange += nodes.length;
        }
        var distance = geoVecLength(centroid, keyPoints[i3]) || 1e-4;
        keyPoints[i3] = [
          centroid[0] + (keyPoints[i3][0] - centroid[0]) / distance * radius,
          centroid[1] + (keyPoints[i3][1] - centroid[1]) / distance * radius
        ];
        loc = projection2.invert(keyPoints[i3]);
        node = keyNodes[i3];
        origNode = origNodes[node.id];
        node = node.move(geoVecInterp(origNode.loc, loc, t2));
        graph = graph.replace(node);
        startAngle = Math.atan2(keyPoints[i3][1] - centroid[1], keyPoints[i3][0] - centroid[0]);
        endAngle = Math.atan2(keyPoints[nextKeyNodeIndex][1] - centroid[1], keyPoints[nextKeyNodeIndex][0] - centroid[0]);
        totalAngle = endAngle - startAngle;
        if (totalAngle * sign2 > 0) {
          totalAngle = -sign2 * (2 * Math.PI - Math.abs(totalAngle));
        }
        do {
          numberNewPoints++;
          eachAngle = totalAngle / (indexRange + numberNewPoints);
        } while (Math.abs(eachAngle) > maxAngle);
        for (j2 = 1; j2 < indexRange; j2++) {
          angle2 = startAngle + j2 * eachAngle;
          loc = projection2.invert([
            centroid[0] + Math.cos(angle2) * radius,
            centroid[1] + Math.sin(angle2) * radius
          ]);
          node = nodes[(j2 + startNodeIndex) % nodes.length];
          origNode = origNodes[node.id];
          nearNodes[node.id] = angle2;
          node = node.move(geoVecInterp(origNode.loc, loc, t2));
          graph = graph.replace(node);
        }
        for (j2 = 0; j2 < numberNewPoints; j2++) {
          angle2 = startAngle + (indexRange + j2) * eachAngle;
          loc = projection2.invert([
            centroid[0] + Math.cos(angle2) * radius,
            centroid[1] + Math.sin(angle2) * radius
          ]);
          var min3 = Infinity;
          for (var nodeId in nearNodes) {
            var nearAngle = nearNodes[nodeId];
            var dist = Math.abs(nearAngle - angle2);
            if (dist < min3) {
              min3 = dist;
              origNode = origNodes[nodeId];
            }
          }
          node = osmNode({ loc: geoVecInterp(origNode.loc, loc, t2) });
          graph = graph.replace(node);
          nodes.splice(endNodeIndex + j2, 0, node);
          inBetweenNodes.push(node.id);
        }
        if (indexRange === 1 && inBetweenNodes.length) {
          var startIndex1 = way.nodes.lastIndexOf(startNode.id);
          var endIndex1 = way.nodes.lastIndexOf(endNode.id);
          var wayDirection1 = endIndex1 - startIndex1;
          if (wayDirection1 < -1) {
            wayDirection1 = 1;
          }
          var parentWays = graph.parentWays(keyNodes[i3]);
          for (j2 = 0; j2 < parentWays.length; j2++) {
            var sharedWay = parentWays[j2];
            if (sharedWay === way)
              continue;
            if (sharedWay.areAdjacent(startNode.id, endNode.id)) {
              var startIndex2 = sharedWay.nodes.lastIndexOf(startNode.id);
              var endIndex2 = sharedWay.nodes.lastIndexOf(endNode.id);
              var wayDirection2 = endIndex2 - startIndex2;
              var insertAt = endIndex2;
              if (wayDirection2 < -1) {
                wayDirection2 = 1;
              }
              if (wayDirection1 !== wayDirection2) {
                inBetweenNodes.reverse();
                insertAt = startIndex2;
              }
              for (k2 = 0; k2 < inBetweenNodes.length; k2++) {
                sharedWay = sharedWay.addNode(inBetweenNodes[k2], insertAt + k2);
              }
              graph = graph.replace(sharedWay);
            }
          }
        }
      }
      ids = nodes.map(function(n3) {
        return n3.id;
      });
      ids.push(ids[0]);
      way = way.update({ nodes: ids });
      graph = graph.replace(way);
      return graph;
    };
    action.makeConvex = function(graph) {
      var way = graph.entity(wayId);
      var nodes = utilArrayUniq(graph.childNodes(way));
      var points = nodes.map(function(n3) {
        return projection2(n3.loc);
      });
      var sign2 = area_default3(points) > 0 ? 1 : -1;
      var hull = hull_default(points);
      var i3, j2;
      if (sign2 === -1) {
        nodes.reverse();
        points.reverse();
      }
      for (i3 = 0; i3 < hull.length - 1; i3++) {
        var startIndex = points.indexOf(hull[i3]);
        var endIndex = points.indexOf(hull[i3 + 1]);
        var indexRange = endIndex - startIndex;
        if (indexRange < 0) {
          indexRange += nodes.length;
        }
        for (j2 = 1; j2 < indexRange; j2++) {
          var point2 = geoVecInterp(hull[i3], hull[i3 + 1], j2 / indexRange);
          var node = nodes[(j2 + startIndex) % nodes.length].move(projection2.invert(point2));
          graph = graph.replace(node);
        }
      }
      return graph;
    };
    action.disabled = function(graph) {
      if (!graph.entity(wayId).isClosed()) {
        return "not_closed";
      }
      var way = graph.entity(wayId);
      var nodes = utilArrayUniq(graph.childNodes(way));
      var points = nodes.map(function(n3) {
        return projection2(n3.loc);
      });
      var hull = hull_default(points);
      var epsilonAngle = Math.PI / 180;
      if (hull.length !== points.length || hull.length < 3) {
        return false;
      }
      var centroid = centroid_default2(points);
      var radius = geoVecLengthSquare(centroid, points[0]);
      var i3, actualPoint;
      for (i3 = 0; i3 < hull.length; i3++) {
        actualPoint = hull[i3];
        var actualDist = geoVecLengthSquare(actualPoint, centroid);
        var diff = Math.abs(actualDist - radius);
        if (diff > 0.05 * radius) {
          return false;
        }
      }
      for (i3 = 0; i3 < hull.length; i3++) {
        actualPoint = hull[i3];
        var nextPoint = hull[(i3 + 1) % hull.length];
        var startAngle = Math.atan2(actualPoint[1] - centroid[1], actualPoint[0] - centroid[0]);
        var endAngle = Math.atan2(nextPoint[1] - centroid[1], nextPoint[0] - centroid[0]);
        var angle2 = endAngle - startAngle;
        if (angle2 < 0) {
          angle2 = -angle2;
        }
        if (angle2 > Math.PI) {
          angle2 = 2 * Math.PI - angle2;
        }
        if (angle2 > maxAngle + epsilonAngle) {
          return false;
        }
      }
      return "already_circular";
    };
    action.transitionable = true;
    return action;
  }

  // modules/actions/delete_way.js
  function actionDeleteWay(wayID) {
    function canDeleteNode(node, graph) {
      if (graph.parentWays(node).length || graph.parentRelations(node).length)
        return false;
      var geometries = osmNodeGeometriesForTags(node.tags);
      if (geometries.point)
        return false;
      if (geometries.vertex)
        return true;
      return !node.hasInterestingTags();
    }
    var action = function(graph) {
      var way = graph.entity(wayID);
      graph.parentRelations(way).forEach(function(parent) {
        parent = parent.removeMembersWithID(wayID);
        graph = graph.replace(parent);
        if (parent.isDegenerate()) {
          graph = actionDeleteRelation(parent.id)(graph);
        }
      });
      new Set(way.nodes).forEach(function(nodeID) {
        graph = graph.replace(way.removeNode(nodeID));
        var node = graph.entity(nodeID);
        if (canDeleteNode(node, graph)) {
          graph = graph.remove(node);
        }
      });
      return graph.remove(way);
    };
    return action;
  }

  // modules/actions/delete_multiple.js
  function actionDeleteMultiple(ids) {
    var actions = {
      way: actionDeleteWay,
      node: actionDeleteNode,
      relation: actionDeleteRelation
    };
    var action = function(graph) {
      ids.forEach(function(id2) {
        if (graph.hasEntity(id2)) {
          graph = actions[graph.entity(id2).type](id2)(graph);
        }
      });
      return graph;
    };
    return action;
  }

  // modules/actions/delete_relation.js
  function actionDeleteRelation(relationID, allowUntaggedMembers) {
    function canDeleteEntity(entity, graph) {
      return !graph.parentWays(entity).length && !graph.parentRelations(entity).length && (!entity.hasInterestingTags() && !allowUntaggedMembers);
    }
    var action = function(graph) {
      var relation = graph.entity(relationID);
      graph.parentRelations(relation).forEach(function(parent) {
        parent = parent.removeMembersWithID(relationID);
        graph = graph.replace(parent);
        if (parent.isDegenerate()) {
          graph = actionDeleteRelation(parent.id)(graph);
        }
      });
      var memberIDs = utilArrayUniq(relation.members.map(function(m2) {
        return m2.id;
      }));
      memberIDs.forEach(function(memberID) {
        graph = graph.replace(relation.removeMembersWithID(memberID));
        var entity = graph.entity(memberID);
        if (canDeleteEntity(entity, graph)) {
          graph = actionDeleteMultiple([memberID])(graph);
        }
      });
      return graph.remove(relation);
    };
    return action;
  }

  // modules/actions/delete_node.js
  function actionDeleteNode(nodeId) {
    var action = function(graph) {
      var node = graph.entity(nodeId);
      graph.parentWays(node).forEach(function(parent) {
        parent = parent.removeNode(nodeId);
        graph = graph.replace(parent);
        if (parent.isDegenerate()) {
          graph = actionDeleteWay(parent.id)(graph);
        }
      });
      graph.parentRelations(node).forEach(function(parent) {
        parent = parent.removeMembersWithID(nodeId);
        graph = graph.replace(parent);
        if (parent.isDegenerate()) {
          graph = actionDeleteRelation(parent.id)(graph);
        }
      });
      return graph.remove(node);
    };
    return action;
  }

  // modules/actions/connect.js
  function actionConnect(nodeIDs) {
    var action = function(graph) {
      var survivor;
      var node;
      var parents;
      var i3, j2;
      nodeIDs.reverse();
      var interestingIDs = [];
      for (i3 = 0; i3 < nodeIDs.length; i3++) {
        node = graph.entity(nodeIDs[i3]);
        if (node.hasInterestingTags()) {
          if (!node.isNew()) {
            interestingIDs.push(node.id);
          }
        }
      }
      survivor = graph.entity(utilOldestID(interestingIDs.length > 0 ? interestingIDs : nodeIDs));
      for (i3 = 0; i3 < nodeIDs.length; i3++) {
        node = graph.entity(nodeIDs[i3]);
        if (node.id === survivor.id)
          continue;
        parents = graph.parentWays(node);
        for (j2 = 0; j2 < parents.length; j2++) {
          graph = graph.replace(parents[j2].replaceNode(node.id, survivor.id));
        }
        parents = graph.parentRelations(node);
        for (j2 = 0; j2 < parents.length; j2++) {
          graph = graph.replace(parents[j2].replaceMember(node, survivor));
        }
        survivor = survivor.mergeTags(node.tags);
        graph = actionDeleteNode(node.id)(graph);
      }
      graph = graph.replace(survivor);
      parents = graph.parentWays(survivor);
      for (i3 = 0; i3 < parents.length; i3++) {
        if (parents[i3].isDegenerate()) {
          graph = actionDeleteWay(parents[i3].id)(graph);
        }
      }
      return graph;
    };
    action.disabled = function(graph) {
      var seen = {};
      var restrictionIDs = [];
      var survivor;
      var node, way;
      var relations, relation, role;
      var i3, j2, k2;
      survivor = graph.entity(utilOldestID(nodeIDs));
      for (i3 = 0; i3 < nodeIDs.length; i3++) {
        node = graph.entity(nodeIDs[i3]);
        relations = graph.parentRelations(node);
        for (j2 = 0; j2 < relations.length; j2++) {
          relation = relations[j2];
          role = relation.memberById(node.id).role || "";
          if (relation.hasFromViaTo()) {
            restrictionIDs.push(relation.id);
          }
          if (seen[relation.id] !== void 0 && seen[relation.id] !== role) {
            return "relation";
          } else {
            seen[relation.id] = role;
          }
        }
      }
      for (i3 = 0; i3 < nodeIDs.length; i3++) {
        node = graph.entity(nodeIDs[i3]);
        var parents = graph.parentWays(node);
        for (j2 = 0; j2 < parents.length; j2++) {
          var parent = parents[j2];
          relations = graph.parentRelations(parent);
          for (k2 = 0; k2 < relations.length; k2++) {
            relation = relations[k2];
            if (relation.hasFromViaTo()) {
              restrictionIDs.push(relation.id);
            }
          }
        }
      }
      restrictionIDs = utilArrayUniq(restrictionIDs);
      for (i3 = 0; i3 < restrictionIDs.length; i3++) {
        relation = graph.entity(restrictionIDs[i3]);
        if (!relation.isComplete(graph))
          continue;
        var memberWays = relation.members.filter(function(m2) {
          return m2.type === "way";
        }).map(function(m2) {
          return graph.entity(m2.id);
        });
        memberWays = utilArrayUniq(memberWays);
        var f2 = relation.memberByRole("from");
        var t2 = relation.memberByRole("to");
        var isUturn = f2.id === t2.id;
        var nodes = { from: [], via: [], to: [], keyfrom: [], keyto: [] };
        for (j2 = 0; j2 < relation.members.length; j2++) {
          collectNodes(relation.members[j2], nodes);
        }
        nodes.keyfrom = utilArrayUniq(nodes.keyfrom.filter(hasDuplicates));
        nodes.keyto = utilArrayUniq(nodes.keyto.filter(hasDuplicates));
        var filter2 = keyNodeFilter(nodes.keyfrom, nodes.keyto);
        nodes.from = nodes.from.filter(filter2);
        nodes.via = nodes.via.filter(filter2);
        nodes.to = nodes.to.filter(filter2);
        var connectFrom = false;
        var connectVia = false;
        var connectTo = false;
        var connectKeyFrom = false;
        var connectKeyTo = false;
        for (j2 = 0; j2 < nodeIDs.length; j2++) {
          var n3 = nodeIDs[j2];
          if (nodes.from.indexOf(n3) !== -1) {
            connectFrom = true;
          }
          if (nodes.via.indexOf(n3) !== -1) {
            connectVia = true;
          }
          if (nodes.to.indexOf(n3) !== -1) {
            connectTo = true;
          }
          if (nodes.keyfrom.indexOf(n3) !== -1) {
            connectKeyFrom = true;
          }
          if (nodes.keyto.indexOf(n3) !== -1) {
            connectKeyTo = true;
          }
        }
        if (connectFrom && connectTo && !isUturn) {
          return "restriction";
        }
        if (connectFrom && connectVia) {
          return "restriction";
        }
        if (connectTo && connectVia) {
          return "restriction";
        }
        if (connectKeyFrom || connectKeyTo) {
          if (nodeIDs.length !== 2) {
            return "restriction";
          }
          var n0 = null;
          var n1 = null;
          for (j2 = 0; j2 < memberWays.length; j2++) {
            way = memberWays[j2];
            if (way.contains(nodeIDs[0])) {
              n0 = nodeIDs[0];
            }
            if (way.contains(nodeIDs[1])) {
              n1 = nodeIDs[1];
            }
          }
          if (n0 && n1) {
            var ok = false;
            for (j2 = 0; j2 < memberWays.length; j2++) {
              way = memberWays[j2];
              if (way.areAdjacent(n0, n1)) {
                ok = true;
                break;
              }
            }
            if (!ok) {
              return "restriction";
            }
          }
        }
        for (j2 = 0; j2 < memberWays.length; j2++) {
          way = memberWays[j2].update({});
          for (k2 = 0; k2 < nodeIDs.length; k2++) {
            if (nodeIDs[k2] === survivor.id)
              continue;
            if (way.areAdjacent(nodeIDs[k2], survivor.id)) {
              way = way.removeNode(nodeIDs[k2]);
            } else {
              way = way.replaceNode(nodeIDs[k2], survivor.id);
            }
          }
          if (way.isDegenerate()) {
            return "restriction";
          }
        }
      }
      return false;
      function hasDuplicates(n4, i4, arr) {
        return arr.indexOf(n4) !== arr.lastIndexOf(n4);
      }
      function keyNodeFilter(froms, tos) {
        return function(n4) {
          return froms.indexOf(n4) === -1 && tos.indexOf(n4) === -1;
        };
      }
      function collectNodes(member, collection) {
        var entity = graph.hasEntity(member.id);
        if (!entity)
          return;
        var role2 = member.role || "";
        if (!collection[role2]) {
          collection[role2] = [];
        }
        if (member.type === "node") {
          collection[role2].push(member.id);
          if (role2 === "via") {
            collection.keyfrom.push(member.id);
            collection.keyto.push(member.id);
          }
        } else if (member.type === "way") {
          collection[role2].push.apply(collection[role2], entity.nodes);
          if (role2 === "from" || role2 === "via") {
            collection.keyfrom.push(entity.first());
            collection.keyfrom.push(entity.last());
          }
          if (role2 === "to" || role2 === "via") {
            collection.keyto.push(entity.first());
            collection.keyto.push(entity.last());
          }
        }
      }
    };
    return action;
  }

  // modules/actions/copy_entities.js
  function actionCopyEntities(ids, fromGraph) {
    var _copies = {};
    var action = function(graph) {
      ids.forEach(function(id3) {
        fromGraph.entity(id3).copy(fromGraph, _copies);
      });
      for (var id2 in _copies) {
        graph = graph.replace(_copies[id2]);
      }
      return graph;
    };
    action.copies = function() {
      return _copies;
    };
    return action;
  }

  // modules/actions/delete_member.js
  function actionDeleteMember(relationId, memberIndex) {
    return function(graph) {
      var relation = graph.entity(relationId).removeMember(memberIndex);
      graph = graph.replace(relation);
      if (relation.isDegenerate()) {
        graph = actionDeleteRelation(relation.id)(graph);
      }
      return graph;
    };
  }

  // modules/actions/discard_tags.js
  function actionDiscardTags(difference2, discardTags) {
    discardTags = discardTags || {};
    return (graph) => {
      difference2.modified().forEach(checkTags);
      difference2.created().forEach(checkTags);
      return graph;
      function checkTags(entity) {
        const keys2 = Object.keys(entity.tags);
        let didDiscard = false;
        let tags = {};
        for (let i3 = 0; i3 < keys2.length; i3++) {
          const k2 = keys2[i3];
          if (discardTags[k2] || !entity.tags[k2]) {
            didDiscard = true;
          } else {
            tags[k2] = entity.tags[k2];
          }
        }
        if (didDiscard) {
          graph = graph.replace(entity.update({ tags }));
        }
      }
    };
  }

  // modules/actions/disconnect.js
  function actionDisconnect(nodeId, newNodeId) {
    var wayIds;
    var disconnectableRelationTypes = {
      "associatedStreet": true,
      "enforcement": true,
      "site": true
    };
    var action = function(graph) {
      var node = graph.entity(nodeId);
      var connections = action.connections(graph);
      connections.forEach(function(connection) {
        var way = graph.entity(connection.wayID);
        var newNode = osmNode({ id: newNodeId, loc: node.loc, tags: node.tags });
        graph = graph.replace(newNode);
        if (connection.index === 0 && way.isArea()) {
          graph = graph.replace(way.replaceNode(way.nodes[0], newNode.id));
        } else if (way.isClosed() && connection.index === way.nodes.length - 1) {
          graph = graph.replace(way.unclose().addNode(newNode.id));
        } else {
          graph = graph.replace(way.updateNode(newNode.id, connection.index));
        }
      });
      return graph;
    };
    action.connections = function(graph) {
      var candidates = [];
      var keeping = false;
      var parentWays = graph.parentWays(graph.entity(nodeId));
      var way, waynode;
      for (var i3 = 0; i3 < parentWays.length; i3++) {
        way = parentWays[i3];
        if (wayIds && wayIds.indexOf(way.id) === -1) {
          keeping = true;
          continue;
        }
        if (way.isArea() && way.nodes[0] === nodeId) {
          candidates.push({ wayID: way.id, index: 0 });
        } else {
          for (var j2 = 0; j2 < way.nodes.length; j2++) {
            waynode = way.nodes[j2];
            if (waynode === nodeId) {
              if (way.isClosed() && parentWays.length > 1 && wayIds && wayIds.indexOf(way.id) !== -1 && j2 === way.nodes.length - 1) {
                continue;
              }
              candidates.push({ wayID: way.id, index: j2 });
            }
          }
        }
      }
      return keeping ? candidates : candidates.slice(1);
    };
    action.disabled = function(graph) {
      var connections = action.connections(graph);
      if (connections.length === 0)
        return "not_connected";
      var parentWays = graph.parentWays(graph.entity(nodeId));
      var seenRelationIds = {};
      var sharedRelation;
      parentWays.forEach(function(way) {
        var relations = graph.parentRelations(way);
        relations.filter((relation) => !disconnectableRelationTypes[relation.tags.type]).forEach(function(relation) {
          if (relation.id in seenRelationIds) {
            if (wayIds) {
              if (wayIds.indexOf(way.id) !== -1 || wayIds.indexOf(seenRelationIds[relation.id]) !== -1) {
                sharedRelation = relation;
              }
            } else {
              sharedRelation = relation;
            }
          } else {
            seenRelationIds[relation.id] = way.id;
          }
        });
      });
      if (sharedRelation)
        return "relation";
    };
    action.limitWays = function(val) {
      if (!arguments.length)
        return wayIds;
      wayIds = val;
      return action;
    };
    return action;
  }

  // modules/actions/extract.js
  function actionExtract(entityID, projection2) {
    var extractedNodeID;
    var action = function(graph) {
      var entity = graph.entity(entityID);
      if (entity.type === "node") {
        return extractFromNode(entity, graph);
      }
      return extractFromWayOrRelation(entity, graph);
    };
    function extractFromNode(node, graph) {
      extractedNodeID = node.id;
      var replacement = osmNode({ loc: node.loc });
      graph = graph.replace(replacement);
      graph = graph.parentWays(node).reduce(function(accGraph, parentWay) {
        return accGraph.replace(parentWay.replaceNode(entityID, replacement.id));
      }, graph);
      return graph.parentRelations(node).reduce(function(accGraph, parentRel) {
        return accGraph.replace(parentRel.replaceMember(node, replacement));
      }, graph);
    }
    function extractFromWayOrRelation(entity, graph) {
      var fromGeometry = entity.geometry(graph);
      var keysToCopyAndRetain = ["source", "wheelchair"];
      var keysToRetain = ["area"];
      var buildingKeysToRetain = ["architect", "building", "height", "layer", "nycdoitt:bin"];
      var extractedLoc = path_default(projection2).centroid(entity.asGeoJSON(graph));
      extractedLoc = extractedLoc && projection2.invert(extractedLoc);
      if (!extractedLoc || !isFinite(extractedLoc[0]) || !isFinite(extractedLoc[1])) {
        extractedLoc = entity.extent(graph).center();
      }
      var indoorAreaValues = {
        area: true,
        corridor: true,
        elevator: true,
        level: true,
        room: true
      };
      var isBuilding = entity.tags.building && entity.tags.building !== "no" || entity.tags["building:part"] && entity.tags["building:part"] !== "no";
      var isIndoorArea = fromGeometry === "area" && entity.tags.indoor && indoorAreaValues[entity.tags.indoor];
      var entityTags = Object.assign({}, entity.tags);
      var pointTags = {};
      for (var key in entityTags) {
        if (entity.type === "relation" && key === "type") {
          continue;
        }
        if (keysToRetain.indexOf(key) !== -1) {
          continue;
        }
        if (isBuilding) {
          if (buildingKeysToRetain.indexOf(key) !== -1 || key.match(/^building:.{1,}/) || key.match(/^roof:.{1,}/))
            continue;
        }
        if (isIndoorArea && key === "indoor") {
          continue;
        }
        pointTags[key] = entityTags[key];
        if (keysToCopyAndRetain.indexOf(key) !== -1 || key.match(/^addr:.{1,}/)) {
          continue;
        } else if (isIndoorArea && key === "level") {
          continue;
        }
        delete entityTags[key];
      }
      if (!isBuilding && !isIndoorArea && fromGeometry === "area") {
        entityTags.area = "yes";
      }
      var replacement = osmNode({ loc: extractedLoc, tags: pointTags });
      graph = graph.replace(replacement);
      extractedNodeID = replacement.id;
      return graph.replace(entity.update({ tags: entityTags }));
    }
    action.getExtractedNodeID = function() {
      return extractedNodeID;
    };
    return action;
  }

  // modules/actions/join.js
  function actionJoin(ids) {
    function groupEntitiesByGeometry(graph) {
      var entities = ids.map(function(id2) {
        return graph.entity(id2);
      });
      return Object.assign(
        { line: [] },
        utilArrayGroupBy(entities, function(entity) {
          return entity.geometry(graph);
        })
      );
    }
    var action = function(graph) {
      var ways = ids.map(graph.entity, graph);
      var survivorID = utilOldestID(ways.map((way) => way.id));
      ways.sort(function(a2, b2) {
        var aSided = a2.isSided();
        var bSided = b2.isSided();
        return aSided && !bSided ? -1 : bSided && !aSided ? 1 : 0;
      });
      var sequences = osmJoinWays(ways, graph);
      var joined = sequences[0];
      graph = sequences.actions.reduce(function(g3, action2) {
        return action2(g3);
      }, graph);
      var survivor = graph.entity(survivorID);
      survivor = survivor.update({ nodes: joined.nodes.map(function(n3) {
        return n3.id;
      }) });
      graph = graph.replace(survivor);
      joined.forEach(function(way) {
        if (way.id === survivorID)
          return;
        graph.parentRelations(way).forEach(function(parent) {
          graph = graph.replace(parent.replaceMember(way, survivor));
        });
        survivor = survivor.mergeTags(way.tags);
        graph = graph.replace(survivor);
        graph = actionDeleteWay(way.id)(graph);
      });
      function checkForSimpleMultipolygon() {
        if (!survivor.isClosed())
          return;
        var multipolygons = graph.parentMultipolygons(survivor).filter(function(multipolygon2) {
          return multipolygon2.members.length === 1;
        });
        if (multipolygons.length !== 1)
          return;
        var multipolygon = multipolygons[0];
        for (var key in survivor.tags) {
          if (multipolygon.tags[key] && // don't collapse if tags cannot be cleanly merged
          multipolygon.tags[key] !== survivor.tags[key])
            return;
        }
        survivor = survivor.mergeTags(multipolygon.tags);
        graph = graph.replace(survivor);
        graph = actionDeleteRelation(
          multipolygon.id,
          true
          /* allow untagged members */
        )(graph);
        var tags = Object.assign({}, survivor.tags);
        if (survivor.geometry(graph) !== "area") {
          tags.area = "yes";
        }
        delete tags.type;
        survivor = survivor.update({ tags });
        graph = graph.replace(survivor);
      }
      checkForSimpleMultipolygon();
      return graph;
    };
    action.resultingWayNodesLength = function(graph) {
      return ids.reduce(function(count, id2) {
        return count + graph.entity(id2).nodes.length;
      }, 0) - ids.length - 1;
    };
    action.disabled = function(graph) {
      var geometries = groupEntitiesByGeometry(graph);
      if (ids.length < 2 || ids.length !== geometries.line.length) {
        return "not_eligible";
      }
      var joined = osmJoinWays(ids.map(graph.entity, graph), graph);
      if (joined.length > 1) {
        return "not_adjacent";
      }
      var i3;
      var sortedParentRelations = function(id2) {
        return graph.parentRelations(graph.entity(id2)).filter((rel) => !rel.isRestriction() && !rel.isConnectivity()).sort((a2, b2) => a2.id - b2.id);
      };
      var relsA = sortedParentRelations(ids[0]);
      for (i3 = 1; i3 < ids.length; i3++) {
        var relsB = sortedParentRelations(ids[i3]);
        if (!utilArrayIdentical(relsA, relsB)) {
          return "conflicting_relations";
        }
      }
      for (i3 = 0; i3 < ids.length - 1; i3++) {
        for (var j2 = i3 + 1; j2 < ids.length; j2++) {
          var path1 = graph.childNodes(graph.entity(ids[i3])).map(function(e3) {
            return e3.loc;
          });
          var path2 = graph.childNodes(graph.entity(ids[j2])).map(function(e3) {
            return e3.loc;
          });
          var intersections = geoPathIntersections(path1, path2);
          var common = utilArrayIntersection(
            joined[0].nodes.map(function(n3) {
              return n3.loc.toString();
            }),
            intersections.map(function(n3) {
              return n3.toString();
            })
          );
          if (common.length !== intersections.length) {
            return "paths_intersect";
          }
        }
      }
      var nodeIds = joined[0].nodes.map(function(n3) {
        return n3.id;
      }).slice(1, -1);
      var relation;
      var tags = {};
      var conflicting = false;
      joined[0].forEach(function(way) {
        var parents = graph.parentRelations(way);
        parents.forEach(function(parent) {
          if ((parent.isRestriction() || parent.isConnectivity()) && parent.members.some(function(m2) {
            return nodeIds.indexOf(m2.id) >= 0;
          })) {
            relation = parent;
          }
        });
        for (var k2 in way.tags) {
          if (!(k2 in tags)) {
            tags[k2] = way.tags[k2];
          } else if (tags[k2] && osmIsInterestingTag(k2) && tags[k2] !== way.tags[k2]) {
            conflicting = true;
          }
        }
      });
      if (relation) {
        return relation.isRestriction() ? "restriction" : "connectivity";
      }
      if (conflicting) {
        return "conflicting_tags";
      }
    };
    return action;
  }

  // modules/actions/merge.js
  function actionMerge(ids) {
    function groupEntitiesByGeometry(graph) {
      var entities = ids.map(function(id2) {
        return graph.entity(id2);
      });
      return Object.assign(
        { point: [], area: [], line: [], relation: [] },
        utilArrayGroupBy(entities, function(entity) {
          return entity.geometry(graph);
        })
      );
    }
    var action = function(graph) {
      var geometries = groupEntitiesByGeometry(graph);
      var target = geometries.area[0] || geometries.line[0];
      var points = geometries.point;
      points.forEach(function(point2) {
        target = target.mergeTags(point2.tags);
        graph = graph.replace(target);
        graph.parentRelations(point2).forEach(function(parent) {
          graph = graph.replace(parent.replaceMember(point2, target));
        });
        var nodes = utilArrayUniq(graph.childNodes(target));
        var removeNode = point2;
        if (!point2.isNew()) {
          var inserted = false;
          var canBeReplaced = function(node2) {
            return !(graph.parentWays(node2).length > 1 || graph.parentRelations(node2).length);
          };
          var replaceNode = function(node2) {
            graph = graph.replace(point2.update({ tags: node2.tags, loc: node2.loc }));
            target = target.replaceNode(node2.id, point2.id);
            graph = graph.replace(target);
            removeNode = node2;
            inserted = true;
          };
          var i3;
          var node;
          for (i3 = 0; i3 < nodes.length; i3++) {
            node = nodes[i3];
            if (canBeReplaced(node) && node.isNew()) {
              replaceNode(node);
              break;
            }
          }
          if (!inserted && point2.hasInterestingTags()) {
            for (i3 = 0; i3 < nodes.length; i3++) {
              node = nodes[i3];
              if (canBeReplaced(node) && !node.hasInterestingTags()) {
                replaceNode(node);
                break;
              }
            }
            if (!inserted) {
              for (i3 = 0; i3 < nodes.length; i3++) {
                node = nodes[i3];
                if (canBeReplaced(node) && utilCompareIDs(point2.id, node.id) < 0) {
                  replaceNode(node);
                  break;
                }
              }
            }
          }
        }
        graph = graph.remove(removeNode);
      });
      if (target.tags.area === "yes") {
        var tags = Object.assign({}, target.tags);
        delete tags.area;
        if (osmTagSuggestingArea(tags)) {
          target = target.update({ tags });
          graph = graph.replace(target);
        }
      }
      return graph;
    };
    action.disabled = function(graph) {
      var geometries = groupEntitiesByGeometry(graph);
      if (geometries.point.length === 0 || geometries.area.length + geometries.line.length !== 1 || geometries.relation.length !== 0) {
        return "not_eligible";
      }
    };
    return action;
  }

  // modules/actions/merge_nodes.js
  function actionMergeNodes(nodeIDs, loc) {
    function chooseLoc(graph) {
      if (!nodeIDs.length)
        return null;
      var sum = [0, 0];
      var interestingCount = 0;
      var interestingLoc;
      for (var i3 = 0; i3 < nodeIDs.length; i3++) {
        var node = graph.entity(nodeIDs[i3]);
        if (node.hasInterestingTags()) {
          interestingLoc = ++interestingCount === 1 ? node.loc : null;
        }
        sum = geoVecAdd(sum, node.loc);
      }
      return interestingLoc || geoVecScale(sum, 1 / nodeIDs.length);
    }
    var action = function(graph) {
      if (nodeIDs.length < 2)
        return graph;
      var toLoc = loc;
      if (!toLoc) {
        toLoc = chooseLoc(graph);
      }
      for (var i3 = 0; i3 < nodeIDs.length; i3++) {
        var node = graph.entity(nodeIDs[i3]);
        if (node.loc !== toLoc) {
          graph = graph.replace(node.move(toLoc));
        }
      }
      return actionConnect(nodeIDs)(graph);
    };
    action.disabled = function(graph) {
      if (nodeIDs.length < 2)
        return "not_eligible";
      for (var i3 = 0; i3 < nodeIDs.length; i3++) {
        var entity = graph.entity(nodeIDs[i3]);
        if (entity.type !== "node")
          return "not_eligible";
      }
      return actionConnect(nodeIDs).disabled(graph);
    };
    return action;
  }

  // modules/osm/changeset.js
  function osmChangeset() {
    if (!(this instanceof osmChangeset)) {
      return new osmChangeset().initialize(arguments);
    } else if (arguments.length) {
      this.initialize(arguments);
    }
  }
  osmEntity.changeset = osmChangeset;
  osmChangeset.prototype = Object.create(osmEntity.prototype);
  Object.assign(osmChangeset.prototype, {
    type: "changeset",
    extent: function() {
      return new geoExtent();
    },
    geometry: function() {
      return "changeset";
    },
    asJXON: function() {
      return {
        osm: {
          changeset: {
            tag: Object.keys(this.tags).map(function(k2) {
              return { "@k": k2, "@v": this.tags[k2] };
            }, this),
            "@version": 0.6,
            "@generator": "iD"
          }
        }
      };
    },
    // Generate [osmChange](http://wiki.openstreetmap.org/wiki/OsmChange)
    // XML. Returns a string.
    osmChangeJXON: function(changes) {
      var changeset_id = this.id;
      function nest(x2, order) {
        var groups = {};
        for (var i3 = 0; i3 < x2.length; i3++) {
          var tagName = Object.keys(x2[i3])[0];
          if (!groups[tagName])
            groups[tagName] = [];
          groups[tagName].push(x2[i3][tagName]);
        }
        var ordered = {};
        order.forEach(function(o2) {
          if (groups[o2])
            ordered[o2] = groups[o2];
        });
        return ordered;
      }
      function sort(changes2) {
        function resolve(item) {
          return relations.find(function(relation2) {
            return item.keyAttributes.type === "relation" && item.keyAttributes.ref === relation2["@id"];
          });
        }
        function isNew(item) {
          return !sorted[item["@id"]] && !processing.find(function(proc) {
            return proc["@id"] === item["@id"];
          });
        }
        var processing = [];
        var sorted = {};
        var relations = changes2.relation;
        if (!relations)
          return changes2;
        for (var i3 = 0; i3 < relations.length; i3++) {
          var relation = relations[i3];
          if (!sorted[relation["@id"]]) {
            processing.push(relation);
          }
          while (processing.length > 0) {
            var next = processing[0], deps = next.member.map(resolve).filter(Boolean).filter(isNew);
            if (deps.length === 0) {
              sorted[next["@id"]] = next;
              processing.shift();
            } else {
              processing = deps.concat(processing);
            }
          }
        }
        changes2.relation = Object.values(sorted);
        return changes2;
      }
      function rep(entity) {
        return entity.asJXON(changeset_id);
      }
      return {
        osmChange: {
          "@version": 0.6,
          "@generator": "iD",
          "create": sort(nest(changes.created.map(rep), ["node", "way", "relation"])),
          "modify": nest(changes.modified.map(rep), ["node", "way", "relation"]),
          "delete": Object.assign(nest(changes.deleted.map(rep), ["relation", "way", "node"]), { "@if-unused": true })
        }
      };
    },
    asGeoJSON: function() {
      return {};
    }
  });

  // modules/osm/note.js
  function osmNote() {
    if (!(this instanceof osmNote)) {
      return new osmNote().initialize(arguments);
    } else if (arguments.length) {
      this.initialize(arguments);
    }
  }
  osmNote.id = function() {
    return osmNote.id.next--;
  };
  osmNote.id.next = -1;
  Object.assign(osmNote.prototype, {
    type: "note",
    initialize: function(sources) {
      for (var i3 = 0; i3 < sources.length; ++i3) {
        var source = sources[i3];
        for (var prop in source) {
          if (Object.prototype.hasOwnProperty.call(source, prop)) {
            if (source[prop] === void 0) {
              delete this[prop];
            } else {
              this[prop] = source[prop];
            }
          }
        }
      }
      if (!this.id) {
        this.id = osmNote.id().toString();
      }
      return this;
    },
    extent: function() {
      return new geoExtent(this.loc);
    },
    update: function(attrs) {
      return osmNote(this, attrs);
    },
    isNew: function() {
      return this.id < 0;
    },
    move: function(loc) {
      return this.update({ loc });
    }
  });

  // modules/osm/relation.js
  function osmRelation() {
    if (!(this instanceof osmRelation)) {
      return new osmRelation().initialize(arguments);
    } else if (arguments.length) {
      this.initialize(arguments);
    }
  }
  osmEntity.relation = osmRelation;
  osmRelation.prototype = Object.create(osmEntity.prototype);
  osmRelation.creationOrder = function(a2, b2) {
    var aId = parseInt(osmEntity.id.toOSM(a2.id), 10);
    var bId = parseInt(osmEntity.id.toOSM(b2.id), 10);
    if (aId < 0 || bId < 0)
      return aId - bId;
    return bId - aId;
  };
  Object.assign(osmRelation.prototype, {
    type: "relation",
    members: [],
    copy: function(resolver, copies) {
      if (copies[this.id])
        return copies[this.id];
      var copy2 = osmEntity.prototype.copy.call(this, resolver, copies);
      var members = this.members.map(function(member) {
        return Object.assign({}, member, { id: resolver.entity(member.id).copy(resolver, copies).id });
      });
      copy2 = copy2.update({ members });
      copies[this.id] = copy2;
      return copy2;
    },
    extent: function(resolver, memo) {
      return resolver.transient(this, "extent", function() {
        if (memo && memo[this.id])
          return geoExtent();
        memo = memo || {};
        memo[this.id] = true;
        var extent = geoExtent();
        for (var i3 = 0; i3 < this.members.length; i3++) {
          var member = resolver.hasEntity(this.members[i3].id);
          if (member) {
            extent._extend(member.extent(resolver, memo));
          }
        }
        return extent;
      });
    },
    geometry: function(graph) {
      return graph.transient(this, "geometry", function() {
        return this.isMultipolygon() ? "area" : "relation";
      });
    },
    isDegenerate: function() {
      return this.members.length === 0;
    },
    // Return an array of members, each extended with an 'index' property whose value
    // is the member index.
    indexedMembers: function() {
      var result = new Array(this.members.length);
      for (var i3 = 0; i3 < this.members.length; i3++) {
        result[i3] = Object.assign({}, this.members[i3], { index: i3 });
      }
      return result;
    },
    // Return the first member with the given role. A copy of the member object
    // is returned, extended with an 'index' property whose value is the member index.
    memberByRole: function(role) {
      for (var i3 = 0; i3 < this.members.length; i3++) {
        if (this.members[i3].role === role) {
          return Object.assign({}, this.members[i3], { index: i3 });
        }
      }
    },
    // Same as memberByRole, but returns all members with the given role
    membersByRole: function(role) {
      var result = [];
      for (var i3 = 0; i3 < this.members.length; i3++) {
        if (this.members[i3].role === role) {
          result.push(Object.assign({}, this.members[i3], { index: i3 }));
        }
      }
      return result;
    },
    // Return the first member with the given id. A copy of the member object
    // is returned, extended with an 'index' property whose value is the member index.
    memberById: function(id2) {
      for (var i3 = 0; i3 < this.members.length; i3++) {
        if (this.members[i3].id === id2) {
          return Object.assign({}, this.members[i3], { index: i3 });
        }
      }
    },
    // Return the first member with the given id and role. A copy of the member object
    // is returned, extended with an 'index' property whose value is the member index.
    memberByIdAndRole: function(id2, role) {
      for (var i3 = 0; i3 < this.members.length; i3++) {
        if (this.members[i3].id === id2 && this.members[i3].role === role) {
          return Object.assign({}, this.members[i3], { index: i3 });
        }
      }
    },
    addMember: function(member, index) {
      var members = this.members.slice();
      members.splice(index === void 0 ? members.length : index, 0, member);
      return this.update({ members });
    },
    updateMember: function(member, index) {
      var members = this.members.slice();
      members.splice(index, 1, Object.assign({}, members[index], member));
      return this.update({ members });
    },
    removeMember: function(index) {
      var members = this.members.slice();
      members.splice(index, 1);
      return this.update({ members });
    },
    removeMembersWithID: function(id2) {
      var members = this.members.filter(function(m2) {
        return m2.id !== id2;
      });
      return this.update({ members });
    },
    moveMember: function(fromIndex, toIndex) {
      var members = this.members.slice();
      members.splice(toIndex, 0, members.splice(fromIndex, 1)[0]);
      return this.update({ members });
    },
    // Wherever a member appears with id `needle.id`, replace it with a member
    // with id `replacement.id`, type `replacement.type`, and the original role,
    // By default, adding a duplicate member (by id and role) is prevented.
    // Return an updated relation.
    replaceMember: function(needle, replacement, keepDuplicates) {
      if (!this.memberById(needle.id))
        return this;
      var members = [];
      for (var i3 = 0; i3 < this.members.length; i3++) {
        var member = this.members[i3];
        if (member.id !== needle.id) {
          members.push(member);
        } else if (keepDuplicates || !this.memberByIdAndRole(replacement.id, member.role)) {
          members.push({ id: replacement.id, type: replacement.type, role: member.role });
        }
      }
      return this.update({ members });
    },
    asJXON: function(changeset_id) {
      var r2 = {
        relation: {
          "@id": this.osmId(),
          "@version": this.version || 0,
          member: this.members.map(function(member) {
            return {
              keyAttributes: {
                type: member.type,
                role: member.role,
                ref: osmEntity.id.toOSM(member.id)
              }
            };
          }, this),
          tag: Object.keys(this.tags).map(function(k2) {
            return { keyAttributes: { k: k2, v: this.tags[k2] } };
          }, this)
        }
      };
      if (changeset_id) {
        r2.relation["@changeset"] = changeset_id;
      }
      return r2;
    },
    asGeoJSON: function(resolver) {
      return resolver.transient(this, "GeoJSON", function() {
        if (this.isMultipolygon()) {
          return {
            type: "MultiPolygon",
            coordinates: this.multipolygon(resolver)
          };
        } else {
          return {
            type: "FeatureCollection",
            properties: this.tags,
            features: this.members.map(function(member) {
              return Object.assign({ role: member.role }, resolver.entity(member.id).asGeoJSON(resolver));
            })
          };
        }
      });
    },
    area: function(resolver) {
      return resolver.transient(this, "area", function() {
        return area_default(this.asGeoJSON(resolver));
      });
    },
    isMultipolygon: function() {
      return this.tags.type === "multipolygon";
    },
    isComplete: function(resolver) {
      for (var i3 = 0; i3 < this.members.length; i3++) {
        if (!resolver.hasEntity(this.members[i3].id)) {
          return false;
        }
      }
      return true;
    },
    hasFromViaTo: function() {
      return this.members.some(function(m2) {
        return m2.role === "from";
      }) && this.members.some(function(m2) {
        return m2.role === "via";
      }) && this.members.some(function(m2) {
        return m2.role === "to";
      });
    },
    isRestriction: function() {
      return !!(this.tags.type && this.tags.type.match(/^restriction:?/));
    },
    isValidRestriction: function() {
      if (!this.isRestriction())
        return false;
      var froms = this.members.filter(function(m2) {
        return m2.role === "from";
      });
      var vias = this.members.filter(function(m2) {
        return m2.role === "via";
      });
      var tos = this.members.filter(function(m2) {
        return m2.role === "to";
      });
      if (froms.length !== 1 && this.tags.restriction !== "no_entry")
        return false;
      if (froms.some(function(m2) {
        return m2.type !== "way";
      }))
        return false;
      if (tos.length !== 1 && this.tags.restriction !== "no_exit")
        return false;
      if (tos.some(function(m2) {
        return m2.type !== "way";
      }))
        return false;
      if (vias.length === 0)
        return false;
      if (vias.length > 1 && vias.some(function(m2) {
        return m2.type !== "way";
      }))
        return false;
      return true;
    },
    isConnectivity: function() {
      return !!(this.tags.type && this.tags.type.match(/^connectivity:?/));
    },
    // Returns an array [A0, ... An], each Ai being an array of node arrays [Nds0, ... Ndsm],
    // where Nds0 is an outer ring and subsequent Ndsi's (if any i > 0) being inner rings.
    //
    // This corresponds to the structure needed for rendering a multipolygon path using a
    // `evenodd` fill rule, as well as the structure of a GeoJSON MultiPolygon geometry.
    //
    // In the case of invalid geometries, this function will still return a result which
    // includes the nodes of all way members, but some Nds may be unclosed and some inner
    // rings not matched with the intended outer ring.
    //
    multipolygon: function(resolver) {
      var outers = this.members.filter(function(m2) {
        return "outer" === (m2.role || "outer");
      });
      var inners = this.members.filter(function(m2) {
        return "inner" === m2.role;
      });
      outers = osmJoinWays(outers, resolver);
      inners = osmJoinWays(inners, resolver);
      var sequenceToLineString = function(sequence) {
        if (sequence.nodes.length > 2 && sequence.nodes[0] !== sequence.nodes[sequence.nodes.length - 1]) {
          sequence.nodes.push(sequence.nodes[0]);
        }
        return sequence.nodes.map(function(node) {
          return node.loc;
        });
      };
      outers = outers.map(sequenceToLineString);
      inners = inners.map(sequenceToLineString);
      var result = outers.map(function(o3) {
        return [area_default({ type: "Polygon", coordinates: [o3] }) > 2 * Math.PI ? o3.reverse() : o3];
      });
      function findOuter(inner2) {
        var o3, outer;
        for (o3 = 0; o3 < outers.length; o3++) {
          outer = outers[o3];
          if (geoPolygonContainsPolygon(outer, inner2)) {
            return o3;
          }
        }
        for (o3 = 0; o3 < outers.length; o3++) {
          outer = outers[o3];
          if (geoPolygonIntersectsPolygon(outer, inner2, false)) {
            return o3;
          }
        }
      }
      for (var i3 = 0; i3 < inners.length; i3++) {
        var inner = inners[i3];
        if (area_default({ type: "Polygon", coordinates: [inner] }) < 2 * Math.PI) {
          inner = inner.reverse();
        }
        var o2 = findOuter(inners[i3]);
        if (o2 !== void 0) {
          result[o2].push(inners[i3]);
        } else {
          result.push([inners[i3]]);
        }
      }
      return result;
    }
  });

  // modules/osm/qa_item.js
  var QAItem = class _QAItem {
    constructor(loc, service, itemType, id2, props) {
      this.loc = loc;
      this.service = service.title;
      this.itemType = itemType;
      this.id = id2 ? id2 : "".concat(_QAItem.id());
      this.update(props);
      if (service && typeof service.getIcon === "function") {
        this.icon = service.getIcon(itemType);
      }
    }
    update(props) {
      const { loc, service, itemType, id: id2 } = this;
      Object.keys(props).forEach((prop) => this[prop] = props[prop]);
      this.loc = loc;
      this.service = service;
      this.itemType = itemType;
      this.id = id2;
      return this;
    }
    // Generic handling for newly created QAItems
    static id() {
      return this.nextId--;
    }
  };
  QAItem.nextId = -1;

  // modules/actions/split.js
  function actionSplit(nodeIds, newWayIds) {
    if (typeof nodeIds === "string")
      nodeIds = [nodeIds];
    var _wayIDs;
    var _keepHistoryOn = "longest";
    const circularJunctions = ["roundabout", "circular"];
    var _createdWayIDs = [];
    function dist(graph, nA, nB) {
      var locA = graph.entity(nA).loc;
      var locB = graph.entity(nB).loc;
      var epsilon3 = 1e-6;
      return locA && locB ? geoSphericalDistance(locA, locB) : epsilon3;
    }
    function splitArea(nodes, idxA, graph) {
      var lengths = new Array(nodes.length);
      var length2;
      var i3;
      var best = 0;
      var idxB;
      function wrap2(index) {
        return utilWrap(index, nodes.length);
      }
      length2 = 0;
      for (i3 = wrap2(idxA + 1); i3 !== idxA; i3 = wrap2(i3 + 1)) {
        length2 += dist(graph, nodes[i3], nodes[wrap2(i3 - 1)]);
        lengths[i3] = length2;
      }
      length2 = 0;
      for (i3 = wrap2(idxA - 1); i3 !== idxA; i3 = wrap2(i3 - 1)) {
        length2 += dist(graph, nodes[i3], nodes[wrap2(i3 + 1)]);
        if (length2 < lengths[i3]) {
          lengths[i3] = length2;
        }
      }
      for (i3 = 0; i3 < nodes.length; i3++) {
        var cost = lengths[i3] / dist(graph, nodes[idxA], nodes[i3]);
        if (cost > best) {
          idxB = i3;
          best = cost;
        }
      }
      return idxB;
    }
    function totalLengthBetweenNodes(graph, nodes) {
      var totalLength = 0;
      for (var i3 = 0; i3 < nodes.length - 1; i3++) {
        totalLength += dist(graph, nodes[i3], nodes[i3 + 1]);
      }
      return totalLength;
    }
    function split(graph, nodeId, wayA, newWayId) {
      var wayB = osmWay({ id: newWayId, tags: wayA.tags });
      var nodesA;
      var nodesB;
      var isArea = wayA.isArea();
      if (wayA.isClosed()) {
        var nodes = wayA.nodes.slice(0, -1);
        var idxA = nodes.indexOf(nodeId);
        var idxB = splitArea(nodes, idxA, graph);
        if (idxB < idxA) {
          nodesA = nodes.slice(idxA).concat(nodes.slice(0, idxB + 1));
          nodesB = nodes.slice(idxB, idxA + 1);
        } else {
          nodesA = nodes.slice(idxA, idxB + 1);
          nodesB = nodes.slice(idxB).concat(nodes.slice(0, idxA + 1));
        }
      } else {
        var idx = wayA.nodes.indexOf(nodeId, 1);
        nodesA = wayA.nodes.slice(0, idx + 1);
        nodesB = wayA.nodes.slice(idx);
      }
      var lengthA = totalLengthBetweenNodes(graph, nodesA);
      var lengthB = totalLengthBetweenNodes(graph, nodesB);
      if (_keepHistoryOn === "longest" && lengthB > lengthA) {
        wayA = wayA.update({ nodes: nodesB });
        wayB = wayB.update({ nodes: nodesA });
        var temp = lengthA;
        lengthA = lengthB;
        lengthB = temp;
      } else {
        wayA = wayA.update({ nodes: nodesA });
        wayB = wayB.update({ nodes: nodesB });
      }
      if (wayA.tags.step_count) {
        var stepCount = Number(wayA.tags.step_count);
        if (stepCount && // ensure a number
        isFinite(stepCount) && // ensure positive
        stepCount > 0 && // ensure integer
        Math.round(stepCount) === stepCount) {
          var tagsA = Object.assign({}, wayA.tags);
          var tagsB = Object.assign({}, wayB.tags);
          var ratioA = lengthA / (lengthA + lengthB);
          var countA = Math.round(stepCount * ratioA);
          tagsA.step_count = countA.toString();
          tagsB.step_count = (stepCount - countA).toString();
          wayA = wayA.update({ tags: tagsA });
          wayB = wayB.update({ tags: tagsB });
        }
      }
      graph = graph.replace(wayA);
      graph = graph.replace(wayB);
      graph.parentRelations(wayA).forEach(function(relation) {
        if (relation.hasFromViaTo()) {
          var f2 = relation.memberByRole("from");
          var v2 = relation.membersByRole("via");
          var t2 = relation.memberByRole("to");
          var i3;
          if (f2.id === wayA.id || t2.id === wayA.id) {
            var keepB = false;
            if (v2.length === 1 && v2[0].type === "node") {
              keepB = wayB.contains(v2[0].id);
            } else {
              for (i3 = 0; i3 < v2.length; i3++) {
                if (v2[i3].type === "way") {
                  var wayVia = graph.hasEntity(v2[i3].id);
                  if (wayVia && utilArrayIntersection(wayB.nodes, wayVia.nodes).length) {
                    keepB = true;
                    break;
                  }
                }
              }
            }
            if (keepB) {
              relation = relation.replaceMember(wayA, wayB);
              graph = graph.replace(relation);
            }
          } else {
            for (i3 = 0; i3 < v2.length; i3++) {
              if (v2[i3].type === "way" && v2[i3].id === wayA.id) {
                graph = splitWayMember(graph, relation.id, wayA, wayB);
              }
            }
          }
        } else {
          graph = splitWayMember(graph, relation.id, wayA, wayB);
        }
      });
      if (isArea) {
        var multipolygon = osmRelation({
          tags: Object.assign({}, wayA.tags, { type: "multipolygon" }),
          members: [
            { id: wayA.id, role: "outer", type: "way" },
            { id: wayB.id, role: "outer", type: "way" }
          ]
        });
        graph = graph.replace(multipolygon);
        graph = graph.replace(wayA.update({ tags: {} }));
        graph = graph.replace(wayB.update({ tags: {} }));
      }
      _createdWayIDs.push(wayB.id);
      return graph;
    }
    function splitWayMember(graph, relationId, wayA, wayB) {
      function connects(way1, way2) {
        if (way1.nodes.length < 2 || way2.nodes.length < 2)
          return false;
        if (circularJunctions.includes(way1.tags.junction) && way1.isClosed()) {
          return way1.nodes.some((nodeId) => nodeId === way2.nodes[0] || nodeId === way2.nodes[way2.nodes.length - 1]);
        } else if (circularJunctions.includes(way2.tags.junction) && way2.isClosed()) {
          return way2.nodes.some((nodeId) => nodeId === way1.nodes[0] || nodeId === way1.nodes[way1.nodes.length - 1]);
        }
        if (way1.nodes[0] === way2.nodes[0])
          return true;
        if (way1.nodes[0] === way2.nodes[way2.nodes.length - 1])
          return true;
        if (way1.nodes[way1.nodes.length - 1] === way2.nodes[way2.nodes.length - 1])
          return true;
        if (way1.nodes[way1.nodes.length - 1] === way2.nodes[0])
          return true;
        return false;
      }
      let relation = graph.entity(relationId);
      const insertMembers = [];
      const members = relation.members;
      for (let i3 = 0; i3 < members.length; i3++) {
        const member = members[i3];
        if (member.id === wayA.id) {
          let wayAconnectsPrev = false;
          let wayAconnectsNext = false;
          let wayBconnectsPrev = false;
          let wayBconnectsNext = false;
          if (i3 > 0 && graph.hasEntity(members[i3 - 1].id)) {
            const prevEntity = graph.entity(members[i3 - 1].id);
            if (prevEntity.type === "way") {
              wayAconnectsPrev = connects(prevEntity, wayA);
              wayBconnectsPrev = connects(prevEntity, wayB);
            }
          }
          if (i3 < members.length - 1 && graph.hasEntity(members[i3 + 1].id)) {
            const nextEntity = graph.entity(members[i3 + 1].id);
            if (nextEntity.type === "way") {
              wayAconnectsNext = connects(nextEntity, wayA);
              wayBconnectsNext = connects(nextEntity, wayB);
            }
          }
          if (wayAconnectsPrev && !wayAconnectsNext || !wayBconnectsPrev && wayBconnectsNext && !(!wayAconnectsPrev && wayAconnectsNext)) {
            insertMembers.push({ at: i3 + 1, role: member.role });
            continue;
          }
          if (!wayAconnectsPrev && wayAconnectsNext || wayBconnectsPrev && !wayBconnectsNext && !(wayAconnectsPrev && !wayAconnectsNext)) {
            insertMembers.push({ at: i3, role: member.role });
            continue;
          }
          if (wayAconnectsPrev && wayBconnectsPrev && wayAconnectsNext && wayBconnectsNext) {
            if (i3 > 2 && graph.hasEntity(members[i3 - 2].id)) {
              const prev2Entity = graph.entity(members[i3 - 2].id);
              if (connects(prev2Entity, wayA) && !connects(prev2Entity, wayB)) {
                insertMembers.push({ at: i3, role: member.role });
                continue;
              }
              if (connects(prev2Entity, wayB) && !connects(prev2Entity, wayA)) {
                insertMembers.push({ at: i3 + 1, role: member.role });
                continue;
              }
            }
            if (i3 < members.length - 2 && graph.hasEntity(members[i3 + 2].id)) {
              const next2Entity = graph.entity(members[i3 + 2].id);
              if (connects(next2Entity, wayA) && !connects(next2Entity, wayB)) {
                insertMembers.push({ at: i3 + 1, role: member.role });
                continue;
              }
              if (connects(next2Entity, wayB) && !connects(next2Entity, wayA)) {
                insertMembers.push({ at: i3, role: member.role });
                continue;
              }
            }
          }
          if (wayA.nodes[wayA.nodes.length - 1] === wayB.nodes[0]) {
            insertMembers.push({ at: i3 + 1, role: member.role });
          } else {
            insertMembers.push({ at: i3, role: member.role });
          }
        }
      }
      insertMembers.reverse().forEach((item) => {
        graph = graph.replace(relation.addMember({
          id: wayB.id,
          type: "way",
          role: item.role
        }, item.at));
        relation = graph.entity(relation.id);
      });
      return graph;
    }
    var action = function(graph) {
      _createdWayIDs = [];
      var newWayIndex = 0;
      for (var i3 = 0; i3 < nodeIds.length; i3++) {
        var nodeId = nodeIds[i3];
        var candidates = action.waysForNode(nodeId, graph);
        for (var j2 = 0; j2 < candidates.length; j2++) {
          graph = split(graph, nodeId, candidates[j2], newWayIds && newWayIds[newWayIndex]);
          newWayIndex += 1;
        }
      }
      return graph;
    };
    action.getCreatedWayIDs = function() {
      return _createdWayIDs;
    };
    action.waysForNode = function(nodeId, graph) {
      var node = graph.entity(nodeId);
      var splittableParents = graph.parentWays(node).filter(isSplittable);
      if (!_wayIDs) {
        var hasLine = splittableParents.some(function(parent) {
          return parent.geometry(graph) === "line";
        });
        if (hasLine) {
          return splittableParents.filter(function(parent) {
            return parent.geometry(graph) === "line";
          });
        }
      }
      return splittableParents;
      function isSplittable(parent) {
        if (_wayIDs && _wayIDs.indexOf(parent.id) === -1)
          return false;
        if (parent.isClosed())
          return true;
        for (var i3 = 1; i3 < parent.nodes.length - 1; i3++) {
          if (parent.nodes[i3] === nodeId)
            return true;
        }
        return false;
      }
    };
    action.ways = function(graph) {
      return utilArrayUniq([].concat.apply([], nodeIds.map(function(nodeId) {
        return action.waysForNode(nodeId, graph);
      })));
    };
    action.disabled = function(graph) {
      for (const nodeId of nodeIds) {
        const candidates = action.waysForNode(nodeId, graph);
        if (candidates.length === 0 || _wayIDs && _wayIDs.length !== candidates.length) {
          return "not_eligible";
        }
        for (const way of candidates) {
          const parentRelations = graph.parentRelations(way);
          for (const parentRelation of parentRelations) {
            if (parentRelation.hasFromViaTo()) {
              const vias = parentRelation.membersByRole("via");
              if (!vias.every((via) => graph.hasEntity(via.id))) {
                return "parent_incomplete";
              }
            } else {
              for (let i3 = 0; i3 < parentRelation.members.length; i3++) {
                if (parentRelation.members[i3].id === way.id) {
                  const memberBeforePresent = i3 > 0 && graph.hasEntity(parentRelation.members[i3 - 1].id);
                  const memberAfterPresent = i3 < parentRelation.members.length - 1 && graph.hasEntity(parentRelation.members[i3 + 1].id);
                  if (!memberBeforePresent && !memberAfterPresent && parentRelation.members.length > 1) {
                    return "parent_incomplete";
                  }
                }
              }
            }
            const relTypesExceptions = ["junction", "enforcement"];
            if (circularJunctions.includes(way.tags.junction) && way.isClosed() && !relTypesExceptions.includes(parentRelation.tags.type)) {
              return "simple_roundabout";
            }
          }
        }
      }
    };
    action.limitWays = function(val) {
      if (!arguments.length)
        return _wayIDs;
      _wayIDs = val;
      return action;
    };
    action.keepHistoryOn = function(val) {
      if (!arguments.length)
        return _keepHistoryOn;
      _keepHistoryOn = val;
      return action;
    };
    return action;
  }

  // modules/core/graph.js
  function coreGraph(other, mutable) {
    if (!(this instanceof coreGraph))
      return new coreGraph(other, mutable);
    if (other instanceof coreGraph) {
      var base = other.base();
      this.entities = Object.assign(Object.create(base.entities), other.entities);
      this._parentWays = Object.assign(Object.create(base.parentWays), other._parentWays);
      this._parentRels = Object.assign(Object.create(base.parentRels), other._parentRels);
    } else {
      this.entities = /* @__PURE__ */ Object.create({});
      this._parentWays = /* @__PURE__ */ Object.create({});
      this._parentRels = /* @__PURE__ */ Object.create({});
      this.rebase(other || [], [this]);
    }
    this.transients = {};
    this._childNodes = {};
    this.frozen = !mutable;
  }
  coreGraph.prototype = {
    hasEntity: function(id2) {
      return this.entities[id2];
    },
    entity: function(id2) {
      var entity = this.entities[id2];
      if (!entity) {
        entity = this.entities.__proto__[id2];
      }
      if (!entity) {
        throw new Error("entity " + id2 + " not found");
      }
      return entity;
    },
    geometry: function(id2) {
      return this.entity(id2).geometry(this);
    },
    transient: function(entity, key, fn) {
      var id2 = entity.id;
      var transients = this.transients[id2] || (this.transients[id2] = {});
      if (transients[key] !== void 0) {
        return transients[key];
      }
      transients[key] = fn.call(entity);
      return transients[key];
    },
    parentWays: function(entity) {
      var parents = this._parentWays[entity.id];
      var result = [];
      if (parents) {
        parents.forEach(function(id2) {
          result.push(this.entity(id2));
        }, this);
      }
      return result;
    },
    isPoi: function(entity) {
      var parents = this._parentWays[entity.id];
      return !parents || parents.size === 0;
    },
    isShared: function(entity) {
      var parents = this._parentWays[entity.id];
      return parents && parents.size > 1;
    },
    parentRelations: function(entity) {
      var parents = this._parentRels[entity.id];
      var result = [];
      if (parents) {
        parents.forEach(function(id2) {
          result.push(this.entity(id2));
        }, this);
      }
      return result;
    },
    parentMultipolygons: function(entity) {
      return this.parentRelations(entity).filter(function(relation) {
        return relation.isMultipolygon();
      });
    },
    childNodes: function(entity) {
      if (this._childNodes[entity.id])
        return this._childNodes[entity.id];
      if (!entity.nodes)
        return [];
      var nodes = [];
      for (var i3 = 0; i3 < entity.nodes.length; i3++) {
        nodes[i3] = this.entity(entity.nodes[i3]);
      }
      if (debug)
        Object.freeze(nodes);
      this._childNodes[entity.id] = nodes;
      return this._childNodes[entity.id];
    },
    base: function() {
      return {
        "entities": Object.getPrototypeOf(this.entities),
        "parentWays": Object.getPrototypeOf(this._parentWays),
        "parentRels": Object.getPrototypeOf(this._parentRels)
      };
    },
    // Unlike other graph methods, rebase mutates in place. This is because it
    // is used only during the history operation that merges newly downloaded
    // data into each state. To external consumers, it should appear as if the
    // graph always contained the newly downloaded data.
    rebase: function(entities, stack, force) {
      var base = this.base();
      var i3, j2, k2, id2;
      for (i3 = 0; i3 < entities.length; i3++) {
        var entity = entities[i3];
        if (!entity.visible || !force && base.entities[entity.id])
          continue;
        base.entities[entity.id] = entity;
        this._updateCalculated(void 0, entity, base.parentWays, base.parentRels);
        if (entity.type === "way") {
          for (j2 = 0; j2 < entity.nodes.length; j2++) {
            id2 = entity.nodes[j2];
            for (k2 = 1; k2 < stack.length; k2++) {
              var ents = stack[k2].entities;
              if (ents.hasOwnProperty(id2) && ents[id2] === void 0) {
                delete ents[id2];
              }
            }
          }
        }
      }
      for (i3 = 0; i3 < stack.length; i3++) {
        stack[i3]._updateRebased();
      }
    },
    _updateRebased: function() {
      var base = this.base();
      Object.keys(this._parentWays).forEach(function(child) {
        if (base.parentWays[child]) {
          base.parentWays[child].forEach(function(id2) {
            if (!this.entities.hasOwnProperty(id2)) {
              this._parentWays[child].add(id2);
            }
          }, this);
        }
      }, this);
      Object.keys(this._parentRels).forEach(function(child) {
        if (base.parentRels[child]) {
          base.parentRels[child].forEach(function(id2) {
            if (!this.entities.hasOwnProperty(id2)) {
              this._parentRels[child].add(id2);
            }
          }, this);
        }
      }, this);
      this.transients = {};
    },
    // Updates calculated properties (parentWays, parentRels) for the specified change
    _updateCalculated: function(oldentity, entity, parentWays, parentRels) {
      parentWays = parentWays || this._parentWays;
      parentRels = parentRels || this._parentRels;
      var type2 = entity && entity.type || oldentity && oldentity.type;
      var removed, added, i3;
      if (type2 === "way") {
        if (oldentity && entity) {
          removed = utilArrayDifference(oldentity.nodes, entity.nodes);
          added = utilArrayDifference(entity.nodes, oldentity.nodes);
        } else if (oldentity) {
          removed = oldentity.nodes;
          added = [];
        } else if (entity) {
          removed = [];
          added = entity.nodes;
        }
        for (i3 = 0; i3 < removed.length; i3++) {
          parentWays[removed[i3]] = new Set(parentWays[removed[i3]]);
          parentWays[removed[i3]].delete(oldentity.id);
        }
        for (i3 = 0; i3 < added.length; i3++) {
          parentWays[added[i3]] = new Set(parentWays[added[i3]]);
          parentWays[added[i3]].add(entity.id);
        }
      } else if (type2 === "relation") {
        var oldentityMemberIDs = oldentity ? oldentity.members.map(function(m2) {
          return m2.id;
        }) : [];
        var entityMemberIDs = entity ? entity.members.map(function(m2) {
          return m2.id;
        }) : [];
        if (oldentity && entity) {
          removed = utilArrayDifference(oldentityMemberIDs, entityMemberIDs);
          added = utilArrayDifference(entityMemberIDs, oldentityMemberIDs);
        } else if (oldentity) {
          removed = oldentityMemberIDs;
          added = [];
        } else if (entity) {
          removed = [];
          added = entityMemberIDs;
        }
        for (i3 = 0; i3 < removed.length; i3++) {
          parentRels[removed[i3]] = new Set(parentRels[removed[i3]]);
          parentRels[removed[i3]].delete(oldentity.id);
        }
        for (i3 = 0; i3 < added.length; i3++) {
          parentRels[added[i3]] = new Set(parentRels[added[i3]]);
          parentRels[added[i3]].add(entity.id);
        }
      }
    },
    replace: function(entity) {
      if (this.entities[entity.id] === entity)
        return this;
      return this.update(function() {
        this._updateCalculated(this.entities[entity.id], entity);
        this.entities[entity.id] = entity;
      });
    },
    remove: function(entity) {
      return this.update(function() {
        this._updateCalculated(entity, void 0);
        this.entities[entity.id] = void 0;
      });
    },
    revert: function(id2) {
      var baseEntity = this.base().entities[id2];
      var headEntity = this.entities[id2];
      if (headEntity === baseEntity)
        return this;
      return this.update(function() {
        this._updateCalculated(headEntity, baseEntity);
        delete this.entities[id2];
      });
    },
    update: function() {
      var graph = this.frozen ? coreGraph(this, true) : this;
      for (var i3 = 0; i3 < arguments.length; i3++) {
        arguments[i3].call(graph, graph);
      }
      if (this.frozen)
        graph.frozen = true;
      return graph;
    },
    // Obliterates any existing entities
    load: function(entities) {
      var base = this.base();
      this.entities = Object.create(base.entities);
      for (var i3 in entities) {
        this.entities[i3] = entities[i3];
        this._updateCalculated(base.entities[i3], this.entities[i3]);
      }
      return this;
    }
  };

  // modules/osm/intersection.js
  function osmTurn(turn) {
    if (!(this instanceof osmTurn)) {
      return new osmTurn(turn);
    }
    Object.assign(this, turn);
  }
  function osmIntersection(graph, startVertexId, maxDistance) {
    maxDistance = maxDistance || 30;
    var vgraph = coreGraph();
    var i3, j2, k2;
    function memberOfRestriction(entity) {
      return graph.parentRelations(entity).some(function(r2) {
        return r2.isRestriction();
      });
    }
    function isRoad(way2) {
      if (way2.isArea() || way2.isDegenerate())
        return false;
      var roads = {
        "motorway": true,
        "motorway_link": true,
        "trunk": true,
        "trunk_link": true,
        "primary": true,
        "primary_link": true,
        "secondary": true,
        "secondary_link": true,
        "tertiary": true,
        "tertiary_link": true,
        "residential": true,
        "unclassified": true,
        "living_street": true,
        "service": true,
        "busway": true,
        "road": true,
        "track": true
      };
      return roads[way2.tags.highway];
    }
    var startNode = graph.entity(startVertexId);
    var checkVertices = [startNode];
    var checkWays;
    var vertices = [];
    var vertexIds = [];
    var vertex;
    var ways = [];
    var wayIds = [];
    var way;
    var nodes = [];
    var node;
    var parents = [];
    var parent;
    var actions = [];
    while (checkVertices.length) {
      vertex = checkVertices.pop();
      checkWays = graph.parentWays(vertex);
      var hasWays = false;
      for (i3 = 0; i3 < checkWays.length; i3++) {
        way = checkWays[i3];
        if (!isRoad(way) && !memberOfRestriction(way))
          continue;
        ways.push(way);
        hasWays = true;
        nodes = utilArrayUniq(graph.childNodes(way));
        for (j2 = 0; j2 < nodes.length; j2++) {
          node = nodes[j2];
          if (node === vertex)
            continue;
          if (vertices.indexOf(node) !== -1)
            continue;
          if (geoSphericalDistance(node.loc, startNode.loc) > maxDistance)
            continue;
          var hasParents = false;
          parents = graph.parentWays(node);
          for (k2 = 0; k2 < parents.length; k2++) {
            parent = parents[k2];
            if (parent === way)
              continue;
            if (ways.indexOf(parent) !== -1)
              continue;
            if (!isRoad(parent))
              continue;
            hasParents = true;
            break;
          }
          if (hasParents) {
            checkVertices.push(node);
          }
        }
      }
      if (hasWays) {
        vertices.push(vertex);
      }
    }
    vertices = utilArrayUniq(vertices);
    ways = utilArrayUniq(ways);
    ways.forEach(function(way2) {
      graph.childNodes(way2).forEach(function(node2) {
        vgraph = vgraph.replace(node2);
      });
      vgraph = vgraph.replace(way2);
      graph.parentRelations(way2).forEach(function(relation) {
        if (relation.isRestriction()) {
          if (relation.isValidRestriction(graph)) {
            vgraph = vgraph.replace(relation);
          } else if (relation.isComplete(graph)) {
            actions.push(actionDeleteRelation(relation.id));
          }
        }
      });
    });
    ways.forEach(function(w2) {
      var way2 = vgraph.entity(w2.id);
      if (way2.tags.oneway === "-1") {
        var action = actionReverse(way2.id, { reverseOneway: true });
        actions.push(action);
        vgraph = action(vgraph);
      }
    });
    var origCount = osmEntity.id.next.way;
    vertices.forEach(function(v2) {
      var splitAll = actionSplit([v2.id]).keepHistoryOn("first");
      if (!splitAll.disabled(vgraph)) {
        splitAll.ways(vgraph).forEach(function(way2) {
          var splitOne = actionSplit([v2.id]).limitWays([way2.id]).keepHistoryOn("first");
          actions.push(splitOne);
          vgraph = splitOne(vgraph);
        });
      }
    });
    osmEntity.id.next.way = origCount;
    vertexIds = vertices.map(function(v2) {
      return v2.id;
    });
    vertices = [];
    ways = [];
    vertexIds.forEach(function(id2) {
      var vertex2 = vgraph.entity(id2);
      var parents2 = vgraph.parentWays(vertex2);
      vertices.push(vertex2);
      ways = ways.concat(parents2);
    });
    vertices = utilArrayUniq(vertices);
    ways = utilArrayUniq(ways);
    vertexIds = vertices.map(function(v2) {
      return v2.id;
    });
    wayIds = ways.map(function(w2) {
      return w2.id;
    });
    function withMetadata(way2, vertexIds2) {
      var __oneWay = way2.isOneWay();
      var __first = vertexIds2.indexOf(way2.first()) !== -1;
      var __last = vertexIds2.indexOf(way2.last()) !== -1;
      var __via = __first && __last;
      var __from = __first && !__oneWay || __last;
      var __to = __first || __last && !__oneWay;
      return way2.update({
        __first,
        __last,
        __from,
        __via,
        __to,
        __oneWay
      });
    }
    ways = [];
    wayIds.forEach(function(id2) {
      var way2 = withMetadata(vgraph.entity(id2), vertexIds);
      vgraph = vgraph.replace(way2);
      ways.push(way2);
    });
    var keepGoing;
    var removeWayIds = [];
    var removeVertexIds = [];
    do {
      keepGoing = false;
      checkVertices = vertexIds.slice();
      for (i3 = 0; i3 < checkVertices.length; i3++) {
        var vertexId = checkVertices[i3];
        vertex = vgraph.hasEntity(vertexId);
        if (!vertex) {
          if (vertexIds.indexOf(vertexId) !== -1) {
            vertexIds.splice(vertexIds.indexOf(vertexId), 1);
          }
          removeVertexIds.push(vertexId);
          continue;
        }
        parents = vgraph.parentWays(vertex);
        if (parents.length < 3) {
          if (vertexIds.indexOf(vertexId) !== -1) {
            vertexIds.splice(vertexIds.indexOf(vertexId), 1);
          }
        }
        if (parents.length === 2) {
          var a2 = parents[0];
          var b2 = parents[1];
          var aIsLeaf = a2 && !a2.__via;
          var bIsLeaf = b2 && !b2.__via;
          var leaf, survivor;
          if (aIsLeaf && !bIsLeaf) {
            leaf = a2;
            survivor = b2;
          } else if (!aIsLeaf && bIsLeaf) {
            leaf = b2;
            survivor = a2;
          }
          if (leaf && survivor) {
            survivor = withMetadata(survivor, vertexIds);
            vgraph = vgraph.replace(survivor).remove(leaf);
            removeWayIds.push(leaf.id);
            keepGoing = true;
          }
        }
        parents = vgraph.parentWays(vertex);
        if (parents.length < 2) {
          if (vertexIds.indexOf(vertexId) !== -1) {
            vertexIds.splice(vertexIds.indexOf(vertexId), 1);
          }
          removeVertexIds.push(vertexId);
          keepGoing = true;
        }
        if (parents.length < 1) {
          vgraph = vgraph.remove(vertex);
        }
      }
    } while (keepGoing);
    vertices = vertices.filter(function(vertex2) {
      return removeVertexIds.indexOf(vertex2.id) === -1;
    }).map(function(vertex2) {
      return vgraph.entity(vertex2.id);
    });
    ways = ways.filter(function(way2) {
      return removeWayIds.indexOf(way2.id) === -1;
    }).map(function(way2) {
      return vgraph.entity(way2.id);
    });
    var intersection2 = {
      graph: vgraph,
      actions,
      vertices,
      ways
    };
    intersection2.turns = function(fromWayId, maxViaWay) {
      if (!fromWayId)
        return [];
      if (!maxViaWay)
        maxViaWay = 0;
      var vgraph2 = intersection2.graph;
      var keyVertexIds = intersection2.vertices.map(function(v2) {
        return v2.id;
      });
      var start2 = vgraph2.entity(fromWayId);
      if (!start2 || !(start2.__from || start2.__via))
        return [];
      var maxPathLength = maxViaWay * 2 + 3;
      var turns = [];
      step(start2);
      return turns;
      function step(entity, currPath, currRestrictions, matchedRestriction) {
        currPath = (currPath || []).slice();
        if (currPath.length >= maxPathLength)
          return;
        currPath.push(entity.id);
        currRestrictions = (currRestrictions || []).slice();
        if (entity.type === "node") {
          stepNode(entity, currPath, currRestrictions);
        } else {
          stepWay(entity, currPath, currRestrictions, matchedRestriction);
        }
      }
      function stepNode(entity, currPath, currRestrictions) {
        var i4, j3;
        var parents2 = vgraph2.parentWays(entity);
        var nextWays = [];
        for (i4 = 0; i4 < parents2.length; i4++) {
          var way2 = parents2[i4];
          if (way2.__oneWay && way2.nodes[0] !== entity.id)
            continue;
          if (currPath.indexOf(way2.id) !== -1 && currPath.length >= 3)
            continue;
          var restrict = null;
          for (j3 = 0; j3 < currRestrictions.length; j3++) {
            var restriction = currRestrictions[j3];
            var f2 = restriction.memberByRole("from");
            var v2 = restriction.membersByRole("via");
            var t2 = restriction.memberByRole("to");
            var isNo = /^no_/.test(restriction.tags.restriction);
            var isOnly = /^only_/.test(restriction.tags.restriction);
            if (!(isNo || isOnly)) {
              continue;
            }
            var matchesFrom = f2.id === fromWayId;
            var matchesViaTo = false;
            var isAlongOnlyPath = false;
            if (t2.id === way2.id) {
              if (v2.length === 1 && v2[0].type === "node") {
                matchesViaTo = v2[0].id === entity.id && (matchesFrom && currPath.length === 2 || !matchesFrom && currPath.length > 2);
              } else {
                var pathVias = [];
                for (k2 = 2; k2 < currPath.length; k2 += 2) {
                  pathVias.push(currPath[k2]);
                }
                var restrictionVias = [];
                for (k2 = 0; k2 < v2.length; k2++) {
                  if (v2[k2].type === "way") {
                    restrictionVias.push(v2[k2].id);
                  }
                }
                var diff = utilArrayDifference(pathVias, restrictionVias);
                matchesViaTo = !diff.length;
              }
            } else if (isOnly) {
              for (k2 = 0; k2 < v2.length; k2++) {
                if (v2[k2].type === "way" && v2[k2].id === way2.id) {
                  isAlongOnlyPath = true;
                  break;
                }
              }
            }
            if (matchesViaTo) {
              if (isOnly) {
                restrict = { id: restriction.id, direct: matchesFrom, from: f2.id, only: true, end: true };
              } else {
                restrict = { id: restriction.id, direct: matchesFrom, from: f2.id, no: true, end: true };
              }
            } else {
              if (isAlongOnlyPath) {
                restrict = { id: restriction.id, direct: false, from: f2.id, only: true, end: false };
              } else if (isOnly) {
                restrict = { id: restriction.id, direct: false, from: f2.id, no: true, end: true };
              }
            }
            if (restrict && restrict.direct)
              break;
          }
          nextWays.push({ way: way2, restrict });
        }
        nextWays.forEach(function(nextWay) {
          step(nextWay.way, currPath, currRestrictions, nextWay.restrict);
        });
      }
      function stepWay(entity, currPath, currRestrictions, matchedRestriction) {
        var i4;
        if (currPath.length >= 3) {
          var turnPath = currPath.slice();
          if (matchedRestriction && matchedRestriction.direct === false) {
            for (i4 = 0; i4 < turnPath.length; i4++) {
              if (turnPath[i4] === matchedRestriction.from) {
                turnPath = turnPath.slice(i4);
                break;
              }
            }
          }
          var turn = pathToTurn(turnPath);
          if (turn) {
            if (matchedRestriction) {
              turn.restrictionID = matchedRestriction.id;
              turn.no = matchedRestriction.no;
              turn.only = matchedRestriction.only;
              turn.direct = matchedRestriction.direct;
            }
            turns.push(osmTurn(turn));
          }
          if (currPath[0] === currPath[2])
            return;
        }
        if (matchedRestriction && matchedRestriction.end)
          return;
        var n1 = vgraph2.entity(entity.first());
        var n22 = vgraph2.entity(entity.last());
        var dist = geoSphericalDistance(n1.loc, n22.loc);
        var nextNodes = [];
        if (currPath.length > 1) {
          if (dist > maxDistance)
            return;
          if (!entity.__via)
            return;
        }
        if (!entity.__oneWay && // bidirectional..
        keyVertexIds.indexOf(n1.id) !== -1 && // key vertex..
        currPath.indexOf(n1.id) === -1) {
          nextNodes.push(n1);
        }
        if (keyVertexIds.indexOf(n22.id) !== -1 && // key vertex..
        currPath.indexOf(n22.id) === -1) {
          nextNodes.push(n22);
        }
        nextNodes.forEach(function(nextNode) {
          var fromRestrictions = vgraph2.parentRelations(entity).filter(function(r2) {
            if (!r2.isRestriction())
              return false;
            var f2 = r2.memberByRole("from");
            if (!f2 || f2.id !== entity.id)
              return false;
            var isOnly = /^only_/.test(r2.tags.restriction);
            if (!isOnly)
              return true;
            var isOnlyVia = false;
            var v2 = r2.membersByRole("via");
            if (v2.length === 1 && v2[0].type === "node") {
              isOnlyVia = v2[0].id === nextNode.id;
            } else {
              for (var i5 = 0; i5 < v2.length; i5++) {
                if (v2[i5].type !== "way")
                  continue;
                var viaWay = vgraph2.entity(v2[i5].id);
                if (viaWay.first() === nextNode.id || viaWay.last() === nextNode.id) {
                  isOnlyVia = true;
                  break;
                }
              }
            }
            return isOnlyVia;
          });
          step(nextNode, currPath, currRestrictions.concat(fromRestrictions), false);
        });
      }
      function pathToTurn(path) {
        if (path.length < 3)
          return;
        var fromWayId2, fromNodeId, fromVertexId;
        var toWayId, toNodeId, toVertexId;
        var viaWayIds, viaNodeId, isUturn;
        fromWayId2 = path[0];
        toWayId = path[path.length - 1];
        if (path.length === 3 && fromWayId2 === toWayId) {
          var way2 = vgraph2.entity(fromWayId2);
          if (way2.__oneWay)
            return null;
          isUturn = true;
          viaNodeId = fromVertexId = toVertexId = path[1];
          fromNodeId = toNodeId = adjacentNode(fromWayId2, viaNodeId);
        } else {
          isUturn = false;
          fromVertexId = path[1];
          fromNodeId = adjacentNode(fromWayId2, fromVertexId);
          toVertexId = path[path.length - 2];
          toNodeId = adjacentNode(toWayId, toVertexId);
          if (path.length === 3) {
            viaNodeId = path[1];
          } else {
            viaWayIds = path.filter(function(entityId) {
              return entityId[0] === "w";
            });
            viaWayIds = viaWayIds.slice(1, viaWayIds.length - 1);
          }
        }
        return {
          key: path.join("_"),
          path,
          from: { node: fromNodeId, way: fromWayId2, vertex: fromVertexId },
          via: { node: viaNodeId, ways: viaWayIds },
          to: { node: toNodeId, way: toWayId, vertex: toVertexId },
          u: isUturn
        };
        function adjacentNode(wayId, affixId) {
          var nodes2 = vgraph2.entity(wayId).nodes;
          return affixId === nodes2[0] ? nodes2[1] : nodes2[nodes2.length - 2];
        }
      }
    };
    return intersection2;
  }
  function osmInferRestriction(graph, turn, projection2) {
    var fromWay = graph.entity(turn.from.way);
    var fromNode = graph.entity(turn.from.node);
    var fromVertex = graph.entity(turn.from.vertex);
    var toWay = graph.entity(turn.to.way);
    var toNode = graph.entity(turn.to.node);
    var toVertex = graph.entity(turn.to.vertex);
    var fromOneWay = fromWay.tags.oneway === "yes";
    var toOneWay = toWay.tags.oneway === "yes";
    var angle2 = (geoAngle(fromVertex, fromNode, projection2) - geoAngle(toVertex, toNode, projection2)) * 180 / Math.PI;
    while (angle2 < 0) {
      angle2 += 360;
    }
    if (fromNode === toNode) {
      return "no_u_turn";
    }
    if ((angle2 < 23 || angle2 > 336) && fromOneWay && toOneWay) {
      return "no_u_turn";
    }
    if ((angle2 < 40 || angle2 > 319) && fromOneWay && toOneWay && turn.from.vertex !== turn.to.vertex) {
      return "no_u_turn";
    }
    if (angle2 < 158) {
      return "no_right_turn";
    }
    if (angle2 > 202) {
      return "no_left_turn";
    }
    return "no_straight_on";
  }

  // modules/actions/merge_polygon.js
  function actionMergePolygon(ids, newRelationId) {
    function groupEntities(graph) {
      var entities = ids.map(function(id2) {
        return graph.entity(id2);
      });
      var geometryGroups = utilArrayGroupBy(entities, function(entity) {
        if (entity.type === "way" && entity.isClosed()) {
          return "closedWay";
        } else if (entity.type === "relation" && entity.isMultipolygon()) {
          return "multipolygon";
        } else {
          return "other";
        }
      });
      return Object.assign(
        { closedWay: [], multipolygon: [], other: [] },
        geometryGroups
      );
    }
    var action = function(graph) {
      var entities = groupEntities(graph);
      var polygons = entities.multipolygon.reduce(function(polygons2, m2) {
        return polygons2.concat(osmJoinWays(m2.members, graph));
      }, []).concat(entities.closedWay.map(function(d2) {
        var member = [{ id: d2.id }];
        member.nodes = graph.childNodes(d2);
        return member;
      }));
      var contained = polygons.map(function(w2, i3) {
        return polygons.map(function(d2, n3) {
          if (i3 === n3)
            return null;
          return geoPolygonContainsPolygon(
            d2.nodes.map(function(n4) {
              return n4.loc;
            }),
            w2.nodes.map(function(n4) {
              return n4.loc;
            })
          );
        });
      });
      var members = [];
      var outer = true;
      while (polygons.length) {
        extractUncontained(polygons);
        polygons = polygons.filter(isContained);
        contained = contained.filter(isContained).map(filterContained);
      }
      function isContained(d2, i3) {
        return contained[i3].some(function(val) {
          return val;
        });
      }
      function filterContained(d2) {
        return d2.filter(isContained);
      }
      function extractUncontained(polygons2) {
        polygons2.forEach(function(d2, i3) {
          if (!isContained(d2, i3)) {
            d2.forEach(function(member) {
              members.push({
                type: "way",
                id: member.id,
                role: outer ? "outer" : "inner"
              });
            });
          }
        });
        outer = !outer;
      }
      var relation;
      if (entities.multipolygon.length > 0) {
        var oldestID = utilOldestID(entities.multipolygon.map((entity) => entity.id));
        relation = entities.multipolygon.find((entity) => entity.id === oldestID);
      } else {
        relation = osmRelation({ id: newRelationId, tags: { type: "multipolygon" } });
      }
      entities.multipolygon.forEach(function(m2) {
        if (m2.id !== relation.id) {
          relation = relation.mergeTags(m2.tags);
          graph = graph.remove(m2);
        }
      });
      entities.closedWay.forEach(function(way) {
        function isThisOuter(m2) {
          return m2.id === way.id && m2.role !== "inner";
        }
        if (members.some(isThisOuter)) {
          relation = relation.mergeTags(way.tags);
          graph = graph.replace(way.update({ tags: {} }));
        }
      });
      return graph.replace(relation.update({
        members,
        tags: utilObjectOmit(relation.tags, ["area"])
      }));
    };
    action.disabled = function(graph) {
      var entities = groupEntities(graph);
      if (entities.other.length > 0 || entities.closedWay.length + entities.multipolygon.length < 2) {
        return "not_eligible";
      }
      if (!entities.multipolygon.every(function(r2) {
        return r2.isComplete(graph);
      })) {
        return "incomplete_relation";
      }
      if (!entities.multipolygon.length) {
        var sharedMultipolygons = [];
        entities.closedWay.forEach(function(way, i3) {
          if (i3 === 0) {
            sharedMultipolygons = graph.parentMultipolygons(way);
          } else {
            sharedMultipolygons = utilArrayIntersection(sharedMultipolygons, graph.parentMultipolygons(way));
          }
        });
        sharedMultipolygons = sharedMultipolygons.filter(function(relation) {
          return relation.members.length === entities.closedWay.length;
        });
        if (sharedMultipolygons.length) {
          return "not_eligible";
        }
      } else if (entities.closedWay.some(function(way) {
        return utilArrayIntersection(graph.parentMultipolygons(way), entities.multipolygon).length;
      })) {
        return "not_eligible";
      }
    };
    return action;
  }

  // modules/actions/merge_remote_changes.js
  var import_fast_deep_equal = __toESM(require_fast_deep_equal());

  // node_modules/node-diff3/index.mjs
  function LCS(buffer1, buffer2) {
    let equivalenceClasses = {};
    for (let j2 = 0; j2 < buffer2.length; j2++) {
      const item = buffer2[j2];
      if (equivalenceClasses[item]) {
        equivalenceClasses[item].push(j2);
      } else {
        equivalenceClasses[item] = [j2];
      }
    }
    const NULLRESULT = { buffer1index: -1, buffer2index: -1, chain: null };
    let candidates = [NULLRESULT];
    for (let i3 = 0; i3 < buffer1.length; i3++) {
      const item = buffer1[i3];
      const buffer2indices = equivalenceClasses[item] || [];
      let r2 = 0;
      let c2 = candidates[0];
      for (let jx = 0; jx < buffer2indices.length; jx++) {
        const j2 = buffer2indices[jx];
        let s2;
        for (s2 = r2; s2 < candidates.length; s2++) {
          if (candidates[s2].buffer2index < j2 && (s2 === candidates.length - 1 || candidates[s2 + 1].buffer2index > j2)) {
            break;
          }
        }
        if (s2 < candidates.length) {
          const newCandidate = { buffer1index: i3, buffer2index: j2, chain: candidates[s2] };
          if (r2 === candidates.length) {
            candidates.push(c2);
          } else {
            candidates[r2] = c2;
          }
          r2 = s2 + 1;
          c2 = newCandidate;
          if (r2 === candidates.length) {
            break;
          }
        }
      }
      candidates[r2] = c2;
    }
    return candidates[candidates.length - 1];
  }
  function diffIndices(buffer1, buffer2) {
    const lcs = LCS(buffer1, buffer2);
    let result = [];
    let tail1 = buffer1.length;
    let tail2 = buffer2.length;
    for (let candidate = lcs; candidate !== null; candidate = candidate.chain) {
      const mismatchLength1 = tail1 - candidate.buffer1index - 1;
      const mismatchLength2 = tail2 - candidate.buffer2index - 1;
      tail1 = candidate.buffer1index;
      tail2 = candidate.buffer2index;
      if (mismatchLength1 || mismatchLength2) {
        result.push({
          buffer1: [tail1 + 1, mismatchLength1],
          buffer1Content: buffer1.slice(tail1 + 1, tail1 + 1 + mismatchLength1),
          buffer2: [tail2 + 1, mismatchLength2],
          buffer2Content: buffer2.slice(tail2 + 1, tail2 + 1 + mismatchLength2)
        });
      }
    }
    result.reverse();
    return result;
  }
  function diff3MergeRegions(a2, o2, b2) {
    let hunks = [];
    function addHunk(h2, ab) {
      hunks.push({
        ab,
        oStart: h2.buffer1[0],
        oLength: h2.buffer1[1],
        // length of o to remove
        abStart: h2.buffer2[0],
        abLength: h2.buffer2[1]
        // length of a/b to insert
        // abContent: (ab === 'a' ? a : b).slice(h.buffer2[0], h.buffer2[0] + h.buffer2[1])
      });
    }
    diffIndices(o2, a2).forEach((item) => addHunk(item, "a"));
    diffIndices(o2, b2).forEach((item) => addHunk(item, "b"));
    hunks.sort((x2, y2) => x2.oStart - y2.oStart);
    let results = [];
    let currOffset = 0;
    function advanceTo(endOffset) {
      if (endOffset > currOffset) {
        results.push({
          stable: true,
          buffer: "o",
          bufferStart: currOffset,
          bufferLength: endOffset - currOffset,
          bufferContent: o2.slice(currOffset, endOffset)
        });
        currOffset = endOffset;
      }
    }
    while (hunks.length) {
      let hunk = hunks.shift();
      let regionStart = hunk.oStart;
      let regionEnd = hunk.oStart + hunk.oLength;
      let regionHunks = [hunk];
      advanceTo(regionStart);
      while (hunks.length) {
        const nextHunk = hunks[0];
        const nextHunkStart = nextHunk.oStart;
        if (nextHunkStart > regionEnd)
          break;
        regionEnd = Math.max(regionEnd, nextHunkStart + nextHunk.oLength);
        regionHunks.push(hunks.shift());
      }
      if (regionHunks.length === 1) {
        if (hunk.abLength > 0) {
          const buffer = hunk.ab === "a" ? a2 : b2;
          results.push({
            stable: true,
            buffer: hunk.ab,
            bufferStart: hunk.abStart,
            bufferLength: hunk.abLength,
            bufferContent: buffer.slice(hunk.abStart, hunk.abStart + hunk.abLength)
          });
        }
      } else {
        let bounds = {
          a: [a2.length, -1, o2.length, -1],
          b: [b2.length, -1, o2.length, -1]
        };
        while (regionHunks.length) {
          hunk = regionHunks.shift();
          const oStart = hunk.oStart;
          const oEnd = oStart + hunk.oLength;
          const abStart = hunk.abStart;
          const abEnd = abStart + hunk.abLength;
          let b3 = bounds[hunk.ab];
          b3[0] = Math.min(abStart, b3[0]);
          b3[1] = Math.max(abEnd, b3[1]);
          b3[2] = Math.min(oStart, b3[2]);
          b3[3] = Math.max(oEnd, b3[3]);
        }
        const aStart = bounds.a[0] + (regionStart - bounds.a[2]);
        const aEnd = bounds.a[1] + (regionEnd - bounds.a[3]);
        const bStart = bounds.b[0] + (regionStart - bounds.b[2]);
        const bEnd = bounds.b[1] + (regionEnd - bounds.b[3]);
        let result = {
          stable: false,
          aStart,
          aLength: aEnd - aStart,
          aContent: a2.slice(aStart, aEnd),
          oStart: regionStart,
          oLength: regionEnd - regionStart,
          oContent: o2.slice(regionStart, regionEnd),
          bStart,
          bLength: bEnd - bStart,
          bContent: b2.slice(bStart, bEnd)
        };
        results.push(result);
      }
      currOffset = regionEnd;
    }
    advanceTo(o2.length);
    return results;
  }
  function diff3Merge(a2, o2, b2, options2) {
    let defaults = {
      excludeFalseConflicts: true,
      stringSeparator: /\s+/
    };
    options2 = Object.assign(defaults, options2);
    if (typeof a2 === "string")
      a2 = a2.split(options2.stringSeparator);
    if (typeof o2 === "string")
      o2 = o2.split(options2.stringSeparator);
    if (typeof b2 === "string")
      b2 = b2.split(options2.stringSeparator);
    let results = [];
    const regions = diff3MergeRegions(a2, o2, b2);
    let okBuffer = [];
    function flushOk() {
      if (okBuffer.length) {
        results.push({ ok: okBuffer });
      }
      okBuffer = [];
    }
    function isFalseConflict(a3, b3) {
      if (a3.length !== b3.length)
        return false;
      for (let i3 = 0; i3 < a3.length; i3++) {
        if (a3[i3] !== b3[i3])
          return false;
      }
      return true;
    }
    regions.forEach((region) => {
      if (region.stable) {
        okBuffer.push(...region.bufferContent);
      } else {
        if (options2.excludeFalseConflicts && isFalseConflict(region.aContent, region.bContent)) {
          okBuffer.push(...region.aContent);
        } else {
          flushOk();
          results.push({
            conflict: {
              a: region.aContent,
              aIndex: region.aStart,
              o: region.oContent,
              oIndex: region.oStart,
              b: region.bContent,
              bIndex: region.bStart
            }
          });
        }
      }
    });
    flushOk();
    return results;
  }

  // modules/actions/merge_remote_changes.js
  var import_lodash2 = __toESM(require_lodash());
  function actionMergeRemoteChanges(id2, localGraph, remoteGraph, discardTags, formatUser) {
    discardTags = discardTags || {};
    var _option = "safe";
    var _conflicts = [];
    function user(d2) {
      return typeof formatUser === "function" ? formatUser(d2) : (0, import_lodash2.escape)(d2);
    }
    function mergeLocation(remote, target) {
      function pointEqual(a2, b2) {
        var epsilon3 = 1e-6;
        return Math.abs(a2[0] - b2[0]) < epsilon3 && Math.abs(a2[1] - b2[1]) < epsilon3;
      }
      if (_option === "force_local" || pointEqual(target.loc, remote.loc)) {
        return target;
      }
      if (_option === "force_remote") {
        return target.update({ loc: remote.loc });
      }
      _conflicts.push(_t.html("merge_remote_changes.conflict.location", { user: { html: user(remote.user) } }));
      return target;
    }
    function mergeNodes(base, remote, target) {
      if (_option === "force_local" || (0, import_fast_deep_equal.default)(target.nodes, remote.nodes)) {
        return target;
      }
      if (_option === "force_remote") {
        return target.update({ nodes: remote.nodes });
      }
      var ccount = _conflicts.length;
      var o2 = base.nodes || [];
      var a2 = target.nodes || [];
      var b2 = remote.nodes || [];
      var nodes = [];
      var hunks = diff3Merge(a2, o2, b2, { excludeFalseConflicts: true });
      for (var i3 = 0; i3 < hunks.length; i3++) {
        var hunk = hunks[i3];
        if (hunk.ok) {
          nodes.push.apply(nodes, hunk.ok);
        } else {
          var c2 = hunk.conflict;
          if ((0, import_fast_deep_equal.default)(c2.o, c2.a)) {
            nodes.push.apply(nodes, c2.b);
          } else if ((0, import_fast_deep_equal.default)(c2.o, c2.b)) {
            nodes.push.apply(nodes, c2.a);
          } else {
            _conflicts.push(_t.html("merge_remote_changes.conflict.nodelist", { user: { html: user(remote.user) } }));
            break;
          }
        }
      }
      return _conflicts.length === ccount ? target.update({ nodes }) : target;
    }
    function mergeChildren(targetWay, children2, updates, graph) {
      function isUsed(node2, targetWay2) {
        var hasInterestingParent = graph.parentWays(node2).some(function(way) {
          return way.id !== targetWay2.id;
        });
        return node2.hasInterestingTags() || hasInterestingParent || graph.parentRelations(node2).length > 0;
      }
      var ccount = _conflicts.length;
      for (var i3 = 0; i3 < children2.length; i3++) {
        var id3 = children2[i3];
        var node = graph.hasEntity(id3);
        if (targetWay.nodes.indexOf(id3) === -1) {
          if (node && !isUsed(node, targetWay)) {
            updates.removeIds.push(id3);
          }
          continue;
        }
        var local = localGraph.hasEntity(id3);
        var remote = remoteGraph.hasEntity(id3);
        var target;
        if (_option === "force_remote" && remote && remote.visible) {
          updates.replacements.push(remote);
        } else if (_option === "force_local" && local) {
          target = osmEntity(local);
          if (remote) {
            target = target.update({ version: remote.version });
          }
          updates.replacements.push(target);
        } else if (_option === "safe" && local && remote && local.version !== remote.version) {
          target = osmEntity(local, { version: remote.version });
          if (remote.visible) {
            target = mergeLocation(remote, target);
          } else {
            _conflicts.push(_t.html("merge_remote_changes.conflict.deleted", { user: { html: user(remote.user) } }));
          }
          if (_conflicts.length !== ccount)
            break;
          updates.replacements.push(target);
        }
      }
      return targetWay;
    }
    function updateChildren(updates, graph) {
      for (var i3 = 0; i3 < updates.replacements.length; i3++) {
        graph = graph.replace(updates.replacements[i3]);
      }
      if (updates.removeIds.length) {
        graph = actionDeleteMultiple(updates.removeIds)(graph);
      }
      return graph;
    }
    function mergeMembers(remote, target) {
      if (_option === "force_local" || (0, import_fast_deep_equal.default)(target.members, remote.members)) {
        return target;
      }
      if (_option === "force_remote") {
        return target.update({ members: remote.members });
      }
      _conflicts.push(_t.html("merge_remote_changes.conflict.memberlist", { user: { html: user(remote.user) } }));
      return target;
    }
    function mergeTags(base, remote, target) {
      if (_option === "force_local" || (0, import_fast_deep_equal.default)(target.tags, remote.tags)) {
        return target;
      }
      if (_option === "force_remote") {
        return target.update({ tags: remote.tags });
      }
      var ccount = _conflicts.length;
      var o2 = base.tags || {};
      var a2 = target.tags || {};
      var b2 = remote.tags || {};
      var keys2 = utilArrayUnion(utilArrayUnion(Object.keys(o2), Object.keys(a2)), Object.keys(b2)).filter(function(k3) {
        return !discardTags[k3];
      });
      var tags = Object.assign({}, a2);
      var changed = false;
      for (var i3 = 0; i3 < keys2.length; i3++) {
        var k2 = keys2[i3];
        if (o2[k2] !== b2[k2] && a2[k2] !== b2[k2]) {
          if (o2[k2] !== a2[k2]) {
            _conflicts.push(_t.html(
              "merge_remote_changes.conflict.tags",
              { tag: k2, local: a2[k2], remote: b2[k2], user: { html: user(remote.user) } }
            ));
          } else {
            if (b2.hasOwnProperty(k2)) {
              tags[k2] = b2[k2];
            } else {
              delete tags[k2];
            }
            changed = true;
          }
        }
      }
      return changed && _conflicts.length === ccount ? target.update({ tags }) : target;
    }
    var action = function(graph) {
      var updates = { replacements: [], removeIds: [] };
      var base = graph.base().entities[id2];
      var local = localGraph.entity(id2);
      var remote = remoteGraph.entity(id2);
      var target = osmEntity(local, { version: remote.version });
      if (!remote.visible) {
        if (_option === "force_remote") {
          return actionDeleteMultiple([id2])(graph);
        } else if (_option === "force_local") {
          if (target.type === "way") {
            target = mergeChildren(target, utilArrayUniq(local.nodes), updates, graph);
            graph = updateChildren(updates, graph);
          }
          return graph.replace(target);
        } else {
          _conflicts.push(_t.html("merge_remote_changes.conflict.deleted", { user: { html: user(remote.user) } }));
          return graph;
        }
      }
      if (target.type === "node") {
        target = mergeLocation(remote, target);
      } else if (target.type === "way") {
        graph.rebase(remoteGraph.childNodes(remote), [graph], false);
        target = mergeNodes(base, remote, target);
        target = mergeChildren(target, utilArrayUnion(local.nodes, remote.nodes), updates, graph);
      } else if (target.type === "relation") {
        target = mergeMembers(remote, target);
      }
      target = mergeTags(base, remote, target);
      if (!_conflicts.length) {
        graph = updateChildren(updates, graph).replace(target);
      }
      return graph;
    };
    action.withOption = function(opt) {
      _option = opt;
      return action;
    };
    action.conflicts = function() {
      return _conflicts;
    };
    return action;
  }

  // modules/actions/move.js
  function actionMove(moveIDs, tryDelta, projection2, cache) {
    var _delta = tryDelta;
    function setupCache(graph) {
      function canMove(nodeID) {
        if (moveIDs.indexOf(nodeID) !== -1)
          return true;
        var parents = graph.parentWays(graph.entity(nodeID));
        if (parents.length < 3)
          return true;
        var parentsMoving = parents.every(function(way) {
          return cache.moving[way.id];
        });
        if (!parentsMoving)
          delete cache.moving[nodeID];
        return parentsMoving;
      }
      function cacheEntities(ids) {
        for (var i3 = 0; i3 < ids.length; i3++) {
          var id2 = ids[i3];
          if (cache.moving[id2])
            continue;
          cache.moving[id2] = true;
          var entity = graph.hasEntity(id2);
          if (!entity)
            continue;
          if (entity.type === "node") {
            cache.nodes.push(id2);
            cache.startLoc[id2] = entity.loc;
          } else if (entity.type === "way") {
            cache.ways.push(id2);
            cacheEntities(entity.nodes);
          } else {
            cacheEntities(entity.members.map(function(member) {
              return member.id;
            }));
          }
        }
      }
      function cacheIntersections(ids) {
        function isEndpoint(way2, id3) {
          return !way2.isClosed() && !!way2.affix(id3);
        }
        for (var i3 = 0; i3 < ids.length; i3++) {
          var id2 = ids[i3];
          var childNodes = graph.childNodes(graph.entity(id2));
          for (var j2 = 0; j2 < childNodes.length; j2++) {
            var node = childNodes[j2];
            var parents = graph.parentWays(node);
            if (parents.length !== 2)
              continue;
            var moved = graph.entity(id2);
            var unmoved = null;
            for (var k2 = 0; k2 < parents.length; k2++) {
              var way = parents[k2];
              if (!cache.moving[way.id]) {
                unmoved = way;
                break;
              }
            }
            if (!unmoved)
              continue;
            if (utilArrayIntersection(moved.nodes, unmoved.nodes).length > 2)
              continue;
            if (moved.isArea() || unmoved.isArea())
              continue;
            cache.intersections.push({
              nodeId: node.id,
              movedId: moved.id,
              unmovedId: unmoved.id,
              movedIsEP: isEndpoint(moved, node.id),
              unmovedIsEP: isEndpoint(unmoved, node.id)
            });
          }
        }
      }
      if (!cache) {
        cache = {};
      }
      if (!cache.ok) {
        cache.moving = {};
        cache.intersections = [];
        cache.replacedVertex = {};
        cache.startLoc = {};
        cache.nodes = [];
        cache.ways = [];
        cacheEntities(moveIDs);
        cacheIntersections(cache.ways);
        cache.nodes = cache.nodes.filter(canMove);
        cache.ok = true;
      }
    }
    function replaceMovedVertex(nodeId, wayId, graph, delta) {
      var way = graph.entity(wayId);
      var moved = graph.entity(nodeId);
      var movedIndex = way.nodes.indexOf(nodeId);
      var len, prevIndex, nextIndex;
      if (way.isClosed()) {
        len = way.nodes.length - 1;
        prevIndex = (movedIndex + len - 1) % len;
        nextIndex = (movedIndex + len + 1) % len;
      } else {
        len = way.nodes.length;
        prevIndex = movedIndex - 1;
        nextIndex = movedIndex + 1;
      }
      var prev = graph.hasEntity(way.nodes[prevIndex]);
      var next = graph.hasEntity(way.nodes[nextIndex]);
      if (!prev || !next)
        return graph;
      var key = wayId + "_" + nodeId;
      var orig = cache.replacedVertex[key];
      if (!orig) {
        orig = osmNode();
        cache.replacedVertex[key] = orig;
        cache.startLoc[orig.id] = cache.startLoc[nodeId];
      }
      var start2, end;
      if (delta) {
        start2 = projection2(cache.startLoc[nodeId]);
        end = projection2.invert(geoVecAdd(start2, delta));
      } else {
        end = cache.startLoc[nodeId];
      }
      orig = orig.move(end);
      var angle2 = Math.abs(geoAngle(orig, prev, projection2) - geoAngle(orig, next, projection2)) * 180 / Math.PI;
      if (angle2 > 175 && angle2 < 185)
        return graph;
      var p1 = [prev.loc, orig.loc, moved.loc, next.loc].map(projection2);
      var p2 = [prev.loc, moved.loc, orig.loc, next.loc].map(projection2);
      var d1 = geoPathLength(p1);
      var d2 = geoPathLength(p2);
      var insertAt = d1 <= d2 ? movedIndex : nextIndex;
      if (way.isClosed() && insertAt === 0)
        insertAt = len;
      way = way.addNode(orig.id, insertAt);
      return graph.replace(orig).replace(way);
    }
    function removeDuplicateVertices(wayId, graph) {
      var way = graph.entity(wayId);
      var epsilon3 = 1e-6;
      var prev, curr;
      function isInteresting(node, graph2) {
        return graph2.parentWays(node).length > 1 || graph2.parentRelations(node).length || node.hasInterestingTags();
      }
      for (var i3 = 0; i3 < way.nodes.length; i3++) {
        curr = graph.entity(way.nodes[i3]);
        if (prev && curr && geoVecEqual(prev.loc, curr.loc, epsilon3)) {
          if (!isInteresting(prev, graph)) {
            way = way.removeNode(prev.id);
            graph = graph.replace(way).remove(prev);
          } else if (!isInteresting(curr, graph)) {
            way = way.removeNode(curr.id);
            graph = graph.replace(way).remove(curr);
          }
        }
        prev = curr;
      }
      return graph;
    }
    function unZorroIntersection(intersection2, graph) {
      var vertex = graph.entity(intersection2.nodeId);
      var way1 = graph.entity(intersection2.movedId);
      var way2 = graph.entity(intersection2.unmovedId);
      var isEP1 = intersection2.movedIsEP;
      var isEP2 = intersection2.unmovedIsEP;
      if (isEP1 && isEP2)
        return graph;
      var nodes1 = graph.childNodes(way1).filter(function(n3) {
        return n3 !== vertex;
      });
      var nodes2 = graph.childNodes(way2).filter(function(n3) {
        return n3 !== vertex;
      });
      if (way1.isClosed() && way1.first() === vertex.id)
        nodes1.push(nodes1[0]);
      if (way2.isClosed() && way2.first() === vertex.id)
        nodes2.push(nodes2[0]);
      var edge1 = !isEP1 && geoChooseEdge(nodes1, projection2(vertex.loc), projection2);
      var edge2 = !isEP2 && geoChooseEdge(nodes2, projection2(vertex.loc), projection2);
      var loc;
      if (!isEP1 && !isEP2) {
        var epsilon3 = 1e-6, maxIter = 10;
        for (var i3 = 0; i3 < maxIter; i3++) {
          loc = geoVecInterp(edge1.loc, edge2.loc, 0.5);
          edge1 = geoChooseEdge(nodes1, projection2(loc), projection2);
          edge2 = geoChooseEdge(nodes2, projection2(loc), projection2);
          if (Math.abs(edge1.distance - edge2.distance) < epsilon3)
            break;
        }
      } else if (!isEP1) {
        loc = edge1.loc;
      } else {
        loc = edge2.loc;
      }
      graph = graph.replace(vertex.move(loc));
      if (!isEP1 && edge1.index !== way1.nodes.indexOf(vertex.id)) {
        way1 = way1.removeNode(vertex.id).addNode(vertex.id, edge1.index);
        graph = graph.replace(way1);
      }
      if (!isEP2 && edge2.index !== way2.nodes.indexOf(vertex.id)) {
        way2 = way2.removeNode(vertex.id).addNode(vertex.id, edge2.index);
        graph = graph.replace(way2);
      }
      return graph;
    }
    function cleanupIntersections(graph) {
      for (var i3 = 0; i3 < cache.intersections.length; i3++) {
        var obj = cache.intersections[i3];
        graph = replaceMovedVertex(obj.nodeId, obj.movedId, graph, _delta);
        graph = replaceMovedVertex(obj.nodeId, obj.unmovedId, graph, null);
        graph = unZorroIntersection(obj, graph);
        graph = removeDuplicateVertices(obj.movedId, graph);
        graph = removeDuplicateVertices(obj.unmovedId, graph);
      }
      return graph;
    }
    function limitDelta(graph) {
      function moveNode(loc) {
        return geoVecAdd(projection2(loc), _delta);
      }
      for (var i3 = 0; i3 < cache.intersections.length; i3++) {
        var obj = cache.intersections[i3];
        if (obj.movedIsEP && obj.unmovedIsEP)
          continue;
        if (!obj.movedIsEP)
          continue;
        var node = graph.entity(obj.nodeId);
        var start2 = projection2(node.loc);
        var end = geoVecAdd(start2, _delta);
        var movedNodes = graph.childNodes(graph.entity(obj.movedId));
        var movedPath = movedNodes.map(function(n3) {
          return moveNode(n3.loc);
        });
        var unmovedNodes = graph.childNodes(graph.entity(obj.unmovedId));
        var unmovedPath = unmovedNodes.map(function(n3) {
          return projection2(n3.loc);
        });
        var hits = geoPathIntersections(movedPath, unmovedPath);
        for (var j2 = 0; i3 < hits.length; i3++) {
          if (geoVecEqual(hits[j2], end))
            continue;
          var edge = geoChooseEdge(unmovedNodes, end, projection2);
          _delta = geoVecSubtract(projection2(edge.loc), start2);
        }
      }
    }
    var action = function(graph) {
      if (_delta[0] === 0 && _delta[1] === 0)
        return graph;
      setupCache(graph);
      if (cache.intersections.length) {
        limitDelta(graph);
      }
      for (var i3 = 0; i3 < cache.nodes.length; i3++) {
        var node = graph.entity(cache.nodes[i3]);
        var start2 = projection2(node.loc);
        var end = geoVecAdd(start2, _delta);
        graph = graph.replace(node.move(projection2.invert(end)));
      }
      if (cache.intersections.length) {
        graph = cleanupIntersections(graph);
      }
      return graph;
    };
    action.delta = function() {
      return _delta;
    };
    return action;
  }

  // modules/actions/move_member.js
  function actionMoveMember(relationId, fromIndex, toIndex) {
    return function(graph) {
      return graph.replace(graph.entity(relationId).moveMember(fromIndex, toIndex));
    };
  }

  // modules/actions/move_node.js
  function actionMoveNode(nodeID, toLoc) {
    var action = function(graph, t2) {
      if (t2 === null || !isFinite(t2))
        t2 = 1;
      t2 = Math.min(Math.max(+t2, 0), 1);
      var node = graph.entity(nodeID);
      return graph.replace(
        node.move(geoVecInterp(node.loc, toLoc, t2))
      );
    };
    action.transitionable = true;
    return action;
  }

  // modules/actions/noop.js
  function actionNoop() {
    return function(graph) {
      return graph;
    };
  }

  // modules/actions/orthogonalize.js
  function actionOrthogonalize(wayID, projection2, vertexID, degThresh, ep) {
    var epsilon3 = ep || 1e-4;
    var threshold = degThresh || 13;
    var lowerThreshold = Math.cos((90 - threshold) * Math.PI / 180);
    var upperThreshold = Math.cos(threshold * Math.PI / 180);
    var action = function(graph, t2) {
      if (t2 === null || !isFinite(t2))
        t2 = 1;
      t2 = Math.min(Math.max(+t2, 0), 1);
      var way = graph.entity(wayID);
      way = way.removeNode("");
      if (way.tags.nonsquare) {
        var tags = Object.assign({}, way.tags);
        delete tags.nonsquare;
        way = way.update({ tags });
      }
      graph = graph.replace(way);
      var isClosed = way.isClosed();
      var nodes = graph.childNodes(way).slice();
      if (isClosed)
        nodes.pop();
      if (vertexID !== void 0) {
        nodes = nodeSubset(nodes, vertexID, isClosed);
        if (nodes.length !== 3)
          return graph;
      }
      var nodeCount = {};
      var points = [];
      var corner = { i: 0, dotp: 1 };
      var node, point2, loc, score, motions, i3, j2;
      for (i3 = 0; i3 < nodes.length; i3++) {
        node = nodes[i3];
        nodeCount[node.id] = (nodeCount[node.id] || 0) + 1;
        points.push({ id: node.id, coord: projection2(node.loc) });
      }
      if (points.length === 3) {
        for (i3 = 0; i3 < 1e3; i3++) {
          motions = points.map(calcMotion);
          points[corner.i].coord = geoVecAdd(points[corner.i].coord, motions[corner.i]);
          score = corner.dotp;
          if (score < epsilon3) {
            break;
          }
        }
        node = graph.entity(nodes[corner.i].id);
        loc = projection2.invert(points[corner.i].coord);
        graph = graph.replace(node.move(geoVecInterp(node.loc, loc, t2)));
      } else {
        var straights = [];
        var simplified = [];
        for (i3 = 0; i3 < points.length; i3++) {
          point2 = points[i3];
          var dotp = 0;
          if (isClosed || i3 > 0 && i3 < points.length - 1) {
            var a2 = points[(i3 - 1 + points.length) % points.length];
            var b2 = points[(i3 + 1) % points.length];
            dotp = Math.abs(geoOrthoNormalizedDotProduct(a2.coord, b2.coord, point2.coord));
          }
          if (dotp > upperThreshold) {
            straights.push(point2);
          } else {
            simplified.push(point2);
          }
        }
        var bestPoints = clonePoints(simplified);
        var originalPoints = clonePoints(simplified);
        score = Infinity;
        for (i3 = 0; i3 < 1e3; i3++) {
          motions = simplified.map(calcMotion);
          for (j2 = 0; j2 < motions.length; j2++) {
            simplified[j2].coord = geoVecAdd(simplified[j2].coord, motions[j2]);
          }
          var newScore = geoOrthoCalcScore(simplified, isClosed, epsilon3, threshold);
          if (newScore < score) {
            bestPoints = clonePoints(simplified);
            score = newScore;
          }
          if (score < epsilon3) {
            break;
          }
        }
        var bestCoords = bestPoints.map(function(p2) {
          return p2.coord;
        });
        if (isClosed)
          bestCoords.push(bestCoords[0]);
        for (i3 = 0; i3 < bestPoints.length; i3++) {
          point2 = bestPoints[i3];
          if (!geoVecEqual(originalPoints[i3].coord, point2.coord)) {
            node = graph.entity(point2.id);
            loc = projection2.invert(point2.coord);
            graph = graph.replace(node.move(geoVecInterp(node.loc, loc, t2)));
          }
        }
        for (i3 = 0; i3 < straights.length; i3++) {
          point2 = straights[i3];
          if (nodeCount[point2.id] > 1)
            continue;
          node = graph.entity(point2.id);
          if (t2 === 1 && graph.parentWays(node).length === 1 && graph.parentRelations(node).length === 0 && !node.hasInterestingTags()) {
            graph = actionDeleteNode(node.id)(graph);
          } else {
            var choice = geoVecProject(point2.coord, bestCoords);
            if (choice) {
              loc = projection2.invert(choice.target);
              graph = graph.replace(node.move(geoVecInterp(node.loc, loc, t2)));
            }
          }
        }
      }
      return graph;
      function clonePoints(array2) {
        return array2.map(function(p2) {
          return { id: p2.id, coord: [p2.coord[0], p2.coord[1]] };
        });
      }
      function calcMotion(point3, i4, array2) {
        if (!isClosed && (i4 === 0 || i4 === array2.length - 1))
          return [0, 0];
        if (nodeCount[array2[i4].id] > 1)
          return [0, 0];
        var a3 = array2[(i4 - 1 + array2.length) % array2.length].coord;
        var origin = point3.coord;
        var b3 = array2[(i4 + 1) % array2.length].coord;
        var p2 = geoVecSubtract(a3, origin);
        var q2 = geoVecSubtract(b3, origin);
        var scale = 2 * Math.min(geoVecLength(p2), geoVecLength(q2));
        p2 = geoVecNormalize(p2);
        q2 = geoVecNormalize(q2);
        var dotp2 = p2[0] * q2[0] + p2[1] * q2[1];
        var val = Math.abs(dotp2);
        if (val < lowerThreshold) {
          corner.i = i4;
          corner.dotp = val;
          var vec = geoVecNormalize(geoVecAdd(p2, q2));
          return geoVecScale(vec, 0.1 * dotp2 * scale);
        }
        return [0, 0];
      }
    };
    function nodeSubset(nodes, vertexID2, isClosed) {
      var first = isClosed ? 0 : 1;
      var last = isClosed ? nodes.length : nodes.length - 1;
      for (var i3 = first; i3 < last; i3++) {
        if (nodes[i3].id === vertexID2) {
          return [
            nodes[(i3 - 1 + nodes.length) % nodes.length],
            nodes[i3],
            nodes[(i3 + 1) % nodes.length]
          ];
        }
      }
      return [];
    }
    action.disabled = function(graph) {
      var way = graph.entity(wayID);
      way = way.removeNode("");
      graph = graph.replace(way);
      var isClosed = way.isClosed();
      var nodes = graph.childNodes(way).slice();
      if (isClosed)
        nodes.pop();
      var allowStraightAngles = false;
      if (vertexID !== void 0) {
        allowStraightAngles = true;
        nodes = nodeSubset(nodes, vertexID, isClosed);
        if (nodes.length !== 3)
          return "end_vertex";
      }
      var coords = nodes.map(function(n3) {
        return projection2(n3.loc);
      });
      var score = geoOrthoCanOrthogonalize(coords, isClosed, epsilon3, threshold, allowStraightAngles);
      if (score === null) {
        return "not_squarish";
      } else if (score === 0) {
        return "square_enough";
      } else {
        return false;
      }
    };
    action.transitionable = true;
    return action;
  }

  // modules/actions/restrict_turn.js
  function actionRestrictTurn(turn, restrictionType, restrictionID) {
    return function(graph) {
      var fromWay = graph.entity(turn.from.way);
      var toWay = graph.entity(turn.to.way);
      var viaNode = turn.via.node && graph.entity(turn.via.node);
      var viaWays = turn.via.ways && turn.via.ways.map(function(id2) {
        return graph.entity(id2);
      });
      var members = [];
      members.push({ id: fromWay.id, type: "way", role: "from" });
      if (viaNode) {
        members.push({ id: viaNode.id, type: "node", role: "via" });
      } else if (viaWays) {
        viaWays.forEach(function(viaWay) {
          members.push({ id: viaWay.id, type: "way", role: "via" });
        });
      }
      members.push({ id: toWay.id, type: "way", role: "to" });
      return graph.replace(osmRelation({
        id: restrictionID,
        tags: {
          type: "restriction",
          restriction: restrictionType
        },
        members
      }));
    };
  }

  // modules/actions/revert.js
  function actionRevert(id2) {
    var action = function(graph) {
      var entity = graph.hasEntity(id2), base = graph.base().entities[id2];
      if (entity && !base) {
        if (entity.type === "node") {
          graph.parentWays(entity).forEach(function(parent) {
            parent = parent.removeNode(id2);
            graph = graph.replace(parent);
            if (parent.isDegenerate()) {
              graph = actionDeleteWay(parent.id)(graph);
            }
          });
        }
        graph.parentRelations(entity).forEach(function(parent) {
          parent = parent.removeMembersWithID(id2);
          graph = graph.replace(parent);
          if (parent.isDegenerate()) {
            graph = actionDeleteRelation(parent.id)(graph);
          }
        });
      }
      return graph.revert(id2);
    };
    return action;
  }

  // modules/actions/rotate.js
  function actionRotate(rotateIds, pivot, angle2, projection2) {
    var action = function(graph) {
      return graph.update(function(graph2) {
        utilGetAllNodes(rotateIds, graph2).forEach(function(node) {
          var point2 = geoRotate([projection2(node.loc)], angle2, pivot)[0];
          graph2 = graph2.replace(node.move(projection2.invert(point2)));
        });
      });
    };
    return action;
  }

  // modules/actions/scale.js
  function actionScale(ids, pivotLoc, scaleFactor, projection2) {
    return function(graph) {
      return graph.update(function(graph2) {
        let point2, radial;
        utilGetAllNodes(ids, graph2).forEach(function(node) {
          point2 = projection2(node.loc);
          radial = [
            point2[0] - pivotLoc[0],
            point2[1] - pivotLoc[1]
          ];
          point2 = [
            pivotLoc[0] + scaleFactor * radial[0],
            pivotLoc[1] + scaleFactor * radial[1]
          ];
          graph2 = graph2.replace(node.move(projection2.invert(point2)));
        });
      });
    };
  }

  // modules/actions/straighten_nodes.js
  function actionStraightenNodes(nodeIDs, projection2) {
    function positionAlongWay(a2, o2, b2) {
      return geoVecDot(a2, b2, o2) / geoVecDot(b2, b2, o2);
    }
    function getEndpoints(points) {
      var ssr = geoGetSmallestSurroundingRectangle(points);
      var p1 = [(ssr.poly[0][0] + ssr.poly[1][0]) / 2, (ssr.poly[0][1] + ssr.poly[1][1]) / 2];
      var q1 = [(ssr.poly[2][0] + ssr.poly[3][0]) / 2, (ssr.poly[2][1] + ssr.poly[3][1]) / 2];
      var p2 = [(ssr.poly[3][0] + ssr.poly[4][0]) / 2, (ssr.poly[3][1] + ssr.poly[4][1]) / 2];
      var q2 = [(ssr.poly[1][0] + ssr.poly[2][0]) / 2, (ssr.poly[1][1] + ssr.poly[2][1]) / 2];
      var isLong = geoVecLength(p1, q1) > geoVecLength(p2, q2);
      if (isLong) {
        return [p1, q1];
      }
      return [p2, q2];
    }
    var action = function(graph, t2) {
      if (t2 === null || !isFinite(t2))
        t2 = 1;
      t2 = Math.min(Math.max(+t2, 0), 1);
      var nodes = nodeIDs.map(function(id2) {
        return graph.entity(id2);
      });
      var points = nodes.map(function(n3) {
        return projection2(n3.loc);
      });
      var endpoints = getEndpoints(points);
      var startPoint = endpoints[0];
      var endPoint = endpoints[1];
      for (var i3 = 0; i3 < points.length; i3++) {
        var node = nodes[i3];
        var point2 = points[i3];
        var u2 = positionAlongWay(point2, startPoint, endPoint);
        var point22 = geoVecInterp(startPoint, endPoint, u2);
        var loc2 = projection2.invert(point22);
        graph = graph.replace(node.move(geoVecInterp(node.loc, loc2, t2)));
      }
      return graph;
    };
    action.disabled = function(graph) {
      var nodes = nodeIDs.map(function(id2) {
        return graph.entity(id2);
      });
      var points = nodes.map(function(n3) {
        return projection2(n3.loc);
      });
      var endpoints = getEndpoints(points);
      var startPoint = endpoints[0];
      var endPoint = endpoints[1];
      var maxDistance = 0;
      for (var i3 = 0; i3 < points.length; i3++) {
        var point2 = points[i3];
        var u2 = positionAlongWay(point2, startPoint, endPoint);
        var p2 = geoVecInterp(startPoint, endPoint, u2);
        var dist = geoVecLength(p2, point2);
        if (!isNaN(dist) && dist > maxDistance) {
          maxDistance = dist;
        }
      }
      if (maxDistance < 1e-4) {
        return "straight_enough";
      }
    };
    action.transitionable = true;
    return action;
  }

  // modules/actions/straighten_way.js
  function actionStraightenWay(selectedIDs, projection2) {
    function positionAlongWay(a2, o2, b2) {
      return geoVecDot(a2, b2, o2) / geoVecDot(b2, b2, o2);
    }
    function allNodes(graph) {
      var nodes = [];
      var startNodes = [];
      var endNodes = [];
      var remainingWays = [];
      var selectedWays = selectedIDs.filter(function(w2) {
        return graph.entity(w2).type === "way";
      });
      var selectedNodes = selectedIDs.filter(function(n3) {
        return graph.entity(n3).type === "node";
      });
      for (var i3 = 0; i3 < selectedWays.length; i3++) {
        var way = graph.entity(selectedWays[i3]);
        nodes = way.nodes.slice(0);
        remainingWays.push(nodes);
        startNodes.push(nodes[0]);
        endNodes.push(nodes[nodes.length - 1]);
      }
      startNodes = startNodes.filter(function(n3) {
        return startNodes.indexOf(n3) === startNodes.lastIndexOf(n3);
      });
      endNodes = endNodes.filter(function(n3) {
        return endNodes.indexOf(n3) === endNodes.lastIndexOf(n3);
      });
      var currNode = utilArrayDifference(startNodes, endNodes).concat(utilArrayDifference(endNodes, startNodes))[0];
      var nextWay = [];
      nodes = [];
      var getNextWay = function(currNode2, remainingWays2) {
        return remainingWays2.filter(function(way2) {
          return way2[0] === currNode2 || way2[way2.length - 1] === currNode2;
        })[0];
      };
      while (remainingWays.length) {
        nextWay = getNextWay(currNode, remainingWays);
        remainingWays = utilArrayDifference(remainingWays, [nextWay]);
        if (nextWay[0] !== currNode) {
          nextWay.reverse();
        }
        nodes = nodes.concat(nextWay);
        currNode = nodes[nodes.length - 1];
      }
      if (selectedNodes.length === 2) {
        var startNodeIdx = nodes.indexOf(selectedNodes[0]);
        var endNodeIdx = nodes.indexOf(selectedNodes[1]);
        var sortedStartEnd = [startNodeIdx, endNodeIdx];
        sortedStartEnd.sort(function(a2, b2) {
          return a2 - b2;
        });
        nodes = nodes.slice(sortedStartEnd[0], sortedStartEnd[1] + 1);
      }
      return nodes.map(function(n3) {
        return graph.entity(n3);
      });
    }
    function shouldKeepNode(node, graph) {
      return graph.parentWays(node).length > 1 || graph.parentRelations(node).length || node.hasInterestingTags();
    }
    var action = function(graph, t2) {
      if (t2 === null || !isFinite(t2))
        t2 = 1;
      t2 = Math.min(Math.max(+t2, 0), 1);
      var nodes = allNodes(graph);
      var points = nodes.map(function(n3) {
        return projection2(n3.loc);
      });
      var startPoint = points[0];
      var endPoint = points[points.length - 1];
      var toDelete = [];
      var i3;
      for (i3 = 1; i3 < points.length - 1; i3++) {
        var node = nodes[i3];
        var point2 = points[i3];
        if (t2 < 1 || shouldKeepNode(node, graph)) {
          var u2 = positionAlongWay(point2, startPoint, endPoint);
          var p2 = geoVecInterp(startPoint, endPoint, u2);
          var loc2 = projection2.invert(p2);
          graph = graph.replace(node.move(geoVecInterp(node.loc, loc2, t2)));
        } else {
          if (toDelete.indexOf(node) === -1) {
            toDelete.push(node);
          }
        }
      }
      for (i3 = 0; i3 < toDelete.length; i3++) {
        graph = actionDeleteNode(toDelete[i3].id)(graph);
      }
      return graph;
    };
    action.disabled = function(graph) {
      var nodes = allNodes(graph);
      var points = nodes.map(function(n3) {
        return projection2(n3.loc);
      });
      var startPoint = points[0];
      var endPoint = points[points.length - 1];
      var threshold = 0.2 * geoVecLength(startPoint, endPoint);
      var i3;
      if (threshold === 0) {
        return "too_bendy";
      }
      var maxDistance = 0;
      for (i3 = 1; i3 < points.length - 1; i3++) {
        var point2 = points[i3];
        var u2 = positionAlongWay(point2, startPoint, endPoint);
        var p2 = geoVecInterp(startPoint, endPoint, u2);
        var dist = geoVecLength(p2, point2);
        if (isNaN(dist) || dist > threshold) {
          return "too_bendy";
        } else if (dist > maxDistance) {
          maxDistance = dist;
        }
      }
      var keepingAllNodes = nodes.every(function(node, i4) {
        return i4 === 0 || i4 === nodes.length - 1 || shouldKeepNode(node, graph);
      });
      if (maxDistance < 1e-4 && // Allow straightening even if already straight in order to remove extraneous nodes
      keepingAllNodes) {
        return "straight_enough";
      }
    };
    action.transitionable = true;
    return action;
  }

  // modules/actions/unrestrict_turn.js
  function actionUnrestrictTurn(turn) {
    return function(graph) {
      return actionDeleteRelation(turn.restrictionID)(graph);
    };
  }

  // modules/actions/reflect.js
  function actionReflect(reflectIds, projection2) {
    var _useLongAxis = true;
    var action = function(graph, t2) {
      if (t2 === null || !isFinite(t2))
        t2 = 1;
      t2 = Math.min(Math.max(+t2, 0), 1);
      var nodes = utilGetAllNodes(reflectIds, graph);
      var points = nodes.map(function(n3) {
        return projection2(n3.loc);
      });
      var ssr = geoGetSmallestSurroundingRectangle(points);
      var p1 = [(ssr.poly[0][0] + ssr.poly[1][0]) / 2, (ssr.poly[0][1] + ssr.poly[1][1]) / 2];
      var q1 = [(ssr.poly[2][0] + ssr.poly[3][0]) / 2, (ssr.poly[2][1] + ssr.poly[3][1]) / 2];
      var p2 = [(ssr.poly[3][0] + ssr.poly[4][0]) / 2, (ssr.poly[3][1] + ssr.poly[4][1]) / 2];
      var q2 = [(ssr.poly[1][0] + ssr.poly[2][0]) / 2, (ssr.poly[1][1] + ssr.poly[2][1]) / 2];
      var p3, q3;
      var isLong = geoVecLength(p1, q1) > geoVecLength(p2, q2);
      if (_useLongAxis && isLong || !_useLongAxis && !isLong) {
        p3 = p1;
        q3 = q1;
      } else {
        p3 = p2;
        q3 = q2;
      }
      var dx = q3[0] - p3[0];
      var dy = q3[1] - p3[1];
      var a2 = (dx * dx - dy * dy) / (dx * dx + dy * dy);
      var b2 = 2 * dx * dy / (dx * dx + dy * dy);
      for (var i3 = 0; i3 < nodes.length; i3++) {
        var node = nodes[i3];
        var c2 = projection2(node.loc);
        var c22 = [
          a2 * (c2[0] - p3[0]) + b2 * (c2[1] - p3[1]) + p3[0],
          b2 * (c2[0] - p3[0]) - a2 * (c2[1] - p3[1]) + p3[1]
        ];
        var loc2 = projection2.invert(c22);
        node = node.move(geoVecInterp(node.loc, loc2, t2));
        graph = graph.replace(node);
      }
      return graph;
    };
    action.useLongAxis = function(val) {
      if (!arguments.length)
        return _useLongAxis;
      _useLongAxis = val;
      return action;
    };
    action.transitionable = true;
    return action;
  }

  // modules/actions/upgrade_tags.js
  function actionUpgradeTags(entityId, oldTags, replaceTags) {
    return function(graph) {
      var entity = graph.entity(entityId);
      var tags = Object.assign({}, entity.tags);
      var transferValue;
      var semiIndex;
      for (var oldTagKey in oldTags) {
        if (!(oldTagKey in tags))
          continue;
        if (oldTags[oldTagKey] === "*") {
          transferValue = tags[oldTagKey];
          delete tags[oldTagKey];
        } else if (oldTags[oldTagKey] === tags[oldTagKey]) {
          delete tags[oldTagKey];
        } else {
          var vals = tags[oldTagKey].split(";").filter(Boolean);
          var oldIndex = vals.indexOf(oldTags[oldTagKey]);
          if (vals.length === 1 || oldIndex === -1) {
            delete tags[oldTagKey];
          } else {
            if (replaceTags && replaceTags[oldTagKey]) {
              semiIndex = oldIndex;
            }
            vals.splice(oldIndex, 1);
            tags[oldTagKey] = vals.join(";");
          }
        }
      }
      if (replaceTags) {
        for (var replaceKey in replaceTags) {
          var replaceValue = replaceTags[replaceKey];
          if (replaceValue === "*") {
            if (tags[replaceKey] && tags[replaceKey] !== "no") {
              continue;
            } else {
              tags[replaceKey] = "yes";
            }
          } else if (replaceValue === "$1") {
            tags[replaceKey] = transferValue;
          } else {
            if (tags[replaceKey] && oldTags[replaceKey] && semiIndex !== void 0) {
              var existingVals = tags[replaceKey].split(";").filter(Boolean);
              if (existingVals.indexOf(replaceValue) === -1) {
                existingVals.splice(semiIndex, 0, replaceValue);
                tags[replaceKey] = existingVals.join(";");
              }
            } else {
              tags[replaceKey] = replaceValue;
            }
          }
        }
      }
      return graph.replace(entity.update({ tags }));
    };
  }

  // modules/behavior/edit.js
  function behaviorEdit(context) {
    function behavior() {
      context.map().minzoom(context.minEditableZoom());
    }
    behavior.off = function() {
      context.map().minzoom(0);
    };
    return behavior;
  }

  // modules/behavior/hover.js
  function behaviorHover(context) {
    var dispatch14 = dispatch_default("hover");
    var _selection = select_default2(null);
    var _newNodeId = null;
    var _initialNodeID = null;
    var _altDisables;
    var _ignoreVertex;
    var _targets = [];
    var _pointerPrefix = "PointerEvent" in window ? "pointer" : "mouse";
    function keydown(d3_event) {
      if (_altDisables && d3_event.keyCode === utilKeybinding.modifierCodes.alt) {
        _selection.selectAll(".hover").classed("hover-suppressed", true).classed("hover", false);
        _selection.classed("hover-disabled", true);
        dispatch14.call("hover", this, null);
      }
    }
    function keyup(d3_event) {
      if (_altDisables && d3_event.keyCode === utilKeybinding.modifierCodes.alt) {
        _selection.selectAll(".hover-suppressed").classed("hover-suppressed", false).classed("hover", true);
        _selection.classed("hover-disabled", false);
        dispatch14.call("hover", this, _targets);
      }
    }
    function behavior(selection2) {
      _selection = selection2;
      _targets = [];
      if (_initialNodeID) {
        _newNodeId = _initialNodeID;
        _initialNodeID = null;
      } else {
        _newNodeId = null;
      }
      _selection.on(_pointerPrefix + "over.hover", pointerover).on(_pointerPrefix + "out.hover", pointerout).on(_pointerPrefix + "down.hover", pointerover);
      select_default2(window).on(_pointerPrefix + "up.hover pointercancel.hover", pointerout, true).on("keydown.hover", keydown).on("keyup.hover", keyup);
      function eventTarget(d3_event) {
        var datum2 = d3_event.target && d3_event.target.__data__;
        if (typeof datum2 !== "object")
          return null;
        if (!(datum2 instanceof osmEntity) && datum2.properties && datum2.properties.entity instanceof osmEntity) {
          return datum2.properties.entity;
        }
        return datum2;
      }
      function pointerover(d3_event) {
        if (context.mode().id.indexOf("drag") === -1 && (!d3_event.pointerType || d3_event.pointerType === "mouse") && d3_event.buttons)
          return;
        var target = eventTarget(d3_event);
        if (target && _targets.indexOf(target) === -1) {
          _targets.push(target);
          updateHover(d3_event, _targets);
        }
      }
      function pointerout(d3_event) {
        var target = eventTarget(d3_event);
        var index = _targets.indexOf(target);
        if (index !== -1) {
          _targets.splice(index);
          updateHover(d3_event, _targets);
        }
      }
      function allowsVertex(d2) {
        return d2.geometry(context.graph()) === "vertex" || _mainPresetIndex.allowsVertex(d2, context.graph());
      }
      function modeAllowsHover(target) {
        var mode = context.mode();
        if (mode.id === "add-point") {
          return mode.preset.matchGeometry("vertex") || target.type !== "way" && target.geometry(context.graph()) !== "vertex";
        }
        return true;
      }
      function updateHover(d3_event, targets) {
        _selection.selectAll(".hover").classed("hover", false);
        _selection.selectAll(".hover-suppressed").classed("hover-suppressed", false);
        var mode = context.mode();
        if (!_newNodeId && (mode.id === "draw-line" || mode.id === "draw-area")) {
          var node = targets.find(function(target) {
            return target instanceof osmEntity && target.type === "node";
          });
          _newNodeId = node && node.id;
        }
        targets = targets.filter(function(datum3) {
          if (datum3 instanceof osmEntity) {
            return datum3.id !== _newNodeId && (datum3.type !== "node" || !_ignoreVertex || allowsVertex(datum3)) && modeAllowsHover(datum3);
          }
          return true;
        });
        var selector = "";
        for (var i3 in targets) {
          var datum2 = targets[i3];
          if (datum2.__featurehash__) {
            selector += ", .data" + datum2.__featurehash__;
          } else if (datum2 instanceof QAItem) {
            selector += ", ." + datum2.service + ".itemId-" + datum2.id;
          } else if (datum2 instanceof osmNote) {
            selector += ", .note-" + datum2.id;
          } else if (datum2 instanceof osmEntity) {
            selector += ", ." + datum2.id;
            if (datum2.type === "relation") {
              for (var j2 in datum2.members) {
                selector += ", ." + datum2.members[j2].id;
              }
            }
          }
        }
        var suppressed = _altDisables && d3_event && d3_event.altKey;
        if (selector.trim().length) {
          selector = selector.slice(1);
          _selection.selectAll(selector).classed(suppressed ? "hover-suppressed" : "hover", true);
        }
        dispatch14.call("hover", this, !suppressed && targets);
      }
    }
    behavior.off = function(selection2) {
      selection2.selectAll(".hover").classed("hover", false);
      selection2.selectAll(".hover-suppressed").classed("hover-suppressed", false);
      selection2.classed("hover-disabled", false);
      selection2.on(_pointerPrefix + "over.hover", null).on(_pointerPrefix + "out.hover", null).on(_pointerPrefix + "down.hover", null);
      select_default2(window).on(_pointerPrefix + "up.hover pointercancel.hover", null, true).on("keydown.hover", null).on("keyup.hover", null);
    };
    behavior.altDisables = function(val) {
      if (!arguments.length)
        return _altDisables;
      _altDisables = val;
      return behavior;
    };
    behavior.ignoreVertex = function(val) {
      if (!arguments.length)
        return _ignoreVertex;
      _ignoreVertex = val;
      return behavior;
    };
    behavior.initialNodeID = function(nodeId) {
      _initialNodeID = nodeId;
      return behavior;
    };
    return utilRebind(behavior, dispatch14, "on");
  }

  // modules/behavior/draw.js
  var _disableSpace = false;
  var _lastSpace = null;
  function behaviorDraw(context) {
    var dispatch14 = dispatch_default(
      "move",
      "down",
      "downcancel",
      "click",
      "clickWay",
      "clickNode",
      "undo",
      "cancel",
      "finish"
    );
    var keybinding = utilKeybinding("draw");
    var _hover = behaviorHover(context).altDisables(true).ignoreVertex(true).on("hover", context.ui().sidebar.hover);
    var _edit = behaviorEdit(context);
    var _closeTolerance = 4;
    var _tolerance = 12;
    var _mouseLeave = false;
    var _lastMouse = null;
    var _lastPointerUpEvent;
    var _downPointer;
    var _pointerPrefix = "PointerEvent" in window ? "pointer" : "mouse";
    function datum2(d3_event) {
      var mode = context.mode();
      var isNote = mode && mode.id.indexOf("note") !== -1;
      if (d3_event.altKey || isNote)
        return {};
      var element;
      if (d3_event.type === "keydown") {
        element = _lastMouse && _lastMouse.target;
      } else {
        element = d3_event.target;
      }
      var d2 = element.__data__;
      return d2 && d2.properties && d2.properties.target ? d2 : {};
    }
    function pointerdown(d3_event) {
      if (_downPointer)
        return;
      var pointerLocGetter = utilFastMouse(this);
      _downPointer = {
        id: d3_event.pointerId || "mouse",
        pointerLocGetter,
        downTime: +/* @__PURE__ */ new Date(),
        downLoc: pointerLocGetter(d3_event)
      };
      dispatch14.call("down", this, d3_event, datum2(d3_event));
    }
    function pointerup(d3_event) {
      if (!_downPointer || _downPointer.id !== (d3_event.pointerId || "mouse"))
        return;
      var downPointer = _downPointer;
      _downPointer = null;
      _lastPointerUpEvent = d3_event;
      if (downPointer.isCancelled)
        return;
      var t2 = +/* @__PURE__ */ new Date();
      var p2 = downPointer.pointerLocGetter(d3_event);
      var dist = geoVecLength(downPointer.downLoc, p2);
      if (dist < _closeTolerance || dist < _tolerance && t2 - downPointer.downTime < 500) {
        select_default2(window).on("click.draw-block", function() {
          d3_event.stopPropagation();
        }, true);
        context.map().dblclickZoomEnable(false);
        window.setTimeout(function() {
          context.map().dblclickZoomEnable(true);
          select_default2(window).on("click.draw-block", null);
        }, 500);
        click(d3_event, p2);
      }
    }
    function pointermove(d3_event) {
      if (_downPointer && _downPointer.id === (d3_event.pointerId || "mouse") && !_downPointer.isCancelled) {
        var p2 = _downPointer.pointerLocGetter(d3_event);
        var dist = geoVecLength(_downPointer.downLoc, p2);
        if (dist >= _closeTolerance) {
          _downPointer.isCancelled = true;
          dispatch14.call("downcancel", this);
        }
      }
      if (d3_event.pointerType && d3_event.pointerType !== "mouse" || d3_event.buttons || _downPointer)
        return;
      if (_lastPointerUpEvent && _lastPointerUpEvent.pointerType !== "mouse" && d3_event.timeStamp - _lastPointerUpEvent.timeStamp < 100)
        return;
      _lastMouse = d3_event;
      dispatch14.call("move", this, d3_event, datum2(d3_event));
    }
    function pointercancel(d3_event) {
      if (_downPointer && _downPointer.id === (d3_event.pointerId || "mouse")) {
        if (!_downPointer.isCancelled) {
          dispatch14.call("downcancel", this);
        }
        _downPointer = null;
      }
    }
    function mouseenter() {
      _mouseLeave = false;
    }
    function mouseleave() {
      _mouseLeave = true;
    }
    function allowsVertex(d2) {
      return d2.geometry(context.graph()) === "vertex" || _mainPresetIndex.allowsVertex(d2, context.graph());
    }
    function click(d3_event, loc) {
      var d2 = datum2(d3_event);
      var target = d2 && d2.properties && d2.properties.entity;
      var mode = context.mode();
      if (target && target.type === "node" && allowsVertex(target)) {
        dispatch14.call("clickNode", this, target, d2);
        return;
      } else if (target && target.type === "way" && (mode.id !== "add-point" || mode.preset.matchGeometry("vertex"))) {
        var choice = geoChooseEdge(
          context.graph().childNodes(target),
          loc,
          context.projection,
          context.activeID()
        );
        if (choice) {
          var edge = [target.nodes[choice.index - 1], target.nodes[choice.index]];
          dispatch14.call("clickWay", this, choice.loc, edge, d2);
          return;
        }
      } else if (mode.id !== "add-point" || mode.preset.matchGeometry("point")) {
        var locLatLng = context.projection.invert(loc);
        dispatch14.call("click", this, locLatLng, d2);
      }
    }
    function space(d3_event) {
      d3_event.preventDefault();
      d3_event.stopPropagation();
      var currSpace = context.map().mouse();
      if (_disableSpace && _lastSpace) {
        var dist = geoVecLength(_lastSpace, currSpace);
        if (dist > _tolerance) {
          _disableSpace = false;
        }
      }
      if (_disableSpace || _mouseLeave || !_lastMouse)
        return;
      _lastSpace = currSpace;
      _disableSpace = true;
      select_default2(window).on("keyup.space-block", function() {
        d3_event.preventDefault();
        d3_event.stopPropagation();
        _disableSpace = false;
        select_default2(window).on("keyup.space-block", null);
      });
      var loc = context.map().mouse() || // or the map center if the mouse has never entered the map
      context.projection(context.map().center());
      click(d3_event, loc);
    }
    function backspace(d3_event) {
      d3_event.preventDefault();
      dispatch14.call("undo");
    }
    function del(d3_event) {
      d3_event.preventDefault();
      dispatch14.call("cancel");
    }
    function ret(d3_event) {
      d3_event.preventDefault();
      dispatch14.call("finish");
    }
    function behavior(selection2) {
      context.install(_hover);
      context.install(_edit);
      _downPointer = null;
      keybinding.on("\u232B", backspace).on("\u2326", del).on("\u238B", ret).on("\u21A9", ret).on("space", space).on("\u2325space", space);
      selection2.on("mouseenter.draw", mouseenter).on("mouseleave.draw", mouseleave).on(_pointerPrefix + "down.draw", pointerdown).on(_pointerPrefix + "move.draw", pointermove);
      select_default2(window).on(_pointerPrefix + "up.draw", pointerup, true).on("pointercancel.draw", pointercancel, true);
      select_default2(document).call(keybinding);
      return behavior;
    }
    behavior.off = function(selection2) {
      context.ui().sidebar.hover.cancel();
      context.uninstall(_hover);
      context.uninstall(_edit);
      selection2.on("mouseenter.draw", null).on("mouseleave.draw", null).on(_pointerPrefix + "down.draw", null).on(_pointerPrefix + "move.draw", null);
      select_default2(window).on(_pointerPrefix + "up.draw", null).on("pointercancel.draw", null);
      select_default2(document).call(keybinding.unbind);
    };
    behavior.hover = function() {
      return _hover;
    };
    return utilRebind(behavior, dispatch14, "on");
  }

  // modules/behavior/breathe.js
  var import_fast_deep_equal2 = __toESM(require_fast_deep_equal());

  // node_modules/d3-scale/src/init.js
  function initRange(domain, range3) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range3).domain(domain);
        break;
    }
    return this;
  }

  // node_modules/d3-scale/src/constant.js
  function constants(x2) {
    return function() {
      return x2;
    };
  }

  // node_modules/d3-scale/src/number.js
  function number2(x2) {
    return +x2;
  }

  // node_modules/d3-scale/src/continuous.js
  var unit = [0, 1];
  function identity3(x2) {
    return x2;
  }
  function normalize(a2, b2) {
    return (b2 -= a2 = +a2) ? function(x2) {
      return (x2 - a2) / b2;
    } : constants(isNaN(b2) ? NaN : 0.5);
  }
  function clamper(a2, b2) {
    var t2;
    if (a2 > b2)
      t2 = a2, a2 = b2, b2 = t2;
    return function(x2) {
      return Math.max(a2, Math.min(b2, x2));
    };
  }
  function bimap(domain, range3, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range3[0], r1 = range3[1];
    if (d1 < d0)
      d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
    else
      d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
    return function(x2) {
      return r0(d0(x2));
    };
  }
  function polymap(domain, range3, interpolate) {
    var j2 = Math.min(domain.length, range3.length) - 1, d2 = new Array(j2), r2 = new Array(j2), i3 = -1;
    if (domain[j2] < domain[0]) {
      domain = domain.slice().reverse();
      range3 = range3.slice().reverse();
    }
    while (++i3 < j2) {
      d2[i3] = normalize(domain[i3], domain[i3 + 1]);
      r2[i3] = interpolate(range3[i3], range3[i3 + 1]);
    }
    return function(x2) {
      var i4 = bisect_default(domain, x2, 1, j2) - 1;
      return r2[i4](d2[i4](x2));
    };
  }
  function copy(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
  }
  function transformer2() {
    var domain = unit, range3 = unit, interpolate = value_default, transform2, untransform, unknown, clamp3 = identity3, piecewise, output, input;
    function rescale() {
      var n3 = Math.min(domain.length, range3.length);
      if (clamp3 !== identity3)
        clamp3 = clamper(domain[0], domain[n3 - 1]);
      piecewise = n3 > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }
    function scale(x2) {
      return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise(domain.map(transform2), range3, interpolate)))(transform2(clamp3(x2)));
    }
    scale.invert = function(y2) {
      return clamp3(untransform((input || (input = piecewise(range3, domain.map(transform2), number_default)))(y2)));
    };
    scale.domain = function(_2) {
      return arguments.length ? (domain = Array.from(_2, number2), rescale()) : domain.slice();
    };
    scale.range = function(_2) {
      return arguments.length ? (range3 = Array.from(_2), rescale()) : range3.slice();
    };
    scale.rangeRound = function(_2) {
      return range3 = Array.from(_2), interpolate = round_default, rescale();
    };
    scale.clamp = function(_2) {
      return arguments.length ? (clamp3 = _2 ? true : identity3, rescale()) : clamp3 !== identity3;
    };
    scale.interpolate = function(_2) {
      return arguments.length ? (interpolate = _2, rescale()) : interpolate;
    };
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    return function(t2, u2) {
      transform2 = t2, untransform = u2;
      return rescale();
    };
  }
  function continuous() {
    return transformer2()(identity3, identity3);
  }

  // node_modules/d3-format/src/formatDecimal.js
  function formatDecimal_default(x2) {
    return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
  }
  function formatDecimalParts(x2, p2) {
    if ((i3 = (x2 = p2 ? x2.toExponential(p2 - 1) : x2.toExponential()).indexOf("e")) < 0)
      return null;
    var i3, coefficient = x2.slice(0, i3);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x2.slice(i3 + 1)
    ];
  }

  // node_modules/d3-format/src/exponent.js
  function exponent_default(x2) {
    return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
  }

  // node_modules/d3-format/src/formatGroup.js
  function formatGroup_default(grouping, thousands) {
    return function(value, width) {
      var i3 = value.length, t2 = [], j2 = 0, g3 = grouping[0], length2 = 0;
      while (i3 > 0 && g3 > 0) {
        if (length2 + g3 + 1 > width)
          g3 = Math.max(1, width - length2);
        t2.push(value.substring(i3 -= g3, i3 + g3));
        if ((length2 += g3 + 1) > width)
          break;
        g3 = grouping[j2 = (j2 + 1) % grouping.length];
      }
      return t2.reverse().join(thousands);
    };
  }

  // node_modules/d3-format/src/formatNumerals.js
  function formatNumerals_default(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i3) {
        return numerals[+i3];
      });
    };
  }

  // node_modules/d3-format/src/formatSpecifier.js
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier)))
      throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };

  // node_modules/d3-format/src/formatTrim.js
  function formatTrim_default(s2) {
    out:
      for (var n3 = s2.length, i3 = 1, i0 = -1, i1; i3 < n3; ++i3) {
        switch (s2[i3]) {
          case ".":
            i0 = i1 = i3;
            break;
          case "0":
            if (i0 === 0)
              i0 = i3;
            i1 = i3;
            break;
          default:
            if (!+s2[i3])
              break out;
            if (i0 > 0)
              i0 = 0;
            break;
        }
      }
    return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
  }

  // node_modules/d3-format/src/formatPrefixAuto.js
  var prefixExponent;
  function formatPrefixAuto_default(x2, p2) {
    var d2 = formatDecimalParts(x2, p2);
    if (!d2)
      return x2 + "";
    var coefficient = d2[0], exponent = d2[1], i3 = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n3 = coefficient.length;
    return i3 === n3 ? coefficient : i3 > n3 ? coefficient + new Array(i3 - n3 + 1).join("0") : i3 > 0 ? coefficient.slice(0, i3) + "." + coefficient.slice(i3) : "0." + new Array(1 - i3).join("0") + formatDecimalParts(x2, Math.max(0, p2 + i3 - 1))[0];
  }

  // node_modules/d3-format/src/formatRounded.js
  function formatRounded_default(x2, p2) {
    var d2 = formatDecimalParts(x2, p2);
    if (!d2)
      return x2 + "";
    var coefficient = d2[0], exponent = d2[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  // node_modules/d3-format/src/formatTypes.js
  var formatTypes_default = {
    "%": (x2, p2) => (x2 * 100).toFixed(p2),
    "b": (x2) => Math.round(x2).toString(2),
    "c": (x2) => x2 + "",
    "d": formatDecimal_default,
    "e": (x2, p2) => x2.toExponential(p2),
    "f": (x2, p2) => x2.toFixed(p2),
    "g": (x2, p2) => x2.toPrecision(p2),
    "o": (x2) => Math.round(x2).toString(8),
    "p": (x2, p2) => formatRounded_default(x2 * 100, p2),
    "r": formatRounded_default,
    "s": formatPrefixAuto_default,
    "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
    "x": (x2) => Math.round(x2).toString(16)
  };

  // node_modules/d3-format/src/identity.js
  function identity_default4(x2) {
    return x2;
  }

  // node_modules/d3-format/src/locale.js
  var map = Array.prototype.map;
  var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function locale_default(locale2) {
    var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default4 : formatGroup_default(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default4 : formatNumerals_default(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision3 = specifier.precision, trim = specifier.trim, type2 = specifier.type;
      if (type2 === "n")
        comma = true, type2 = "g";
      else if (!formatTypes_default[type2])
        precision3 === void 0 && (precision3 = 12), trim = true, type2 = "g";
      if (zero3 || fill === "0" && align === "=")
        zero3 = true, fill = "0", align = "=";
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
      var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
      precision3 = precision3 === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision3)) : Math.max(0, Math.min(20, precision3));
      function format2(value) {
        var valuePrefix = prefix, valueSuffix = suffix, i3, n3, c2;
        if (type2 === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;
          var valueNegative = value < 0 || 1 / value < 0;
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision3);
          if (trim)
            value = formatTrim_default(value);
          if (valueNegative && +value === 0 && sign2 !== "+")
            valueNegative = false;
          valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
          valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
          if (maybeSuffix) {
            i3 = -1, n3 = value.length;
            while (++i3 < n3) {
              if (c2 = value.charCodeAt(i3), 48 > c2 || c2 > 57) {
                valueSuffix = (c2 === 46 ? decimal + value.slice(i3 + 1) : value.slice(i3)) + valueSuffix;
                value = value.slice(0, i3);
                break;
              }
            }
          }
        }
        if (comma && !zero3)
          value = group(value, Infinity);
        var length2 = valuePrefix.length + value.length + valueSuffix.length, padding = length2 < width ? new Array(width - length2 + 1).join(fill) : "";
        if (comma && zero3)
          value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding;
            break;
          case "=":
            value = valuePrefix + padding + value + valueSuffix;
            break;
          case "^":
            value = padding.slice(0, length2 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length2);
            break;
          default:
            value = padding + valuePrefix + value + valueSuffix;
            break;
        }
        return numerals(value);
      }
      format2.toString = function() {
        return specifier + "";
      };
      return format2;
    }
    function formatPrefix2(specifier, value) {
      var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k2 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
      return function(value2) {
        return f2(k2 * value2) + prefix;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }

  // node_modules/d3-format/src/defaultLocale.js
  var locale;
  var format;
  var formatPrefix;
  defaultLocale({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale(definition) {
    locale = locale_default(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  // node_modules/d3-format/src/precisionFixed.js
  function precisionFixed_default(step) {
    return Math.max(0, -exponent_default(Math.abs(step)));
  }

  // node_modules/d3-format/src/precisionPrefix.js
  function precisionPrefix_default(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
  }

  // node_modules/d3-format/src/precisionRound.js
  function precisionRound_default(step, max3) {
    step = Math.abs(step), max3 = Math.abs(max3) - step;
    return Math.max(0, exponent_default(max3) - exponent_default(step)) + 1;
  }

  // node_modules/d3-scale/src/tickFormat.js
  function tickFormat(start2, stop, count, specifier) {
    var step = tickStep(start2, stop, count), precision3;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start2), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision3 = precisionPrefix_default(step, value)))
          specifier.precision = precision3;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision3 = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
          specifier.precision = precision3 - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision3 = precisionFixed_default(step)))
          specifier.precision = precision3 - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }

  // node_modules/d3-scale/src/linear.js
  function linearish(scale) {
    var domain = scale.domain;
    scale.ticks = function(count) {
      var d2 = domain();
      return ticks(d2[0], d2[d2.length - 1], count == null ? 10 : count);
    };
    scale.tickFormat = function(count, specifier) {
      var d2 = domain();
      return tickFormat(d2[0], d2[d2.length - 1], count == null ? 10 : count, specifier);
    };
    scale.nice = function(count) {
      if (count == null)
        count = 10;
      var d2 = domain();
      var i0 = 0;
      var i1 = d2.length - 1;
      var start2 = d2[i0];
      var stop = d2[i1];
      var prestep;
      var step;
      var maxIter = 10;
      if (stop < start2) {
        step = start2, start2 = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }
      while (maxIter-- > 0) {
        step = tickIncrement(start2, stop, count);
        if (step === prestep) {
          d2[i0] = start2;
          d2[i1] = stop;
          return domain(d2);
        } else if (step > 0) {
          start2 = Math.floor(start2 / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start2 = Math.ceil(start2 * step) / step;
          stop = Math.floor(stop * step) / step;
        } else {
          break;
        }
        prestep = step;
      }
      return scale;
    };
    return scale;
  }
  function linear3() {
    var scale = continuous();
    scale.copy = function() {
      return copy(scale, linear3());
    };
    initRange.apply(scale, arguments);
    return linearish(scale);
  }

  // node_modules/d3-scale/src/quantize.js
  function quantize() {
    var x05 = 0, x12 = 1, n3 = 1, domain = [0.5], range3 = [0, 1], unknown;
    function scale(x2) {
      return x2 != null && x2 <= x2 ? range3[bisect_default(domain, x2, 0, n3)] : unknown;
    }
    function rescale() {
      var i3 = -1;
      domain = new Array(n3);
      while (++i3 < n3)
        domain[i3] = ((i3 + 1) * x12 - (i3 - n3) * x05) / (n3 + 1);
      return scale;
    }
    scale.domain = function(_2) {
      return arguments.length ? ([x05, x12] = _2, x05 = +x05, x12 = +x12, rescale()) : [x05, x12];
    };
    scale.range = function(_2) {
      return arguments.length ? (n3 = (range3 = Array.from(_2)).length - 1, rescale()) : range3.slice();
    };
    scale.invertExtent = function(y2) {
      var i3 = range3.indexOf(y2);
      return i3 < 0 ? [NaN, NaN] : i3 < 1 ? [x05, domain[0]] : i3 >= n3 ? [domain[n3 - 1], x12] : [domain[i3 - 1], domain[i3]];
    };
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : scale;
    };
    scale.thresholds = function() {
      return domain.slice();
    };
    scale.copy = function() {
      return quantize().domain([x05, x12]).range(range3).unknown(unknown);
    };
    return initRange.apply(linearish(scale), arguments);
  }

  // modules/behavior/breathe.js
  function behaviorBreathe() {
    var duration = 800;
    var steps = 4;
    var selector = ".selected.shadow, .selected .shadow";
    var _selected = select_default2(null);
    var _classed = "";
    var _params = {};
    var _done = false;
    var _timer;
    function ratchetyInterpolator(a2, b2, steps2, units) {
      a2 = Number(a2);
      b2 = Number(b2);
      var sample = quantize().domain([0, 1]).range(quantize_default(number_default(a2, b2), steps2));
      return function(t2) {
        return String(sample(t2)) + (units || "");
      };
    }
    function reset(selection2) {
      selection2.style("stroke-opacity", null).style("stroke-width", null).style("fill-opacity", null).style("r", null);
    }
    function setAnimationParams(transition2, fromTo) {
      var toFrom = fromTo === "from" ? "to" : "from";
      transition2.styleTween("stroke-opacity", function(d2) {
        return ratchetyInterpolator(
          _params[d2.id][toFrom].opacity,
          _params[d2.id][fromTo].opacity,
          steps
        );
      }).styleTween("stroke-width", function(d2) {
        return ratchetyInterpolator(
          _params[d2.id][toFrom].width,
          _params[d2.id][fromTo].width,
          steps,
          "px"
        );
      }).styleTween("fill-opacity", function(d2) {
        return ratchetyInterpolator(
          _params[d2.id][toFrom].opacity,
          _params[d2.id][fromTo].opacity,
          steps
        );
      }).styleTween("r", function(d2) {
        return ratchetyInterpolator(
          _params[d2.id][toFrom].width,
          _params[d2.id][fromTo].width,
          steps,
          "px"
        );
      });
    }
    function calcAnimationParams(selection2) {
      selection2.call(reset).each(function(d2) {
        var s2 = select_default2(this);
        var tag2 = s2.node().tagName;
        var p2 = { "from": {}, "to": {} };
        var opacity;
        var width;
        if (tag2 === "circle") {
          opacity = Number(s2.style("fill-opacity") || 0.5);
          width = Number(s2.style("r") || 15.5);
        } else {
          opacity = Number(s2.style("stroke-opacity") || 0.7);
          width = Number(s2.style("stroke-width") || 10);
        }
        p2.tag = tag2;
        p2.from.opacity = opacity * 0.6;
        p2.to.opacity = opacity * 1.25;
        p2.from.width = width * 0.7;
        p2.to.width = width * (tag2 === "circle" ? 1.5 : 1);
        _params[d2.id] = p2;
      });
    }
    function run(surface, fromTo) {
      var toFrom = fromTo === "from" ? "to" : "from";
      var currSelected = surface.selectAll(selector);
      var currClassed = surface.attr("class");
      if (_done || currSelected.empty()) {
        _selected.call(reset);
        _selected = select_default2(null);
        return;
      }
      if (!(0, import_fast_deep_equal2.default)(currSelected.data(), _selected.data()) || currClassed !== _classed) {
        _selected.call(reset);
        _classed = currClassed;
        _selected = currSelected.call(calcAnimationParams);
      }
      var didCallNextRun = false;
      _selected.transition().duration(duration).call(setAnimationParams, fromTo).on("end", function() {
        if (!didCallNextRun) {
          surface.call(run, toFrom);
          didCallNextRun = true;
        }
        if (!select_default2(this).classed("selected")) {
          reset(select_default2(this));
        }
      });
    }
    function behavior(surface) {
      _done = false;
      _timer = timer(function() {
        if (surface.selectAll(selector).empty()) {
          return false;
        }
        surface.call(run, "from");
        _timer.stop();
        return true;
      }, 20);
    }
    behavior.restartIfNeeded = function(surface) {
      if (_selected.empty()) {
        surface.call(run, "from");
        if (_timer) {
          _timer.stop();
        }
      }
    };
    behavior.off = function() {
      _done = true;
      if (_timer) {
        _timer.stop();
      }
      _selected.interrupt().call(reset);
    };
    return behavior;
  }

  // modules/behavior/operation.js
  function behaviorOperation(context) {
    var _operation;
    function keypress(d3_event) {
      if (!context.map().withinEditableZoom())
        return;
      if (_operation.availableForKeypress && !_operation.availableForKeypress())
        return;
      d3_event.preventDefault();
      var disabled = _operation.disabled();
      if (disabled) {
        context.ui().flash.duration(4e3).iconName("#iD-operation-" + _operation.id).iconClass("operation disabled").label(_operation.tooltip())();
      } else {
        context.ui().flash.duration(2e3).iconName("#iD-operation-" + _operation.id).iconClass("operation").label(_operation.annotation() || _operation.title)();
        if (_operation.point)
          _operation.point(null);
        _operation();
      }
    }
    function behavior() {
      if (_operation && _operation.available()) {
        context.keybinding().on(_operation.keys, keypress);
      }
      return behavior;
    }
    behavior.off = function() {
      context.keybinding().off(_operation.keys);
    };
    behavior.which = function(_2) {
      if (!arguments.length)
        return _operation;
      _operation = _2;
      return behavior;
    };
    return behavior;
  }

  // modules/operations/circularize.js
  function operationCircularize(context, selectedIDs) {
    var _extent;
    var _actions = selectedIDs.map(getAction).filter(Boolean);
    var _amount = _actions.length === 1 ? "single" : "multiple";
    var _coords = utilGetAllNodes(selectedIDs, context.graph()).map(function(n3) {
      return n3.loc;
    });
    function getAction(entityID) {
      var entity = context.entity(entityID);
      if (entity.type !== "way" || new Set(entity.nodes).size <= 1)
        return null;
      if (!_extent) {
        _extent = entity.extent(context.graph());
      } else {
        _extent = _extent.extend(entity.extent(context.graph()));
      }
      return actionCircularize(entityID, context.projection);
    }
    var operation2 = function() {
      if (!_actions.length)
        return;
      var combinedAction = function(graph, t2) {
        _actions.forEach(function(action) {
          if (!action.disabled(graph)) {
            graph = action(graph, t2);
          }
        });
        return graph;
      };
      combinedAction.transitionable = true;
      context.perform(combinedAction, operation2.annotation());
      window.setTimeout(function() {
        context.validator().validate();
      }, 300);
    };
    operation2.available = function() {
      return _actions.length && selectedIDs.length === _actions.length;
    };
    operation2.disabled = function() {
      if (!_actions.length)
        return "";
      var actionDisableds = _actions.map(function(action) {
        return action.disabled(context.graph());
      }).filter(Boolean);
      if (actionDisableds.length === _actions.length) {
        if (new Set(actionDisableds).size > 1) {
          return "multiple_blockers";
        }
        return actionDisableds[0];
      } else if (_extent.percentContainedIn(context.map().extent()) < 0.8) {
        return "too_large";
      } else if (someMissing()) {
        return "not_downloaded";
      } else if (selectedIDs.some(context.hasHiddenConnections)) {
        return "connected_to_hidden";
      }
      return false;
      function someMissing() {
        if (context.inIntro())
          return false;
        var osm = context.connection();
        if (osm) {
          var missing = _coords.filter(function(loc) {
            return !osm.isDataLoaded(loc);
          });
          if (missing.length) {
            missing.forEach(function(loc) {
              context.loadTileAtLoc(loc);
            });
            return true;
          }
        }
        return false;
      }
    };
    operation2.tooltip = function() {
      var disable = operation2.disabled();
      return disable ? _t.append("operations.circularize." + disable + "." + _amount) : _t.append("operations.circularize.description." + _amount);
    };
    operation2.annotation = function() {
      return _t("operations.circularize.annotation.feature", { n: _actions.length });
    };
    operation2.id = "circularize";
    operation2.keys = [_t("operations.circularize.key")];
    operation2.title = _t.append("operations.circularize.title");
    operation2.behavior = behaviorOperation(context).which(operation2);
    return operation2;
  }

  // modules/ui/cmd.js
  var uiCmd = function(code) {
    var detected = utilDetect();
    if (detected.os === "mac") {
      return code;
    }
    if (detected.os === "win") {
      if (code === "\u2318\u21E7Z")
        return "Ctrl+Y";
    }
    var result = "", replacements = {
      "\u2318": "Ctrl",
      "\u21E7": "Shift",
      "\u2325": "Alt",
      "\u232B": "Backspace",
      "\u2326": "Delete"
    };
    for (var i3 = 0; i3 < code.length; i3++) {
      if (code[i3] in replacements) {
        result += replacements[code[i3]] + (i3 < code.length - 1 ? "+" : "");
      } else {
        result += code[i3];
      }
    }
    return result;
  };
  uiCmd.display = function(code) {
    if (code.length !== 1)
      return code;
    var detected = utilDetect();
    var mac = detected.os === "mac";
    var replacements = {
      "\u2318": mac ? "\u2318 " + _t("shortcuts.key.cmd") : _t("shortcuts.key.ctrl"),
      "\u21E7": mac ? "\u21E7 " + _t("shortcuts.key.shift") : _t("shortcuts.key.shift"),
      "\u2325": mac ? "\u2325 " + _t("shortcuts.key.option") : _t("shortcuts.key.alt"),
      "\u2303": mac ? "\u2303 " + _t("shortcuts.key.ctrl") : _t("shortcuts.key.ctrl"),
      "\u232B": mac ? "\u232B " + _t("shortcuts.key.delete") : _t("shortcuts.key.backspace"),
      "\u2326": mac ? "\u2326 " + _t("shortcuts.key.del") : _t("shortcuts.key.del"),
      "\u2196": mac ? "\u2196 " + _t("shortcuts.key.pgup") : _t("shortcuts.key.pgup"),
      "\u2198": mac ? "\u2198 " + _t("shortcuts.key.pgdn") : _t("shortcuts.key.pgdn"),
      "\u21DE": mac ? "\u21DE " + _t("shortcuts.key.home") : _t("shortcuts.key.home"),
      "\u21DF": mac ? "\u21DF " + _t("shortcuts.key.end") : _t("shortcuts.key.end"),
      "\u21B5": mac ? "\u23CE " + _t("shortcuts.key.return") : _t("shortcuts.key.enter"),
      "\u238B": mac ? "\u238B " + _t("shortcuts.key.esc") : _t("shortcuts.key.esc"),
      "\u2630": mac ? "\u2630 " + _t("shortcuts.key.menu") : _t("shortcuts.key.menu")
    };
    return replacements[code] || code;
  };

  // modules/operations/delete.js
  function operationDelete(context, selectedIDs) {
    var multi = selectedIDs.length === 1 ? "single" : "multiple";
    var action = actionDeleteMultiple(selectedIDs);
    var nodes = utilGetAllNodes(selectedIDs, context.graph());
    var coords = nodes.map(function(n3) {
      return n3.loc;
    });
    var extent = utilTotalExtent(selectedIDs, context.graph());
    var operation2 = function() {
      var nextSelectedID;
      var nextSelectedLoc;
      if (selectedIDs.length === 1) {
        var id2 = selectedIDs[0];
        var entity = context.entity(id2);
        var geometry = entity.geometry(context.graph());
        var parents = context.graph().parentWays(entity);
        var parent = parents[0];
        if (geometry === "vertex") {
          var nodes2 = parent.nodes;
          var i3 = nodes2.indexOf(id2);
          if (i3 === 0) {
            i3++;
          } else if (i3 === nodes2.length - 1) {
            i3--;
          } else {
            var a2 = geoSphericalDistance(entity.loc, context.entity(nodes2[i3 - 1]).loc);
            var b2 = geoSphericalDistance(entity.loc, context.entity(nodes2[i3 + 1]).loc);
            i3 = a2 < b2 ? i3 - 1 : i3 + 1;
          }
          nextSelectedID = nodes2[i3];
          nextSelectedLoc = context.entity(nextSelectedID).loc;
        }
      }
      context.perform(action, operation2.annotation());
      context.validator().validate();
      if (nextSelectedID && nextSelectedLoc) {
        if (context.hasEntity(nextSelectedID)) {
          context.enter(modeSelect(context, [nextSelectedID]).follow(true));
        } else {
          context.map().centerEase(nextSelectedLoc);
          context.enter(modeBrowse(context));
        }
      } else {
        context.enter(modeBrowse(context));
      }
    };
    operation2.available = function() {
      return true;
    };
    operation2.disabled = function() {
      if (extent.percentContainedIn(context.map().extent()) < 0.8) {
        return "too_large";
      } else if (someMissing()) {
        return "not_downloaded";
      } else if (selectedIDs.some(context.hasHiddenConnections)) {
        return "connected_to_hidden";
      } else if (selectedIDs.some(protectedMember)) {
        return "part_of_relation";
      } else if (selectedIDs.some(incompleteRelation)) {
        return "incomplete_relation";
      } else if (selectedIDs.some(hasWikidataTag)) {
        return "has_wikidata_tag";
      }
      return false;
      function someMissing() {
        if (context.inIntro())
          return false;
        var osm = context.connection();
        if (osm) {
          var missing = coords.filter(function(loc) {
            return !osm.isDataLoaded(loc);
          });
          if (missing.length) {
            missing.forEach(function(loc) {
              context.loadTileAtLoc(loc);
            });
            return true;
          }
        }
        return false;
      }
      function hasWikidataTag(id2) {
        var entity = context.entity(id2);
        return entity.tags.wikidata && entity.tags.wikidata.trim().length > 0;
      }
      function incompleteRelation(id2) {
        var entity = context.entity(id2);
        return entity.type === "relation" && !entity.isComplete(context.graph());
      }
      function protectedMember(id2) {
        var entity = context.entity(id2);
        if (entity.type !== "way")
          return false;
        var parents = context.graph().parentRelations(entity);
        for (var i3 = 0; i3 < parents.length; i3++) {
          var parent = parents[i3];
          var type2 = parent.tags.type;
          var role = parent.memberById(id2).role || "outer";
          if (type2 === "route" || type2 === "boundary" || type2 === "multipolygon" && role === "outer") {
            return true;
          }
        }
        return false;
      }
    };
    operation2.tooltip = function() {
      var disable = operation2.disabled();
      return disable ? _t.append("operations.delete." + disable + "." + multi) : _t.append("operations.delete.description." + multi);
    };
    operation2.annotation = function() {
      return selectedIDs.length === 1 ? _t("operations.delete.annotation." + context.graph().geometry(selectedIDs[0])) : _t("operations.delete.annotation.feature", { n: selectedIDs.length });
    };
    operation2.id = "delete";
    operation2.keys = [uiCmd("\u2318\u232B"), uiCmd("\u2318\u2326"), uiCmd("\u2326")];
    operation2.title = _t.append("operations.delete.title");
    operation2.behavior = behaviorOperation(context).which(operation2);
    return operation2;
  }

  // modules/operations/orthogonalize.js
  function operationOrthogonalize(context, selectedIDs) {
    var _extent;
    var _type;
    var _actions = selectedIDs.map(chooseAction).filter(Boolean);
    var _amount = _actions.length === 1 ? "single" : "multiple";
    var _coords = utilGetAllNodes(selectedIDs, context.graph()).map(function(n3) {
      return n3.loc;
    });
    function chooseAction(entityID) {
      var entity = context.entity(entityID);
      var geometry = entity.geometry(context.graph());
      if (!_extent) {
        _extent = entity.extent(context.graph());
      } else {
        _extent = _extent.extend(entity.extent(context.graph()));
      }
      if (entity.type === "way" && new Set(entity.nodes).size > 2) {
        if (_type && _type !== "feature")
          return null;
        _type = "feature";
        return actionOrthogonalize(entityID, context.projection);
      } else if (geometry === "vertex") {
        if (_type && _type !== "corner")
          return null;
        _type = "corner";
        var graph = context.graph();
        var parents = graph.parentWays(entity);
        if (parents.length === 1) {
          var way = parents[0];
          if (way.nodes.indexOf(entityID) !== -1) {
            return actionOrthogonalize(way.id, context.projection, entityID);
          }
        }
      }
      return null;
    }
    var operation2 = function() {
      if (!_actions.length)
        return;
      var combinedAction = function(graph, t2) {
        _actions.forEach(function(action) {
          if (!action.disabled(graph)) {
            graph = action(graph, t2);
          }
        });
        return graph;
      };
      combinedAction.transitionable = true;
      context.perform(combinedAction, operation2.annotation());
      window.setTimeout(function() {
        context.validator().validate();
      }, 300);
    };
    operation2.available = function() {
      return _actions.length && selectedIDs.length === _actions.length;
    };
    operation2.disabled = function() {
      if (!_actions.length)
        return "";
      var actionDisableds = _actions.map(function(action) {
        return action.disabled(context.graph());
      }).filter(Boolean);
      if (actionDisableds.length === _actions.length) {
        if (new Set(actionDisableds).size > 1) {
          return "multiple_blockers";
        }
        return actionDisableds[0];
      } else if (_extent && _extent.percentContainedIn(context.map().extent()) < 0.8) {
        return "too_large";
      } else if (someMissing()) {
        return "not_downloaded";
      } else if (selectedIDs.some(context.hasHiddenConnections)) {
        return "connected_to_hidden";
      }
      return false;
      function someMissing() {
        if (context.inIntro())
          return false;
        var osm = context.connection();
        if (osm) {
          var missing = _coords.filter(function(loc) {
            return !osm.isDataLoaded(loc);
          });
          if (missing.length) {
            missing.forEach(function(loc) {
              context.loadTileAtLoc(loc);
            });
            return true;
          }
        }
        return false;
      }
    };
    operation2.tooltip = function() {
      var disable = operation2.disabled();
      return disable ? _t.append("operations.orthogonalize." + disable + "." + _amount) : _t.append("operations.orthogonalize.description." + _type + "." + _amount);
    };
    operation2.annotation = function() {
      return _t("operations.orthogonalize.annotation." + _type, { n: _actions.length });
    };
    operation2.id = "orthogonalize";
    operation2.keys = [_t("operations.orthogonalize.key")];
    operation2.title = _t.append("operations.orthogonalize.title");
    operation2.behavior = behaviorOperation(context).which(operation2);
    return operation2;
  }

  // modules/operations/reflect.js
  function operationReflectShort(context, selectedIDs) {
    return operationReflect(context, selectedIDs, "short");
  }
  function operationReflectLong(context, selectedIDs) {
    return operationReflect(context, selectedIDs, "long");
  }
  function operationReflect(context, selectedIDs, axis) {
    axis = axis || "long";
    var multi = selectedIDs.length === 1 ? "single" : "multiple";
    var nodes = utilGetAllNodes(selectedIDs, context.graph());
    var coords = nodes.map(function(n3) {
      return n3.loc;
    });
    var extent = utilTotalExtent(selectedIDs, context.graph());
    var operation2 = function() {
      var action = actionReflect(selectedIDs, context.projection).useLongAxis(Boolean(axis === "long"));
      context.perform(action, operation2.annotation());
      window.setTimeout(function() {
        context.validator().validate();
      }, 300);
    };
    operation2.available = function() {
      return nodes.length >= 3;
    };
    operation2.disabled = function() {
      if (extent.percentContainedIn(context.map().extent()) < 0.8) {
        return "too_large";
      } else if (someMissing()) {
        return "not_downloaded";
      } else if (selectedIDs.some(context.hasHiddenConnections)) {
        return "connected_to_hidden";
      } else if (selectedIDs.some(incompleteRelation)) {
        return "incomplete_relation";
      }
      return false;
      function someMissing() {
        if (context.inIntro())
          return false;
        var osm = context.connection();
        if (osm) {
          var missing = coords.filter(function(loc) {
            return !osm.isDataLoaded(loc);
          });
          if (missing.length) {
            missing.forEach(function(loc) {
              context.loadTileAtLoc(loc);
            });
            return true;
          }
        }
        return false;
      }
      function incompleteRelation(id2) {
        var entity = context.entity(id2);
        return entity.type === "relation" && !entity.isComplete(context.graph());
      }
    };
    operation2.tooltip = function() {
      var disable = operation2.disabled();
      return disable ? _t.append("operations.reflect." + disable + "." + multi) : _t.append("operations.reflect.description." + axis + "." + multi);
    };
    operation2.annotation = function() {
      return _t("operations.reflect.annotation." + axis + ".feature", { n: selectedIDs.length });
    };
    operation2.id = "reflect-" + axis;
    operation2.keys = [_t("operations.reflect.key." + axis)];
    operation2.title = _t.append("operations.reflect.title." + axis);
    operation2.behavior = behaviorOperation(context).which(operation2);
    return operation2;
  }

  // modules/operations/move.js
  function operationMove(context, selectedIDs) {
    var multi = selectedIDs.length === 1 ? "single" : "multiple";
    var nodes = utilGetAllNodes(selectedIDs, context.graph());
    var coords = nodes.map(function(n3) {
      return n3.loc;
    });
    var extent = utilTotalExtent(selectedIDs, context.graph());
    var operation2 = function() {
      context.enter(modeMove(context, selectedIDs));
    };
    operation2.available = function() {
      return selectedIDs.length > 0;
    };
    operation2.disabled = function() {
      if (extent.percentContainedIn(context.map().extent()) < 0.8) {
        return "too_large";
      } else if (someMissing()) {
        return "not_downloaded";
      } else if (selectedIDs.some(context.hasHiddenConnections)) {
        return "connected_to_hidden";
      } else if (selectedIDs.some(incompleteRelation)) {
        return "incomplete_relation";
      }
      return false;
      function someMissing() {
        if (context.inIntro())
          return false;
        var osm = context.connection();
        if (osm) {
          var missing = coords.filter(function(loc) {
            return !osm.isDataLoaded(loc);
          });
          if (missing.length) {
            missing.forEach(function(loc) {
              context.loadTileAtLoc(loc);
            });
            return true;
          }
        }
        return false;
      }
      function incompleteRelation(id2) {
        var entity = context.entity(id2);
        return entity.type === "relation" && !entity.isComplete(context.graph());
      }
    };
    operation2.tooltip = function() {
      var disable = operation2.disabled();
      return disable ? _t.append("operations.move." + disable + "." + multi) : _t.append("operations.move.description." + multi);
    };
    operation2.annotation = function() {
      return selectedIDs.length === 1 ? _t("operations.move.annotation." + context.graph().geometry(selectedIDs[0])) : _t("operations.move.annotation.feature", { n: selectedIDs.length });
    };
    operation2.id = "move";
    operation2.keys = [_t("operations.move.key")];
    operation2.title = _t.append("operations.move.title");
    operation2.behavior = behaviorOperation(context).which(operation2);
    operation2.mouseOnly = true;
    return operation2;
  }

  // modules/modes/rotate.js
  function modeRotate(context, entityIDs) {
    var _tolerancePx = 4;
    var mode = {
      id: "rotate",
      button: "browse"
    };
    var keybinding = utilKeybinding("rotate");
    var behaviors = [
      behaviorEdit(context),
      operationCircularize(context, entityIDs).behavior,
      operationDelete(context, entityIDs).behavior,
      operationMove(context, entityIDs).behavior,
      operationOrthogonalize(context, entityIDs).behavior,
      operationReflectLong(context, entityIDs).behavior,
      operationReflectShort(context, entityIDs).behavior
    ];
    var annotation = entityIDs.length === 1 ? _t("operations.rotate.annotation." + context.graph().geometry(entityIDs[0])) : _t("operations.rotate.annotation.feature", { n: entityIDs.length });
    var _prevGraph;
    var _prevAngle;
    var _prevTransform;
    var _pivot;
    var _pointerPrefix = "PointerEvent" in window ? "pointer" : "mouse";
    function doRotate(d3_event) {
      var fn;
      if (context.graph() !== _prevGraph) {
        fn = context.perform;
      } else {
        fn = context.replace;
      }
      var projection2 = context.projection;
      var currTransform = projection2.transform();
      if (!_prevTransform || currTransform.k !== _prevTransform.k || currTransform.x !== _prevTransform.x || currTransform.y !== _prevTransform.y) {
        var nodes = utilGetAllNodes(entityIDs, context.graph());
        var points = nodes.map(function(n3) {
          return projection2(n3.loc);
        });
        _pivot = getPivot(points);
        _prevAngle = void 0;
      }
      var currMouse = context.map().mouse(d3_event);
      var currAngle = Math.atan2(currMouse[1] - _pivot[1], currMouse[0] - _pivot[0]);
      if (typeof _prevAngle === "undefined")
        _prevAngle = currAngle;
      var delta = currAngle - _prevAngle;
      fn(actionRotate(entityIDs, _pivot, delta, projection2));
      _prevTransform = currTransform;
      _prevAngle = currAngle;
      _prevGraph = context.graph();
    }
    function getPivot(points) {
      var _pivot2;
      if (points.length === 1) {
        _pivot2 = points[0];
      } else if (points.length === 2) {
        _pivot2 = geoVecInterp(points[0], points[1], 0.5);
      } else {
        var polygonHull = hull_default(points);
        if (polygonHull.length === 2) {
          _pivot2 = geoVecInterp(points[0], points[1], 0.5);
        } else {
          _pivot2 = centroid_default2(hull_default(points));
        }
      }
      return _pivot2;
    }
    function finish(d3_event) {
      d3_event.stopPropagation();
      context.replace(actionNoop(), annotation);
      context.enter(modeSelect(context, entityIDs));
    }
    function cancel() {
      if (_prevGraph)
        context.pop();
      context.enter(modeSelect(context, entityIDs));
    }
    function undone() {
      context.enter(modeBrowse(context));
    }
    mode.enter = function() {
      _prevGraph = null;
      context.features().forceVisible(entityIDs);
      behaviors.forEach(context.install);
      var downEvent;
      context.surface().on(_pointerPrefix + "down.modeRotate", function(d3_event) {
        downEvent = d3_event;
      });
      select_default2(window).on(_pointerPrefix + "move.modeRotate", doRotate, true).on(_pointerPrefix + "up.modeRotate", function(d3_event) {
        if (!downEvent)
          return;
        var mapNode = context.container().select(".main-map").node();
        var pointGetter = utilFastMouse(mapNode);
        var p1 = pointGetter(downEvent);
        var p2 = pointGetter(d3_event);
        var dist = geoVecLength(p1, p2);
        if (dist <= _tolerancePx)
          finish(d3_event);
        downEvent = null;
      }, true);
      context.history().on("undone.modeRotate", undone);
      keybinding.on("\u238B", cancel).on("\u21A9", finish);
      select_default2(document).call(keybinding);
    };
    mode.exit = function() {
      behaviors.forEach(context.uninstall);
      context.surface().on(_pointerPrefix + "down.modeRotate", null);
      select_default2(window).on(_pointerPrefix + "move.modeRotate", null, true).on(_pointerPrefix + "up.modeRotate", null, true);
      context.history().on("undone.modeRotate", null);
      select_default2(document).call(keybinding.unbind);
      context.features().forceVisible([]);
    };
    mode.selectedIDs = function() {
      if (!arguments.length)
        return entityIDs;
      return mode;
    };
    return mode;
  }

  // modules/operations/rotate.js
  function operationRotate(context, selectedIDs) {
    var multi = selectedIDs.length === 1 ? "single" : "multiple";
    var nodes = utilGetAllNodes(selectedIDs, context.graph());
    var coords = nodes.map(function(n3) {
      return n3.loc;
    });
    var extent = utilTotalExtent(selectedIDs, context.graph());
    var operation2 = function() {
      context.enter(modeRotate(context, selectedIDs));
    };
    operation2.available = function() {
      return nodes.length >= 2;
    };
    operation2.disabled = function() {
      if (extent.percentContainedIn(context.map().extent()) < 0.8) {
        return "too_large";
      } else if (someMissing()) {
        return "not_downloaded";
      } else if (selectedIDs.some(context.hasHiddenConnections)) {
        return "connected_to_hidden";
      } else if (selectedIDs.some(incompleteRelation)) {
        return "incomplete_relation";
      }
      return false;
      function someMissing() {
        if (context.inIntro())
          return false;
        var osm = context.connection();
        if (osm) {
          var missing = coords.filter(function(loc) {
            return !osm.isDataLoaded(loc);
          });
          if (missing.length) {
            missing.forEach(function(loc) {
              context.loadTileAtLoc(loc);
            });
            return true;
          }
        }
        return false;
      }
      function incompleteRelation(id2) {
        var entity = context.entity(id2);
        return entity.type === "relation" && !entity.isComplete(context.graph());
      }
    };
    operation2.tooltip = function() {
      var disable = operation2.disabled();
      return disable ? _t.append("operations.rotate." + disable + "." + multi) : _t.append("operations.rotate.description." + multi);
    };
    operation2.annotation = function() {
      return selectedIDs.length === 1 ? _t("operations.rotate.annotation." + context.graph().geometry(selectedIDs[0])) : _t("operations.rotate.annotation.feature", { n: selectedIDs.length });
    };
    operation2.id = "rotate";
    operation2.keys = [_t("operations.rotate.key")];
    operation2.title = _t.append("operations.rotate.title");
    operation2.behavior = behaviorOperation(context).which(operation2);
    operation2.mouseOnly = true;
    return operation2;
  }

  // modules/modes/move.js
  function modeMove(context, entityIDs, baseGraph) {
    var _tolerancePx = 4;
    var mode = {
      id: "move",
      button: "browse"
    };
    var keybinding = utilKeybinding("move");
    var behaviors = [
      behaviorEdit(context),
      operationCircularize(context, entityIDs).behavior,
      operationDelete(context, entityIDs).behavior,
      operationOrthogonalize(context, entityIDs).behavior,
      operationReflectLong(context, entityIDs).behavior,
      operationReflectShort(context, entityIDs).behavior,
      operationRotate(context, entityIDs).behavior
    ];
    var annotation = entityIDs.length === 1 ? _t("operations.move.annotation." + context.graph().geometry(entityIDs[0])) : _t("operations.move.annotation.feature", { n: entityIDs.length });
    var _prevGraph;
    var _cache5;
    var _origin;
    var _nudgeInterval;
    var _pointerPrefix = "PointerEvent" in window ? "pointer" : "mouse";
    function doMove(nudge) {
      nudge = nudge || [0, 0];
      var fn;
      if (_prevGraph !== context.graph()) {
        _cache5 = {};
        _origin = context.map().mouseCoordinates();
        fn = context.perform;
      } else {
        fn = context.overwrite;
      }
      var currMouse = context.map().mouse();
      var origMouse = context.projection(_origin);
      var delta = geoVecSubtract(geoVecSubtract(currMouse, origMouse), nudge);
      fn(actionMove(entityIDs, delta, context.projection, _cache5));
      _prevGraph = context.graph();
    }
    function startNudge(nudge) {
      if (_nudgeInterval)
        window.clearInterval(_nudgeInterval);
      _nudgeInterval = window.setInterval(function() {
        context.map().pan(nudge);
        doMove(nudge);
      }, 50);
    }
    function stopNudge() {
      if (_nudgeInterval) {
        window.clearInterval(_nudgeInterval);
        _nudgeInterval = null;
      }
    }
    function move() {
      doMove();
      var nudge = geoViewportEdge(context.map().mouse(), context.map().dimensions());
      if (nudge) {
        startNudge(nudge);
      } else {
        stopNudge();
      }
    }
    function finish(d3_event) {
      d3_event.stopPropagation();
      context.replace(actionNoop(), annotation);
      context.enter(modeSelect(context, entityIDs));
      stopNudge();
    }
    function cancel() {
      if (baseGraph) {
        while (context.graph() !== baseGraph)
          context.pop();
        context.enter(modeBrowse(context));
      } else {
        if (_prevGraph)
          context.pop();
        context.enter(modeSelect(context, entityIDs));
      }
      stopNudge();
    }
    function undone() {
      context.enter(modeBrowse(context));
    }
    mode.enter = function() {
      _origin = context.map().mouseCoordinates();
      _prevGraph = null;
      _cache5 = {};
      context.features().forceVisible(entityIDs);
      behaviors.forEach(context.install);
      var downEvent;
      context.surface().on(_pointerPrefix + "down.modeMove", function(d3_event) {
        downEvent = d3_event;
      });
      select_default2(window).on(_pointerPrefix + "move.modeMove", move, true).on(_pointerPrefix + "up.modeMove", function(d3_event) {
        if (!downEvent)
          return;
        var mapNode = context.container().select(".main-map").node();
        var pointGetter = utilFastMouse(mapNode);
        var p1 = pointGetter(downEvent);
        var p2 = pointGetter(d3_event);
        var dist = geoVecLength(p1, p2);
        if (dist <= _tolerancePx)
          finish(d3_event);
        downEvent = null;
      }, true);
      context.history().on("undone.modeMove", undone);
      keybinding.on("\u238B", cancel).on("\u21A9", finish);
      select_default2(document).call(keybinding);
    };
    mode.exit = function() {
      stopNudge();
      behaviors.forEach(function(behavior) {
        context.uninstall(behavior);
      });
      context.surface().on(_pointerPrefix + "down.modeMove", null);
      select_default2(window).on(_pointerPrefix + "move.modeMove", null, true).on(_pointerPrefix + "up.modeMove", null, true);
      context.history().on("undone.modeMove", null);
      select_default2(document).call(keybinding.unbind);
      context.features().forceVisible([]);
    };
    mode.selectedIDs = function() {
      if (!arguments.length)
        return entityIDs;
      return mode;
    };
    return mode;
  }

  // modules/behavior/paste.js
  function behaviorPaste(context) {
    function doPaste(d3_event) {
      if (!context.map().withinEditableZoom())
        return;
      d3_event.preventDefault();
      var baseGraph = context.graph();
      var mouse = context.map().mouse();
      var projection2 = context.projection;
      var viewport = geoExtent(projection2.clipExtent()).polygon();
      if (!geoPointInPolygon(mouse, viewport))
        return;
      var oldIDs = context.copyIDs();
      if (!oldIDs.length)
        return;
      var extent = geoExtent();
      var oldGraph = context.copyGraph();
      var newIDs = [];
      var action = actionCopyEntities(oldIDs, oldGraph);
      context.perform(action);
      var copies = action.copies();
      var originals = /* @__PURE__ */ new Set();
      Object.values(copies).forEach(function(entity) {
        originals.add(entity.id);
      });
      for (var id2 in copies) {
        var oldEntity = oldGraph.entity(id2);
        var newEntity = copies[id2];
        extent._extend(oldEntity.extent(oldGraph));
        var parents = context.graph().parentWays(newEntity);
        var parentCopied = parents.some(function(parent) {
          return originals.has(parent.id);
        });
        if (!parentCopied) {
          newIDs.push(newEntity.id);
        }
      }
      var copyPoint = context.copyLonLat() && projection2(context.copyLonLat()) || projection2(extent.center());
      var delta = geoVecSubtract(mouse, copyPoint);
      context.perform(actionMove(newIDs, delta, projection2));
      context.enter(modeMove(context, newIDs, baseGraph));
    }
    function behavior() {
      context.keybinding().on(uiCmd("\u2318V"), doPaste);
      return behavior;
    }
    behavior.off = function() {
      context.keybinding().off(uiCmd("\u2318V"));
    };
    return behavior;
  }

  // modules/behavior/drag.js
  function behaviorDrag() {
    var dispatch14 = dispatch_default("start", "move", "end");
    var _tolerancePx = 1;
    var _penTolerancePx = 4;
    var _origin = null;
    var _selector = "";
    var _targetNode;
    var _targetEntity;
    var _surface;
    var _pointerId;
    var _pointerPrefix = "PointerEvent" in window ? "pointer" : "mouse";
    var d3_event_userSelectProperty = utilPrefixCSSProperty("UserSelect");
    var d3_event_userSelectSuppress = function() {
      var selection2 = selection_default();
      var select = selection2.style(d3_event_userSelectProperty);
      selection2.style(d3_event_userSelectProperty, "none");
      return function() {
        selection2.style(d3_event_userSelectProperty, select);
      };
    };
    function pointerdown(d3_event) {
      if (_pointerId)
        return;
      _pointerId = d3_event.pointerId || "mouse";
      _targetNode = this;
      var pointerLocGetter = utilFastMouse(_surface || _targetNode.parentNode);
      var offset;
      var startOrigin = pointerLocGetter(d3_event);
      var started = false;
      var selectEnable = d3_event_userSelectSuppress();
      select_default2(window).on(_pointerPrefix + "move.drag", pointermove).on(_pointerPrefix + "up.drag pointercancel.drag", pointerup, true);
      if (_origin) {
        offset = _origin.call(_targetNode, _targetEntity);
        offset = [offset[0] - startOrigin[0], offset[1] - startOrigin[1]];
      } else {
        offset = [0, 0];
      }
      d3_event.stopPropagation();
      function pointermove(d3_event2) {
        if (_pointerId !== (d3_event2.pointerId || "mouse"))
          return;
        var p2 = pointerLocGetter(d3_event2);
        if (!started) {
          var dist = geoVecLength(startOrigin, p2);
          var tolerance = d3_event2.pointerType === "pen" ? _penTolerancePx : _tolerancePx;
          if (dist < tolerance)
            return;
          started = true;
          dispatch14.call("start", this, d3_event2, _targetEntity);
        } else {
          startOrigin = p2;
          d3_event2.stopPropagation();
          d3_event2.preventDefault();
          var dx = p2[0] - startOrigin[0];
          var dy = p2[1] - startOrigin[1];
          dispatch14.call("move", this, d3_event2, _targetEntity, [p2[0] + offset[0], p2[1] + offset[1]], [dx, dy]);
        }
      }
      function pointerup(d3_event2) {
        if (_pointerId !== (d3_event2.pointerId || "mouse"))
          return;
        _pointerId = null;
        if (started) {
          dispatch14.call("end", this, d3_event2, _targetEntity);
          d3_event2.preventDefault();
        }
        select_default2(window).on(_pointerPrefix + "move.drag", null).on(_pointerPrefix + "up.drag pointercancel.drag", null);
        selectEnable();
      }
    }
    function behavior(selection2) {
      var matchesSelector = utilPrefixDOMProperty("matchesSelector");
      var delegate = pointerdown;
      if (_selector) {
        delegate = function(d3_event) {
          var root3 = this;
          var target = d3_event.target;
          for (; target && target !== root3; target = target.parentNode) {
            var datum2 = target.__data__;
            _targetEntity = datum2 instanceof osmNote ? datum2 : datum2 && datum2.properties && datum2.properties.entity;
            if (_targetEntity && target[matchesSelector](_selector)) {
              return pointerdown.call(target, d3_event);
            }
          }
        };
      }
      selection2.on(_pointerPrefix + "down.drag" + _selector, delegate);
    }
    behavior.off = function(selection2) {
      selection2.on(_pointerPrefix + "down.drag" + _selector, null);
    };
    behavior.selector = function(_2) {
      if (!arguments.length)
        return _selector;
      _selector = _2;
      return behavior;
    };
    behavior.origin = function(_2) {
      if (!arguments.length)
        return _origin;
      _origin = _2;
      return behavior;
    };
    behavior.cancel = function() {
      select_default2(window).on(_pointerPrefix + "move.drag", null).on(_pointerPrefix + "up.drag pointercancel.drag", null);
      return behavior;
    };
    behavior.targetNode = function(_2) {
      if (!arguments.length)
        return _targetNode;
      _targetNode = _2;
      return behavior;
    };
    behavior.targetEntity = function(_2) {
      if (!arguments.length)
        return _targetEntity;
      _targetEntity = _2;
      return behavior;
    };
    behavior.surface = function(_2) {
      if (!arguments.length)
        return _surface;
      _surface = _2;
      return behavior;
    };
    return utilRebind(behavior, dispatch14, "on");
  }

  // modules/modes/drag_node.js
  function modeDragNode(context) {
    var mode = {
      id: "drag-node",
      button: "browse"
    };
    var hover = behaviorHover(context).altDisables(true).on("hover", context.ui().sidebar.hover);
    var edit2 = behaviorEdit(context);
    var _nudgeInterval;
    var _restoreSelectedIDs = [];
    var _wasMidpoint = false;
    var _isCancelled = false;
    var _activeEntity;
    var _startLoc;
    var _lastLoc;
    function startNudge(d3_event, entity, nudge) {
      if (_nudgeInterval)
        window.clearInterval(_nudgeInterval);
      _nudgeInterval = window.setInterval(function() {
        context.map().pan(nudge);
        doMove(d3_event, entity, nudge);
      }, 50);
    }
    function stopNudge() {
      if (_nudgeInterval) {
        window.clearInterval(_nudgeInterval);
        _nudgeInterval = null;
      }
    }
    function moveAnnotation(entity) {
      return _t("operations.move.annotation." + entity.geometry(context.graph()));
    }
    function connectAnnotation(nodeEntity, targetEntity) {
      var nodeGeometry = nodeEntity.geometry(context.graph());
      var targetGeometry = targetEntity.geometry(context.graph());
      if (nodeGeometry === "vertex" && targetGeometry === "vertex") {
        var nodeParentWayIDs = context.graph().parentWays(nodeEntity);
        var targetParentWayIDs = context.graph().parentWays(targetEntity);
        var sharedParentWays = utilArrayIntersection(nodeParentWayIDs, targetParentWayIDs);
        if (sharedParentWays.length !== 0) {
          if (sharedParentWays[0].areAdjacent(nodeEntity.id, targetEntity.id)) {
            return _t("operations.connect.annotation.from_vertex.to_adjacent_vertex");
          }
          return _t("operations.connect.annotation.from_vertex.to_sibling_vertex");
        }
      }
      return _t("operations.connect.annotation.from_" + nodeGeometry + ".to_" + targetGeometry);
    }
    function shouldSnapToNode(target) {
      if (!_activeEntity)
        return false;
      return _activeEntity.geometry(context.graph()) !== "vertex" || (target.geometry(context.graph()) === "vertex" || _mainPresetIndex.allowsVertex(target, context.graph()));
    }
    function origin(entity) {
      return context.projection(entity.loc);
    }
    function keydown(d3_event) {
      if (d3_event.keyCode === utilKeybinding.modifierCodes.alt) {
        if (context.surface().classed("nope")) {
          context.surface().classed("nope-suppressed", true);
        }
        context.surface().classed("nope", false).classed("nope-disabled", true);
      }
    }
    function keyup(d3_event) {
      if (d3_event.keyCode === utilKeybinding.modifierCodes.alt) {
        if (context.surface().classed("nope-suppressed")) {
          context.surface().classed("nope", true);
        }
        context.surface().classed("nope-suppressed", false).classed("nope-disabled", false);
      }
    }
    function start2(d3_event, entity) {
      _wasMidpoint = entity.type === "midpoint";
      var hasHidden = context.features().hasHiddenConnections(entity, context.graph());
      _isCancelled = !context.editable() || d3_event.shiftKey || hasHidden;
      if (_isCancelled) {
        if (hasHidden) {
          context.ui().flash.duration(4e3).iconName("#iD-icon-no").label(_t.append("modes.drag_node.connected_to_hidden"))();
        }
        return drag.cancel();
      }
      if (_wasMidpoint) {
        var midpoint = entity;
        entity = osmNode();
        context.perform(actionAddMidpoint(midpoint, entity));
        entity = context.entity(entity.id);
        var vertex = context.surface().selectAll("." + entity.id);
        drag.targetNode(vertex.node()).targetEntity(entity);
      } else {
        context.perform(actionNoop());
      }
      _activeEntity = entity;
      _startLoc = entity.loc;
      hover.ignoreVertex(entity.geometry(context.graph()) === "vertex");
      context.surface().selectAll("." + _activeEntity.id).classed("active", true);
      context.enter(mode);
    }
    function datum2(d3_event) {
      if (!d3_event || d3_event.altKey) {
        return {};
      } else {
        var d2 = d3_event.target.__data__;
        return d2 && d2.properties && d2.properties.target ? d2 : {};
      }
    }
    function doMove(d3_event, entity, nudge) {
      nudge = nudge || [0, 0];
      var currPoint = d3_event && d3_event.point || context.projection(_lastLoc);
      var currMouse = geoVecSubtract(currPoint, nudge);
      var loc = context.projection.invert(currMouse);
      var target, edge;
      if (!_nudgeInterval) {
        var d2 = datum2(d3_event);
        target = d2 && d2.properties && d2.properties.entity;
        var targetLoc = target && target.loc;
        var targetNodes = d2 && d2.properties && d2.properties.nodes;
        if (targetLoc) {
          if (shouldSnapToNode(target)) {
            loc = targetLoc;
          }
        } else if (targetNodes) {
          edge = geoChooseEdge(targetNodes, context.map().mouse(), context.projection, end.id);
          if (edge) {
            loc = edge.loc;
          }
        }
      }
      context.replace(
        actionMoveNode(entity.id, loc)
      );
      var isInvalid = false;
      if (target) {
        isInvalid = hasRelationConflict(entity, target, edge, context.graph());
      }
      if (!isInvalid) {
        isInvalid = hasInvalidGeometry(entity, context.graph());
      }
      var nope = context.surface().classed("nope");
      if (isInvalid === "relation" || isInvalid === "restriction") {
        if (!nope) {
          context.ui().flash.duration(4e3).iconName("#iD-icon-no").label(_t.append(
            "operations.connect." + isInvalid,
            { relation: _mainPresetIndex.item("type/restriction").name() }
          ))();
        }
      } else if (isInvalid) {
        var errorID = isInvalid === "line" ? "lines" : "areas";
        context.ui().flash.duration(3e3).iconName("#iD-icon-no").label(_t.append("self_intersection.error." + errorID))();
      } else {
        if (nope) {
          context.ui().flash.duration(1).label("")();
        }
      }
      var nopeDisabled = context.surface().classed("nope-disabled");
      if (nopeDisabled) {
        context.surface().classed("nope", false).classed("nope-suppressed", isInvalid);
      } else {
        context.surface().classed("nope", isInvalid).classed("nope-suppressed", false);
      }
      _lastLoc = loc;
    }
    function hasRelationConflict(entity, target, edge, graph) {
      var testGraph = graph.update();
      if (edge) {
        var midpoint = osmNode();
        var action = actionAddMidpoint({
          loc: edge.loc,
          edge: [target.nodes[edge.index - 1], target.nodes[edge.index]]
        }, midpoint);
        testGraph = action(testGraph);
        target = midpoint;
      }
      var ids = [entity.id, target.id];
      return actionConnect(ids).disabled(testGraph);
    }
    function hasInvalidGeometry(entity, graph) {
      var parents = graph.parentWays(entity);
      var i3, j2, k2;
      for (i3 = 0; i3 < parents.length; i3++) {
        var parent = parents[i3];
        var nodes = [];
        var activeIndex = null;
        var relations = graph.parentRelations(parent);
        for (j2 = 0; j2 < relations.length; j2++) {
          if (!relations[j2].isMultipolygon())
            continue;
          var rings = osmJoinWays(relations[j2].members, graph);
          for (k2 = 0; k2 < rings.length; k2++) {
            nodes = rings[k2].nodes;
            if (nodes.find(function(n3) {
              return n3.id === entity.id;
            })) {
              activeIndex = k2;
              if (geoHasSelfIntersections(nodes, entity.id)) {
                return "multipolygonMember";
              }
            }
            rings[k2].coords = nodes.map(function(n3) {
              return n3.loc;
            });
          }
          for (k2 = 0; k2 < rings.length; k2++) {
            if (k2 === activeIndex)
              continue;
            if (geoHasLineIntersections(rings[activeIndex].nodes, rings[k2].nodes, entity.id)) {
              return "multipolygonRing";
            }
          }
        }
        if (activeIndex === null) {
          nodes = parent.nodes.map(function(nodeID) {
            return graph.entity(nodeID);
          });
          if (nodes.length && geoHasSelfIntersections(nodes, entity.id)) {
            return parent.geometry(graph);
          }
        }
      }
      return false;
    }
    function move(d3_event, entity, point2) {
      if (_isCancelled)
        return;
      d3_event.stopPropagation();
      context.surface().classed("nope-disabled", d3_event.altKey);
      _lastLoc = context.projection.invert(point2);
      doMove(d3_event, entity);
      var nudge = geoViewportEdge(point2, context.map().dimensions());
      if (nudge) {
        startNudge(d3_event, entity, nudge);
      } else {
        stopNudge();
      }
    }
    function end(d3_event, entity) {
      if (_isCancelled)
        return;
      var wasPoint = entity.geometry(context.graph()) === "point";
      var d2 = datum2(d3_event);
      var nope = d2 && d2.properties && d2.properties.nope || context.surface().classed("nope");
      var target = d2 && d2.properties && d2.properties.entity;
      if (nope) {
        context.perform(
          _actionBounceBack(entity.id, _startLoc)
        );
      } else if (target && target.type === "way") {
        var choice = geoChooseEdge(context.graph().childNodes(target), context.map().mouse(), context.projection, entity.id);
        context.replace(
          actionAddMidpoint({
            loc: choice.loc,
            edge: [target.nodes[choice.index - 1], target.nodes[choice.index]]
          }, entity),
          connectAnnotation(entity, target)
        );
      } else if (target && target.type === "node" && shouldSnapToNode(target)) {
        context.replace(
          actionConnect([target.id, entity.id]),
          connectAnnotation(entity, target)
        );
      } else if (_wasMidpoint) {
        context.replace(
          actionNoop(),
          _t("operations.add.annotation.vertex")
        );
      } else {
        context.replace(
          actionNoop(),
          moveAnnotation(entity)
        );
      }
      if (wasPoint) {
        context.enter(modeSelect(context, [entity.id]));
      } else {
        var reselection = _restoreSelectedIDs.filter(function(id2) {
          return context.graph().hasEntity(id2);
        });
        if (reselection.length) {
          context.enter(modeSelect(context, reselection));
        } else {
          context.enter(modeBrowse(context));
        }
      }
    }
    function _actionBounceBack(nodeID, toLoc) {
      var moveNode = actionMoveNode(nodeID, toLoc);
      var action = function(graph, t2) {
        if (t2 === 1)
          context.pop();
        return moveNode(graph, t2);
      };
      action.transitionable = true;
      return action;
    }
    function cancel() {
      drag.cancel();
      context.enter(modeBrowse(context));
    }
    var drag = behaviorDrag().selector(".layer-touch.points .target").surface(context.container().select(".main-map").node()).origin(origin).on("start", start2).on("move", move).on("end", end);
    mode.enter = function() {
      context.install(hover);
      context.install(edit2);
      select_default2(window).on("keydown.dragNode", keydown).on("keyup.dragNode", keyup);
      context.history().on("undone.drag-node", cancel);
    };
    mode.exit = function() {
      context.ui().sidebar.hover.cancel();
      context.uninstall(hover);
      context.uninstall(edit2);
      select_default2(window).on("keydown.dragNode", null).on("keyup.dragNode", null);
      context.history().on("undone.drag-node", null);
      _activeEntity = null;
      context.surface().classed("nope", false).classed("nope-suppressed", false).classed("nope-disabled", false).selectAll(".active").classed("active", false);
      stopNudge();
    };
    mode.selectedIDs = function() {
      if (!arguments.length)
        return _activeEntity ? [_activeEntity.id] : [];
      return mode;
    };
    mode.activeID = function() {
      if (!arguments.length)
        return _activeEntity && _activeEntity.id;
      return mode;
    };
    mode.restoreSelectedIDs = function(_2) {
      if (!arguments.length)
        return _restoreSelectedIDs;
      _restoreSelectedIDs = _2;
      return mode;
    };
    mode.behavior = drag;
    return mode;
  }

  // modules/services/keepRight.js
  var import_rbush = __toESM(require_rbush_min());

  // node_modules/d3-fetch/src/text.js
  function responseText(response) {
    if (!response.ok)
      throw new Error(response.status + " " + response.statusText);
    return response.text();
  }
  function text_default3(input, init2) {
    return fetch(input, init2).then(responseText);
  }

  // node_modules/d3-fetch/src/json.js
  function responseJson(response) {
    if (!response.ok)
      throw new Error(response.status + " " + response.statusText);
    if (response.status === 204 || response.status === 205)
      return;
    return response.json();
  }
  function json_default(input, init2) {
    return fetch(input, init2).then(responseJson);
  }

  // node_modules/d3-fetch/src/xml.js
  function parser(type2) {
    return (input, init2) => text_default3(input, init2).then((text) => new DOMParser().parseFromString(text, type2));
  }
  var xml_default = parser("application/xml");
  var html = parser("text/html");
  var svg = parser("image/svg+xml");

  // modules/services/keepRight.js
  var tiler = utilTiler();
  var dispatch2 = dispatch_default("loaded");
  var _tileZoom = 14;
  var _krUrlRoot = "https://www.keepright.at";
  var _krData = { errorTypes: {}, localizeStrings: {} };
  var _cache;
  var _krRuleset = [
    // no 20 - multiple node on same spot - these are mostly boundaries overlapping roads
    30,
    40,
    50,
    60,
    70,
    90,
    100,
    110,
    120,
    130,
    150,
    160,
    170,
    180,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    210,
    220,
    230,
    231,
    232,
    270,
    280,
    281,
    282,
    283,
    284,
    285,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    300,
    310,
    311,
    312,
    313,
    320,
    350,
    360,
    370,
    380,
    390,
    400,
    401,
    402,
    410,
    411,
    412,
    413
  ];
  function abortRequest(controller) {
    if (controller) {
      controller.abort();
    }
  }
  function abortUnwantedRequests(cache, tiles) {
    Object.keys(cache.inflightTile).forEach((k2) => {
      const wanted = tiles.find((tile) => k2 === tile.id);
      if (!wanted) {
        abortRequest(cache.inflightTile[k2]);
        delete cache.inflightTile[k2];
      }
    });
  }
  function encodeIssueRtree(d2) {
    return { minX: d2.loc[0], minY: d2.loc[1], maxX: d2.loc[0], maxY: d2.loc[1], data: d2 };
  }
  function updateRtree(item, replace) {
    _cache.rtree.remove(item, (a2, b2) => a2.data.id === b2.data.id);
    if (replace) {
      _cache.rtree.insert(item);
    }
  }
  function tokenReplacements(d2) {
    if (!(d2 instanceof QAItem))
      return;
    const replacements = {};
    const issueTemplate = _krData.errorTypes[d2.whichType];
    if (!issueTemplate) {
      console.log("No Template: ", d2.whichType);
      console.log("  ", d2.description);
      return;
    }
    if (!issueTemplate.regex)
      return;
    const errorRegex = new RegExp(issueTemplate.regex, "i");
    const errorMatch = errorRegex.exec(d2.description);
    if (!errorMatch) {
      console.log("Unmatched: ", d2.whichType);
      console.log("  ", d2.description);
      console.log("  ", errorRegex);
      return;
    }
    for (let i3 = 1; i3 < errorMatch.length; i3++) {
      let capture = errorMatch[i3];
      let idType;
      idType = "IDs" in issueTemplate ? issueTemplate.IDs[i3 - 1] : "";
      if (idType && capture) {
        capture = parseError(capture, idType);
      } else {
        const compare2 = capture.toLowerCase();
        if (_krData.localizeStrings[compare2]) {
          capture = _t("QA.keepRight.error_parts." + _krData.localizeStrings[compare2]);
        } else {
          capture = unescape_default(capture);
        }
      }
      replacements["var" + i3] = capture;
    }
    return replacements;
  }
  function parseError(capture, idType) {
    const compare2 = capture.toLowerCase();
    if (_krData.localizeStrings[compare2]) {
      capture = _t("QA.keepRight.error_parts." + _krData.localizeStrings[compare2]);
    }
    switch (idType) {
      case "this":
        capture = linkErrorObject2(capture);
        break;
      case "url":
        capture = linkURL(capture);
        break;
      case "n":
      case "w":
      case "r":
        capture = linkEntity2(idType + capture);
        break;
      case "20":
        capture = parse20(capture);
        break;
      case "211":
        capture = parse211(capture);
        break;
      case "231":
        capture = parse231(capture);
        break;
      case "294":
        capture = parse294(capture);
        break;
      case "370":
        capture = parse370(capture);
        break;
    }
    return capture;
    function linkErrorObject2(d2) {
      return { html: '<a class="error_object_link">'.concat(d2, "</a>") };
    }
    function linkEntity2(d2) {
      return { html: '<a class="error_entity_link">'.concat(d2, "</a>") };
    }
    function linkURL(d2) {
      return { html: '<a class="kr_external_link" target="_blank" href="'.concat(d2, '">').concat(d2, "</a>") };
    }
    function parse211(capture2) {
      let newList = [];
      const items = capture2.split(", ");
      items.forEach((item) => {
        let id2 = linkEntity2("n" + item.slice(1));
        newList.push(id2);
      });
      return newList.join(", ");
    }
    function parse231(capture2) {
      let newList = [];
      const items = capture2.split("),");
      items.forEach((item) => {
        const match = item.match(/\#(\d+)\((.+)\)?/);
        if (match !== null && match.length > 2) {
          newList.push(
            linkEntity2("w" + match[1]) + " " + _t("QA.keepRight.errorTypes.231.layer", { layer: match[2] })
          );
        }
      });
      return newList.join(", ");
    }
    function parse294(capture2) {
      let newList = [];
      const items = capture2.split(",");
      items.forEach((item) => {
        item = item.split(" ");
        const role = '"'.concat(item[0], '"');
        const idType2 = item[1].slice(0, 1);
        let id2 = item[2].slice(1);
        id2 = linkEntity2(idType2 + id2);
        newList.push("".concat(role, " ").concat(item[1], " ").concat(id2));
      });
      return newList.join(", ");
    }
    function parse370(capture2) {
      if (!capture2)
        return "";
      const match = capture2.match(/\(including the name (\'.+\')\)/);
      if (match && match.length) {
        return _t("QA.keepRight.errorTypes.370.including_the_name", { name: match[1] });
      }
      return "";
    }
    function parse20(capture2) {
      let newList = [];
      const items = capture2.split(",");
      items.forEach((item) => {
        const id2 = linkEntity2("n" + item.slice(1));
        newList.push(id2);
      });
      return newList.join(", ");
    }
  }
  var keepRight_default = {
    title: "keepRight",
    init() {
      _mainFileFetcher.get("keepRight").then((d2) => _krData = d2);
      if (!_cache) {
        this.reset();
      }
      this.event = utilRebind(this, dispatch2, "on");
    },
    reset() {
      if (_cache) {
        Object.values(_cache.inflightTile).forEach(abortRequest);
      }
      _cache = {
        data: {},
        loadedTile: {},
        inflightTile: {},
        inflightPost: {},
        closed: {},
        rtree: new import_rbush.default()
      };
    },
    // KeepRight API:  http://osm.mueschelsoft.de/keepright/interfacing.php
    loadIssues(projection2) {
      const options2 = {
        format: "geojson",
        ch: _krRuleset
      };
      const tiles = tiler.zoomExtent([_tileZoom, _tileZoom]).getTiles(projection2);
      abortUnwantedRequests(_cache, tiles);
      tiles.forEach((tile) => {
        if (_cache.loadedTile[tile.id] || _cache.inflightTile[tile.id])
          return;
        const [left, top, right, bottom] = tile.extent.rectangle();
        const params = Object.assign({}, options2, { left, bottom, right, top });
        const url = "".concat(_krUrlRoot, "/export.php?") + utilQsString(params);
        const controller = new AbortController();
        _cache.inflightTile[tile.id] = controller;
        json_default(url, { signal: controller.signal }).then((data) => {
          delete _cache.inflightTile[tile.id];
          _cache.loadedTile[tile.id] = true;
          if (!data || !data.features || !data.features.length) {
            throw new Error("No Data");
          }
          data.features.forEach((feature3) => {
            const {
              properties: {
                error_type: itemType,
                error_id: id2,
                comment = null,
                object_id: objectId,
                object_type: objectType,
                schema,
                title
              }
            } = feature3;
            let {
              geometry: { coordinates: loc },
              properties: { description = "" }
            } = feature3;
            const issueTemplate = _krData.errorTypes[itemType];
            const parentIssueType = (Math.floor(itemType / 10) * 10).toString();
            const whichType = issueTemplate ? itemType : parentIssueType;
            const whichTemplate = _krData.errorTypes[whichType];
            switch (whichType) {
              case "170":
                description = "This feature has a FIXME tag: ".concat(description);
                break;
              case "292":
              case "293":
                description = description.replace("A turn-", "This turn-");
                break;
              case "294":
              case "295":
              case "296":
              case "297":
              case "298":
                description = "This turn-restriction~".concat(description);
                break;
              case "300":
                description = "This highway is missing a maxspeed tag";
                break;
              case "411":
              case "412":
              case "413":
                description = "This feature~".concat(description);
                break;
            }
            let coincident = false;
            do {
              let delta = coincident ? [1e-5, 0] : [0, 1e-5];
              loc = geoVecAdd(loc, delta);
              let bbox2 = geoExtent(loc).bbox();
              coincident = _cache.rtree.search(bbox2).length;
            } while (coincident);
            let d2 = new QAItem(loc, this, itemType, id2, {
              comment,
              description,
              whichType,
              parentIssueType,
              severity: whichTemplate.severity || "error",
              objectId,
              objectType,
              schema,
              title
            });
            d2.replacements = tokenReplacements(d2);
            _cache.data[id2] = d2;
            _cache.rtree.insert(encodeIssueRtree(d2));
          });
          dispatch2.call("loaded");
        }).catch(() => {
          delete _cache.inflightTile[tile.id];
          _cache.loadedTile[tile.id] = true;
        });
      });
    },
    postUpdate(d2, callback) {
      if (_cache.inflightPost[d2.id]) {
        return callback({ message: "Error update already inflight", status: -2 }, d2);
      }
      const params = { schema: d2.schema, id: d2.id };
      if (d2.newStatus) {
        params.st = d2.newStatus;
      }
      if (d2.newComment !== void 0) {
        params.co = d2.newComment;
      }
      const url = "".concat(_krUrlRoot, "/comment.php?") + utilQsString(params);
      const controller = new AbortController();
      _cache.inflightPost[d2.id] = controller;
      json_default(url, { signal: controller.signal }).finally(() => {
        delete _cache.inflightPost[d2.id];
        if (d2.newStatus === "ignore") {
          this.removeItem(d2);
        } else if (d2.newStatus === "ignore_t") {
          this.removeItem(d2);
          _cache.closed["".concat(d2.schema, ":").concat(d2.id)] = true;
        } else {
          d2 = this.replaceItem(d2.update({
            comment: d2.newComment,
            newComment: void 0,
            newState: void 0
          }));
        }
        if (callback)
          callback(null, d2);
      });
    },
    // Get all cached QAItems covering the viewport
    getItems(projection2) {
      const viewport = projection2.clipExtent();
      const min3 = [viewport[0][0], viewport[1][1]];
      const max3 = [viewport[1][0], viewport[0][1]];
      const bbox2 = geoExtent(projection2.invert(min3), projection2.invert(max3)).bbox();
      return _cache.rtree.search(bbox2).map((d2) => d2.data);
    },
    // Get a QAItem from cache
    // NOTE: Don't change method name until UI v3 is merged
    getError(id2) {
      return _cache.data[id2];
    },
    // Replace a single QAItem in the cache
    replaceItem(item) {
      if (!(item instanceof QAItem) || !item.id)
        return;
      _cache.data[item.id] = item;
      updateRtree(encodeIssueRtree(item), true);
      return item;
    },
    // Remove a single QAItem from the cache
    removeItem(item) {
      if (!(item instanceof QAItem) || !item.id)
        return;
      delete _cache.data[item.id];
      updateRtree(encodeIssueRtree(item), false);
    },
    issueURL(item) {
      return "".concat(_krUrlRoot, "/report_map.php?schema=").concat(item.schema, "&error=").concat(item.id);
    },
    // Get an array of issues closed during this session.
    // Used to populate `closed:keepright` changeset tag
    getClosedIDs() {
      return Object.keys(_cache.closed).sort();
    }
  };

  // modules/services/improveOSM.js
  var import_rbush2 = __toESM(require_rbush_min());
  var tiler2 = utilTiler();
  var dispatch3 = dispatch_default("loaded");
  var _tileZoom2 = 14;
  var _impOsmUrls = {
    ow: "https://grab.community.improve-osm.org/directionOfFlowService",
    mr: "https://grab.community.improve-osm.org/missingGeoService",
    tr: "https://grab.community.improve-osm.org/turnRestrictionService"
  };
  var _impOsmData = { icons: {} };
  var _cache2;
  function abortRequest2(i3) {
    Object.values(i3).forEach((controller) => {
      if (controller) {
        controller.abort();
      }
    });
  }
  function abortUnwantedRequests2(cache, tiles) {
    Object.keys(cache.inflightTile).forEach((k2) => {
      const wanted = tiles.find((tile) => k2 === tile.id);
      if (!wanted) {
        abortRequest2(cache.inflightTile[k2]);
        delete cache.inflightTile[k2];
      }
    });
  }
  function encodeIssueRtree2(d2) {
    return { minX: d2.loc[0], minY: d2.loc[1], maxX: d2.loc[0], maxY: d2.loc[1], data: d2 };
  }
  function updateRtree2(item, replace) {
    _cache2.rtree.remove(item, (a2, b2) => a2.data.id === b2.data.id);
    if (replace) {
      _cache2.rtree.insert(item);
    }
  }
  function linkErrorObject(d2) {
    return { html: '<a class="error_object_link">'.concat(d2, "</a>") };
  }
  function linkEntity(d2) {
    return { html: '<a class="error_entity_link">'.concat(d2, "</a>") };
  }
  function pointAverage(points) {
    if (points.length) {
      const sum = points.reduce(
        (acc, point2) => geoVecAdd(acc, [point2.lon, point2.lat]),
        [0, 0]
      );
      return geoVecScale(sum, 1 / points.length);
    } else {
      return [0, 0];
    }
  }
  function relativeBearing(p1, p2) {
    let angle2 = Math.atan2(p2.lon - p1.lon, p2.lat - p1.lat);
    if (angle2 < 0) {
      angle2 += 2 * Math.PI;
    }
    return angle2 * 180 / Math.PI;
  }
  function cardinalDirection(bearing) {
    const dir = 45 * Math.round(bearing / 45);
    const compass = {
      0: "north",
      45: "northeast",
      90: "east",
      135: "southeast",
      180: "south",
      225: "southwest",
      270: "west",
      315: "northwest",
      360: "north"
    };
    return _t("QA.improveOSM.directions.".concat(compass[dir]));
  }
  function preventCoincident(loc, bumpUp) {
    let coincident = false;
    do {
      let delta = coincident ? [1e-5, 0] : bumpUp ? [0, 1e-5] : [0, 0];
      loc = geoVecAdd(loc, delta);
      let bbox2 = geoExtent(loc).bbox();
      coincident = _cache2.rtree.search(bbox2).length;
    } while (coincident);
    return loc;
  }
  var improveOSM_default = {
    title: "improveOSM",
    init() {
      _mainFileFetcher.get("qa_data").then((d2) => _impOsmData = d2.improveOSM);
      if (!_cache2) {
        this.reset();
      }
      this.event = utilRebind(this, dispatch3, "on");
    },
    reset() {
      if (_cache2) {
        Object.values(_cache2.inflightTile).forEach(abortRequest2);
      }
      _cache2 = {
        data: {},
        loadedTile: {},
        inflightTile: {},
        inflightPost: {},
        closed: {},
        rtree: new import_rbush2.default()
      };
    },
    loadIssues(projection2) {
      const options2 = {
        client: "iD",
        status: "OPEN",
        zoom: "19"
        // Use a high zoom so that clusters aren't returned
      };
      const tiles = tiler2.zoomExtent([_tileZoom2, _tileZoom2]).getTiles(projection2);
      abortUnwantedRequests2(_cache2, tiles);
      tiles.forEach((tile) => {
        if (_cache2.loadedTile[tile.id] || _cache2.inflightTile[tile.id])
          return;
        const [east, north, west, south] = tile.extent.rectangle();
        const params = Object.assign({}, options2, { east, south, west, north });
        const requests = {};
        Object.keys(_impOsmUrls).forEach((k2) => {
          const kParams = Object.assign(
            {},
            params,
            k2 === "mr" ? { type: "PARKING,ROAD,BOTH,PATH" } : { confidenceLevel: "C1" }
          );
          const url = "".concat(_impOsmUrls[k2], "/search?") + utilQsString(kParams);
          const controller = new AbortController();
          requests[k2] = controller;
          json_default(url, { signal: controller.signal }).then((data) => {
            delete _cache2.inflightTile[tile.id][k2];
            if (!Object.keys(_cache2.inflightTile[tile.id]).length) {
              delete _cache2.inflightTile[tile.id];
              _cache2.loadedTile[tile.id] = true;
            }
            if (data.roadSegments) {
              data.roadSegments.forEach((feature3) => {
                const { points, wayId, fromNodeId, toNodeId } = feature3;
                const itemId = "".concat(wayId).concat(fromNodeId).concat(toNodeId);
                let mid = points.length / 2;
                let loc;
                if (mid % 1 === 0) {
                  loc = pointAverage([points[mid - 1], points[mid]]);
                } else {
                  mid = points[Math.floor(mid)];
                  loc = [mid.lon, mid.lat];
                }
                loc = preventCoincident(loc, false);
                let d2 = new QAItem(loc, this, k2, itemId, {
                  issueKey: k2,
                  // used as a category
                  identifier: {
                    // used to post changes
                    wayId,
                    fromNodeId,
                    toNodeId
                  },
                  objectId: wayId,
                  objectType: "way"
                });
                d2.replacements = {
                  percentage: feature3.percentOfTrips,
                  num_trips: feature3.numberOfTrips,
                  highway: linkErrorObject(_t("QA.keepRight.error_parts.highway")),
                  from_node: linkEntity("n" + feature3.fromNodeId),
                  to_node: linkEntity("n" + feature3.toNodeId)
                };
                _cache2.data[d2.id] = d2;
                _cache2.rtree.insert(encodeIssueRtree2(d2));
              });
            }
            if (data.tiles) {
              data.tiles.forEach((feature3) => {
                const { type: type2, x: x2, y: y2, numberOfTrips } = feature3;
                const geoType = type2.toLowerCase();
                const itemId = "".concat(geoType).concat(x2).concat(y2).concat(numberOfTrips);
                let loc = pointAverage(feature3.points);
                loc = preventCoincident(loc, false);
                let d2 = new QAItem(loc, this, "".concat(k2, "-").concat(geoType), itemId, {
                  issueKey: k2,
                  identifier: { x: x2, y: y2 }
                });
                d2.replacements = {
                  num_trips: numberOfTrips,
                  geometry_type: _t("QA.improveOSM.geometry_types.".concat(geoType))
                };
                if (numberOfTrips === -1) {
                  d2.desc = _t("QA.improveOSM.error_types.mr.description_alt", d2.replacements);
                }
                _cache2.data[d2.id] = d2;
                _cache2.rtree.insert(encodeIssueRtree2(d2));
              });
            }
            if (data.entities) {
              data.entities.forEach((feature3) => {
                const { point: point2, id: id2, segments, numberOfPasses, turnType } = feature3;
                const itemId = "".concat(id2.replace(/[,:+#]/g, "_"));
                const loc = preventCoincident([point2.lon, point2.lat], true);
                const ids = id2.split(",");
                const from_way = ids[0];
                const via_node = ids[3];
                const to_way = ids[2].split(":")[1];
                let d2 = new QAItem(loc, this, k2, itemId, {
                  issueKey: k2,
                  identifier: id2,
                  objectId: via_node,
                  objectType: "node"
                });
                const [p1, p2] = segments[0].points;
                const dir_of_travel = cardinalDirection(relativeBearing(p1, p2));
                d2.replacements = {
                  num_passed: numberOfPasses,
                  num_trips: segments[0].numberOfTrips,
                  turn_restriction: turnType.toLowerCase(),
                  from_way: linkEntity("w" + from_way),
                  to_way: linkEntity("w" + to_way),
                  travel_direction: dir_of_travel,
                  junction: linkErrorObject(_t("QA.keepRight.error_parts.this_node"))
                };
                _cache2.data[d2.id] = d2;
                _cache2.rtree.insert(encodeIssueRtree2(d2));
                dispatch3.call("loaded");
              });
            }
          }).catch(() => {
            delete _cache2.inflightTile[tile.id][k2];
            if (!Object.keys(_cache2.inflightTile[tile.id]).length) {
              delete _cache2.inflightTile[tile.id];
              _cache2.loadedTile[tile.id] = true;
            }
          });
        });
        _cache2.inflightTile[tile.id] = requests;
      });
    },
    getComments(item) {
      if (item.comments) {
        return Promise.resolve(item);
      }
      const key = item.issueKey;
      let qParams = {};
      if (key === "ow") {
        qParams = item.identifier;
      } else if (key === "mr") {
        qParams.tileX = item.identifier.x;
        qParams.tileY = item.identifier.y;
      } else if (key === "tr") {
        qParams.targetId = item.identifier;
      }
      const url = "".concat(_impOsmUrls[key], "/retrieveComments?") + utilQsString(qParams);
      const cacheComments = (data) => {
        item.comments = data.comments ? data.comments.reverse() : [];
        this.replaceItem(item);
      };
      return json_default(url).then(cacheComments).then(() => item);
    },
    postUpdate(d2, callback) {
      if (!osm_default.authenticated()) {
        return callback({ message: "Not Authenticated", status: -3 }, d2);
      }
      if (_cache2.inflightPost[d2.id]) {
        return callback({ message: "Error update already inflight", status: -2 }, d2);
      }
      osm_default.userDetails(sendPayload.bind(this));
      function sendPayload(err, user) {
        if (err) {
          return callback(err, d2);
        }
        const key = d2.issueKey;
        const url = "".concat(_impOsmUrls[key], "/comment");
        const payload = {
          username: user.display_name,
          targetIds: [d2.identifier]
        };
        if (d2.newStatus) {
          payload.status = d2.newStatus;
          payload.text = "status changed";
        }
        if (d2.newComment) {
          payload.text = d2.newComment;
        }
        const controller = new AbortController();
        _cache2.inflightPost[d2.id] = controller;
        const options2 = {
          method: "POST",
          signal: controller.signal,
          body: JSON.stringify(payload)
        };
        json_default(url, options2).then(() => {
          delete _cache2.inflightPost[d2.id];
          if (!d2.newStatus) {
            const now3 = /* @__PURE__ */ new Date();
            let comments = d2.comments ? d2.comments : [];
            comments.push({
              username: payload.username,
              text: payload.text,
              timestamp: now3.getTime() / 1e3
            });
            this.replaceItem(d2.update({
              comments,
              newComment: void 0
            }));
          } else {
            this.removeItem(d2);
            if (d2.newStatus === "SOLVED") {
              if (!(d2.issueKey in _cache2.closed)) {
                _cache2.closed[d2.issueKey] = 0;
              }
              _cache2.closed[d2.issueKey] += 1;
            }
          }
          if (callback)
            callback(null, d2);
        }).catch((err2) => {
          delete _cache2.inflightPost[d2.id];
          if (callback)
            callback(err2.message);
        });
      }
    },
    // Get all cached QAItems covering the viewport
    getItems(projection2) {
      const viewport = projection2.clipExtent();
      const min3 = [viewport[0][0], viewport[1][1]];
      const max3 = [viewport[1][0], viewport[0][1]];
      const bbox2 = geoExtent(projection2.invert(min3), projection2.invert(max3)).bbox();
      return _cache2.rtree.search(bbox2).map((d2) => d2.data);
    },
    // Get a QAItem from cache
    // NOTE: Don't change method name until UI v3 is merged
    getError(id2) {
      return _cache2.data[id2];
    },
    // get the name of the icon to display for this item
    getIcon(itemType) {
      return _impOsmData.icons[itemType];
    },
    // Replace a single QAItem in the cache
    replaceItem(issue) {
      if (!(issue instanceof QAItem) || !issue.id)
        return;
      _cache2.data[issue.id] = issue;
      updateRtree2(encodeIssueRtree2(issue), true);
      return issue;
    },
    // Remove a single QAItem from the cache
    removeItem(issue) {
      if (!(issue instanceof QAItem) || !issue.id)
        return;
      delete _cache2.data[issue.id];
      updateRtree2(encodeIssueRtree2(issue), false);
    },
    // Used to populate `closed:improveosm:*` changeset tags
    getClosedCounts() {
      return _cache2.closed;
    }
  };

  // modules/services/osmose.js
  var import_rbush3 = __toESM(require_rbush_min());

  // node_modules/marked/lib/marked.esm.js
  function _getDefaults() {
    return {
      async: false,
      breaks: false,
      extensions: null,
      gfm: true,
      hooks: null,
      pedantic: false,
      renderer: null,
      silent: false,
      tokenizer: null,
      walkTokens: null
    };
  }
  var _defaults = _getDefaults();
  function changeDefaults(newDefaults) {
    _defaults = newDefaults;
  }
  var escapeTest = /[&<>"']/;
  var escapeReplace = new RegExp(escapeTest.source, "g");
  var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
  var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
  var escapeReplacements = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var getEscapeReplacement = (ch) => escapeReplacements[ch];
  function escape$1(html3, encode) {
    if (encode) {
      if (escapeTest.test(html3)) {
        return html3.replace(escapeReplace, getEscapeReplacement);
      }
    } else {
      if (escapeTestNoEncode.test(html3)) {
        return html3.replace(escapeReplaceNoEncode, getEscapeReplacement);
      }
    }
    return html3;
  }
  var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
  function unescape2(html3) {
    return html3.replace(unescapeTest, (_2, n3) => {
      n3 = n3.toLowerCase();
      if (n3 === "colon")
        return ":";
      if (n3.charAt(0) === "#") {
        return n3.charAt(1) === "x" ? String.fromCharCode(parseInt(n3.substring(2), 16)) : String.fromCharCode(+n3.substring(1));
      }
      return "";
    });
  }
  var caret = /(^|[^\[])\^/g;
  function edit(regex, opt) {
    let source = typeof regex === "string" ? regex : regex.source;
    opt = opt || "";
    const obj = {
      replace: (name, val) => {
        let valSource = typeof val === "string" ? val : val.source;
        valSource = valSource.replace(caret, "$1");
        source = source.replace(name, valSource);
        return obj;
      },
      getRegex: () => {
        return new RegExp(source, opt);
      }
    };
    return obj;
  }
  function cleanUrl(href) {
    try {
      href = encodeURI(href).replace(/%25/g, "%");
    } catch (e3) {
      return null;
    }
    return href;
  }
  var noopTest = { exec: () => null };
  function splitCells(tableRow, count) {
    const row = tableRow.replace(/\|/g, (match, offset, str) => {
      let escaped = false;
      let curr = offset;
      while (--curr >= 0 && str[curr] === "\\")
        escaped = !escaped;
      if (escaped) {
        return "|";
      } else {
        return " |";
      }
    }), cells = row.split(/ \|/);
    let i3 = 0;
    if (!cells[0].trim()) {
      cells.shift();
    }
    if (cells.length > 0 && !cells[cells.length - 1].trim()) {
      cells.pop();
    }
    if (count) {
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count)
          cells.push("");
      }
    }
    for (; i3 < cells.length; i3++) {
      cells[i3] = cells[i3].trim().replace(/\\\|/g, "|");
    }
    return cells;
  }
  function rtrim(str, c2, invert) {
    const l2 = str.length;
    if (l2 === 0) {
      return "";
    }
    let suffLen = 0;
    while (suffLen < l2) {
      const currChar = str.charAt(l2 - suffLen - 1);
      if (currChar === c2 && !invert) {
        suffLen++;
      } else if (currChar !== c2 && invert) {
        suffLen++;
      } else {
        break;
      }
    }
    return str.slice(0, l2 - suffLen);
  }
  function findClosingBracket(str, b2) {
    if (str.indexOf(b2[1]) === -1) {
      return -1;
    }
    let level = 0;
    for (let i3 = 0; i3 < str.length; i3++) {
      if (str[i3] === "\\") {
        i3++;
      } else if (str[i3] === b2[0]) {
        level++;
      } else if (str[i3] === b2[1]) {
        level--;
        if (level < 0) {
          return i3;
        }
      }
    }
    return -1;
  }
  function outputLink(cap, link3, raw, lexer2) {
    const href = link3.href;
    const title = link3.title ? escape$1(link3.title) : null;
    const text = cap[1].replace(/\\([\[\]])/g, "$1");
    if (cap[0].charAt(0) !== "!") {
      lexer2.state.inLink = true;
      const token = {
        type: "link",
        raw,
        href,
        title,
        text,
        tokens: lexer2.inlineTokens(text)
      };
      lexer2.state.inLink = false;
      return token;
    }
    return {
      type: "image",
      raw,
      href,
      title,
      text: escape$1(text)
    };
  }
  function indentCodeCompensation(raw, text) {
    const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
    if (matchIndentToCode === null) {
      return text;
    }
    const indentToCode = matchIndentToCode[1];
    return text.split("\n").map((node) => {
      const matchIndentInNode = node.match(/^\s+/);
      if (matchIndentInNode === null) {
        return node;
      }
      const [indentInNode] = matchIndentInNode;
      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }
      return node;
    }).join("\n");
  }
  var _Tokenizer = class {
    // set by the lexer
    constructor(options2) {
      __publicField(this, "options");
      __publicField(this, "rules");
      // set by the lexer
      __publicField(this, "lexer");
      this.options = options2 || _defaults;
    }
    space(src) {
      const cap = this.rules.block.newline.exec(src);
      if (cap && cap[0].length > 0) {
        return {
          type: "space",
          raw: cap[0]
        };
      }
    }
    code(src) {
      const cap = this.rules.block.code.exec(src);
      if (cap) {
        const text = cap[0].replace(/^ {1,4}/gm, "");
        return {
          type: "code",
          raw: cap[0],
          codeBlockStyle: "indented",
          text: !this.options.pedantic ? rtrim(text, "\n") : text
        };
      }
    }
    fences(src) {
      const cap = this.rules.block.fences.exec(src);
      if (cap) {
        const raw = cap[0];
        const text = indentCodeCompensation(raw, cap[3] || "");
        return {
          type: "code",
          raw,
          lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
          text
        };
      }
    }
    heading(src) {
      const cap = this.rules.block.heading.exec(src);
      if (cap) {
        let text = cap[2].trim();
        if (/#$/.test(text)) {
          const trimmed = rtrim(text, "#");
          if (this.options.pedantic) {
            text = trimmed.trim();
          } else if (!trimmed || / $/.test(trimmed)) {
            text = trimmed.trim();
          }
        }
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[1].length,
          text,
          tokens: this.lexer.inline(text)
        };
      }
    }
    hr(src) {
      const cap = this.rules.block.hr.exec(src);
      if (cap) {
        return {
          type: "hr",
          raw: cap[0]
        };
      }
    }
    blockquote(src) {
      const cap = this.rules.block.blockquote.exec(src);
      if (cap) {
        let text = cap[0].replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, "\n    $1");
        text = rtrim(text.replace(/^ *>[ \t]?/gm, ""), "\n");
        const top = this.lexer.state.top;
        this.lexer.state.top = true;
        const tokens = this.lexer.blockTokens(text);
        this.lexer.state.top = top;
        return {
          type: "blockquote",
          raw: cap[0],
          tokens,
          text
        };
      }
    }
    list(src) {
      let cap = this.rules.block.list.exec(src);
      if (cap) {
        let bull = cap[1].trim();
        const isordered = bull.length > 1;
        const list2 = {
          type: "list",
          raw: "",
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : "",
          loose: false,
          items: []
        };
        bull = isordered ? "\\d{1,9}\\".concat(bull.slice(-1)) : "\\".concat(bull);
        if (this.options.pedantic) {
          bull = isordered ? bull : "[*+-]";
        }
        const itemRegex = new RegExp("^( {0,3}".concat(bull, ")((?:[	 ][^\\n]*)?(?:\\n|$))"));
        let raw = "";
        let itemContents = "";
        let endsWithBlankLine = false;
        while (src) {
          let endEarly = false;
          if (!(cap = itemRegex.exec(src))) {
            break;
          }
          if (this.rules.block.hr.test(src)) {
            break;
          }
          raw = cap[0];
          src = src.substring(raw.length);
          let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t2) => " ".repeat(3 * t2.length));
          let nextLine = src.split("\n", 1)[0];
          let indent = 0;
          if (this.options.pedantic) {
            indent = 2;
            itemContents = line.trimStart();
          } else {
            indent = cap[2].search(/[^ ]/);
            indent = indent > 4 ? 1 : indent;
            itemContents = line.slice(indent);
            indent += cap[1].length;
          }
          let blankLine = false;
          if (!line && /^ *$/.test(nextLine)) {
            raw += nextLine + "\n";
            src = src.substring(nextLine.length + 1);
            endEarly = true;
          }
          if (!endEarly) {
            const nextBulletRegex = new RegExp("^ {0,".concat(Math.min(3, indent - 1), "}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))"));
            const hrRegex = new RegExp("^ {0,".concat(Math.min(3, indent - 1), "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)"));
            const fencesBeginRegex = new RegExp("^ {0,".concat(Math.min(3, indent - 1), "}(?:```|~~~)"));
            const headingBeginRegex = new RegExp("^ {0,".concat(Math.min(3, indent - 1), "}#"));
            while (src) {
              const rawLine = src.split("\n", 1)[0];
              nextLine = rawLine;
              if (this.options.pedantic) {
                nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
              }
              if (fencesBeginRegex.test(nextLine)) {
                break;
              }
              if (headingBeginRegex.test(nextLine)) {
                break;
              }
              if (nextBulletRegex.test(nextLine)) {
                break;
              }
              if (hrRegex.test(src)) {
                break;
              }
              if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
                itemContents += "\n" + nextLine.slice(indent);
              } else {
                if (blankLine) {
                  break;
                }
                if (line.search(/[^ ]/) >= 4) {
                  break;
                }
                if (fencesBeginRegex.test(line)) {
                  break;
                }
                if (headingBeginRegex.test(line)) {
                  break;
                }
                if (hrRegex.test(line)) {
                  break;
                }
                itemContents += "\n" + nextLine;
              }
              if (!blankLine && !nextLine.trim()) {
                blankLine = true;
              }
              raw += rawLine + "\n";
              src = src.substring(rawLine.length + 1);
              line = nextLine.slice(indent);
            }
          }
          if (!list2.loose) {
            if (endsWithBlankLine) {
              list2.loose = true;
            } else if (/\n *\n *$/.test(raw)) {
              endsWithBlankLine = true;
            }
          }
          let istask = null;
          let ischecked;
          if (this.options.gfm) {
            istask = /^\[[ xX]\] /.exec(itemContents);
            if (istask) {
              ischecked = istask[0] !== "[ ] ";
              itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
            }
          }
          list2.items.push({
            type: "list_item",
            raw,
            task: !!istask,
            checked: ischecked,
            loose: false,
            text: itemContents,
            tokens: []
          });
          list2.raw += raw;
        }
        list2.items[list2.items.length - 1].raw = raw.trimEnd();
        list2.items[list2.items.length - 1].text = itemContents.trimEnd();
        list2.raw = list2.raw.trimEnd();
        for (let i3 = 0; i3 < list2.items.length; i3++) {
          this.lexer.state.top = false;
          list2.items[i3].tokens = this.lexer.blockTokens(list2.items[i3].text, []);
          if (!list2.loose) {
            const spacers = list2.items[i3].tokens.filter((t2) => t2.type === "space");
            const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t2) => /\n.*\n/.test(t2.raw));
            list2.loose = hasMultipleLineBreaks;
          }
        }
        if (list2.loose) {
          for (let i3 = 0; i3 < list2.items.length; i3++) {
            list2.items[i3].loose = true;
          }
        }
        return list2;
      }
    }
    html(src) {
      const cap = this.rules.block.html.exec(src);
      if (cap) {
        const token = {
          type: "html",
          block: true,
          raw: cap[0],
          pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
          text: cap[0]
        };
        return token;
      }
    }
    def(src) {
      const cap = this.rules.block.def.exec(src);
      if (cap) {
        const tag2 = cap[1].toLowerCase().replace(/\s+/g, " ");
        const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
        const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
        return {
          type: "def",
          tag: tag2,
          raw: cap[0],
          href,
          title
        };
      }
    }
    table(src) {
      const cap = this.rules.block.table.exec(src);
      if (!cap) {
        return;
      }
      if (!/[:|]/.test(cap[2])) {
        return;
      }
      const headers = splitCells(cap[1]);
      const aligns = cap[2].replace(/^\||\| *$/g, "").split("|");
      const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : [];
      const item = {
        type: "table",
        raw: cap[0],
        header: [],
        align: [],
        rows: []
      };
      if (headers.length !== aligns.length) {
        return;
      }
      for (const align of aligns) {
        if (/^ *-+: *$/.test(align)) {
          item.align.push("right");
        } else if (/^ *:-+: *$/.test(align)) {
          item.align.push("center");
        } else if (/^ *:-+ *$/.test(align)) {
          item.align.push("left");
        } else {
          item.align.push(null);
        }
      }
      for (const header of headers) {
        item.header.push({
          text: header,
          tokens: this.lexer.inline(header)
        });
      }
      for (const row of rows) {
        item.rows.push(splitCells(row, item.header.length).map((cell) => {
          return {
            text: cell,
            tokens: this.lexer.inline(cell)
          };
        }));
      }
      return item;
    }
    lheading(src) {
      const cap = this.rules.block.lheading.exec(src);
      if (cap) {
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[2].charAt(0) === "=" ? 1 : 2,
          text: cap[1],
          tokens: this.lexer.inline(cap[1])
        };
      }
    }
    paragraph(src) {
      const cap = this.rules.block.paragraph.exec(src);
      if (cap) {
        const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
        return {
          type: "paragraph",
          raw: cap[0],
          text,
          tokens: this.lexer.inline(text)
        };
      }
    }
    text(src) {
      const cap = this.rules.block.text.exec(src);
      if (cap) {
        return {
          type: "text",
          raw: cap[0],
          text: cap[0],
          tokens: this.lexer.inline(cap[0])
        };
      }
    }
    escape(src) {
      const cap = this.rules.inline.escape.exec(src);
      if (cap) {
        return {
          type: "escape",
          raw: cap[0],
          text: escape$1(cap[1])
        };
      }
    }
    tag(src) {
      const cap = this.rules.inline.tag.exec(src);
      if (cap) {
        if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
          this.lexer.state.inLink = true;
        } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
          this.lexer.state.inLink = false;
        }
        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = true;
        } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = false;
        }
        return {
          type: "html",
          raw: cap[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          block: false,
          text: cap[0]
        };
      }
    }
    link(src) {
      const cap = this.rules.inline.link.exec(src);
      if (cap) {
        const trimmedUrl = cap[2].trim();
        if (!this.options.pedantic && /^</.test(trimmedUrl)) {
          if (!/>$/.test(trimmedUrl)) {
            return;
          }
          const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          const lastParenIndex = findClosingBracket(cap[2], "()");
          if (lastParenIndex > -1) {
            const start2 = cap[0].indexOf("!") === 0 ? 5 : 4;
            const linkLen = start2 + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = "";
          }
        }
        let href = cap[2];
        let title = "";
        if (this.options.pedantic) {
          const link3 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
          if (link3) {
            href = link3[1];
            title = link3[3];
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : "";
        }
        href = href.trim();
        if (/^</.test(href)) {
          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }
        return outputLink(cap, {
          href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
          title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
        }, cap[0], this.lexer);
      }
    }
    reflink(src, links) {
      let cap;
      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        const linkString = (cap[2] || cap[1]).replace(/\s+/g, " ");
        const link3 = links[linkString.toLowerCase()];
        if (!link3) {
          const text = cap[0].charAt(0);
          return {
            type: "text",
            raw: text,
            text
          };
        }
        return outputLink(cap, link3, cap[0], this.lexer);
      }
    }
    emStrong(src, maskedSrc, prevChar = "") {
      let match = this.rules.inline.emStrongLDelim.exec(src);
      if (!match)
        return;
      if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
        return;
      const nextChar = match[1] || match[2] || "";
      if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
        const lLength = [...match[0]].length - 1;
        let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
        const endReg = match[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
        endReg.lastIndex = 0;
        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
        while ((match = endReg.exec(maskedSrc)) != null) {
          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
          if (!rDelim)
            continue;
          rLength = [...rDelim].length;
          if (match[3] || match[4]) {
            delimTotal += rLength;
            continue;
          } else if (match[5] || match[6]) {
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue;
            }
          }
          delimTotal -= rLength;
          if (delimTotal > 0)
            continue;
          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
          const lastCharLength = [...match[0]][0].length;
          const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
          if (Math.min(lLength, rLength) % 2) {
            const text2 = raw.slice(1, -1);
            return {
              type: "em",
              raw,
              text: text2,
              tokens: this.lexer.inlineTokens(text2)
            };
          }
          const text = raw.slice(2, -2);
          return {
            type: "strong",
            raw,
            text,
            tokens: this.lexer.inlineTokens(text)
          };
        }
      }
    }
    codespan(src) {
      const cap = this.rules.inline.code.exec(src);
      if (cap) {
        let text = cap[2].replace(/\n/g, " ");
        const hasNonSpaceChars = /[^ ]/.test(text);
        const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text = text.substring(1, text.length - 1);
        }
        text = escape$1(text, true);
        return {
          type: "codespan",
          raw: cap[0],
          text
        };
      }
    }
    br(src) {
      const cap = this.rules.inline.br.exec(src);
      if (cap) {
        return {
          type: "br",
          raw: cap[0]
        };
      }
    }
    del(src) {
      const cap = this.rules.inline.del.exec(src);
      if (cap) {
        return {
          type: "del",
          raw: cap[0],
          text: cap[2],
          tokens: this.lexer.inlineTokens(cap[2])
        };
      }
    }
    autolink(src) {
      const cap = this.rules.inline.autolink.exec(src);
      if (cap) {
        let text, href;
        if (cap[2] === "@") {
          text = escape$1(cap[1]);
          href = "mailto:" + text;
        } else {
          text = escape$1(cap[1]);
          href = text;
        }
        return {
          type: "link",
          raw: cap[0],
          text,
          href,
          tokens: [
            {
              type: "text",
              raw: text,
              text
            }
          ]
        };
      }
    }
    url(src) {
      var _a2, _b;
      let cap;
      if (cap = this.rules.inline.url.exec(src)) {
        let text, href;
        if (cap[2] === "@") {
          text = escape$1(cap[0]);
          href = "mailto:" + text;
        } else {
          let prevCapZero;
          do {
            prevCapZero = cap[0];
            cap[0] = (_b = (_a2 = this.rules.inline._backpedal.exec(cap[0])) == null ? void 0 : _a2[0]) != null ? _b : "";
          } while (prevCapZero !== cap[0]);
          text = escape$1(cap[0]);
          if (cap[1] === "www.") {
            href = "http://" + cap[0];
          } else {
            href = cap[0];
          }
        }
        return {
          type: "link",
          raw: cap[0],
          text,
          href,
          tokens: [
            {
              type: "text",
              raw: text,
              text
            }
          ]
        };
      }
    }
    inlineText(src) {
      const cap = this.rules.inline.text.exec(src);
      if (cap) {
        let text;
        if (this.lexer.state.inRawBlock) {
          text = cap[0];
        } else {
          text = escape$1(cap[0]);
        }
        return {
          type: "text",
          raw: cap[0],
          text
        };
      }
    }
  };
  var newline = /^(?: *(?:\n|$))+/;
  var blockCode = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/;
  var fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
  var hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
  var heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
  var bullet = /(?:[*+-]|\d{1,9}[.)])/;
  var lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, bullet).replace(/blockCode/g, / {4}/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).getRegex();
  var _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
  var blockText = /^[^\n]+/;
  var _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  var def = edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
  var list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
  var _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
  var _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
  var html2 = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  var paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
  var blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
  var blockNormal = {
    blockquote,
    code: blockCode,
    def,
    fences,
    heading,
    hr,
    html: html2,
    lheading,
    list,
    newline,
    paragraph,
    table: noopTest,
    text: blockText
  };
  var gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
  var blockGfm = {
    ...blockNormal,
    table: gfmTable,
    paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
  };
  var blockPedantic = {
    ...blockNormal,
    html: edit("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    // fences not supported
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
  };
  var escape4 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
  var inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
  var br = /^( {2,}|\\)\n(?!\s*$)/;
  var inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
  var _punctuation = "\\p{P}\\p{S}";
  var punctuation = edit(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, _punctuation).getRegex();
  var blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
  var emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, _punctuation).getRegex();
  var emStrongRDelimAst = edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, _punctuation).getRegex();
  var emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, _punctuation).getRegex();
  var anyPunctuation = edit(/\\([punct])/, "gu").replace(/punct/g, _punctuation).getRegex();
  var autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
  var _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
  var tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
  var _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  var link2 = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
  var reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
  var nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
  var reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
  var inlineNormal = {
    _backpedal: noopTest,
    // only used for GFM url
    anyPunctuation,
    autolink,
    blockSkip,
    br,
    code: inlineCode,
    del: noopTest,
    emStrongLDelim,
    emStrongRDelimAst,
    emStrongRDelimUnd,
    escape: escape4,
    link: link2,
    nolink,
    punctuation,
    reflink,
    reflinkSearch,
    tag,
    text: inlineText,
    url: noopTest
  };
  var inlinePedantic = {
    ...inlineNormal,
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
  };
  var inlineGfm = {
    ...inlineNormal,
    escape: edit(escape4).replace("])", "~|])").getRegex(),
    url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  };
  var inlineBreaks = {
    ...inlineGfm,
    br: edit(br).replace("{2,}", "*").getRegex(),
    text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
  };
  var block = {
    normal: blockNormal,
    gfm: blockGfm,
    pedantic: blockPedantic
  };
  var inline = {
    normal: inlineNormal,
    gfm: inlineGfm,
    breaks: inlineBreaks,
    pedantic: inlinePedantic
  };
  var _Lexer = class __Lexer {
    constructor(options2) {
      __publicField(this, "tokens");
      __publicField(this, "options");
      __publicField(this, "state");
      __publicField(this, "tokenizer");
      __publicField(this, "inlineQueue");
      this.tokens = [];
      this.tokens.links = /* @__PURE__ */ Object.create(null);
      this.options = options2 || _defaults;
      this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      this.tokenizer.lexer = this;
      this.inlineQueue = [];
      this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      const rules = {
        block: block.normal,
        inline: inline.normal
      };
      if (this.options.pedantic) {
        rules.block = block.pedantic;
        rules.inline = inline.pedantic;
      } else if (this.options.gfm) {
        rules.block = block.gfm;
        if (this.options.breaks) {
          rules.inline = inline.breaks;
        } else {
          rules.inline = inline.gfm;
        }
      }
      this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */
    static get rules() {
      return {
        block,
        inline
      };
    }
    /**
     * Static Lex Method
     */
    static lex(src, options2) {
      const lexer2 = new __Lexer(options2);
      return lexer2.lex(src);
    }
    /**
     * Static Lex Inline Method
     */
    static lexInline(src, options2) {
      const lexer2 = new __Lexer(options2);
      return lexer2.inlineTokens(src);
    }
    /**
     * Preprocessing
     */
    lex(src) {
      src = src.replace(/\r\n|\r/g, "\n");
      this.blockTokens(src, this.tokens);
      for (let i3 = 0; i3 < this.inlineQueue.length; i3++) {
        const next = this.inlineQueue[i3];
        this.inlineTokens(next.src, next.tokens);
      }
      this.inlineQueue = [];
      return this.tokens;
    }
    blockTokens(src, tokens = []) {
      if (this.options.pedantic) {
        src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
      } else {
        src = src.replace(/^( *)(\t+)/gm, (_2, leading, tabs) => {
          return leading + "    ".repeat(tabs.length);
        });
      }
      let token;
      let lastToken;
      let cutSrc;
      let lastParagraphClipped;
      while (src) {
        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);
          if (token.raw.length === 1 && tokens.length > 0) {
            tokens[tokens.length - 1].raw += "\n";
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.code(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.def(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.raw;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }
          continue;
        }
        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startBlock) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startBlock.forEach((getStartIndex) => {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
          lastToken = tokens[tokens.length - 1];
          if (lastParagraphClipped && lastToken.type === "paragraph") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          lastParagraphClipped = cutSrc.length !== src.length;
          src = src.substring(token.raw.length);
          continue;
        }
        if (token = this.tokenizer.text(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      this.state.top = true;
      return tokens;
    }
    inline(src, tokens = []) {
      this.inlineQueue.push({ src, tokens });
      return tokens;
    }
    /**
     * Lexing/Compiling
     */
    inlineTokens(src, tokens = []) {
      let token, lastToken, cutSrc;
      let maskedSrc = src;
      let match;
      let keepPrevChar, prevChar;
      if (this.tokens.links) {
        const links = Object.keys(this.tokens.links);
        if (links.length > 0) {
          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      }
      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }
      while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
      }
      while (src) {
        if (!keepPrevChar) {
          prevChar = "";
        }
        keepPrevChar = false;
        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.tag(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === "text" && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === "text" && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.autolink(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (!this.state.inLink && (token = this.tokenizer.url(src))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startInline) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startInline.forEach((getStartIndex) => {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (token = this.tokenizer.inlineText(cutSrc)) {
          src = src.substring(token.raw.length);
          if (token.raw.slice(-1) !== "_") {
            prevChar = token.raw.slice(-1);
          }
          keepPrevChar = true;
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      return tokens;
    }
  };
  var _Renderer = class {
    constructor(options2) {
      __publicField(this, "options");
      this.options = options2 || _defaults;
    }
    code(code, infostring, escaped) {
      var _a2;
      const lang = (_a2 = (infostring || "").match(/^\S*/)) == null ? void 0 : _a2[0];
      code = code.replace(/\n$/, "") + "\n";
      if (!lang) {
        return "<pre><code>" + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
      }
      return '<pre><code class="language-' + escape$1(lang) + '">' + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
    }
    blockquote(quote) {
      return "<blockquote>\n".concat(quote, "</blockquote>\n");
    }
    html(html3, block2) {
      return html3;
    }
    heading(text, level, raw) {
      return "<h".concat(level, ">").concat(text, "</h").concat(level, ">\n");
    }
    hr() {
      return "<hr>\n";
    }
    list(body, ordered, start2) {
      const type2 = ordered ? "ol" : "ul";
      const startatt = ordered && start2 !== 1 ? ' start="' + start2 + '"' : "";
      return "<" + type2 + startatt + ">\n" + body + "</" + type2 + ">\n";
    }
    listitem(text, task, checked) {
      return "<li>".concat(text, "</li>\n");
    }
    checkbox(checked) {
      return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
    }
    paragraph(text) {
      return "<p>".concat(text, "</p>\n");
    }
    table(header, body) {
      if (body)
        body = "<tbody>".concat(body, "</tbody>");
      return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
    }
    tablerow(content) {
      return "<tr>\n".concat(content, "</tr>\n");
    }
    tablecell(content, flags) {
      const type2 = flags.header ? "th" : "td";
      const tag2 = flags.align ? "<".concat(type2, ' align="').concat(flags.align, '">') : "<".concat(type2, ">");
      return tag2 + content + "</".concat(type2, ">\n");
    }
    /**
     * span level renderer
     */
    strong(text) {
      return "<strong>".concat(text, "</strong>");
    }
    em(text) {
      return "<em>".concat(text, "</em>");
    }
    codespan(text) {
      return "<code>".concat(text, "</code>");
    }
    br() {
      return "<br>";
    }
    del(text) {
      return "<del>".concat(text, "</del>");
    }
    link(href, title, text) {
      const cleanHref = cleanUrl(href);
      if (cleanHref === null) {
        return text;
      }
      href = cleanHref;
      let out = '<a href="' + href + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += ">" + text + "</a>";
      return out;
    }
    image(href, title, text) {
      const cleanHref = cleanUrl(href);
      if (cleanHref === null) {
        return text;
      }
      href = cleanHref;
      let out = '<img src="'.concat(href, '" alt="').concat(text, '"');
      if (title) {
        out += ' title="'.concat(title, '"');
      }
      out += ">";
      return out;
    }
    text(text) {
      return text;
    }
  };
  var _TextRenderer = class {
    // no need for block level renderers
    strong(text) {
      return text;
    }
    em(text) {
      return text;
    }
    codespan(text) {
      return text;
    }
    del(text) {
      return text;
    }
    html(text) {
      return text;
    }
    text(text) {
      return text;
    }
    link(href, title, text) {
      return "" + text;
    }
    image(href, title, text) {
      return "" + text;
    }
    br() {
      return "";
    }
  };
  var _Parser = class __Parser {
    constructor(options2) {
      __publicField(this, "options");
      __publicField(this, "renderer");
      __publicField(this, "textRenderer");
      this.options = options2 || _defaults;
      this.options.renderer = this.options.renderer || new _Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.textRenderer = new _TextRenderer();
    }
    /**
     * Static Parse Method
     */
    static parse(tokens, options2) {
      const parser3 = new __Parser(options2);
      return parser3.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    static parseInline(tokens, options2) {
      const parser3 = new __Parser(options2);
      return parser3.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    parse(tokens, top = true) {
      let out = "";
      for (let i3 = 0; i3 < tokens.length; i3++) {
        const token = tokens[i3];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
          const genericToken = token;
          const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
          if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
            out += ret || "";
            continue;
          }
        }
        switch (token.type) {
          case "space": {
            continue;
          }
          case "hr": {
            out += this.renderer.hr();
            continue;
          }
          case "heading": {
            const headingToken = token;
            out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape2(this.parseInline(headingToken.tokens, this.textRenderer)));
            continue;
          }
          case "code": {
            const codeToken = token;
            out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
            continue;
          }
          case "table": {
            const tableToken = token;
            let header = "";
            let cell = "";
            for (let j2 = 0; j2 < tableToken.header.length; j2++) {
              cell += this.renderer.tablecell(this.parseInline(tableToken.header[j2].tokens), { header: true, align: tableToken.align[j2] });
            }
            header += this.renderer.tablerow(cell);
            let body = "";
            for (let j2 = 0; j2 < tableToken.rows.length; j2++) {
              const row = tableToken.rows[j2];
              cell = "";
              for (let k2 = 0; k2 < row.length; k2++) {
                cell += this.renderer.tablecell(this.parseInline(row[k2].tokens), { header: false, align: tableToken.align[k2] });
              }
              body += this.renderer.tablerow(cell);
            }
            out += this.renderer.table(header, body);
            continue;
          }
          case "blockquote": {
            const blockquoteToken = token;
            const body = this.parse(blockquoteToken.tokens);
            out += this.renderer.blockquote(body);
            continue;
          }
          case "list": {
            const listToken = token;
            const ordered = listToken.ordered;
            const start2 = listToken.start;
            const loose = listToken.loose;
            let body = "";
            for (let j2 = 0; j2 < listToken.items.length; j2++) {
              const item = listToken.items[j2];
              const checked = item.checked;
              const task = item.task;
              let itemBody = "";
              if (item.task) {
                const checkbox = this.renderer.checkbox(!!checked);
                if (loose) {
                  if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                    item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                      item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                    }
                  } else {
                    item.tokens.unshift({
                      type: "text",
                      text: checkbox + " "
                    });
                  }
                } else {
                  itemBody += checkbox + " ";
                }
              }
              itemBody += this.parse(item.tokens, loose);
              body += this.renderer.listitem(itemBody, task, !!checked);
            }
            out += this.renderer.list(body, ordered, start2);
            continue;
          }
          case "html": {
            const htmlToken = token;
            out += this.renderer.html(htmlToken.text, htmlToken.block);
            continue;
          }
          case "paragraph": {
            const paragraphToken = token;
            out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
            continue;
          }
          case "text": {
            let textToken = token;
            let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
            while (i3 + 1 < tokens.length && tokens[i3 + 1].type === "text") {
              textToken = tokens[++i3];
              body += "\n" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
            }
            out += top ? this.renderer.paragraph(body) : body;
            continue;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return "";
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
    /**
     * Parse Inline Tokens
     */
    parseInline(tokens, renderer) {
      renderer = renderer || this.renderer;
      let out = "";
      for (let i3 = 0; i3 < tokens.length; i3++) {
        const token = tokens[i3];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
          const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
          if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
            out += ret || "";
            continue;
          }
        }
        switch (token.type) {
          case "escape": {
            const escapeToken = token;
            out += renderer.text(escapeToken.text);
            break;
          }
          case "html": {
            const tagToken = token;
            out += renderer.html(tagToken.text);
            break;
          }
          case "link": {
            const linkToken = token;
            out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));
            break;
          }
          case "image": {
            const imageToken = token;
            out += renderer.image(imageToken.href, imageToken.title, imageToken.text);
            break;
          }
          case "strong": {
            const strongToken = token;
            out += renderer.strong(this.parseInline(strongToken.tokens, renderer));
            break;
          }
          case "em": {
            const emToken = token;
            out += renderer.em(this.parseInline(emToken.tokens, renderer));
            break;
          }
          case "codespan": {
            const codespanToken = token;
            out += renderer.codespan(codespanToken.text);
            break;
          }
          case "br": {
            out += renderer.br();
            break;
          }
          case "del": {
            const delToken = token;
            out += renderer.del(this.parseInline(delToken.tokens, renderer));
            break;
          }
          case "text": {
            const textToken = token;
            out += renderer.text(textToken.text);
            break;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return "";
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
  };
  var _Hooks = class {
    constructor(options2) {
      __publicField(this, "options");
      this.options = options2 || _defaults;
    }
    /**
     * Process markdown before marked
     */
    preprocess(markdown) {
      return markdown;
    }
    /**
     * Process HTML after marked is finished
     */
    postprocess(html3) {
      return html3;
    }
    /**
     * Process all tokens before walk tokens
     */
    processAllTokens(tokens) {
      return tokens;
    }
  };
  __publicField(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
    "preprocess",
    "postprocess",
    "processAllTokens"
  ]));
  var _parseMarkdown, parseMarkdown_fn, _onError, onError_fn;
  var Marked = class {
    constructor(...args) {
      __privateAdd(this, _parseMarkdown);
      __privateAdd(this, _onError);
      __publicField(this, "defaults", _getDefaults());
      __publicField(this, "options", this.setOptions);
      __publicField(this, "parse", __privateMethod(this, _parseMarkdown, parseMarkdown_fn).call(this, _Lexer.lex, _Parser.parse));
      __publicField(this, "parseInline", __privateMethod(this, _parseMarkdown, parseMarkdown_fn).call(this, _Lexer.lexInline, _Parser.parseInline));
      __publicField(this, "Parser", _Parser);
      __publicField(this, "Renderer", _Renderer);
      __publicField(this, "TextRenderer", _TextRenderer);
      __publicField(this, "Lexer", _Lexer);
      __publicField(this, "Tokenizer", _Tokenizer);
      __publicField(this, "Hooks", _Hooks);
      this.use(...args);
    }
    /**
     * Run callback for every token
     */
    walkTokens(tokens, callback) {
      var _a2, _b;
      let values = [];
      for (const token of tokens) {
        values = values.concat(callback.call(this, token));
        switch (token.type) {
          case "table": {
            const tableToken = token;
            for (const cell of tableToken.header) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
            for (const row of tableToken.rows) {
              for (const cell of row) {
                values = values.concat(this.walkTokens(cell.tokens, callback));
              }
            }
            break;
          }
          case "list": {
            const listToken = token;
            values = values.concat(this.walkTokens(listToken.items, callback));
            break;
          }
          default: {
            const genericToken = token;
            if ((_b = (_a2 = this.defaults.extensions) == null ? void 0 : _a2.childTokens) == null ? void 0 : _b[genericToken.type]) {
              this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                const tokens2 = genericToken[childTokens].flat(Infinity);
                values = values.concat(this.walkTokens(tokens2, callback));
              });
            } else if (genericToken.tokens) {
              values = values.concat(this.walkTokens(genericToken.tokens, callback));
            }
          }
        }
      }
      return values;
    }
    use(...args) {
      const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
      args.forEach((pack) => {
        const opts = { ...pack };
        opts.async = this.defaults.async || opts.async || false;
        if (pack.extensions) {
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if ("renderer" in ext) {
              const prevRenderer = extensions.renderers[ext.name];
              if (prevRenderer) {
                extensions.renderers[ext.name] = function(...args2) {
                  let ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if ("tokenizer" in ext) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              const extLevel = extensions[ext.level];
              if (extLevel) {
                extLevel.unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if ("childTokens" in ext && ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
          opts.extensions = extensions;
        }
        if (pack.renderer) {
          const renderer = this.defaults.renderer || new _Renderer(this.defaults);
          for (const prop in pack.renderer) {
            if (!(prop in renderer)) {
              throw new Error("renderer '".concat(prop, "' does not exist"));
            }
            if (prop === "options") {
              continue;
            }
            const rendererProp = prop;
            const rendererFunc = pack.renderer[rendererProp];
            const prevRenderer = renderer[rendererProp];
            renderer[rendererProp] = (...args2) => {
              let ret = rendererFunc.apply(renderer, args2);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args2);
              }
              return ret || "";
            };
          }
          opts.renderer = renderer;
        }
        if (pack.tokenizer) {
          const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
          for (const prop in pack.tokenizer) {
            if (!(prop in tokenizer)) {
              throw new Error("tokenizer '".concat(prop, "' does not exist"));
            }
            if (["options", "rules", "lexer"].includes(prop)) {
              continue;
            }
            const tokenizerProp = prop;
            const tokenizerFunc = pack.tokenizer[tokenizerProp];
            const prevTokenizer = tokenizer[tokenizerProp];
            tokenizer[tokenizerProp] = (...args2) => {
              let ret = tokenizerFunc.apply(tokenizer, args2);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args2);
              }
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }
        if (pack.hooks) {
          const hooks = this.defaults.hooks || new _Hooks();
          for (const prop in pack.hooks) {
            if (!(prop in hooks)) {
              throw new Error("hook '".concat(prop, "' does not exist"));
            }
            if (prop === "options") {
              continue;
            }
            const hooksProp = prop;
            const hooksFunc = pack.hooks[hooksProp];
            const prevHook = hooks[hooksProp];
            if (_Hooks.passThroughHooks.has(prop)) {
              hooks[hooksProp] = (arg) => {
                if (this.defaults.async) {
                  return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                    return prevHook.call(hooks, ret2);
                  });
                }
                const ret = hooksFunc.call(hooks, arg);
                return prevHook.call(hooks, ret);
              };
            } else {
              hooks[hooksProp] = (...args2) => {
                let ret = hooksFunc.apply(hooks, args2);
                if (ret === false) {
                  ret = prevHook.apply(hooks, args2);
                }
                return ret;
              };
            }
          }
          opts.hooks = hooks;
        }
        if (pack.walkTokens) {
          const walkTokens2 = this.defaults.walkTokens;
          const packWalktokens = pack.walkTokens;
          opts.walkTokens = function(token) {
            let values = [];
            values.push(packWalktokens.call(this, token));
            if (walkTokens2) {
              values = values.concat(walkTokens2.call(this, token));
            }
            return values;
          };
        }
        this.defaults = { ...this.defaults, ...opts };
      });
      return this;
    }
    setOptions(opt) {
      this.defaults = { ...this.defaults, ...opt };
      return this;
    }
    lexer(src, options2) {
      return _Lexer.lex(src, options2 != null ? options2 : this.defaults);
    }
    parser(tokens, options2) {
      return _Parser.parse(tokens, options2 != null ? options2 : this.defaults);
    }
  };
  _parseMarkdown = new WeakSet();
  parseMarkdown_fn = function(lexer2, parser3) {
    return (src, options2) => {
      const origOpt = { ...options2 };
      const opt = { ...this.defaults, ...origOpt };
      if (this.defaults.async === true && origOpt.async === false) {
        if (!opt.silent) {
          console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.");
        }
        opt.async = true;
      }
      const throwError = __privateMethod(this, _onError, onError_fn).call(this, !!opt.silent, !!opt.async);
      if (typeof src === "undefined" || src === null) {
        return throwError(new Error("marked(): input parameter is undefined or null"));
      }
      if (typeof src !== "string") {
        return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
      }
      if (opt.hooks) {
        opt.hooks.options = opt;
      }
      if (opt.async) {
        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser3(tokens, opt)).then((html3) => opt.hooks ? opt.hooks.postprocess(html3) : html3).catch(throwError);
      }
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        let tokens = lexer2(src, opt);
        if (opt.hooks) {
          tokens = opt.hooks.processAllTokens(tokens);
        }
        if (opt.walkTokens) {
          this.walkTokens(tokens, opt.walkTokens);
        }
        let html3 = parser3(tokens, opt);
        if (opt.hooks) {
          html3 = opt.hooks.postprocess(html3);
        }
        return html3;
      } catch (e3) {
        return throwError(e3);
      }
    };
  };
  _onError = new WeakSet();
  onError_fn = function(silent, async) {
    return (e3) => {
      e3.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (silent) {
        const msg = "<p>An error occurred:</p><pre>" + escape$1(e3.message + "", true) + "</pre>";
        if (async) {
          return Promise.resolve(msg);
        }
        return msg;
      }
      if (async) {
        return Promise.reject(e3);
      }
      throw e3;
    };
  };
  var markedInstance = new Marked();
  function marked(src, opt) {
    return markedInstance.parse(src, opt);
  }
  marked.options = marked.setOptions = function(options2) {
    markedInstance.setOptions(options2);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.getDefaults = _getDefaults;
  marked.defaults = _defaults;
  marked.use = function(...args) {
    markedInstance.use(...args);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.walkTokens = function(tokens, callback) {
    return markedInstance.walkTokens(tokens, callback);
  };
  marked.parseInline = markedInstance.parseInline;
  marked.Parser = _Parser;
  marked.parser = _Parser.parse;
  marked.Renderer = _Renderer;
  marked.TextRenderer = _TextRenderer;
  marked.Lexer = _Lexer;
  marked.lexer = _Lexer.lex;
  marked.Tokenizer = _Tokenizer;
  marked.Hooks = _Hooks;
  marked.parse = marked;
  var options = marked.options;
  var setOptions = marked.setOptions;
  var use = marked.use;
  var walkTokens = marked.walkTokens;
  var parseInline = marked.parseInline;
  var parser2 = _Parser.parse;
  var lexer = _Lexer.lex;

  // modules/services/osmose.js
  var tiler3 = utilTiler();
  var dispatch4 = dispatch_default("loaded");
  var _tileZoom3 = 14;
  var _osmoseUrlRoot = "https://osmose.openstreetmap.fr/api/0.3";
  var _osmoseData = { icons: {}, items: [] };
  var _cache3;
  function abortRequest3(controller) {
    if (controller) {
      controller.abort();
    }
  }
  function abortUnwantedRequests3(cache, tiles) {
    Object.keys(cache.inflightTile).forEach((k2) => {
      let wanted = tiles.find((tile) => k2 === tile.id);
      if (!wanted) {
        abortRequest3(cache.inflightTile[k2]);
        delete cache.inflightTile[k2];
      }
    });
  }
  function encodeIssueRtree3(d2) {
    return { minX: d2.loc[0], minY: d2.loc[1], maxX: d2.loc[0], maxY: d2.loc[1], data: d2 };
  }
  function updateRtree3(item, replace) {
    _cache3.rtree.remove(item, (a2, b2) => a2.data.id === b2.data.id);
    if (replace) {
      _cache3.rtree.insert(item);
    }
  }
  function preventCoincident2(loc) {
    let coincident = false;
    do {
      let delta = coincident ? [1e-5, 0] : [0, 1e-5];
      loc = geoVecAdd(loc, delta);
      let bbox2 = geoExtent(loc).bbox();
      coincident = _cache3.rtree.search(bbox2).length;
    } while (coincident);
    return loc;
  }
  var osmose_default = {
    title: "osmose",
    init() {
      _mainFileFetcher.get("qa_data").then((d2) => {
        _osmoseData = d2.osmose;
        _osmoseData.items = Object.keys(d2.osmose.icons).map((s2) => s2.split("-")[0]).reduce((unique, item) => unique.indexOf(item) !== -1 ? unique : [...unique, item], []);
      });
      if (!_cache3) {
        this.reset();
      }
      this.event = utilRebind(this, dispatch4, "on");
    },
    reset() {
      let _strings = {};
      let _colors = {};
      if (_cache3) {
        Object.values(_cache3.inflightTile).forEach(abortRequest3);
        _strings = _cache3.strings;
        _colors = _cache3.colors;
      }
      _cache3 = {
        data: {},
        loadedTile: {},
        inflightTile: {},
        inflightPost: {},
        closed: {},
        rtree: new import_rbush3.default(),
        strings: _strings,
        colors: _colors
      };
    },
    loadIssues(projection2) {
      let params = {
        // Tiles return a maximum # of issues
        // So we want to filter our request for only types iD supports
        item: _osmoseData.items
      };
      let tiles = tiler3.zoomExtent([_tileZoom3, _tileZoom3]).getTiles(projection2);
      abortUnwantedRequests3(_cache3, tiles);
      tiles.forEach((tile) => {
        if (_cache3.loadedTile[tile.id] || _cache3.inflightTile[tile.id])
          return;
        let [x2, y2, z2] = tile.xyz;
        let url = "".concat(_osmoseUrlRoot, "/issues/").concat(z2, "/").concat(x2, "/").concat(y2, ".geojson?") + utilQsString(params);
        let controller = new AbortController();
        _cache3.inflightTile[tile.id] = controller;
        json_default(url, { signal: controller.signal }).then((data) => {
          delete _cache3.inflightTile[tile.id];
          _cache3.loadedTile[tile.id] = true;
          if (data.features) {
            data.features.forEach((issue) => {
              const { item, class: cl, uuid: id2 } = issue.properties;
              const itemType = "".concat(item, "-").concat(cl);
              if (itemType in _osmoseData.icons) {
                let loc = issue.geometry.coordinates;
                loc = preventCoincident2(loc);
                let d2 = new QAItem(loc, this, itemType, id2, { item });
                if (item === 8300 || item === 8360) {
                  d2.elems = [];
                }
                _cache3.data[d2.id] = d2;
                _cache3.rtree.insert(encodeIssueRtree3(d2));
              }
            });
          }
          dispatch4.call("loaded");
        }).catch(() => {
          delete _cache3.inflightTile[tile.id];
          _cache3.loadedTile[tile.id] = true;
        });
      });
    },
    loadIssueDetail(issue) {
      if (issue.elems !== void 0) {
        return Promise.resolve(issue);
      }
      const url = "".concat(_osmoseUrlRoot, "/issue/").concat(issue.id, "?langs=").concat(_mainLocalizer.localeCode());
      const cacheDetails = (data) => {
        issue.elems = data.elems.map((e3) => e3.type.substring(0, 1) + e3.id);
        issue.detail = data.subtitle ? marked(data.subtitle.auto) : "";
        this.replaceItem(issue);
      };
      return json_default(url).then(cacheDetails).then(() => issue);
    },
    loadStrings(locale2 = _mainLocalizer.localeCode()) {
      const items = Object.keys(_osmoseData.icons);
      if (locale2 in _cache3.strings && Object.keys(_cache3.strings[locale2]).length === items.length) {
        return Promise.resolve(_cache3.strings[locale2]);
      }
      if (!(locale2 in _cache3.strings)) {
        _cache3.strings[locale2] = {};
      }
      const allRequests = items.map((itemType) => {
        if (itemType in _cache3.strings[locale2])
          return null;
        const cacheData = (data) => {
          const [cat = { items: [] }] = data.categories;
          const [item2 = { class: [] }] = cat.items;
          const [cl2 = null] = item2.class;
          if (!cl2) {
            console.log("Osmose strings request (".concat(itemType, ") had unexpected data"));
            return;
          }
          const { item: itemInt, color: color2 } = item2;
          if (/^#[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3}/.test(color2)) {
            _cache3.colors[itemInt] = color2;
          }
          const { title, detail, fix, trap } = cl2;
          let issueStrings = {};
          if (title)
            issueStrings.title = title.auto;
          if (detail)
            issueStrings.detail = marked(detail.auto);
          if (trap)
            issueStrings.trap = marked(trap.auto);
          if (fix)
            issueStrings.fix = marked(fix.auto);
          _cache3.strings[locale2][itemType] = issueStrings;
        };
        const [item, cl] = itemType.split("-");
        const url = "".concat(_osmoseUrlRoot, "/items/").concat(item, "/class/").concat(cl, "?langs=").concat(locale2);
        return json_default(url).then(cacheData);
      }).filter(Boolean);
      return Promise.all(allRequests).then(() => _cache3.strings[locale2]);
    },
    getStrings(itemType, locale2 = _mainLocalizer.localeCode()) {
      return locale2 in _cache3.strings ? _cache3.strings[locale2][itemType] : {};
    },
    getColor(itemType) {
      return itemType in _cache3.colors ? _cache3.colors[itemType] : "#FFFFFF";
    },
    postUpdate(issue, callback) {
      if (_cache3.inflightPost[issue.id]) {
        return callback({ message: "Issue update already inflight", status: -2 }, issue);
      }
      const url = "".concat(_osmoseUrlRoot, "/issue/").concat(issue.id, "/").concat(issue.newStatus);
      const controller = new AbortController();
      const after = () => {
        delete _cache3.inflightPost[issue.id];
        this.removeItem(issue);
        if (issue.newStatus === "done") {
          if (!(issue.item in _cache3.closed)) {
            _cache3.closed[issue.item] = 0;
          }
          _cache3.closed[issue.item] += 1;
        }
        if (callback)
          callback(null, issue);
      };
      _cache3.inflightPost[issue.id] = controller;
      fetch(url, { signal: controller.signal }).then(after).catch((err) => {
        delete _cache3.inflightPost[issue.id];
        if (callback)
          callback(err.message);
      });
    },
    // Get all cached QAItems covering the viewport
    getItems(projection2) {
      const viewport = projection2.clipExtent();
      const min3 = [viewport[0][0], viewport[1][1]];
      const max3 = [viewport[1][0], viewport[0][1]];
      const bbox2 = geoExtent(projection2.invert(min3), projection2.invert(max3)).bbox();
      return _cache3.rtree.search(bbox2).map((d2) => d2.data);
    },
    // Get a QAItem from cache
    // NOTE: Don't change method name until UI v3 is merged
    getError(id2) {
      return _cache3.data[id2];
    },
    // get the name of the icon to display for this item
    getIcon(itemType) {
      return _osmoseData.icons[itemType];
    },
    // Replace a single QAItem in the cache
    replaceItem(item) {
      if (!(item instanceof QAItem) || !item.id)
        return;
      _cache3.data[item.id] = item;
      updateRtree3(encodeIssueRtree3(item), true);
      return item;
    },
    // Remove a single QAItem from the cache
    removeItem(item) {
      if (!(item instanceof QAItem) || !item.id)
        return;
      delete _cache3.data[item.id];
      updateRtree3(encodeIssueRtree3(item), false);
    },
    // Used to populate `closed:osmose:*` changeset tags
    getClosedCounts() {
      return _cache3.closed;
    },
    itemURL(item) {
      return "https://osmose.openstreetmap.fr/en/error/".concat(item.id);
    }
  };

  // modules/services/mapillary.js
  var import_pbf = __toESM(require_pbf());
  var import_rbush4 = __toESM(require_rbush_min());
  var import_vector_tile = __toESM(require_vector_tile());
  var accessToken = "MLY|4100327730013843|5bb78b81720791946a9a7b956c57b7cf";
  var apiUrl = "https://graph.mapillary.com/";
  var baseTileUrl = "https://tiles.mapillary.com/maps/vtp";
  var mapFeatureTileUrl = "".concat(baseTileUrl, "/mly_map_feature_point/2/{z}/{x}/{y}?access_token=").concat(accessToken);
  var tileUrl = "".concat(baseTileUrl, "/mly1_public/2/{z}/{x}/{y}?access_token=").concat(accessToken);
  var trafficSignTileUrl = "".concat(baseTileUrl, "/mly_map_feature_traffic_sign/2/{z}/{x}/{y}?access_token=").concat(accessToken);
  var viewercss = "mapillary-js/mapillary.css";
  var viewerjs = "mapillary-js/mapillary.js";
  var minZoom = 14;
  var dispatch5 = dispatch_default("change", "loadedImages", "loadedSigns", "loadedMapFeatures", "bearingChanged", "imageChanged");
  var _loadViewerPromise;
  var _mlyActiveImage;
  var _mlyCache;
  var _mlyFallback = false;
  var _mlyHighlightedDetection;
  var _mlyShowFeatureDetections = false;
  var _mlyShowSignDetections = false;
  var _mlyViewer;
  var _mlyViewerFilter = ["all"];
  function loadTiles(which, url, maxZoom2, projection2) {
    const tiler9 = utilTiler().zoomExtent([minZoom, maxZoom2]).skipNullIsland(true);
    const tiles = tiler9.getTiles(projection2);
    tiles.forEach(function(tile) {
      loadTile(which, url, tile);
    });
  }
  function loadTile(which, url, tile) {
    const cache = _mlyCache.requests;
    const tileId = "".concat(tile.id, "-").concat(which);
    if (cache.loaded[tileId] || cache.inflight[tileId])
      return;
    const controller = new AbortController();
    cache.inflight[tileId] = controller;
    const requestUrl = url.replace("{x}", tile.xyz[0]).replace("{y}", tile.xyz[1]).replace("{z}", tile.xyz[2]);
    fetch(requestUrl, { signal: controller.signal }).then(function(response) {
      if (!response.ok) {
        throw new Error(response.status + " " + response.statusText);
      }
      cache.loaded[tileId] = true;
      delete cache.inflight[tileId];
      return response.arrayBuffer();
    }).then(function(data) {
      if (!data) {
        throw new Error("No Data");
      }
      loadTileDataToCache(data, tile, which);
      if (which === "images") {
        dispatch5.call("loadedImages");
      } else if (which === "signs") {
        dispatch5.call("loadedSigns");
      } else if (which === "points") {
        dispatch5.call("loadedMapFeatures");
      }
    }).catch(function() {
      cache.loaded[tileId] = true;
      delete cache.inflight[tileId];
    });
  }
  function loadTileDataToCache(data, tile, which) {
    const vectorTile = new import_vector_tile.VectorTile(new import_pbf.default(data));
    let features, cache, layer, i3, feature3, loc, d2;
    if (vectorTile.layers.hasOwnProperty("image")) {
      features = [];
      cache = _mlyCache.images;
      layer = vectorTile.layers.image;
      for (i3 = 0; i3 < layer.length; i3++) {
        feature3 = layer.feature(i3).toGeoJSON(tile.xyz[0], tile.xyz[1], tile.xyz[2]);
        loc = feature3.geometry.coordinates;
        d2 = {
          loc,
          captured_at: feature3.properties.captured_at,
          ca: feature3.properties.compass_angle,
          id: feature3.properties.id,
          is_pano: feature3.properties.is_pano,
          sequence_id: feature3.properties.sequence_id
        };
        cache.forImageId[d2.id] = d2;
        features.push({
          minX: loc[0],
          minY: loc[1],
          maxX: loc[0],
          maxY: loc[1],
          data: d2
        });
      }
      if (cache.rtree) {
        cache.rtree.load(features);
      }
    }
    if (vectorTile.layers.hasOwnProperty("sequence")) {
      features = [];
      cache = _mlyCache.sequences;
      layer = vectorTile.layers.sequence;
      for (i3 = 0; i3 < layer.length; i3++) {
        feature3 = layer.feature(i3).toGeoJSON(tile.xyz[0], tile.xyz[1], tile.xyz[2]);
        if (cache.lineString[feature3.properties.id]) {
          cache.lineString[feature3.properties.id].push(feature3);
        } else {
          cache.lineString[feature3.properties.id] = [feature3];
        }
      }
    }
    if (vectorTile.layers.hasOwnProperty("point")) {
      features = [];
      cache = _mlyCache[which];
      layer = vectorTile.layers.point;
      for (i3 = 0; i3 < layer.length; i3++) {
        feature3 = layer.feature(i3).toGeoJSON(tile.xyz[0], tile.xyz[1], tile.xyz[2]);
        loc = feature3.geometry.coordinates;
        d2 = {
          loc,
          id: feature3.properties.id,
          first_seen_at: feature3.properties.first_seen_at,
          last_seen_at: feature3.properties.last_seen_at,
          value: feature3.properties.value
        };
        features.push({
          minX: loc[0],
          minY: loc[1],
          maxX: loc[0],
          maxY: loc[1],
          data: d2
        });
      }
      if (cache.rtree) {
        cache.rtree.load(features);
      }
    }
    if (vectorTile.layers.hasOwnProperty("traffic_sign")) {
      features = [];
      cache = _mlyCache[which];
      layer = vectorTile.layers.traffic_sign;
      for (i3 = 0; i3 < layer.length; i3++) {
        feature3 = layer.feature(i3).toGeoJSON(tile.xyz[0], tile.xyz[1], tile.xyz[2]);
        loc = feature3.geometry.coordinates;
        d2 = {
          loc,
          id: feature3.properties.id,
          first_seen_at: feature3.properties.first_seen_at,
          last_seen_at: feature3.properties.last_seen_at,
          value: feature3.properties.value
        };
        features.push({
          minX: loc[0],
          minY: loc[1],
          maxX: loc[0],
          maxY: loc[1],
          data: d2
        });
      }
      if (cache.rtree) {
        cache.rtree.load(features);
      }
    }
  }
  function loadData(url) {
    return fetch(url).then(function(response) {
      if (!response.ok) {
        throw new Error(response.status + " " + response.statusText);
      }
      return response.json();
    }).then(function(result) {
      if (!result) {
        return [];
      }
      return result.data || [];
    });
  }
  function partitionViewport(projection2) {
    const z2 = geoScaleToZoom(projection2.scale());
    const z22 = Math.ceil(z2 * 2) / 2 + 2.5;
    const tiler9 = utilTiler().zoomExtent([z22, z22]);
    return tiler9.getTiles(projection2).map(function(tile) {
      return tile.extent;
    });
  }
  function searchLimited(limit, projection2, rtree) {
    limit = limit || 5;
    return partitionViewport(projection2).reduce(function(result, extent) {
      const found = rtree.search(extent.bbox()).slice(0, limit).map(function(d2) {
        return d2.data;
      });
      return found.length ? result.concat(found) : result;
    }, []);
  }
  var mapillary_default = {
    // Initialize Mapillary
    init: function() {
      if (!_mlyCache) {
        this.reset();
      }
      this.event = utilRebind(this, dispatch5, "on");
    },
    // Reset cache and state
    reset: function() {
      if (_mlyCache) {
        Object.values(_mlyCache.requests.inflight).forEach(function(request3) {
          request3.abort();
        });
      }
      _mlyCache = {
        images: { rtree: new import_rbush4.default(), forImageId: {} },
        image_detections: { forImageId: {} },
        signs: { rtree: new import_rbush4.default() },
        points: { rtree: new import_rbush4.default() },
        sequences: { rtree: new import_rbush4.default(), lineString: {} },
        requests: { loaded: {}, inflight: {} }
      };
      _mlyActiveImage = null;
    },
    // Get visible images
    images: function(projection2) {
      const limit = 5;
      return searchLimited(limit, projection2, _mlyCache.images.rtree);
    },
    // Get visible traffic signs
    signs: function(projection2) {
      const limit = 5;
      return searchLimited(limit, projection2, _mlyCache.signs.rtree);
    },
    // Get visible map (point) features
    mapFeatures: function(projection2) {
      const limit = 5;
      return searchLimited(limit, projection2, _mlyCache.points.rtree);
    },
    // Get cached image by id
    cachedImage: function(imageId) {
      return _mlyCache.images.forImageId[imageId];
    },
    // Get visible sequences
    sequences: function(projection2) {
      const viewport = projection2.clipExtent();
      const min3 = [viewport[0][0], viewport[1][1]];
      const max3 = [viewport[1][0], viewport[0][1]];
      const bbox2 = geoExtent(projection2.invert(min3), projection2.invert(max3)).bbox();
      const sequenceIds = {};
      let lineStrings = [];
      _mlyCache.images.rtree.search(bbox2).forEach(function(d2) {
        if (d2.data.sequence_id) {
          sequenceIds[d2.data.sequence_id] = true;
        }
      });
      Object.keys(sequenceIds).forEach(function(sequenceId) {
        if (_mlyCache.sequences.lineString[sequenceId]) {
          lineStrings = lineStrings.concat(_mlyCache.sequences.lineString[sequenceId]);
        }
      });
      return lineStrings;
    },
    // Load images in the visible area
    loadImages: function(projection2) {
      loadTiles("images", tileUrl, 14, projection2);
    },
    // Load traffic signs in the visible area
    loadSigns: function(projection2) {
      loadTiles("signs", trafficSignTileUrl, 14, projection2);
    },
    // Load map (point) features in the visible area
    loadMapFeatures: function(projection2) {
      loadTiles("points", mapFeatureTileUrl, 14, projection2);
    },
    // Return a promise that resolves when the image viewer (Mapillary JS) library has finished loading
    ensureViewerLoaded: function(context) {
      if (_loadViewerPromise)
        return _loadViewerPromise;
      const wrap2 = context.container().select(".photoviewer").selectAll(".mly-wrapper").data([0]);
      wrap2.enter().append("div").attr("id", "ideditor-mly").attr("class", "photo-wrapper mly-wrapper").classed("hide", true);
      const that = this;
      _loadViewerPromise = new Promise((resolve, reject) => {
        let loadedCount = 0;
        function loaded() {
          loadedCount += 1;
          if (loadedCount === 2)
            resolve();
        }
        const head = select_default2("head");
        head.selectAll("#ideditor-mapillary-viewercss").data([0]).enter().append("link").attr("id", "ideditor-mapillary-viewercss").attr("rel", "stylesheet").attr("crossorigin", "anonymous").attr("href", context.asset(viewercss)).on("load.serviceMapillary", loaded).on("error.serviceMapillary", function() {
          reject();
        });
        head.selectAll("#ideditor-mapillary-viewerjs").data([0]).enter().append("script").attr("id", "ideditor-mapillary-viewerjs").attr("crossorigin", "anonymous").attr("src", context.asset(viewerjs)).on("load.serviceMapillary", loaded).on("error.serviceMapillary", function() {
          reject();
        });
      }).catch(function() {
        _loadViewerPromise = null;
      }).then(function() {
        that.initViewer(context);
      });
      return _loadViewerPromise;
    },
    // Load traffic sign image sprites
    loadSignResources: function(context) {
      context.ui().svgDefs.addSprites(
        ["mapillary-sprite"],
        false
        /* don't override colors */
      );
      return this;
    },
    // Load map (point) feature image sprites
    loadObjectResources: function(context) {
      context.ui().svgDefs.addSprites(
        ["mapillary-object-sprite"],
        false
        /* don't override colors */
      );
      return this;
    },
    // Remove previous detections in image viewer
    resetTags: function() {
      if (_mlyViewer && !_mlyFallback) {
        _mlyViewer.getComponent("tag").removeAll();
      }
    },
    // Show map feature detections in image viewer
    showFeatureDetections: function(value) {
      _mlyShowFeatureDetections = value;
      if (!_mlyShowFeatureDetections && !_mlyShowSignDetections) {
        this.resetTags();
      }
    },
    // Show traffic sign detections in image viewer
    showSignDetections: function(value) {
      _mlyShowSignDetections = value;
      if (!_mlyShowFeatureDetections && !_mlyShowSignDetections) {
        this.resetTags();
      }
    },
    // Apply filter to image viewer
    filterViewer: function(context) {
      const showsPano = context.photos().showsPanoramic();
      const showsFlat = context.photos().showsFlat();
      const fromDate = context.photos().fromDate();
      const toDate = context.photos().toDate();
      const filter2 = ["all"];
      if (!showsPano)
        filter2.push(["!=", "cameraType", "spherical"]);
      if (!showsFlat && showsPano)
        filter2.push(["==", "pano", true]);
      if (fromDate) {
        filter2.push([">=", "capturedAt", new Date(fromDate).getTime()]);
      }
      if (toDate) {
        filter2.push([">=", "capturedAt", new Date(toDate).getTime()]);
      }
      if (_mlyViewer) {
        _mlyViewer.setFilter(filter2);
      }
      _mlyViewerFilter = filter2;
      return filter2;
    },
    // Make the image viewer visible
    showViewer: function(context) {
      const wrap2 = context.container().select(".photoviewer").classed("hide", false);
      const isHidden = wrap2.selectAll(".photo-wrapper.mly-wrapper.hide").size();
      if (isHidden && _mlyViewer) {
        wrap2.selectAll(".photo-wrapper:not(.mly-wrapper)").classed("hide", true);
        wrap2.selectAll(".photo-wrapper.mly-wrapper").classed("hide", false);
        _mlyViewer.resize();
      }
      return this;
    },
    // Hide the image viewer and resets map markers
    hideViewer: function(context) {
      _mlyActiveImage = null;
      if (!_mlyFallback && _mlyViewer) {
        _mlyViewer.getComponent("sequence").stop();
      }
      const viewer = context.container().select(".photoviewer");
      if (!viewer.empty())
        viewer.datum(null);
      viewer.classed("hide", true).selectAll(".photo-wrapper").classed("hide", true);
      this.updateUrlImage(null);
      dispatch5.call("imageChanged");
      dispatch5.call("loadedMapFeatures");
      dispatch5.call("loadedSigns");
      return this.setStyles(context, null);
    },
    // Update the URL with current image id
    updateUrlImage: function(imageId) {
      if (!window.mocha) {
        const hash = utilStringQs(window.location.hash);
        if (imageId) {
          hash.photo = "mapillary/" + imageId;
        } else {
          delete hash.photo;
        }
        window.location.replace("#" + utilQsString(hash, true));
      }
    },
    // Highlight the detection in the viewer that is related to the clicked map feature
    highlightDetection: function(detection) {
      if (detection) {
        _mlyHighlightedDetection = detection.id;
      }
      return this;
    },
    // Initialize image viewer (Mapillar JS)
    initViewer: function(context) {
      const that = this;
      if (!window.mapillary)
        return;
      const opts = {
        accessToken,
        component: {
          cover: false,
          keyboard: false,
          tag: true
        },
        container: "ideditor-mly"
      };
      if (!mapillary.isSupported() && mapillary.isFallbackSupported()) {
        _mlyFallback = true;
        opts.component = {
          cover: false,
          direction: false,
          imagePlane: false,
          keyboard: false,
          mouse: false,
          sequence: false,
          tag: false,
          image: true,
          // fallback
          navigation: true
          // fallback
        };
      }
      _mlyViewer = new mapillary.Viewer(opts);
      _mlyViewer.on("image", imageChanged);
      _mlyViewer.on("bearing", bearingChanged);
      if (_mlyViewerFilter) {
        _mlyViewer.setFilter(_mlyViewerFilter);
      }
      context.ui().photoviewer.on("resize.mapillary", function() {
        if (_mlyViewer)
          _mlyViewer.resize();
      });
      function imageChanged(node) {
        that.resetTags();
        const image = node.image;
        that.setActiveImage(image);
        that.setStyles(context, null);
        const loc = [image.originalLngLat.lng, image.originalLngLat.lat];
        context.map().centerEase(loc);
        that.updateUrlImage(image.id);
        if (_mlyShowFeatureDetections || _mlyShowSignDetections) {
          that.updateDetections(image.id, "".concat(apiUrl, "/").concat(image.id, "/detections?access_token=").concat(accessToken, "&fields=id,image,geometry,value"));
        }
        dispatch5.call("imageChanged");
      }
      function bearingChanged(e3) {
        dispatch5.call("bearingChanged", void 0, e3);
      }
    },
    // Move to an image
    selectImage: function(context, imageId) {
      if (_mlyViewer && imageId) {
        _mlyViewer.moveTo(imageId).catch(function(e3) {
          console.error("mly3", e3);
        });
      }
      return this;
    },
    // Return the currently displayed image
    getActiveImage: function() {
      return _mlyActiveImage;
    },
    // Return a list of detection objects for the given id
    getDetections: function(id2) {
      return loadData("".concat(apiUrl, "/").concat(id2, "/detections?access_token=").concat(accessToken, "&fields=id,value,image"));
    },
    // Set the currently visible image
    setActiveImage: function(image) {
      if (image) {
        _mlyActiveImage = {
          ca: image.originalCompassAngle,
          id: image.id,
          loc: [image.originalLngLat.lng, image.originalLngLat.lat],
          is_pano: image.cameraType === "spherical",
          sequence_id: image.sequenceId
        };
      } else {
        _mlyActiveImage = null;
      }
    },
    // Update the currently highlighted sequence and selected bubble.
    setStyles: function(context, hovered) {
      const hoveredImageId = hovered && hovered.id;
      const hoveredSequenceId = hovered && hovered.sequence_id;
      const selectedSequenceId = _mlyActiveImage && _mlyActiveImage.sequence_id;
      context.container().selectAll(".layer-mapillary .viewfield-group").classed("highlighted", function(d2) {
        return d2.sequence_id === selectedSequenceId || d2.id === hoveredImageId;
      }).classed("hovered", function(d2) {
        return d2.id === hoveredImageId;
      });
      context.container().selectAll(".layer-mapillary .sequence").classed("highlighted", function(d2) {
        return d2.properties.id === hoveredSequenceId;
      }).classed("currentView", function(d2) {
        return d2.properties.id === selectedSequenceId;
      });
      return this;
    },
    // Get detections for the current image and shows them in the image viewer
    updateDetections: function(imageId, url) {
      if (!_mlyViewer || _mlyFallback)
        return;
      if (!imageId)
        return;
      const cache = _mlyCache.image_detections;
      if (cache.forImageId[imageId]) {
        showDetections(_mlyCache.image_detections.forImageId[imageId]);
      } else {
        loadData(url).then((detections) => {
          detections.forEach(function(detection) {
            if (!cache.forImageId[imageId]) {
              cache.forImageId[imageId] = [];
            }
            cache.forImageId[imageId].push({
              geometry: detection.geometry,
              id: detection.id,
              image_id: imageId,
              value: detection.value
            });
          });
          showDetections(_mlyCache.image_detections.forImageId[imageId] || []);
        });
      }
      function showDetections(detections) {
        const tagComponent = _mlyViewer.getComponent("tag");
        detections.forEach(function(data) {
          const tag2 = makeTag(data);
          if (tag2) {
            tagComponent.add([tag2]);
          }
        });
      }
      function makeTag(data) {
        const valueParts = data.value.split("--");
        if (!valueParts.length)
          return;
        let tag2;
        let text;
        let color2 = 16777215;
        if (_mlyHighlightedDetection === data.id) {
          color2 = 16776960;
          text = valueParts[1];
          if (text === "flat" || text === "discrete" || text === "sign") {
            text = valueParts[2];
          }
          text = text.replace(/-/g, " ");
          text = text.charAt(0).toUpperCase() + text.slice(1);
          _mlyHighlightedDetection = null;
        }
        var decodedGeometry = window.atob(data.geometry);
        var uintArray = new Uint8Array(decodedGeometry.length);
        for (var i3 = 0; i3 < decodedGeometry.length; i3++) {
          uintArray[i3] = decodedGeometry.charCodeAt(i3);
        }
        const tile = new import_vector_tile.VectorTile(new import_pbf.default(uintArray.buffer));
        const layer = tile.layers["mpy-or"];
        const geometries = layer.feature(0).loadGeometry();
        const polygon2 = geometries.map((ring) => ring.map((point2) => [point2.x / layer.extent, point2.y / layer.extent]));
        tag2 = new mapillary.OutlineTag(
          data.id,
          new mapillary.PolygonGeometry(polygon2[0]),
          {
            text,
            textColor: color2,
            lineColor: color2,
            lineWidth: 2,
            fillColor: color2,
            fillOpacity: 0.3
          }
        );
        return tag2;
      }
    },
    // Return the current cache
    cache: function() {
      return _mlyCache;
    }
  };

  // modules/core/validation/models.js
  function validationIssue(attrs) {
    this.type = attrs.type;
    this.subtype = attrs.subtype;
    this.severity = attrs.severity;
    this.message = attrs.message;
    this.reference = attrs.reference;
    this.entityIds = attrs.entityIds;
    this.loc = attrs.loc;
    this.data = attrs.data;
    this.dynamicFixes = attrs.dynamicFixes;
    this.hash = attrs.hash;
    this.id = generateID.apply(this);
    this.key = generateKey.apply(this);
    this.autoFix = null;
    function generateID() {
      var parts = [this.type];
      if (this.hash) {
        parts.push(this.hash);
      }
      if (this.subtype) {
        parts.push(this.subtype);
      }
      if (this.entityIds) {
        var entityKeys = this.entityIds.slice().sort();
        parts.push.apply(parts, entityKeys);
      }
      return parts.join(":");
    }
    function generateKey() {
      return this.id + ":" + Date.now().toString();
    }
    this.extent = function(resolver) {
      if (this.loc) {
        return geoExtent(this.loc);
      }
      if (this.entityIds && this.entityIds.length) {
        return this.entityIds.reduce(function(extent, entityId) {
          return extent.extend(resolver.entity(entityId).extent(resolver));
        }, geoExtent());
      }
      return null;
    };
    this.fixes = function(context) {
      var fixes = this.dynamicFixes ? this.dynamicFixes(context) : [];
      var issue = this;
      if (issue.severity === "warning") {
        fixes.push(new validationIssueFix({
          title: _t.append("issues.fix.ignore_issue.title"),
          icon: "iD-icon-close",
          onClick: function() {
            context.validator().ignoreIssue(this.issue.id);
          }
        }));
      }
      fixes.forEach(function(fix) {
        fix.id = fix.title.stringId;
        fix.issue = issue;
        if (fix.autoArgs) {
          issue.autoFix = fix;
        }
      });
      return fixes;
    };
  }
  function validationIssueFix(attrs) {
    this.title = attrs.title;
    this.onClick = attrs.onClick;
    this.disabledReason = attrs.disabledReason;
    this.icon = attrs.icon;
    this.entityIds = attrs.entityIds || [];
    this.autoArgs = attrs.autoArgs;
    this.issue = null;
  }

  // modules/services/maprules.js
  var buildRuleChecks = function() {
    return {
      equals: function(equals) {
        return function(tags) {
          return Object.keys(equals).every(function(k2) {
            return equals[k2] === tags[k2];
          });
        };
      },
      notEquals: function(notEquals) {
        return function(tags) {
          return Object.keys(notEquals).some(function(k2) {
            return notEquals[k2] !== tags[k2];
          });
        };
      },
      absence: function(absence) {
        return function(tags) {
          return Object.keys(tags).indexOf(absence) === -1;
        };
      },
      presence: function(presence) {
        return function(tags) {
          return Object.keys(tags).indexOf(presence) > -1;
        };
      },
      greaterThan: function(greaterThan) {
        var key = Object.keys(greaterThan)[0];
        var value = greaterThan[key];
        return function(tags) {
          return tags[key] > value;
        };
      },
      greaterThanEqual: function(greaterThanEqual) {
        var key = Object.keys(greaterThanEqual)[0];
        var value = greaterThanEqual[key];
        return function(tags) {
          return tags[key] >= value;
        };
      },
      lessThan: function(lessThan) {
        var key = Object.keys(lessThan)[0];
        var value = lessThan[key];
        return function(tags) {
          return tags[key] < value;
        };
      },
      lessThanEqual: function(lessThanEqual) {
        var key = Object.keys(lessThanEqual)[0];
        var value = lessThanEqual[key];
        return function(tags) {
          return tags[key] <= value;
        };
      },
      positiveRegex: function(positiveRegex) {
        var tagKey = Object.keys(positiveRegex)[0];
        var expression = positiveRegex[tagKey].join("|");
        var regex = new RegExp(expression);
        return function(tags) {
          return regex.test(tags[tagKey]);
        };
      },
      negativeRegex: function(negativeRegex) {
        var tagKey = Object.keys(negativeRegex)[0];
        var expression = negativeRegex[tagKey].join("|");
        var regex = new RegExp(expression);
        return function(tags) {
          return !regex.test(tags[tagKey]);
        };
      }
    };
  };
  var buildLineKeys = function() {
    return {
      highway: {
        rest_area: true,
        services: true
      },
      railway: {
        roundhouse: true,
        station: true,
        traverser: true,
        turntable: true,
        wash: true
      }
    };
  };
  var maprules_default = {
    init: function() {
      this._ruleChecks = buildRuleChecks();
      this._validationRules = [];
      this._areaKeys = osmAreaKeys;
      this._lineKeys = buildLineKeys();
    },
    // list of rules only relevant to tag checks...
    filterRuleChecks: function(selector) {
      var _ruleChecks = this._ruleChecks;
      return Object.keys(selector).reduce(function(rules, key) {
        if (["geometry", "error", "warning"].indexOf(key) === -1) {
          rules.push(_ruleChecks[key](selector[key]));
        }
        return rules;
      }, []);
    },
    // builds tagMap from mapcss-parse selector object...
    buildTagMap: function(selector) {
      var getRegexValues = function(regexes) {
        return regexes.map(function(regex) {
          return regex.replace(/\$|\^/g, "");
        });
      };
      var tagMap = Object.keys(selector).reduce(function(expectedTags, key) {
        var values;
        var isRegex = /regex/gi.test(key);
        var isEqual4 = /equals/gi.test(key);
        if (isRegex || isEqual4) {
          Object.keys(selector[key]).forEach(function(selectorKey) {
            values = isEqual4 ? [selector[key][selectorKey]] : getRegexValues(selector[key][selectorKey]);
            if (expectedTags.hasOwnProperty(selectorKey)) {
              values = values.concat(expectedTags[selectorKey]);
            }
            expectedTags[selectorKey] = values;
          });
        } else if (/(greater|less)Than(Equal)?|presence/g.test(key)) {
          var tagKey = /presence/.test(key) ? selector[key] : Object.keys(selector[key])[0];
          values = [selector[key][tagKey]];
          if (expectedTags.hasOwnProperty(tagKey)) {
            values = values.concat(expectedTags[tagKey]);
          }
          expectedTags[tagKey] = values;
        }
        return expectedTags;
      }, {});
      return tagMap;
    },
    // inspired by osmWay#isArea()
    inferGeometry: function(tagMap) {
      var _lineKeys = this._lineKeys;
      var _areaKeys = this._areaKeys;
      var keyValueDoesNotImplyArea = function(key2) {
        return utilArrayIntersection(tagMap[key2], Object.keys(_areaKeys[key2])).length > 0;
      };
      var keyValueImpliesLine = function(key2) {
        return utilArrayIntersection(tagMap[key2], Object.keys(_lineKeys[key2])).length > 0;
      };
      if (tagMap.hasOwnProperty("area")) {
        if (tagMap.area.indexOf("yes") > -1) {
          return "area";
        }
        if (tagMap.area.indexOf("no") > -1) {
          return "line";
        }
      }
      for (var key in tagMap) {
        if (key in _areaKeys && !keyValueDoesNotImplyArea(key)) {
          return "area";
        }
        if (key in _lineKeys && keyValueImpliesLine(key)) {
          return "area";
        }
      }
      return "line";
    },
    // adds from mapcss-parse selector check...
    addRule: function(selector) {
      var rule = {
        // checks relevant to mapcss-selector
        checks: this.filterRuleChecks(selector),
        // true if all conditions for a tag error are true..
        matches: function(entity) {
          return this.checks.every(function(check) {
            return check(entity.tags);
          });
        },
        // borrowed from Way#isArea()
        inferredGeometry: this.inferGeometry(this.buildTagMap(selector), this._areaKeys),
        geometryMatches: function(entity, graph) {
          if (entity.type === "node" || entity.type === "relation") {
            return selector.geometry === entity.type;
          } else if (entity.type === "way") {
            return this.inferredGeometry === entity.geometry(graph);
          }
        },
        // when geometries match and tag matches are present, return a warning...
        findIssues: function(entity, graph, issues) {
          if (this.geometryMatches(entity, graph) && this.matches(entity)) {
            var severity = Object.keys(selector).indexOf("error") > -1 ? "error" : "warning";
            var message = selector[severity];
            issues.push(new validationIssue({
              type: "maprules",
              severity,
              message: function() {
                return message;
              },
              entityIds: [entity.id]
            }));
          }
        }
      };
      this._validationRules.push(rule);
    },
    clearRules: function() {
      this._validationRules = [];
    },
    // returns validationRules...
    validationRules: function() {
      return this._validationRules;
    },
    // returns ruleChecks
    ruleChecks: function() {
      return this._ruleChecks;
    }
  };

  // modules/services/nominatim.js
  var import_rbush7 = __toESM(require_rbush_min());

  // modules/core/difference.js
  var import_fast_deep_equal3 = __toESM(require_fast_deep_equal());
  function coreDifference(base, head) {
    var _changes = {};
    var _didChange = {};
    var _diff = {};
    function checkEntityID(id2) {
      var h2 = head.entities[id2];
      var b2 = base.entities[id2];
      if (h2 === b2)
        return;
      if (_changes[id2])
        return;
      if (!h2 && b2) {
        _changes[id2] = { base: b2, head: h2 };
        _didChange.deletion = true;
        return;
      }
      if (h2 && !b2) {
        _changes[id2] = { base: b2, head: h2 };
        _didChange.addition = true;
        return;
      }
      if (h2 && b2) {
        if (h2.members && b2.members && !(0, import_fast_deep_equal3.default)(h2.members, b2.members)) {
          _changes[id2] = { base: b2, head: h2 };
          _didChange.geometry = true;
          _didChange.properties = true;
          return;
        }
        if (h2.loc && b2.loc && !geoVecEqual(h2.loc, b2.loc)) {
          _changes[id2] = { base: b2, head: h2 };
          _didChange.geometry = true;
        }
        if (h2.nodes && b2.nodes && !(0, import_fast_deep_equal3.default)(h2.nodes, b2.nodes)) {
          _changes[id2] = { base: b2, head: h2 };
          _didChange.geometry = true;
        }
        if (h2.tags && b2.tags && !(0, import_fast_deep_equal3.default)(h2.tags, b2.tags)) {
          _changes[id2] = { base: b2, head: h2 };
          _didChange.properties = true;
        }
      }
    }
    function load() {
      var ids = utilArrayUniq(Object.keys(head.entities).concat(Object.keys(base.entities)));
      for (var i3 = 0; i3 < ids.length; i3++) {
        checkEntityID(ids[i3]);
      }
    }
    load();
    _diff.length = function length2() {
      return Object.keys(_changes).length;
    };
    _diff.changes = function changes() {
      return _changes;
    };
    _diff.didChange = _didChange;
    _diff.extantIDs = function extantIDs(includeRelMembers) {
      var result = /* @__PURE__ */ new Set();
      Object.keys(_changes).forEach(function(id2) {
        if (_changes[id2].head) {
          result.add(id2);
        }
        var h2 = _changes[id2].head;
        var b2 = _changes[id2].base;
        var entity = h2 || b2;
        if (includeRelMembers && entity.type === "relation") {
          var mh = h2 ? h2.members.map(function(m2) {
            return m2.id;
          }) : [];
          var mb = b2 ? b2.members.map(function(m2) {
            return m2.id;
          }) : [];
          utilArrayUnion(mh, mb).forEach(function(memberID) {
            if (head.hasEntity(memberID)) {
              result.add(memberID);
            }
          });
        }
      });
      return Array.from(result);
    };
    _diff.modified = function modified() {
      var result = [];
      Object.values(_changes).forEach(function(change) {
        if (change.base && change.head) {
          result.push(change.head);
        }
      });
      return result;
    };
    _diff.created = function created() {
      var result = [];
      Object.values(_changes).forEach(function(change) {
        if (!change.base && change.head) {
          result.push(change.head);
        }
      });
      return result;
    };
    _diff.deleted = function deleted() {
      var result = [];
      Object.values(_changes).forEach(function(change) {
        if (change.base && !change.head) {
          result.push(change.base);
        }
      });
      return result;
    };
    _diff.summary = function summary() {
      var relevant = {};
      var keys2 = Object.keys(_changes);
      for (var i3 = 0; i3 < keys2.length; i3++) {
        var change = _changes[keys2[i3]];
        if (change.head && change.head.geometry(head) !== "vertex") {
          addEntity(change.head, head, change.base ? "modified" : "created");
        } else if (change.base && change.base.geometry(base) !== "vertex") {
          addEntity(change.base, base, "deleted");
        } else if (change.base && change.head) {
          var moved = !(0, import_fast_deep_equal3.default)(change.base.loc, change.head.loc);
          var retagged = !(0, import_fast_deep_equal3.default)(change.base.tags, change.head.tags);
          if (moved) {
            addParents(change.head);
          }
          if (retagged || moved && change.head.hasInterestingTags()) {
            addEntity(change.head, head, "modified");
          }
        } else if (change.head && change.head.hasInterestingTags()) {
          addEntity(change.head, head, "created");
        } else if (change.base && change.base.hasInterestingTags()) {
          addEntity(change.base, base, "deleted");
        }
      }
      return Object.values(relevant);
      function addEntity(entity, graph, changeType) {
        relevant[entity.id] = {
          entity,
          graph,
          changeType
        };
      }
      function addParents(entity) {
        var parents = head.parentWays(entity);
        for (var j2 = parents.length - 1; j2 >= 0; j2--) {
          var parent = parents[j2];
          if (!(parent.id in relevant)) {
            addEntity(parent, head, "modified");
          }
        }
      }
    };
    _diff.complete = function complete(extent) {
      var result = {};
      var id2, change;
      for (id2 in _changes) {
        change = _changes[id2];
        var h2 = change.head;
        var b2 = change.base;
        var entity = h2 || b2;
        var i3;
        if (extent && (!h2 || !h2.intersects(extent, head)) && (!b2 || !b2.intersects(extent, base))) {
          continue;
        }
        result[id2] = h2;
        if (entity.type === "way") {
          var nh = h2 ? h2.nodes : [];
          var nb = b2 ? b2.nodes : [];
          var diff;
          diff = utilArrayDifference(nh, nb);
          for (i3 = 0; i3 < diff.length; i3++) {
            result[diff[i3]] = head.hasEntity(diff[i3]);
          }
          diff = utilArrayDifference(nb, nh);
          for (i3 = 0; i3 < diff.length; i3++) {
            result[diff[i3]] = head.hasEntity(diff[i3]);
          }
        }
        if (entity.type === "relation" && entity.isMultipolygon()) {
          var mh = h2 ? h2.members.map(function(m2) {
            return m2.id;
          }) : [];
          var mb = b2 ? b2.members.map(function(m2) {
            return m2.id;
          }) : [];
          var ids = utilArrayUnion(mh, mb);
          for (i3 = 0; i3 < ids.length; i3++) {
            var member = head.hasEntity(ids[i3]);
            if (!member)
              continue;
            if (extent && !member.intersects(extent, head))
              continue;
            result[ids[i3]] = member;
          }
        }
        addParents(head.parentWays(entity), result);
        addParents(head.parentRelations(entity), result);
      }
      return result;
      function addParents(parents, result2) {
        for (var i4 = 0; i4 < parents.length; i4++) {
          var parent = parents[i4];
          if (parent.id in result2)
            continue;
          result2[parent.id] = parent;
          addParents(head.parentRelations(parent), result2);
        }
      }
    };
    return _diff;
  }

  // modules/core/tree.js
  var import_rbush5 = __toESM(require_rbush_min());
  function coreTree(head) {
    var _rtree = new import_rbush5.default();
    var _bboxes = {};
    var _segmentsRTree = new import_rbush5.default();
    var _segmentsBBoxes = {};
    var _segmentsByWayId = {};
    var tree = {};
    function entityBBox(entity) {
      var bbox2 = entity.extent(head).bbox();
      bbox2.id = entity.id;
      _bboxes[entity.id] = bbox2;
      return bbox2;
    }
    function segmentBBox(segment) {
      var extent = segment.extent(head);
      if (!extent)
        return null;
      var bbox2 = extent.bbox();
      bbox2.segment = segment;
      _segmentsBBoxes[segment.id] = bbox2;
      return bbox2;
    }
    function removeEntity(entity) {
      _rtree.remove(_bboxes[entity.id]);
      delete _bboxes[entity.id];
      if (_segmentsByWayId[entity.id]) {
        _segmentsByWayId[entity.id].forEach(function(segment) {
          _segmentsRTree.remove(_segmentsBBoxes[segment.id]);
          delete _segmentsBBoxes[segment.id];
        });
        delete _segmentsByWayId[entity.id];
      }
    }
    function loadEntities(entities) {
      _rtree.load(entities.map(entityBBox));
      var segments = [];
      entities.forEach(function(entity) {
        if (entity.segments) {
          var entitySegments = entity.segments(head);
          _segmentsByWayId[entity.id] = entitySegments;
          segments = segments.concat(entitySegments);
        }
      });
      if (segments.length)
        _segmentsRTree.load(segments.map(segmentBBox).filter(Boolean));
    }
    function updateParents(entity, insertions, memo) {
      head.parentWays(entity).forEach(function(way) {
        if (_bboxes[way.id]) {
          removeEntity(way);
          insertions[way.id] = way;
        }
        updateParents(way, insertions, memo);
      });
      head.parentRelations(entity).forEach(function(relation) {
        if (memo[entity.id])
          return;
        memo[entity.id] = true;
        if (_bboxes[relation.id]) {
          removeEntity(relation);
          insertions[relation.id] = relation;
        }
        updateParents(relation, insertions, memo);
      });
    }
    tree.rebase = function(entities, force) {
      var insertions = {};
      for (var i3 = 0; i3 < entities.length; i3++) {
        var entity = entities[i3];
        if (!entity.visible)
          continue;
        if (head.entities.hasOwnProperty(entity.id) || _bboxes[entity.id]) {
          if (!force) {
            continue;
          } else if (_bboxes[entity.id]) {
            removeEntity(entity);
          }
        }
        insertions[entity.id] = entity;
        updateParents(entity, insertions, {});
      }
      loadEntities(Object.values(insertions));
      return tree;
    };
    function updateToGraph(graph) {
      if (graph === head)
        return;
      var diff = coreDifference(head, graph);
      head = graph;
      var changed = diff.didChange;
      if (!changed.addition && !changed.deletion && !changed.geometry)
        return;
      var insertions = {};
      if (changed.deletion) {
        diff.deleted().forEach(function(entity) {
          removeEntity(entity);
        });
      }
      if (changed.geometry) {
        diff.modified().forEach(function(entity) {
          removeEntity(entity);
          insertions[entity.id] = entity;
          updateParents(entity, insertions, {});
        });
      }
      if (changed.addition) {
        diff.created().forEach(function(entity) {
          insertions[entity.id] = entity;
        });
      }
      loadEntities(Object.values(insertions));
    }
    tree.intersects = function(extent, graph) {
      updateToGraph(graph);
      return _rtree.search(extent.bbox()).map(function(bbox2) {
        return graph.entity(bbox2.id);
      });
    };
    tree.waySegments = function(extent, graph) {
      updateToGraph(graph);
      return _segmentsRTree.search(extent.bbox()).map(function(bbox2) {
        return bbox2.segment;
      });
    };
    return tree;
  }

  // modules/svg/icon.js
  function svgIcon(name, svgklass, useklass) {
    return function drawIcon(selection2) {
      selection2.selectAll("svg.icon" + (svgklass ? "." + svgklass.split(" ")[0] : "")).data([0]).enter().append("svg").attr("class", "icon " + (svgklass || "")).append("use").attr("xlink:href", name).attr("class", useklass);
    };
  }

  // modules/ui/modal.js
  function uiModal(selection2, blocking) {
    let keybinding = utilKeybinding("modal");
    let previous = selection2.select("div.modal");
    let animate = previous.empty();
    previous.transition().duration(200).style("opacity", 0).remove();
    let shaded = selection2.append("div").attr("class", "shaded").style("opacity", 0);
    shaded.close = () => {
      shaded.transition().duration(200).style("opacity", 0).remove();
      modal.transition().duration(200).style("top", "0px");
      select_default2(document).call(keybinding.unbind);
    };
    let modal = shaded.append("div").attr("class", "modal fillL");
    modal.append("input").attr("class", "keytrap keytrap-first").on("focus.keytrap", moveFocusToLast);
    if (!blocking) {
      shaded.on("click.remove-modal", (d3_event) => {
        if (d3_event.target === this) {
          shaded.close();
        }
      });
      modal.append("button").attr("class", "close").attr("title", _t("icons.close")).on("click", shaded.close).call(svgIcon("#iD-icon-close"));
      keybinding.on("\u232B", shaded.close).on("\u238B", shaded.close);
      select_default2(document).call(keybinding);
    }
    modal.append("div").attr("class", "content");
    modal.append("input").attr("class", "keytrap keytrap-last").on("focus.keytrap", moveFocusToFirst);
    if (animate) {
      shaded.transition().style("opacity", 1);
    } else {
      shaded.style("opacity", 1);
    }
    return shaded;
    function moveFocusToFirst() {
      let node = modal.select("a, button, input:not(.keytrap), select, textarea").node();
      if (node) {
        node.focus();
      } else {
        select_default2(this).node().blur();
      }
    }
    function moveFocusToLast() {
      let nodes = modal.selectAll("a, button, input:not(.keytrap), select, textarea").nodes();
      if (nodes.length) {
        nodes[nodes.length - 1].focus();
      } else {
        select_default2(this).node().blur();
      }
    }
  }

  // modules/ui/loading.js
  function uiLoading(context) {
    let _modalSelection = select_default2(null);
    let _message = "";
    let _blocking = false;
    let loading = (selection2) => {
      _modalSelection = uiModal(selection2, _blocking);
      let loadertext = _modalSelection.select(".content").classed("loading-modal", true).append("div").attr("class", "modal-section fillL");
      loadertext.append("img").attr("class", "loader").attr("src", context.imagePath("loader-white.gif"));
      loadertext.append("h3").html(_message);
      _modalSelection.select("button.close").attr("class", "hide");
      return loading;
    };
    loading.message = function(val) {
      if (!arguments.length)
        return _message;
      _message = val;
      return loading;
    };
    loading.blocking = function(val) {
      if (!arguments.length)
        return _blocking;
      _blocking = val;
      return loading;
    };
    loading.close = () => {
      _modalSelection.remove();
    };
    loading.isShown = () => {
      return _modalSelection && !_modalSelection.empty() && _modalSelection.node().parentNode;
    };
    return loading;
  }

  // modules/core/history.js
  function coreHistory(context) {
    var dispatch14 = dispatch_default("reset", "change", "merge", "restore", "undone", "redone", "storage_error");
    var lock = utilSessionMutex("lock");
    var _hasUnresolvedRestorableChanges = lock.lock() && !!corePreferences(getKey("saved_history"));
    var duration = 150;
    var _imageryUsed = [];
    var _photoOverlaysUsed = [];
    var _checkpoints = {};
    var _pausedGraph;
    var _stack;
    var _index;
    var _tree;
    function _act(actions, t2) {
      actions = Array.prototype.slice.call(actions);
      var annotation;
      if (typeof actions[actions.length - 1] !== "function") {
        annotation = actions.pop();
      }
      var graph = _stack[_index].graph;
      for (var i3 = 0; i3 < actions.length; i3++) {
        graph = actions[i3](graph, t2);
      }
      return {
        graph,
        annotation,
        imageryUsed: _imageryUsed,
        photoOverlaysUsed: _photoOverlaysUsed,
        transform: context.projection.transform(),
        selectedIDs: context.selectedIDs()
      };
    }
    function _perform(args, t2) {
      var previous = _stack[_index].graph;
      _stack = _stack.slice(0, _index + 1);
      var actionResult = _act(args, t2);
      _stack.push(actionResult);
      _index++;
      return change(previous);
    }
    function _replace(args, t2) {
      var previous = _stack[_index].graph;
      var actionResult = _act(args, t2);
      _stack[_index] = actionResult;
      return change(previous);
    }
    function _overwrite(args, t2) {
      var previous = _stack[_index].graph;
      if (_index > 0) {
        _index--;
        _stack.pop();
      }
      _stack = _stack.slice(0, _index + 1);
      var actionResult = _act(args, t2);
      _stack.push(actionResult);
      _index++;
      return change(previous);
    }
    function change(previous) {
      var difference2 = coreDifference(previous, history.graph());
      if (!_pausedGraph) {
        dispatch14.call("change", this, difference2);
      }
      return difference2;
    }
    function getKey(n3) {
      return "iD_" + window.location.origin + "_" + n3;
    }
    var history = {
      graph: function() {
        return _stack[_index].graph;
      },
      tree: function() {
        return _tree;
      },
      base: function() {
        return _stack[0].graph;
      },
      merge: function(entities) {
        var stack = _stack.map(function(state) {
          return state.graph;
        });
        _stack[0].graph.rebase(entities, stack, false);
        _tree.rebase(entities, false);
        dispatch14.call("merge", this, entities);
      },
      perform: function() {
        select_default2(document).interrupt("history.perform");
        var transitionable = false;
        var action0 = arguments[0];
        if (arguments.length === 1 || arguments.length === 2 && typeof arguments[1] !== "function") {
          transitionable = !!action0.transitionable;
        }
        if (transitionable) {
          var origArguments = arguments;
          select_default2(document).transition("history.perform").duration(duration).ease(linear2).tween("history.tween", function() {
            return function(t2) {
              if (t2 < 1)
                _overwrite([action0], t2);
            };
          }).on("start", function() {
            _perform([action0], 0);
          }).on("end interrupt", function() {
            _overwrite(origArguments, 1);
          });
        } else {
          return _perform(arguments);
        }
      },
      replace: function() {
        select_default2(document).interrupt("history.perform");
        return _replace(arguments, 1);
      },
      // Same as calling pop and then perform
      overwrite: function() {
        select_default2(document).interrupt("history.perform");
        return _overwrite(arguments, 1);
      },
      pop: function(n3) {
        select_default2(document).interrupt("history.perform");
        var previous = _stack[_index].graph;
        if (isNaN(+n3) || +n3 < 0) {
          n3 = 1;
        }
        while (n3-- > 0 && _index > 0) {
          _index--;
          _stack.pop();
        }
        return change(previous);
      },
      // Back to the previous annotated state or _index = 0.
      undo: function() {
        select_default2(document).interrupt("history.perform");
        var previousStack = _stack[_index];
        var previous = previousStack.graph;
        while (_index > 0) {
          _index--;
          if (_stack[_index].annotation)
            break;
        }
        dispatch14.call("undone", this, _stack[_index], previousStack);
        return change(previous);
      },
      // Forward to the next annotated state.
      redo: function() {
        select_default2(document).interrupt("history.perform");
        var previousStack = _stack[_index];
        var previous = previousStack.graph;
        var tryIndex = _index;
        while (tryIndex < _stack.length - 1) {
          tryIndex++;
          if (_stack[tryIndex].annotation) {
            _index = tryIndex;
            dispatch14.call("redone", this, _stack[_index], previousStack);
            break;
          }
        }
        return change(previous);
      },
      pauseChangeDispatch: function() {
        if (!_pausedGraph) {
          _pausedGraph = _stack[_index].graph;
        }
      },
      resumeChangeDispatch: function() {
        if (_pausedGraph) {
          var previous = _pausedGraph;
          _pausedGraph = null;
          return change(previous);
        }
      },
      undoAnnotation: function() {
        var i3 = _index;
        while (i3 >= 0) {
          if (_stack[i3].annotation)
            return _stack[i3].annotation;
          i3--;
        }
      },
      redoAnnotation: function() {
        var i3 = _index + 1;
        while (i3 <= _stack.length - 1) {
          if (_stack[i3].annotation)
            return _stack[i3].annotation;
          i3++;
        }
      },
      // Returns the entities from the active graph with bounding boxes
      // overlapping the given `extent`.
      intersects: function(extent) {
        return _tree.intersects(extent, _stack[_index].graph);
      },
      difference: function() {
        var base = _stack[0].graph;
        var head = _stack[_index].graph;
        return coreDifference(base, head);
      },
      changes: function(action) {
        var base = _stack[0].graph;
        var head = _stack[_index].graph;
        if (action) {
          head = action(head);
        }
        var difference2 = coreDifference(base, head);
        return {
          modified: difference2.modified(),
          created: difference2.created(),
          deleted: difference2.deleted()
        };
      },
      hasChanges: function() {
        return this.difference().length() > 0;
      },
      imageryUsed: function(sources) {
        if (sources) {
          _imageryUsed = sources;
          return history;
        } else {
          var s2 = /* @__PURE__ */ new Set();
          _stack.slice(1, _index + 1).forEach(function(state) {
            state.imageryUsed.forEach(function(source) {
              if (source !== "Custom") {
                s2.add(source);
              }
            });
          });
          return Array.from(s2);
        }
      },
      photoOverlaysUsed: function(sources) {
        if (sources) {
          _photoOverlaysUsed = sources;
          return history;
        } else {
          var s2 = /* @__PURE__ */ new Set();
          _stack.slice(1, _index + 1).forEach(function(state) {
            if (state.photoOverlaysUsed && Array.isArray(state.photoOverlaysUsed)) {
              state.photoOverlaysUsed.forEach(function(photoOverlay) {
                s2.add(photoOverlay);
              });
            }
          });
          return Array.from(s2);
        }
      },
      // save the current history state
      checkpoint: function(key) {
        _checkpoints[key] = {
          stack: _stack,
          index: _index
        };
        return history;
      },
      // restore history state to a given checkpoint or reset completely
      reset: function(key) {
        if (key !== void 0 && _checkpoints.hasOwnProperty(key)) {
          _stack = _checkpoints[key].stack;
          _index = _checkpoints[key].index;
        } else {
          _stack = [{ graph: coreGraph() }];
          _index = 0;
          _tree = coreTree(_stack[0].graph);
          _checkpoints = {};
        }
        dispatch14.call("reset");
        dispatch14.call("change");
        return history;
      },
      // `toIntroGraph()` is used to export the intro graph used by the walkthrough.
      //
      // To use it:
      //  1. Start the walkthrough.
      //  2. Get to a "free editing" tutorial step
      //  3. Make your edits to the walkthrough map
      //  4. In your browser dev console run:
      //        `id.history().toIntroGraph()`
      //  5. This outputs stringified JSON to the browser console
      //  6. Copy it to `data/intro_graph.json` and prettify it in your code editor
      toIntroGraph: function() {
        var nextID = { n: 0, r: 0, w: 0 };
        var permIDs = {};
        var graph = this.graph();
        var baseEntities = {};
        Object.values(graph.base().entities).forEach(function(entity) {
          var copy2 = copyIntroEntity(entity);
          baseEntities[copy2.id] = copy2;
        });
        Object.keys(graph.entities).forEach(function(id2) {
          var entity = graph.entities[id2];
          if (entity) {
            var copy2 = copyIntroEntity(entity);
            baseEntities[copy2.id] = copy2;
          } else {
            delete baseEntities[id2];
          }
        });
        Object.values(baseEntities).forEach(function(entity) {
          if (Array.isArray(entity.nodes)) {
            entity.nodes = entity.nodes.map(function(node) {
              return permIDs[node] || node;
            });
          }
          if (Array.isArray(entity.members)) {
            entity.members = entity.members.map(function(member) {
              member.id = permIDs[member.id] || member.id;
              return member;
            });
          }
        });
        return JSON.stringify({ dataIntroGraph: baseEntities });
        function copyIntroEntity(source) {
          var copy2 = utilObjectOmit(source, ["type", "user", "v", "version", "visible"]);
          if (copy2.tags && !Object.keys(copy2.tags)) {
            delete copy2.tags;
          }
          if (Array.isArray(copy2.loc)) {
            copy2.loc[0] = +copy2.loc[0].toFixed(6);
            copy2.loc[1] = +copy2.loc[1].toFixed(6);
          }
          var match = source.id.match(/([nrw])-\d*/);
          if (match !== null) {
            var nrw = match[1];
            var permID;
            do {
              permID = nrw + ++nextID[nrw];
            } while (baseEntities.hasOwnProperty(permID));
            copy2.id = permIDs[source.id] = permID;
          }
          return copy2;
        }
      },
      toJSON: function() {
        if (!this.hasChanges())
          return;
        var allEntities = {};
        var baseEntities = {};
        var base = _stack[0];
        var s2 = _stack.map(function(i3) {
          var modified = [];
          var deleted = [];
          Object.keys(i3.graph.entities).forEach(function(id2) {
            var entity = i3.graph.entities[id2];
            if (entity) {
              var key = osmEntity.key(entity);
              allEntities[key] = entity;
              modified.push(key);
            } else {
              deleted.push(id2);
            }
            if (id2 in base.graph.entities) {
              baseEntities[id2] = base.graph.entities[id2];
            }
            if (entity && entity.nodes) {
              entity.nodes.forEach(function(nodeID) {
                if (nodeID in base.graph.entities) {
                  baseEntities[nodeID] = base.graph.entities[nodeID];
                }
              });
            }
            var baseParents = base.graph._parentWays[id2];
            if (baseParents) {
              baseParents.forEach(function(parentID) {
                if (parentID in base.graph.entities) {
                  baseEntities[parentID] = base.graph.entities[parentID];
                }
              });
            }
          });
          var x2 = {};
          if (modified.length)
            x2.modified = modified;
          if (deleted.length)
            x2.deleted = deleted;
          if (i3.imageryUsed)
            x2.imageryUsed = i3.imageryUsed;
          if (i3.photoOverlaysUsed)
            x2.photoOverlaysUsed = i3.photoOverlaysUsed;
          if (i3.annotation)
            x2.annotation = i3.annotation;
          if (i3.transform)
            x2.transform = i3.transform;
          if (i3.selectedIDs)
            x2.selectedIDs = i3.selectedIDs;
          return x2;
        });
        return JSON.stringify({
          version: 3,
          entities: Object.values(allEntities),
          baseEntities: Object.values(baseEntities),
          stack: s2,
          nextIDs: osmEntity.id.next,
          index: _index,
          // note the time the changes were saved
          timestamp: (/* @__PURE__ */ new Date()).getTime()
        });
      },
      fromJSON: function(json, loadChildNodes) {
        var h2 = JSON.parse(json);
        var loadComplete = true;
        osmEntity.id.next = h2.nextIDs;
        _index = h2.index;
        if (h2.version === 2 || h2.version === 3) {
          var allEntities = {};
          h2.entities.forEach(function(entity) {
            allEntities[osmEntity.key(entity)] = osmEntity(entity);
          });
          if (h2.version === 3) {
            var baseEntities = h2.baseEntities.map(function(d2) {
              return osmEntity(d2);
            });
            var stack = _stack.map(function(state) {
              return state.graph;
            });
            _stack[0].graph.rebase(baseEntities, stack, true);
            _tree.rebase(baseEntities, true);
            if (loadChildNodes) {
              var osm = context.connection();
              var baseWays = baseEntities.filter(function(e3) {
                return e3.type === "way";
              });
              var nodeIDs = baseWays.reduce(function(acc, way) {
                return utilArrayUnion(acc, way.nodes);
              }, []);
              var missing = nodeIDs.filter(function(n3) {
                return !_stack[0].graph.hasEntity(n3);
              });
              if (missing.length && osm) {
                loadComplete = false;
                context.map().redrawEnable(false);
                var loading = uiLoading(context).blocking(true);
                context.container().call(loading);
                var childNodesLoaded = function(err, result) {
                  if (!err) {
                    var visibleGroups = utilArrayGroupBy(result.data, "visible");
                    var visibles = visibleGroups.true || [];
                    var invisibles = visibleGroups.false || [];
                    if (visibles.length) {
                      var visibleIDs = visibles.map(function(entity) {
                        return entity.id;
                      });
                      var stack2 = _stack.map(function(state) {
                        return state.graph;
                      });
                      missing = utilArrayDifference(missing, visibleIDs);
                      _stack[0].graph.rebase(visibles, stack2, true);
                      _tree.rebase(visibles, true);
                    }
                    invisibles.forEach(function(entity) {
                      osm.loadEntityVersion(entity.id, +entity.version - 1, childNodesLoaded);
                    });
                  }
                  if (err || !missing.length) {
                    loading.close();
                    context.map().redrawEnable(true);
                    dispatch14.call("change");
                    dispatch14.call("restore", this);
                  }
                };
                osm.loadMultiple(missing, childNodesLoaded);
              }
            }
          }
          _stack = h2.stack.map(function(d2) {
            var entities = {}, entity;
            if (d2.modified) {
              d2.modified.forEach(function(key) {
                entity = allEntities[key];
                entities[entity.id] = entity;
              });
            }
            if (d2.deleted) {
              d2.deleted.forEach(function(id2) {
                entities[id2] = void 0;
              });
            }
            return {
              graph: coreGraph(_stack[0].graph).load(entities),
              annotation: d2.annotation,
              imageryUsed: d2.imageryUsed,
              photoOverlaysUsed: d2.photoOverlaysUsed,
              transform: d2.transform,
              selectedIDs: d2.selectedIDs
            };
          });
        } else {
          _stack = h2.stack.map(function(d2) {
            var entities = {};
            for (var i3 in d2.entities) {
              var entity = d2.entities[i3];
              entities[i3] = entity === "undefined" ? void 0 : osmEntity(entity);
            }
            d2.graph = coreGraph(_stack[0].graph).load(entities);
            return d2;
          });
        }
        var transform2 = _stack[_index].transform;
        if (transform2) {
          context.map().transformEase(transform2, 0);
        }
        if (loadComplete) {
          dispatch14.call("change");
          dispatch14.call("restore", this);
        }
        return history;
      },
      lock: function() {
        return lock.lock();
      },
      unlock: function() {
        lock.unlock();
      },
      save: function() {
        if (lock.locked() && // don't overwrite existing, unresolved changes
        !_hasUnresolvedRestorableChanges) {
          const success = corePreferences(getKey("saved_history"), history.toJSON() || null);
          if (!success)
            dispatch14.call("storage_error");
        }
        return history;
      },
      // delete the history version saved in localStorage
      clearSaved: function() {
        context.debouncedSave.cancel();
        if (lock.locked()) {
          _hasUnresolvedRestorableChanges = false;
          corePreferences(getKey("saved_history"), null);
          corePreferences("comment", null);
          corePreferences("hashtags", null);
          corePreferences("source", null);
        }
        return history;
      },
      savedHistoryJSON: function() {
        return corePreferences(getKey("saved_history"));
      },
      hasRestorableChanges: function() {
        return _hasUnresolvedRestorableChanges;
      },
      // load history from a version stored in localStorage
      restore: function() {
        if (lock.locked()) {
          _hasUnresolvedRestorableChanges = false;
          var json = this.savedHistoryJSON();
          if (json)
            history.fromJSON(json, true);
        }
      },
      _getKey: getKey
    };
    history.reset();
    return utilRebind(history, dispatch14, "on");
  }

  // modules/validations/index.js
  var validations_exports = {};
  __export(validations_exports, {
    validationAlmostJunction: () => validationAlmostJunction,
    validationCloseNodes: () => validationCloseNodes,
    validationCrossingWays: () => validationCrossingWays,
    validationDisconnectedWay: () => validationDisconnectedWay,
    validationFormatting: () => validationFormatting,
    validationHelpRequest: () => validationHelpRequest,
    validationImpossibleOneway: () => validationImpossibleOneway,
    validationIncompatibleSource: () => validationIncompatibleSource,
    validationMaprules: () => validationMaprules,
    validationMismatchedGeometry: () => validationMismatchedGeometry,
    validationMissingRole: () => validationMissingRole,
    validationMissingTag: () => validationMissingTag,
    validationMutuallyExclusiveTags: () => validationMutuallyExclusiveTags,
    validationOutdatedTags: () => validationOutdatedTags,
    validationPrivateData: () => validationPrivateData,
    validationSuspiciousName: () => validationSuspiciousName,
    validationUnsquareWay: () => validationUnsquareWay
  });

  // modules/validations/almost_junction.js
  function validationAlmostJunction(context) {
    const type2 = "almost_junction";
    const EXTEND_TH_METERS = 5;
    const WELD_TH_METERS = 0.75;
    const CLOSE_NODE_TH = EXTEND_TH_METERS - WELD_TH_METERS;
    const SIG_ANGLE_TH = Math.atan(WELD_TH_METERS / EXTEND_TH_METERS);
    function isHighway(entity) {
      return entity.type === "way" && osmRoutableHighwayTagValues[entity.tags.highway];
    }
    function isTaggedAsNotContinuing(node) {
      return node.tags.noexit === "yes" || node.tags.amenity === "parking_entrance" || node.tags.entrance && node.tags.entrance !== "no";
    }
    const validation = function checkAlmostJunction(entity, graph) {
      if (!isHighway(entity))
        return [];
      if (entity.isDegenerate())
        return [];
      const tree = context.history().tree();
      const extendableNodeInfos = findConnectableEndNodesByExtension(entity);
      let issues = [];
      extendableNodeInfos.forEach((extendableNodeInfo) => {
        issues.push(new validationIssue({
          type: type2,
          subtype: "highway-highway",
          severity: "warning",
          message: function(context2) {
            const entity1 = context2.hasEntity(this.entityIds[0]);
            if (this.entityIds[0] === this.entityIds[2]) {
              return entity1 ? _t.append("issues.almost_junction.self.message", {
                feature: utilDisplayLabel(entity1, context2.graph())
              }) : "";
            } else {
              const entity2 = context2.hasEntity(this.entityIds[2]);
              return entity1 && entity2 ? _t.append("issues.almost_junction.message", {
                feature: utilDisplayLabel(entity1, context2.graph()),
                feature2: utilDisplayLabel(entity2, context2.graph())
              }) : "";
            }
          },
          reference: showReference,
          entityIds: [
            entity.id,
            extendableNodeInfo.node.id,
            extendableNodeInfo.wid
          ],
          loc: extendableNodeInfo.node.loc,
          hash: JSON.stringify(extendableNodeInfo.node.loc),
          data: {
            midId: extendableNodeInfo.mid.id,
            edge: extendableNodeInfo.edge,
            cross_loc: extendableNodeInfo.cross_loc
          },
          dynamicFixes: makeFixes
        }));
      });
      return issues;
      function makeFixes(context2) {
        let fixes = [new validationIssueFix({
          icon: "iD-icon-abutment",
          title: _t.append("issues.fix.connect_features.title"),
          onClick: function(context3) {
            const annotation = _t("issues.fix.connect_almost_junction.annotation");
            const [, endNodeId, crossWayId] = this.issue.entityIds;
            const midNode = context3.entity(this.issue.data.midId);
            const endNode = context3.entity(endNodeId);
            const crossWay = context3.entity(crossWayId);
            const nearEndNodes = findNearbyEndNodes(endNode, crossWay);
            if (nearEndNodes.length > 0) {
              const collinear = findSmallJoinAngle(midNode, endNode, nearEndNodes);
              if (collinear) {
                context3.perform(
                  actionMergeNodes([collinear.id, endNode.id], collinear.loc),
                  annotation
                );
                return;
              }
            }
            const targetEdge = this.issue.data.edge;
            const crossLoc = this.issue.data.cross_loc;
            const edgeNodes = [context3.entity(targetEdge[0]), context3.entity(targetEdge[1])];
            const closestNodeInfo = geoSphericalClosestNode(edgeNodes, crossLoc);
            if (closestNodeInfo.distance < WELD_TH_METERS) {
              context3.perform(
                actionMergeNodes([closestNodeInfo.node.id, endNode.id], closestNodeInfo.node.loc),
                annotation
              );
            } else {
              context3.perform(
                actionAddMidpoint({ loc: crossLoc, edge: targetEdge }, endNode),
                annotation
              );
            }
          }
        })];
        const node = context2.hasEntity(this.entityIds[1]);
        if (node && !node.hasInterestingTags()) {
          fixes.push(new validationIssueFix({
            icon: "maki-barrier",
            title: _t.append("issues.fix.tag_as_disconnected.title"),
            onClick: function(context3) {
              const nodeID = this.issue.entityIds[1];
              const tags = Object.assign({}, context3.entity(nodeID).tags);
              tags.noexit = "yes";
              context3.perform(
                actionChangeTags(nodeID, tags),
                _t("issues.fix.tag_as_disconnected.annotation")
              );
            }
          }));
        }
        return fixes;
      }
      function showReference(selection2) {
        selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.almost_junction.highway-highway.reference"));
      }
      function isExtendableCandidate(node, way) {
        const osm = services.osm;
        if (osm && !osm.isDataLoaded(node.loc)) {
          return false;
        }
        if (isTaggedAsNotContinuing(node) || graph.parentWays(node).length !== 1) {
          return false;
        }
        let occurrences = 0;
        for (const index in way.nodes) {
          if (way.nodes[index] === node.id) {
            occurrences += 1;
            if (occurrences > 1) {
              return false;
            }
          }
        }
        return true;
      }
      function findConnectableEndNodesByExtension(way) {
        let results = [];
        if (way.isClosed())
          return results;
        let testNodes;
        const indices = [0, way.nodes.length - 1];
        indices.forEach((nodeIndex) => {
          const nodeID = way.nodes[nodeIndex];
          const node = graph.entity(nodeID);
          if (!isExtendableCandidate(node, way))
            return;
          const connectionInfo = canConnectByExtend(way, nodeIndex);
          if (!connectionInfo)
            return;
          testNodes = graph.childNodes(way).slice();
          testNodes[nodeIndex] = testNodes[nodeIndex].move(connectionInfo.cross_loc);
          if (geoHasSelfIntersections(testNodes, nodeID))
            return;
          results.push(connectionInfo);
        });
        return results;
      }
      function findNearbyEndNodes(node, way) {
        return [
          way.nodes[0],
          way.nodes[way.nodes.length - 1]
        ].map((d2) => graph.entity(d2)).filter((d2) => {
          return d2.id !== node.id && geoSphericalDistance(node.loc, d2.loc) <= CLOSE_NODE_TH;
        });
      }
      function findSmallJoinAngle(midNode, tipNode, endNodes) {
        let joinTo;
        let minAngle = Infinity;
        endNodes.forEach((endNode) => {
          const a1 = geoAngle(midNode, tipNode, context.projection) + Math.PI;
          const a2 = geoAngle(midNode, endNode, context.projection) + Math.PI;
          const diff = Math.max(a1, a2) - Math.min(a1, a2);
          if (diff < minAngle) {
            joinTo = endNode;
            minAngle = diff;
          }
        });
        if (minAngle <= SIG_ANGLE_TH)
          return joinTo;
        return null;
      }
      function hasTag(tags, key) {
        return tags[key] !== void 0 && tags[key] !== "no";
      }
      function canConnectWays(way, way2) {
        if (way.id === way2.id)
          return true;
        if ((hasTag(way.tags, "bridge") || hasTag(way2.tags, "bridge")) && !(hasTag(way.tags, "bridge") && hasTag(way2.tags, "bridge")))
          return false;
        if ((hasTag(way.tags, "tunnel") || hasTag(way2.tags, "tunnel")) && !(hasTag(way.tags, "tunnel") && hasTag(way2.tags, "tunnel")))
          return false;
        const layer1 = way.tags.layer || "0", layer2 = way2.tags.layer || "0";
        if (layer1 !== layer2)
          return false;
        const level1 = way.tags.level || "0", level2 = way2.tags.level || "0";
        if (level1 !== level2)
          return false;
        return true;
      }
      function canConnectByExtend(way, endNodeIdx) {
        const tipNid = way.nodes[endNodeIdx];
        const midNid = endNodeIdx === 0 ? way.nodes[1] : way.nodes[way.nodes.length - 2];
        const tipNode = graph.entity(tipNid);
        const midNode = graph.entity(midNid);
        const lon = tipNode.loc[0];
        const lat = tipNode.loc[1];
        const lon_range = geoMetersToLon(EXTEND_TH_METERS, lat) / 2;
        const lat_range = geoMetersToLat(EXTEND_TH_METERS) / 2;
        const queryExtent = geoExtent([
          [lon - lon_range, lat - lat_range],
          [lon + lon_range, lat + lat_range]
        ]);
        const edgeLen = geoSphericalDistance(midNode.loc, tipNode.loc);
        const t2 = EXTEND_TH_METERS / edgeLen + 1;
        const extTipLoc = geoVecInterp(midNode.loc, tipNode.loc, t2);
        const segmentInfos = tree.waySegments(queryExtent, graph);
        for (let i3 = 0; i3 < segmentInfos.length; i3++) {
          let segmentInfo = segmentInfos[i3];
          let way2 = graph.entity(segmentInfo.wayId);
          if (!isHighway(way2))
            continue;
          if (!canConnectWays(way, way2))
            continue;
          let nAid = segmentInfo.nodes[0], nBid = segmentInfo.nodes[1];
          if (nAid === tipNid || nBid === tipNid)
            continue;
          let nA = graph.entity(nAid), nB = graph.entity(nBid);
          let crossLoc = geoLineIntersection([tipNode.loc, extTipLoc], [nA.loc, nB.loc]);
          if (crossLoc) {
            return {
              mid: midNode,
              node: tipNode,
              wid: way2.id,
              edge: [nA.id, nB.id],
              cross_loc: crossLoc
            };
          }
        }
        return null;
      }
    };
    validation.type = type2;
    return validation;
  }

  // modules/validations/close_nodes.js
  function validationCloseNodes(context) {
    var type2 = "close_nodes";
    var pointThresholdMeters = 0.2;
    var validation = function(entity, graph) {
      if (entity.type === "node") {
        return getIssuesForNode(entity);
      } else if (entity.type === "way") {
        return getIssuesForWay(entity);
      }
      return [];
      function getIssuesForNode(node) {
        var parentWays = graph.parentWays(node);
        if (parentWays.length) {
          return getIssuesForVertex(node, parentWays);
        } else {
          return getIssuesForDetachedPoint(node);
        }
      }
      function wayTypeFor(way) {
        if (way.tags.boundary && way.tags.boundary !== "no")
          return "boundary";
        if (way.tags.indoor && way.tags.indoor !== "no")
          return "indoor";
        if (way.tags.building && way.tags.building !== "no" || way.tags["building:part"] && way.tags["building:part"] !== "no")
          return "building";
        if (osmPathHighwayTagValues[way.tags.highway])
          return "path";
        var parentRelations = graph.parentRelations(way);
        for (var i3 in parentRelations) {
          var relation = parentRelations[i3];
          if (relation.tags.type === "boundary")
            return "boundary";
          if (relation.isMultipolygon()) {
            if (relation.tags.indoor && relation.tags.indoor !== "no")
              return "indoor";
            if (relation.tags.building && relation.tags.building !== "no" || relation.tags["building:part"] && relation.tags["building:part"] !== "no")
              return "building";
          }
        }
        return "other";
      }
      function shouldCheckWay(way) {
        if (way.nodes.length <= 2 || way.isClosed() && way.nodes.length <= 4)
          return false;
        var bbox2 = way.extent(graph).bbox();
        var hypotenuseMeters = geoSphericalDistance([bbox2.minX, bbox2.minY], [bbox2.maxX, bbox2.maxY]);
        if (hypotenuseMeters < 1.5)
          return false;
        return true;
      }
      function getIssuesForWay(way) {
        if (!shouldCheckWay(way))
          return [];
        var issues = [], nodes = graph.childNodes(way);
        for (var i3 = 0; i3 < nodes.length - 1; i3++) {
          var node1 = nodes[i3];
          var node2 = nodes[i3 + 1];
          var issue = getWayIssueIfAny(node1, node2, way);
          if (issue)
            issues.push(issue);
        }
        return issues;
      }
      function getIssuesForVertex(node, parentWays) {
        var issues = [];
        function checkForCloseness(node1, node2, way) {
          var issue = getWayIssueIfAny(node1, node2, way);
          if (issue)
            issues.push(issue);
        }
        for (var i3 = 0; i3 < parentWays.length; i3++) {
          var parentWay = parentWays[i3];
          if (!shouldCheckWay(parentWay))
            continue;
          var lastIndex = parentWay.nodes.length - 1;
          for (var j2 = 0; j2 < parentWay.nodes.length; j2++) {
            if (j2 !== 0) {
              if (parentWay.nodes[j2 - 1] === node.id) {
                checkForCloseness(node, graph.entity(parentWay.nodes[j2]), parentWay);
              }
            }
            if (j2 !== lastIndex) {
              if (parentWay.nodes[j2 + 1] === node.id) {
                checkForCloseness(graph.entity(parentWay.nodes[j2]), node, parentWay);
              }
            }
          }
        }
        return issues;
      }
      function thresholdMetersForWay(way) {
        if (!shouldCheckWay(way))
          return 0;
        var wayType = wayTypeFor(way);
        if (wayType === "boundary")
          return 0;
        if (wayType === "indoor")
          return 0.01;
        if (wayType === "building")
          return 0.05;
        if (wayType === "path")
          return 0.1;
        return 0.2;
      }
      function getIssuesForDetachedPoint(node) {
        var issues = [];
        var lon = node.loc[0];
        var lat = node.loc[1];
        var lon_range = geoMetersToLon(pointThresholdMeters, lat) / 2;
        var lat_range = geoMetersToLat(pointThresholdMeters) / 2;
        var queryExtent = geoExtent([
          [lon - lon_range, lat - lat_range],
          [lon + lon_range, lat + lat_range]
        ]);
        var intersected = context.history().tree().intersects(queryExtent, graph);
        for (var j2 = 0; j2 < intersected.length; j2++) {
          var nearby = intersected[j2];
          if (nearby.id === node.id)
            continue;
          if (nearby.type !== "node" || nearby.geometry(graph) !== "point")
            continue;
          if (nearby.loc === node.loc || geoSphericalDistance(node.loc, nearby.loc) < pointThresholdMeters) {
            if ("memorial:type" in node.tags && "memorial:type" in nearby.tags && node.tags["memorial:type"] === "stolperstein" && nearby.tags["memorial:type"] === "stolperstein")
              continue;
            if ("memorial" in node.tags && "memorial" in nearby.tags && node.tags.memorial === "stolperstein" && nearby.tags.memorial === "stolperstein")
              continue;
            var zAxisKeys = { layer: true, level: true, "addr:housenumber": true, "addr:unit": true };
            var zAxisDifferentiates = false;
            for (var key in zAxisKeys) {
              var nodeValue = node.tags[key] || "0";
              var nearbyValue = nearby.tags[key] || "0";
              if (nodeValue !== nearbyValue) {
                zAxisDifferentiates = true;
                break;
              }
            }
            if (zAxisDifferentiates)
              continue;
            issues.push(new validationIssue({
              type: type2,
              subtype: "detached",
              severity: "warning",
              message: function(context2) {
                var entity2 = context2.hasEntity(this.entityIds[0]), entity22 = context2.hasEntity(this.entityIds[1]);
                return entity2 && entity22 ? _t.append("issues.close_nodes.detached.message", {
                  feature: utilDisplayLabel(entity2, context2.graph()),
                  feature2: utilDisplayLabel(entity22, context2.graph())
                }) : "";
              },
              reference: showReference,
              entityIds: [node.id, nearby.id],
              dynamicFixes: function() {
                return [
                  new validationIssueFix({
                    icon: "iD-operation-disconnect",
                    title: _t.append("issues.fix.move_points_apart.title")
                  }),
                  new validationIssueFix({
                    icon: "iD-icon-layers",
                    title: _t.append("issues.fix.use_different_layers_or_levels.title")
                  })
                ];
              }
            }));
          }
        }
        return issues;
        function showReference(selection2) {
          var referenceText = _t("issues.close_nodes.detached.reference");
          selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").html(referenceText);
        }
      }
      function getWayIssueIfAny(node1, node2, way) {
        if (node1.id === node2.id || node1.hasInterestingTags() && node2.hasInterestingTags()) {
          return null;
        }
        if (node1.loc !== node2.loc) {
          var parentWays1 = graph.parentWays(node1);
          var parentWays2 = new Set(graph.parentWays(node2));
          var sharedWays = parentWays1.filter(function(parentWay) {
            return parentWays2.has(parentWay);
          });
          var thresholds = sharedWays.map(function(parentWay) {
            return thresholdMetersForWay(parentWay);
          });
          var threshold = Math.min(...thresholds);
          var distance = geoSphericalDistance(node1.loc, node2.loc);
          if (distance > threshold)
            return null;
        }
        return new validationIssue({
          type: type2,
          subtype: "vertices",
          severity: "warning",
          message: function(context2) {
            var entity2 = context2.hasEntity(this.entityIds[0]);
            return entity2 ? _t.append("issues.close_nodes.message", { way: utilDisplayLabel(entity2, context2.graph()) }) : "";
          },
          reference: showReference,
          entityIds: [way.id, node1.id, node2.id],
          loc: node1.loc,
          dynamicFixes: function() {
            return [
              new validationIssueFix({
                icon: "iD-icon-plus",
                title: _t.append("issues.fix.merge_points.title"),
                onClick: function(context2) {
                  var entityIds = this.issue.entityIds;
                  var action = actionMergeNodes([entityIds[1], entityIds[2]]);
                  context2.perform(action, _t("issues.fix.merge_close_vertices.annotation"));
                }
              }),
              new validationIssueFix({
                icon: "iD-operation-disconnect",
                title: _t.append("issues.fix.move_points_apart.title")
              })
            ];
          }
        });
        function showReference(selection2) {
          var referenceText = _t("issues.close_nodes.reference");
          selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").html(referenceText);
        }
      }
    };
    validation.type = type2;
    return validation;
  }

  // modules/validations/crossing_ways.js
  var import_lodash3 = __toESM(require_lodash());
  function validationCrossingWays(context) {
    var type2 = "crossing_ways";
    function getFeatureWithFeatureTypeTagsForWay(way, graph) {
      if (getFeatureType(way, graph) === null) {
        var parentRels = graph.parentRelations(way);
        for (var i3 = 0; i3 < parentRels.length; i3++) {
          var rel = parentRels[i3];
          if (getFeatureType(rel, graph) !== null) {
            return rel;
          }
        }
      }
      return way;
    }
    function hasTag(tags, key) {
      return tags[key] !== void 0 && tags[key] !== "no";
    }
    function taggedAsIndoor(tags) {
      return hasTag(tags, "indoor") || hasTag(tags, "level") || tags.highway === "corridor";
    }
    function allowsBridge(featureType) {
      return featureType === "highway" || featureType === "railway" || featureType === "waterway";
    }
    function allowsTunnel(featureType) {
      return featureType === "highway" || featureType === "railway" || featureType === "waterway";
    }
    var ignoredBuildings = {
      demolished: true,
      dismantled: true,
      proposed: true,
      razed: true
    };
    function getFeatureType(entity, graph) {
      var geometry = entity.geometry(graph);
      if (geometry !== "line" && geometry !== "area")
        return null;
      var tags = entity.tags;
      if (hasTag(tags, "building") && !ignoredBuildings[tags.building])
        return "building";
      if (hasTag(tags, "highway") && osmRoutableHighwayTagValues[tags.highway])
        return "highway";
      if (geometry !== "line")
        return null;
      if (hasTag(tags, "railway") && osmRailwayTrackTagValues[tags.railway])
        return "railway";
      if (hasTag(tags, "waterway") && osmFlowingWaterwayTagValues[tags.waterway])
        return "waterway";
      return null;
    }
    function isLegitCrossing(tags1, featureType1, tags2, featureType2) {
      var level1 = tags1.level || "0";
      var level2 = tags2.level || "0";
      if (taggedAsIndoor(tags1) && taggedAsIndoor(tags2) && level1 !== level2) {
        return true;
      }
      var layer1 = tags1.layer || "0";
      var layer2 = tags2.layer || "0";
      if (allowsBridge(featureType1) && allowsBridge(featureType2)) {
        if (hasTag(tags1, "bridge") && !hasTag(tags2, "bridge"))
          return true;
        if (!hasTag(tags1, "bridge") && hasTag(tags2, "bridge"))
          return true;
        if (hasTag(tags1, "bridge") && hasTag(tags2, "bridge") && layer1 !== layer2)
          return true;
      } else if (allowsBridge(featureType1) && hasTag(tags1, "bridge"))
        return true;
      else if (allowsBridge(featureType2) && hasTag(tags2, "bridge"))
        return true;
      if (allowsTunnel(featureType1) && allowsTunnel(featureType2)) {
        if (hasTag(tags1, "tunnel") && !hasTag(tags2, "tunnel"))
          return true;
        if (!hasTag(tags1, "tunnel") && hasTag(tags2, "tunnel"))
          return true;
        if (hasTag(tags1, "tunnel") && hasTag(tags2, "tunnel") && layer1 !== layer2)
          return true;
      } else if (allowsTunnel(featureType1) && hasTag(tags1, "tunnel"))
        return true;
      else if (allowsTunnel(featureType2) && hasTag(tags2, "tunnel"))
        return true;
      if (featureType1 === "waterway" && featureType2 === "highway" && tags2.man_made === "pier")
        return true;
      if (featureType2 === "waterway" && featureType1 === "highway" && tags1.man_made === "pier")
        return true;
      if (featureType1 === "building" || featureType2 === "building" || taggedAsIndoor(tags1) || taggedAsIndoor(tags2)) {
        if (layer1 !== layer2)
          return true;
      }
      return false;
    }
    var highwaysDisallowingFords = {
      motorway: true,
      motorway_link: true,
      trunk: true,
      trunk_link: true,
      primary: true,
      primary_link: true,
      secondary: true,
      secondary_link: true
    };
    function tagsForConnectionNodeIfAllowed(entity1, entity2, graph, lessLikelyTags) {
      var featureType1 = getFeatureType(entity1, graph);
      var featureType2 = getFeatureType(entity2, graph);
      var geometry1 = entity1.geometry(graph);
      var geometry2 = entity2.geometry(graph);
      var bothLines = geometry1 === "line" && geometry2 === "line";
      if (featureType1 === featureType2) {
        if (featureType1 === "highway") {
          var entity1IsPath = osmPathHighwayTagValues[entity1.tags.highway];
          var entity2IsPath = osmPathHighwayTagValues[entity2.tags.highway];
          if ((entity1IsPath || entity2IsPath) && entity1IsPath !== entity2IsPath) {
            var roadFeature = entity1IsPath ? entity2 : entity1;
            var pathFeature = entity1IsPath ? entity1 : entity2;
            if (roadFeature.tags.highway === "track") {
              return {};
            }
            if (!lessLikelyTags && roadFeature.tags.highway === "service" && pathFeature.tags.highway === "footway" && pathFeature.tags.footway === "sidewalk") {
              return {};
            }
            if (["marked", "unmarked", "traffic_signals", "uncontrolled"].indexOf(pathFeature.tags.crossing) !== -1) {
              return bothLines ? { highway: "crossing", crossing: pathFeature.tags.crossing } : {};
            }
            return bothLines ? { highway: "crossing" } : {};
          }
          return {};
        }
        if (featureType1 === "waterway")
          return {};
        if (featureType1 === "railway")
          return {};
      } else {
        var featureTypes = [featureType1, featureType2];
        if (featureTypes.indexOf("highway") !== -1) {
          if (featureTypes.indexOf("railway") !== -1) {
            if (!bothLines)
              return {};
            var isTram = entity1.tags.railway === "tram" || entity2.tags.railway === "tram";
            if (osmPathHighwayTagValues[entity1.tags.highway] || osmPathHighwayTagValues[entity2.tags.highway]) {
              if (isTram)
                return { railway: "tram_crossing" };
              return { railway: "crossing" };
            } else {
              if (isTram)
                return { railway: "tram_level_crossing" };
              return { railway: "level_crossing" };
            }
          }
          if (featureTypes.indexOf("waterway") !== -1) {
            if (hasTag(entity1.tags, "tunnel") && hasTag(entity2.tags, "tunnel"))
              return null;
            if (hasTag(entity1.tags, "bridge") && hasTag(entity2.tags, "bridge"))
              return null;
            if (highwaysDisallowingFords[entity1.tags.highway] || highwaysDisallowingFords[entity2.tags.highway]) {
              return null;
            }
            return bothLines ? { ford: "yes" } : {};
          }
        }
      }
      return null;
    }
    function findCrossingsByWay(way1, graph, tree) {
      var edgeCrossInfos = [];
      if (way1.type !== "way")
        return edgeCrossInfos;
      var taggedFeature1 = getFeatureWithFeatureTypeTagsForWay(way1, graph);
      var way1FeatureType = getFeatureType(taggedFeature1, graph);
      if (way1FeatureType === null)
        return edgeCrossInfos;
      var checkedSingleCrossingWays = {};
      var i3, j2;
      var extent;
      var n1, n22, nA, nB, nAId, nBId;
      var segment1, segment2;
      var oneOnly;
      var segmentInfos, segment2Info, way2, taggedFeature2, way2FeatureType;
      var way1Nodes = graph.childNodes(way1);
      var comparedWays = {};
      for (i3 = 0; i3 < way1Nodes.length - 1; i3++) {
        n1 = way1Nodes[i3];
        n22 = way1Nodes[i3 + 1];
        extent = geoExtent([
          [
            Math.min(n1.loc[0], n22.loc[0]),
            Math.min(n1.loc[1], n22.loc[1])
          ],
          [
            Math.max(n1.loc[0], n22.loc[0]),
            Math.max(n1.loc[1], n22.loc[1])
          ]
        ]);
        segmentInfos = tree.waySegments(extent, graph);
        for (j2 = 0; j2 < segmentInfos.length; j2++) {
          segment2Info = segmentInfos[j2];
          if (segment2Info.wayId === way1.id)
            continue;
          if (checkedSingleCrossingWays[segment2Info.wayId])
            continue;
          comparedWays[segment2Info.wayId] = true;
          way2 = graph.hasEntity(segment2Info.wayId);
          if (!way2)
            continue;
          taggedFeature2 = getFeatureWithFeatureTypeTagsForWay(way2, graph);
          way2FeatureType = getFeatureType(taggedFeature2, graph);
          if (way2FeatureType === null || isLegitCrossing(taggedFeature1.tags, way1FeatureType, taggedFeature2.tags, way2FeatureType)) {
            continue;
          }
          oneOnly = way1FeatureType === "building" || way2FeatureType === "building";
          nAId = segment2Info.nodes[0];
          nBId = segment2Info.nodes[1];
          if (nAId === n1.id || nAId === n22.id || nBId === n1.id || nBId === n22.id) {
            continue;
          }
          nA = graph.hasEntity(nAId);
          if (!nA)
            continue;
          nB = graph.hasEntity(nBId);
          if (!nB)
            continue;
          segment1 = [n1.loc, n22.loc];
          segment2 = [nA.loc, nB.loc];
          var point2 = geoLineIntersection(segment1, segment2);
          if (point2) {
            edgeCrossInfos.push({
              wayInfos: [
                {
                  way: way1,
                  featureType: way1FeatureType,
                  edge: [n1.id, n22.id]
                },
                {
                  way: way2,
                  featureType: way2FeatureType,
                  edge: [nA.id, nB.id]
                }
              ],
              crossPoint: point2
            });
            if (oneOnly) {
              checkedSingleCrossingWays[way2.id] = true;
              break;
            }
          }
        }
      }
      return edgeCrossInfos;
    }
    function waysToCheck(entity, graph) {
      var featureType = getFeatureType(entity, graph);
      if (!featureType)
        return [];
      if (entity.type === "way") {
        return [entity];
      } else if (entity.type === "relation") {
        return entity.members.reduce(function(array2, member) {
          if (member.type === "way" && // only look at geometry ways
          (!member.role || member.role === "outer" || member.role === "inner")) {
            var entity2 = graph.hasEntity(member.id);
            if (entity2 && array2.indexOf(entity2) === -1) {
              array2.push(entity2);
            }
          }
          return array2;
        }, []);
      }
      return [];
    }
    var validation = function checkCrossingWays(entity, graph) {
      var tree = context.history().tree();
      var ways = waysToCheck(entity, graph);
      var issues = [];
      var wayIndex, crossingIndex, crossings;
      for (wayIndex in ways) {
        crossings = findCrossingsByWay(ways[wayIndex], graph, tree);
        for (crossingIndex in crossings) {
          issues.push(createIssue(crossings[crossingIndex], graph));
        }
      }
      return issues;
    };
    function createIssue(crossing, graph) {
      crossing.wayInfos.sort(function(way1Info, way2Info) {
        var type1 = way1Info.featureType;
        var type22 = way2Info.featureType;
        if (type1 === type22) {
          return utilDisplayLabel(way1Info.way, graph) > utilDisplayLabel(way2Info.way, graph);
        } else if (type1 === "waterway") {
          return true;
        } else if (type22 === "waterway") {
          return false;
        }
        return type1 < type22;
      });
      var entities = crossing.wayInfos.map(function(wayInfo) {
        return getFeatureWithFeatureTypeTagsForWay(wayInfo.way, graph);
      });
      var edges = [crossing.wayInfos[0].edge, crossing.wayInfos[1].edge];
      var featureTypes = [crossing.wayInfos[0].featureType, crossing.wayInfos[1].featureType];
      var connectionTags = tagsForConnectionNodeIfAllowed(entities[0], entities[1], graph);
      var featureType1 = crossing.wayInfos[0].featureType;
      var featureType2 = crossing.wayInfos[1].featureType;
      var isCrossingIndoors = taggedAsIndoor(entities[0].tags) && taggedAsIndoor(entities[1].tags);
      var isCrossingTunnels = allowsTunnel(featureType1) && hasTag(entities[0].tags, "tunnel") && allowsTunnel(featureType2) && hasTag(entities[1].tags, "tunnel");
      var isCrossingBridges = allowsBridge(featureType1) && hasTag(entities[0].tags, "bridge") && allowsBridge(featureType2) && hasTag(entities[1].tags, "bridge");
      var subtype = [featureType1, featureType2].sort().join("-");
      var crossingTypeID = subtype;
      if (isCrossingIndoors) {
        crossingTypeID = "indoor-indoor";
      } else if (isCrossingTunnels) {
        crossingTypeID = "tunnel-tunnel";
      } else if (isCrossingBridges) {
        crossingTypeID = "bridge-bridge";
      }
      if (connectionTags && (isCrossingIndoors || isCrossingTunnels || isCrossingBridges)) {
        crossingTypeID += "_connectable";
      }
      var uniqueID = crossing.crossPoint[0].toFixed(4) + "," + crossing.crossPoint[1].toFixed(4);
      return new validationIssue({
        type: type2,
        subtype,
        severity: "warning",
        message: function(context2) {
          var graph2 = context2.graph();
          var entity1 = graph2.hasEntity(this.entityIds[0]), entity2 = graph2.hasEntity(this.entityIds[1]);
          return entity1 && entity2 ? _t.append("issues.crossing_ways.message", {
            feature: utilDisplayLabel(entity1, graph2),
            feature2: utilDisplayLabel(entity2, graph2)
          }) : "";
        },
        reference: showReference,
        entityIds: entities.map(function(entity) {
          return entity.id;
        }),
        data: {
          edges,
          featureTypes,
          connectionTags
        },
        hash: uniqueID,
        loc: crossing.crossPoint,
        dynamicFixes: function(context2) {
          var mode = context2.mode();
          if (!mode || mode.id !== "select" || mode.selectedIDs().length !== 1)
            return [];
          var selectedIndex = this.entityIds[0] === mode.selectedIDs()[0] ? 0 : 1;
          var selectedFeatureType = this.data.featureTypes[selectedIndex];
          var otherFeatureType = this.data.featureTypes[selectedIndex === 0 ? 1 : 0];
          var fixes = [];
          if (connectionTags) {
            fixes.push(makeConnectWaysFix(this.data.connectionTags));
            let lessLikelyConnectionTags = tagsForConnectionNodeIfAllowed(entities[0], entities[1], graph, true);
            if (lessLikelyConnectionTags && !(0, import_lodash3.isEqual)(connectionTags, lessLikelyConnectionTags)) {
              fixes.push(makeConnectWaysFix(lessLikelyConnectionTags));
            }
          }
          if (isCrossingIndoors) {
            fixes.push(new validationIssueFix({
              icon: "iD-icon-layers",
              title: _t.append("issues.fix.use_different_levels.title")
            }));
          } else if (isCrossingTunnels || isCrossingBridges || featureType1 === "building" || featureType2 === "building") {
            fixes.push(makeChangeLayerFix("higher"));
            fixes.push(makeChangeLayerFix("lower"));
          } else if (context2.graph().geometry(this.entityIds[0]) === "line" && context2.graph().geometry(this.entityIds[1]) === "line") {
            if (allowsBridge(selectedFeatureType) && selectedFeatureType !== "waterway") {
              fixes.push(makeAddBridgeOrTunnelFix("add_a_bridge", "temaki-bridge", "bridge"));
            }
            var skipTunnelFix = otherFeatureType === "waterway" && selectedFeatureType !== "waterway";
            if (allowsTunnel(selectedFeatureType) && !skipTunnelFix) {
              fixes.push(makeAddBridgeOrTunnelFix("add_a_tunnel", "temaki-tunnel", "tunnel"));
            }
          }
          fixes.push(new validationIssueFix({
            icon: "iD-operation-move",
            title: _t.append("issues.fix.reposition_features.title")
          }));
          return fixes;
        }
      });
      function showReference(selection2) {
        selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.crossing_ways." + crossingTypeID + ".reference"));
      }
    }
    function makeAddBridgeOrTunnelFix(fixTitleID, iconName, bridgeOrTunnel) {
      return new validationIssueFix({
        icon: iconName,
        title: _t.append("issues.fix." + fixTitleID + ".title"),
        onClick: function(context2) {
          var mode = context2.mode();
          if (!mode || mode.id !== "select")
            return;
          var selectedIDs = mode.selectedIDs();
          if (selectedIDs.length !== 1)
            return;
          var selectedWayID = selectedIDs[0];
          if (!context2.hasEntity(selectedWayID))
            return;
          var resultWayIDs = [selectedWayID];
          var edge, crossedEdge, crossedWayID;
          if (this.issue.entityIds[0] === selectedWayID) {
            edge = this.issue.data.edges[0];
            crossedEdge = this.issue.data.edges[1];
            crossedWayID = this.issue.entityIds[1];
          } else {
            edge = this.issue.data.edges[1];
            crossedEdge = this.issue.data.edges[0];
            crossedWayID = this.issue.entityIds[0];
          }
          var crossingLoc = this.issue.loc;
          var projection2 = context2.projection;
          var action = function actionAddStructure(graph) {
            var edgeNodes = [graph.entity(edge[0]), graph.entity(edge[1])];
            var crossedWay = graph.hasEntity(crossedWayID);
            var structLengthMeters = crossedWay && isFinite(crossedWay.tags.width) && Number(crossedWay.tags.width);
            if (!structLengthMeters) {
              structLengthMeters = crossedWay && crossedWay.impliedLineWidthMeters();
            }
            if (structLengthMeters) {
              if (getFeatureType(crossedWay, graph) === "railway") {
                structLengthMeters *= 2;
              }
            } else {
              structLengthMeters = 8;
            }
            var a1 = geoAngle(edgeNodes[0], edgeNodes[1], projection2) + Math.PI;
            var a2 = geoAngle(graph.entity(crossedEdge[0]), graph.entity(crossedEdge[1]), projection2) + Math.PI;
            var crossingAngle = Math.max(a1, a2) - Math.min(a1, a2);
            if (crossingAngle > Math.PI)
              crossingAngle -= Math.PI;
            structLengthMeters = structLengthMeters / 2 / Math.sin(crossingAngle) * 2;
            structLengthMeters += 4;
            structLengthMeters = Math.min(Math.max(structLengthMeters, 4), 50);
            function geomToProj(geoPoint) {
              return [
                geoLonToMeters(geoPoint[0], geoPoint[1]),
                geoLatToMeters(geoPoint[1])
              ];
            }
            function projToGeom(projPoint) {
              var lat = geoMetersToLat(projPoint[1]);
              return [
                geoMetersToLon(projPoint[0], lat),
                lat
              ];
            }
            var projEdgeNode1 = geomToProj(edgeNodes[0].loc);
            var projEdgeNode2 = geomToProj(edgeNodes[1].loc);
            var projectedAngle = geoVecAngle(projEdgeNode1, projEdgeNode2);
            var projectedCrossingLoc = geomToProj(crossingLoc);
            var linearToSphericalMetersRatio = geoVecLength(projEdgeNode1, projEdgeNode2) / geoSphericalDistance(edgeNodes[0].loc, edgeNodes[1].loc);
            function locSphericalDistanceFromCrossingLoc(angle2, distanceMeters) {
              var lengthSphericalMeters = distanceMeters * linearToSphericalMetersRatio;
              return projToGeom([
                projectedCrossingLoc[0] + Math.cos(angle2) * lengthSphericalMeters,
                projectedCrossingLoc[1] + Math.sin(angle2) * lengthSphericalMeters
              ]);
            }
            var endpointLocGetter1 = function(lengthMeters) {
              return locSphericalDistanceFromCrossingLoc(projectedAngle, lengthMeters);
            };
            var endpointLocGetter2 = function(lengthMeters) {
              return locSphericalDistanceFromCrossingLoc(projectedAngle + Math.PI, lengthMeters);
            };
            var minEdgeLengthMeters = 0.55;
            function determineEndpoint(edge2, endNode, locGetter) {
              var newNode;
              var idealLengthMeters = structLengthMeters / 2;
              var crossingToEdgeEndDistance = geoSphericalDistance(crossingLoc, endNode.loc);
              if (crossingToEdgeEndDistance - idealLengthMeters > minEdgeLengthMeters) {
                var idealNodeLoc = locGetter(idealLengthMeters);
                newNode = osmNode();
                graph = actionAddMidpoint({ loc: idealNodeLoc, edge: edge2 }, newNode)(graph);
              } else {
                var edgeCount = 0;
                endNode.parentIntersectionWays(graph).forEach(function(way) {
                  way.nodes.forEach(function(nodeID) {
                    if (nodeID === endNode.id) {
                      if (endNode.id === way.first() && endNode.id !== way.last() || endNode.id === way.last() && endNode.id !== way.first()) {
                        edgeCount += 1;
                      } else {
                        edgeCount += 2;
                      }
                    }
                  });
                });
                if (edgeCount >= 3) {
                  var insetLength = crossingToEdgeEndDistance - minEdgeLengthMeters;
                  if (insetLength > minEdgeLengthMeters) {
                    var insetNodeLoc = locGetter(insetLength);
                    newNode = osmNode();
                    graph = actionAddMidpoint({ loc: insetNodeLoc, edge: edge2 }, newNode)(graph);
                  }
                }
              }
              if (!newNode)
                newNode = endNode;
              var splitAction = actionSplit([newNode.id]).limitWays(resultWayIDs);
              graph = splitAction(graph);
              if (splitAction.getCreatedWayIDs().length) {
                resultWayIDs.push(splitAction.getCreatedWayIDs()[0]);
              }
              return newNode;
            }
            var structEndNode1 = determineEndpoint(edge, edgeNodes[1], endpointLocGetter1);
            var structEndNode2 = determineEndpoint([edgeNodes[0].id, structEndNode1.id], edgeNodes[0], endpointLocGetter2);
            var structureWay = resultWayIDs.map(function(id2) {
              return graph.entity(id2);
            }).find(function(way) {
              return way.nodes.indexOf(structEndNode1.id) !== -1 && way.nodes.indexOf(structEndNode2.id) !== -1;
            });
            var tags = Object.assign({}, structureWay.tags);
            if (bridgeOrTunnel === "bridge") {
              tags.bridge = "yes";
              tags.layer = "1";
            } else {
              var tunnelValue = "yes";
              if (getFeatureType(structureWay, graph) === "waterway") {
                tunnelValue = "culvert";
              }
              tags.tunnel = tunnelValue;
              tags.layer = "-1";
            }
            graph = actionChangeTags(structureWay.id, tags)(graph);
            return graph;
          };
          context2.perform(action, _t("issues.fix." + fixTitleID + ".annotation"));
          context2.enter(modeSelect(context2, resultWayIDs));
        }
      });
    }
    function makeConnectWaysFix(connectionTags) {
      var fixTitleID = "connect_features";
      var fixIcon = "iD-icon-crossing";
      if (connectionTags.highway === "crossing") {
        fixTitleID = "connect_using_crossing";
        fixIcon = "temaki-pedestrian";
      }
      if (connectionTags.ford) {
        fixTitleID = "connect_using_ford";
        fixIcon = "roentgen-ford";
      }
      const fix = new validationIssueFix({
        icon: fixIcon,
        title: _t.append("issues.fix." + fixTitleID + ".title"),
        onClick: function(context2) {
          var loc = this.issue.loc;
          var edges = this.issue.data.edges;
          context2.perform(
            function actionConnectCrossingWays(graph) {
              var node = osmNode({ loc, tags: connectionTags });
              graph = graph.replace(node);
              var nodesToMerge = [node.id];
              var mergeThresholdInMeters = 0.75;
              edges.forEach(function(edge) {
                var edgeNodes = [graph.entity(edge[0]), graph.entity(edge[1])];
                var nearby = geoSphericalClosestNode(edgeNodes, loc);
                if ((!nearby.node.hasInterestingTags() || nearby.node.isCrossing()) && nearby.distance < mergeThresholdInMeters) {
                  nodesToMerge.push(nearby.node.id);
                } else {
                  graph = actionAddMidpoint({ loc, edge }, node)(graph);
                }
              });
              if (nodesToMerge.length > 1) {
                graph = actionMergeNodes(nodesToMerge, loc)(graph);
              }
              return graph;
            },
            _t("issues.fix.connect_crossing_features.annotation")
          );
        }
      });
      fix._connectionTags = connectionTags;
      return fix;
    }
    function makeChangeLayerFix(higherOrLower) {
      return new validationIssueFix({
        icon: "iD-icon-" + (higherOrLower === "higher" ? "up" : "down"),
        title: _t.append("issues.fix.tag_this_as_" + higherOrLower + ".title"),
        onClick: function(context2) {
          var mode = context2.mode();
          if (!mode || mode.id !== "select")
            return;
          var selectedIDs = mode.selectedIDs();
          if (selectedIDs.length !== 1)
            return;
          var selectedID = selectedIDs[0];
          if (!this.issue.entityIds.some(function(entityId) {
            return entityId === selectedID;
          }))
            return;
          var entity = context2.hasEntity(selectedID);
          if (!entity)
            return;
          var tags = Object.assign({}, entity.tags);
          var layer = tags.layer && Number(tags.layer);
          if (layer && !isNaN(layer)) {
            if (higherOrLower === "higher") {
              layer += 1;
            } else {
              layer -= 1;
            }
          } else {
            if (higherOrLower === "higher") {
              layer = 1;
            } else {
              layer = -1;
            }
          }
          tags.layer = layer.toString();
          context2.perform(
            actionChangeTags(entity.id, tags),
            _t("operations.change_tags.annotation")
          );
        }
      });
    }
    validation.type = type2;
    return validation;
  }

  // modules/behavior/draw_way.js
  function behaviorDrawWay(context, wayID, mode, startGraph) {
    const keybinding = utilKeybinding("drawWay");
    var dispatch14 = dispatch_default("rejectedSelfIntersection");
    var behavior = behaviorDraw(context);
    var _nodeIndex;
    var _origWay;
    var _wayGeometry;
    var _headNodeID;
    var _annotation;
    var _pointerHasMoved = false;
    var _drawNode;
    var _didResolveTempEdit = false;
    function createDrawNode(loc) {
      _drawNode = osmNode({ loc });
      context.pauseChangeDispatch();
      context.replace(function actionAddDrawNode(graph) {
        var way = graph.entity(wayID);
        return graph.replace(_drawNode).replace(way.addNode(_drawNode.id, _nodeIndex));
      }, _annotation);
      context.resumeChangeDispatch();
      setActiveElements();
    }
    function removeDrawNode() {
      context.pauseChangeDispatch();
      context.replace(
        function actionDeleteDrawNode(graph) {
          var way = graph.entity(wayID);
          return graph.replace(way.removeNode(_drawNode.id)).remove(_drawNode);
        },
        _annotation
      );
      _drawNode = void 0;
      context.resumeChangeDispatch();
    }
    function keydown(d3_event) {
      if (d3_event.keyCode === utilKeybinding.modifierCodes.alt) {
        if (context.surface().classed("nope")) {
          context.surface().classed("nope-suppressed", true);
        }
        context.surface().classed("nope", false).classed("nope-disabled", true);
      }
    }
    function keyup(d3_event) {
      if (d3_event.keyCode === utilKeybinding.modifierCodes.alt) {
        if (context.surface().classed("nope-suppressed")) {
          context.surface().classed("nope", true);
        }
        context.surface().classed("nope-suppressed", false).classed("nope-disabled", false);
      }
    }
    function allowsVertex(d2) {
      return d2.geometry(context.graph()) === "vertex" || _mainPresetIndex.allowsVertex(d2, context.graph());
    }
    function move(d3_event, datum2) {
      var loc = context.map().mouseCoordinates();
      if (!_drawNode)
        createDrawNode(loc);
      context.surface().classed("nope-disabled", d3_event.altKey);
      var targetLoc = datum2 && datum2.properties && datum2.properties.entity && allowsVertex(datum2.properties.entity) && datum2.properties.entity.loc;
      var targetNodes = datum2 && datum2.properties && datum2.properties.nodes;
      if (targetLoc) {
        loc = targetLoc;
      } else if (targetNodes) {
        var choice = geoChooseEdge(targetNodes, context.map().mouse(), context.projection, _drawNode.id);
        if (choice) {
          loc = choice.loc;
        }
      }
      context.replace(actionMoveNode(_drawNode.id, loc), _annotation);
      _drawNode = context.entity(_drawNode.id);
      checkGeometry(
        true
        /* includeDrawNode */
      );
    }
    function checkGeometry(includeDrawNode) {
      var nopeDisabled = context.surface().classed("nope-disabled");
      var isInvalid = isInvalidGeometry(includeDrawNode);
      if (nopeDisabled) {
        context.surface().classed("nope", false).classed("nope-suppressed", isInvalid);
      } else {
        context.surface().classed("nope", isInvalid).classed("nope-suppressed", false);
      }
    }
    function isInvalidGeometry(includeDrawNode) {
      var testNode = _drawNode;
      var parentWay = context.graph().entity(wayID);
      var nodes = context.graph().childNodes(parentWay).slice();
      if (includeDrawNode) {
        if (parentWay.isClosed()) {
          nodes.pop();
        }
      } else {
        if (parentWay.isClosed()) {
          if (nodes.length < 3)
            return false;
          if (_drawNode)
            nodes.splice(-2, 1);
          testNode = nodes[nodes.length - 2];
        } else {
          return false;
        }
      }
      return testNode && geoHasSelfIntersections(nodes, testNode.id);
    }
    function undone() {
      _didResolveTempEdit = true;
      context.pauseChangeDispatch();
      var nextMode;
      if (context.graph() === startGraph) {
        nextMode = modeSelect(context, [wayID]);
      } else {
        context.pop(1);
        nextMode = mode;
      }
      context.perform(actionNoop());
      context.pop(1);
      context.resumeChangeDispatch();
      context.enter(nextMode);
    }
    function setActiveElements() {
      if (!_drawNode)
        return;
      context.surface().selectAll("." + _drawNode.id).classed("active", true);
    }
    function resetToStartGraph() {
      while (context.graph() !== startGraph) {
        context.pop();
      }
    }
    var drawWay = function(surface) {
      _drawNode = void 0;
      _didResolveTempEdit = false;
      _origWay = context.entity(wayID);
      if (typeof _nodeIndex === "number") {
        _headNodeID = _origWay.nodes[_nodeIndex];
      } else if (_origWay.isClosed()) {
        _headNodeID = _origWay.nodes[_origWay.nodes.length - 2];
      } else {
        _headNodeID = _origWay.nodes[_origWay.nodes.length - 1];
      }
      _wayGeometry = _origWay.geometry(context.graph());
      _annotation = _t(
        (_origWay.nodes.length === (_origWay.isClosed() ? 2 : 1) ? "operations.start.annotation." : "operations.continue.annotation.") + _wayGeometry
      );
      _pointerHasMoved = false;
      context.pauseChangeDispatch();
      context.perform(actionNoop(), _annotation);
      context.resumeChangeDispatch();
      behavior.hover().initialNodeID(_headNodeID);
      behavior.on("move", function() {
        _pointerHasMoved = true;
        move.apply(this, arguments);
      }).on("down", function() {
        move.apply(this, arguments);
      }).on("downcancel", function() {
        if (_drawNode)
          removeDrawNode();
      }).on("click", drawWay.add).on("clickWay", drawWay.addWay).on("clickNode", drawWay.addNode).on("undo", context.undo).on("cancel", drawWay.cancel).on("finish", drawWay.finish);
      select_default2(window).on("keydown.drawWay", keydown).on("keyup.drawWay", keyup);
      context.map().dblclickZoomEnable(false).on("drawn.draw", setActiveElements);
      setActiveElements();
      surface.call(behavior);
      context.history().on("undone.draw", undone);
    };
    drawWay.off = function(surface) {
      if (!_didResolveTempEdit) {
        context.pauseChangeDispatch();
        resetToStartGraph();
        context.resumeChangeDispatch();
      }
      _drawNode = void 0;
      _nodeIndex = void 0;
      context.map().on("drawn.draw", null);
      surface.call(behavior.off).selectAll(".active").classed("active", false);
      surface.classed("nope", false).classed("nope-suppressed", false).classed("nope-disabled", false);
      select_default2(window).on("keydown.drawWay", null).on("keyup.drawWay", null);
      context.history().on("undone.draw", null);
    };
    function attemptAdd(d2, loc, doAdd) {
      if (_drawNode) {
        context.replace(actionMoveNode(_drawNode.id, loc), _annotation);
        _drawNode = context.entity(_drawNode.id);
      } else {
        createDrawNode(loc);
      }
      checkGeometry(
        true
        /* includeDrawNode */
      );
      if (d2 && d2.properties && d2.properties.nope || context.surface().classed("nope")) {
        if (!_pointerHasMoved) {
          removeDrawNode();
        }
        dispatch14.call("rejectedSelfIntersection", this);
        return;
      }
      context.pauseChangeDispatch();
      doAdd();
      _didResolveTempEdit = true;
      context.resumeChangeDispatch();
      context.enter(mode);
    }
    drawWay.add = function(loc, d2) {
      attemptAdd(d2, loc, function() {
      });
    };
    drawWay.addWay = function(loc, edge, d2) {
      attemptAdd(d2, loc, function() {
        context.replace(
          actionAddMidpoint({ loc, edge }, _drawNode),
          _annotation
        );
      });
    };
    drawWay.addNode = function(node, d2) {
      if (node.id === _headNodeID || // or the first node when drawing an area
      _origWay.isClosed() && node.id === _origWay.first()) {
        drawWay.finish();
        return;
      }
      attemptAdd(d2, node.loc, function() {
        context.replace(
          function actionReplaceDrawNode(graph) {
            graph = graph.replace(graph.entity(wayID).removeNode(_drawNode.id)).remove(_drawNode);
            return graph.replace(graph.entity(wayID).addNode(node.id, _nodeIndex));
          },
          _annotation
        );
      });
    };
    function getFeatureType(ways) {
      if (ways.every((way) => way.isClosed()))
        return "area";
      if (ways.every((way) => !way.isClosed()))
        return "line";
      return "generic";
    }
    function followMode() {
      if (_didResolveTempEdit)
        return;
      try {
        const isDrawingArea = _origWay.nodes[0] === _origWay.nodes.slice(-1)[0];
        const [secondLastNodeId, lastNodeId] = _origWay.nodes.slice(isDrawingArea ? -3 : -2);
        const historyGraph = context.history().graph();
        if (!lastNodeId || !secondLastNodeId || !historyGraph.hasEntity(lastNodeId) || !historyGraph.hasEntity(secondLastNodeId)) {
          context.ui().flash.duration(4e3).iconName("#iD-icon-no").label(_t.append("operations.follow.error.needs_more_initial_nodes"))();
          return;
        }
        const lastNodesParents = historyGraph.parentWays(historyGraph.entity(lastNodeId)).filter((w2) => w2.id !== wayID);
        const secondLastNodesParents = historyGraph.parentWays(historyGraph.entity(secondLastNodeId)).filter((w2) => w2.id !== wayID);
        const featureType = getFeatureType(lastNodesParents);
        if (lastNodesParents.length !== 1 || secondLastNodesParents.length === 0) {
          context.ui().flash.duration(4e3).iconName("#iD-icon-no").label(_t.append("operations.follow.error.intersection_of_multiple_ways.".concat(featureType)))();
          return;
        }
        if (!secondLastNodesParents.some((n3) => n3.id === lastNodesParents[0].id)) {
          context.ui().flash.duration(4e3).iconName("#iD-icon-no").label(_t.append("operations.follow.error.intersection_of_different_ways.".concat(featureType)))();
          return;
        }
        const way = lastNodesParents[0];
        const indexOfLast = way.nodes.indexOf(lastNodeId);
        const indexOfSecondLast = way.nodes.indexOf(secondLastNodeId);
        const isDescendingPastZero = indexOfLast === way.nodes.length - 2 && indexOfSecondLast === 0;
        let nextNodeIndex = indexOfLast + (indexOfLast > indexOfSecondLast && !isDescendingPastZero ? 1 : -1);
        if (nextNodeIndex === -1)
          nextNodeIndex = indexOfSecondLast === 1 ? way.nodes.length - 2 : 1;
        const nextNode = historyGraph.entity(way.nodes[nextNodeIndex]);
        drawWay.addNode(nextNode, {
          geometry: { type: "Point", coordinates: nextNode.loc },
          id: nextNode.id,
          properties: { target: true, entity: nextNode }
        });
      } catch {
        context.ui().flash.duration(4e3).iconName("#iD-icon-no").label(_t.append("operations.follow.error.unknown"))();
      }
    }
    keybinding.on(_t("operations.follow.key"), followMode);
    select_default2(document).call(keybinding);
    drawWay.finish = function() {
      checkGeometry(
        false
        /* includeDrawNode */
      );
      if (context.surface().classed("nope")) {
        dispatch14.call("rejectedSelfIntersection", this);
        return;
      }
      context.pauseChangeDispatch();
      context.pop(1);
      _didResolveTempEdit = true;
      context.resumeChangeDispatch();
      var way = context.hasEntity(wayID);
      if (!way || way.isDegenerate()) {
        drawWay.cancel();
        return;
      }
      window.setTimeout(function() {
        context.map().dblclickZoomEnable(true);
      }, 1e3);
      var isNewFeature = !mode.isContinuing;
      context.enter(modeSelect(context, [wayID]).newFeature(isNewFeature));
    };
    drawWay.cancel = function() {
      context.pauseChangeDispatch();
      resetToStartGraph();
      context.resumeChangeDispatch();
      window.setTimeout(function() {
        context.map().dblclickZoomEnable(true);
      }, 1e3);
      context.surface().classed("nope", false).classed("nope-disabled", false).classed("nope-suppressed", false);
      context.enter(modeBrowse(context));
    };
    drawWay.nodeIndex = function(val) {
      if (!arguments.length)
        return _nodeIndex;
      _nodeIndex = val;
      return drawWay;
    };
    drawWay.activeID = function() {
      if (!arguments.length)
        return _drawNode && _drawNode.id;
      return drawWay;
    };
    return utilRebind(drawWay, dispatch14, "on");
  }

  // modules/modes/draw_line.js
  function modeDrawLine(context, wayID, startGraph, button, affix, continuing) {
    var mode = {
      button,
      id: "draw-line"
    };
    var behavior = behaviorDrawWay(context, wayID, mode, startGraph).on("rejectedSelfIntersection.modeDrawLine", function() {
      context.ui().flash.iconName("#iD-icon-no").label(_t.append("self_intersection.error.lines"))();
    });
    mode.wayID = wayID;
    mode.isContinuing = continuing;
    mode.enter = function() {
      behavior.nodeIndex(affix === "prefix" ? 0 : void 0);
      context.install(behavior);
    };
    mode.exit = function() {
      context.uninstall(behavior);
    };
    mode.selectedIDs = function() {
      return [wayID];
    };
    mode.activeID = function() {
      return behavior && behavior.activeID() || [];
    };
    return mode;
  }

  // modules/validations/disconnected_way.js
  function validationDisconnectedWay() {
    var type2 = "disconnected_way";
    function isTaggedAsHighway(entity) {
      return osmRoutableHighwayTagValues[entity.tags.highway];
    }
    var validation = function checkDisconnectedWay(entity, graph) {
      var routingIslandWays = routingIslandForEntity(entity);
      if (!routingIslandWays)
        return [];
      return [new validationIssue({
        type: type2,
        subtype: "highway",
        severity: "warning",
        message: function(context) {
          var entity2 = this.entityIds.length && context.hasEntity(this.entityIds[0]);
          var label = entity2 && utilDisplayLabel(entity2, context.graph());
          return _t.append("issues.disconnected_way.routable.message", { count: this.entityIds.length, highway: label });
        },
        reference: showReference,
        entityIds: Array.from(routingIslandWays).map(function(way) {
          return way.id;
        }),
        dynamicFixes: makeFixes
      })];
      function makeFixes(context) {
        var fixes = [];
        var singleEntity = this.entityIds.length === 1 && context.hasEntity(this.entityIds[0]);
        if (singleEntity) {
          if (singleEntity.type === "way" && !singleEntity.isClosed()) {
            var textDirection = _mainLocalizer.textDirection();
            var startFix = makeContinueDrawingFixIfAllowed(textDirection, singleEntity.first(), "start");
            if (startFix)
              fixes.push(startFix);
            var endFix = makeContinueDrawingFixIfAllowed(textDirection, singleEntity.last(), "end");
            if (endFix)
              fixes.push(endFix);
          }
          if (!fixes.length) {
            fixes.push(new validationIssueFix({
              title: _t.append("issues.fix.connect_feature.title")
            }));
          }
          fixes.push(new validationIssueFix({
            icon: "iD-operation-delete",
            title: _t.append("issues.fix.delete_feature.title"),
            entityIds: [singleEntity.id],
            onClick: function(context2) {
              var id2 = this.issue.entityIds[0];
              var operation2 = operationDelete(context2, [id2]);
              if (!operation2.disabled()) {
                operation2();
              }
            }
          }));
        } else {
          fixes.push(new validationIssueFix({
            title: _t.append("issues.fix.connect_features.title")
          }));
        }
        return fixes;
      }
      function showReference(selection2) {
        selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.disconnected_way.routable.reference"));
      }
      function routingIslandForEntity(entity2) {
        var routingIsland = /* @__PURE__ */ new Set();
        var waysToCheck = [];
        function queueParentWays(node) {
          graph.parentWays(node).forEach(function(parentWay) {
            if (!routingIsland.has(parentWay) && // only check each feature once
            isRoutableWay(parentWay, false)) {
              routingIsland.add(parentWay);
              waysToCheck.push(parentWay);
            }
          });
        }
        if (entity2.type === "way" && isRoutableWay(entity2, true)) {
          routingIsland.add(entity2);
          waysToCheck.push(entity2);
        } else if (entity2.type === "node" && isRoutableNode(entity2)) {
          routingIsland.add(entity2);
          queueParentWays(entity2);
        } else {
          return null;
        }
        while (waysToCheck.length) {
          var wayToCheck = waysToCheck.pop();
          var childNodes = graph.childNodes(wayToCheck);
          for (var i3 in childNodes) {
            var vertex = childNodes[i3];
            if (isConnectedVertex(vertex)) {
              return null;
            }
            if (isRoutableNode(vertex)) {
              routingIsland.add(vertex);
            }
            queueParentWays(vertex);
          }
        }
        return routingIsland;
      }
      function isConnectedVertex(vertex) {
        var osm = services.osm;
        if (osm && !osm.isDataLoaded(vertex.loc))
          return true;
        if (vertex.tags.entrance && vertex.tags.entrance !== "no")
          return true;
        if (vertex.tags.amenity === "parking_entrance")
          return true;
        return false;
      }
      function isRoutableNode(node) {
        if (node.tags.highway === "elevator")
          return true;
        return false;
      }
      function isRoutableWay(way, ignoreInnerWays) {
        if (isTaggedAsHighway(way) || way.tags.route === "ferry")
          return true;
        return graph.parentRelations(way).some(function(parentRelation) {
          if (parentRelation.tags.type === "route" && parentRelation.tags.route === "ferry")
            return true;
          if (parentRelation.isMultipolygon() && isTaggedAsHighway(parentRelation) && (!ignoreInnerWays || parentRelation.memberById(way.id).role !== "inner"))
            return true;
          return false;
        });
      }
      function makeContinueDrawingFixIfAllowed(textDirection, vertexID, whichEnd) {
        var vertex = graph.hasEntity(vertexID);
        if (!vertex || vertex.tags.noexit === "yes")
          return null;
        var useLeftContinue = whichEnd === "start" && textDirection === "ltr" || whichEnd === "end" && textDirection === "rtl";
        return new validationIssueFix({
          icon: "iD-operation-continue" + (useLeftContinue ? "-left" : ""),
          title: _t.append("issues.fix.continue_from_" + whichEnd + ".title"),
          entityIds: [vertexID],
          onClick: function(context) {
            var wayId = this.issue.entityIds[0];
            var way = context.hasEntity(wayId);
            var vertexId = this.entityIds[0];
            var vertex2 = context.hasEntity(vertexId);
            if (!way || !vertex2)
              return;
            var map2 = context.map();
            if (!context.editable() || !map2.trimmedExtent().contains(vertex2.loc)) {
              map2.zoomToEase(vertex2);
            }
            context.enter(
              modeDrawLine(context, wayId, context.graph(), "line", way.affix(vertexId), true)
            );
          }
        });
      }
    };
    validation.type = type2;
    return validation;
  }

  // modules/validations/invalid_format.js
  function validationFormatting() {
    var type2 = "invalid_format";
    var validation = function(entity) {
      var issues = [];
      function isValidEmail(email) {
        var valid_email = /^[^\(\)\\,":;<>@\[\]]+@[^\(\)\\,":;<>@\[\]\.]+(?:\.[a-z0-9-]+)*$/i;
        return !email || valid_email.test(email);
      }
      function showReferenceEmail(selection2) {
        selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.invalid_format.email.reference"));
      }
      if (entity.tags.email) {
        var emails = entity.tags.email.split(";").map(function(s2) {
          return s2.trim();
        }).filter(function(x2) {
          return !isValidEmail(x2);
        });
        if (emails.length) {
          issues.push(new validationIssue({
            type: type2,
            subtype: "email",
            severity: "warning",
            message: function(context) {
              var entity2 = context.hasEntity(this.entityIds[0]);
              return entity2 ? _t.append(
                "issues.invalid_format.email.message" + this.data,
                { feature: utilDisplayLabel(entity2, context.graph()), email: emails.join(", ") }
              ) : "";
            },
            reference: showReferenceEmail,
            entityIds: [entity.id],
            hash: emails.join(),
            data: emails.length > 1 ? "_multi" : ""
          }));
        }
      }
      return issues;
    };
    validation.type = type2;
    return validation;
  }

  // modules/validations/help_request.js
  function validationHelpRequest(context) {
    var type2 = "help_request";
    var validation = function checkFixmeTag(entity) {
      if (!entity.tags.fixme)
        return [];
      if (entity.version === void 0)
        return [];
      if (entity.v !== void 0) {
        var baseEntity = context.history().base().hasEntity(entity.id);
        if (!baseEntity || !baseEntity.tags.fixme)
          return [];
      }
      return [new validationIssue({
        type: type2,
        subtype: "fixme_tag",
        severity: "warning",
        message: function(context2) {
          var entity2 = context2.hasEntity(this.entityIds[0]);
          return entity2 ? _t.append("issues.fixme_tag.message", {
            feature: utilDisplayLabel(
              entity2,
              context2.graph(),
              true
              /* verbose */
            )
          }) : "";
        },
        dynamicFixes: function() {
          return [
            new validationIssueFix({
              title: _t.append("issues.fix.address_the_concern.title")
            })
          ];
        },
        reference: showReference,
        entityIds: [entity.id]
      })];
      function showReference(selection2) {
        selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.fixme_tag.reference"));
      }
    };
    validation.type = type2;
    return validation;
  }

  // modules/validations/impossible_oneway.js
  function validationImpossibleOneway() {
    var type2 = "impossible_oneway";
    var validation = function checkImpossibleOneway(entity, graph) {
      if (entity.type !== "way" || entity.geometry(graph) !== "line")
        return [];
      if (entity.isClosed())
        return [];
      if (!typeForWay(entity))
        return [];
      if (!isOneway(entity))
        return [];
      var firstIssues = issuesForNode(entity, entity.first());
      var lastIssues = issuesForNode(entity, entity.last());
      return firstIssues.concat(lastIssues);
      function typeForWay(way) {
        if (way.geometry(graph) !== "line")
          return null;
        if (osmRoutableHighwayTagValues[way.tags.highway])
          return "highway";
        if (osmFlowingWaterwayTagValues[way.tags.waterway])
          return "waterway";
        return null;
      }
      function isOneway(way) {
        if (way.tags.oneway === "yes")
          return true;
        if (way.tags.oneway)
          return false;
        for (var key in way.tags) {
          if (osmOneWayTags[key] && osmOneWayTags[key][way.tags[key]]) {
            return true;
          }
        }
        return false;
      }
      function nodeOccursMoreThanOnce(way, nodeID) {
        var occurrences = 0;
        for (var index in way.nodes) {
          if (way.nodes[index] === nodeID) {
            occurrences += 1;
            if (occurrences > 1)
              return true;
          }
        }
        return false;
      }
      function isConnectedViaOtherTypes(way, node) {
        var wayType = typeForWay(way);
        if (wayType === "highway") {
          if (node.tags.entrance && node.tags.entrance !== "no")
            return true;
          if (node.tags.amenity === "parking_entrance")
            return true;
        } else if (wayType === "waterway") {
          if (node.id === way.first()) {
            if (node.tags.natural === "spring")
              return true;
          } else {
            if (node.tags.manhole === "drain")
              return true;
          }
        }
        return graph.parentWays(node).some(function(parentWay) {
          if (parentWay.id === way.id)
            return false;
          if (wayType === "highway") {
            if (parentWay.geometry(graph) === "area" && osmRoutableHighwayTagValues[parentWay.tags.highway])
              return true;
            if (parentWay.tags.route === "ferry")
              return true;
            return graph.parentRelations(parentWay).some(function(parentRelation) {
              if (parentRelation.tags.type === "route" && parentRelation.tags.route === "ferry")
                return true;
              return parentRelation.isMultipolygon() && osmRoutableHighwayTagValues[parentRelation.tags.highway];
            });
          } else if (wayType === "waterway") {
            if (parentWay.tags.natural === "water" || parentWay.tags.natural === "coastline")
              return true;
          }
          return false;
        });
      }
      function issuesForNode(way, nodeID) {
        var isFirst = nodeID === way.first();
        var wayType = typeForWay(way);
        if (nodeOccursMoreThanOnce(way, nodeID))
          return [];
        var osm = services.osm;
        if (!osm)
          return [];
        var node = graph.hasEntity(nodeID);
        if (!node || !osm.isDataLoaded(node.loc))
          return [];
        if (isConnectedViaOtherTypes(way, node))
          return [];
        var attachedWaysOfSameType = graph.parentWays(node).filter(function(parentWay) {
          if (parentWay.id === way.id)
            return false;
          return typeForWay(parentWay) === wayType;
        });
        if (wayType === "waterway" && attachedWaysOfSameType.length === 0)
          return [];
        var attachedOneways = attachedWaysOfSameType.filter(function(attachedWay) {
          return isOneway(attachedWay);
        });
        if (attachedOneways.length < attachedWaysOfSameType.length)
          return [];
        if (attachedOneways.length) {
          var connectedEndpointsOkay = attachedOneways.some(function(attachedOneway) {
            if ((isFirst ? attachedOneway.first() : attachedOneway.last()) !== nodeID)
              return true;
            if (nodeOccursMoreThanOnce(attachedOneway, nodeID))
              return true;
            return false;
          });
          if (connectedEndpointsOkay)
            return [];
        }
        var placement = isFirst ? "start" : "end", messageID = wayType + ".", referenceID = wayType + ".";
        if (wayType === "waterway") {
          messageID += "connected." + placement;
          referenceID += "connected";
        } else {
          messageID += placement;
          referenceID += placement;
        }
        return [new validationIssue({
          type: type2,
          subtype: wayType,
          severity: "warning",
          message: function(context) {
            var entity2 = context.hasEntity(this.entityIds[0]);
            return entity2 ? _t.append("issues.impossible_oneway." + messageID + ".message", {
              feature: utilDisplayLabel(entity2, context.graph())
            }) : "";
          },
          reference: getReference(referenceID),
          entityIds: [way.id, node.id],
          dynamicFixes: function() {
            var fixes = [];
            if (attachedOneways.length) {
              fixes.push(new validationIssueFix({
                icon: "iD-operation-reverse",
                title: _t.append("issues.fix.reverse_feature.title"),
                entityIds: [way.id],
                onClick: function(context) {
                  var id2 = this.issue.entityIds[0];
                  context.perform(actionReverse(id2), _t("operations.reverse.annotation.line", { n: 1 }));
                }
              }));
            }
            if (node.tags.noexit !== "yes") {
              var textDirection = _mainLocalizer.textDirection();
              var useLeftContinue = isFirst && textDirection === "ltr" || !isFirst && textDirection === "rtl";
              fixes.push(new validationIssueFix({
                icon: "iD-operation-continue" + (useLeftContinue ? "-left" : ""),
                title: _t.append("issues.fix.continue_from_" + (isFirst ? "start" : "end") + ".title"),
                onClick: function(context) {
                  var entityID = this.issue.entityIds[0];
                  var vertexID = this.issue.entityIds[1];
                  var way2 = context.entity(entityID);
                  var vertex = context.entity(vertexID);
                  continueDrawing(way2, vertex, context);
                }
              }));
            }
            return fixes;
          },
          loc: node.loc
        })];
        function getReference(referenceID2) {
          return function showReference(selection2) {
            selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.impossible_oneway." + referenceID2 + ".reference"));
          };
        }
      }
    };
    function continueDrawing(way, vertex, context) {
      var map2 = context.map();
      if (!context.editable() || !map2.trimmedExtent().contains(vertex.loc)) {
        map2.zoomToEase(vertex);
      }
      context.enter(
        modeDrawLine(context, way.id, context.graph(), "line", way.affix(vertex.id), true)
      );
    }
    validation.type = type2;
    return validation;
  }

  // modules/validations/incompatible_source.js
  function validationIncompatibleSource() {
    const type2 = "incompatible_source";
    const incompatibleRules = [
      {
        id: "amap",
        regex: /(^amap$|^amap\.com|autonavi|mapabc|高德)/i
      },
      {
        id: "baidu",
        regex: /(baidu|mapbar|百度)/i
      },
      {
        id: "google",
        regex: /google/i,
        exceptRegex: /((books|drive)\.google|google\s?(books|drive|plus))|(esri\/Google_Africa_Buildings)/i
      }
    ];
    const validation = function checkIncompatibleSource(entity) {
      const entitySources = entity.tags && entity.tags.source && entity.tags.source.split(";");
      if (!entitySources)
        return [];
      const entityID = entity.id;
      return entitySources.map((source) => {
        const matchRule = incompatibleRules.find((rule) => {
          if (!rule.regex.test(source))
            return false;
          if (rule.exceptRegex && rule.exceptRegex.test(source))
            return false;
          return true;
        });
        if (!matchRule)
          return null;
        return new validationIssue({
          type: type2,
          severity: "warning",
          message: (context) => {
            const entity2 = context.hasEntity(entityID);
            return entity2 ? _t.append("issues.incompatible_source.feature.message", {
              feature: utilDisplayLabel(
                entity2,
                context.graph(),
                true
                /* verbose */
              ),
              value: source
            }) : "";
          },
          reference: getReference(matchRule.id),
          entityIds: [entityID],
          hash: source,
          dynamicFixes: () => {
            return [
              new validationIssueFix({ title: _t.append("issues.fix.remove_proprietary_data.title") })
            ];
          }
        });
      }).filter(Boolean);
      function getReference(id2) {
        return function showReference(selection2) {
          selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.incompatible_source.reference.".concat(id2)));
        };
      }
    };
    validation.type = type2;
    return validation;
  }

  // modules/validations/maprules.js
  function validationMaprules() {
    var type2 = "maprules";
    var validation = function checkMaprules(entity, graph) {
      if (!services.maprules)
        return [];
      var rules = services.maprules.validationRules();
      var issues = [];
      for (var i3 = 0; i3 < rules.length; i3++) {
        var rule = rules[i3];
        rule.findIssues(entity, graph, issues);
      }
      return issues;
    };
    validation.type = type2;
    return validation;
  }

  // modules/validations/mismatched_geometry.js
  var import_fast_deep_equal4 = __toESM(require_fast_deep_equal());
  function validationMismatchedGeometry() {
    var type2 = "mismatched_geometry";
    function tagSuggestingLineIsArea(entity) {
      if (entity.type !== "way" || entity.isClosed())
        return null;
      var tagSuggestingArea = entity.tagSuggestingArea();
      if (!tagSuggestingArea) {
        return null;
      }
      var asLine = _mainPresetIndex.matchTags(tagSuggestingArea, "line");
      var asArea = _mainPresetIndex.matchTags(tagSuggestingArea, "area");
      if (asLine && asArea && (0, import_fast_deep_equal4.default)(asLine.tags, asArea.tags)) {
        return null;
      }
      return tagSuggestingArea;
    }
    function makeConnectEndpointsFixOnClick(way, graph) {
      if (way.nodes.length < 3)
        return null;
      var nodes = graph.childNodes(way), testNodes;
      var firstToLastDistanceMeters = geoSphericalDistance(nodes[0].loc, nodes[nodes.length - 1].loc);
      if (firstToLastDistanceMeters < 0.75) {
        testNodes = nodes.slice();
        testNodes.pop();
        testNodes.push(testNodes[0]);
        if (!geoHasSelfIntersections(testNodes, testNodes[0].id)) {
          return function(context) {
            var way2 = context.entity(this.issue.entityIds[0]);
            context.perform(
              actionMergeNodes([way2.nodes[0], way2.nodes[way2.nodes.length - 1]], nodes[0].loc),
              _t("issues.fix.connect_endpoints.annotation")
            );
          };
        }
      }
      testNodes = nodes.slice();
      testNodes.push(testNodes[0]);
      if (!geoHasSelfIntersections(testNodes, testNodes[0].id)) {
        return function(context) {
          var wayId = this.issue.entityIds[0];
          var way2 = context.entity(wayId);
          var nodeId = way2.nodes[0];
          var index = way2.nodes.length;
          context.perform(
            actionAddVertex(wayId, nodeId, index),
            _t("issues.fix.connect_endpoints.annotation")
          );
        };
      }
    }
    function lineTaggedAsAreaIssue(entity) {
      var tagSuggestingArea = tagSuggestingLineIsArea(entity);
      if (!tagSuggestingArea)
        return null;
      var validAsLine = false;
      var presetAsLine = _mainPresetIndex.matchTags(entity.tags, "line");
      if (presetAsLine) {
        validAsLine = true;
        var key = Object.keys(tagSuggestingArea)[0];
        if (presetAsLine.tags[key] && presetAsLine.tags[key] === "*") {
          validAsLine = false;
        }
        if (Object.keys(presetAsLine.tags).length === 0) {
          validAsLine = false;
        }
      }
      return new validationIssue({
        type: type2,
        subtype: "area_as_line",
        severity: "warning",
        message: function(context) {
          var entity2 = context.hasEntity(this.entityIds[0]);
          return entity2 ? _t.append("issues.tag_suggests_area.message", {
            feature: utilDisplayLabel(
              entity2,
              "area",
              true
              /* verbose */
            ),
            tag: utilTagText({ tags: tagSuggestingArea })
          }) : "";
        },
        reference: showReference,
        entityIds: [entity.id],
        hash: JSON.stringify(tagSuggestingArea),
        dynamicFixes: function(context) {
          var fixes = [];
          var entity2 = context.entity(this.entityIds[0]);
          var connectEndsOnClick = makeConnectEndpointsFixOnClick(entity2, context.graph());
          if (!validAsLine) {
            fixes.push(new validationIssueFix({
              title: _t.append("issues.fix.connect_endpoints.title"),
              onClick: connectEndsOnClick
            }));
          }
          fixes.push(new validationIssueFix({
            icon: "iD-operation-delete",
            title: _t.append("issues.fix.remove_tag.title"),
            onClick: function(context2) {
              var entityId = this.issue.entityIds[0];
              var entity3 = context2.entity(entityId);
              var tags = Object.assign({}, entity3.tags);
              for (var key2 in tagSuggestingArea) {
                delete tags[key2];
              }
              context2.perform(
                actionChangeTags(entityId, tags),
                _t("issues.fix.remove_tag.annotation")
              );
            }
          }));
          return fixes;
        }
      });
      function showReference(selection2) {
        selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.tag_suggests_area.reference"));
      }
    }
    function vertexPointIssue(entity, graph) {
      if (entity.type !== "node")
        return null;
      if (Object.keys(entity.tags).length === 0)
        return null;
      if (entity.isOnAddressLine(graph))
        return null;
      var geometry = entity.geometry(graph);
      var allowedGeometries = osmNodeGeometriesForTags(entity.tags);
      if (geometry === "point" && !allowedGeometries.point && allowedGeometries.vertex) {
        return new validationIssue({
          type: type2,
          subtype: "vertex_as_point",
          severity: "warning",
          message: function(context) {
            var entity2 = context.hasEntity(this.entityIds[0]);
            return entity2 ? _t.append("issues.vertex_as_point.message", {
              feature: utilDisplayLabel(
                entity2,
                "vertex",
                true
                /* verbose */
              )
            }) : "";
          },
          reference: function showReference(selection2) {
            selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.vertex_as_point.reference"));
          },
          entityIds: [entity.id]
        });
      } else if (geometry === "vertex" && !allowedGeometries.vertex && allowedGeometries.point) {
        return new validationIssue({
          type: type2,
          subtype: "point_as_vertex",
          severity: "warning",
          message: function(context) {
            var entity2 = context.hasEntity(this.entityIds[0]);
            return entity2 ? _t.append("issues.point_as_vertex.message", {
              feature: utilDisplayLabel(
                entity2,
                "point",
                true
                /* verbose */
              )
            }) : "";
          },
          reference: function showReference(selection2) {
            selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.point_as_vertex.reference"));
          },
          entityIds: [entity.id],
          dynamicFixes: extractPointDynamicFixes
        });
      }
      return null;
    }
    function otherMismatchIssue(entity, graph) {
      if (!entity.hasInterestingTags())
        return null;
      if (entity.type !== "node" && entity.type !== "way")
        return null;
      if (entity.type === "node" && entity.isOnAddressLine(graph))
        return null;
      var sourceGeom = entity.geometry(graph);
      var targetGeoms = entity.type === "way" ? ["point", "vertex"] : ["line", "area"];
      if (sourceGeom === "area")
        targetGeoms.unshift("line");
      var asSource = _mainPresetIndex.match(entity, graph);
      var targetGeom = targetGeoms.find((nodeGeom) => {
        var asTarget = _mainPresetIndex.matchTags(entity.tags, nodeGeom);
        if (!asSource || !asTarget || asSource === asTarget || // sometimes there are two presets with the same tags for different geometries
        (0, import_fast_deep_equal4.default)(asSource.tags, asTarget.tags))
          return false;
        if (asTarget.isFallback())
          return false;
        var primaryKey = Object.keys(asTarget.tags)[0];
        if (primaryKey === "building")
          return false;
        if (asTarget.tags[primaryKey] === "*")
          return false;
        return asSource.isFallback() || asSource.tags[primaryKey] === "*";
      });
      if (!targetGeom)
        return null;
      var subtype = targetGeom + "_as_" + sourceGeom;
      if (targetGeom === "vertex")
        targetGeom = "point";
      if (sourceGeom === "vertex")
        sourceGeom = "point";
      var referenceId = targetGeom + "_as_" + sourceGeom;
      var dynamicFixes;
      if (targetGeom === "point") {
        dynamicFixes = extractPointDynamicFixes;
      } else if (sourceGeom === "area" && targetGeom === "line") {
        dynamicFixes = lineToAreaDynamicFixes;
      }
      return new validationIssue({
        type: type2,
        subtype,
        severity: "warning",
        message: function(context) {
          var entity2 = context.hasEntity(this.entityIds[0]);
          return entity2 ? _t.append("issues." + referenceId + ".message", {
            feature: utilDisplayLabel(
              entity2,
              targetGeom,
              true
              /* verbose */
            )
          }) : "";
        },
        reference: function showReference(selection2) {
          selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.mismatched_geometry.reference"));
        },
        entityIds: [entity.id],
        dynamicFixes
      });
    }
    function lineToAreaDynamicFixes(context) {
      var convertOnClick;
      var entityId = this.entityIds[0];
      var entity = context.entity(entityId);
      var tags = Object.assign({}, entity.tags);
      delete tags.area;
      if (!osmTagSuggestingArea(tags)) {
        convertOnClick = function(context2) {
          var entityId2 = this.issue.entityIds[0];
          var entity2 = context2.entity(entityId2);
          var tags2 = Object.assign({}, entity2.tags);
          if (tags2.area) {
            delete tags2.area;
          }
          context2.perform(
            actionChangeTags(entityId2, tags2),
            _t("issues.fix.convert_to_line.annotation")
          );
        };
      }
      return [
        new validationIssueFix({
          icon: "iD-icon-line",
          title: _t.append("issues.fix.convert_to_line.title"),
          onClick: convertOnClick
        })
      ];
    }
    function extractPointDynamicFixes(context) {
      var entityId = this.entityIds[0];
      var extractOnClick = null;
      if (!context.hasHiddenConnections(entityId)) {
        extractOnClick = function(context2) {
          var entityId2 = this.issue.entityIds[0];
          var action = actionExtract(entityId2, context2.projection);
          context2.perform(
            action,
            _t("operations.extract.annotation", { n: 1 })
          );
          context2.enter(modeSelect(context2, [action.getExtractedNodeID()]));
        };
      }
      return [
        new validationIssueFix({
          icon: "iD-operation-extract",
          title: _t.append("issues.fix.extract_point.title"),
          onClick: extractOnClick
        })
      ];
    }
    function unclosedMultipolygonPartIssues(entity, graph) {
      if (entity.type !== "relation" || !entity.isMultipolygon() || entity.isDegenerate() || // cannot determine issues for incompletely-downloaded relations
      !entity.isComplete(graph))
        return [];
      var sequences = osmJoinWays(entity.members, graph);
      var issues = [];
      for (var i3 in sequences) {
        var sequence = sequences[i3];
        if (!sequence.nodes)
          continue;
        var firstNode = sequence.nodes[0];
        var lastNode = sequence.nodes[sequence.nodes.length - 1];
        if (firstNode === lastNode)
          continue;
        var issue = new validationIssue({
          type: type2,
          subtype: "unclosed_multipolygon_part",
          severity: "warning",
          message: function(context) {
            var entity2 = context.hasEntity(this.entityIds[0]);
            return entity2 ? _t.append("issues.unclosed_multipolygon_part.message", {
              feature: utilDisplayLabel(
                entity2,
                context.graph(),
                true
                /* verbose */
              )
            }) : "";
          },
          reference: showReference,
          loc: sequence.nodes[0].loc,
          entityIds: [entity.id],
          hash: sequence.map(function(way) {
            return way.id;
          }).join()
        });
        issues.push(issue);
      }
      return issues;
      function showReference(selection2) {
        selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.unclosed_multipolygon_part.reference"));
      }
    }
    var validation = function checkMismatchedGeometry(entity, graph) {
      var vertexPoint = vertexPointIssue(entity, graph);
      if (vertexPoint)
        return [vertexPoint];
      var lineAsArea = lineTaggedAsAreaIssue(entity);
      if (lineAsArea)
        return [lineAsArea];
      var mismatch = otherMismatchIssue(entity, graph);
      if (mismatch)
        return [mismatch];
      return unclosedMultipolygonPartIssues(entity, graph);
    };
    validation.type = type2;
    return validation;
  }

  // modules/validations/missing_role.js
  function validationMissingRole() {
    var type2 = "missing_role";
    var validation = function checkMissingRole(entity, graph) {
      var issues = [];
      if (entity.type === "way") {
        graph.parentRelations(entity).forEach(function(relation) {
          if (!relation.isMultipolygon())
            return;
          var member = relation.memberById(entity.id);
          if (member && isMissingRole(member)) {
            issues.push(makeIssue(entity, relation, member));
          }
        });
      } else if (entity.type === "relation" && entity.isMultipolygon()) {
        entity.indexedMembers().forEach(function(member) {
          var way = graph.hasEntity(member.id);
          if (way && isMissingRole(member)) {
            issues.push(makeIssue(way, entity, member));
          }
        });
      }
      return issues;
    };
    function isMissingRole(member) {
      return !member.role || !member.role.trim().length;
    }
    function makeIssue(way, relation, member) {
      return new validationIssue({
        type: type2,
        severity: "warning",
        message: function(context) {
          var member2 = context.hasEntity(this.entityIds[1]), relation2 = context.hasEntity(this.entityIds[0]);
          return member2 && relation2 ? _t.append("issues.missing_role.message", {
            member: utilDisplayLabel(member2, context.graph()),
            relation: utilDisplayLabel(relation2, context.graph())
          }) : "";
        },
        reference: showReference,
        entityIds: [relation.id, way.id],
        data: {
          member
        },
        hash: member.index.toString(),
        dynamicFixes: function() {
          return [
            makeAddRoleFix("inner"),
            makeAddRoleFix("outer"),
            new validationIssueFix({
              icon: "iD-operation-delete",
              title: _t.append("issues.fix.remove_from_relation.title"),
              onClick: function(context) {
                context.perform(
                  actionDeleteMember(this.issue.entityIds[0], this.issue.data.member.index),
                  _t("operations.delete_member.annotation", {
                    n: 1
                  })
                );
              }
            })
          ];
        }
      });
      function showReference(selection2) {
        selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.missing_role.multipolygon.reference"));
      }
    }
    function makeAddRoleFix(role) {
      return new validationIssueFix({
        title: _t.append("issues.fix.set_as_" + role + ".title"),
        onClick: function(context) {
          var oldMember = this.issue.data.member;
          var member = { id: this.issue.entityIds[1], type: oldMember.type, role };
          context.perform(
            actionChangeMember(this.issue.entityIds[0], member, oldMember.index),
            _t("operations.change_role.annotation", {
              n: 1
            })
          );
        }
      });
    }
    validation.type = type2;
    return validation;
  }

  // modules/validations/missing_tag.js
  function validationMissingTag(context) {
    var type2 = "missing_tag";
    function hasDescriptiveTags(entity) {
      var onlyAttributeKeys = ["description", "name", "note", "start_date"];
      var entityDescriptiveKeys = Object.keys(entity.tags).filter(function(k2) {
        if (k2 === "area" || !osmIsInterestingTag(k2))
          return false;
        return !onlyAttributeKeys.some(function(attributeKey) {
          return k2 === attributeKey || k2.indexOf(attributeKey + ":") === 0;
        });
      });
      if (entity.type === "relation" && entityDescriptiveKeys.length === 1 && entity.tags.type === "multipolygon") {
        return false;
      }
      return entityDescriptiveKeys.length > 0;
    }
    function isUnknownRoad(entity) {
      return entity.type === "way" && entity.tags.highway === "road";
    }
    function isUntypedRelation(entity) {
      return entity.type === "relation" && !entity.tags.type;
    }
    var validation = function checkMissingTag(entity, graph) {
      var subtype;
      var osm = context.connection();
      var isUnloadedNode = entity.type === "node" && osm && !osm.isDataLoaded(entity.loc);
      if (!isUnloadedNode && // allow untagged nodes that are part of ways
      entity.geometry(graph) !== "vertex" && // allow untagged entities that are part of relations
      !entity.hasParentRelations(graph)) {
        if (Object.keys(entity.tags).length === 0) {
          subtype = "any";
        } else if (!hasDescriptiveTags(entity)) {
          subtype = "descriptive";
        } else if (isUntypedRelation(entity)) {
          subtype = "relation_type";
        }
      }
      if (!subtype && isUnknownRoad(entity)) {
        subtype = "highway_classification";
      }
      if (!subtype)
        return [];
      var messageID = subtype === "highway_classification" ? "unknown_road" : "missing_tag." + subtype;
      var referenceID = subtype === "highway_classification" ? "unknown_road" : "missing_tag";
      var canDelete = entity.version === void 0 || entity.v !== void 0;
      var severity = canDelete && subtype !== "highway_classification" ? "error" : "warning";
      return [new validationIssue({
        type: type2,
        subtype,
        severity,
        message: function(context2) {
          var entity2 = context2.hasEntity(this.entityIds[0]);
          return entity2 ? _t.append("issues." + messageID + ".message", {
            feature: utilDisplayLabel(entity2, context2.graph())
          }) : "";
        },
        reference: showReference,
        entityIds: [entity.id],
        dynamicFixes: function(context2) {
          var fixes = [];
          var selectFixType = subtype === "highway_classification" ? "select_road_type" : "select_preset";
          fixes.push(new validationIssueFix({
            icon: "iD-icon-search",
            title: _t.append("issues.fix." + selectFixType + ".title"),
            onClick: function(context3) {
              context3.ui().sidebar.showPresetList();
            }
          }));
          var deleteOnClick;
          var id2 = this.entityIds[0];
          var operation2 = operationDelete(context2, [id2]);
          var disabledReasonID = operation2.disabled();
          if (!disabledReasonID) {
            deleteOnClick = function(context3) {
              var id3 = this.issue.entityIds[0];
              var operation3 = operationDelete(context3, [id3]);
              if (!operation3.disabled()) {
                operation3();
              }
            };
          }
          fixes.push(
            new validationIssueFix({
              icon: "iD-operation-delete",
              title: _t.append("issues.fix.delete_feature.title"),
              disabledReason: disabledReasonID ? _t("operations.delete." + disabledReasonID + ".single") : void 0,
              onClick: deleteOnClick
            })
          );
          return fixes;
        }
      })];
      function showReference(selection2) {
        selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues." + referenceID + ".reference"));
      }
    };
    validation.type = type2;
    return validation;
  }

  // modules/validations/mutually_exclusive_tags.js
  function validationMutuallyExclusiveTags() {
    const type2 = "mutually_exclusive_tags";
    const tagKeyPairs = osmMutuallyExclusiveTagPairs;
    const validation = function checkMutuallyExclusiveTags(entity) {
      let pairsFounds = tagKeyPairs.filter((pair3) => {
        return pair3[0] in entity.tags && pair3[1] in entity.tags;
      }).filter((pair3) => {
        return !(pair3[0].match(/^(addr:)?no[a-z]/) && entity.tags[pair3[0]] === "no" || pair3[1].match(/^(addr:)?no[a-z]/) && entity.tags[pair3[1]] === "no");
      });
      Object.keys(entity.tags).forEach((key) => {
        let negative_key = "not:" + key;
        if (negative_key in entity.tags && entity.tags[negative_key].split(";").includes(entity.tags[key])) {
          pairsFounds.push([negative_key, key, "same_value"]);
        }
        if (key.match(/^name:[a-z]+/)) {
          negative_key = "not:name";
          if (negative_key in entity.tags && entity.tags[negative_key].split(";").includes(entity.tags[key])) {
            pairsFounds.push([negative_key, key, "same_value"]);
          }
        }
      });
      let issues = pairsFounds.map((pair3) => {
        const subtype = pair3[2] || "default";
        return new validationIssue({
          type: type2,
          subtype,
          severity: "warning",
          message: function(context) {
            let entity2 = context.hasEntity(this.entityIds[0]);
            return entity2 ? _t.append("issues.".concat(type2, ".").concat(subtype, ".message"), {
              feature: utilDisplayLabel(entity2, context.graph()),
              tag1: pair3[0],
              tag2: pair3[1]
            }) : "";
          },
          reference: (selection2) => showReference(selection2, pair3, subtype),
          entityIds: [entity.id],
          dynamicFixes: () => pair3.slice(0, 2).map((tagToRemove) => createIssueFix(tagToRemove))
        });
      });
      function createIssueFix(tagToRemove) {
        return new validationIssueFix({
          icon: "iD-operation-delete",
          title: _t.append("issues.fix.remove_named_tag.title", { tag: tagToRemove }),
          onClick: function(context) {
            const entityId = this.issue.entityIds[0];
            const entity2 = context.entity(entityId);
            let tags = Object.assign({}, entity2.tags);
            delete tags[tagToRemove];
            context.perform(
              actionChangeTags(entityId, tags),
              _t("issues.fix.remove_named_tag.annotation", { tag: tagToRemove })
            );
          }
        });
      }
      function showReference(selection2, pair3, subtype) {
        selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.".concat(type2, ".").concat(subtype, ".reference"), { tag1: pair3[0], tag2: pair3[1] }));
      }
      return issues;
    };
    validation.type = type2;
    return validation;
  }

  // modules/validations/outdated_tags.js
  function validationOutdatedTags() {
    const type2 = "outdated_tags";
    let _waitingForDeprecated = true;
    let _dataDeprecated;
    _mainFileFetcher.get("deprecated").then((d2) => _dataDeprecated = d2).catch(() => {
    }).finally(() => _waitingForDeprecated = false);
    function oldTagIssues(entity, graph) {
      if (!entity.hasInterestingTags())
        return [];
      let preset = _mainPresetIndex.match(entity, graph);
      if (!preset)
        return [];
      const oldTags = Object.assign({}, entity.tags);
      let subtype = "deprecated_tags";
      if (preset.replacement) {
        const newPreset = _mainPresetIndex.item(preset.replacement);
        graph = actionChangePreset(
          entity.id,
          preset,
          newPreset,
          true
          /* skip field defaults */
        )(graph);
        entity = graph.entity(entity.id);
        preset = newPreset;
      }
      const upgradeReasons = [];
      if (_dataDeprecated) {
        const deprecatedTags = entity.deprecatedTags(_dataDeprecated);
        if (entity.type === "way" && entity.isClosed() && entity.tags.traffic_calming === "island" && !entity.tags.highway) {
          deprecatedTags.push({
            old: { traffic_calming: "island" },
            replace: { "area:highway": "traffic_island" }
          });
        }
        if (deprecatedTags.length) {
          deprecatedTags.forEach((tag2) => {
            graph = actionUpgradeTags(entity.id, tag2.old, tag2.replace)(graph);
            upgradeReasons.push({
              source: "id-tagging-schema--deprecated",
              data: tag2
            });
          });
          entity = graph.entity(entity.id);
        }
      }
      let newTags = Object.assign({}, entity.tags);
      if (preset.tags !== preset.addTags) {
        Object.keys(preset.addTags).forEach((k2) => {
          if (!newTags[k2]) {
            if (preset.addTags[k2] === "*") {
              newTags[k2] = "yes";
            } else if (preset.addTags[k2]) {
              newTags[k2] = preset.addTags[k2];
            }
            upgradeReasons.push({
              source: "id-tagging-schema--preset-addTags",
              data: preset
            });
          }
        });
      }
      const nsi = services.nsi;
      let waitingForNsi = false;
      let nsiResult;
      if (nsi) {
        waitingForNsi = nsi.status() === "loading";
        if (!waitingForNsi) {
          const loc = entity.extent(graph).center();
          nsiResult = nsi.upgradeTags(newTags, loc);
          if (nsiResult) {
            newTags = nsiResult.newTags;
            subtype = "noncanonical_brand";
            upgradeReasons.push({
              source: "name-suggestion-index",
              data: nsiResult
            });
          }
        }
      }
      let issues = [];
      issues.provisional = _waitingForDeprecated || waitingForNsi;
      const tagDiff = utilTagDiff(oldTags, newTags);
      if (!tagDiff.length)
        return issues;
      const isOnlyAddingTags = tagDiff.every((d2) => d2.type === "+");
      let prefix = "";
      if (nsiResult) {
        prefix = "noncanonical_brand.";
      } else if (subtype === "deprecated_tags" && isOnlyAddingTags) {
        subtype = "incomplete_tags";
        prefix = "incomplete.";
      }
      let autoArgs = subtype !== "noncanonical_brand" ? [doUpgrade, _t("issues.fix.upgrade_tags.annotation")] : null;
      issues.push(new validationIssue({
        type: type2,
        subtype,
        severity: "warning",
        message: showMessage,
        reference: showReference,
        entityIds: [entity.id],
        hash: utilHashcode(JSON.stringify(tagDiff)),
        dynamicFixes: () => {
          let fixes = [
            new validationIssueFix({
              autoArgs,
              title: _t.append("issues.fix.upgrade_tags.title"),
              onClick: (context) => {
                context.perform(doUpgrade, _t("issues.fix.upgrade_tags.annotation"));
              }
            })
          ];
          const item = nsiResult && nsiResult.matched;
          if (item) {
            fixes.push(
              new validationIssueFix({
                title: _t.append("issues.fix.tag_as_not.title", { name: item.displayName }),
                onClick: (context) => {
                  context.perform(addNotTag, _t("issues.fix.tag_as_not.annotation"));
                }
              })
            );
          }
          return fixes;
        }
      }));
      return issues;
      function doUpgrade(graph2) {
        const currEntity = graph2.hasEntity(entity.id);
        if (!currEntity)
          return graph2;
        let newTags2 = Object.assign({}, currEntity.tags);
        tagDiff.forEach((diff) => {
          if (diff.type === "-") {
            delete newTags2[diff.key];
          } else if (diff.type === "+") {
            newTags2[diff.key] = diff.newVal;
          }
        });
        return actionChangeTags(currEntity.id, newTags2)(graph2);
      }
      function addNotTag(graph2) {
        const currEntity = graph2.hasEntity(entity.id);
        if (!currEntity)
          return graph2;
        const item = nsiResult && nsiResult.matched;
        if (!item)
          return graph2;
        let newTags2 = Object.assign({}, currEntity.tags);
        const wd = item.mainTag;
        const notwd = "not:".concat(wd);
        const qid = item.tags[wd];
        newTags2[notwd] = qid;
        if (newTags2[wd] === qid) {
          const wp = item.mainTag.replace("wikidata", "wikipedia");
          delete newTags2[wd];
          delete newTags2[wp];
        }
        return actionChangeTags(currEntity.id, newTags2)(graph2);
      }
      function showMessage(context) {
        const currEntity = context.hasEntity(entity.id);
        if (!currEntity)
          return "";
        let messageID = "issues.outdated_tags.".concat(prefix, "message");
        if (subtype === "noncanonical_brand" && isOnlyAddingTags) {
          messageID += "_incomplete";
        }
        return _t.append(messageID, {
          feature: utilDisplayLabel(
            currEntity,
            context.graph(),
            true
            /* verbose */
          )
        });
      }
      function showReference(selection2) {
        let enter = selection2.selectAll(".issue-reference").data([0]).enter();
        enter.append("div").attr("class", "issue-reference").call(_t.append("issues.outdated_tags.".concat(prefix, "reference")));
        enter.append("strong").call(_t.append("issues.suggested"));
        enter.append("table").attr("class", "tagDiff-table").selectAll(".tagDiff-row").data(tagDiff).enter().append("tr").attr("class", "tagDiff-row").append("td").attr("class", (d2) => {
          let klass = d2.type === "+" ? "add" : "remove";
          return "tagDiff-cell tagDiff-cell-".concat(klass);
        }).html((d2) => d2.display);
      }
    }
    let validation = oldTagIssues;
    validation.type = type2;
    return validation;
  }

  // modules/validations/private_data.js
  function validationPrivateData() {
    var type2 = "private_data";
    var privateBuildingValues = {
      detached: true,
      farm: true,
      house: true,
      houseboat: true,
      residential: true,
      semidetached_house: true,
      static_caravan: true
    };
    var publicKeys = {
      amenity: true,
      craft: true,
      historic: true,
      leisure: true,
      office: true,
      shop: true,
      tourism: true
    };
    var personalTags = {
      "contact:email": true,
      "contact:fax": true,
      "contact:phone": true,
      email: true,
      fax: true,
      phone: true
    };
    var validation = function checkPrivateData(entity) {
      var tags = entity.tags;
      if (!tags.building || !privateBuildingValues[tags.building])
        return [];
      var keepTags = {};
      for (var k2 in tags) {
        if (publicKeys[k2])
          return [];
        if (!personalTags[k2]) {
          keepTags[k2] = tags[k2];
        }
      }
      var tagDiff = utilTagDiff(tags, keepTags);
      if (!tagDiff.length)
        return [];
      var fixID = tagDiff.length === 1 ? "remove_tag" : "remove_tags";
      return [new validationIssue({
        type: type2,
        severity: "warning",
        message: showMessage,
        reference: showReference,
        entityIds: [entity.id],
        dynamicFixes: function() {
          return [
            new validationIssueFix({
              icon: "iD-operation-delete",
              title: _t.append("issues.fix." + fixID + ".title"),
              onClick: function(context) {
                context.perform(doUpgrade, _t("issues.fix.remove_tag.annotation"));
              }
            })
          ];
        }
      })];
      function doUpgrade(graph) {
        var currEntity = graph.hasEntity(entity.id);
        if (!currEntity)
          return graph;
        var newTags = Object.assign({}, currEntity.tags);
        tagDiff.forEach(function(diff) {
          if (diff.type === "-") {
            delete newTags[diff.key];
          } else if (diff.type === "+") {
            newTags[diff.key] = diff.newVal;
          }
        });
        return actionChangeTags(currEntity.id, newTags)(graph);
      }
      function showMessage(context) {
        var currEntity = context.hasEntity(this.entityIds[0]);
        if (!currEntity)
          return "";
        return _t.append(
          "issues.private_data.contact.message",
          { feature: utilDisplayLabel(currEntity, context.graph()) }
        );
      }
      function showReference(selection2) {
        var enter = selection2.selectAll(".issue-reference").data([0]).enter();
        enter.append("div").attr("class", "issue-reference").call(_t.append("issues.private_data.reference"));
        enter.append("strong").call(_t.append("issues.suggested"));
        enter.append("table").attr("class", "tagDiff-table").selectAll(".tagDiff-row").data(tagDiff).enter().append("tr").attr("class", "tagDiff-row").append("td").attr("class", function(d2) {
          var klass = d2.type === "+" ? "add" : "remove";
          return "tagDiff-cell tagDiff-cell-" + klass;
        }).html(function(d2) {
          return d2.display;
        });
      }
    };
    validation.type = type2;
    return validation;
  }

  // modules/validations/suspicious_name.js
  function validationSuspiciousName() {
    const type2 = "suspicious_name";
    const keysToTestForGenericValues = [
      "aerialway",
      "aeroway",
      "amenity",
      "building",
      "craft",
      "highway",
      "leisure",
      "railway",
      "man_made",
      "office",
      "shop",
      "tourism",
      "waterway"
    ];
    let _waitingForNsi = false;
    function isGenericMatchInNsi(tags) {
      const nsi = services.nsi;
      if (nsi) {
        _waitingForNsi = nsi.status() === "loading";
        if (!_waitingForNsi) {
          return nsi.isGenericName(tags);
        }
      }
      return false;
    }
    function nameMatchesRawTag(lowercaseName, tags) {
      for (let i3 = 0; i3 < keysToTestForGenericValues.length; i3++) {
        let key = keysToTestForGenericValues[i3];
        let val = tags[key];
        if (val) {
          val = val.toLowerCase();
          if (key === lowercaseName || val === lowercaseName || key.replace(/\_/g, " ") === lowercaseName || val.replace(/\_/g, " ") === lowercaseName) {
            return true;
          }
        }
      }
      return false;
    }
    function isGenericName(name, tags) {
      name = name.toLowerCase();
      return nameMatchesRawTag(name, tags) || isGenericMatchInNsi(tags);
    }
    function makeGenericNameIssue(entityId, nameKey, genericName, langCode) {
      return new validationIssue({
        type: type2,
        subtype: "generic_name",
        severity: "warning",
        message: function(context) {
          let entity = context.hasEntity(this.entityIds[0]);
          if (!entity)
            return "";
          let preset = _mainPresetIndex.match(entity, context.graph());
          let langName = langCode && _mainLocalizer.languageName(langCode);
          return _t.append(
            "issues.generic_name.message" + (langName ? "_language" : ""),
            { feature: preset.name(), name: genericName, language: langName }
          );
        },
        reference: showReference,
        entityIds: [entityId],
        hash: "".concat(nameKey, "=").concat(genericName),
        dynamicFixes: function() {
          return [
            new validationIssueFix({
              icon: "iD-operation-delete",
              title: _t.append("issues.fix.remove_the_name.title"),
              onClick: function(context) {
                let entityId2 = this.issue.entityIds[0];
                let entity = context.entity(entityId2);
                let tags = Object.assign({}, entity.tags);
                delete tags[nameKey];
                context.perform(
                  actionChangeTags(entityId2, tags),
                  _t("issues.fix.remove_generic_name.annotation")
                );
              }
            })
          ];
        }
      });
      function showReference(selection2) {
        selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.generic_name.reference"));
      }
    }
    let validation = function checkGenericName(entity) {
      const tags = entity.tags;
      const hasWikidata = !!tags.wikidata || !!tags["brand:wikidata"] || !!tags["operator:wikidata"];
      if (hasWikidata)
        return [];
      let issues = [];
      for (let key in tags) {
        const m2 = key.match(/^name(?:(?::)([a-zA-Z_-]+))?$/);
        if (!m2)
          continue;
        const langCode = m2.length >= 2 ? m2[1] : null;
        const value = tags[key];
        if (isGenericName(value, tags)) {
          issues.provisional = _waitingForNsi;
          issues.push(makeGenericNameIssue(entity.id, key, value, langCode));
        }
      }
      return issues;
    };
    validation.type = type2;
    return validation;
  }

  // modules/validations/unsquare_way.js
  function validationUnsquareWay(context) {
    var type2 = "unsquare_way";
    var DEFAULT_DEG_THRESHOLD = 5;
    var epsilon3 = 0.05;
    var nodeThreshold = 10;
    function isBuilding(entity, graph) {
      if (entity.type !== "way" || entity.geometry(graph) !== "area")
        return false;
      return entity.tags.building && entity.tags.building !== "no";
    }
    var validation = function checkUnsquareWay(entity, graph) {
      if (!isBuilding(entity, graph))
        return [];
      if (entity.tags.nonsquare === "yes")
        return [];
      var isClosed = entity.isClosed();
      if (!isClosed)
        return [];
      var nodes = graph.childNodes(entity).slice();
      if (nodes.length > nodeThreshold + 1)
        return [];
      var osm = services.osm;
      if (!osm || nodes.some(function(node) {
        return !osm.isDataLoaded(node.loc);
      }))
        return [];
      var hasConnectedSquarableWays = nodes.some(function(node) {
        return graph.parentWays(node).some(function(way) {
          if (way.id === entity.id)
            return false;
          if (isBuilding(way, graph))
            return true;
          return graph.parentRelations(way).some(function(parentRelation) {
            return parentRelation.isMultipolygon() && parentRelation.tags.building && parentRelation.tags.building !== "no";
          });
        });
      });
      if (hasConnectedSquarableWays)
        return [];
      var storedDegreeThreshold = corePreferences("validate-square-degrees");
      var degreeThreshold = isFinite(storedDegreeThreshold) ? Number(storedDegreeThreshold) : DEFAULT_DEG_THRESHOLD;
      var points = nodes.map(function(node) {
        return context.projection(node.loc);
      });
      if (!geoOrthoCanOrthogonalize(points, isClosed, epsilon3, degreeThreshold, true))
        return [];
      var autoArgs;
      if (!entity.tags.wikidata) {
        var autoAction = actionOrthogonalize(entity.id, context.projection, void 0, degreeThreshold);
        autoAction.transitionable = false;
        autoArgs = [autoAction, _t("operations.orthogonalize.annotation.feature", { n: 1 })];
      }
      return [new validationIssue({
        type: type2,
        subtype: "building",
        severity: "warning",
        message: function(context2) {
          var entity2 = context2.hasEntity(this.entityIds[0]);
          return entity2 ? _t.append("issues.unsquare_way.message", {
            feature: utilDisplayLabel(entity2, context2.graph())
          }) : "";
        },
        reference: showReference,
        entityIds: [entity.id],
        hash: degreeThreshold,
        dynamicFixes: function() {
          return [
            new validationIssueFix({
              icon: "iD-operation-orthogonalize",
              title: _t.append("issues.fix.square_feature.title"),
              autoArgs,
              onClick: function(context2, completionHandler) {
                var entityId = this.issue.entityIds[0];
                context2.perform(
                  actionOrthogonalize(entityId, context2.projection, void 0, degreeThreshold),
                  _t("operations.orthogonalize.annotation.feature", { n: 1 })
                );
                window.setTimeout(function() {
                  completionHandler();
                }, 175);
              }
            })
            /*
            new validationIssueFix({
                title: t.append('issues.fix.tag_as_unsquare.title'),
                onClick: function(context) {
                    var entityId = this.issue.entityIds[0];
                    var entity = context.entity(entityId);
                    var tags = Object.assign({}, entity.tags);  // shallow copy
                    tags.nonsquare = 'yes';
                    context.perform(
                        actionChangeTags(entityId, tags),
                        t('issues.fix.tag_as_unsquare.annotation')
                    );
                }
            })
            */
          ];
        }
      })];
      function showReference(selection2) {
        selection2.selectAll(".issue-reference").data([0]).enter().append("div").attr("class", "issue-reference").call(_t.append("issues.unsquare_way.buildings.reference"));
      }
    };
    validation.type = type2;
    return validation;
  }

  // modules/core/validator.js
  function coreValidator(context) {
    let dispatch14 = dispatch_default("validated", "focusedIssue");
    let validator = utilRebind({}, dispatch14, "on");
    let _rules = {};
    let _disabledRules = {};
    let _ignoredIssueIDs = /* @__PURE__ */ new Set();
    let _resolvedIssueIDs = /* @__PURE__ */ new Set();
    let _baseCache = validationCache("base");
    let _headCache = validationCache("head");
    let _completeDiff = {};
    let _headIsCurrent = false;
    let _deferredRIC = {};
    let _deferredST = /* @__PURE__ */ new Set();
    let _headPromise;
    const RETRY = 5e3;
    const _errorOverrides = parseHashParam(context.initialHashParams.validationError);
    const _warningOverrides = parseHashParam(context.initialHashParams.validationWarning);
    const _disableOverrides = parseHashParam(context.initialHashParams.validationDisable);
    function parseHashParam(param) {
      let result = [];
      let rules = (param || "").split(",");
      rules.forEach((rule) => {
        rule = rule.trim();
        const parts = rule.split("/", 2);
        const type2 = parts[0];
        const subtype = parts[1] || "*";
        if (!type2 || !subtype)
          return;
        result.push({ type: makeRegExp(type2), subtype: makeRegExp(subtype) });
      });
      return result;
      function makeRegExp(str) {
        const escaped = str.replace(/[-\/\\^$+?.()|[\]{}]/g, "\\$&").replace(/\*/g, ".*");
        return new RegExp("^" + escaped + "$");
      }
    }
    validator.init = () => {
      Object.values(validations_exports).forEach((validation) => {
        if (typeof validation !== "function")
          return;
        const fn = validation(context);
        const key = fn.type;
        _rules[key] = fn;
      });
      let disabledRules = corePreferences("validate-disabledRules");
      if (disabledRules) {
        disabledRules.split(",").forEach((k2) => _disabledRules[k2] = true);
      }
    };
    function reset(resetIgnored) {
      _baseCache.queue = [];
      _headCache.queue = [];
      Object.keys(_deferredRIC).forEach((key) => {
        window.cancelIdleCallback(key);
        _deferredRIC[key]();
      });
      _deferredRIC = {};
      _deferredST.forEach(window.clearTimeout);
      _deferredST.clear();
      if (resetIgnored)
        _ignoredIssueIDs.clear();
      _resolvedIssueIDs.clear();
      _baseCache = validationCache("base");
      _headCache = validationCache("head");
      _completeDiff = {};
      _headIsCurrent = false;
    }
    validator.reset = () => {
      reset(true);
    };
    validator.resetIgnoredIssues = () => {
      _ignoredIssueIDs.clear();
      dispatch14.call("validated");
    };
    validator.revalidateUnsquare = () => {
      revalidateUnsquare(_headCache);
      revalidateUnsquare(_baseCache);
      dispatch14.call("validated");
    };
    function revalidateUnsquare(cache) {
      const checkUnsquareWay = _rules.unsquare_way;
      if (!cache.graph || typeof checkUnsquareWay !== "function")
        return;
      cache.uncacheIssuesOfType("unsquare_way");
      const buildings = context.history().tree().intersects(geoExtent([-180, -90], [180, 90]), cache.graph).filter((entity) => entity.type === "way" && entity.tags.building && entity.tags.building !== "no");
      buildings.forEach((entity) => {
        const detected = checkUnsquareWay(entity, cache.graph);
        if (!detected.length)
          return;
        cache.cacheIssues(detected);
      });
    }
    validator.getIssues = (options2) => {
      const opts = Object.assign({ what: "all", where: "all", includeIgnored: false, includeDisabledRules: false }, options2);
      const view = context.map().extent();
      let seen = /* @__PURE__ */ new Set();
      let results = [];
      if (_headCache.graph && _headCache.graph !== _baseCache.graph) {
        Object.values(_headCache.issuesByIssueID).forEach((issue) => {
          const userModified = (issue.entityIds || []).some((id2) => _completeDiff.hasOwnProperty(id2));
          if (opts.what === "edited" && !userModified)
            return;
          if (!filter2(issue))
            return;
          seen.add(issue.id);
          results.push(issue);
        });
      }
      if (opts.what === "all") {
        Object.values(_baseCache.issuesByIssueID).forEach((issue) => {
          if (!filter2(issue))
            return;
          seen.add(issue.id);
          results.push(issue);
        });
      }
      return results;
      function filter2(issue) {
        if (!issue)
          return false;
        if (seen.has(issue.id))
          return false;
        if (_resolvedIssueIDs.has(issue.id))
          return false;
        if (opts.includeDisabledRules === "only" && !_disabledRules[issue.type])
          return false;
        if (!opts.includeDisabledRules && _disabledRules[issue.type])
          return false;
        if (opts.includeIgnored === "only" && !_ignoredIssueIDs.has(issue.id))
          return false;
        if (!opts.includeIgnored && _ignoredIssueIDs.has(issue.id))
          return false;
        if ((issue.entityIds || []).some((id2) => !context.hasEntity(id2)))
          return false;
        if (opts.where === "visible") {
          const extent = issue.extent(context.graph());
          if (!view.intersects(extent))
            return false;
        }
        return true;
      }
    };
    validator.getResolvedIssues = () => {
      return Array.from(_resolvedIssueIDs).map((issueID) => _baseCache.issuesByIssueID[issueID]).filter(Boolean);
    };
    validator.focusIssue = (issue) => {
      const graph = context.graph();
      let selectID;
      let focusCenter;
      const issueExtent = issue.extent(graph);
      if (issueExtent) {
        focusCenter = issueExtent.center();
      }
      if (issue.entityIds && issue.entityIds.length) {
        selectID = issue.entityIds[0];
        if (selectID && selectID.charAt(0) === "r") {
          const ids = utilEntityAndDeepMemberIDs([selectID], graph);
          let nodeID = ids.find((id2) => id2.charAt(0) === "n" && graph.hasEntity(id2));
          if (!nodeID) {
            const wayID = ids.find((id2) => id2.charAt(0) === "w" && graph.hasEntity(id2));
            if (wayID) {
              nodeID = graph.entity(wayID).first();
            }
          }
          if (nodeID) {
            focusCenter = graph.entity(nodeID).loc;
          }
        }
      }
      if (focusCenter) {
        const setZoom = Math.max(context.map().zoom(), 19);
        context.map().unobscuredCenterZoomEase(focusCenter, setZoom);
      }
      if (selectID) {
        window.setTimeout(() => {
          context.enter(modeSelect(context, [selectID]));
          dispatch14.call("focusedIssue", this, issue);
        }, 250);
      }
    };
    validator.getIssuesBySeverity = (options2) => {
      let groups = utilArrayGroupBy(validator.getIssues(options2), "severity");
      groups.error = groups.error || [];
      groups.warning = groups.warning || [];
      return groups;
    };
    validator.getSharedEntityIssues = (entityIDs, options2) => {
      const orderedIssueTypes = [
        // Show some issue types in a particular order:
        "missing_tag",
        "missing_role",
        // - missing data first
        "outdated_tags",
        "mismatched_geometry",
        // - identity issues
        "crossing_ways",
        "almost_junction",
        // - geometry issues where fixing them might solve connectivity issues
        "disconnected_way",
        "impossible_oneway"
        // - finally connectivity issues
      ];
      const allIssues = validator.getIssues(options2);
      const forEntityIDs = new Set(entityIDs);
      return allIssues.filter((issue) => (issue.entityIds || []).some((entityID) => forEntityIDs.has(entityID))).sort((issue1, issue2) => {
        if (issue1.type === issue2.type) {
          return issue1.id < issue2.id ? -1 : 1;
        }
        const index1 = orderedIssueTypes.indexOf(issue1.type);
        const index2 = orderedIssueTypes.indexOf(issue2.type);
        if (index1 !== -1 && index2 !== -1) {
          return index1 - index2;
        } else if (index1 === -1 && index2 === -1) {
          return issue1.type < issue2.type ? -1 : 1;
        } else {
          return index1 !== -1 ? -1 : 1;
        }
      });
    };
    validator.getEntityIssues = (entityID, options2) => {
      return validator.getSharedEntityIssues([entityID], options2);
    };
    validator.getRuleKeys = () => {
      return Object.keys(_rules);
    };
    validator.isRuleEnabled = (key) => {
      return !_disabledRules[key];
    };
    validator.toggleRule = (key) => {
      if (_disabledRules[key]) {
        delete _disabledRules[key];
      } else {
        _disabledRules[key] = true;
      }
      corePreferences("validate-disabledRules", Object.keys(_disabledRules).join(","));
      validator.validate();
    };
    validator.disableRules = (keys2) => {
      _disabledRules = {};
      keys2.forEach((k2) => _disabledRules[k2] = true);
      corePreferences("validate-disabledRules", Object.keys(_disabledRules).join(","));
      validator.validate();
    };
    validator.ignoreIssue = (issueID) => {
      _ignoredIssueIDs.add(issueID);
    };
    validator.validate = () => {
      const baseGraph = context.history().base();
      if (!_headCache.graph)
        _headCache.graph = baseGraph;
      if (!_baseCache.graph)
        _baseCache.graph = baseGraph;
      const prevGraph = _headCache.graph;
      const currGraph = context.graph();
      if (currGraph === prevGraph) {
        _headIsCurrent = true;
        dispatch14.call("validated");
        return Promise.resolve();
      }
      if (_headPromise) {
        _headIsCurrent = false;
        return _headPromise;
      }
      _headCache.graph = currGraph;
      _completeDiff = context.history().difference().complete();
      const incrementalDiff = coreDifference(prevGraph, currGraph);
      let entityIDs = Object.keys(incrementalDiff.complete());
      entityIDs = _headCache.withAllRelatedEntities(entityIDs);
      if (!entityIDs.size) {
        dispatch14.call("validated");
        return Promise.resolve();
      }
      _headPromise = validateEntitiesAsync(entityIDs, _headCache).then(() => updateResolvedIssues(entityIDs)).then(() => dispatch14.call("validated")).catch(() => {
      }).then(() => {
        _headPromise = null;
        if (!_headIsCurrent) {
          validator.validate();
        }
      });
      return _headPromise;
    };
    context.history().on("restore.validator", validator.validate).on("undone.validator", validator.validate).on("redone.validator", validator.validate).on("reset.validator", () => {
      reset(false);
      validator.validate();
    });
    context.on("exit.validator", validator.validate);
    context.history().on("merge.validator", (entities) => {
      if (!entities)
        return;
      const baseGraph = context.history().base();
      if (!_headCache.graph)
        _headCache.graph = baseGraph;
      if (!_baseCache.graph)
        _baseCache.graph = baseGraph;
      let entityIDs = entities.map((entity) => entity.id);
      entityIDs = _baseCache.withAllRelatedEntities(entityIDs);
      validateEntitiesAsync(entityIDs, _baseCache);
    });
    function validateEntity(entity, graph) {
      let result = { issues: [], provisional: false };
      Object.keys(_rules).forEach(runValidation);
      return result;
      function runValidation(key) {
        const fn = _rules[key];
        if (typeof fn !== "function") {
          console.error("no such validation rule = " + key);
          return;
        }
        let detected = fn(entity, graph);
        if (detected.provisional) {
          result.provisional = true;
        }
        detected = detected.filter(applySeverityOverrides);
        result.issues = result.issues.concat(detected);
        function applySeverityOverrides(issue) {
          const type2 = issue.type;
          const subtype = issue.subtype || "";
          let i3;
          for (i3 = 0; i3 < _errorOverrides.length; i3++) {
            if (_errorOverrides[i3].type.test(type2) && _errorOverrides[i3].subtype.test(subtype)) {
              issue.severity = "error";
              return true;
            }
          }
          for (i3 = 0; i3 < _warningOverrides.length; i3++) {
            if (_warningOverrides[i3].type.test(type2) && _warningOverrides[i3].subtype.test(subtype)) {
              issue.severity = "warning";
              return true;
            }
          }
          for (i3 = 0; i3 < _disableOverrides.length; i3++) {
            if (_disableOverrides[i3].type.test(type2) && _disableOverrides[i3].subtype.test(subtype)) {
              return false;
            }
          }
          return true;
        }
      }
    }
    function updateResolvedIssues(entityIDs) {
      entityIDs.forEach((entityID) => {
        const baseIssues = _baseCache.issuesByEntityID[entityID];
        if (!baseIssues)
          return;
        baseIssues.forEach((issueID) => {
          const issue = _baseCache.issuesByIssueID[issueID];
          const userModified = (issue.entityIds || []).some((id2) => _completeDiff.hasOwnProperty(id2));
          if (userModified && !_headCache.issuesByIssueID[issueID]) {
            _resolvedIssueIDs.add(issueID);
          } else {
            _resolvedIssueIDs.delete(issueID);
          }
        });
      });
    }
    function validateEntitiesAsync(entityIDs, cache) {
      const jobs = Array.from(entityIDs).map((entityID) => {
        if (cache.queuedEntityIDs.has(entityID))
          return null;
        cache.queuedEntityIDs.add(entityID);
        cache.uncacheEntityID(entityID);
        return () => {
          cache.queuedEntityIDs.delete(entityID);
          const graph = cache.graph;
          if (!graph)
            return;
          const entity = graph.hasEntity(entityID);
          if (!entity)
            return;
          const result = validateEntity(entity, graph);
          if (result.provisional) {
            cache.provisionalEntityIDs.add(entityID);
          }
          cache.cacheIssues(result.issues);
        };
      }).filter(Boolean);
      cache.queue = cache.queue.concat(utilArrayChunk(jobs, 100));
      if (cache.queuePromise)
        return cache.queuePromise;
      cache.queuePromise = processQueue(cache).then(() => revalidateProvisionalEntities(cache)).catch(() => {
      }).finally(() => cache.queuePromise = null);
      return cache.queuePromise;
    }
    function revalidateProvisionalEntities(cache) {
      if (!cache.provisionalEntityIDs.size)
        return;
      const handle = window.setTimeout(() => {
        _deferredST.delete(handle);
        if (!cache.provisionalEntityIDs.size)
          return;
        validateEntitiesAsync(Array.from(cache.provisionalEntityIDs), cache);
      }, RETRY);
      _deferredST.add(handle);
    }
    function processQueue(cache) {
      if (!cache.queue.length)
        return Promise.resolve();
      const chunk = cache.queue.pop();
      return new Promise((resolvePromise, rejectPromise) => {
        const handle = window.requestIdleCallback(() => {
          delete _deferredRIC[handle];
          chunk.forEach((job) => job());
          resolvePromise();
        });
        _deferredRIC[handle] = rejectPromise;
      }).then(() => {
        if (cache.queue.length % 25 === 0)
          dispatch14.call("validated");
      }).then(() => processQueue(cache));
    }
    return validator;
  }
  function validationCache(which) {
    let cache = {
      which,
      graph: null,
      queue: [],
      queuePromise: null,
      queuedEntityIDs: /* @__PURE__ */ new Set(),
      provisionalEntityIDs: /* @__PURE__ */ new Set(),
      issuesByIssueID: {},
      // issue.id -> issue
      issuesByEntityID: {}
      // entity.id -> Set(issue.id)
    };
    cache.cacheIssue = (issue) => {
      (issue.entityIds || []).forEach((entityID) => {
        if (!cache.issuesByEntityID[entityID]) {
          cache.issuesByEntityID[entityID] = /* @__PURE__ */ new Set();
        }
        cache.issuesByEntityID[entityID].add(issue.id);
      });
      cache.issuesByIssueID[issue.id] = issue;
    };
    cache.uncacheIssue = (issue) => {
      (issue.entityIds || []).forEach((entityID) => {
        if (cache.issuesByEntityID[entityID]) {
          cache.issuesByEntityID[entityID].delete(issue.id);
        }
      });
      delete cache.issuesByIssueID[issue.id];
    };
    cache.cacheIssues = (issues) => {
      issues.forEach(cache.cacheIssue);
    };
    cache.uncacheIssues = (issues) => {
      issues.forEach(cache.uncacheIssue);
    };
    cache.uncacheIssuesOfType = (type2) => {
      const issuesOfType = Object.values(cache.issuesByIssueID).filter((issue) => issue.type === type2);
      cache.uncacheIssues(issuesOfType);
    };
    cache.uncacheEntityID = (entityID) => {
      const entityIssueIDs = cache.issuesByEntityID[entityID];
      if (entityIssueIDs) {
        entityIssueIDs.forEach((issueID) => {
          const issue = cache.issuesByIssueID[issueID];
          if (issue) {
            cache.uncacheIssue(issue);
          } else {
            delete cache.issuesByIssueID[issueID];
          }
        });
      }
      delete cache.issuesByEntityID[entityID];
      cache.provisionalEntityIDs.delete(entityID);
    };
    cache.withAllRelatedEntities = (entityIDs) => {
      let result = /* @__PURE__ */ new Set();
      (entityIDs || []).forEach((entityID) => {
        result.add(entityID);
        const entityIssueIDs = cache.issuesByEntityID[entityID];
        if (entityIssueIDs) {
          entityIssueIDs.forEach((issueID) => {
            const issue = cache.issuesByIssueID[issueID];
            if (issue) {
              (issue.entityIds || []).forEach((relatedID) => result.add(relatedID));
            } else {
              delete cache.issuesByIssueID[issueID];
            }
          });
        }
      });
      return result;
    };
    return cache;
  }

  // modules/core/uploader.js
  function coreUploader(context) {
    var dispatch14 = dispatch_default(
      // Start and end events are dispatched exactly once each per legitimate outside call to `save`
      "saveStarted",
      // dispatched as soon as a call to `save` has been deemed legitimate
      "saveEnded",
      // dispatched after the result event has been dispatched
      "willAttemptUpload",
      // dispatched before the actual upload call occurs, if it will
      "progressChanged",
      // Each save results in one of these outcomes:
      "resultNoChanges",
      // upload wasn't attempted since there were no edits
      "resultErrors",
      // upload failed due to errors
      "resultConflicts",
      // upload failed due to data conflicts
      "resultSuccess"
      // upload completed without errors
    );
    var _isSaving = false;
    var _conflicts = [];
    var _errors = [];
    var _origChanges;
    var _discardTags = {};
    _mainFileFetcher.get("discarded").then(function(d2) {
      _discardTags = d2;
    }).catch(function() {
    });
    var uploader = utilRebind({}, dispatch14, "on");
    uploader.isSaving = function() {
      return _isSaving;
    };
    uploader.save = function(changeset, tryAgain, checkConflicts) {
      if (_isSaving && !tryAgain) {
        return;
      }
      var osm = context.connection();
      if (!osm)
        return;
      if (!osm.authenticated()) {
        osm.authenticate(function(err) {
          if (!err) {
            uploader.save(changeset, tryAgain, checkConflicts);
          }
        });
        return;
      }
      if (!_isSaving) {
        _isSaving = true;
        dispatch14.call("saveStarted", this);
      }
      var history = context.history();
      _conflicts = [];
      _errors = [];
      _origChanges = history.changes(actionDiscardTags(history.difference(), _discardTags));
      if (!tryAgain) {
        history.perform(actionNoop());
      }
      if (!checkConflicts) {
        upload(changeset);
      } else {
        performFullConflictCheck(changeset);
      }
    };
    function performFullConflictCheck(changeset) {
      var osm = context.connection();
      if (!osm)
        return;
      var history = context.history();
      var localGraph = context.graph();
      var remoteGraph = coreGraph(history.base(), true);
      var summary = history.difference().summary();
      var _toCheck = [];
      for (var i3 = 0; i3 < summary.length; i3++) {
        var item = summary[i3];
        if (item.changeType === "modified") {
          _toCheck.push(item.entity.id);
        }
      }
      var _toLoad = withChildNodes(_toCheck, localGraph);
      var _loaded = {};
      var _toLoadCount = 0;
      var _toLoadTotal = _toLoad.length;
      if (_toCheck.length) {
        dispatch14.call("progressChanged", this, _toLoadCount, _toLoadTotal);
        _toLoad.forEach(function(id2) {
          _loaded[id2] = false;
        });
        osm.loadMultiple(_toLoad, loaded);
      } else {
        upload(changeset);
      }
      return;
      function withChildNodes(ids, graph) {
        var s2 = new Set(ids);
        ids.forEach(function(id2) {
          var entity = graph.entity(id2);
          if (entity.type !== "way")
            return;
          graph.childNodes(entity).forEach(function(child) {
            if (child.version !== void 0) {
              s2.add(child.id);
            }
          });
        });
        return Array.from(s2);
      }
      function loaded(err, result) {
        if (_errors.length)
          return;
        if (err) {
          _errors.push({
            msg: err.message || err.responseText,
            details: [_t("save.status_code", { code: err.status })]
          });
          didResultInErrors();
        } else {
          var loadMore = [];
          result.data.forEach(function(entity) {
            remoteGraph.replace(entity);
            _loaded[entity.id] = true;
            _toLoad = _toLoad.filter(function(val) {
              return val !== entity.id;
            });
            if (!entity.visible)
              return;
            var i4, id2;
            if (entity.type === "way") {
              for (i4 = 0; i4 < entity.nodes.length; i4++) {
                id2 = entity.nodes[i4];
                if (_loaded[id2] === void 0) {
                  _loaded[id2] = false;
                  loadMore.push(id2);
                }
              }
            } else if (entity.type === "relation" && entity.isMultipolygon()) {
              for (i4 = 0; i4 < entity.members.length; i4++) {
                id2 = entity.members[i4].id;
                if (_loaded[id2] === void 0) {
                  _loaded[id2] = false;
                  loadMore.push(id2);
                }
              }
            }
          });
          _toLoadCount += result.data.length;
          _toLoadTotal += loadMore.length;
          dispatch14.call("progressChanged", this, _toLoadCount, _toLoadTotal);
          if (loadMore.length) {
            _toLoad.push.apply(_toLoad, loadMore);
            osm.loadMultiple(loadMore, loaded);
          }
          if (!_toLoad.length) {
            detectConflicts();
            upload(changeset);
          }
        }
      }
      function detectConflicts() {
        function choice(id2, text, action) {
          return {
            id: id2,
            text,
            action: function() {
              history.replace(action);
            }
          };
        }
        function formatUser(d2) {
          return '<a href="' + osm.userURL(d2) + '" target="_blank">' + escape_default(d2) + "</a>";
        }
        function entityName(entity) {
          return utilDisplayName(entity) || utilDisplayType(entity.id) + " " + entity.id;
        }
        function sameVersions(local, remote) {
          if (local.version !== remote.version)
            return false;
          if (local.type === "way") {
            var children2 = utilArrayUnion(local.nodes, remote.nodes);
            for (var i4 = 0; i4 < children2.length; i4++) {
              var a2 = localGraph.hasEntity(children2[i4]);
              var b2 = remoteGraph.hasEntity(children2[i4]);
              if (a2 && b2 && a2.version !== b2.version)
                return false;
            }
          }
          return true;
        }
        _toCheck.forEach(function(id2) {
          var local = localGraph.entity(id2);
          var remote = remoteGraph.entity(id2);
          if (sameVersions(local, remote))
            return;
          var merge2 = actionMergeRemoteChanges(id2, localGraph, remoteGraph, _discardTags, formatUser);
          history.replace(merge2);
          var mergeConflicts = merge2.conflicts();
          if (!mergeConflicts.length)
            return;
          var forceLocal = actionMergeRemoteChanges(id2, localGraph, remoteGraph, _discardTags).withOption("force_local");
          var forceRemote = actionMergeRemoteChanges(id2, localGraph, remoteGraph, _discardTags).withOption("force_remote");
          var keepMine = _t("save.conflict." + (remote.visible ? "keep_local" : "restore"));
          var keepTheirs = _t("save.conflict." + (remote.visible ? "keep_remote" : "delete"));
          _conflicts.push({
            id: id2,
            name: entityName(local),
            details: mergeConflicts,
            chosen: 1,
            choices: [
              choice(id2, keepMine, forceLocal),
              choice(id2, keepTheirs, forceRemote)
            ]
          });
        });
      }
    }
    function upload(changeset) {
      var osm = context.connection();
      if (!osm) {
        _errors.push({ msg: "No OSM Service" });
      }
      if (_conflicts.length) {
        didResultInConflicts(changeset);
      } else if (_errors.length) {
        didResultInErrors();
      } else {
        var history = context.history();
        var changes = history.changes(actionDiscardTags(history.difference(), _discardTags));
        if (changes.modified.length || changes.created.length || changes.deleted.length) {
          dispatch14.call("willAttemptUpload", this);
          osm.putChangeset(changeset, changes, uploadCallback);
        } else {
          didResultInNoChanges();
        }
      }
    }
    function uploadCallback(err, changeset) {
      if (err) {
        if (err.status === 409) {
          uploader.save(changeset, true, true);
        } else {
          _errors.push({
            msg: err.message || err.responseText,
            details: [_t("save.status_code", { code: err.status })]
          });
          didResultInErrors();
        }
      } else {
        didResultInSuccess(changeset);
      }
    }
    function didResultInNoChanges() {
      dispatch14.call("resultNoChanges", this);
      endSave();
      context.flush();
    }
    function didResultInErrors() {
      context.history().pop();
      dispatch14.call("resultErrors", this, _errors);
      endSave();
    }
    function didResultInConflicts(changeset) {
      _conflicts.sort(function(a2, b2) {
        return b2.id.localeCompare(a2.id);
      });
      dispatch14.call("resultConflicts", this, changeset, _conflicts, _origChanges);
      endSave();
    }
    function didResultInSuccess(changeset) {
      context.history().clearSaved();
      dispatch14.call("resultSuccess", this, changeset);
      window.setTimeout(function() {
        endSave();
        context.flush();
      }, 2500);
    }
    function endSave() {
      _isSaving = false;
      dispatch14.call("saveEnded", this);
    }
    uploader.cancelConflictResolution = function() {
      context.history().pop();
    };
    uploader.processResolvedConflicts = function(changeset) {
      var history = context.history();
      for (var i3 = 0; i3 < _conflicts.length; i3++) {
        if (_conflicts[i3].chosen === 1) {
          var entity = context.hasEntity(_conflicts[i3].id);
          if (entity && entity.type === "way") {
            var children2 = utilArrayUniq(entity.nodes);
            for (var j2 = 0; j2 < children2.length; j2++) {
              history.replace(actionRevert(children2[j2]));
            }
          }
          history.replace(actionRevert(_conflicts[i3].id));
        }
      }
      uploader.save(changeset, true, false);
    };
    uploader.reset = function() {
    };
    return uploader;
  }

  // modules/renderer/background_source.js
  var import_lodash4 = __toESM(require_lodash());

  // modules/util/IntervalTasksQueue.js
  var IntervalTasksQueue = class {
    /**
     * Interval in milliseconds inside which only 1 task can execute.
     * e.g. if interval is 200ms, and 5 async tasks are unqueued,
     * they will complete in ~1s if not cleared
     * @param {number} intervalInMs
     */
    constructor(intervalInMs) {
      this.intervalInMs = intervalInMs;
      this.pendingHandles = [];
      this.time = 0;
    }
    enqueue(task) {
      let taskTimeout = this.time;
      this.time += this.intervalInMs;
      this.pendingHandles.push(setTimeout(() => {
        this.time -= this.intervalInMs;
        task();
      }, taskTimeout));
    }
    clear() {
      this.pendingHandles.forEach((timeoutHandle) => {
        clearTimeout(timeoutHandle);
      });
      this.pendingHandles = [];
      this.time = 0;
    }
  };

  // modules/renderer/background_source.js
  var isRetina = window.devicePixelRatio && window.devicePixelRatio >= 2;
  window.matchMedia("\n        (-webkit-min-device-pixel-ratio: 2), /* Safari */\n        (min-resolution: 2dppx),             /* standard */\n        (min-resolution: 192dpi)             /* fallback */\n    ").addListener(function() {
    isRetina = window.devicePixelRatio && window.devicePixelRatio >= 2;
  });
  function localeDateString(s2) {
    if (!s2)
      return null;
    var options2 = { day: "numeric", month: "short", year: "numeric" };
    var d2 = new Date(s2);
    if (isNaN(d2.getTime()))
      return null;
    return d2.toLocaleDateString(_mainLocalizer.localeCode(), options2);
  }
  function vintageRange(vintage) {
    var s2;
    if (vintage.start || vintage.end) {
      s2 = vintage.start || "?";
      if (vintage.start !== vintage.end) {
        s2 += " - " + (vintage.end || "?");
      }
    }
    return s2;
  }
  function rendererBackgroundSource(data) {
    var source = Object.assign({}, data);
    var _offset = [0, 0];
    var _name = source.name;
    var _description = source.description;
    var _best = !!source.best;
    var _template = source.encrypted ? utilAesDecrypt(source.template) : source.template;
    source.tileSize = data.tileSize || 256;
    source.zoomExtent = data.zoomExtent || [0, 22];
    source.overzoom = data.overzoom !== false;
    source.offset = function(val) {
      if (!arguments.length)
        return _offset;
      _offset = val;
      return source;
    };
    source.nudge = function(val, zoomlevel) {
      _offset[0] += val[0] / Math.pow(2, zoomlevel);
      _offset[1] += val[1] / Math.pow(2, zoomlevel);
      return source;
    };
    source.name = function() {
      var id_safe = source.id.replace(/\./g, "<TX_DOT>");
      return _t("imagery." + id_safe + ".name", { default: (0, import_lodash4.escape)(_name) });
    };
    source.label = function() {
      var id_safe = source.id.replace(/\./g, "<TX_DOT>");
      return _t.append("imagery." + id_safe + ".name", { default: (0, import_lodash4.escape)(_name) });
    };
    source.hasDescription = function() {
      var id_safe = source.id.replace(/\./g, "<TX_DOT>");
      var descriptionText = _mainLocalizer.tInfo("imagery." + id_safe + ".description", { default: (0, import_lodash4.escape)(_description) }).text;
      return descriptionText !== "";
    };
    source.description = function() {
      var id_safe = source.id.replace(/\./g, "<TX_DOT>");
      return _t.append("imagery." + id_safe + ".description", { default: (0, import_lodash4.escape)(_description) });
    };
    source.best = function() {
      return _best;
    };
    source.area = function() {
      if (!data.polygon)
        return Number.MAX_VALUE;
      var area = area_default({ type: "MultiPolygon", coordinates: [data.polygon] });
      return isNaN(area) ? 0 : area;
    };
    source.imageryUsed = function() {
      return _name || source.id;
    };
    source.template = function(val) {
      if (!arguments.length)
        return _template;
      if (source.id === "custom" || source.id === "Bing") {
        _template = val;
      }
      return source;
    };
    source.url = function(coord2) {
      var result = _template.replace(/#[\s\S]*/u, "");
      if (result === "")
        return result;
      if (!source.type || source.id === "custom") {
        if (/SERVICE=WMS|\{(proj|wkid|bbox)\}/.test(result)) {
          source.type = "wms";
          source.projection = "EPSG:3857";
        } else if (/\{(x|y)\}/.test(result)) {
          source.type = "tms";
        } else if (/\{u\}/.test(result)) {
          source.type = "bing";
        }
      }
      if (source.type === "wms") {
        var tileToProjectedCoords = function(x2, y2, z2) {
          var zoomSize = Math.pow(2, z2);
          var lon = x2 / zoomSize * Math.PI * 2 - Math.PI;
          var lat = Math.atan(Math.sinh(Math.PI * (1 - 2 * y2 / zoomSize)));
          switch (source.projection) {
            case "EPSG:4326":
              return {
                x: lon * 180 / Math.PI,
                y: lat * 180 / Math.PI
              };
            default:
              var mercCoords = mercatorRaw(lon, lat);
              return {
                x: 2003750834e-2 / Math.PI * mercCoords[0],
                y: 2003750834e-2 / Math.PI * mercCoords[1]
              };
          }
        };
        var tileSize = source.tileSize;
        var projection2 = source.projection;
        var minXmaxY = tileToProjectedCoords(coord2[0], coord2[1], coord2[2]);
        var maxXminY = tileToProjectedCoords(coord2[0] + 1, coord2[1] + 1, coord2[2]);
        result = result.replace(/\{(\w+)\}/g, function(token, key) {
          switch (key) {
            case "width":
            case "height":
              return tileSize;
            case "proj":
              return projection2;
            case "wkid":
              return projection2.replace(/^EPSG:/, "");
            case "bbox":
              if (projection2 === "EPSG:4326" && // The CRS parameter implies version 1.3 (prior versions use SRS)
              /VERSION=1.3|CRS={proj}/.test(source.template().toUpperCase())) {
                return maxXminY.y + "," + minXmaxY.x + "," + minXmaxY.y + "," + maxXminY.x;
              } else {
                return minXmaxY.x + "," + maxXminY.y + "," + maxXminY.x + "," + minXmaxY.y;
              }
            case "w":
              return minXmaxY.x;
            case "s":
              return maxXminY.y;
            case "n":
              return maxXminY.x;
            case "e":
              return minXmaxY.y;
            default:
              return token;
          }
        });
      } else if (source.type === "tms") {
        result = result.replace("{x}", coord2[0]).replace("{y}", coord2[1]).replace(/\{[t-]y\}/, Math.pow(2, coord2[2]) - coord2[1] - 1).replace(/\{z(oom)?\}/, coord2[2]).replace(/\{@2x\}|\{r\}/, isRetina ? "@2x" : "");
      } else if (source.type === "bing") {
        result = result.replace("{u}", function() {
          var u2 = "";
          for (var zoom = coord2[2]; zoom > 0; zoom--) {
            var b2 = 0;
            var mask = 1 << zoom - 1;
            if ((coord2[0] & mask) !== 0)
              b2++;
            if ((coord2[1] & mask) !== 0)
              b2 += 2;
            u2 += b2.toString();
          }
          return u2;
        });
      }
      result = result.replace(/\{switch:([^}]+)\}/, function(s2, r2) {
        var subdomains = r2.split(",");
        return subdomains[(coord2[0] + coord2[1]) % subdomains.length];
      });
      return result;
    };
    source.validZoom = function(z2) {
      return source.zoomExtent[0] <= z2 && (source.overzoom || source.zoomExtent[1] > z2);
    };
    source.isLocatorOverlay = function() {
      return source.id === "mapbox_locator_overlay";
    };
    source.isHidden = function() {
      return source.id === "DigitalGlobe-Premium-vintage" || source.id === "DigitalGlobe-Standard-vintage";
    };
    source.copyrightNotices = function() {
    };
    source.getMetadata = function(center, tileCoord, callback) {
      var vintage = {
        start: localeDateString(source.startDate),
        end: localeDateString(source.endDate)
      };
      vintage.range = vintageRange(vintage);
      var metadata = { vintage };
      callback(null, metadata);
    };
    return source;
  }
  rendererBackgroundSource.Bing = function(data, dispatch14) {
    data.template = "https://ecn.t{switch:0,1,2,3}.tiles.virtualearth.net/tiles/a{u}.jpeg?g=1&pr=odbl&n=z";
    var bing = rendererBackgroundSource(data);
    var key = utilAesDecrypt("5c875730b09c6b422433e807e1ff060b6536c791dbfffcffc4c6b18a1bdba1f14593d151adb50e19e1be1ab19aef813bf135d0f103475e5c724dec94389e45d0");
    const strictParam = "n";
    var url = "https://dev.virtualearth.net/REST/v1/Imagery/Metadata/AerialOSM?include=ImageryProviders&uriScheme=https&key=" + key;
    var cache = {};
    var inflight = {};
    var providers = [];
    var taskQueue = new IntervalTasksQueue(250);
    var metadataLastZoom = -1;
    json_default(url).then(function(json) {
      let imageryResource = json.resourceSets[0].resources[0];
      let template = imageryResource.imageUrl;
      let subDomains = imageryResource.imageUrlSubdomains;
      let subDomainNumbers = subDomains.map((subDomain) => {
        return subDomain.substring(1);
      }).join(",");
      template = template.replace("{subdomain}", "t{switch:".concat(subDomainNumbers, "}")).replace("{quadkey}", "{u}");
      if (!new URLSearchParams(template).has(strictParam)) {
        template += "&".concat(strictParam, "=z");
      }
      bing.template(template);
      providers = imageryResource.imageryProviders.map(function(provider) {
        return {
          attribution: provider.attribution,
          areas: provider.coverageAreas.map(function(area) {
            return {
              zoom: [area.zoomMin, area.zoomMax],
              extent: geoExtent([area.bbox[1], area.bbox[0]], [area.bbox[3], area.bbox[2]])
            };
          })
        };
      });
      dispatch14.call("change");
    }).catch(function() {
    });
    bing.copyrightNotices = function(zoom, extent) {
      zoom = Math.min(zoom, 21);
      return providers.filter(function(provider) {
        return provider.areas.some(function(area) {
          return extent.intersects(area.extent) && area.zoom[0] <= zoom && area.zoom[1] >= zoom;
        });
      }).map(function(provider) {
        return provider.attribution;
      }).join(", ");
    };
    bing.getMetadata = function(center, tileCoord, callback) {
      var tileID = tileCoord.slice(0, 3).join("/");
      var zoom = Math.min(tileCoord[2], 21);
      var centerPoint = center[1] + "," + center[0];
      var url2 = "https://dev.virtualearth.net/REST/v1/Imagery/BasicMetadata/AerialOSM/" + centerPoint + "?zl=" + zoom + "&key=" + key;
      if (inflight[tileID])
        return;
      if (!cache[tileID]) {
        cache[tileID] = {};
      }
      if (cache[tileID] && cache[tileID].metadata) {
        return callback(null, cache[tileID].metadata);
      }
      inflight[tileID] = true;
      if (metadataLastZoom !== tileCoord[2]) {
        metadataLastZoom = tileCoord[2];
        taskQueue.clear();
      }
      taskQueue.enqueue(() => {
        json_default(url2).then(function(result) {
          delete inflight[tileID];
          if (!result) {
            throw new Error("Unknown Error");
          }
          var vintage = {
            start: localeDateString(result.resourceSets[0].resources[0].vintageStart),
            end: localeDateString(result.resourceSets[0].resources[0].vintageEnd)
          };
          vintage.range = vintageRange(vintage);
          var metadata = { vintage };
          cache[tileID].metadata = metadata;
          if (callback)
            callback(null, metadata);
        }).catch(function(err) {
          delete inflight[tileID];
          if (callback)
            callback(err.message);
        });
      });
    };
    bing.terms_url = "https://blog.openstreetmap.org/2010/11/30/microsoft-imagery-details";
    return bing;
  };
  rendererBackgroundSource.Esri = function(data) {
    if (data.template.match(/blankTile/) === null) {
      data.template = data.template + "?blankTile=false";
    }
    var esri = rendererBackgroundSource(data);
    var cache = {};
    var inflight = {};
    var _prevCenter;
    esri.fetchTilemap = function(center) {
      if (_prevCenter && geoSphericalDistance(center, _prevCenter) < 5e3)
        return;
      _prevCenter = center;
      var z2 = 20;
      var dummyUrl = esri.url([1, 2, 3]);
      var x2 = Math.floor((center[0] + 180) / 360 * Math.pow(2, z2));
      var y2 = Math.floor((1 - Math.log(Math.tan(center[1] * Math.PI / 180) + 1 / Math.cos(center[1] * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, z2));
      var tilemapUrl = dummyUrl.replace(/tile\/[0-9]+\/[0-9]+\/[0-9]+\?blankTile=false/, "tilemap") + "/" + z2 + "/" + y2 + "/" + x2 + "/8/8";
      json_default(tilemapUrl).then(function(tilemap) {
        if (!tilemap) {
          throw new Error("Unknown Error");
        }
        var hasTiles = true;
        for (var i3 = 0; i3 < tilemap.data.length; i3++) {
          if (!tilemap.data[i3]) {
            hasTiles = false;
            break;
          }
        }
        esri.zoomExtent[1] = hasTiles ? 22 : 19;
      }).catch(function() {
      });
    };
    esri.getMetadata = function(center, tileCoord, callback) {
      if (esri.id !== "EsriWorldImagery") {
        return callback(null, {});
      }
      var tileID = tileCoord.slice(0, 3).join("/");
      var zoom = Math.min(tileCoord[2], esri.zoomExtent[1]);
      var centerPoint = center[0] + "," + center[1];
      var unknown = _t("info_panels.background.unknown");
      var vintage = {};
      var metadata = {};
      if (inflight[tileID])
        return;
      var url = "https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/4/query";
      url += "?returnGeometry=false&geometry=" + centerPoint + "&inSR=4326&geometryType=esriGeometryPoint&outFields=*&f=json";
      if (!cache[tileID]) {
        cache[tileID] = {};
      }
      if (cache[tileID] && cache[tileID].metadata) {
        return callback(null, cache[tileID].metadata);
      }
      inflight[tileID] = true;
      json_default(url).then(function(result) {
        delete inflight[tileID];
        result = result.features.map((f2) => f2.attributes).filter((a2) => a2.MinMapLevel <= zoom && a2.MaxMapLevel >= zoom)[0];
        if (!result) {
          throw new Error("Unknown Error");
        } else if (result.features && result.features.length < 1) {
          throw new Error("No Results");
        } else if (result.error && result.error.message) {
          throw new Error(result.error.message);
        }
        var captureDate = localeDateString(result.SRC_DATE2);
        vintage = {
          start: captureDate,
          end: captureDate,
          range: captureDate
        };
        metadata = {
          vintage,
          source: clean2(result.NICE_NAME),
          description: clean2(result.NICE_DESC),
          resolution: clean2(+Number(result.SRC_RES).toFixed(4)),
          accuracy: clean2(+Number(result.SRC_ACC).toFixed(4))
        };
        if (isFinite(metadata.resolution)) {
          metadata.resolution += " m";
        }
        if (isFinite(metadata.accuracy)) {
          metadata.accuracy += " m";
        }
        cache[tileID].metadata = metadata;
        if (callback)
          callback(null, metadata);
      }).catch(function(err) {
        delete inflight[tileID];
        if (callback)
          callback(err.message);
      });
      function clean2(val) {
        return String(val).trim() || unknown;
      }
    };
    return esri;
  };
  rendererBackgroundSource.None = function() {
    var source = rendererBackgroundSource({ id: "none", template: "" });
    source.name = function() {
      return _t("background.none");
    };
    source.label = function() {
      return _t.append("background.none");
    };
    source.imageryUsed = function() {
      return null;
    };
    source.area = function() {
      return -1;
    };
    return source;
  };
  rendererBackgroundSource.Custom = function(template) {
    var source = rendererBackgroundSource({ id: "custom", template });
    source.name = function() {
      return _t("background.custom");
    };
    source.label = function() {
      return _t.append("background.custom");
    };
    source.imageryUsed = function() {
      var cleaned = source.template();
      if (cleaned.indexOf("?") !== -1) {
        var parts = cleaned.split("?", 2);
        var qs = utilStringQs(parts[1]);
        ["access_token", "connectId", "token", "Signature"].forEach(function(param) {
          if (qs[param]) {
            qs[param] = "{apikey}";
          }
        });
        cleaned = parts[0] + "?" + utilQsString(qs, true);
      }
      cleaned = cleaned.replace(/token\/(\w+)/, "token/{apikey}").replace(/key=(\w+)/, "key={apikey}");
      return "Custom (" + cleaned + " )";
    };
    source.area = function() {
      return -2;
    };
    return source;
  };

  // node_modules/@turf/helpers/dist/es/index.js
  var earthRadius = 63710088e-1;
  var factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: earthRadius / 111325,
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1e3,
    kilometres: earthRadius / 1e3,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1e3,
    millimetres: earthRadius * 1e3,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius * 1.0936
  };
  var unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.37,
    kilometers: 1 / 1e3,
    kilometres: 1 / 1e3,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1e3,
    millimetres: 1e3,
    nauticalmiles: 1 / 1852,
    radians: 1 / earthRadius,
    yards: 1.0936133
  };
  function feature2(geom, properties, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var feat = { type: "Feature" };
    if (options2.id === 0 || options2.id) {
      feat.id = options2.id;
    }
    if (options2.bbox) {
      feat.bbox = options2.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
  }
  function polygon(coordinates, properties, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
      var ring = coordinates_1[_i];
      if (ring.length < 4) {
        throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
      }
      for (var j2 = 0; j2 < ring[ring.length - 1].length; j2++) {
        if (ring[ring.length - 1][j2] !== ring[0][j2]) {
          throw new Error("First and last Position are not equivalent.");
        }
      }
    }
    var geom = {
      type: "Polygon",
      coordinates
    };
    return feature2(geom, properties, options2);
  }
  function lineString(coordinates, properties, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (coordinates.length < 2) {
      throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
      type: "LineString",
      coordinates
    };
    return feature2(geom, properties, options2);
  }
  function multiLineString(coordinates, properties, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var geom = {
      type: "MultiLineString",
      coordinates
    };
    return feature2(geom, properties, options2);
  }
  function multiPolygon(coordinates, properties, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var geom = {
      type: "MultiPolygon",
      coordinates
    };
    return feature2(geom, properties, options2);
  }

  // node_modules/@turf/invariant/dist/es/index.js
  function getGeom(geojson) {
    if (geojson.type === "Feature") {
      return geojson.geometry;
    }
    return geojson;
  }

  // node_modules/@turf/bbox-clip/dist/es/lib/lineclip.js
  function lineclip(points, bbox2, result) {
    var len = points.length, codeA = bitCode(points[0], bbox2), part = [], i3, codeB, lastCode;
    var a2;
    var b2;
    if (!result)
      result = [];
    for (i3 = 1; i3 < len; i3++) {
      a2 = points[i3 - 1];
      b2 = points[i3];
      codeB = lastCode = bitCode(b2, bbox2);
      while (true) {
        if (!(codeA | codeB)) {
          part.push(a2);
          if (codeB !== lastCode) {
            part.push(b2);
            if (i3 < len - 1) {
              result.push(part);
              part = [];
            }
          } else if (i3 === len - 1) {
            part.push(b2);
          }
          break;
        } else if (codeA & codeB) {
          break;
        } else if (codeA) {
          a2 = intersect(a2, b2, codeA, bbox2);
          codeA = bitCode(a2, bbox2);
        } else {
          b2 = intersect(a2, b2, codeB, bbox2);
          codeB = bitCode(b2, bbox2);
        }
      }
      codeA = lastCode;
    }
    if (part.length)
      result.push(part);
    return result;
  }
  function polygonclip(points, bbox2) {
    var result, edge, prev, prevInside, i3, p2, inside;
    for (edge = 1; edge <= 8; edge *= 2) {
      result = [];
      prev = points[points.length - 1];
      prevInside = !(bitCode(prev, bbox2) & edge);
      for (i3 = 0; i3 < points.length; i3++) {
        p2 = points[i3];
        inside = !(bitCode(p2, bbox2) & edge);
        if (inside !== prevInside)
          result.push(intersect(prev, p2, edge, bbox2));
        if (inside)
          result.push(p2);
        prev = p2;
        prevInside = inside;
      }
      points = result;
      if (!points.length)
        break;
    }
    return result;
  }
  function intersect(a2, b2, edge, bbox2) {
    return edge & 8 ? [a2[0] + (b2[0] - a2[0]) * (bbox2[3] - a2[1]) / (b2[1] - a2[1]), bbox2[3]] : edge & 4 ? [a2[0] + (b2[0] - a2[0]) * (bbox2[1] - a2[1]) / (b2[1] - a2[1]), bbox2[1]] : edge & 2 ? [bbox2[2], a2[1] + (b2[1] - a2[1]) * (bbox2[2] - a2[0]) / (b2[0] - a2[0])] : edge & 1 ? [bbox2[0], a2[1] + (b2[1] - a2[1]) * (bbox2[0] - a2[0]) / (b2[0] - a2[0])] : null;
  }
  function bitCode(p2, bbox2) {
    var code = 0;
    if (p2[0] < bbox2[0])
      code |= 1;
    else if (p2[0] > bbox2[2])
      code |= 2;
    if (p2[1] < bbox2[1])
      code |= 4;
    else if (p2[1] > bbox2[3])
      code |= 8;
    return code;
  }

  // node_modules/@turf/bbox-clip/dist/es/index.js
  function bboxClip(feature3, bbox2) {
    var geom = getGeom(feature3);
    var type2 = geom.type;
    var properties = feature3.type === "Feature" ? feature3.properties : {};
    var coords = geom.coordinates;
    switch (type2) {
      case "LineString":
      case "MultiLineString": {
        var lines_1 = [];
        if (type2 === "LineString") {
          coords = [coords];
        }
        coords.forEach(function(line) {
          lineclip(line, bbox2, lines_1);
        });
        if (lines_1.length === 1) {
          return lineString(lines_1[0], properties);
        }
        return multiLineString(lines_1, properties);
      }
      case "Polygon":
        return polygon(clipPolygon(coords, bbox2), properties);
      case "MultiPolygon":
        return multiPolygon(coords.map(function(poly) {
          return clipPolygon(poly, bbox2);
        }), properties);
      default:
        throw new Error("geometry " + type2 + " not supported");
    }
  }
  function clipPolygon(rings, bbox2) {
    var outRings = [];
    for (var _i = 0, rings_1 = rings; _i < rings_1.length; _i++) {
      var ring = rings_1[_i];
      var clipped = polygonclip(ring, bbox2);
      if (clipped.length > 0) {
        if (clipped[0][0] !== clipped[clipped.length - 1][0] || clipped[0][1] !== clipped[clipped.length - 1][1]) {
          clipped.push(clipped[0]);
        }
        if (clipped.length >= 4) {
          outRings.push(clipped);
        }
      }
    }
    return outRings;
  }

  // node_modules/@turf/meta/dist/es/index.js
  function coordEach(geojson, callback, excludeWrapCoord) {
    if (geojson === null)
      return;
    var j2, k2, l2, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type2 = geojson.type, isFeatureCollection = type2 === "FeatureCollection", isFeature = type2 === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
        var multiFeatureIndex = 0;
        var geometryIndex = 0;
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
        if (geometry === null)
          continue;
        coords = geometry.coordinates;
        var geomType = geometry.type;
        wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
        switch (geomType) {
          case null:
            break;
          case "Point":
            if (callback(
              coords,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            multiFeatureIndex++;
            break;
          case "LineString":
          case "MultiPoint":
            for (j2 = 0; j2 < coords.length; j2++) {
              if (callback(
                coords[j2],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
              if (geomType === "MultiPoint")
                multiFeatureIndex++;
            }
            if (geomType === "LineString")
              multiFeatureIndex++;
            break;
          case "Polygon":
          case "MultiLineString":
            for (j2 = 0; j2 < coords.length; j2++) {
              for (k2 = 0; k2 < coords[j2].length - wrapShrink; k2++) {
                if (callback(
                  coords[j2][k2],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              if (geomType === "MultiLineString")
                multiFeatureIndex++;
              if (geomType === "Polygon")
                geometryIndex++;
            }
            if (geomType === "Polygon")
              multiFeatureIndex++;
            break;
          case "MultiPolygon":
            for (j2 = 0; j2 < coords.length; j2++) {
              geometryIndex = 0;
              for (k2 = 0; k2 < coords[j2].length; k2++) {
                for (l2 = 0; l2 < coords[j2][k2].length - wrapShrink; l2++) {
                  if (callback(
                    coords[j2][k2][l2],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                }
                geometryIndex++;
              }
              multiFeatureIndex++;
            }
            break;
          case "GeometryCollection":
            for (j2 = 0; j2 < geometry.geometries.length; j2++)
              if (coordEach(geometry.geometries[j2], callback, excludeWrapCoord) === false)
                return false;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
    }
  }

  // node_modules/@turf/bbox/dist/es/index.js
  function bbox(geojson) {
    var result = [Infinity, Infinity, -Infinity, -Infinity];
    coordEach(geojson, function(coord2) {
      if (result[0] > coord2[0]) {
        result[0] = coord2[0];
      }
      if (result[1] > coord2[1]) {
        result[1] = coord2[1];
      }
      if (result[2] < coord2[0]) {
        result[2] = coord2[0];
      }
      if (result[3] < coord2[1]) {
        result[3] = coord2[1];
      }
    });
    return result;
  }
  bbox["default"] = bbox;
  var es_default = bbox;

  // modules/renderer/background.js
  var import_which_polygon3 = __toESM(require_which_polygon());

  // modules/renderer/tile_layer.js
  function rendererTileLayer(context) {
    var transformProp = utilPrefixCSSProperty("Transform");
    var tiler9 = utilTiler();
    var _tileSize = 256;
    var _projection;
    var _cache5 = {};
    var _tileOrigin;
    var _zoom;
    var _source;
    function tileSizeAtZoom(d2, z2) {
      var EPSILON = 2e-3;
      return _tileSize * Math.pow(2, z2 - d2[2]) / _tileSize + EPSILON;
    }
    function atZoom(t2, distance) {
      var power = Math.pow(2, distance);
      return [
        Math.floor(t2[0] * power),
        Math.floor(t2[1] * power),
        t2[2] + distance
      ];
    }
    function lookUp(d2) {
      for (var up = -1; up > -d2[2]; up--) {
        var tile = atZoom(d2, up);
        if (_cache5[_source.url(tile)] !== false) {
          return tile;
        }
      }
    }
    function uniqueBy(a2, n3) {
      var o2 = [];
      var seen = {};
      for (var i3 = 0; i3 < a2.length; i3++) {
        if (seen[a2[i3][n3]] === void 0) {
          o2.push(a2[i3]);
          seen[a2[i3][n3]] = true;
        }
      }
      return o2;
    }
    function addSource(d2) {
      d2.push(_source.url(d2));
      return d2;
    }
    function background(selection2) {
      _zoom = geoScaleToZoom(_projection.scale(), _tileSize);
      var pixelOffset;
      if (_source) {
        pixelOffset = [
          _source.offset()[0] * Math.pow(2, _zoom),
          _source.offset()[1] * Math.pow(2, _zoom)
        ];
      } else {
        pixelOffset = [0, 0];
      }
      var translate = [
        _projection.translate()[0] + pixelOffset[0],
        _projection.translate()[1] + pixelOffset[1]
      ];
      tiler9.scale(_projection.scale() * 2 * Math.PI).translate(translate);
      _tileOrigin = [
        _projection.scale() * Math.PI - translate[0],
        _projection.scale() * Math.PI - translate[1]
      ];
      render(selection2);
    }
    function render(selection2) {
      if (!_source)
        return;
      var requests = [];
      var showDebug = context.getDebug("tile") && !_source.overlay;
      if (_source.validZoom(_zoom)) {
        tiler9.skipNullIsland(!!_source.overlay);
        tiler9().forEach(function(d2) {
          addSource(d2);
          if (d2[3] === "")
            return;
          if (typeof d2[3] !== "string")
            return;
          requests.push(d2);
          if (_cache5[d2[3]] === false && lookUp(d2)) {
            requests.push(addSource(lookUp(d2)));
          }
        });
        requests = uniqueBy(requests, 3).filter(function(r2) {
          return _cache5[r2[3]] !== false;
        });
      }
      function load(d3_event, d2) {
        _cache5[d2[3]] = true;
        select_default2(this).on("error", null).on("load", null).classed("tile-loaded", true);
        render(selection2);
      }
      function error(d3_event, d2) {
        _cache5[d2[3]] = false;
        select_default2(this).on("error", null).on("load", null).remove();
        render(selection2);
      }
      function imageTransform(d2) {
        var ts = _tileSize * Math.pow(2, _zoom - d2[2]);
        var scale = tileSizeAtZoom(d2, _zoom);
        return "translate(" + (d2[0] * ts - _tileOrigin[0]) + "px," + (d2[1] * ts - _tileOrigin[1]) + "px) scale(" + scale + "," + scale + ")";
      }
      function tileCenter(d2) {
        var ts = _tileSize * Math.pow(2, _zoom - d2[2]);
        return [
          d2[0] * ts - _tileOrigin[0] + ts / 2,
          d2[1] * ts - _tileOrigin[1] + ts / 2
        ];
      }
      function debugTransform(d2) {
        var coord2 = tileCenter(d2);
        return "translate(" + coord2[0] + "px," + coord2[1] + "px)";
      }
      var dims = tiler9.size();
      var mapCenter = [dims[0] / 2, dims[1] / 2];
      var minDist = Math.max(dims[0], dims[1]);
      var nearCenter;
      requests.forEach(function(d2) {
        var c2 = tileCenter(d2);
        var dist = geoVecLength(c2, mapCenter);
        if (dist < minDist) {
          minDist = dist;
          nearCenter = d2;
        }
      });
      var image = selection2.selectAll("img").data(requests, function(d2) {
        return d2[3];
      });
      image.exit().style(transformProp, imageTransform).classed("tile-removing", true).classed("tile-center", false).each(function() {
        var tile = select_default2(this);
        window.setTimeout(function() {
          if (tile.classed("tile-removing")) {
            tile.remove();
          }
        }, 300);
      });
      image.enter().append("img").attr("class", "tile").attr("alt", "").attr("draggable", "false").style("width", _tileSize + "px").style("height", _tileSize + "px").attr("src", function(d2) {
        return d2[3];
      }).on("error", error).on("load", load).merge(image).style(transformProp, imageTransform).classed("tile-debug", showDebug).classed("tile-removing", false).classed("tile-center", function(d2) {
        return d2 === nearCenter;
      });
      var debug2 = selection2.selectAll(".tile-label-debug").data(showDebug ? requests : [], function(d2) {
        return d2[3];
      });
      debug2.exit().remove();
      if (showDebug) {
        var debugEnter = debug2.enter().append("div").attr("class", "tile-label-debug");
        debugEnter.append("div").attr("class", "tile-label-debug-coord");
        debugEnter.append("div").attr("class", "tile-label-debug-vintage");
        debug2 = debug2.merge(debugEnter);
        debug2.style(transformProp, debugTransform);
        debug2.selectAll(".tile-label-debug-coord").text(function(d2) {
          return d2[2] + " / " + d2[0] + " / " + d2[1];
        });
        debug2.selectAll(".tile-label-debug-vintage").each(function(d2) {
          var span = select_default2(this);
          var center = context.projection.invert(tileCenter(d2));
          _source.getMetadata(center, d2, function(err, result) {
            if (result && result.vintage && result.vintage.range) {
              span.text(result.vintage.range);
            } else {
              span.text("");
              span.call(_t.append("info_panels.background.vintage"));
              span.append("span").text(": ");
              span.call(_t.append("info_panels.background.unknown"));
            }
          });
        });
      }
    }
    background.projection = function(val) {
      if (!arguments.length)
        return _projection;
      _projection = val;
      return background;
    };
    background.dimensions = function(val) {
      if (!arguments.length)
        return tiler9.size();
      tiler9.size(val);
      return background;
    };
    background.source = function(val) {
      if (!arguments.length)
        return _source;
      _source = val;
      _tileSize = _source.tileSize;
      _cache5 = {};
      tiler9.tileSize(_source.tileSize).zoomExtent(_source.zoomExtent);
      return background;
    };
    return background;
  }

  // modules/renderer/background.js
  var _imageryIndex = null;
  function rendererBackground(context) {
    const dispatch14 = dispatch_default("change");
    const baseLayer = rendererTileLayer(context).projection(context.projection);
    let _checkedBlocklists = [];
    let _isValid = true;
    let _overlayLayers = [];
    let _brightness = 1;
    let _contrast = 1;
    let _saturation = 1;
    let _sharpness = 1;
    function ensureImageryIndex() {
      return _mainFileFetcher.get("imagery").then((sources) => {
        if (_imageryIndex)
          return _imageryIndex;
        _imageryIndex = {
          imagery: sources,
          features: {}
        };
        const features = sources.map((source) => {
          if (!source.polygon)
            return null;
          const rings = source.polygon.map((ring) => [ring]);
          const feature3 = {
            type: "Feature",
            properties: { id: source.id },
            geometry: { type: "MultiPolygon", coordinates: rings }
          };
          _imageryIndex.features[source.id] = feature3;
          return feature3;
        }).filter(Boolean);
        _imageryIndex.query = (0, import_which_polygon3.default)({ type: "FeatureCollection", features });
        _imageryIndex.backgrounds = sources.map((source) => {
          if (source.type === "bing") {
            return rendererBackgroundSource.Bing(source, dispatch14);
          } else if (/^EsriWorldImagery/.test(source.id)) {
            return rendererBackgroundSource.Esri(source);
          } else {
            return rendererBackgroundSource(source);
          }
        });
        _imageryIndex.backgrounds.unshift(rendererBackgroundSource.None());
        let template = corePreferences("background-custom-template") || "";
        const custom = rendererBackgroundSource.Custom(template);
        _imageryIndex.backgrounds.unshift(custom);
        return _imageryIndex;
      });
    }
    function background(selection2) {
      const currSource = baseLayer.source();
      if (context.map().zoom() > 18) {
        if (currSource && /^EsriWorldImagery/.test(currSource.id)) {
          const center = context.map().center();
          currSource.fetchTilemap(center);
        }
      }
      const sources = background.sources(context.map().extent());
      const wasValid = _isValid;
      _isValid = !!sources.filter((d2) => d2 === currSource).length;
      if (wasValid !== _isValid) {
        background.updateImagery();
      }
      let baseFilter = "";
      if (_brightness !== 1) {
        baseFilter += " brightness(".concat(_brightness, ")");
      }
      if (_contrast !== 1) {
        baseFilter += " contrast(".concat(_contrast, ")");
      }
      if (_saturation !== 1) {
        baseFilter += " saturate(".concat(_saturation, ")");
      }
      if (_sharpness < 1) {
        const blur = number_default(0.5, 5)(1 - _sharpness);
        baseFilter += " blur(".concat(blur, "px)");
      }
      let base = selection2.selectAll(".layer-background").data([0]);
      base = base.enter().insert("div", ".layer-data").attr("class", "layer layer-background").merge(base);
      base.style("filter", baseFilter || null);
      let imagery = base.selectAll(".layer-imagery").data([0]);
      imagery.enter().append("div").attr("class", "layer layer-imagery").merge(imagery).call(baseLayer);
      let maskFilter = "";
      let mixBlendMode = "";
      if (_sharpness > 1) {
        mixBlendMode = "overlay";
        maskFilter = "saturate(0) blur(3px) invert(1)";
        let contrast = _sharpness - 1;
        maskFilter += " contrast(".concat(contrast, ")");
        let brightness = number_default(1, 0.85)(_sharpness - 1);
        maskFilter += " brightness(".concat(brightness, ")");
      }
      let mask = base.selectAll(".layer-unsharp-mask").data(_sharpness > 1 ? [0] : []);
      mask.exit().remove();
      mask.enter().append("div").attr("class", "layer layer-mask layer-unsharp-mask").merge(mask).call(baseLayer).style("filter", maskFilter || null).style("mix-blend-mode", mixBlendMode || null);
      let overlays = selection2.selectAll(".layer-overlay").data(_overlayLayers, (d2) => d2.source().name());
      overlays.exit().remove();
      overlays.enter().insert("div", ".layer-data").attr("class", "layer layer-overlay").merge(overlays).each((layer, i3, nodes) => select_default2(nodes[i3]).call(layer));
    }
    background.updateImagery = function() {
      let currSource = baseLayer.source();
      if (context.inIntro() || !currSource)
        return;
      let o2 = _overlayLayers.filter((d2) => !d2.source().isLocatorOverlay() && !d2.source().isHidden()).map((d2) => d2.source().id).join(",");
      const meters = geoOffsetToMeters(currSource.offset());
      const EPSILON = 0.01;
      const x2 = +meters[0].toFixed(2);
      const y2 = +meters[1].toFixed(2);
      let hash = utilStringQs(window.location.hash);
      let id2 = currSource.id;
      if (id2 === "custom") {
        id2 = "custom:".concat(currSource.template());
      }
      if (id2) {
        hash.background = id2;
      } else {
        delete hash.background;
      }
      if (o2) {
        hash.overlays = o2;
      } else {
        delete hash.overlays;
      }
      if (Math.abs(x2) > EPSILON || Math.abs(y2) > EPSILON) {
        hash.offset = "".concat(x2, ",").concat(y2);
      } else {
        delete hash.offset;
      }
      if (!window.mocha) {
        window.location.replace("#" + utilQsString(hash, true));
      }
      let imageryUsed = [];
      let photoOverlaysUsed = [];
      const currUsed = currSource.imageryUsed();
      if (currUsed && _isValid) {
        imageryUsed.push(currUsed);
      }
      _overlayLayers.filter((d2) => !d2.source().isLocatorOverlay() && !d2.source().isHidden()).forEach((d2) => imageryUsed.push(d2.source().imageryUsed()));
      const dataLayer = context.layers().layer("data");
      if (dataLayer && dataLayer.enabled() && dataLayer.hasData()) {
        imageryUsed.push(dataLayer.getSrc());
      }
      const photoOverlayLayers = {
        streetside: "Bing Streetside",
        mapillary: "Mapillary Images",
        "mapillary-map-features": "Mapillary Map Features",
        "mapillary-signs": "Mapillary Signs",
        kartaview: "KartaView Images",
        vegbilder: "Norwegian Road Administration Images",
        mapilio: "Mapilio Images"
      };
      for (let layerID in photoOverlayLayers) {
        const layer = context.layers().layer(layerID);
        if (layer && layer.enabled()) {
          photoOverlaysUsed.push(layerID);
          imageryUsed.push(photoOverlayLayers[layerID]);
        }
      }
      context.history().imageryUsed(imageryUsed);
      context.history().photoOverlaysUsed(photoOverlaysUsed);
    };
    background.sources = (extent, zoom, includeCurrent) => {
      if (!_imageryIndex)
        return [];
      let visible = {};
      (_imageryIndex.query.bbox(extent.rectangle(), true) || []).forEach((d2) => visible[d2.id] = true);
      const currSource = baseLayer.source();
      const osm = context.connection();
      const blocklists = osm && osm.imageryBlocklists() || [];
      const blocklistChanged = blocklists.length !== _checkedBlocklists.length || blocklists.some((regex, index) => String(regex) !== _checkedBlocklists[index]);
      if (blocklistChanged) {
        _imageryIndex.backgrounds.forEach((source) => {
          source.isBlocked = blocklists.some((regex) => regex.test(source.template()));
        });
        _checkedBlocklists = blocklists.map((regex) => String(regex));
      }
      return _imageryIndex.backgrounds.filter((source) => {
        if (includeCurrent && currSource === source)
          return true;
        if (source.isBlocked)
          return false;
        if (!source.polygon)
          return true;
        if (zoom && zoom < 6)
          return false;
        return visible[source.id];
      });
    };
    background.dimensions = (val) => {
      if (!val)
        return;
      baseLayer.dimensions(val);
      _overlayLayers.forEach((layer) => layer.dimensions(val));
    };
    background.baseLayerSource = function(d2) {
      if (!arguments.length)
        return baseLayer.source();
      const osm = context.connection();
      if (!osm)
        return background;
      const blocklists = osm.imageryBlocklists();
      const template = d2.template();
      let fail = false;
      let tested = 0;
      let regex;
      for (let i3 = 0; i3 < blocklists.length; i3++) {
        regex = blocklists[i3];
        fail = regex.test(template);
        tested++;
        if (fail)
          break;
      }
      if (!tested) {
        regex = /.*\.google(apis)?\..*\/(vt|kh)[\?\/].*([xyz]=.*){3}.*/;
        fail = regex.test(template);
      }
      baseLayer.source(!fail ? d2 : background.findSource("none"));
      dispatch14.call("change");
      background.updateImagery();
      return background;
    };
    background.findSource = (id2) => {
      if (!id2 || !_imageryIndex)
        return null;
      return _imageryIndex.backgrounds.find((d2) => d2.id && d2.id === id2);
    };
    background.bing = () => {
      background.baseLayerSource(background.findSource("Bing"));
    };
    background.showsLayer = (d2) => {
      const currSource = baseLayer.source();
      if (!d2 || !currSource)
        return false;
      return d2.id === currSource.id || _overlayLayers.some((layer) => d2.id === layer.source().id);
    };
    background.overlayLayerSources = () => {
      return _overlayLayers.map((layer) => layer.source());
    };
    background.toggleOverlayLayer = (d2) => {
      let layer;
      for (let i3 = 0; i3 < _overlayLayers.length; i3++) {
        layer = _overlayLayers[i3];
        if (layer.source() === d2) {
          _overlayLayers.splice(i3, 1);
          dispatch14.call("change");
          background.updateImagery();
          return;
        }
      }
      layer = rendererTileLayer(context).source(d2).projection(context.projection).dimensions(
        baseLayer.dimensions()
      );
      _overlayLayers.push(layer);
      dispatch14.call("change");
      background.updateImagery();
    };
    background.nudge = (d2, zoom) => {
      const currSource = baseLayer.source();
      if (currSource) {
        currSource.nudge(d2, zoom);
        dispatch14.call("change");
        background.updateImagery();
      }
      return background;
    };
    background.offset = function(d2) {
      const currSource = baseLayer.source();
      if (!arguments.length) {
        return currSource && currSource.offset() || [0, 0];
      }
      if (currSource) {
        currSource.offset(d2);
        dispatch14.call("change");
        background.updateImagery();
      }
      return background;
    };
    background.brightness = function(d2) {
      if (!arguments.length)
        return _brightness;
      _brightness = d2;
      if (context.mode())
        dispatch14.call("change");
      return background;
    };
    background.contrast = function(d2) {
      if (!arguments.length)
        return _contrast;
      _contrast = d2;
      if (context.mode())
        dispatch14.call("change");
      return background;
    };
    background.saturation = function(d2) {
      if (!arguments.length)
        return _saturation;
      _saturation = d2;
      if (context.mode())
        dispatch14.call("change");
      return background;
    };
    background.sharpness = function(d2) {
      if (!arguments.length)
        return _sharpness;
      _sharpness = d2;
      if (context.mode())
        dispatch14.call("change");
      return background;
    };
    let _loadPromise;
    background.ensureLoaded = () => {
      if (_loadPromise)
        return _loadPromise;
      return _loadPromise = ensureImageryIndex();
    };
    background.init = () => {
      const loadPromise = background.ensureLoaded();
      const hash = utilStringQs(window.location.hash);
      const requestedBackground = hash.background || hash.layer;
      const lastUsedBackground = corePreferences("background-last-used");
      return loadPromise.then((imageryIndex) => {
        const extent = context.map().extent();
        const validBackgrounds = background.sources(extent).filter((d2) => d2.id !== "none" && d2.id !== "custom");
        const first = validBackgrounds.length && validBackgrounds[0];
        const isLastUsedValid = !!validBackgrounds.find((d2) => d2.id && d2.id === lastUsedBackground);
        let best;
        if (!requestedBackground && extent) {
          const viewArea = extent.area();
          best = validBackgrounds.find((s2) => {
            if (!s2.best() || s2.overlay)
              return false;
            let bbox2 = es_default(bboxClip(
              { type: "MultiPolygon", coordinates: [s2.polygon || [extent.polygon()]] },
              extent.rectangle()
            ));
            let area = geoExtent(bbox2.slice(0, 2), bbox2.slice(2, 4)).area();
            return area / viewArea > 0.5;
          });
        }
        if (requestedBackground && requestedBackground.indexOf("custom:") === 0) {
          const template = requestedBackground.replace(/^custom:/, "");
          const custom = background.findSource("custom");
          background.baseLayerSource(custom.template(template));
          corePreferences("background-custom-template", template);
        } else {
          background.baseLayerSource(
            background.findSource(requestedBackground) || best || isLastUsedValid && background.findSource(lastUsedBackground) || background.findSource("Bing") || first || background.findSource("none")
          );
        }
        const locator = imageryIndex.backgrounds.find((d2) => d2.overlay && d2.default);
        if (locator) {
          background.toggleOverlayLayer(locator);
        }
        const overlays = (hash.overlays || "").split(",");
        overlays.forEach((overlay) => {
          overlay = background.findSource(overlay);
          if (overlay) {
            background.toggleOverlayLayer(overlay);
          }
        });
        if (hash.gpx) {
          const gpx2 = context.layers().layer("data");
          if (gpx2) {
            gpx2.url(hash.gpx, ".gpx");
          }
        }
        if (hash.offset) {
          const offset = hash.offset.replace(/;/g, ",").split(",").map((n3) => !isNaN(n3) && n3);
          if (offset.length === 2) {
            background.offset(geoMetersToOffset(offset));
          }
        }
      }).catch((err) => {
        console.error(err);
      });
    };
    return utilRebind(background, dispatch14, "on");
  }

  // modules/renderer/features.js
  function rendererFeatures(context) {
    var dispatch14 = dispatch_default("change", "redraw");
    var features = utilRebind({}, dispatch14, "on");
    var _deferred2 = /* @__PURE__ */ new Set();
    var traffic_roads = {
      "motorway": true,
      "motorway_link": true,
      "trunk": true,
      "trunk_link": true,
      "primary": true,
      "primary_link": true,
      "secondary": true,
      "secondary_link": true,
      "tertiary": true,
      "tertiary_link": true,
      "residential": true,
      "unclassified": true,
      "living_street": true,
      "busway": true
    };
    var service_roads = {
      "service": true,
      "road": true,
      "track": true
    };
    var paths = {
      "path": true,
      "footway": true,
      "cycleway": true,
      "bridleway": true,
      "steps": true,
      "pedestrian": true
    };
    var _cullFactor = 1;
    var _cache5 = {};
    var _rules = {};
    var _stats = {};
    var _keys = [];
    var _hidden = [];
    var _forceVisible = {};
    function update() {
      if (!window.mocha) {
        var hash = utilStringQs(window.location.hash);
        var disabled = features.disabled();
        if (disabled.length) {
          hash.disable_features = disabled.join(",");
        } else {
          delete hash.disable_features;
        }
        window.location.replace("#" + utilQsString(hash, true));
        corePreferences("disabled-features", disabled.join(","));
      }
      _hidden = features.hidden();
      dispatch14.call("change");
      dispatch14.call("redraw");
    }
    function defineRule(k2, filter2, max3) {
      var isEnabled = true;
      _keys.push(k2);
      _rules[k2] = {
        filter: filter2,
        enabled: isEnabled,
        // whether the user wants it enabled..
        count: 0,
        currentMax: max3 || Infinity,
        defaultMax: max3 || Infinity,
        enable: function() {
          this.enabled = true;
          this.currentMax = this.defaultMax;
        },
        disable: function() {
          this.enabled = false;
          this.currentMax = 0;
        },
        hidden: function() {
          return this.count === 0 && !this.enabled || this.count > this.currentMax * _cullFactor;
        },
        autoHidden: function() {
          return this.hidden() && this.currentMax > 0;
        }
      };
    }
    defineRule("points", function isPoint(tags, geometry) {
      return geometry === "point";
    }, 200);
    defineRule("traffic_roads", function isTrafficRoad(tags) {
      return traffic_roads[tags.highway];
    });
    defineRule("service_roads", function isServiceRoad(tags) {
      return service_roads[tags.highway];
    });
    defineRule("paths", function isPath(tags) {
      return paths[tags.highway];
    });
    defineRule("buildings", function isBuilding(tags) {
      return !!tags.building && tags.building !== "no" || tags.parking === "multi-storey" || tags.parking === "sheds" || tags.parking === "carports" || tags.parking === "garage_boxes";
    }, 250);
    defineRule("building_parts", function isBuildingPart(tags) {
      return tags["building:part"];
    });
    defineRule("indoor", function isIndoor(tags) {
      return tags.indoor;
    });
    defineRule("landuse", function isLanduse(tags, geometry) {
      return geometry === "area" && !_rules.buildings.filter(tags) && !_rules.building_parts.filter(tags) && !_rules.indoor.filter(tags) && !_rules.water.filter(tags) && !_rules.pistes.filter(tags);
    });
    defineRule("boundaries", function isBoundary(tags, geometry) {
      return (geometry === "line" && !!tags.boundary || geometry === "relation" && tags.type === "boundary") && !(traffic_roads[tags.highway] || service_roads[tags.highway] || paths[tags.highway] || tags.waterway || tags.railway || tags.landuse || tags.natural || tags.building || tags.power);
    });
    defineRule("water", function isWater(tags) {
      return !!tags.waterway || tags.natural === "water" || tags.natural === "coastline" || tags.natural === "bay" || tags.landuse === "pond" || tags.landuse === "basin" || tags.landuse === "reservoir" || tags.landuse === "salt_pond";
    });
    defineRule("rail", function isRail(tags) {
      return (!!tags.railway || tags.landuse === "railway") && !(traffic_roads[tags.highway] || service_roads[tags.highway] || paths[tags.highway]);
    });
    defineRule("pistes", function isPiste(tags) {
      return tags["piste:type"];
    });
    defineRule("aerialways", function isPiste(tags) {
      return tags.aerialway && tags.aerialway !== "yes" && tags.aerialway !== "station";
    });
    defineRule("power", function isPower(tags) {
      return !!tags.power;
    });
    defineRule("past_future", function isPastFuture(tags) {
      if (traffic_roads[tags.highway] || service_roads[tags.highway] || paths[tags.highway]) {
        return false;
      }
      var strings = Object.keys(tags);
      for (var i3 = 0; i3 < strings.length; i3++) {
        var s2 = strings[i3];
        if (osmLifecyclePrefixes[s2] || osmLifecyclePrefixes[tags[s2]])
          return true;
      }
      return false;
    });
    defineRule("others", function isOther(tags, geometry) {
      return geometry === "line" || geometry === "area";
    });
    features.features = function() {
      return _rules;
    };
    features.keys = function() {
      return _keys;
    };
    features.enabled = function(k2) {
      if (!arguments.length) {
        return _keys.filter(function(k3) {
          return _rules[k3].enabled;
        });
      }
      return _rules[k2] && _rules[k2].enabled;
    };
    features.disabled = function(k2) {
      if (!arguments.length) {
        return _keys.filter(function(k3) {
          return !_rules[k3].enabled;
        });
      }
      return _rules[k2] && !_rules[k2].enabled;
    };
    features.hidden = function(k2) {
      if (!arguments.length) {
        return _keys.filter(function(k3) {
          return _rules[k3].hidden();
        });
      }
      return _rules[k2] && _rules[k2].hidden();
    };
    features.autoHidden = function(k2) {
      if (!arguments.length) {
        return _keys.filter(function(k3) {
          return _rules[k3].autoHidden();
        });
      }
      return _rules[k2] && _rules[k2].autoHidden();
    };
    features.enable = function(k2) {
      if (_rules[k2] && !_rules[k2].enabled) {
        _rules[k2].enable();
        update();
      }
    };
    features.enableAll = function() {
      var didEnable = false;
      for (var k2 in _rules) {
        if (!_rules[k2].enabled) {
          didEnable = true;
          _rules[k2].enable();
        }
      }
      if (didEnable)
        update();
    };
    features.disable = function(k2) {
      if (_rules[k2] && _rules[k2].enabled) {
        _rules[k2].disable();
        update();
      }
    };
    features.disableAll = function() {
      var didDisable = false;
      for (var k2 in _rules) {
        if (_rules[k2].enabled) {
          didDisable = true;
          _rules[k2].disable();
        }
      }
      if (didDisable)
        update();
    };
    features.toggle = function(k2) {
      if (_rules[k2]) {
        (function(f2) {
          return f2.enabled ? f2.disable() : f2.enable();
        })(_rules[k2]);
        update();
      }
    };
    features.resetStats = function() {
      for (var i3 = 0; i3 < _keys.length; i3++) {
        _rules[_keys[i3]].count = 0;
      }
      dispatch14.call("change");
    };
    features.gatherStats = function(d2, resolver, dimensions) {
      var needsRedraw = false;
      var types = utilArrayGroupBy(d2, "type");
      var entities = [].concat(types.relation || [], types.way || [], types.node || []);
      var currHidden, geometry, matches, i3, j2;
      for (i3 = 0; i3 < _keys.length; i3++) {
        _rules[_keys[i3]].count = 0;
      }
      _cullFactor = dimensions[0] * dimensions[1] / 1e6;
      for (i3 = 0; i3 < entities.length; i3++) {
        geometry = entities[i3].geometry(resolver);
        matches = Object.keys(features.getMatches(entities[i3], resolver, geometry));
        for (j2 = 0; j2 < matches.length; j2++) {
          _rules[matches[j2]].count++;
        }
      }
      currHidden = features.hidden();
      if (currHidden !== _hidden) {
        _hidden = currHidden;
        needsRedraw = true;
        dispatch14.call("change");
      }
      return needsRedraw;
    };
    features.stats = function() {
      for (var i3 = 0; i3 < _keys.length; i3++) {
        _stats[_keys[i3]] = _rules[_keys[i3]].count;
      }
      return _stats;
    };
    features.clear = function(d2) {
      for (var i3 = 0; i3 < d2.length; i3++) {
        features.clearEntity(d2[i3]);
      }
    };
    features.clearEntity = function(entity) {
      delete _cache5[osmEntity.key(entity)];
    };
    features.reset = function() {
      Array.from(_deferred2).forEach(function(handle) {
        window.cancelIdleCallback(handle);
        _deferred2.delete(handle);
      });
      _cache5 = {};
    };
    function relationShouldBeChecked(relation) {
      return relation.tags.type === "boundary";
    }
    features.getMatches = function(entity, resolver, geometry) {
      if (geometry === "vertex" || geometry === "relation" && !relationShouldBeChecked(entity))
        return {};
      var ent = osmEntity.key(entity);
      if (!_cache5[ent]) {
        _cache5[ent] = {};
      }
      if (!_cache5[ent].matches) {
        var matches = {};
        var hasMatch = false;
        for (var i3 = 0; i3 < _keys.length; i3++) {
          if (_keys[i3] === "others") {
            if (hasMatch)
              continue;
            if (entity.type === "way") {
              var parents = features.getParents(entity, resolver, geometry);
              if (parents.length === 1 && parents[0].isMultipolygon() || // 2b. or belongs only to boundary relations
              parents.length > 0 && parents.every(function(parent) {
                return parent.tags.type === "boundary";
              })) {
                var pkey = osmEntity.key(parents[0]);
                if (_cache5[pkey] && _cache5[pkey].matches) {
                  matches = Object.assign({}, _cache5[pkey].matches);
                  continue;
                }
              }
            }
          }
          if (_rules[_keys[i3]].filter(entity.tags, geometry)) {
            matches[_keys[i3]] = hasMatch = true;
          }
        }
        _cache5[ent].matches = matches;
      }
      return _cache5[ent].matches;
    };
    features.getParents = function(entity, resolver, geometry) {
      if (geometry === "point")
        return [];
      var ent = osmEntity.key(entity);
      if (!_cache5[ent]) {
        _cache5[ent] = {};
      }
      if (!_cache5[ent].parents) {
        var parents = [];
        if (geometry === "vertex") {
          parents = resolver.parentWays(entity);
        } else {
          parents = resolver.parentRelations(entity);
        }
        _cache5[ent].parents = parents;
      }
      return _cache5[ent].parents;
    };
    features.isHiddenPreset = function(preset, geometry) {
      if (!_hidden.length)
        return false;
      if (!preset.tags)
        return false;
      var test = preset.setTags({}, geometry);
      for (var key in _rules) {
        if (_rules[key].filter(test, geometry)) {
          if (_hidden.indexOf(key) !== -1) {
            return key;
          }
          return false;
        }
      }
      return false;
    };
    features.isHiddenFeature = function(entity, resolver, geometry) {
      if (!_hidden.length)
        return false;
      if (!entity.version)
        return false;
      if (_forceVisible[entity.id])
        return false;
      var matches = Object.keys(features.getMatches(entity, resolver, geometry));
      return matches.length && matches.every(function(k2) {
        return features.hidden(k2);
      });
    };
    features.isHiddenChild = function(entity, resolver, geometry) {
      if (!_hidden.length)
        return false;
      if (!entity.version || geometry === "point")
        return false;
      if (_forceVisible[entity.id])
        return false;
      var parents = features.getParents(entity, resolver, geometry);
      if (!parents.length)
        return false;
      for (var i3 = 0; i3 < parents.length; i3++) {
        if (!features.isHidden(parents[i3], resolver, parents[i3].geometry(resolver))) {
          return false;
        }
      }
      return true;
    };
    features.hasHiddenConnections = function(entity, resolver) {
      if (!_hidden.length)
        return false;
      var childNodes, connections;
      if (entity.type === "midpoint") {
        childNodes = [resolver.entity(entity.edge[0]), resolver.entity(entity.edge[1])];
        connections = [];
      } else {
        childNodes = entity.nodes ? resolver.childNodes(entity) : [];
        connections = features.getParents(entity, resolver, entity.geometry(resolver));
      }
      connections = childNodes.reduce(function(result, e3) {
        return resolver.isShared(e3) ? utilArrayUnion(result, resolver.parentWays(e3)) : result;
      }, connections);
      return connections.some(function(e3) {
        return features.isHidden(e3, resolver, e3.geometry(resolver));
      });
    };
    features.isHidden = function(entity, resolver, geometry) {
      if (!_hidden.length)
        return false;
      if (!entity.version)
        return false;
      var fn = geometry === "vertex" ? features.isHiddenChild : features.isHiddenFeature;
      return fn(entity, resolver, geometry);
    };
    features.filter = function(d2, resolver) {
      if (!_hidden.length)
        return d2;
      var result = [];
      for (var i3 = 0; i3 < d2.length; i3++) {
        var entity = d2[i3];
        if (!features.isHidden(entity, resolver, entity.geometry(resolver))) {
          result.push(entity);
        }
      }
      return result;
    };
    features.forceVisible = function(entityIDs) {
      if (!arguments.length)
        return Object.keys(_forceVisible);
      _forceVisible = {};
      for (var i3 = 0; i3 < entityIDs.length; i3++) {
        _forceVisible[entityIDs[i3]] = true;
        var entity = context.hasEntity(entityIDs[i3]);
        if (entity && entity.type === "relation") {
          for (var j2 in entity.members) {
            _forceVisible[entity.members[j2].id] = true;
          }
        }
      }
      return features;
    };
    features.init = function() {
      var storage = corePreferences("disabled-features");
      if (storage) {
        var storageDisabled = storage.replace(/;/g, ",").split(",");
        storageDisabled.forEach(features.disable);
      }
      var hash = utilStringQs(window.location.hash);
      if (hash.disable_features) {
        var hashDisabled = hash.disable_features.replace(/;/g, ",").split(",");
        hashDisabled.forEach(features.disable);
      }
    };
    context.history().on("merge.features", function(newEntities) {
      if (!newEntities)
        return;
      var handle = window.requestIdleCallback(function() {
        var graph = context.graph();
        var types = utilArrayGroupBy(newEntities, "type");
        var entities = [].concat(types.relation || [], types.way || [], types.node || []);
        for (var i3 = 0; i3 < entities.length; i3++) {
          var geometry = entities[i3].geometry(graph);
          features.getMatches(entities[i3], graph, geometry);
        }
      });
      _deferred2.add(handle);
    });
    return features;
  }

  // modules/svg/areas.js
  var import_fast_deep_equal5 = __toESM(require_fast_deep_equal());

  // modules/svg/helpers.js
  function svgPassiveVertex(node, graph, activeID) {
    if (!activeID)
      return 1;
    if (activeID === node.id)
      return 0;
    var parents = graph.parentWays(node);
    var i3, j2, nodes, isClosed, ix1, ix2, ix3, ix4, max3;
    for (i3 = 0; i3 < parents.length; i3++) {
      nodes = parents[i3].nodes;
      isClosed = parents[i3].isClosed();
      for (j2 = 0; j2 < nodes.length; j2++) {
        if (nodes[j2] === node.id) {
          ix1 = j2 - 2;
          ix2 = j2 - 1;
          ix3 = j2 + 1;
          ix4 = j2 + 2;
          if (isClosed) {
            max3 = nodes.length - 1;
            if (ix1 < 0)
              ix1 = max3 + ix1;
            if (ix2 < 0)
              ix2 = max3 + ix2;
            if (ix3 > max3)
              ix3 = ix3 - max3;
            if (ix4 > max3)
              ix4 = ix4 - max3;
          }
          if (nodes[ix1] === activeID)
            return 0;
          else if (nodes[ix2] === activeID)
            return 2;
          else if (nodes[ix3] === activeID)
            return 2;
          else if (nodes[ix4] === activeID)
            return 0;
          else if (isClosed && nodes.indexOf(activeID) !== -1)
            return 0;
        }
      }
    }
    return 1;
  }
  function svgMarkerSegments(projection2, graph, dt2, shouldReverse, bothDirections) {
    return function(entity) {
      var i3 = 0;
      var offset = dt2;
      var segments = [];
      var clip = identity_default2().clipExtent(projection2.clipExtent()).stream;
      var coordinates = graph.childNodes(entity).map(function(n3) {
        return n3.loc;
      });
      var a2, b2;
      if (shouldReverse(entity)) {
        coordinates.reverse();
      }
      stream_default({
        type: "LineString",
        coordinates
      }, projection2.stream(clip({
        lineStart: function() {
        },
        lineEnd: function() {
          a2 = null;
        },
        point: function(x2, y2) {
          b2 = [x2, y2];
          if (a2) {
            var span = geoVecLength(a2, b2) - offset;
            if (span >= 0) {
              var heading2 = geoVecAngle(a2, b2);
              var dx = dt2 * Math.cos(heading2);
              var dy = dt2 * Math.sin(heading2);
              var p2 = [
                a2[0] + offset * Math.cos(heading2),
                a2[1] + offset * Math.sin(heading2)
              ];
              var coord2 = [a2, p2];
              for (span -= dt2; span >= 0; span -= dt2) {
                p2 = geoVecAdd(p2, [dx, dy]);
                coord2.push(p2);
              }
              coord2.push(b2);
              var segment = "";
              var j2;
              for (j2 = 0; j2 < coord2.length; j2++) {
                segment += (j2 === 0 ? "M" : "L") + coord2[j2][0] + "," + coord2[j2][1];
              }
              segments.push({ id: entity.id, index: i3++, d: segment });
              if (bothDirections(entity)) {
                segment = "";
                for (j2 = coord2.length - 1; j2 >= 0; j2--) {
                  segment += (j2 === coord2.length - 1 ? "M" : "L") + coord2[j2][0] + "," + coord2[j2][1];
                }
                segments.push({ id: entity.id, index: i3++, d: segment });
              }
            }
            offset = -span;
          }
          a2 = b2;
        }
      })));
      return segments;
    };
  }
  function svgPath(projection2, graph, isArea) {
    var cache = {};
    var padding = isArea ? 65 : 5;
    var viewport = projection2.clipExtent();
    var paddedExtent = [
      [viewport[0][0] - padding, viewport[0][1] - padding],
      [viewport[1][0] + padding, viewport[1][1] + padding]
    ];
    var clip = identity_default2().clipExtent(paddedExtent).stream;
    var project = projection2.stream;
    var path = path_default().projection({ stream: function(output) {
      return project(clip(output));
    } });
    var svgpath = function(entity) {
      if (entity.id in cache) {
        return cache[entity.id];
      } else {
        return cache[entity.id] = path(entity.asGeoJSON(graph));
      }
    };
    svgpath.geojson = function(d2) {
      if (d2.__featurehash__ !== void 0) {
        if (d2.__featurehash__ in cache) {
          return cache[d2.__featurehash__];
        } else {
          return cache[d2.__featurehash__] = path(d2);
        }
      } else {
        return path(d2);
      }
    };
    return svgpath;
  }
  function svgPointTransform(projection2) {
    var svgpoint = function(entity) {
      var pt2 = projection2(entity.loc);
      return "translate(" + pt2[0] + "," + pt2[1] + ")";
    };
    svgpoint.geojson = function(d2) {
      return svgpoint(d2.properties.entity);
    };
    return svgpoint;
  }
  function svgRelationMemberTags(graph) {
    return function(entity) {
      var tags = entity.tags;
      var shouldCopyMultipolygonTags = !entity.hasInterestingTags();
      graph.parentRelations(entity).forEach(function(relation) {
        var type2 = relation.tags.type;
        if (type2 === "multipolygon" && shouldCopyMultipolygonTags || type2 === "boundary") {
          tags = Object.assign({}, relation.tags, tags);
        }
      });
      return tags;
    };
  }
  function svgSegmentWay(way, graph, activeID) {
    if (activeID === void 0) {
      return graph.transient(way, "waySegments", getWaySegments);
    } else {
      return getWaySegments();
    }
    function getWaySegments() {
      var isActiveWay = way.nodes.indexOf(activeID) !== -1;
      var features = { passive: [], active: [] };
      var start2 = {};
      var end = {};
      var node, type2;
      for (var i3 = 0; i3 < way.nodes.length; i3++) {
        node = graph.entity(way.nodes[i3]);
        type2 = svgPassiveVertex(node, graph, activeID);
        end = { node, type: type2 };
        if (start2.type !== void 0) {
          if (start2.node.id === activeID || end.node.id === activeID) {
          } else if (isActiveWay && (start2.type === 2 || end.type === 2)) {
            pushActive(start2, end, i3);
          } else if (start2.type === 0 && end.type === 0) {
            pushActive(start2, end, i3);
          } else {
            pushPassive(start2, end, i3);
          }
        }
        start2 = end;
      }
      return features;
      function pushActive(start3, end2, index) {
        features.active.push({
          type: "Feature",
          id: way.id + "-" + index + "-nope",
          properties: {
            nope: true,
            target: true,
            entity: way,
            nodes: [start3.node, end2.node],
            index
          },
          geometry: {
            type: "LineString",
            coordinates: [start3.node.loc, end2.node.loc]
          }
        });
      }
      function pushPassive(start3, end2, index) {
        features.passive.push({
          type: "Feature",
          id: way.id + "-" + index,
          properties: {
            target: true,
            entity: way,
            nodes: [start3.node, end2.node],
            index
          },
          geometry: {
            type: "LineString",
            coordinates: [start3.node.loc, end2.node.loc]
          }
        });
      }
    }
  }

  // modules/svg/tag_classes.js
  function svgTagClasses() {
    var primaries = [
      "building",
      "highway",
      "railway",
      "waterway",
      "aeroway",
      "aerialway",
      "piste:type",
      "boundary",
      "power",
      "amenity",
      "natural",
      "landuse",
      "leisure",
      "military",
      "place",
      "man_made",
      "route",
      "attraction",
      "roller_coaster",
      "building:part",
      "indoor"
    ];
    var statuses = Object.keys(osmLifecyclePrefixes);
    var secondaries = [
      "oneway",
      "bridge",
      "tunnel",
      "embankment",
      "cutting",
      "barrier",
      "surface",
      "tracktype",
      "footway",
      "crossing",
      "service",
      "sport",
      "public_transport",
      "location",
      "parking",
      "golf",
      "type",
      "leisure",
      "man_made",
      "indoor",
      "construction",
      "proposed"
    ];
    var _tags = function(entity) {
      return entity.tags;
    };
    var tagClasses = function(selection2) {
      selection2.each(function tagClassesEach(entity) {
        var value = this.className;
        if (value.baseVal !== void 0) {
          value = value.baseVal;
        }
        var t2 = _tags(entity);
        var computed = tagClasses.getClassesString(t2, value);
        if (computed !== value) {
          select_default2(this).attr("class", computed);
        }
      });
    };
    tagClasses.getClassesString = function(t2, value) {
      var primary, status;
      var i3, j2, k2, v2;
      var overrideGeometry;
      if (/\bstroke\b/.test(value)) {
        if (!!t2.barrier && t2.barrier !== "no") {
          overrideGeometry = "line";
        }
      }
      var classes = value.trim().split(/\s+/).filter(function(klass) {
        return klass.length && !/^tag-/.test(klass);
      }).map(function(klass) {
        return klass === "line" || klass === "area" ? overrideGeometry || klass : klass;
      });
      for (i3 = 0; i3 < primaries.length; i3++) {
        k2 = primaries[i3];
        v2 = t2[k2];
        if (!v2 || v2 === "no")
          continue;
        if (k2 === "piste:type") {
          k2 = "piste";
        } else if (k2 === "building:part") {
          k2 = "building_part";
        }
        primary = k2;
        if (statuses.indexOf(v2) !== -1) {
          status = v2;
          classes.push("tag-" + k2);
        } else {
          classes.push("tag-" + k2);
          classes.push("tag-" + k2 + "-" + v2);
        }
        break;
      }
      if (!primary) {
        for (i3 = 0; i3 < statuses.length; i3++) {
          for (j2 = 0; j2 < primaries.length; j2++) {
            k2 = statuses[i3] + ":" + primaries[j2];
            v2 = t2[k2];
            if (!v2 || v2 === "no")
              continue;
            status = statuses[i3];
            break;
          }
        }
      }
      if (!status) {
        for (i3 = 0; i3 < statuses.length; i3++) {
          k2 = statuses[i3];
          v2 = t2[k2];
          if (!v2 || v2 === "no")
            continue;
          if (v2 === "yes") {
            status = k2;
          } else if (primary && primary === v2) {
            status = k2;
          } else if (!primary && primaries.indexOf(v2) !== -1) {
            status = k2;
            primary = v2;
            classes.push("tag-" + v2);
          }
          if (status)
            break;
        }
      }
      if (status) {
        classes.push("tag-status");
        classes.push("tag-status-" + status);
      }
      for (i3 = 0; i3 < secondaries.length; i3++) {
        k2 = secondaries[i3];
        v2 = t2[k2];
        if (!v2 || v2 === "no" || k2 === primary)
          continue;
        classes.push("tag-" + k2);
        classes.push("tag-" + k2 + "-" + v2);
      }
      if (primary === "highway" && !osmPathHighwayTagValues[t2.highway] || primary === "aeroway") {
        var surface = t2.highway === "track" ? "unpaved" : "paved";
        for (k2 in t2) {
          v2 = t2[k2];
          if (k2 in osmPavedTags) {
            surface = osmPavedTags[k2][v2] ? "paved" : "unpaved";
          }
          if (k2 in osmSemipavedTags && !!osmSemipavedTags[k2][v2]) {
            surface = "semipaved";
          }
        }
        classes.push("tag-" + surface);
      }
      var qid = t2.wikidata || t2["flag:wikidata"] || t2["brand:wikidata"] || t2["network:wikidata"] || t2["operator:wikidata"];
      if (qid) {
        classes.push("tag-wikidata");
      }
      return classes.filter((klass) => /^[-_a-z0-9]+$/.test(klass)).join(" ").trim();
    };
    tagClasses.tags = function(val) {
      if (!arguments.length)
        return _tags;
      _tags = val;
      return tagClasses;
    };
    return tagClasses;
  }

  // modules/svg/tag_pattern.js
  var patterns = {
    // tag - pattern name
    // -or-
    // tag - value - pattern name
    // -or-
    // tag - value - rules (optional tag-values, pattern name)
    // (matches earlier rules first, so fallback should be last entry)
    amenity: {
      grave_yard: "cemetery",
      fountain: "water_standing"
    },
    landuse: {
      cemetery: [
        { religion: "christian", pattern: "cemetery_christian" },
        { religion: "buddhist", pattern: "cemetery_buddhist" },
        { religion: "muslim", pattern: "cemetery_muslim" },
        { religion: "jewish", pattern: "cemetery_jewish" },
        { pattern: "cemetery" }
      ],
      construction: "construction",
      farmland: "farmland",
      farmyard: "farmyard",
      forest: [
        { leaf_type: "broadleaved", pattern: "forest_broadleaved" },
        { leaf_type: "needleleaved", pattern: "forest_needleleaved" },
        { leaf_type: "leafless", pattern: "forest_leafless" },
        { pattern: "forest" }
        // same as 'leaf_type:mixed'
      ],
      grave_yard: "cemetery",
      grass: "grass",
      landfill: "landfill",
      meadow: "meadow",
      military: "construction",
      orchard: "orchard",
      quarry: "quarry",
      vineyard: "vineyard"
    },
    leisure: {
      horse_riding: "farmyard"
    },
    natural: {
      beach: "beach",
      grassland: "grass",
      sand: "beach",
      scrub: "scrub",
      water: [
        { water: "pond", pattern: "pond" },
        { water: "reservoir", pattern: "water_standing" },
        { pattern: "waves" }
      ],
      wetland: [
        { wetland: "marsh", pattern: "wetland_marsh" },
        { wetland: "swamp", pattern: "wetland_swamp" },
        { wetland: "bog", pattern: "wetland_bog" },
        { wetland: "reedbed", pattern: "wetland_reedbed" },
        { pattern: "wetland" }
      ],
      wood: [
        { leaf_type: "broadleaved", pattern: "forest_broadleaved" },
        { leaf_type: "needleleaved", pattern: "forest_needleleaved" },
        { leaf_type: "leafless", pattern: "forest_leafless" },
        { pattern: "forest" }
        // same as 'leaf_type:mixed'
      ]
    },
    golf: {
      green: "golf_green",
      tee: "grass",
      fairway: "grass",
      rough: "scrub"
    },
    surface: {
      grass: "grass",
      sand: "beach"
    }
  };
  function svgTagPattern(tags) {
    if (tags.building && tags.building !== "no") {
      return null;
    }
    for (var tag2 in patterns) {
      var entityValue = tags[tag2];
      if (!entityValue)
        continue;
      if (typeof patterns[tag2] === "string") {
        return "pattern-" + patterns[tag2];
      } else {
        var values = patterns[tag2];
        for (var value in values) {
          if (entityValue !== value)
            continue;
          var rules = values[value];
          if (typeof rules === "string") {
            return "pattern-" + rules;
          }
          for (var ruleKey in rules) {
            var rule = rules[ruleKey];
            var pass = true;
            for (var criterion in rule) {
              if (criterion !== "pattern") {
                var v2 = tags[criterion];
                if (!v2 || v2 !== rule[criterion]) {
                  pass = false;
                  break;
                }
              }
            }
            if (pass) {
              return "pattern-" + rule.pattern;
            }
          }
        }
      }
    }
    return null;
  }

  // modules/svg/areas.js
  function svgAreas(projection2, context) {
    function getPatternStyle(tags) {
      var imageID = svgTagPattern(tags);
      if (imageID) {
        return 'url("#ideditor-' + imageID + '")';
      }
      return "";
    }
    function drawTargets(selection2, graph, entities, filter2) {
      var targetClass = context.getDebug("target") ? "pink " : "nocolor ";
      var nopeClass = context.getDebug("target") ? "red " : "nocolor ";
      var getPath = svgPath(projection2).geojson;
      var activeID = context.activeID();
      var base = context.history().base();
      var data = { targets: [], nopes: [] };
      entities.forEach(function(way) {
        var features = svgSegmentWay(way, graph, activeID);
        data.targets.push.apply(data.targets, features.passive);
        data.nopes.push.apply(data.nopes, features.active);
      });
      var targetData = data.targets.filter(getPath);
      var targets = selection2.selectAll(".area.target-allowed").filter(function(d2) {
        return filter2(d2.properties.entity);
      }).data(targetData, function key(d2) {
        return d2.id;
      });
      targets.exit().remove();
      var segmentWasEdited = function(d2) {
        var wayID = d2.properties.entity.id;
        if (!base.entities[wayID] || !(0, import_fast_deep_equal5.default)(graph.entities[wayID].nodes, base.entities[wayID].nodes)) {
          return false;
        }
        return d2.properties.nodes.some(function(n3) {
          return !base.entities[n3.id] || !(0, import_fast_deep_equal5.default)(graph.entities[n3.id].loc, base.entities[n3.id].loc);
        });
      };
      targets.enter().append("path").merge(targets).attr("d", getPath).attr("class", function(d2) {
        return "way area target target-allowed " + targetClass + d2.id;
      }).classed("segment-edited", segmentWasEdited);
      var nopeData = data.nopes.filter(getPath);
      var nopes = selection2.selectAll(".area.target-nope").filter(function(d2) {
        return filter2(d2.properties.entity);
      }).data(nopeData, function key(d2) {
        return d2.id;
      });
      nopes.exit().remove();
      nopes.enter().append("path").merge(nopes).attr("d", getPath).attr("class", function(d2) {
        return "way area target target-nope " + nopeClass + d2.id;
      }).classed("segment-edited", segmentWasEdited);
    }
    function drawAreas(selection2, graph, entities, filter2) {
      var path = svgPath(projection2, graph, true);
      var areas = {};
      var base = context.history().base();
      for (var i3 = 0; i3 < entities.length; i3++) {
        var entity = entities[i3];
        if (entity.geometry(graph) !== "area")
          continue;
        if (!areas[entity.id]) {
          areas[entity.id] = {
            entity,
            area: Math.abs(entity.area(graph))
          };
        }
      }
      var fills = Object.values(areas).filter(function hasPath(a2) {
        return path(a2.entity);
      });
      fills.sort(function areaSort(a2, b2) {
        return b2.area - a2.area;
      });
      fills = fills.map(function(a2) {
        return a2.entity;
      });
      var strokes = fills.filter(function(area) {
        return area.type === "way";
      });
      var data = {
        clip: fills,
        shadow: strokes,
        stroke: strokes,
        fill: fills
      };
      var clipPaths = context.surface().selectAll("defs").selectAll(".clipPath-osm").filter(filter2).data(data.clip, osmEntity.key);
      clipPaths.exit().remove();
      var clipPathsEnter = clipPaths.enter().append("clipPath").attr("class", "clipPath-osm").attr("id", function(entity2) {
        return "ideditor-" + entity2.id + "-clippath";
      });
      clipPathsEnter.append("path");
      clipPaths.merge(clipPathsEnter).selectAll("path").attr("d", path);
      var drawLayer = selection2.selectAll(".layer-osm.areas");
      var touchLayer = selection2.selectAll(".layer-touch.areas");
      var areagroup = drawLayer.selectAll("g.areagroup").data(["fill", "shadow", "stroke"]);
      areagroup = areagroup.enter().append("g").attr("class", function(d2) {
        return "areagroup area-" + d2;
      }).merge(areagroup);
      var paths = areagroup.selectAll("path").filter(filter2).data(function(layer) {
        return data[layer];
      }, osmEntity.key);
      paths.exit().remove();
      var fillpaths = selection2.selectAll(".area-fill path.area").nodes();
      var bisect = bisector(function(node) {
        return -node.__data__.area(graph);
      }).left;
      function sortedByArea(entity2) {
        if (this._parent.__data__ === "fill") {
          return fillpaths[bisect(fillpaths, -entity2.area(graph))];
        }
      }
      paths = paths.enter().insert("path", sortedByArea).merge(paths).each(function(entity2) {
        var layer = this.parentNode.__data__;
        this.setAttribute("class", entity2.type + " area " + layer + " " + entity2.id);
        if (layer === "fill") {
          this.setAttribute("clip-path", "url(#ideditor-" + entity2.id + "-clippath)");
          this.style.fill = this.style.stroke = getPatternStyle(entity2.tags);
        }
      }).classed("added", function(d2) {
        return !base.entities[d2.id];
      }).classed("geometry-edited", function(d2) {
        return graph.entities[d2.id] && base.entities[d2.id] && !(0, import_fast_deep_equal5.default)(graph.entities[d2.id].nodes, base.entities[d2.id].nodes);
      }).classed("retagged", function(d2) {
        return graph.entities[d2.id] && base.entities[d2.id] && !(0, import_fast_deep_equal5.default)(graph.entities[d2.id].tags, base.entities[d2.id].tags);
      }).call(svgTagClasses()).attr("d", path);
      touchLayer.call(drawTargets, graph, data.stroke, filter2);
    }
    return drawAreas;
  }

  // modules/svg/data.js
  var import_fast_json_stable_stringify = __toESM(require_fast_json_stable_stringify());

  // node_modules/@tmcw/togeojson/dist/togeojson.es.mjs
  function $(element, tagName) {
    return Array.from(element.getElementsByTagName(tagName));
  }
  function normalizeId(id2) {
    return id2[0] === "#" ? id2 : "#".concat(id2);
  }
  function $ns(element, tagName, ns) {
    return Array.from(element.getElementsByTagNameNS(ns, tagName));
  }
  function nodeVal(node) {
    node == null ? void 0 : node.normalize();
    return node && node.textContent || "";
  }
  function get1(node, tagName, callback) {
    const n3 = node.getElementsByTagName(tagName);
    const result = n3.length ? n3[0] : null;
    if (result && callback)
      callback(result);
    return result;
  }
  function get3(node, tagName, callback) {
    const properties = {};
    if (!node)
      return properties;
    const n3 = node.getElementsByTagName(tagName);
    const result = n3.length ? n3[0] : null;
    if (result && callback) {
      return callback(result, properties);
    }
    return properties;
  }
  function val1(node, tagName, callback) {
    const val = nodeVal(get1(node, tagName));
    if (val && callback)
      return callback(val) || {};
    return {};
  }
  function $num(node, tagName, callback) {
    const val = parseFloat(nodeVal(get1(node, tagName)));
    if (isNaN(val))
      return void 0;
    if (val && callback)
      return callback(val) || {};
    return {};
  }
  function num1(node, tagName, callback) {
    const val = parseFloat(nodeVal(get1(node, tagName)));
    if (isNaN(val))
      return void 0;
    if (callback)
      callback(val);
    return val;
  }
  function getMulti(node, propertyNames) {
    const properties = {};
    for (const property of propertyNames) {
      val1(node, property, (val) => {
        properties[property] = val;
      });
    }
    return properties;
  }
  function isElement(node) {
    return (node == null ? void 0 : node.nodeType) === 1;
  }
  function getLineStyle(node) {
    return get3(node, "line", (lineStyle) => {
      const val = Object.assign({}, val1(lineStyle, "color", (color2) => {
        return { stroke: "#".concat(color2) };
      }), $num(lineStyle, "opacity", (opacity) => {
        return { "stroke-opacity": opacity };
      }), $num(lineStyle, "width", (width) => {
        return { "stroke-width": width * 96 / 25.4 };
      }));
      return val;
    });
  }
  function getExtensions(node) {
    let values = [];
    if (node === null)
      return values;
    for (const child of Array.from(node.childNodes)) {
      if (!isElement(child))
        continue;
      const name = abbreviateName(child.nodeName);
      if (name === "gpxtpx:TrackPointExtension") {
        values = values.concat(getExtensions(child));
      } else {
        const val = nodeVal(child);
        values.push([name, parseNumeric(val)]);
      }
    }
    return values;
  }
  function abbreviateName(name) {
    return ["heart", "gpxtpx:hr", "hr"].includes(name) ? "heart" : name;
  }
  function parseNumeric(val) {
    const num = parseFloat(val);
    return isNaN(num) ? val : num;
  }
  function coordPair$1(node) {
    const ll = [
      parseFloat(node.getAttribute("lon") || ""),
      parseFloat(node.getAttribute("lat") || "")
    ];
    if (isNaN(ll[0]) || isNaN(ll[1])) {
      return null;
    }
    num1(node, "ele", (val) => {
      ll.push(val);
    });
    const time = get1(node, "time");
    return {
      coordinates: ll,
      time: time ? nodeVal(time) : null,
      extendedValues: getExtensions(get1(node, "extensions"))
    };
  }
  function extractProperties(node) {
    var _a2;
    const properties = getMulti(node, [
      "name",
      "cmt",
      "desc",
      "type",
      "time",
      "keywords"
    ]);
    const extensions = Array.from(node.getElementsByTagNameNS("http://www.garmin.com/xmlschemas/GpxExtensions/v3", "*"));
    for (const child of extensions) {
      if (((_a2 = child.parentNode) == null ? void 0 : _a2.parentNode) === node) {
        properties[child.tagName.replace(":", "_")] = nodeVal(child);
      }
    }
    const links = $(node, "link");
    if (links.length) {
      properties.links = links.map((link3) => Object.assign({ href: link3.getAttribute("href") }, getMulti(link3, ["text", "type"])));
    }
    return properties;
  }
  function getPoints$1(node, pointname) {
    const pts = $(node, pointname);
    const line = [];
    const times = [];
    const extendedValues = {};
    for (let i3 = 0; i3 < pts.length; i3++) {
      const c2 = coordPair$1(pts[i3]);
      if (!c2) {
        continue;
      }
      line.push(c2.coordinates);
      if (c2.time)
        times.push(c2.time);
      for (const [name, val] of c2.extendedValues) {
        const plural = name === "heart" ? name : name.replace("gpxtpx:", "") + "s";
        if (!extendedValues[plural]) {
          extendedValues[plural] = Array(pts.length).fill(null);
        }
        extendedValues[plural][i3] = val;
      }
    }
    if (line.length < 2)
      return;
    return {
      line,
      times,
      extendedValues
    };
  }
  function getRoute(node) {
    const line = getPoints$1(node, "rtept");
    if (!line)
      return;
    return {
      type: "Feature",
      properties: Object.assign({ _gpxType: "rte" }, extractProperties(node), getLineStyle(get1(node, "extensions"))),
      geometry: {
        type: "LineString",
        coordinates: line.line
      }
    };
  }
  function getTrack(node) {
    const segments = $(node, "trkseg");
    const track = [];
    const times = [];
    const extractedLines = [];
    for (const segment of segments) {
      const line = getPoints$1(segment, "trkpt");
      if (line) {
        extractedLines.push(line);
        if (line.times && line.times.length)
          times.push(line.times);
      }
    }
    if (extractedLines.length === 0)
      return null;
    const multi = extractedLines.length > 1;
    const properties = Object.assign({ _gpxType: "trk" }, extractProperties(node), getLineStyle(get1(node, "extensions")), times.length ? {
      coordinateProperties: {
        times: multi ? times : times[0]
      }
    } : {});
    for (const line of extractedLines) {
      track.push(line.line);
      if (!properties.coordinateProperties) {
        properties.coordinateProperties = {};
      }
      const props = properties.coordinateProperties;
      const entries = Object.entries(line.extendedValues);
      for (let i3 = 0; i3 < entries.length; i3++) {
        const [name, val] = entries[i3];
        if (multi) {
          if (!props[name]) {
            props[name] = extractedLines.map((line2) => new Array(line2.line.length).fill(null));
          }
          props[name][i3] = val;
        } else {
          props[name] = val;
        }
      }
    }
    return {
      type: "Feature",
      properties,
      geometry: multi ? {
        type: "MultiLineString",
        coordinates: track
      } : {
        type: "LineString",
        coordinates: track[0]
      }
    };
  }
  function getPoint(node) {
    const properties = Object.assign(extractProperties(node), getMulti(node, ["sym"]));
    const pair3 = coordPair$1(node);
    if (!pair3)
      return null;
    return {
      type: "Feature",
      properties,
      geometry: {
        type: "Point",
        coordinates: pair3.coordinates
      }
    };
  }
  function* gpxGen(node) {
    for (const track of $(node, "trk")) {
      const feature3 = getTrack(track);
      if (feature3)
        yield feature3;
    }
    for (const route of $(node, "rte")) {
      const feature3 = getRoute(route);
      if (feature3)
        yield feature3;
    }
    for (const waypoint of $(node, "wpt")) {
      const point2 = getPoint(waypoint);
      if (point2)
        yield point2;
    }
  }
  function gpx(node) {
    return {
      type: "FeatureCollection",
      features: Array.from(gpxGen(node))
    };
  }
  function fixColor(v2, prefix) {
    const properties = {};
    const colorProp = prefix == "stroke" || prefix === "fill" ? prefix : prefix + "-color";
    if (v2[0] === "#") {
      v2 = v2.substring(1);
    }
    if (v2.length === 6 || v2.length === 3) {
      properties[colorProp] = "#" + v2;
    } else if (v2.length === 8) {
      properties[prefix + "-opacity"] = parseInt(v2.substring(0, 2), 16) / 255;
      properties[colorProp] = "#" + v2.substring(6, 8) + v2.substring(4, 6) + v2.substring(2, 4);
    }
    return properties;
  }
  function numericProperty(node, source, target) {
    const properties = {};
    num1(node, source, (val) => {
      properties[target] = val;
    });
    return properties;
  }
  function getColor(node, output) {
    return get3(node, "color", (elem) => fixColor(nodeVal(elem), output));
  }
  function extractIconHref(node) {
    return get3(node, "Icon", (icon2, properties) => {
      val1(icon2, "href", (href) => {
        properties.icon = href;
      });
      return properties;
    });
  }
  function extractIcon(node) {
    return get3(node, "IconStyle", (iconStyle) => {
      return Object.assign(getColor(iconStyle, "icon"), numericProperty(iconStyle, "scale", "icon-scale"), numericProperty(iconStyle, "heading", "icon-heading"), get3(iconStyle, "hotSpot", (hotspot) => {
        const left = parseFloat(hotspot.getAttribute("x") || "");
        const top = parseFloat(hotspot.getAttribute("y") || "");
        const xunits = hotspot.getAttribute("xunits") || "";
        const yunits = hotspot.getAttribute("yunits") || "";
        if (!isNaN(left) && !isNaN(top))
          return {
            "icon-offset": [left, top],
            "icon-offset-units": [xunits, yunits]
          };
        return {};
      }), extractIconHref(iconStyle));
    });
  }
  function extractLabel(node) {
    return get3(node, "LabelStyle", (labelStyle) => {
      return Object.assign(getColor(labelStyle, "label"), numericProperty(labelStyle, "scale", "label-scale"));
    });
  }
  function extractLine(node) {
    return get3(node, "LineStyle", (lineStyle) => {
      return Object.assign(getColor(lineStyle, "stroke"), numericProperty(lineStyle, "width", "stroke-width"));
    });
  }
  function extractPoly(node) {
    return get3(node, "PolyStyle", (polyStyle, properties) => {
      return Object.assign(properties, get3(polyStyle, "color", (elem) => fixColor(nodeVal(elem), "fill")), val1(polyStyle, "fill", (fill) => {
        if (fill === "0")
          return { "fill-opacity": 0 };
      }), val1(polyStyle, "outline", (outline) => {
        if (outline === "0")
          return { "stroke-opacity": 0 };
      }));
    });
  }
  function extractStyle(node) {
    return Object.assign({}, extractPoly(node), extractLine(node), extractLabel(node), extractIcon(node));
  }
  var toNumber2 = (x2) => Number(x2);
  var typeConverters = {
    string: (x2) => x2,
    int: toNumber2,
    uint: toNumber2,
    short: toNumber2,
    ushort: toNumber2,
    float: toNumber2,
    double: toNumber2,
    bool: (x2) => Boolean(x2)
  };
  function extractExtendedData(node, schema) {
    return get3(node, "ExtendedData", (extendedData, properties) => {
      for (const data of $(extendedData, "Data")) {
        properties[data.getAttribute("name") || ""] = nodeVal(get1(data, "value"));
      }
      for (const simpleData of $(extendedData, "SimpleData")) {
        const name = simpleData.getAttribute("name") || "";
        const typeConverter = schema[name] || typeConverters.string;
        properties[name] = typeConverter(nodeVal(simpleData));
      }
      return properties;
    });
  }
  function getMaybeHTMLDescription(node) {
    const descriptionNode = get1(node, "description");
    for (const c2 of Array.from((descriptionNode == null ? void 0 : descriptionNode.childNodes) || [])) {
      if (c2.nodeType === 4) {
        return {
          description: {
            "@type": "html",
            value: nodeVal(c2)
          }
        };
      }
    }
    return {};
  }
  function extractTimeSpan(node) {
    return get3(node, "TimeSpan", (timeSpan) => {
      return {
        timespan: {
          begin: nodeVal(get1(timeSpan, "begin")),
          end: nodeVal(get1(timeSpan, "end"))
        }
      };
    });
  }
  function extractTimeStamp(node) {
    return get3(node, "TimeStamp", (timeStamp) => {
      return { timestamp: nodeVal(get1(timeStamp, "when")) };
    });
  }
  function extractCascadedStyle(node, styleMap) {
    return val1(node, "styleUrl", (styleUrl) => {
      styleUrl = normalizeId(styleUrl);
      if (styleMap[styleUrl]) {
        return Object.assign({ styleUrl }, styleMap[styleUrl]);
      }
      return { styleUrl };
    });
  }
  var removeSpace = /\s*/g;
  var trimSpace = /^\s*|\s*$/g;
  var splitSpace = /\s+/;
  function coord1(value) {
    return value.replace(removeSpace, "").split(",").map(parseFloat).filter((num) => !isNaN(num)).slice(0, 3);
  }
  function coord(value) {
    return value.replace(trimSpace, "").split(splitSpace).map(coord1).filter((coord2) => {
      return coord2.length >= 2;
    });
  }
  function gxCoords(node) {
    let elems = $(node, "coord");
    if (elems.length === 0) {
      elems = $ns(node, "coord", "*");
    }
    const coordinates = elems.map((elem) => {
      return nodeVal(elem).split(" ").map(parseFloat);
    });
    if (coordinates.length === 0) {
      return null;
    }
    return {
      geometry: coordinates.length > 2 ? {
        type: "LineString",
        coordinates
      } : {
        type: "Point",
        coordinates: coordinates[0]
      },
      times: $(node, "when").map((elem) => nodeVal(elem))
    };
  }
  function fixRing(ring) {
    if (ring.length === 0)
      return ring;
    const first = ring[0];
    const last = ring[ring.length - 1];
    let equal = true;
    for (let i3 = 0; i3 < Math.max(first.length, last.length); i3++) {
      if (first[i3] !== last[i3]) {
        equal = false;
        break;
      }
    }
    if (!equal) {
      return ring.concat([ring[0]]);
    }
    return ring;
  }
  function getCoordinates(node) {
    return nodeVal(get1(node, "coordinates"));
  }
  function getGeometry(node) {
    let geometries = [];
    let coordTimes = [];
    for (let i3 = 0; i3 < node.childNodes.length; i3++) {
      const child = node.childNodes.item(i3);
      if (isElement(child)) {
        switch (child.tagName) {
          case "MultiGeometry":
          case "MultiTrack":
          case "gx:MultiTrack": {
            const childGeometries = getGeometry(child);
            geometries = geometries.concat(childGeometries.geometries);
            coordTimes = coordTimes.concat(childGeometries.coordTimes);
            break;
          }
          case "Point": {
            const coordinates = coord1(getCoordinates(child));
            if (coordinates.length >= 2) {
              geometries.push({
                type: "Point",
                coordinates
              });
            }
            break;
          }
          case "LinearRing":
          case "LineString": {
            const coordinates = coord(getCoordinates(child));
            if (coordinates.length >= 2) {
              geometries.push({
                type: "LineString",
                coordinates
              });
            }
            break;
          }
          case "Polygon": {
            const coords = [];
            for (const linearRing of $(child, "LinearRing")) {
              const ring = fixRing(coord(getCoordinates(linearRing)));
              if (ring.length >= 4) {
                coords.push(ring);
              }
            }
            if (coords.length) {
              geometries.push({
                type: "Polygon",
                coordinates: coords
              });
            }
            break;
          }
          case "Track":
          case "gx:Track": {
            const gx = gxCoords(child);
            if (!gx)
              break;
            const { times, geometry } = gx;
            geometries.push(geometry);
            if (times.length)
              coordTimes.push(times);
            break;
          }
        }
      }
    }
    return {
      geometries,
      coordTimes
    };
  }
  function geometryListToGeometry(geometries) {
    return geometries.length === 0 ? null : geometries.length === 1 ? geometries[0] : {
      type: "GeometryCollection",
      geometries
    };
  }
  function getPlacemark(node, styleMap, schema, options2) {
    var _a2;
    const { coordTimes, geometries } = getGeometry(node);
    const geometry = geometryListToGeometry(geometries);
    if (!geometry && options2.skipNullGeometry) {
      return null;
    }
    const feature3 = {
      type: "Feature",
      geometry,
      properties: Object.assign(getMulti(node, [
        "name",
        "address",
        "visibility",
        "open",
        "phoneNumber",
        "description"
      ]), getMaybeHTMLDescription(node), extractCascadedStyle(node, styleMap), extractStyle(node), extractExtendedData(node, schema), extractTimeSpan(node), extractTimeStamp(node), coordTimes.length ? {
        coordinateProperties: {
          times: coordTimes.length === 1 ? coordTimes[0] : coordTimes
        }
      } : {})
    };
    if (((_a2 = feature3.properties) == null ? void 0 : _a2.visibility) !== void 0) {
      feature3.properties.visibility = feature3.properties.visibility !== "0";
    }
    const id2 = node.getAttribute("id");
    if (id2 !== null && id2 !== "")
      feature3.id = id2;
    return feature3;
  }
  function getGroundOverlayBox(node) {
    const latLonQuad = get1(node, "gx:LatLonQuad");
    if (latLonQuad) {
      const ring = fixRing(coord(getCoordinates(node)));
      return {
        geometry: {
          type: "Polygon",
          coordinates: [ring]
        }
      };
    }
    return getLatLonBox(node);
  }
  var DEGREES_TO_RADIANS = Math.PI / 180;
  function rotateBox(bbox2, coordinates, rotation) {
    const center = [(bbox2[0] + bbox2[2]) / 2, (bbox2[1] + bbox2[3]) / 2];
    return [
      coordinates[0].map((coordinate) => {
        const dy = coordinate[1] - center[1];
        const dx = coordinate[0] - center[0];
        const distance = Math.sqrt(Math.pow(dy, 2) + Math.pow(dx, 2));
        const angle2 = Math.atan2(dy, dx) + rotation * DEGREES_TO_RADIANS;
        return [
          center[0] + Math.cos(angle2) * distance,
          center[1] + Math.sin(angle2) * distance
        ];
      })
    ];
  }
  function getLatLonBox(node) {
    const latLonBox = get1(node, "LatLonBox");
    if (latLonBox) {
      const north = num1(latLonBox, "north");
      const west = num1(latLonBox, "west");
      const east = num1(latLonBox, "east");
      const south = num1(latLonBox, "south");
      const rotation = num1(latLonBox, "rotation");
      if (typeof north === "number" && typeof south === "number" && typeof west === "number" && typeof east === "number") {
        const bbox2 = [west, south, east, north];
        let coordinates = [
          [
            [west, north],
            [east, north],
            [east, south],
            [west, south],
            [west, north]
            // top left (again)
          ]
        ];
        if (typeof rotation === "number") {
          coordinates = rotateBox(bbox2, coordinates, rotation);
        }
        return {
          bbox: bbox2,
          geometry: {
            type: "Polygon",
            coordinates
          }
        };
      }
    }
    return null;
  }
  function getGroundOverlay(node, styleMap, schema, options2) {
    var _a2;
    const box = getGroundOverlayBox(node);
    const geometry = (box == null ? void 0 : box.geometry) || null;
    if (!geometry && options2.skipNullGeometry) {
      return null;
    }
    const feature3 = {
      type: "Feature",
      geometry,
      properties: Object.assign(
        /**
         * Related to
         * https://gist.github.com/tmcw/037a1cb6660d74a392e9da7446540f46
         */
        { "@geometry-type": "groundoverlay" },
        getMulti(node, [
          "name",
          "address",
          "visibility",
          "open",
          "phoneNumber",
          "description"
        ]),
        getMaybeHTMLDescription(node),
        extractCascadedStyle(node, styleMap),
        extractStyle(node),
        extractIconHref(node),
        extractExtendedData(node, schema),
        extractTimeSpan(node),
        extractTimeStamp(node)
      )
    };
    if (box == null ? void 0 : box.bbox) {
      feature3.bbox = box.bbox;
    }
    if (((_a2 = feature3.properties) == null ? void 0 : _a2.visibility) !== void 0) {
      feature3.properties.visibility = feature3.properties.visibility !== "0";
    }
    const id2 = node.getAttribute("id");
    if (id2 !== null && id2 !== "")
      feature3.id = id2;
    return feature3;
  }
  function getStyleId(style) {
    let id2 = style.getAttribute("id");
    const parentNode = style.parentNode;
    if (!id2 && isElement(parentNode) && parentNode.localName === "CascadingStyle") {
      id2 = parentNode.getAttribute("kml:id") || parentNode.getAttribute("id");
    }
    return normalizeId(id2 || "");
  }
  function buildStyleMap(node) {
    const styleMap = {};
    for (const style of $(node, "Style")) {
      styleMap[getStyleId(style)] = extractStyle(style);
    }
    for (const map2 of $(node, "StyleMap")) {
      const id2 = normalizeId(map2.getAttribute("id") || "");
      val1(map2, "styleUrl", (styleUrl) => {
        styleUrl = normalizeId(styleUrl);
        if (styleMap[styleUrl]) {
          styleMap[id2] = styleMap[styleUrl];
        }
      });
    }
    return styleMap;
  }
  function buildSchema(node) {
    const schema = {};
    for (const field of $(node, "SimpleField")) {
      schema[field.getAttribute("name") || ""] = typeConverters[field.getAttribute("type") || ""] || typeConverters["string"];
    }
    return schema;
  }
  function* kmlGen(node, options2 = {
    skipNullGeometry: false
  }) {
    const styleMap = buildStyleMap(node);
    const schema = buildSchema(node);
    for (const placemark of $(node, "Placemark")) {
      const feature3 = getPlacemark(placemark, styleMap, schema, options2);
      if (feature3)
        yield feature3;
    }
    for (const groundOverlay of $(node, "GroundOverlay")) {
      const feature3 = getGroundOverlay(groundOverlay, styleMap, schema, options2);
      if (feature3)
        yield feature3;
    }
  }
  function kml(node, options2 = {
    skipNullGeometry: false
  }) {
    return {
      type: "FeatureCollection",
      features: Array.from(kmlGen(node, options2))
    };
  }

  // modules/svg/data.js
  var _initialized = false;
  var _enabled = false;
  var _geojson;
  function svgData(projection2, context, dispatch14) {
    var throttledRedraw = throttle_default(function() {
      dispatch14.call("change");
    }, 1e3);
    var _showLabels = true;
    var detected = utilDetect();
    var layer = select_default2(null);
    var _vtService;
    var _fileList;
    var _template;
    var _src;
    const supportedFormats = [
      ".gpx",
      ".kml",
      ".geojson",
      ".json"
    ];
    function init2() {
      if (_initialized)
        return;
      _geojson = {};
      _enabled = true;
      function over(d3_event) {
        d3_event.stopPropagation();
        d3_event.preventDefault();
        d3_event.dataTransfer.dropEffect = "copy";
      }
      context.container().attr("dropzone", "copy").on("drop.svgData", function(d3_event) {
        d3_event.stopPropagation();
        d3_event.preventDefault();
        if (!detected.filedrop)
          return;
        var f2 = d3_event.dataTransfer.files[0];
        var extension = getExtension(f2.name);
        if (!supportedFormats.includes(extension))
          return;
        drawData.fileList(d3_event.dataTransfer.files);
      }).on("dragenter.svgData", over).on("dragexit.svgData", over).on("dragover.svgData", over);
      _initialized = true;
    }
    function getService() {
      if (services.vectorTile && !_vtService) {
        _vtService = services.vectorTile;
        _vtService.event.on("loadedData", throttledRedraw);
      } else if (!services.vectorTile && _vtService) {
        _vtService = null;
      }
      return _vtService;
    }
    function showLayer() {
      layerOn();
      layer.style("opacity", 0).transition().duration(250).style("opacity", 1).on("end", function() {
        dispatch14.call("change");
      });
    }
    function hideLayer() {
      throttledRedraw.cancel();
      layer.transition().duration(250).style("opacity", 0).on("end", layerOff);
    }
    function layerOn() {
      layer.style("display", "block");
    }
    function layerOff() {
      layer.selectAll(".viewfield-group").remove();
      layer.style("display", "none");
    }
    function ensureIDs(gj) {
      if (!gj)
        return null;
      if (gj.type === "FeatureCollection") {
        for (var i3 = 0; i3 < gj.features.length; i3++) {
          ensureFeatureID(gj.features[i3]);
        }
      } else {
        ensureFeatureID(gj);
      }
      return gj;
    }
    function ensureFeatureID(feature3) {
      if (!feature3)
        return;
      feature3.__featurehash__ = utilHashcode((0, import_fast_json_stable_stringify.default)(feature3));
      return feature3;
    }
    function getFeatures(gj) {
      if (!gj)
        return [];
      if (gj.type === "FeatureCollection") {
        return gj.features;
      } else {
        return [gj];
      }
    }
    function featureKey(d2) {
      return d2.__featurehash__;
    }
    function isPolygon(d2) {
      return d2.geometry.type === "Polygon" || d2.geometry.type === "MultiPolygon";
    }
    function clipPathID(d2) {
      return "ideditor-data-" + d2.__featurehash__ + "-clippath";
    }
    function featureClasses(d2) {
      return [
        "data" + d2.__featurehash__,
        d2.geometry.type,
        isPolygon(d2) ? "area" : "",
        d2.__layerID__ || ""
      ].filter(Boolean).join(" ");
    }
    function drawData(selection2) {
      var vtService = getService();
      var getPath = svgPath(projection2).geojson;
      var getAreaPath = svgPath(projection2, null, true).geojson;
      var hasData = drawData.hasData();
      layer = selection2.selectAll(".layer-mapdata").data(_enabled && hasData ? [0] : []);
      layer.exit().remove();
      layer = layer.enter().append("g").attr("class", "layer-mapdata").merge(layer);
      var surface = context.surface();
      if (!surface || surface.empty())
        return;
      var geoData, polygonData;
      if (_template && vtService) {
        var sourceID = _template;
        vtService.loadTiles(sourceID, _template, projection2);
        geoData = vtService.data(sourceID, projection2);
      } else {
        geoData = getFeatures(_geojson);
      }
      geoData = geoData.filter(getPath);
      polygonData = geoData.filter(isPolygon);
      var clipPaths = surface.selectAll("defs").selectAll(".clipPath-data").data(polygonData, featureKey);
      clipPaths.exit().remove();
      var clipPathsEnter = clipPaths.enter().append("clipPath").attr("class", "clipPath-data").attr("id", clipPathID);
      clipPathsEnter.append("path");
      clipPaths.merge(clipPathsEnter).selectAll("path").attr("d", getAreaPath);
      var datagroups = layer.selectAll("g.datagroup").data(["fill", "shadow", "stroke"]);
      datagroups = datagroups.enter().append("g").attr("class", function(d2) {
        return "datagroup datagroup-" + d2;
      }).merge(datagroups);
      var pathData = {
        fill: polygonData,
        shadow: geoData,
        stroke: geoData
      };
      var paths = datagroups.selectAll("path").data(function(layer2) {
        return pathData[layer2];
      }, featureKey);
      paths.exit().remove();
      paths = paths.enter().append("path").attr("class", function(d2) {
        var datagroup = this.parentNode.__data__;
        return "pathdata " + datagroup + " " + featureClasses(d2);
      }).attr("clip-path", function(d2) {
        var datagroup = this.parentNode.__data__;
        return datagroup === "fill" ? "url(#" + clipPathID(d2) + ")" : null;
      }).merge(paths).attr("d", function(d2) {
        var datagroup = this.parentNode.__data__;
        return datagroup === "fill" ? getAreaPath(d2) : getPath(d2);
      });
      layer.call(drawLabels, "label-halo", geoData).call(drawLabels, "label", geoData);
      function drawLabels(selection3, textClass, data) {
        var labelPath = path_default(projection2);
        var labelData = data.filter(function(d2) {
          return _showLabels && d2.properties && (d2.properties.desc || d2.properties.name);
        });
        var labels = selection3.selectAll("text." + textClass).data(labelData, featureKey);
        labels.exit().remove();
        labels = labels.enter().append("text").attr("class", function(d2) {
          return textClass + " " + featureClasses(d2);
        }).merge(labels).text(function(d2) {
          return d2.properties.desc || d2.properties.name;
        }).attr("x", function(d2) {
          var centroid = labelPath.centroid(d2);
          return centroid[0] + 11;
        }).attr("y", function(d2) {
          var centroid = labelPath.centroid(d2);
          return centroid[1];
        });
      }
    }
    function getExtension(fileName) {
      if (!fileName)
        return;
      var re3 = /\.(gpx|kml|(geo)?json|png)$/i;
      var match = fileName.toLowerCase().match(re3);
      return match && match.length && match[0];
    }
    function xmlToDom(textdata) {
      return new DOMParser().parseFromString(textdata, "text/xml");
    }
    function stringifyGeojsonProperties(feature3) {
      const properties = feature3.properties;
      for (const key in properties) {
        const property = properties[key];
        if (typeof property === "number" || typeof property === "boolean" || Array.isArray(property)) {
          properties[key] = property.toString();
        } else if (property === null) {
          properties[key] = "null";
        } else if (typeof property === "object") {
          properties[key] = JSON.stringify(property);
        }
      }
    }
    drawData.setFile = function(extension, data) {
      _template = null;
      _fileList = null;
      _geojson = null;
      _src = null;
      var gj;
      switch (extension) {
        case ".gpx":
          gj = gpx(xmlToDom(data));
          break;
        case ".kml":
          gj = kml(xmlToDom(data));
          break;
        case ".geojson":
        case ".json":
          gj = JSON.parse(data);
          if (gj.type === "FeatureCollection") {
            gj.features.forEach(stringifyGeojsonProperties);
          } else if (gj.type === "Feature") {
            stringifyGeojsonProperties(gj);
          }
          break;
      }
      gj = gj || {};
      if (Object.keys(gj).length) {
        _geojson = ensureIDs(gj);
        _src = extension + " data file";
        this.fitZoom();
      }
      dispatch14.call("change");
      return this;
    };
    drawData.showLabels = function(val) {
      if (!arguments.length)
        return _showLabels;
      _showLabels = val;
      return this;
    };
    drawData.enabled = function(val) {
      if (!arguments.length)
        return _enabled;
      _enabled = val;
      if (_enabled) {
        showLayer();
      } else {
        hideLayer();
      }
      dispatch14.call("change");
      return this;
    };
    drawData.hasData = function() {
      var gj = _geojson || {};
      return !!(_template || Object.keys(gj).length);
    };
    drawData.template = function(val, src) {
      if (!arguments.length)
        return _template;
      var osm = context.connection();
      if (osm) {
        var blocklists = osm.imageryBlocklists();
        var fail = false;
        var tested = 0;
        var regex;
        for (var i3 = 0; i3 < blocklists.length; i3++) {
          regex = blocklists[i3];
          fail = regex.test(val);
          tested++;
          if (fail)
            break;
        }
        if (!tested) {
          regex = /.*\.google(apis)?\..*\/(vt|kh)[\?\/].*([xyz]=.*){3}.*/;
          fail = regex.test(val);
        }
      }
      _template = val;
      _fileList = null;
      _geojson = null;
      _src = src || "vectortile:" + val.split(/[?#]/)[0];
      dispatch14.call("change");
      return this;
    };
    drawData.geojson = function(gj, src) {
      if (!arguments.length)
        return _geojson;
      _template = null;
      _fileList = null;
      _geojson = null;
      _src = null;
      gj = gj || {};
      if (Object.keys(gj).length) {
        _geojson = ensureIDs(gj);
        _src = src || "unknown.geojson";
      }
      dispatch14.call("change");
      return this;
    };
    drawData.fileList = function(fileList) {
      if (!arguments.length)
        return _fileList;
      _template = null;
      _geojson = null;
      _src = null;
      _fileList = fileList;
      if (!fileList || !fileList.length)
        return this;
      var f2 = fileList[0];
      var extension = getExtension(f2.name);
      var reader = new FileReader();
      reader.onload = /* @__PURE__ */ function() {
        return function(e3) {
          drawData.setFile(extension, e3.target.result);
        };
      }(f2);
      reader.readAsText(f2);
      return this;
    };
    drawData.url = function(url, defaultExtension) {
      _template = null;
      _fileList = null;
      _geojson = null;
      _src = null;
      var testUrl = url.split(/[?#]/)[0];
      var extension = getExtension(testUrl) || defaultExtension;
      if (extension) {
        _template = null;
        text_default3(url).then(function(data) {
          drawData.setFile(extension, data);
        }).catch(function() {
        });
      } else {
        drawData.template(url);
      }
      return this;
    };
    drawData.getSrc = function() {
      return _src || "";
    };
    drawData.fitZoom = function() {
      var features = getFeatures(_geojson);
      if (!features.length)
        return;
      var map2 = context.map();
      var viewport = map2.trimmedExtent().polygon();
      var coords = features.reduce(function(coords2, feature3) {
        var geom = feature3.geometry;
        if (!geom)
          return coords2;
        var c2 = geom.coordinates;
        switch (geom.type) {
          case "Point":
            c2 = [c2];
          case "MultiPoint":
          case "LineString":
            break;
          case "MultiPolygon":
            c2 = utilArrayFlatten(c2);
          case "Polygon":
          case "MultiLineString":
            c2 = utilArrayFlatten(c2);
            break;
        }
        return utilArrayUnion(coords2, c2);
      }, []);
      if (!geoPolygonIntersectsPolygon(viewport, coords, true)) {
        var extent = geoExtent(bounds_default({ type: "LineString", coordinates: coords }));
        map2.centerZoom(extent.center(), map2.trimmedExtentZoom(extent));
      }
      return this;
    };
    init2();
    return drawData;
  }

  // modules/svg/debug.js
  function svgDebug(projection2, context) {
    function drawDebug(selection2) {
      const showTile = context.getDebug("tile");
      const showCollision = context.getDebug("collision");
      const showImagery = context.getDebug("imagery");
      const showTouchTargets = context.getDebug("target");
      const showDownloaded = context.getDebug("downloaded");
      let debugData = [];
      if (showTile) {
        debugData.push({ class: "red", label: "tile" });
      }
      if (showCollision) {
        debugData.push({ class: "yellow", label: "collision" });
      }
      if (showImagery) {
        debugData.push({ class: "orange", label: "imagery" });
      }
      if (showTouchTargets) {
        debugData.push({ class: "pink", label: "touchTargets" });
      }
      if (showDownloaded) {
        debugData.push({ class: "purple", label: "downloaded" });
      }
      let legend = context.container().select(".main-content").selectAll(".debug-legend").data(debugData.length ? [0] : []);
      legend.exit().remove();
      legend = legend.enter().append("div").attr("class", "fillD debug-legend").merge(legend);
      let legendItems = legend.selectAll(".debug-legend-item").data(debugData, (d2) => d2.label);
      legendItems.exit().remove();
      legendItems.enter().append("span").attr("class", (d2) => "debug-legend-item ".concat(d2.class)).text((d2) => d2.label);
      let layer = selection2.selectAll(".layer-debug").data(showImagery || showDownloaded ? [0] : []);
      layer.exit().remove();
      layer = layer.enter().append("g").attr("class", "layer-debug").merge(layer);
      const extent = context.map().extent();
      _mainFileFetcher.get("imagery").then((d2) => {
        const hits = showImagery && d2.query.bbox(extent.rectangle(), true) || [];
        const features = hits.map((d4) => d4.features[d4.id]);
        let imagery = layer.selectAll("path.debug-imagery").data(features);
        imagery.exit().remove();
        imagery.enter().append("path").attr("class", "debug-imagery debug orange");
      }).catch(() => {
      });
      const osm = context.connection();
      let dataDownloaded = [];
      if (osm && showDownloaded) {
        const rtree = osm.caches("get").tile.rtree;
        dataDownloaded = rtree.all().map((bbox2) => {
          return {
            type: "Feature",
            properties: { id: bbox2.id },
            geometry: {
              type: "Polygon",
              coordinates: [[
                [bbox2.minX, bbox2.minY],
                [bbox2.minX, bbox2.maxY],
                [bbox2.maxX, bbox2.maxY],
                [bbox2.maxX, bbox2.minY],
                [bbox2.minX, bbox2.minY]
              ]]
            }
          };
        });
      }
      let downloaded = layer.selectAll("path.debug-downloaded").data(showDownloaded ? dataDownloaded : []);
      downloaded.exit().remove();
      downloaded.enter().append("path").attr("class", "debug-downloaded debug purple");
      layer.selectAll("path").attr("d", svgPath(projection2).geojson);
    }
    drawDebug.enabled = function() {
      if (!arguments.length) {
        return context.getDebug("tile") || context.getDebug("collision") || context.getDebug("imagery") || context.getDebug("target") || context.getDebug("downloaded");
      } else {
        return this;
      }
    };
    return drawDebug;
  }

  // modules/svg/defs.js
  function svgDefs(context) {
    var _defsSelection = select_default2(null);
    var _spritesheetIds = [
      "iD-sprite",
      "maki-sprite",
      "temaki-sprite",
      "fa-sprite",
      "roentgen-sprite",
      "community-sprite"
    ];
    function drawDefs(selection2) {
      _defsSelection = selection2.append("defs");
      _defsSelection.append("marker").attr("id", "ideditor-oneway-marker").attr("viewBox", "0 0 10 5").attr("refX", 2.5).attr("refY", 2.5).attr("markerWidth", 2).attr("markerHeight", 2).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("class", "oneway-marker-path").attr("d", "M 5,3 L 0,3 L 0,2 L 5,2 L 5,0 L 10,2.5 L 5,5 z").attr("stroke", "none").attr("fill", "#000").attr("opacity", "0.75");
      function addSidedMarker(name, color2, offset) {
        _defsSelection.append("marker").attr("id", "ideditor-sided-marker-" + name).attr("viewBox", "0 0 2 2").attr("refX", 1).attr("refY", -offset).attr("markerWidth", 1.5).attr("markerHeight", 1.5).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("class", "sided-marker-path sided-marker-" + name + "-path").attr("d", "M 0,0 L 1,1 L 2,0 z").attr("stroke", "none").attr("fill", color2);
      }
      addSidedMarker("natural", "rgb(170, 170, 170)", 0);
      addSidedMarker("coastline", "#77dede", 1);
      addSidedMarker("waterway", "#77dede", 1);
      addSidedMarker("barrier", "#ddd", 1);
      addSidedMarker("man_made", "#fff", 0);
      _defsSelection.append("marker").attr("id", "ideditor-viewfield-marker").attr("viewBox", "0 0 16 16").attr("refX", 8).attr("refY", 16).attr("markerWidth", 4).attr("markerHeight", 4).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("class", "viewfield-marker-path").attr("d", "M 6,14 C 8,13.4 8,13.4 10,14 L 16,3 C 12,0 4,0 0,3 z").attr("fill", "#333").attr("fill-opacity", "0.75").attr("stroke", "#fff").attr("stroke-width", "0.5px").attr("stroke-opacity", "0.75");
      _defsSelection.append("marker").attr("id", "ideditor-viewfield-marker-wireframe").attr("viewBox", "0 0 16 16").attr("refX", 8).attr("refY", 16).attr("markerWidth", 4).attr("markerHeight", 4).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("class", "viewfield-marker-path").attr("d", "M 6,14 C 8,13.4 8,13.4 10,14 L 16,3 C 12,0 4,0 0,3 z").attr("fill", "none").attr("stroke", "#fff").attr("stroke-width", "0.5px").attr("stroke-opacity", "0.75");
      var patterns2 = _defsSelection.selectAll("pattern").data([
        // pattern name, pattern image name
        ["beach", "dots"],
        ["construction", "construction"],
        ["cemetery", "cemetery"],
        ["cemetery_christian", "cemetery_christian"],
        ["cemetery_buddhist", "cemetery_buddhist"],
        ["cemetery_muslim", "cemetery_muslim"],
        ["cemetery_jewish", "cemetery_jewish"],
        ["farmland", "farmland"],
        ["farmyard", "farmyard"],
        ["forest", "forest"],
        ["forest_broadleaved", "forest_broadleaved"],
        ["forest_needleleaved", "forest_needleleaved"],
        ["forest_leafless", "forest_leafless"],
        ["golf_green", "grass"],
        ["grass", "grass"],
        ["landfill", "landfill"],
        ["meadow", "grass"],
        ["orchard", "orchard"],
        ["pond", "pond"],
        ["quarry", "quarry"],
        ["scrub", "bushes"],
        ["vineyard", "vineyard"],
        ["water_standing", "lines"],
        ["waves", "waves"],
        ["wetland", "wetland"],
        ["wetland_marsh", "wetland_marsh"],
        ["wetland_swamp", "wetland_swamp"],
        ["wetland_bog", "wetland_bog"],
        ["wetland_reedbed", "wetland_reedbed"]
      ]).enter().append("pattern").attr("id", function(d2) {
        return "ideditor-pattern-" + d2[0];
      }).attr("width", 32).attr("height", 32).attr("patternUnits", "userSpaceOnUse");
      patterns2.append("rect").attr("x", 0).attr("y", 0).attr("width", 32).attr("height", 32).attr("class", function(d2) {
        return "pattern-color-" + d2[0];
      });
      patterns2.append("image").attr("x", 0).attr("y", 0).attr("width", 32).attr("height", 32).attr("xlink:href", function(d2) {
        return context.imagePath("pattern/" + d2[1] + ".png");
      });
      _defsSelection.selectAll("clipPath").data([12, 18, 20, 32, 45]).enter().append("clipPath").attr("id", function(d2) {
        return "ideditor-clip-square-" + d2;
      }).append("rect").attr("x", 0).attr("y", 0).attr("width", function(d2) {
        return d2;
      }).attr("height", function(d2) {
        return d2;
      });
      addSprites(_spritesheetIds, true);
    }
    function addSprites(ids, overrideColors) {
      _spritesheetIds = utilArrayUniq(_spritesheetIds.concat(ids));
      var spritesheets = _defsSelection.selectAll(".spritesheet").data(_spritesheetIds);
      spritesheets.enter().append("g").attr("class", function(d2) {
        return "spritesheet spritesheet-" + d2;
      }).each(function(d2) {
        var url = context.imagePath(d2 + ".svg");
        var node = select_default2(this).node();
        svg(url).then(function(svg2) {
          node.appendChild(
            select_default2(svg2.documentElement).attr("id", "ideditor-" + d2).node()
          );
          if (overrideColors && d2 !== "iD-sprite") {
            select_default2(node).selectAll("path").attr("fill", "currentColor");
          }
        }).catch(function() {
        });
      });
      spritesheets.exit().remove();
    }
    drawDefs.addSprites = addSprites;
    return drawDefs;
  }

  // modules/svg/keepRight.js
  var _layerEnabled = false;
  var _qaService;
  function svgKeepRight(projection2, context, dispatch14) {
    const throttledRedraw = throttle_default(() => dispatch14.call("change"), 1e3);
    const minZoom4 = 12;
    let touchLayer = select_default2(null);
    let drawLayer = select_default2(null);
    let layerVisible = false;
    function markerPath(selection2, klass) {
      selection2.attr("class", klass).attr("transform", "translate(-4, -24)").attr("d", "M11.6,6.2H7.1l1.4-5.1C8.6,0.6,8.1,0,7.5,0H2.2C1.7,0,1.3,0.3,1.3,0.8L0,10.2c-0.1,0.6,0.4,1.1,0.9,1.1h4.6l-1.8,7.6C3.6,19.4,4.1,20,4.7,20c0.3,0,0.6-0.2,0.8-0.5l6.9-11.9C12.7,7,12.3,6.2,11.6,6.2z");
    }
    function getService() {
      if (services.keepRight && !_qaService) {
        _qaService = services.keepRight;
        _qaService.on("loaded", throttledRedraw);
      } else if (!services.keepRight && _qaService) {
        _qaService = null;
      }
      return _qaService;
    }
    function editOn() {
      if (!layerVisible) {
        layerVisible = true;
        drawLayer.style("display", "block");
      }
    }
    function editOff() {
      if (layerVisible) {
        layerVisible = false;
        drawLayer.style("display", "none");
        drawLayer.selectAll(".qaItem.keepRight").remove();
        touchLayer.selectAll(".qaItem.keepRight").remove();
      }
    }
    function layerOn() {
      editOn();
      drawLayer.style("opacity", 0).transition().duration(250).style("opacity", 1).on("end interrupt", () => dispatch14.call("change"));
    }
    function layerOff() {
      throttledRedraw.cancel();
      drawLayer.interrupt();
      touchLayer.selectAll(".qaItem.keepRight").remove();
      drawLayer.transition().duration(250).style("opacity", 0).on("end interrupt", () => {
        editOff();
        dispatch14.call("change");
      });
    }
    function updateMarkers() {
      if (!layerVisible || !_layerEnabled)
        return;
      const service = getService();
      const selectedID = context.selectedErrorID();
      const data = service ? service.getItems(projection2) : [];
      const getTransform = svgPointTransform(projection2);
      const markers = drawLayer.selectAll(".qaItem.keepRight").data(data, (d2) => d2.id);
      markers.exit().remove();
      const markersEnter = markers.enter().append("g").attr("class", (d2) => "qaItem ".concat(d2.service, " itemId-").concat(d2.id, " itemType-").concat(d2.parentIssueType));
      markersEnter.append("ellipse").attr("cx", 0.5).attr("cy", 1).attr("rx", 6.5).attr("ry", 3).attr("class", "stroke");
      markersEnter.append("path").call(markerPath, "shadow");
      markersEnter.append("use").attr("class", "qaItem-fill").attr("width", "20px").attr("height", "20px").attr("x", "-8px").attr("y", "-22px").attr("xlink:href", "#iD-icon-bolt");
      markers.merge(markersEnter).sort(sortY).classed("selected", (d2) => d2.id === selectedID).attr("transform", getTransform);
      if (touchLayer.empty())
        return;
      const fillClass = context.getDebug("target") ? "pink " : "nocolor ";
      const targets = touchLayer.selectAll(".qaItem.keepRight").data(data, (d2) => d2.id);
      targets.exit().remove();
      targets.enter().append("rect").attr("width", "20px").attr("height", "20px").attr("x", "-8px").attr("y", "-22px").merge(targets).sort(sortY).attr("class", (d2) => "qaItem ".concat(d2.service, " target ").concat(fillClass, " itemId-").concat(d2.id)).attr("transform", getTransform);
      function sortY(a2, b2) {
        return a2.id === selectedID ? 1 : b2.id === selectedID ? -1 : a2.severity === "error" && b2.severity !== "error" ? 1 : b2.severity === "error" && a2.severity !== "error" ? -1 : b2.loc[1] - a2.loc[1];
      }
    }
    function drawKeepRight(selection2) {
      const service = getService();
      const surface = context.surface();
      if (surface && !surface.empty()) {
        touchLayer = surface.selectAll(".data-layer.touch .layer-touch.markers");
      }
      drawLayer = selection2.selectAll(".layer-keepRight").data(service ? [0] : []);
      drawLayer.exit().remove();
      drawLayer = drawLayer.enter().append("g").attr("class", "layer-keepRight").style("display", _layerEnabled ? "block" : "none").merge(drawLayer);
      if (_layerEnabled) {
        if (service && ~~context.map().zoom() >= minZoom4) {
          editOn();
          service.loadIssues(projection2);
          updateMarkers();
        } else {
          editOff();
        }
      }
    }
    drawKeepRight.enabled = function(val) {
      if (!arguments.length)
        return _layerEnabled;
      _layerEnabled = val;
      if (_layerEnabled) {
        layerOn();
      } else {
        layerOff();
        if (context.selectedErrorID()) {
          context.enter(modeBrowse(context));
        }
      }
      dispatch14.call("change");
      return this;
    };
    drawKeepRight.supported = () => !!getService();
    return drawKeepRight;
  }

  // modules/svg/geolocate.js
  function svgGeolocate(projection2) {
    var layer = select_default2(null);
    var _position;
    function init2() {
      if (svgGeolocate.initialized)
        return;
      svgGeolocate.enabled = false;
      svgGeolocate.initialized = true;
    }
    function showLayer() {
      layer.style("display", "block");
    }
    function hideLayer() {
      layer.transition().duration(250).style("opacity", 0);
    }
    function layerOn() {
      layer.style("opacity", 0).transition().duration(250).style("opacity", 1);
    }
    function layerOff() {
      layer.style("display", "none");
    }
    function transform2(d2) {
      return svgPointTransform(projection2)(d2);
    }
    function accuracy(accuracy2, loc) {
      var degreesRadius = geoMetersToLat(accuracy2), tangentLoc = [loc[0], loc[1] + degreesRadius], projectedTangent = projection2(tangentLoc), projectedLoc = projection2([loc[0], loc[1]]);
      return Math.round(projectedLoc[1] - projectedTangent[1]).toString();
    }
    function update() {
      var geolocation = { loc: [_position.coords.longitude, _position.coords.latitude] };
      var groups = layer.selectAll(".geolocations").selectAll(".geolocation").data([geolocation]);
      groups.exit().remove();
      var pointsEnter = groups.enter().append("g").attr("class", "geolocation");
      pointsEnter.append("circle").attr("class", "geolocate-radius").attr("dx", "0").attr("dy", "0").attr("fill", "rgb(15,128,225)").attr("fill-opacity", "0.3").attr("r", "0");
      pointsEnter.append("circle").attr("dx", "0").attr("dy", "0").attr("fill", "rgb(15,128,225)").attr("stroke", "white").attr("stroke-width", "1.5").attr("r", "6");
      groups.merge(pointsEnter).attr("transform", transform2);
      layer.select(".geolocate-radius").attr("r", accuracy(_position.coords.accuracy, geolocation.loc));
    }
    function drawLocation(selection2) {
      var enabled = svgGeolocate.enabled;
      layer = selection2.selectAll(".layer-geolocate").data([0]);
      layer.exit().remove();
      var layerEnter = layer.enter().append("g").attr("class", "layer-geolocate").style("display", enabled ? "block" : "none");
      layerEnter.append("g").attr("class", "geolocations");
      layer = layerEnter.merge(layer);
      if (enabled) {
        update();
      } else {
        layerOff();
      }
    }
    drawLocation.enabled = function(position, enabled) {
      if (!arguments.length)
        return svgGeolocate.enabled;
      _position = position;
      svgGeolocate.enabled = enabled;
      if (svgGeolocate.enabled) {
        showLayer();
        layerOn();
      } else {
        hideLayer();
      }
      return this;
    };
    init2();
    return drawLocation;
  }

  // modules/svg/labels.js
  var import_rbush6 = __toESM(require_rbush_min());
  function svgLabels(projection2, context) {
    var path = path_default(projection2);
    var detected = utilDetect();
    var baselineHack = detected.ie || detected.browser.toLowerCase() === "edge" || detected.browser.toLowerCase() === "firefox" && detected.version >= 70;
    var _rdrawn = new import_rbush6.default();
    var _rskipped = new import_rbush6.default();
    var _textWidthCache = {};
    var _entitybboxes = {};
    var labelStack = [
      ["line", "aeroway", "*", 12],
      ["line", "highway", "motorway", 12],
      ["line", "highway", "trunk", 12],
      ["line", "highway", "primary", 12],
      ["line", "highway", "secondary", 12],
      ["line", "highway", "tertiary", 12],
      ["line", "highway", "*", 12],
      ["line", "railway", "*", 12],
      ["line", "waterway", "*", 12],
      ["area", "aeroway", "*", 12],
      ["area", "amenity", "*", 12],
      ["area", "building", "*", 12],
      ["area", "historic", "*", 12],
      ["area", "leisure", "*", 12],
      ["area", "man_made", "*", 12],
      ["area", "natural", "*", 12],
      ["area", "shop", "*", 12],
      ["area", "tourism", "*", 12],
      ["area", "camp_site", "*", 12],
      ["point", "aeroway", "*", 10],
      ["point", "amenity", "*", 10],
      ["point", "building", "*", 10],
      ["point", "historic", "*", 10],
      ["point", "leisure", "*", 10],
      ["point", "man_made", "*", 10],
      ["point", "natural", "*", 10],
      ["point", "shop", "*", 10],
      ["point", "tourism", "*", 10],
      ["point", "camp_site", "*", 10],
      ["line", "ref", "*", 12],
      ["area", "ref", "*", 12],
      ["point", "ref", "*", 10],
      ["line", "name", "*", 12],
      ["area", "name", "*", 12],
      ["point", "name", "*", 10]
    ];
    function shouldSkipIcon(preset) {
      var noIcons = ["building", "landuse", "natural"];
      return noIcons.some(function(s2) {
        return preset.id.indexOf(s2) >= 0;
      });
    }
    function get4(array2, prop) {
      return function(d2, i3) {
        return array2[i3][prop];
      };
    }
    function textWidth(text, size, elem) {
      var c2 = _textWidthCache[size];
      if (!c2)
        c2 = _textWidthCache[size] = {};
      if (c2[text]) {
        return c2[text];
      } else if (elem) {
        c2[text] = elem.getComputedTextLength();
        return c2[text];
      } else {
        var str = encodeURIComponent(text).match(/%[CDEFcdef]/g);
        if (str === null) {
          return size / 3 * 2 * text.length;
        } else {
          return size / 3 * (2 * text.length + str.length);
        }
      }
    }
    function drawLinePaths(selection2, entities, filter2, classes, labels) {
      var paths = selection2.selectAll("path").filter(filter2).data(entities, osmEntity.key);
      paths.exit().remove();
      paths.enter().append("path").style("stroke-width", get4(labels, "font-size")).attr("id", function(d2) {
        return "ideditor-labelpath-" + d2.id;
      }).attr("class", classes).merge(paths).attr("d", get4(labels, "lineString"));
    }
    function drawLineLabels(selection2, entities, filter2, classes, labels) {
      var texts = selection2.selectAll("text." + classes).filter(filter2).data(entities, osmEntity.key);
      texts.exit().remove();
      texts.enter().append("text").attr("class", function(d2, i3) {
        return classes + " " + labels[i3].classes + " " + d2.id;
      }).attr("dy", baselineHack ? "0.35em" : null).append("textPath").attr("class", "textpath");
      selection2.selectAll("text." + classes).selectAll(".textpath").filter(filter2).data(entities, osmEntity.key).attr("startOffset", "50%").attr("xlink:href", function(d2) {
        return "#ideditor-labelpath-" + d2.id;
      }).text(utilDisplayNameForPath);
    }
    function drawPointLabels(selection2, entities, filter2, classes, labels) {
      var texts = selection2.selectAll("text." + classes).filter(filter2).data(entities, osmEntity.key);
      texts.exit().remove();
      texts.enter().append("text").attr("class", function(d2, i3) {
        return classes + " " + labels[i3].classes + " " + d2.id;
      }).merge(texts).attr("x", get4(labels, "x")).attr("y", get4(labels, "y")).style("text-anchor", get4(labels, "textAnchor")).text(utilDisplayName).each(function(d2, i3) {
        textWidth(utilDisplayName(d2), labels[i3].height, this);
      });
    }
    function drawAreaLabels(selection2, entities, filter2, classes, labels) {
      entities = entities.filter(hasText);
      labels = labels.filter(hasText);
      drawPointLabels(selection2, entities, filter2, classes, labels);
      function hasText(d2, i3) {
        return labels[i3].hasOwnProperty("x") && labels[i3].hasOwnProperty("y");
      }
    }
    function drawAreaIcons(selection2, entities, filter2, classes, labels) {
      var icons = selection2.selectAll("use." + classes).filter(filter2).data(entities, osmEntity.key);
      icons.exit().remove();
      icons.enter().append("use").attr("class", "icon " + classes).attr("width", "17px").attr("height", "17px").merge(icons).attr("transform", get4(labels, "transform")).attr("xlink:href", function(d2) {
        var preset = _mainPresetIndex.match(d2, context.graph());
        var picon = preset && preset.icon;
        return picon ? "#" + picon : "";
      });
    }
    function drawCollisionBoxes(selection2, rtree, which) {
      var classes = "debug " + which + " " + (which === "debug-skipped" ? "orange" : "yellow");
      var gj = [];
      if (context.getDebug("collision")) {
        gj = rtree.all().map(function(d2) {
          return { type: "Polygon", coordinates: [[
            [d2.minX, d2.minY],
            [d2.maxX, d2.minY],
            [d2.maxX, d2.maxY],
            [d2.minX, d2.maxY],
            [d2.minX, d2.minY]
          ]] };
        });
      }
      var boxes = selection2.selectAll("." + which).data(gj);
      boxes.exit().remove();
      boxes.enter().append("path").attr("class", classes).merge(boxes).attr("d", path_default());
    }
    function drawLabels(selection2, graph, entities, filter2, dimensions, fullRedraw) {
      var wireframe = context.surface().classed("fill-wireframe");
      var zoom = geoScaleToZoom(projection2.scale());
      var labelable = [];
      var renderNodeAs = {};
      var i3, j2, k2, entity, geometry;
      for (i3 = 0; i3 < labelStack.length; i3++) {
        labelable.push([]);
      }
      if (fullRedraw) {
        _rdrawn.clear();
        _rskipped.clear();
        _entitybboxes = {};
      } else {
        for (i3 = 0; i3 < entities.length; i3++) {
          entity = entities[i3];
          var toRemove = [].concat(_entitybboxes[entity.id] || []).concat(_entitybboxes[entity.id + "I"] || []);
          for (j2 = 0; j2 < toRemove.length; j2++) {
            _rdrawn.remove(toRemove[j2]);
            _rskipped.remove(toRemove[j2]);
          }
        }
      }
      for (i3 = 0; i3 < entities.length; i3++) {
        entity = entities[i3];
        geometry = entity.geometry(graph);
        if (geometry === "point" || geometry === "vertex" && isInterestingVertex(entity)) {
          var hasDirections = entity.directions(graph, projection2).length;
          var markerPadding;
          if (!wireframe && geometry === "point" && !(zoom >= 18 && hasDirections)) {
            renderNodeAs[entity.id] = "point";
            markerPadding = 20;
          } else {
            renderNodeAs[entity.id] = "vertex";
            markerPadding = 0;
          }
          var coord2 = projection2(entity.loc);
          var nodePadding = 10;
          var bbox2 = {
            minX: coord2[0] - nodePadding,
            minY: coord2[1] - nodePadding - markerPadding,
            maxX: coord2[0] + nodePadding,
            maxY: coord2[1] + nodePadding
          };
          doInsert(bbox2, entity.id + "P");
        }
        if (geometry === "vertex") {
          geometry = "point";
        }
        var preset = geometry === "area" && _mainPresetIndex.match(entity, graph);
        var icon2 = preset && !shouldSkipIcon(preset) && preset.icon;
        if (!icon2 && !utilDisplayName(entity))
          continue;
        for (k2 = 0; k2 < labelStack.length; k2++) {
          var matchGeom = labelStack[k2][0];
          var matchKey = labelStack[k2][1];
          var matchVal = labelStack[k2][2];
          var hasVal = entity.tags[matchKey];
          if (geometry === matchGeom && hasVal && (matchVal === "*" || matchVal === hasVal)) {
            labelable[k2].push(entity);
            break;
          }
        }
      }
      var positions = {
        point: [],
        line: [],
        area: []
      };
      var labelled = {
        point: [],
        line: [],
        area: []
      };
      for (k2 = 0; k2 < labelable.length; k2++) {
        var fontSize = labelStack[k2][3];
        for (i3 = 0; i3 < labelable[k2].length; i3++) {
          entity = labelable[k2][i3];
          geometry = entity.geometry(graph);
          var getName = geometry === "line" ? utilDisplayNameForPath : utilDisplayName;
          var name = getName(entity);
          var width = name && textWidth(name, fontSize);
          var p2 = null;
          if (geometry === "point" || geometry === "vertex") {
            if (wireframe)
              continue;
            var renderAs = renderNodeAs[entity.id];
            if (renderAs === "vertex" && zoom < 17)
              continue;
            p2 = getPointLabel(entity, width, fontSize, renderAs);
          } else if (geometry === "line") {
            p2 = getLineLabel(entity, width, fontSize);
          } else if (geometry === "area") {
            p2 = getAreaLabel(entity, width, fontSize);
          }
          if (p2) {
            if (geometry === "vertex") {
              geometry = "point";
            }
            p2.classes = geometry + " tag-" + labelStack[k2][1];
            positions[geometry].push(p2);
            labelled[geometry].push(entity);
          }
        }
      }
      function isInterestingVertex(entity2) {
        var selectedIDs = context.selectedIDs();
        return entity2.hasInterestingTags() || entity2.isEndpoint(graph) || entity2.isConnected(graph) || selectedIDs.indexOf(entity2.id) !== -1 || graph.parentWays(entity2).some(function(parent) {
          return selectedIDs.indexOf(parent.id) !== -1;
        });
      }
      function getPointLabel(entity2, width2, height, geometry2) {
        var y2 = geometry2 === "point" ? -12 : 0;
        var pointOffsets = {
          ltr: [15, y2, "start"],
          rtl: [-15, y2, "end"]
        };
        var textDirection = _mainLocalizer.textDirection();
        var coord3 = projection2(entity2.loc);
        var textPadding = 2;
        var offset = pointOffsets[textDirection];
        var p3 = {
          height,
          width: width2,
          x: coord3[0] + offset[0],
          y: coord3[1] + offset[1],
          textAnchor: offset[2]
        };
        var bbox3;
        if (textDirection === "rtl") {
          bbox3 = {
            minX: p3.x - width2 - textPadding,
            minY: p3.y - height / 2 - textPadding,
            maxX: p3.x + textPadding,
            maxY: p3.y + height / 2 + textPadding
          };
        } else {
          bbox3 = {
            minX: p3.x - textPadding,
            minY: p3.y - height / 2 - textPadding,
            maxX: p3.x + width2 + textPadding,
            maxY: p3.y + height / 2 + textPadding
          };
        }
        if (tryInsert([bbox3], entity2.id, true)) {
          return p3;
        }
      }
      function getLineLabel(entity2, width2, height) {
        var viewport = geoExtent(context.projection.clipExtent()).polygon();
        var points = graph.childNodes(entity2).map(function(node) {
          return projection2(node.loc);
        });
        var length2 = geoPathLength(points);
        if (length2 < width2 + 20)
          return;
        var lineOffsets = [
          50,
          45,
          55,
          40,
          60,
          35,
          65,
          30,
          70,
          25,
          75,
          20,
          80,
          15,
          95,
          10,
          90,
          5,
          95
        ];
        var padding = 3;
        for (var i4 = 0; i4 < lineOffsets.length; i4++) {
          var offset = lineOffsets[i4];
          var middle = offset / 100 * length2;
          var start2 = middle - width2 / 2;
          if (start2 < 0 || start2 + width2 > length2)
            continue;
          var sub = subpath(points, start2, start2 + width2);
          if (!sub || !geoPolygonIntersectsPolygon(viewport, sub, true)) {
            continue;
          }
          var isReverse = reverse(sub);
          if (isReverse) {
            sub = sub.reverse();
          }
          var bboxes = [];
          var boxsize = (height + 2) / 2;
          for (var j3 = 0; j3 < sub.length - 1; j3++) {
            var a2 = sub[j3];
            var b2 = sub[j3 + 1];
            var num = Math.max(1, Math.floor(geoVecLength(a2, b2) / boxsize / 2));
            for (var box = 0; box < num; box++) {
              var p3 = geoVecInterp(a2, b2, box / num);
              var x05 = p3[0] - boxsize - padding;
              var y05 = p3[1] - boxsize - padding;
              var x12 = p3[0] + boxsize + padding;
              var y12 = p3[1] + boxsize + padding;
              bboxes.push({
                minX: Math.min(x05, x12),
                minY: Math.min(y05, y12),
                maxX: Math.max(x05, x12),
                maxY: Math.max(y05, y12)
              });
            }
          }
          if (tryInsert(bboxes, entity2.id, false)) {
            return {
              "font-size": height + 2,
              lineString: lineString2(sub),
              startOffset: offset + "%"
            };
          }
        }
        function reverse(p4) {
          var angle2 = Math.atan2(p4[1][1] - p4[0][1], p4[1][0] - p4[0][0]);
          return !(p4[0][0] < p4[p4.length - 1][0] && angle2 < Math.PI / 2 && angle2 > -Math.PI / 2);
        }
        function lineString2(points2) {
          return "M" + points2.join("L");
        }
        function subpath(points2, from, to) {
          var sofar = 0;
          var start3, end, i0, i1;
          for (var i5 = 0; i5 < points2.length - 1; i5++) {
            var a3 = points2[i5];
            var b3 = points2[i5 + 1];
            var current = geoVecLength(a3, b3);
            var portion;
            if (!start3 && sofar + current >= from) {
              portion = (from - sofar) / current;
              start3 = [
                a3[0] + portion * (b3[0] - a3[0]),
                a3[1] + portion * (b3[1] - a3[1])
              ];
              i0 = i5 + 1;
            }
            if (!end && sofar + current >= to) {
              portion = (to - sofar) / current;
              end = [
                a3[0] + portion * (b3[0] - a3[0]),
                a3[1] + portion * (b3[1] - a3[1])
              ];
              i1 = i5 + 1;
            }
            sofar += current;
          }
          var result = points2.slice(i0, i1);
          result.unshift(start3);
          result.push(end);
          return result;
        }
      }
      function getAreaLabel(entity2, width2, height) {
        var centroid = path.centroid(entity2.asGeoJSON(graph));
        var extent = entity2.extent(graph);
        var areaWidth = projection2(extent[1])[0] - projection2(extent[0])[0];
        if (isNaN(centroid[0]) || areaWidth < 20)
          return;
        var preset2 = _mainPresetIndex.match(entity2, context.graph());
        var picon = preset2 && preset2.icon;
        var iconSize = 17;
        var padding = 2;
        var p3 = {};
        if (picon) {
          if (addIcon()) {
            addLabel(iconSize + padding);
            return p3;
          }
        } else {
          if (addLabel(0)) {
            return p3;
          }
        }
        function addIcon() {
          var iconX = centroid[0] - iconSize / 2;
          var iconY = centroid[1] - iconSize / 2;
          var bbox3 = {
            minX: iconX,
            minY: iconY,
            maxX: iconX + iconSize,
            maxY: iconY + iconSize
          };
          if (tryInsert([bbox3], entity2.id + "I", true)) {
            p3.transform = "translate(" + iconX + "," + iconY + ")";
            return true;
          }
          return false;
        }
        function addLabel(yOffset) {
          if (width2 && areaWidth >= width2 + 20) {
            var labelX = centroid[0];
            var labelY = centroid[1] + yOffset;
            var bbox3 = {
              minX: labelX - width2 / 2 - padding,
              minY: labelY - height / 2 - padding,
              maxX: labelX + width2 / 2 + padding,
              maxY: labelY + height / 2 + padding
            };
            if (tryInsert([bbox3], entity2.id, true)) {
              p3.x = labelX;
              p3.y = labelY;
              p3.textAnchor = "middle";
              p3.height = height;
              return true;
            }
          }
          return false;
        }
      }
      function doInsert(bbox3, id2) {
        bbox3.id = id2;
        var oldbox = _entitybboxes[id2];
        if (oldbox) {
          _rdrawn.remove(oldbox);
        }
        _entitybboxes[id2] = bbox3;
        _rdrawn.insert(bbox3);
      }
      function tryInsert(bboxes, id2, saveSkipped) {
        var skipped = false;
        for (var i4 = 0; i4 < bboxes.length; i4++) {
          var bbox3 = bboxes[i4];
          bbox3.id = id2;
          if (bbox3.minX < 0 || bbox3.minY < 0 || bbox3.maxX > dimensions[0] || bbox3.maxY > dimensions[1]) {
            skipped = true;
            break;
          }
          if (_rdrawn.collides(bbox3)) {
            skipped = true;
            break;
          }
        }
        _entitybboxes[id2] = bboxes;
        if (skipped) {
          if (saveSkipped) {
            _rskipped.load(bboxes);
          }
        } else {
          _rdrawn.load(bboxes);
        }
        return !skipped;
      }
      var layer = selection2.selectAll(".layer-osm.labels");
      layer.selectAll(".labels-group").data(["halo", "label", "debug"]).enter().append("g").attr("class", function(d2) {
        return "labels-group " + d2;
      });
      var halo = layer.selectAll(".labels-group.halo");
      var label = layer.selectAll(".labels-group.label");
      var debug2 = layer.selectAll(".labels-group.debug");
      drawPointLabels(label, labelled.point, filter2, "pointlabel", positions.point);
      drawPointLabels(halo, labelled.point, filter2, "pointlabel-halo", positions.point);
      drawLinePaths(layer, labelled.line, filter2, "", positions.line);
      drawLineLabels(label, labelled.line, filter2, "linelabel", positions.line);
      drawLineLabels(halo, labelled.line, filter2, "linelabel-halo", positions.line);
      drawAreaLabels(label, labelled.area, filter2, "arealabel", positions.area);
      drawAreaLabels(halo, labelled.area, filter2, "arealabel-halo", positions.area);
      drawAreaIcons(label, labelled.area, filter2, "areaicon", positions.area);
      drawAreaIcons(halo, labelled.area, filter2, "areaicon-halo", positions.area);
      drawCollisionBoxes(debug2, _rskipped, "debug-skipped");
      drawCollisionBoxes(debug2, _rdrawn, "debug-drawn");
      layer.call(filterLabels);
    }
    function filterLabels(selection2) {
      var drawLayer = selection2.selectAll(".layer-osm.labels");
      var layers = drawLayer.selectAll(".labels-group.halo, .labels-group.label");
      layers.selectAll(".nolabel").classed("nolabel", false);
      var mouse = context.map().mouse();
      var graph = context.graph();
      var selectedIDs = context.selectedIDs();
      var ids = [];
      var pad2, bbox2;
      if (mouse) {
        pad2 = 20;
        bbox2 = { minX: mouse[0] - pad2, minY: mouse[1] - pad2, maxX: mouse[0] + pad2, maxY: mouse[1] + pad2 };
        var nearMouse = _rdrawn.search(bbox2).map(function(entity2) {
          return entity2.id;
        });
        ids.push.apply(ids, nearMouse);
      }
      for (var i3 = 0; i3 < selectedIDs.length; i3++) {
        var entity = graph.hasEntity(selectedIDs[i3]);
        if (entity && entity.type === "node") {
          ids.push(selectedIDs[i3]);
        }
      }
      layers.selectAll(utilEntitySelector(ids)).classed("nolabel", true);
      var debug2 = selection2.selectAll(".labels-group.debug");
      var gj = [];
      if (context.getDebug("collision")) {
        gj = bbox2 ? [{
          type: "Polygon",
          coordinates: [[
            [bbox2.minX, bbox2.minY],
            [bbox2.maxX, bbox2.minY],
            [bbox2.maxX, bbox2.maxY],
            [bbox2.minX, bbox2.maxY],
            [bbox2.minX, bbox2.minY]
          ]]
        }] : [];
      }
      var box = debug2.selectAll(".debug-mouse").data(gj);
      box.exit().remove();
      box.enter().append("path").attr("class", "debug debug-mouse yellow").merge(box).attr("d", path_default());
    }
    var throttleFilterLabels = throttle_default(filterLabels, 100);
    drawLabels.observe = function(selection2) {
      var listener = function() {
        throttleFilterLabels(selection2);
      };
      selection2.on("mousemove.hidelabels", listener);
      context.on("enter.hidelabels", listener);
    };
    drawLabels.off = function(selection2) {
      throttleFilterLabels.cancel();
      selection2.on("mousemove.hidelabels", null);
      context.on("enter.hidelabels", null);
    };
    return drawLabels;
  }

  // node_modules/exifr/dist/full.esm.mjs
  var e = "undefined" != typeof self ? self : global;
  var t = "undefined" != typeof navigator;
  var i2 = t && "undefined" == typeof HTMLImageElement;
  var n2 = !("undefined" == typeof global || "undefined" == typeof process || !process.versions || !process.versions.node);
  var s = e.Buffer;
  var r = e.BigInt;
  var a = !!s;
  var o = (e3) => e3;
  function l(e3, t2 = o) {
    if (n2)
      try {
        return "function" == typeof __require ? Promise.resolve(t2(__require(e3))) : import(
          /* webpackIgnore: true */
          e3
        ).then(t2);
      } catch (t3) {
        console.warn("Couldn't load ".concat(e3));
      }
  }
  var h = e.fetch;
  var u = (e3) => h = e3;
  if (!e.fetch) {
    const e3 = l("http", (e4) => e4), t2 = l("https", (e4) => e4), i3 = (n3, { headers: s2 } = {}) => new Promise(async (r2, a2) => {
      let { port: o2, hostname: l2, pathname: h2, protocol: u2, search: c2 } = new URL(n3);
      const f2 = { method: "GET", hostname: l2, path: encodeURI(h2) + c2, headers: s2 };
      "" !== o2 && (f2.port = Number(o2));
      const d2 = ("https:" === u2 ? await t2 : await e3).request(f2, (e4) => {
        if (301 === e4.statusCode || 302 === e4.statusCode) {
          let t3 = new URL(e4.headers.location, n3).toString();
          return i3(t3, { headers: s2 }).then(r2).catch(a2);
        }
        r2({ status: e4.statusCode, arrayBuffer: () => new Promise((t3) => {
          let i4 = [];
          e4.on("data", (e6) => i4.push(e6)), e4.on("end", () => t3(Buffer.concat(i4)));
        }) });
      });
      d2.on("error", a2), d2.end();
    });
    u(i3);
  }
  function c(e3, t2, i3) {
    return t2 in e3 ? Object.defineProperty(e3, t2, { value: i3, enumerable: true, configurable: true, writable: true }) : e3[t2] = i3, e3;
  }
  var f = (e3) => p(e3) ? void 0 : e3;
  var d = (e3) => void 0 !== e3;
  function p(e3) {
    return void 0 === e3 || (e3 instanceof Map ? 0 === e3.size : 0 === Object.values(e3).filter(d).length);
  }
  function g2(e3) {
    let t2 = new Error(e3);
    throw delete t2.stack, t2;
  }
  function m(e3) {
    return "" === (e3 = function(e4) {
      for (; e4.endsWith("\0"); )
        e4 = e4.slice(0, -1);
      return e4;
    }(e3).trim()) ? void 0 : e3;
  }
  function S(e3) {
    let t2 = function(e4) {
      let t3 = 0;
      return e4.ifd0.enabled && (t3 += 1024), e4.exif.enabled && (t3 += 2048), e4.makerNote && (t3 += 2048), e4.userComment && (t3 += 1024), e4.gps.enabled && (t3 += 512), e4.interop.enabled && (t3 += 100), e4.ifd1.enabled && (t3 += 1024), t3 + 2048;
    }(e3);
    return e3.jfif.enabled && (t2 += 50), e3.xmp.enabled && (t2 += 2e4), e3.iptc.enabled && (t2 += 14e3), e3.icc.enabled && (t2 += 6e3), t2;
  }
  var C = (e3) => String.fromCharCode.apply(null, e3);
  var y = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8") : void 0;
  function b(e3) {
    return y ? y.decode(e3) : a ? Buffer.from(e3).toString("utf8") : decodeURIComponent(escape(C(e3)));
  }
  var I = class _I {
    static from(e3, t2) {
      return e3 instanceof this && e3.le === t2 ? e3 : new _I(e3, void 0, void 0, t2);
    }
    constructor(e3, t2 = 0, i3, n3) {
      if ("boolean" == typeof n3 && (this.le = n3), Array.isArray(e3) && (e3 = new Uint8Array(e3)), 0 === e3)
        this.byteOffset = 0, this.byteLength = 0;
      else if (e3 instanceof ArrayBuffer) {
        void 0 === i3 && (i3 = e3.byteLength - t2);
        let n4 = new DataView(e3, t2, i3);
        this._swapDataView(n4);
      } else if (e3 instanceof Uint8Array || e3 instanceof DataView || e3 instanceof _I) {
        void 0 === i3 && (i3 = e3.byteLength - t2), (t2 += e3.byteOffset) + i3 > e3.byteOffset + e3.byteLength && g2("Creating view outside of available memory in ArrayBuffer");
        let n4 = new DataView(e3.buffer, t2, i3);
        this._swapDataView(n4);
      } else if ("number" == typeof e3) {
        let t3 = new DataView(new ArrayBuffer(e3));
        this._swapDataView(t3);
      } else
        g2("Invalid input argument for BufferView: " + e3);
    }
    _swapArrayBuffer(e3) {
      this._swapDataView(new DataView(e3));
    }
    _swapBuffer(e3) {
      this._swapDataView(new DataView(e3.buffer, e3.byteOffset, e3.byteLength));
    }
    _swapDataView(e3) {
      this.dataView = e3, this.buffer = e3.buffer, this.byteOffset = e3.byteOffset, this.byteLength = e3.byteLength;
    }
    _lengthToEnd(e3) {
      return this.byteLength - e3;
    }
    set(e3, t2, i3 = _I) {
      return e3 instanceof DataView || e3 instanceof _I ? e3 = new Uint8Array(e3.buffer, e3.byteOffset, e3.byteLength) : e3 instanceof ArrayBuffer && (e3 = new Uint8Array(e3)), e3 instanceof Uint8Array || g2("BufferView.set(): Invalid data argument."), this.toUint8().set(e3, t2), new i3(this, t2, e3.byteLength);
    }
    subarray(e3, t2) {
      return t2 = t2 || this._lengthToEnd(e3), new _I(this, e3, t2);
    }
    toUint8() {
      return new Uint8Array(this.buffer, this.byteOffset, this.byteLength);
    }
    getUint8Array(e3, t2) {
      return new Uint8Array(this.buffer, this.byteOffset + e3, t2);
    }
    getString(e3 = 0, t2 = this.byteLength) {
      return b(this.getUint8Array(e3, t2));
    }
    getLatin1String(e3 = 0, t2 = this.byteLength) {
      let i3 = this.getUint8Array(e3, t2);
      return C(i3);
    }
    getUnicodeString(e3 = 0, t2 = this.byteLength) {
      const i3 = [];
      for (let n3 = 0; n3 < t2 && e3 + n3 < this.byteLength; n3 += 2)
        i3.push(this.getUint16(e3 + n3));
      return C(i3);
    }
    getInt8(e3) {
      return this.dataView.getInt8(e3);
    }
    getUint8(e3) {
      return this.dataView.getUint8(e3);
    }
    getInt16(e3, t2 = this.le) {
      return this.dataView.getInt16(e3, t2);
    }
    getInt32(e3, t2 = this.le) {
      return this.dataView.getInt32(e3, t2);
    }
    getUint16(e3, t2 = this.le) {
      return this.dataView.getUint16(e3, t2);
    }
    getUint32(e3, t2 = this.le) {
      return this.dataView.getUint32(e3, t2);
    }
    getFloat32(e3, t2 = this.le) {
      return this.dataView.getFloat32(e3, t2);
    }
    getFloat64(e3, t2 = this.le) {
      return this.dataView.getFloat64(e3, t2);
    }
    getFloat(e3, t2 = this.le) {
      return this.dataView.getFloat32(e3, t2);
    }
    getDouble(e3, t2 = this.le) {
      return this.dataView.getFloat64(e3, t2);
    }
    getUintBytes(e3, t2, i3) {
      switch (t2) {
        case 1:
          return this.getUint8(e3, i3);
        case 2:
          return this.getUint16(e3, i3);
        case 4:
          return this.getUint32(e3, i3);
        case 8:
          return this.getUint64 && this.getUint64(e3, i3);
      }
    }
    getUint(e3, t2, i3) {
      switch (t2) {
        case 8:
          return this.getUint8(e3, i3);
        case 16:
          return this.getUint16(e3, i3);
        case 32:
          return this.getUint32(e3, i3);
        case 64:
          return this.getUint64 && this.getUint64(e3, i3);
      }
    }
    toString(e3) {
      return this.dataView.toString(e3, this.constructor.name);
    }
    ensureChunk() {
    }
  };
  function P(e3, t2) {
    g2("".concat(e3, " '").concat(t2, "' was not loaded, try using full build of exifr."));
  }
  var k = class extends Map {
    constructor(e3) {
      super(), this.kind = e3;
    }
    get(e3, t2) {
      return this.has(e3) || P(this.kind, e3), t2 && (e3 in t2 || function(e4, t3) {
        g2("Unknown ".concat(e4, " '").concat(t3, "'."));
      }(this.kind, e3), t2[e3].enabled || P(this.kind, e3)), super.get(e3);
    }
    keyList() {
      return Array.from(this.keys());
    }
  };
  var w = new k("file parser");
  var T = new k("segment parser");
  var A = new k("file reader");
  function D(e3, n3) {
    return "string" == typeof e3 ? O(e3, n3) : t && !i2 && e3 instanceof HTMLImageElement ? O(e3.src, n3) : e3 instanceof Uint8Array || e3 instanceof ArrayBuffer || e3 instanceof DataView ? new I(e3) : t && e3 instanceof Blob ? x(e3, n3, "blob", R) : void g2("Invalid input argument");
  }
  function O(e3, i3) {
    return (s2 = e3).startsWith("data:") || s2.length > 1e4 ? v(e3, i3, "base64") : n2 && e3.includes("://") ? x(e3, i3, "url", M) : n2 ? v(e3, i3, "fs") : t ? x(e3, i3, "url", M) : void g2("Invalid input argument");
    var s2;
  }
  async function x(e3, t2, i3, n3) {
    return A.has(i3) ? v(e3, t2, i3) : n3 ? async function(e4, t3) {
      let i4 = await t3(e4);
      return new I(i4);
    }(e3, n3) : void g2("Parser ".concat(i3, " is not loaded"));
  }
  async function v(e3, t2, i3) {
    let n3 = new (A.get(i3))(e3, t2);
    return await n3.read(), n3;
  }
  var M = (e3) => h(e3).then((e4) => e4.arrayBuffer());
  var R = (e3) => new Promise((t2, i3) => {
    let n3 = new FileReader();
    n3.onloadend = () => t2(n3.result || new ArrayBuffer()), n3.onerror = i3, n3.readAsArrayBuffer(e3);
  });
  var L = class extends Map {
    get tagKeys() {
      return this.allKeys || (this.allKeys = Array.from(this.keys())), this.allKeys;
    }
    get tagValues() {
      return this.allValues || (this.allValues = Array.from(this.values())), this.allValues;
    }
  };
  function U(e3, t2, i3) {
    let n3 = new L();
    for (let [e4, t3] of i3)
      n3.set(e4, t3);
    if (Array.isArray(t2))
      for (let i4 of t2)
        e3.set(i4, n3);
    else
      e3.set(t2, n3);
    return n3;
  }
  function F(e3, t2, i3) {
    let n3, s2 = e3.get(t2);
    for (n3 of i3)
      s2.set(n3[0], n3[1]);
  }
  var E = /* @__PURE__ */ new Map();
  var B = /* @__PURE__ */ new Map();
  var N = /* @__PURE__ */ new Map();
  var G = ["chunked", "firstChunkSize", "firstChunkSizeNode", "firstChunkSizeBrowser", "chunkSize", "chunkLimit"];
  var V = ["jfif", "xmp", "icc", "iptc", "ihdr"];
  var z = ["tiff", ...V];
  var H = ["ifd0", "ifd1", "exif", "gps", "interop"];
  var j = [...z, ...H];
  var W = ["makerNote", "userComment"];
  var K = ["translateKeys", "translateValues", "reviveValues", "multiSegment"];
  var X = [...K, "sanitize", "mergeOutput", "silentErrors"];
  var _ = class {
    get translate() {
      return this.translateKeys || this.translateValues || this.reviveValues;
    }
  };
  var Y = class extends _ {
    get needed() {
      return this.enabled || this.deps.size > 0;
    }
    constructor(e3, t2, i3, n3) {
      if (super(), c(this, "enabled", false), c(this, "skip", /* @__PURE__ */ new Set()), c(this, "pick", /* @__PURE__ */ new Set()), c(this, "deps", /* @__PURE__ */ new Set()), c(this, "translateKeys", false), c(this, "translateValues", false), c(this, "reviveValues", false), this.key = e3, this.enabled = t2, this.parse = this.enabled, this.applyInheritables(n3), this.canBeFiltered = H.includes(e3), this.canBeFiltered && (this.dict = E.get(e3)), void 0 !== i3)
        if (Array.isArray(i3))
          this.parse = this.enabled = true, this.canBeFiltered && i3.length > 0 && this.translateTagSet(i3, this.pick);
        else if ("object" == typeof i3) {
          if (this.enabled = true, this.parse = false !== i3.parse, this.canBeFiltered) {
            let { pick: e4, skip: t3 } = i3;
            e4 && e4.length > 0 && this.translateTagSet(e4, this.pick), t3 && t3.length > 0 && this.translateTagSet(t3, this.skip);
          }
          this.applyInheritables(i3);
        } else
          true === i3 || false === i3 ? this.parse = this.enabled = i3 : g2("Invalid options argument: ".concat(i3));
    }
    applyInheritables(e3) {
      let t2, i3;
      for (t2 of K)
        i3 = e3[t2], void 0 !== i3 && (this[t2] = i3);
    }
    translateTagSet(e3, t2) {
      if (this.dict) {
        let i3, n3, { tagKeys: s2, tagValues: r2 } = this.dict;
        for (i3 of e3)
          "string" == typeof i3 ? (n3 = r2.indexOf(i3), -1 === n3 && (n3 = s2.indexOf(Number(i3))), -1 !== n3 && t2.add(Number(s2[n3]))) : t2.add(i3);
      } else
        for (let i3 of e3)
          t2.add(i3);
    }
    finalizeFilters() {
      !this.enabled && this.deps.size > 0 ? (this.enabled = true, ee(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && ee(this.pick, this.deps);
    }
  };
  var $2 = { jfif: false, tiff: true, xmp: false, icc: false, iptc: false, ifd0: true, ifd1: false, exif: true, gps: true, interop: false, ihdr: void 0, makerNote: false, userComment: false, multiSegment: false, skip: [], pick: [], translateKeys: true, translateValues: true, reviveValues: true, sanitize: true, mergeOutput: true, silentErrors: true, chunked: true, firstChunkSize: void 0, firstChunkSizeNode: 512, firstChunkSizeBrowser: 65536, chunkSize: 65536, chunkLimit: 5 };
  var J = /* @__PURE__ */ new Map();
  var q = class extends _ {
    static useCached(e3) {
      let t2 = J.get(e3);
      return void 0 !== t2 || (t2 = new this(e3), J.set(e3, t2)), t2;
    }
    constructor(e3) {
      super(), true === e3 ? this.setupFromTrue() : void 0 === e3 ? this.setupFromUndefined() : Array.isArray(e3) ? this.setupFromArray(e3) : "object" == typeof e3 ? this.setupFromObject(e3) : g2("Invalid options argument ".concat(e3)), void 0 === this.firstChunkSize && (this.firstChunkSize = t ? this.firstChunkSizeBrowser : this.firstChunkSizeNode), this.mergeOutput && (this.ifd1.enabled = false), this.filterNestedSegmentTags(), this.traverseTiffDependencyTree(), this.checkLoadedPlugins();
    }
    setupFromUndefined() {
      let e3;
      for (e3 of G)
        this[e3] = $2[e3];
      for (e3 of X)
        this[e3] = $2[e3];
      for (e3 of W)
        this[e3] = $2[e3];
      for (e3 of j)
        this[e3] = new Y(e3, $2[e3], void 0, this);
    }
    setupFromTrue() {
      let e3;
      for (e3 of G)
        this[e3] = $2[e3];
      for (e3 of X)
        this[e3] = $2[e3];
      for (e3 of W)
        this[e3] = true;
      for (e3 of j)
        this[e3] = new Y(e3, true, void 0, this);
    }
    setupFromArray(e3) {
      let t2;
      for (t2 of G)
        this[t2] = $2[t2];
      for (t2 of X)
        this[t2] = $2[t2];
      for (t2 of W)
        this[t2] = $2[t2];
      for (t2 of j)
        this[t2] = new Y(t2, false, void 0, this);
      this.setupGlobalFilters(e3, void 0, H);
    }
    setupFromObject(e3) {
      let t2;
      for (t2 of (H.ifd0 = H.ifd0 || H.image, H.ifd1 = H.ifd1 || H.thumbnail, Object.assign(this, e3), G))
        this[t2] = Z(e3[t2], $2[t2]);
      for (t2 of X)
        this[t2] = Z(e3[t2], $2[t2]);
      for (t2 of W)
        this[t2] = Z(e3[t2], $2[t2]);
      for (t2 of z)
        this[t2] = new Y(t2, $2[t2], e3[t2], this);
      for (t2 of H)
        this[t2] = new Y(t2, $2[t2], e3[t2], this.tiff);
      this.setupGlobalFilters(e3.pick, e3.skip, H, j), true === e3.tiff ? this.batchEnableWithBool(H, true) : false === e3.tiff ? this.batchEnableWithUserValue(H, e3) : Array.isArray(e3.tiff) ? this.setupGlobalFilters(e3.tiff, void 0, H) : "object" == typeof e3.tiff && this.setupGlobalFilters(e3.tiff.pick, e3.tiff.skip, H);
    }
    batchEnableWithBool(e3, t2) {
      for (let i3 of e3)
        this[i3].enabled = t2;
    }
    batchEnableWithUserValue(e3, t2) {
      for (let i3 of e3) {
        let e4 = t2[i3];
        this[i3].enabled = false !== e4 && void 0 !== e4;
      }
    }
    setupGlobalFilters(e3, t2, i3, n3 = i3) {
      if (e3 && e3.length) {
        for (let e4 of n3)
          this[e4].enabled = false;
        let t3 = Q(e3, i3);
        for (let [e4, i4] of t3)
          ee(this[e4].pick, i4), this[e4].enabled = true;
      } else if (t2 && t2.length) {
        let e4 = Q(t2, i3);
        for (let [t3, i4] of e4)
          ee(this[t3].skip, i4);
      }
    }
    filterNestedSegmentTags() {
      let { ifd0: e3, exif: t2, xmp: i3, iptc: n3, icc: s2 } = this;
      this.makerNote ? t2.deps.add(37500) : t2.skip.add(37500), this.userComment ? t2.deps.add(37510) : t2.skip.add(37510), i3.enabled || e3.skip.add(700), n3.enabled || e3.skip.add(33723), s2.enabled || e3.skip.add(34675);
    }
    traverseTiffDependencyTree() {
      let { ifd0: e3, exif: t2, gps: i3, interop: n3 } = this;
      n3.needed && (t2.deps.add(40965), e3.deps.add(40965)), t2.needed && e3.deps.add(34665), i3.needed && e3.deps.add(34853), this.tiff.enabled = H.some((e4) => true === this[e4].enabled) || this.makerNote || this.userComment;
      for (let e4 of H)
        this[e4].finalizeFilters();
    }
    get onlyTiff() {
      return !V.map((e3) => this[e3].enabled).some((e3) => true === e3) && this.tiff.enabled;
    }
    checkLoadedPlugins() {
      for (let e3 of z)
        this[e3].enabled && !T.has(e3) && P("segment parser", e3);
    }
  };
  function Q(e3, t2) {
    let i3, n3, s2, r2, a2 = [];
    for (s2 of t2) {
      for (r2 of (i3 = E.get(s2), n3 = [], i3))
        (e3.includes(r2[0]) || e3.includes(r2[1])) && n3.push(r2[0]);
      n3.length && a2.push([s2, n3]);
    }
    return a2;
  }
  function Z(e3, t2) {
    return void 0 !== e3 ? e3 : void 0 !== t2 ? t2 : void 0;
  }
  function ee(e3, t2) {
    for (let i3 of t2)
      e3.add(i3);
  }
  c(q, "default", $2);
  var te = class {
    constructor(e3) {
      c(this, "parsers", {}), c(this, "output", {}), c(this, "errors", []), c(this, "pushToErrors", (e4) => this.errors.push(e4)), this.options = q.useCached(e3);
    }
    async read(e3) {
      this.file = await D(e3, this.options);
    }
    setup() {
      if (this.fileParser)
        return;
      let { file: e3 } = this, t2 = e3.getUint16(0);
      for (let [i3, n3] of w)
        if (n3.canHandle(e3, t2))
          return this.fileParser = new n3(this.options, this.file, this.parsers), e3[i3] = true;
      this.file.close && this.file.close(), g2("Unknown file format");
    }
    async parse() {
      let { output: e3, errors: t2 } = this;
      return this.setup(), this.options.silentErrors ? (await this.executeParsers().catch(this.pushToErrors), t2.push(...this.fileParser.errors)) : await this.executeParsers(), this.file.close && this.file.close(), this.options.silentErrors && t2.length > 0 && (e3.errors = t2), f(e3);
    }
    async executeParsers() {
      let { output: e3 } = this;
      await this.fileParser.parse();
      let t2 = Object.values(this.parsers).map(async (t3) => {
        let i3 = await t3.parse();
        t3.assignToOutput(e3, i3);
      });
      this.options.silentErrors && (t2 = t2.map((e4) => e4.catch(this.pushToErrors))), await Promise.all(t2);
    }
    async extractThumbnail() {
      this.setup();
      let { options: e3, file: t2 } = this, i3 = T.get("tiff", e3);
      var n3;
      if (t2.tiff ? n3 = { start: 0, type: "tiff" } : t2.jpeg && (n3 = await this.fileParser.getOrFindSegment("tiff")), void 0 === n3)
        return;
      let s2 = await this.fileParser.ensureSegmentChunk(n3), r2 = this.parsers.tiff = new i3(s2, e3, t2), a2 = await r2.extractThumbnail();
      return t2.close && t2.close(), a2;
    }
  };
  async function ie(e3, t2) {
    let i3 = new te(t2);
    return await i3.read(e3), i3.parse();
  }
  var ne = Object.freeze({ __proto__: null, parse: ie, Exifr: te, fileParsers: w, segmentParsers: T, fileReaders: A, tagKeys: E, tagValues: B, tagRevivers: N, createDictionary: U, extendDictionary: F, fetchUrlAsArrayBuffer: M, readBlobAsArrayBuffer: R, chunkedProps: G, otherSegments: V, segments: z, tiffBlocks: H, segmentsAndBlocks: j, tiffExtractables: W, inheritables: K, allFormatters: X, Options: q });
  var se = class {
    constructor(e3, t2, i3) {
      c(this, "errors", []), c(this, "ensureSegmentChunk", async (e4) => {
        let t3 = e4.start, i4 = e4.size || 65536;
        if (this.file.chunked)
          if (this.file.available(t3, i4))
            e4.chunk = this.file.subarray(t3, i4);
          else
            try {
              e4.chunk = await this.file.readChunk(t3, i4);
            } catch (t4) {
              g2("Couldn't read segment: ".concat(JSON.stringify(e4), ". ").concat(t4.message));
            }
        else
          this.file.byteLength > t3 + i4 ? e4.chunk = this.file.subarray(t3, i4) : void 0 === e4.size ? e4.chunk = this.file.subarray(t3) : g2("Segment unreachable: " + JSON.stringify(e4));
        return e4.chunk;
      }), this.extendOptions && this.extendOptions(e3), this.options = e3, this.file = t2, this.parsers = i3;
    }
    injectSegment(e3, t2) {
      this.options[e3].enabled && this.createParser(e3, t2);
    }
    createParser(e3, t2) {
      let i3 = new (T.get(e3))(t2, this.options, this.file);
      return this.parsers[e3] = i3;
    }
    createParsers(e3) {
      for (let t2 of e3) {
        let { type: e4, chunk: i3 } = t2, n3 = this.options[e4];
        if (n3 && n3.enabled) {
          let t3 = this.parsers[e4];
          t3 && t3.append || t3 || this.createParser(e4, i3);
        }
      }
    }
    async readSegments(e3) {
      let t2 = e3.map(this.ensureSegmentChunk);
      await Promise.all(t2);
    }
  };
  var re2 = class {
    static findPosition(e3, t2) {
      let i3 = e3.getUint16(t2 + 2) + 2, n3 = "function" == typeof this.headerLength ? this.headerLength(e3, t2, i3) : this.headerLength, s2 = t2 + n3, r2 = i3 - n3;
      return { offset: t2, length: i3, headerLength: n3, start: s2, size: r2, end: s2 + r2 };
    }
    static parse(e3, t2 = {}) {
      return new this(e3, new q({ [this.type]: t2 }), e3).parse();
    }
    normalizeInput(e3) {
      return e3 instanceof I ? e3 : new I(e3);
    }
    constructor(e3, t2 = {}, i3) {
      c(this, "errors", []), c(this, "raw", /* @__PURE__ */ new Map()), c(this, "handleError", (e4) => {
        if (!this.options.silentErrors)
          throw e4;
        this.errors.push(e4.message);
      }), this.chunk = this.normalizeInput(e3), this.file = i3, this.type = this.constructor.type, this.globalOptions = this.options = t2, this.localOptions = t2[this.type], this.canTranslate = this.localOptions && this.localOptions.translate;
    }
    translate() {
      this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type));
    }
    get output() {
      return this.translated ? this.translated : this.raw ? Object.fromEntries(this.raw) : void 0;
    }
    translateBlock(e3, t2) {
      let i3 = N.get(t2), n3 = B.get(t2), s2 = E.get(t2), r2 = this.options[t2], a2 = r2.reviveValues && !!i3, o2 = r2.translateValues && !!n3, l2 = r2.translateKeys && !!s2, h2 = {};
      for (let [t3, r3] of e3)
        a2 && i3.has(t3) ? r3 = i3.get(t3)(r3) : o2 && n3.has(t3) && (r3 = this.translateValue(r3, n3.get(t3))), l2 && s2.has(t3) && (t3 = s2.get(t3) || t3), h2[t3] = r3;
      return h2;
    }
    translateValue(e3, t2) {
      return t2[e3] || t2.DEFAULT || e3;
    }
    assignToOutput(e3, t2) {
      this.assignObjectToOutput(e3, this.constructor.type, t2);
    }
    assignObjectToOutput(e3, t2, i3) {
      if (this.globalOptions.mergeOutput)
        return Object.assign(e3, i3);
      e3[t2] ? Object.assign(e3[t2], i3) : e3[t2] = i3;
    }
  };
  c(re2, "headerLength", 4), c(re2, "type", void 0), c(re2, "multiSegment", false), c(re2, "canHandle", () => false);
  function ae(e3) {
    return 192 === e3 || 194 === e3 || 196 === e3 || 219 === e3 || 221 === e3 || 218 === e3 || 254 === e3;
  }
  function oe(e3) {
    return e3 >= 224 && e3 <= 239;
  }
  function le(e3, t2, i3) {
    for (let [n3, s2] of T)
      if (s2.canHandle(e3, t2, i3))
        return n3;
  }
  var he = class extends se {
    constructor(...e3) {
      super(...e3), c(this, "appSegments", []), c(this, "jpegSegments", []), c(this, "unknownSegments", []);
    }
    static canHandle(e3, t2) {
      return 65496 === t2;
    }
    async parse() {
      await this.findAppSegments(), await this.readSegments(this.appSegments), this.mergeMultiSegments(), this.createParsers(this.mergedAppSegments || this.appSegments);
    }
    setupSegmentFinderArgs(e3) {
      true === e3 ? (this.findAll = true, this.wanted = new Set(T.keyList())) : (e3 = void 0 === e3 ? T.keyList().filter((e4) => this.options[e4].enabled) : e3.filter((e4) => this.options[e4].enabled && T.has(e4)), this.findAll = false, this.remaining = new Set(e3), this.wanted = new Set(e3)), this.unfinishedMultiSegment = false;
    }
    async findAppSegments(e3 = 0, t2) {
      this.setupSegmentFinderArgs(t2);
      let { file: i3, findAll: n3, wanted: s2, remaining: r2 } = this;
      if (!n3 && this.file.chunked && (n3 = Array.from(s2).some((e4) => {
        let t3 = T.get(e4), i4 = this.options[e4];
        return t3.multiSegment && i4.multiSegment;
      }), n3 && await this.file.readWhole()), e3 = this.findAppSegmentsInRange(e3, i3.byteLength), !this.options.onlyTiff && i3.chunked) {
        let t3 = false;
        for (; r2.size > 0 && !t3 && (i3.canReadNextChunk || this.unfinishedMultiSegment); ) {
          let { nextChunkOffset: n4 } = i3, s3 = this.appSegments.some((e4) => !this.file.available(e4.offset || e4.start, e4.length || e4.size));
          if (t3 = e3 > n4 && !s3 ? !await i3.readNextChunk(e3) : !await i3.readNextChunk(n4), void 0 === (e3 = this.findAppSegmentsInRange(e3, i3.byteLength)))
            return;
        }
      }
    }
    findAppSegmentsInRange(e3, t2) {
      t2 -= 2;
      let i3, n3, s2, r2, a2, o2, { file: l2, findAll: h2, wanted: u2, remaining: c2, options: f2 } = this;
      for (; e3 < t2; e3++)
        if (255 === l2.getUint8(e3)) {
          if (i3 = l2.getUint8(e3 + 1), oe(i3)) {
            if (n3 = l2.getUint16(e3 + 2), s2 = le(l2, e3, n3), s2 && u2.has(s2) && (r2 = T.get(s2), a2 = r2.findPosition(l2, e3), o2 = f2[s2], a2.type = s2, this.appSegments.push(a2), !h2 && (r2.multiSegment && o2.multiSegment ? (this.unfinishedMultiSegment = a2.chunkNumber < a2.chunkCount, this.unfinishedMultiSegment || c2.delete(s2)) : c2.delete(s2), 0 === c2.size)))
              break;
            f2.recordUnknownSegments && (a2 = re2.findPosition(l2, e3), a2.marker = i3, this.unknownSegments.push(a2)), e3 += n3 + 1;
          } else if (ae(i3)) {
            if (n3 = l2.getUint16(e3 + 2), 218 === i3 && false !== f2.stopAfterSos)
              return;
            f2.recordJpegSegments && this.jpegSegments.push({ offset: e3, length: n3, marker: i3 }), e3 += n3 + 1;
          }
        }
      return e3;
    }
    mergeMultiSegments() {
      if (!this.appSegments.some((e4) => e4.multiSegment))
        return;
      let e3 = function(e4, t2) {
        let i3, n3, s2, r2 = /* @__PURE__ */ new Map();
        for (let a2 = 0; a2 < e4.length; a2++)
          i3 = e4[a2], n3 = i3[t2], r2.has(n3) ? s2 = r2.get(n3) : r2.set(n3, s2 = []), s2.push(i3);
        return Array.from(r2);
      }(this.appSegments, "type");
      this.mergedAppSegments = e3.map(([e4, t2]) => {
        let i3 = T.get(e4, this.options);
        if (i3.handleMultiSegments) {
          return { type: e4, chunk: i3.handleMultiSegments(t2) };
        }
        return t2[0];
      });
    }
    getSegment(e3) {
      return this.appSegments.find((t2) => t2.type === e3);
    }
    async getOrFindSegment(e3) {
      let t2 = this.getSegment(e3);
      return void 0 === t2 && (await this.findAppSegments(0, [e3]), t2 = this.getSegment(e3)), t2;
    }
  };
  c(he, "type", "jpeg"), w.set("jpeg", he);
  var ue = [void 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 4];
  var ce = class extends re2 {
    parseHeader() {
      var e3 = this.chunk.getUint16();
      18761 === e3 ? this.le = true : 19789 === e3 && (this.le = false), this.chunk.le = this.le, this.headerParsed = true;
    }
    parseTags(e3, t2, i3 = /* @__PURE__ */ new Map()) {
      let { pick: n3, skip: s2 } = this.options[t2];
      n3 = new Set(n3);
      let r2 = n3.size > 0, a2 = 0 === s2.size, o2 = this.chunk.getUint16(e3);
      e3 += 2;
      for (let l2 = 0; l2 < o2; l2++) {
        let o3 = this.chunk.getUint16(e3);
        if (r2) {
          if (n3.has(o3) && (i3.set(o3, this.parseTag(e3, o3, t2)), n3.delete(o3), 0 === n3.size))
            break;
        } else
          !a2 && s2.has(o3) || i3.set(o3, this.parseTag(e3, o3, t2));
        e3 += 12;
      }
      return i3;
    }
    parseTag(e3, t2, i3) {
      let { chunk: n3 } = this, s2 = n3.getUint16(e3 + 2), r2 = n3.getUint32(e3 + 4), a2 = ue[s2];
      if (a2 * r2 <= 4 ? e3 += 8 : e3 = n3.getUint32(e3 + 8), (s2 < 1 || s2 > 13) && g2("Invalid TIFF value type. block: ".concat(i3.toUpperCase(), ", tag: ").concat(t2.toString(16), ", type: ").concat(s2, ", offset ").concat(e3)), e3 > n3.byteLength && g2("Invalid TIFF value offset. block: ".concat(i3.toUpperCase(), ", tag: ").concat(t2.toString(16), ", type: ").concat(s2, ", offset ").concat(e3, " is outside of chunk size ").concat(n3.byteLength)), 1 === s2)
        return n3.getUint8Array(e3, r2);
      if (2 === s2)
        return m(n3.getString(e3, r2));
      if (7 === s2)
        return n3.getUint8Array(e3, r2);
      if (1 === r2)
        return this.parseTagValue(s2, e3);
      {
        let t3 = new (function(e4) {
          switch (e4) {
            case 1:
              return Uint8Array;
            case 3:
              return Uint16Array;
            case 4:
              return Uint32Array;
            case 5:
              return Array;
            case 6:
              return Int8Array;
            case 8:
              return Int16Array;
            case 9:
              return Int32Array;
            case 10:
              return Array;
            case 11:
              return Float32Array;
            case 12:
              return Float64Array;
            default:
              return Array;
          }
        }(s2))(r2), i4 = a2;
        for (let n4 = 0; n4 < r2; n4++)
          t3[n4] = this.parseTagValue(s2, e3), e3 += i4;
        return t3;
      }
    }
    parseTagValue(e3, t2) {
      let { chunk: i3 } = this;
      switch (e3) {
        case 1:
          return i3.getUint8(t2);
        case 3:
          return i3.getUint16(t2);
        case 4:
          return i3.getUint32(t2);
        case 5:
          return i3.getUint32(t2) / i3.getUint32(t2 + 4);
        case 6:
          return i3.getInt8(t2);
        case 8:
          return i3.getInt16(t2);
        case 9:
          return i3.getInt32(t2);
        case 10:
          return i3.getInt32(t2) / i3.getInt32(t2 + 4);
        case 11:
          return i3.getFloat(t2);
        case 12:
          return i3.getDouble(t2);
        case 13:
          return i3.getUint32(t2);
        default:
          g2("Invalid tiff type ".concat(e3));
      }
    }
  };
  var fe = class extends ce {
    static canHandle(e3, t2) {
      return 225 === e3.getUint8(t2 + 1) && 1165519206 === e3.getUint32(t2 + 4) && 0 === e3.getUint16(t2 + 8);
    }
    async parse() {
      this.parseHeader();
      let { options: e3 } = this;
      return e3.ifd0.enabled && await this.parseIfd0Block(), e3.exif.enabled && await this.safeParse("parseExifBlock"), e3.gps.enabled && await this.safeParse("parseGpsBlock"), e3.interop.enabled && await this.safeParse("parseInteropBlock"), e3.ifd1.enabled && await this.safeParse("parseThumbnailBlock"), this.createOutput();
    }
    safeParse(e3) {
      let t2 = this[e3]();
      return void 0 !== t2.catch && (t2 = t2.catch(this.handleError)), t2;
    }
    findIfd0Offset() {
      void 0 === this.ifd0Offset && (this.ifd0Offset = this.chunk.getUint32(4));
    }
    findIfd1Offset() {
      if (void 0 === this.ifd1Offset) {
        this.findIfd0Offset();
        let e3 = this.chunk.getUint16(this.ifd0Offset), t2 = this.ifd0Offset + 2 + 12 * e3;
        this.ifd1Offset = this.chunk.getUint32(t2);
      }
    }
    parseBlock(e3, t2) {
      let i3 = /* @__PURE__ */ new Map();
      return this[t2] = i3, this.parseTags(e3, t2, i3), i3;
    }
    async parseIfd0Block() {
      if (this.ifd0)
        return;
      let { file: e3 } = this;
      this.findIfd0Offset(), this.ifd0Offset < 8 && g2("Malformed EXIF data"), !e3.chunked && this.ifd0Offset > e3.byteLength && g2("IFD0 offset points to outside of file.\nthis.ifd0Offset: ".concat(this.ifd0Offset, ", file.byteLength: ").concat(e3.byteLength)), e3.tiff && await e3.ensureChunk(this.ifd0Offset, S(this.options));
      let t2 = this.parseBlock(this.ifd0Offset, "ifd0");
      return 0 !== t2.size ? (this.exifOffset = t2.get(34665), this.interopOffset = t2.get(40965), this.gpsOffset = t2.get(34853), this.xmp = t2.get(700), this.iptc = t2.get(33723), this.icc = t2.get(34675), this.options.sanitize && (t2.delete(34665), t2.delete(40965), t2.delete(34853), t2.delete(700), t2.delete(33723), t2.delete(34675)), t2) : void 0;
    }
    async parseExifBlock() {
      if (this.exif)
        return;
      if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.exifOffset)
        return;
      this.file.tiff && await this.file.ensureChunk(this.exifOffset, S(this.options));
      let e3 = this.parseBlock(this.exifOffset, "exif");
      return this.interopOffset || (this.interopOffset = e3.get(40965)), this.makerNote = e3.get(37500), this.userComment = e3.get(37510), this.options.sanitize && (e3.delete(40965), e3.delete(37500), e3.delete(37510)), this.unpack(e3, 41728), this.unpack(e3, 41729), e3;
    }
    unpack(e3, t2) {
      let i3 = e3.get(t2);
      i3 && 1 === i3.length && e3.set(t2, i3[0]);
    }
    async parseGpsBlock() {
      if (this.gps)
        return;
      if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.gpsOffset)
        return;
      let e3 = this.parseBlock(this.gpsOffset, "gps");
      return e3 && e3.has(2) && e3.has(4) && (e3.set("latitude", de(...e3.get(2), e3.get(1))), e3.set("longitude", de(...e3.get(4), e3.get(3)))), e3;
    }
    async parseInteropBlock() {
      if (!this.interop && (this.ifd0 || await this.parseIfd0Block(), void 0 !== this.interopOffset || this.exif || await this.parseExifBlock(), void 0 !== this.interopOffset))
        return this.parseBlock(this.interopOffset, "interop");
    }
    async parseThumbnailBlock(e3 = false) {
      if (!this.ifd1 && !this.ifd1Parsed && (!this.options.mergeOutput || e3))
        return this.findIfd1Offset(), this.ifd1Offset > 0 && (this.parseBlock(this.ifd1Offset, "ifd1"), this.ifd1Parsed = true), this.ifd1;
    }
    async extractThumbnail() {
      if (this.headerParsed || this.parseHeader(), this.ifd1Parsed || await this.parseThumbnailBlock(true), void 0 === this.ifd1)
        return;
      let e3 = this.ifd1.get(513), t2 = this.ifd1.get(514);
      return this.chunk.getUint8Array(e3, t2);
    }
    get image() {
      return this.ifd0;
    }
    get thumbnail() {
      return this.ifd1;
    }
    createOutput() {
      let e3, t2, i3, n3 = {};
      for (t2 of H)
        if (e3 = this[t2], !p(e3))
          if (i3 = this.canTranslate ? this.translateBlock(e3, t2) : Object.fromEntries(e3), this.options.mergeOutput) {
            if ("ifd1" === t2)
              continue;
            Object.assign(n3, i3);
          } else
            n3[t2] = i3;
      return this.makerNote && (n3.makerNote = this.makerNote), this.userComment && (n3.userComment = this.userComment), n3;
    }
    assignToOutput(e3, t2) {
      if (this.globalOptions.mergeOutput)
        Object.assign(e3, t2);
      else
        for (let [i3, n3] of Object.entries(t2))
          this.assignObjectToOutput(e3, i3, n3);
    }
  };
  function de(e3, t2, i3, n3) {
    var s2 = e3 + t2 / 60 + i3 / 3600;
    return "S" !== n3 && "W" !== n3 || (s2 *= -1), s2;
  }
  c(fe, "type", "tiff"), c(fe, "headerLength", 10), T.set("tiff", fe);
  var pe = Object.freeze({ __proto__: null, default: ne, Exifr: te, fileParsers: w, segmentParsers: T, fileReaders: A, tagKeys: E, tagValues: B, tagRevivers: N, createDictionary: U, extendDictionary: F, fetchUrlAsArrayBuffer: M, readBlobAsArrayBuffer: R, chunkedProps: G, otherSegments: V, segments: z, tiffBlocks: H, segmentsAndBlocks: j, tiffExtractables: W, inheritables: K, allFormatters: X, Options: q, parse: ie });
  var ge = { ifd0: false, ifd1: false, exif: false, gps: false, interop: false, sanitize: false, reviveValues: true, translateKeys: false, translateValues: false, mergeOutput: false };
  var me = Object.assign({}, ge, { firstChunkSize: 4e4, gps: [1, 2, 3, 4] });
  async function Se(e3) {
    let t2 = new te(me);
    await t2.read(e3);
    let i3 = await t2.parse();
    if (i3 && i3.gps) {
      let { latitude: e4, longitude: t3 } = i3.gps;
      return { latitude: e4, longitude: t3 };
    }
  }
  var Ce = Object.assign({}, ge, { tiff: false, ifd1: true, mergeOutput: false });
  async function ye(e3) {
    let t2 = new te(Ce);
    await t2.read(e3);
    let i3 = await t2.extractThumbnail();
    return i3 && a ? s.from(i3) : i3;
  }
  async function be(e3) {
    let t2 = await this.thumbnail(e3);
    if (void 0 !== t2) {
      let e4 = new Blob([t2]);
      return URL.createObjectURL(e4);
    }
  }
  var Ie = Object.assign({}, ge, { firstChunkSize: 4e4, ifd0: [274] });
  async function Pe(e3) {
    let t2 = new te(Ie);
    await t2.read(e3);
    let i3 = await t2.parse();
    if (i3 && i3.ifd0)
      return i3.ifd0[274];
  }
  var ke = Object.freeze({ 1: { dimensionSwapped: false, scaleX: 1, scaleY: 1, deg: 0, rad: 0 }, 2: { dimensionSwapped: false, scaleX: -1, scaleY: 1, deg: 0, rad: 0 }, 3: { dimensionSwapped: false, scaleX: 1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 4: { dimensionSwapped: false, scaleX: -1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 5: { dimensionSwapped: true, scaleX: 1, scaleY: -1, deg: 90, rad: 90 * Math.PI / 180 }, 6: { dimensionSwapped: true, scaleX: 1, scaleY: 1, deg: 90, rad: 90 * Math.PI / 180 }, 7: { dimensionSwapped: true, scaleX: 1, scaleY: -1, deg: 270, rad: 270 * Math.PI / 180 }, 8: { dimensionSwapped: true, scaleX: 1, scaleY: 1, deg: 270, rad: 270 * Math.PI / 180 } });
  var we = true;
  var Te = true;
  if ("object" == typeof navigator) {
    let e3 = navigator.userAgent;
    if (e3.includes("iPad") || e3.includes("iPhone")) {
      let t2 = e3.match(/OS (\d+)_(\d+)/);
      if (t2) {
        let [, e4, i3] = t2, n3 = Number(e4) + 0.1 * Number(i3);
        we = n3 < 13.4, Te = false;
      }
    } else if (e3.includes("OS X 10")) {
      let [, t2] = e3.match(/OS X 10[_.](\d+)/);
      we = Te = Number(t2) < 15;
    }
    if (e3.includes("Chrome/")) {
      let [, t2] = e3.match(/Chrome\/(\d+)/);
      we = Te = Number(t2) < 81;
    } else if (e3.includes("Firefox/")) {
      let [, t2] = e3.match(/Firefox\/(\d+)/);
      we = Te = Number(t2) < 77;
    }
  }
  async function Ae(e3) {
    let t2 = await Pe(e3);
    return Object.assign({ canvas: we, css: Te }, ke[t2]);
  }
  var De = class extends I {
    constructor(...e3) {
      super(...e3), c(this, "ranges", new Oe()), 0 !== this.byteLength && this.ranges.add(0, this.byteLength);
    }
    _tryExtend(e3, t2, i3) {
      if (0 === e3 && 0 === this.byteLength && i3) {
        let e4 = new DataView(i3.buffer || i3, i3.byteOffset, i3.byteLength);
        this._swapDataView(e4);
      } else {
        let i4 = e3 + t2;
        if (i4 > this.byteLength) {
          let { dataView: e4 } = this._extend(i4);
          this._swapDataView(e4);
        }
      }
    }
    _extend(e3) {
      let t2;
      t2 = a ? s.allocUnsafe(e3) : new Uint8Array(e3);
      let i3 = new DataView(t2.buffer, t2.byteOffset, t2.byteLength);
      return t2.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), { uintView: t2, dataView: i3 };
    }
    subarray(e3, t2, i3 = false) {
      return t2 = t2 || this._lengthToEnd(e3), i3 && this._tryExtend(e3, t2), this.ranges.add(e3, t2), super.subarray(e3, t2);
    }
    set(e3, t2, i3 = false) {
      i3 && this._tryExtend(t2, e3.byteLength, e3);
      let n3 = super.set(e3, t2);
      return this.ranges.add(t2, n3.byteLength), n3;
    }
    async ensureChunk(e3, t2) {
      this.chunked && (this.ranges.available(e3, t2) || await this.readChunk(e3, t2));
    }
    available(e3, t2) {
      return this.ranges.available(e3, t2);
    }
  };
  var Oe = class {
    constructor() {
      c(this, "list", []);
    }
    get length() {
      return this.list.length;
    }
    add(e3, t2, i3 = 0) {
      let n3 = e3 + t2, s2 = this.list.filter((t3) => xe(e3, t3.offset, n3) || xe(e3, t3.end, n3));
      if (s2.length > 0) {
        e3 = Math.min(e3, ...s2.map((e4) => e4.offset)), n3 = Math.max(n3, ...s2.map((e4) => e4.end)), t2 = n3 - e3;
        let i4 = s2.shift();
        i4.offset = e3, i4.length = t2, i4.end = n3, this.list = this.list.filter((e4) => !s2.includes(e4));
      } else
        this.list.push({ offset: e3, length: t2, end: n3 });
    }
    available(e3, t2) {
      let i3 = e3 + t2;
      return this.list.some((t3) => t3.offset <= e3 && i3 <= t3.end);
    }
  };
  function xe(e3, t2, i3) {
    return e3 <= t2 && t2 <= i3;
  }
  var ve = class extends De {
    constructor(e3, t2) {
      super(0), c(this, "chunksRead", 0), this.input = e3, this.options = t2;
    }
    async readWhole() {
      this.chunked = false, await this.readChunk(this.nextChunkOffset);
    }
    async readChunked() {
      this.chunked = true, await this.readChunk(0, this.options.firstChunkSize);
    }
    async readNextChunk(e3 = this.nextChunkOffset) {
      if (this.fullyRead)
        return this.chunksRead++, false;
      let t2 = this.options.chunkSize, i3 = await this.readChunk(e3, t2);
      return !!i3 && i3.byteLength === t2;
    }
    async readChunk(e3, t2) {
      if (this.chunksRead++, 0 !== (t2 = this.safeWrapAddress(e3, t2)))
        return this._readChunk(e3, t2);
    }
    safeWrapAddress(e3, t2) {
      return void 0 !== this.size && e3 + t2 > this.size ? Math.max(0, this.size - e3) : t2;
    }
    get nextChunkOffset() {
      if (0 !== this.ranges.list.length)
        return this.ranges.list[0].length;
    }
    get canReadNextChunk() {
      return this.chunksRead < this.options.chunkLimit;
    }
    get fullyRead() {
      return void 0 !== this.size && this.nextChunkOffset === this.size;
    }
    read() {
      return this.options.chunked ? this.readChunked() : this.readWhole();
    }
    close() {
    }
  };
  A.set("blob", class extends ve {
    async readWhole() {
      this.chunked = false;
      let e3 = await R(this.input);
      this._swapArrayBuffer(e3);
    }
    readChunked() {
      return this.chunked = true, this.size = this.input.size, super.readChunked();
    }
    async _readChunk(e3, t2) {
      let i3 = t2 ? e3 + t2 : void 0, n3 = this.input.slice(e3, i3), s2 = await R(n3);
      return this.set(s2, e3, true);
    }
  });
  var Me = Object.freeze({ __proto__: null, default: pe, Exifr: te, fileParsers: w, segmentParsers: T, fileReaders: A, tagKeys: E, tagValues: B, tagRevivers: N, createDictionary: U, extendDictionary: F, fetchUrlAsArrayBuffer: M, readBlobAsArrayBuffer: R, chunkedProps: G, otherSegments: V, segments: z, tiffBlocks: H, segmentsAndBlocks: j, tiffExtractables: W, inheritables: K, allFormatters: X, Options: q, parse: ie, gpsOnlyOptions: me, gps: Se, thumbnailOnlyOptions: Ce, thumbnail: ye, thumbnailUrl: be, orientationOnlyOptions: Ie, orientation: Pe, rotations: ke, get rotateCanvas() {
    return we;
  }, get rotateCss() {
    return Te;
  }, rotation: Ae });
  A.set("url", class extends ve {
    async readWhole() {
      this.chunked = false;
      let e3 = await M(this.input);
      e3 instanceof ArrayBuffer ? this._swapArrayBuffer(e3) : e3 instanceof Uint8Array && this._swapBuffer(e3);
    }
    async _readChunk(e3, t2) {
      let i3 = t2 ? e3 + t2 - 1 : void 0, n3 = this.options.httpHeaders || {};
      (e3 || i3) && (n3.range = "bytes=".concat([e3, i3].join("-")));
      let s2 = await h(this.input, { headers: n3 }), r2 = await s2.arrayBuffer(), a2 = r2.byteLength;
      if (416 !== s2.status)
        return a2 !== t2 && (this.size = e3 + a2), this.set(r2, e3, true);
    }
  });
  I.prototype.getUint64 = function(e3) {
    let t2 = this.getUint32(e3), i3 = this.getUint32(e3 + 4);
    return t2 < 1048575 ? t2 << 32 | i3 : void 0 !== typeof r ? (console.warn("Using BigInt because of type 64uint but JS can only handle 53b numbers."), r(t2) << r(32) | r(i3)) : void g2("Trying to read 64b value but JS can only handle 53b numbers.");
  };
  var Re = class extends se {
    parseBoxes(e3 = 0) {
      let t2 = [];
      for (; e3 < this.file.byteLength - 4; ) {
        let i3 = this.parseBoxHead(e3);
        if (t2.push(i3), 0 === i3.length)
          break;
        e3 += i3.length;
      }
      return t2;
    }
    parseSubBoxes(e3) {
      e3.boxes = this.parseBoxes(e3.start);
    }
    findBox(e3, t2) {
      return void 0 === e3.boxes && this.parseSubBoxes(e3), e3.boxes.find((e4) => e4.kind === t2);
    }
    parseBoxHead(e3) {
      let t2 = this.file.getUint32(e3), i3 = this.file.getString(e3 + 4, 4), n3 = e3 + 8;
      return 1 === t2 && (t2 = this.file.getUint64(e3 + 8), n3 += 8), { offset: e3, length: t2, kind: i3, start: n3 };
    }
    parseBoxFullHead(e3) {
      if (void 0 !== e3.version)
        return;
      let t2 = this.file.getUint32(e3.start);
      e3.version = t2 >> 24, e3.start += 4;
    }
  };
  var Le = class extends Re {
    static canHandle(e3, t2) {
      if (0 !== t2)
        return false;
      let i3 = e3.getUint16(2);
      if (i3 > 50)
        return false;
      let n3 = 16, s2 = [];
      for (; n3 < i3; )
        s2.push(e3.getString(n3, 4)), n3 += 4;
      return s2.includes(this.type);
    }
    async parse() {
      let e3 = this.file.getUint32(0), t2 = this.parseBoxHead(e3);
      for (; "meta" !== t2.kind; )
        e3 += t2.length, await this.file.ensureChunk(e3, 16), t2 = this.parseBoxHead(e3);
      await this.file.ensureChunk(t2.offset, t2.length), this.parseBoxFullHead(t2), this.parseSubBoxes(t2), this.options.icc.enabled && await this.findIcc(t2), this.options.tiff.enabled && await this.findExif(t2);
    }
    async registerSegment(e3, t2, i3) {
      await this.file.ensureChunk(t2, i3);
      let n3 = this.file.subarray(t2, i3);
      this.createParser(e3, n3);
    }
    async findIcc(e3) {
      let t2 = this.findBox(e3, "iprp");
      if (void 0 === t2)
        return;
      let i3 = this.findBox(t2, "ipco");
      if (void 0 === i3)
        return;
      let n3 = this.findBox(i3, "colr");
      void 0 !== n3 && await this.registerSegment("icc", n3.offset + 12, n3.length);
    }
    async findExif(e3) {
      let t2 = this.findBox(e3, "iinf");
      if (void 0 === t2)
        return;
      let i3 = this.findBox(e3, "iloc");
      if (void 0 === i3)
        return;
      let n3 = this.findExifLocIdInIinf(t2), s2 = this.findExtentInIloc(i3, n3);
      if (void 0 === s2)
        return;
      let [r2, a2] = s2;
      await this.file.ensureChunk(r2, a2);
      let o2 = 4 + this.file.getUint32(r2);
      r2 += o2, a2 -= o2, await this.registerSegment("tiff", r2, a2);
    }
    findExifLocIdInIinf(e3) {
      this.parseBoxFullHead(e3);
      let t2, i3, n3, s2, r2 = e3.start, a2 = this.file.getUint16(r2);
      for (r2 += 2; a2--; ) {
        if (t2 = this.parseBoxHead(r2), this.parseBoxFullHead(t2), i3 = t2.start, t2.version >= 2 && (n3 = 3 === t2.version ? 4 : 2, s2 = this.file.getString(i3 + n3 + 2, 4), "Exif" === s2))
          return this.file.getUintBytes(i3, n3);
        r2 += t2.length;
      }
    }
    get8bits(e3) {
      let t2 = this.file.getUint8(e3);
      return [t2 >> 4, 15 & t2];
    }
    findExtentInIloc(e3, t2) {
      this.parseBoxFullHead(e3);
      let i3 = e3.start, [n3, s2] = this.get8bits(i3++), [r2, a2] = this.get8bits(i3++), o2 = 2 === e3.version ? 4 : 2, l2 = 1 === e3.version || 2 === e3.version ? 2 : 0, h2 = a2 + n3 + s2, u2 = 2 === e3.version ? 4 : 2, c2 = this.file.getUintBytes(i3, u2);
      for (i3 += u2; c2--; ) {
        let e4 = this.file.getUintBytes(i3, o2);
        i3 += o2 + l2 + 2 + r2;
        let u3 = this.file.getUint16(i3);
        if (i3 += 2, e4 === t2)
          return u3 > 1 && console.warn("ILOC box has more than one extent but we're only processing one\nPlease create an issue at https://github.com/MikeKovarik/exifr with this file"), [this.file.getUintBytes(i3 + a2, n3), this.file.getUintBytes(i3 + a2 + n3, s2)];
        i3 += u3 * h2;
      }
    }
  };
  var Ue = class extends Le {
  };
  c(Ue, "type", "heic");
  var Fe = class extends Le {
  };
  c(Fe, "type", "avif"), w.set("heic", Ue), w.set("avif", Fe), U(E, ["ifd0", "ifd1"], [[256, "ImageWidth"], [257, "ImageHeight"], [258, "BitsPerSample"], [259, "Compression"], [262, "PhotometricInterpretation"], [270, "ImageDescription"], [271, "Make"], [272, "Model"], [273, "StripOffsets"], [274, "Orientation"], [277, "SamplesPerPixel"], [278, "RowsPerStrip"], [279, "StripByteCounts"], [282, "XResolution"], [283, "YResolution"], [284, "PlanarConfiguration"], [296, "ResolutionUnit"], [301, "TransferFunction"], [305, "Software"], [306, "ModifyDate"], [315, "Artist"], [316, "HostComputer"], [317, "Predictor"], [318, "WhitePoint"], [319, "PrimaryChromaticities"], [513, "ThumbnailOffset"], [514, "ThumbnailLength"], [529, "YCbCrCoefficients"], [530, "YCbCrSubSampling"], [531, "YCbCrPositioning"], [532, "ReferenceBlackWhite"], [700, "ApplicationNotes"], [33432, "Copyright"], [33723, "IPTC"], [34665, "ExifIFD"], [34675, "ICC"], [34853, "GpsIFD"], [330, "SubIFD"], [40965, "InteropIFD"], [40091, "XPTitle"], [40092, "XPComment"], [40093, "XPAuthor"], [40094, "XPKeywords"], [40095, "XPSubject"]]), U(E, "exif", [[33434, "ExposureTime"], [33437, "FNumber"], [34850, "ExposureProgram"], [34852, "SpectralSensitivity"], [34855, "ISO"], [34858, "TimeZoneOffset"], [34859, "SelfTimerMode"], [34864, "SensitivityType"], [34865, "StandardOutputSensitivity"], [34866, "RecommendedExposureIndex"], [34867, "ISOSpeed"], [34868, "ISOSpeedLatitudeyyy"], [34869, "ISOSpeedLatitudezzz"], [36864, "ExifVersion"], [36867, "DateTimeOriginal"], [36868, "CreateDate"], [36873, "GooglePlusUploadCode"], [36880, "OffsetTime"], [36881, "OffsetTimeOriginal"], [36882, "OffsetTimeDigitized"], [37121, "ComponentsConfiguration"], [37122, "CompressedBitsPerPixel"], [37377, "ShutterSpeedValue"], [37378, "ApertureValue"], [37379, "BrightnessValue"], [37380, "ExposureCompensation"], [37381, "MaxApertureValue"], [37382, "SubjectDistance"], [37383, "MeteringMode"], [37384, "LightSource"], [37385, "Flash"], [37386, "FocalLength"], [37393, "ImageNumber"], [37394, "SecurityClassification"], [37395, "ImageHistory"], [37396, "SubjectArea"], [37500, "MakerNote"], [37510, "UserComment"], [37520, "SubSecTime"], [37521, "SubSecTimeOriginal"], [37522, "SubSecTimeDigitized"], [37888, "AmbientTemperature"], [37889, "Humidity"], [37890, "Pressure"], [37891, "WaterDepth"], [37892, "Acceleration"], [37893, "CameraElevationAngle"], [40960, "FlashpixVersion"], [40961, "ColorSpace"], [40962, "ExifImageWidth"], [40963, "ExifImageHeight"], [40964, "RelatedSoundFile"], [41483, "FlashEnergy"], [41486, "FocalPlaneXResolution"], [41487, "FocalPlaneYResolution"], [41488, "FocalPlaneResolutionUnit"], [41492, "SubjectLocation"], [41493, "ExposureIndex"], [41495, "SensingMethod"], [41728, "FileSource"], [41729, "SceneType"], [41730, "CFAPattern"], [41985, "CustomRendered"], [41986, "ExposureMode"], [41987, "WhiteBalance"], [41988, "DigitalZoomRatio"], [41989, "FocalLengthIn35mmFormat"], [41990, "SceneCaptureType"], [41991, "GainControl"], [41992, "Contrast"], [41993, "Saturation"], [41994, "Sharpness"], [41996, "SubjectDistanceRange"], [42016, "ImageUniqueID"], [42032, "OwnerName"], [42033, "SerialNumber"], [42034, "LensInfo"], [42035, "LensMake"], [42036, "LensModel"], [42037, "LensSerialNumber"], [42080, "CompositeImage"], [42081, "CompositeImageCount"], [42082, "CompositeImageExposureTimes"], [42240, "Gamma"], [59932, "Padding"], [59933, "OffsetSchema"], [65e3, "OwnerName"], [65001, "SerialNumber"], [65002, "Lens"], [65100, "RawFile"], [65101, "Converter"], [65102, "WhiteBalance"], [65105, "Exposure"], [65106, "Shadows"], [65107, "Brightness"], [65108, "Contrast"], [65109, "Saturation"], [65110, "Sharpness"], [65111, "Smoothness"], [65112, "MoireFilter"], [40965, "InteropIFD"]]), U(E, "gps", [[0, "GPSVersionID"], [1, "GPSLatitudeRef"], [2, "GPSLatitude"], [3, "GPSLongitudeRef"], [4, "GPSLongitude"], [5, "GPSAltitudeRef"], [6, "GPSAltitude"], [7, "GPSTimeStamp"], [8, "GPSSatellites"], [9, "GPSStatus"], [10, "GPSMeasureMode"], [11, "GPSDOP"], [12, "GPSSpeedRef"], [13, "GPSSpeed"], [14, "GPSTrackRef"], [15, "GPSTrack"], [16, "GPSImgDirectionRef"], [17, "GPSImgDirection"], [18, "GPSMapDatum"], [19, "GPSDestLatitudeRef"], [20, "GPSDestLatitude"], [21, "GPSDestLongitudeRef"], [22, "GPSDestLongitude"], [23, "GPSDestBearingRef"], [24, "GPSDestBearing"], [25, "GPSDestDistanceRef"], [26, "GPSDestDistance"], [27, "GPSProcessingMethod"], [28, "GPSAreaInformation"], [29, "GPSDateStamp"], [30, "GPSDifferential"], [31, "GPSHPositioningError"]]), U(B, ["ifd0", "ifd1"], [[274, { 1: "Horizontal (normal)", 2: "Mirror horizontal", 3: "Rotate 180", 4: "Mirror vertical", 5: "Mirror horizontal and rotate 270 CW", 6: "Rotate 90 CW", 7: "Mirror horizontal and rotate 90 CW", 8: "Rotate 270 CW" }], [296, { 1: "None", 2: "inches", 3: "cm" }]]);
  var Ee = U(B, "exif", [[34850, { 0: "Not defined", 1: "Manual", 2: "Normal program", 3: "Aperture priority", 4: "Shutter priority", 5: "Creative program", 6: "Action program", 7: "Portrait mode", 8: "Landscape mode" }], [37121, { 0: "-", 1: "Y", 2: "Cb", 3: "Cr", 4: "R", 5: "G", 6: "B" }], [37383, { 0: "Unknown", 1: "Average", 2: "CenterWeightedAverage", 3: "Spot", 4: "MultiSpot", 5: "Pattern", 6: "Partial", 255: "Other" }], [37384, { 0: "Unknown", 1: "Daylight", 2: "Fluorescent", 3: "Tungsten (incandescent light)", 4: "Flash", 9: "Fine weather", 10: "Cloudy weather", 11: "Shade", 12: "Daylight fluorescent (D 5700 - 7100K)", 13: "Day white fluorescent (N 4600 - 5400K)", 14: "Cool white fluorescent (W 3900 - 4500K)", 15: "White fluorescent (WW 3200 - 3700K)", 17: "Standard light A", 18: "Standard light B", 19: "Standard light C", 20: "D55", 21: "D65", 22: "D75", 23: "D50", 24: "ISO studio tungsten", 255: "Other" }], [37385, { 0: "Flash did not fire", 1: "Flash fired", 5: "Strobe return light not detected", 7: "Strobe return light detected", 9: "Flash fired, compulsory flash mode", 13: "Flash fired, compulsory flash mode, return light not detected", 15: "Flash fired, compulsory flash mode, return light detected", 16: "Flash did not fire, compulsory flash mode", 24: "Flash did not fire, auto mode", 25: "Flash fired, auto mode", 29: "Flash fired, auto mode, return light not detected", 31: "Flash fired, auto mode, return light detected", 32: "No flash function", 65: "Flash fired, red-eye reduction mode", 69: "Flash fired, red-eye reduction mode, return light not detected", 71: "Flash fired, red-eye reduction mode, return light detected", 73: "Flash fired, compulsory flash mode, red-eye reduction mode", 77: "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected", 79: "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected", 89: "Flash fired, auto mode, red-eye reduction mode", 93: "Flash fired, auto mode, return light not detected, red-eye reduction mode", 95: "Flash fired, auto mode, return light detected, red-eye reduction mode" }], [41495, { 1: "Not defined", 2: "One-chip color area sensor", 3: "Two-chip color area sensor", 4: "Three-chip color area sensor", 5: "Color sequential area sensor", 7: "Trilinear sensor", 8: "Color sequential linear sensor" }], [41728, { 1: "Film Scanner", 2: "Reflection Print Scanner", 3: "Digital Camera" }], [41729, { 1: "Directly photographed" }], [41985, { 0: "Normal", 1: "Custom", 2: "HDR (no original saved)", 3: "HDR (original saved)", 4: "Original (for HDR)", 6: "Panorama", 7: "Portrait HDR", 8: "Portrait" }], [41986, { 0: "Auto", 1: "Manual", 2: "Auto bracket" }], [41987, { 0: "Auto", 1: "Manual" }], [41990, { 0: "Standard", 1: "Landscape", 2: "Portrait", 3: "Night", 4: "Other" }], [41991, { 0: "None", 1: "Low gain up", 2: "High gain up", 3: "Low gain down", 4: "High gain down" }], [41996, { 0: "Unknown", 1: "Macro", 2: "Close", 3: "Distant" }], [42080, { 0: "Unknown", 1: "Not a Composite Image", 2: "General Composite Image", 3: "Composite Image Captured While Shooting" }]]);
  var Be = { 1: "No absolute unit of measurement", 2: "Inch", 3: "Centimeter" };
  Ee.set(37392, Be), Ee.set(41488, Be);
  var Ne = { 0: "Normal", 1: "Low", 2: "High" };
  function Ge(e3) {
    return "object" == typeof e3 && void 0 !== e3.length ? e3[0] : e3;
  }
  function Ve(e3) {
    let t2 = Array.from(e3).slice(1);
    return t2[1] > 15 && (t2 = t2.map((e4) => String.fromCharCode(e4))), "0" !== t2[2] && 0 !== t2[2] || t2.pop(), t2.join(".");
  }
  function ze(e3) {
    if ("string" == typeof e3) {
      var [t2, i3, n3, s2, r2, a2] = e3.trim().split(/[-: ]/g).map(Number), o2 = new Date(t2, i3 - 1, n3);
      return Number.isNaN(s2) || Number.isNaN(r2) || Number.isNaN(a2) || (o2.setHours(s2), o2.setMinutes(r2), o2.setSeconds(a2)), Number.isNaN(+o2) ? e3 : o2;
    }
  }
  function He(e3) {
    if ("string" == typeof e3)
      return e3;
    let t2 = [];
    if (0 === e3[1] && 0 === e3[e3.length - 1])
      for (let i3 = 0; i3 < e3.length; i3 += 2)
        t2.push(je(e3[i3 + 1], e3[i3]));
    else
      for (let i3 = 0; i3 < e3.length; i3 += 2)
        t2.push(je(e3[i3], e3[i3 + 1]));
    return m(String.fromCodePoint(...t2));
  }
  function je(e3, t2) {
    return e3 << 8 | t2;
  }
  Ee.set(41992, Ne), Ee.set(41993, Ne), Ee.set(41994, Ne), U(N, ["ifd0", "ifd1"], [[50827, function(e3) {
    return "string" != typeof e3 ? b(e3) : e3;
  }], [306, ze], [40091, He], [40092, He], [40093, He], [40094, He], [40095, He]]), U(N, "exif", [[40960, Ve], [36864, Ve], [36867, ze], [36868, ze], [40962, Ge], [40963, Ge]]), U(N, "gps", [[0, (e3) => Array.from(e3).join(".")], [7, (e3) => Array.from(e3).join(":")]]);
  var We = class extends re2 {
    static canHandle(e3, t2) {
      return 225 === e3.getUint8(t2 + 1) && 1752462448 === e3.getUint32(t2 + 4) && "http://ns.adobe.com/" === e3.getString(t2 + 4, "http://ns.adobe.com/".length);
    }
    static headerLength(e3, t2) {
      return "http://ns.adobe.com/xmp/extension/" === e3.getString(t2 + 4, "http://ns.adobe.com/xmp/extension/".length) ? 79 : 4 + "http://ns.adobe.com/xap/1.0/".length + 1;
    }
    static findPosition(e3, t2) {
      let i3 = super.findPosition(e3, t2);
      return i3.multiSegment = i3.extended = 79 === i3.headerLength, i3.multiSegment ? (i3.chunkCount = e3.getUint8(t2 + 72), i3.chunkNumber = e3.getUint8(t2 + 76), 0 !== e3.getUint8(t2 + 77) && i3.chunkNumber++) : (i3.chunkCount = 1 / 0, i3.chunkNumber = -1), i3;
    }
    static handleMultiSegments(e3) {
      return e3.map((e4) => e4.chunk.getString()).join("");
    }
    normalizeInput(e3) {
      return "string" == typeof e3 ? e3 : I.from(e3).getString();
    }
    parse(e3 = this.chunk) {
      if (!this.localOptions.parse)
        return e3;
      e3 = function(e4) {
        let t3 = {}, i4 = {};
        for (let e6 of Ze)
          t3[e6] = [], i4[e6] = 0;
        return e4.replace(et, (e6, n4, s2) => {
          if ("<" === n4) {
            let n5 = ++i4[s2];
            return t3[s2].push(n5), "".concat(e6, "#").concat(n5);
          }
          return "".concat(e6, "#").concat(t3[s2].pop());
        });
      }(e3);
      let t2 = Xe.findAll(e3, "rdf", "Description");
      0 === t2.length && t2.push(new Xe("rdf", "Description", void 0, e3));
      let i3, n3 = {};
      for (let e4 of t2)
        for (let t3 of e4.properties)
          i3 = Je(t3.ns, n3), _e(t3, i3);
      return function(e4) {
        let t3;
        for (let i4 in e4)
          t3 = e4[i4] = f(e4[i4]), void 0 === t3 && delete e4[i4];
        return f(e4);
      }(n3);
    }
    assignToOutput(e3, t2) {
      if (this.localOptions.parse)
        for (let [i3, n3] of Object.entries(t2))
          switch (i3) {
            case "tiff":
              this.assignObjectToOutput(e3, "ifd0", n3);
              break;
            case "exif":
              this.assignObjectToOutput(e3, "exif", n3);
              break;
            case "xmlns":
              break;
            default:
              this.assignObjectToOutput(e3, i3, n3);
          }
      else
        e3.xmp = t2;
    }
  };
  c(We, "type", "xmp"), c(We, "multiSegment", true), T.set("xmp", We);
  var Ke = class _Ke {
    static findAll(e3) {
      return qe(e3, /([a-zA-Z0-9-]+):([a-zA-Z0-9-]+)=("[^"]*"|'[^']*')/gm).map(_Ke.unpackMatch);
    }
    static unpackMatch(e3) {
      let t2 = e3[1], i3 = e3[2], n3 = e3[3].slice(1, -1);
      return n3 = Qe(n3), new _Ke(t2, i3, n3);
    }
    constructor(e3, t2, i3) {
      this.ns = e3, this.name = t2, this.value = i3;
    }
    serialize() {
      return this.value;
    }
  };
  var Xe = class _Xe {
    static findAll(e3, t2, i3) {
      if (void 0 !== t2 || void 0 !== i3) {
        t2 = t2 || "[\\w\\d-]+", i3 = i3 || "[\\w\\d-]+";
        var n3 = new RegExp("<(".concat(t2, "):(").concat(i3, ")(#\\d+)?((\\s+?[\\w\\d-:]+=(\"[^\"]*\"|'[^']*'))*\\s*)(\\/>|>([\\s\\S]*?)<\\/\\1:\\2\\3>)"), "gm");
      } else
        n3 = /<([\w\d-]+):([\w\d-]+)(#\d+)?((\s+?[\w\d-:]+=("[^"]*"|'[^']*'))*\s*)(\/>|>([\s\S]*?)<\/\1:\2\3>)/gm;
      return qe(e3, n3).map(_Xe.unpackMatch);
    }
    static unpackMatch(e3) {
      let t2 = e3[1], i3 = e3[2], n3 = e3[4], s2 = e3[8];
      return new _Xe(t2, i3, n3, s2);
    }
    constructor(e3, t2, i3, n3) {
      this.ns = e3, this.name = t2, this.attrString = i3, this.innerXml = n3, this.attrs = Ke.findAll(i3), this.children = _Xe.findAll(n3), this.value = 0 === this.children.length ? Qe(n3) : void 0, this.properties = [...this.attrs, ...this.children];
    }
    get isPrimitive() {
      return void 0 !== this.value && 0 === this.attrs.length && 0 === this.children.length;
    }
    get isListContainer() {
      return 1 === this.children.length && this.children[0].isList;
    }
    get isList() {
      let { ns: e3, name: t2 } = this;
      return "rdf" === e3 && ("Seq" === t2 || "Bag" === t2 || "Alt" === t2);
    }
    get isListItem() {
      return "rdf" === this.ns && "li" === this.name;
    }
    serialize() {
      if (0 === this.properties.length && void 0 === this.value)
        return;
      if (this.isPrimitive)
        return this.value;
      if (this.isListContainer)
        return this.children[0].serialize();
      if (this.isList)
        return $e(this.children.map(Ye));
      if (this.isListItem && 1 === this.children.length && 0 === this.attrs.length)
        return this.children[0].serialize();
      let e3 = {};
      for (let t2 of this.properties)
        _e(t2, e3);
      return void 0 !== this.value && (e3.value = this.value), f(e3);
    }
  };
  function _e(e3, t2) {
    let i3 = e3.serialize();
    void 0 !== i3 && (t2[e3.name] = i3);
  }
  var Ye = (e3) => e3.serialize();
  var $e = (e3) => 1 === e3.length ? e3[0] : e3;
  var Je = (e3, t2) => t2[e3] ? t2[e3] : t2[e3] = {};
  function qe(e3, t2) {
    let i3, n3 = [];
    if (!e3)
      return n3;
    for (; null !== (i3 = t2.exec(e3)); )
      n3.push(i3);
    return n3;
  }
  function Qe(e3) {
    if (function(e4) {
      return null == e4 || "null" === e4 || "undefined" === e4 || "" === e4 || "" === e4.trim();
    }(e3))
      return;
    let t2 = Number(e3);
    if (!Number.isNaN(t2))
      return t2;
    let i3 = e3.toLowerCase();
    return "true" === i3 || "false" !== i3 && e3.trim();
  }
  var Ze = ["rdf:li", "rdf:Seq", "rdf:Bag", "rdf:Alt", "rdf:Description"];
  var et = new RegExp("(<|\\/)(".concat(Ze.join("|"), ")"), "g");
  var tt = Object.freeze({ __proto__: null, default: Me, Exifr: te, fileParsers: w, segmentParsers: T, fileReaders: A, tagKeys: E, tagValues: B, tagRevivers: N, createDictionary: U, extendDictionary: F, fetchUrlAsArrayBuffer: M, readBlobAsArrayBuffer: R, chunkedProps: G, otherSegments: V, segments: z, tiffBlocks: H, segmentsAndBlocks: j, tiffExtractables: W, inheritables: K, allFormatters: X, Options: q, parse: ie, gpsOnlyOptions: me, gps: Se, thumbnailOnlyOptions: Ce, thumbnail: ye, thumbnailUrl: be, orientationOnlyOptions: Ie, orientation: Pe, rotations: ke, get rotateCanvas() {
    return we;
  }, get rotateCss() {
    return Te;
  }, rotation: Ae });
  var at = l("fs", (e3) => e3.promises);
  A.set("fs", class extends ve {
    async readWhole() {
      this.chunked = false, this.fs = await at;
      let e3 = await this.fs.readFile(this.input);
      this._swapBuffer(e3);
    }
    async readChunked() {
      this.chunked = true, this.fs = await at, await this.open(), await this.readChunk(0, this.options.firstChunkSize);
    }
    async open() {
      void 0 === this.fh && (this.fh = await this.fs.open(this.input, "r"), this.size = (await this.fh.stat(this.input)).size);
    }
    async _readChunk(e3, t2) {
      void 0 === this.fh && await this.open(), e3 + t2 > this.size && (t2 = this.size - e3);
      var i3 = this.subarray(e3, t2, true);
      return await this.fh.read(i3.dataView, 0, t2, e3), i3;
    }
    async close() {
      if (this.fh) {
        let e3 = this.fh;
        this.fh = void 0, await e3.close();
      }
    }
  });
  A.set("base64", class extends ve {
    constructor(...e3) {
      super(...e3), this.input = this.input.replace(/^data:([^;]+);base64,/gim, ""), this.size = this.input.length / 4 * 3, this.input.endsWith("==") ? this.size -= 2 : this.input.endsWith("=") && (this.size -= 1);
    }
    async _readChunk(e3, t2) {
      let i3, n3, r2 = this.input;
      void 0 === e3 ? (e3 = 0, i3 = 0, n3 = 0) : (i3 = 4 * Math.floor(e3 / 3), n3 = e3 - i3 / 4 * 3), void 0 === t2 && (t2 = this.size);
      let o2 = e3 + t2, l2 = i3 + 4 * Math.ceil(o2 / 3);
      r2 = r2.slice(i3, l2);
      let h2 = Math.min(t2, this.size - e3);
      if (a) {
        let t3 = s.from(r2, "base64").slice(n3, n3 + h2);
        return this.set(t3, e3, true);
      }
      {
        let t3 = this.subarray(e3, h2, true), i4 = atob(r2), s2 = t3.toUint8();
        for (let e4 = 0; e4 < h2; e4++)
          s2[e4] = i4.charCodeAt(n3 + e4);
        return t3;
      }
    }
  });
  var ot = class extends se {
    static canHandle(e3, t2) {
      return 18761 === t2 || 19789 === t2;
    }
    extendOptions(e3) {
      let { ifd0: t2, xmp: i3, iptc: n3, icc: s2 } = e3;
      i3.enabled && t2.deps.add(700), n3.enabled && t2.deps.add(33723), s2.enabled && t2.deps.add(34675), t2.finalizeFilters();
    }
    async parse() {
      let { tiff: e3, xmp: t2, iptc: i3, icc: n3 } = this.options;
      if (e3.enabled || t2.enabled || i3.enabled || n3.enabled) {
        let e4 = Math.max(S(this.options), this.options.chunkSize);
        await this.file.ensureChunk(0, e4), this.createParser("tiff", this.file), this.parsers.tiff.parseHeader(), await this.parsers.tiff.parseIfd0Block(), this.adaptTiffPropAsSegment("xmp"), this.adaptTiffPropAsSegment("iptc"), this.adaptTiffPropAsSegment("icc");
      }
    }
    adaptTiffPropAsSegment(e3) {
      if (this.parsers.tiff[e3]) {
        let t2 = this.parsers.tiff[e3];
        this.injectSegment(e3, t2);
      }
    }
  };
  c(ot, "type", "tiff"), w.set("tiff", ot);
  var lt = l("zlib");
  var ht = ["ihdr", "iccp", "text", "itxt", "exif"];
  var ut = class extends se {
    constructor(...e3) {
      super(...e3), c(this, "catchError", (e4) => this.errors.push(e4)), c(this, "metaChunks", []), c(this, "unknownChunks", []);
    }
    static canHandle(e3, t2) {
      return 35152 === t2 && 2303741511 === e3.getUint32(0) && 218765834 === e3.getUint32(4);
    }
    async parse() {
      let { file: e3 } = this;
      await this.findPngChunksInRange("\x89PNG\r\n\n".length, e3.byteLength), await this.readSegments(this.metaChunks), this.findIhdr(), this.parseTextChunks(), await this.findExif().catch(this.catchError), await this.findXmp().catch(this.catchError), await this.findIcc().catch(this.catchError);
    }
    async findPngChunksInRange(e3, t2) {
      let { file: i3 } = this;
      for (; e3 < t2; ) {
        let t3 = i3.getUint32(e3), n3 = i3.getUint32(e3 + 4), s2 = i3.getString(e3 + 4, 4).toLowerCase(), r2 = t3 + 4 + 4 + 4, a2 = { type: s2, offset: e3, length: r2, start: e3 + 4 + 4, size: t3, marker: n3 };
        ht.includes(s2) ? this.metaChunks.push(a2) : this.unknownChunks.push(a2), e3 += r2;
      }
    }
    parseTextChunks() {
      let e3 = this.metaChunks.filter((e4) => "text" === e4.type);
      for (let t2 of e3) {
        let [e4, i3] = this.file.getString(t2.start, t2.size).split("\0");
        this.injectKeyValToIhdr(e4, i3);
      }
    }
    injectKeyValToIhdr(e3, t2) {
      let i3 = this.parsers.ihdr;
      i3 && i3.raw.set(e3, t2);
    }
    findIhdr() {
      let e3 = this.metaChunks.find((e4) => "ihdr" === e4.type);
      e3 && false !== this.options.ihdr.enabled && this.createParser("ihdr", e3.chunk);
    }
    async findExif() {
      let e3 = this.metaChunks.find((e4) => "exif" === e4.type);
      e3 && this.injectSegment("tiff", e3.chunk);
    }
    async findXmp() {
      let e3 = this.metaChunks.filter((e4) => "itxt" === e4.type);
      for (let t2 of e3) {
        "XML:com.adobe.xmp" === t2.chunk.getString(0, "XML:com.adobe.xmp".length) && this.injectSegment("xmp", t2.chunk);
      }
    }
    async findIcc() {
      let e3 = this.metaChunks.find((e4) => "iccp" === e4.type);
      if (!e3)
        return;
      let { chunk: t2 } = e3, i3 = t2.getUint8Array(0, 81), s2 = 0;
      for (; s2 < 80 && 0 !== i3[s2]; )
        s2++;
      let r2 = s2 + 2, a2 = t2.getString(0, s2);
      if (this.injectKeyValToIhdr("ProfileName", a2), n2) {
        let e4 = await lt, i4 = t2.getUint8Array(r2);
        i4 = e4.inflateSync(i4), this.injectSegment("icc", i4);
      }
    }
  };
  c(ut, "type", "png"), w.set("png", ut), U(E, "interop", [[1, "InteropIndex"], [2, "InteropVersion"], [4096, "RelatedImageFileFormat"], [4097, "RelatedImageWidth"], [4098, "RelatedImageHeight"]]), F(E, "ifd0", [[11, "ProcessingSoftware"], [254, "SubfileType"], [255, "OldSubfileType"], [263, "Thresholding"], [264, "CellWidth"], [265, "CellLength"], [266, "FillOrder"], [269, "DocumentName"], [280, "MinSampleValue"], [281, "MaxSampleValue"], [285, "PageName"], [286, "XPosition"], [287, "YPosition"], [290, "GrayResponseUnit"], [297, "PageNumber"], [321, "HalftoneHints"], [322, "TileWidth"], [323, "TileLength"], [332, "InkSet"], [337, "TargetPrinter"], [18246, "Rating"], [18249, "RatingPercent"], [33550, "PixelScale"], [34264, "ModelTransform"], [34377, "PhotoshopSettings"], [50706, "DNGVersion"], [50707, "DNGBackwardVersion"], [50708, "UniqueCameraModel"], [50709, "LocalizedCameraModel"], [50736, "DNGLensInfo"], [50739, "ShadowScale"], [50740, "DNGPrivateData"], [33920, "IntergraphMatrix"], [33922, "ModelTiePoint"], [34118, "SEMInfo"], [34735, "GeoTiffDirectory"], [34736, "GeoTiffDoubleParams"], [34737, "GeoTiffAsciiParams"], [50341, "PrintIM"], [50721, "ColorMatrix1"], [50722, "ColorMatrix2"], [50723, "CameraCalibration1"], [50724, "CameraCalibration2"], [50725, "ReductionMatrix1"], [50726, "ReductionMatrix2"], [50727, "AnalogBalance"], [50728, "AsShotNeutral"], [50729, "AsShotWhiteXY"], [50730, "BaselineExposure"], [50731, "BaselineNoise"], [50732, "BaselineSharpness"], [50734, "LinearResponseLimit"], [50735, "CameraSerialNumber"], [50741, "MakerNoteSafety"], [50778, "CalibrationIlluminant1"], [50779, "CalibrationIlluminant2"], [50781, "RawDataUniqueID"], [50827, "OriginalRawFileName"], [50828, "OriginalRawFileData"], [50831, "AsShotICCProfile"], [50832, "AsShotPreProfileMatrix"], [50833, "CurrentICCProfile"], [50834, "CurrentPreProfileMatrix"], [50879, "ColorimetricReference"], [50885, "SRawType"], [50898, "PanasonicTitle"], [50899, "PanasonicTitle2"], [50931, "CameraCalibrationSig"], [50932, "ProfileCalibrationSig"], [50933, "ProfileIFD"], [50934, "AsShotProfileName"], [50936, "ProfileName"], [50937, "ProfileHueSatMapDims"], [50938, "ProfileHueSatMapData1"], [50939, "ProfileHueSatMapData2"], [50940, "ProfileToneCurve"], [50941, "ProfileEmbedPolicy"], [50942, "ProfileCopyright"], [50964, "ForwardMatrix1"], [50965, "ForwardMatrix2"], [50966, "PreviewApplicationName"], [50967, "PreviewApplicationVersion"], [50968, "PreviewSettingsName"], [50969, "PreviewSettingsDigest"], [50970, "PreviewColorSpace"], [50971, "PreviewDateTime"], [50972, "RawImageDigest"], [50973, "OriginalRawFileDigest"], [50981, "ProfileLookTableDims"], [50982, "ProfileLookTableData"], [51043, "TimeCodes"], [51044, "FrameRate"], [51058, "TStop"], [51081, "ReelName"], [51089, "OriginalDefaultFinalSize"], [51090, "OriginalBestQualitySize"], [51091, "OriginalDefaultCropSize"], [51105, "CameraLabel"], [51107, "ProfileHueSatMapEncoding"], [51108, "ProfileLookTableEncoding"], [51109, "BaselineExposureOffset"], [51110, "DefaultBlackRender"], [51111, "NewRawImageDigest"], [51112, "RawToPreviewGain"]]);
  var ct = [[273, "StripOffsets"], [279, "StripByteCounts"], [288, "FreeOffsets"], [289, "FreeByteCounts"], [291, "GrayResponseCurve"], [292, "T4Options"], [293, "T6Options"], [300, "ColorResponseUnit"], [320, "ColorMap"], [324, "TileOffsets"], [325, "TileByteCounts"], [326, "BadFaxLines"], [327, "CleanFaxData"], [328, "ConsecutiveBadFaxLines"], [330, "SubIFD"], [333, "InkNames"], [334, "NumberofInks"], [336, "DotRange"], [338, "ExtraSamples"], [339, "SampleFormat"], [340, "SMinSampleValue"], [341, "SMaxSampleValue"], [342, "TransferRange"], [343, "ClipPath"], [344, "XClipPathUnits"], [345, "YClipPathUnits"], [346, "Indexed"], [347, "JPEGTables"], [351, "OPIProxy"], [400, "GlobalParametersIFD"], [401, "ProfileType"], [402, "FaxProfile"], [403, "CodingMethods"], [404, "VersionYear"], [405, "ModeNumber"], [433, "Decode"], [434, "DefaultImageColor"], [435, "T82Options"], [437, "JPEGTables"], [512, "JPEGProc"], [515, "JPEGRestartInterval"], [517, "JPEGLosslessPredictors"], [518, "JPEGPointTransforms"], [519, "JPEGQTables"], [520, "JPEGDCTables"], [521, "JPEGACTables"], [559, "StripRowCounts"], [999, "USPTOMiscellaneous"], [18247, "XP_DIP_XML"], [18248, "StitchInfo"], [28672, "SonyRawFileType"], [28688, "SonyToneCurve"], [28721, "VignettingCorrection"], [28722, "VignettingCorrParams"], [28724, "ChromaticAberrationCorrection"], [28725, "ChromaticAberrationCorrParams"], [28726, "DistortionCorrection"], [28727, "DistortionCorrParams"], [29895, "SonyCropTopLeft"], [29896, "SonyCropSize"], [32781, "ImageID"], [32931, "WangTag1"], [32932, "WangAnnotation"], [32933, "WangTag3"], [32934, "WangTag4"], [32953, "ImageReferencePoints"], [32954, "RegionXformTackPoint"], [32955, "WarpQuadrilateral"], [32956, "AffineTransformMat"], [32995, "Matteing"], [32996, "DataType"], [32997, "ImageDepth"], [32998, "TileDepth"], [33300, "ImageFullWidth"], [33301, "ImageFullHeight"], [33302, "TextureFormat"], [33303, "WrapModes"], [33304, "FovCot"], [33305, "MatrixWorldToScreen"], [33306, "MatrixWorldToCamera"], [33405, "Model2"], [33421, "CFARepeatPatternDim"], [33422, "CFAPattern2"], [33423, "BatteryLevel"], [33424, "KodakIFD"], [33445, "MDFileTag"], [33446, "MDScalePixel"], [33447, "MDColorTable"], [33448, "MDLabName"], [33449, "MDSampleInfo"], [33450, "MDPrepDate"], [33451, "MDPrepTime"], [33452, "MDFileUnits"], [33589, "AdventScale"], [33590, "AdventRevision"], [33628, "UIC1Tag"], [33629, "UIC2Tag"], [33630, "UIC3Tag"], [33631, "UIC4Tag"], [33918, "IntergraphPacketData"], [33919, "IntergraphFlagRegisters"], [33921, "INGRReserved"], [34016, "Site"], [34017, "ColorSequence"], [34018, "IT8Header"], [34019, "RasterPadding"], [34020, "BitsPerRunLength"], [34021, "BitsPerExtendedRunLength"], [34022, "ColorTable"], [34023, "ImageColorIndicator"], [34024, "BackgroundColorIndicator"], [34025, "ImageColorValue"], [34026, "BackgroundColorValue"], [34027, "PixelIntensityRange"], [34028, "TransparencyIndicator"], [34029, "ColorCharacterization"], [34030, "HCUsage"], [34031, "TrapIndicator"], [34032, "CMYKEquivalent"], [34152, "AFCP_IPTC"], [34232, "PixelMagicJBIGOptions"], [34263, "JPLCartoIFD"], [34306, "WB_GRGBLevels"], [34310, "LeafData"], [34687, "TIFF_FXExtensions"], [34688, "MultiProfiles"], [34689, "SharedData"], [34690, "T88Options"], [34732, "ImageLayer"], [34750, "JBIGOptions"], [34856, "Opto-ElectricConvFactor"], [34857, "Interlace"], [34908, "FaxRecvParams"], [34909, "FaxSubAddress"], [34910, "FaxRecvTime"], [34929, "FedexEDR"], [34954, "LeafSubIFD"], [37387, "FlashEnergy"], [37388, "SpatialFrequencyResponse"], [37389, "Noise"], [37390, "FocalPlaneXResolution"], [37391, "FocalPlaneYResolution"], [37392, "FocalPlaneResolutionUnit"], [37397, "ExposureIndex"], [37398, "TIFF-EPStandardID"], [37399, "SensingMethod"], [37434, "CIP3DataFile"], [37435, "CIP3Sheet"], [37436, "CIP3Side"], [37439, "StoNits"], [37679, "MSDocumentText"], [37680, "MSPropertySetStorage"], [37681, "MSDocumentTextPosition"], [37724, "ImageSourceData"], [40965, "InteropIFD"], [40976, "SamsungRawPointersOffset"], [40977, "SamsungRawPointersLength"], [41217, "SamsungRawByteOrder"], [41218, "SamsungRawUnknown"], [41484, "SpatialFrequencyResponse"], [41485, "Noise"], [41489, "ImageNumber"], [41490, "SecurityClassification"], [41491, "ImageHistory"], [41494, "TIFF-EPStandardID"], [41995, "DeviceSettingDescription"], [42112, "GDALMetadata"], [42113, "GDALNoData"], [44992, "ExpandSoftware"], [44993, "ExpandLens"], [44994, "ExpandFilm"], [44995, "ExpandFilterLens"], [44996, "ExpandScanner"], [44997, "ExpandFlashLamp"], [46275, "HasselbladRawImage"], [48129, "PixelFormat"], [48130, "Transformation"], [48131, "Uncompressed"], [48132, "ImageType"], [48256, "ImageWidth"], [48257, "ImageHeight"], [48258, "WidthResolution"], [48259, "HeightResolution"], [48320, "ImageOffset"], [48321, "ImageByteCount"], [48322, "AlphaOffset"], [48323, "AlphaByteCount"], [48324, "ImageDataDiscard"], [48325, "AlphaDataDiscard"], [50215, "OceScanjobDesc"], [50216, "OceApplicationSelector"], [50217, "OceIDNumber"], [50218, "OceImageLogic"], [50255, "Annotations"], [50459, "HasselbladExif"], [50547, "OriginalFileName"], [50560, "USPTOOriginalContentType"], [50656, "CR2CFAPattern"], [50710, "CFAPlaneColor"], [50711, "CFALayout"], [50712, "LinearizationTable"], [50713, "BlackLevelRepeatDim"], [50714, "BlackLevel"], [50715, "BlackLevelDeltaH"], [50716, "BlackLevelDeltaV"], [50717, "WhiteLevel"], [50718, "DefaultScale"], [50719, "DefaultCropOrigin"], [50720, "DefaultCropSize"], [50733, "BayerGreenSplit"], [50737, "ChromaBlurRadius"], [50738, "AntiAliasStrength"], [50752, "RawImageSegmentation"], [50780, "BestQualityScale"], [50784, "AliasLayerMetadata"], [50829, "ActiveArea"], [50830, "MaskedAreas"], [50935, "NoiseReductionApplied"], [50974, "SubTileBlockSize"], [50975, "RowInterleaveFactor"], [51008, "OpcodeList1"], [51009, "OpcodeList2"], [51022, "OpcodeList3"], [51041, "NoiseProfile"], [51114, "CacheVersion"], [51125, "DefaultUserCrop"], [51157, "NikonNEFInfo"], [65024, "KdcIFD"]];
  F(E, "ifd0", ct), F(E, "exif", ct), U(B, "gps", [[23, { M: "Magnetic North", T: "True North" }], [25, { K: "Kilometers", M: "Miles", N: "Nautical Miles" }]]);
  var ft = class extends re2 {
    static canHandle(e3, t2) {
      return 224 === e3.getUint8(t2 + 1) && 1246120262 === e3.getUint32(t2 + 4) && 0 === e3.getUint8(t2 + 8);
    }
    parse() {
      return this.parseTags(), this.translate(), this.output;
    }
    parseTags() {
      this.raw = /* @__PURE__ */ new Map([[0, this.chunk.getUint16(0)], [2, this.chunk.getUint8(2)], [3, this.chunk.getUint16(3)], [5, this.chunk.getUint16(5)], [7, this.chunk.getUint8(7)], [8, this.chunk.getUint8(8)]]);
    }
  };
  c(ft, "type", "jfif"), c(ft, "headerLength", 9), T.set("jfif", ft), U(E, "jfif", [[0, "JFIFVersion"], [2, "ResolutionUnit"], [3, "XResolution"], [5, "YResolution"], [7, "ThumbnailWidth"], [8, "ThumbnailHeight"]]);
  var dt = class extends re2 {
    parse() {
      return this.parseTags(), this.translate(), this.output;
    }
    parseTags() {
      this.raw = new Map([[0, this.chunk.getUint32(0)], [4, this.chunk.getUint32(4)], [8, this.chunk.getUint8(8)], [9, this.chunk.getUint8(9)], [10, this.chunk.getUint8(10)], [11, this.chunk.getUint8(11)], [12, this.chunk.getUint8(12)], ...Array.from(this.raw)]);
    }
  };
  c(dt, "type", "ihdr"), T.set("ihdr", dt), U(E, "ihdr", [[0, "ImageWidth"], [4, "ImageHeight"], [8, "BitDepth"], [9, "ColorType"], [10, "Compression"], [11, "Filter"], [12, "Interlace"]]), U(B, "ihdr", [[9, { 0: "Grayscale", 2: "RGB", 3: "Palette", 4: "Grayscale with Alpha", 6: "RGB with Alpha", DEFAULT: "Unknown" }], [10, { 0: "Deflate/Inflate", DEFAULT: "Unknown" }], [11, { 0: "Adaptive", DEFAULT: "Unknown" }], [12, { 0: "Noninterlaced", 1: "Adam7 Interlace", DEFAULT: "Unknown" }]]);
  var pt = class extends re2 {
    static canHandle(e3, t2) {
      return 226 === e3.getUint8(t2 + 1) && 1229144927 === e3.getUint32(t2 + 4);
    }
    static findPosition(e3, t2) {
      let i3 = super.findPosition(e3, t2);
      return i3.chunkNumber = e3.getUint8(t2 + 16), i3.chunkCount = e3.getUint8(t2 + 17), i3.multiSegment = i3.chunkCount > 1, i3;
    }
    static handleMultiSegments(e3) {
      return function(e4) {
        let t2 = function(e6) {
          let t3 = e6[0].constructor, i3 = 0;
          for (let t4 of e6)
            i3 += t4.length;
          let n3 = new t3(i3), s2 = 0;
          for (let t4 of e6)
            n3.set(t4, s2), s2 += t4.length;
          return n3;
        }(e4.map((e6) => e6.chunk.toUint8()));
        return new I(t2);
      }(e3);
    }
    parse() {
      return this.raw = /* @__PURE__ */ new Map(), this.parseHeader(), this.parseTags(), this.translate(), this.output;
    }
    parseHeader() {
      let { raw: e3 } = this;
      this.chunk.byteLength < 84 && g2("ICC header is too short");
      for (let [t2, i3] of Object.entries(gt)) {
        t2 = parseInt(t2, 10);
        let n3 = i3(this.chunk, t2);
        "\0\0\0\0" !== n3 && e3.set(t2, n3);
      }
    }
    parseTags() {
      let e3, t2, i3, n3, s2, { raw: r2 } = this, a2 = this.chunk.getUint32(128), o2 = 132, l2 = this.chunk.byteLength;
      for (; a2--; ) {
        if (e3 = this.chunk.getString(o2, 4), t2 = this.chunk.getUint32(o2 + 4), i3 = this.chunk.getUint32(o2 + 8), n3 = this.chunk.getString(t2, 4), t2 + i3 > l2)
          return void console.warn("reached the end of the first ICC chunk. Enable options.tiff.multiSegment to read all ICC segments.");
        s2 = this.parseTag(n3, t2, i3), void 0 !== s2 && "\0\0\0\0" !== s2 && r2.set(e3, s2), o2 += 12;
      }
    }
    parseTag(e3, t2, i3) {
      switch (e3) {
        case "desc":
          return this.parseDesc(t2);
        case "mluc":
          return this.parseMluc(t2);
        case "text":
          return this.parseText(t2, i3);
        case "sig ":
          return this.parseSig(t2);
      }
      if (!(t2 + i3 > this.chunk.byteLength))
        return this.chunk.getUint8Array(t2, i3);
    }
    parseDesc(e3) {
      let t2 = this.chunk.getUint32(e3 + 8) - 1;
      return m(this.chunk.getString(e3 + 12, t2));
    }
    parseText(e3, t2) {
      return m(this.chunk.getString(e3 + 8, t2 - 8));
    }
    parseSig(e3) {
      return m(this.chunk.getString(e3 + 8, 4));
    }
    parseMluc(e3) {
      let { chunk: t2 } = this, i3 = t2.getUint32(e3 + 8), n3 = t2.getUint32(e3 + 12), s2 = e3 + 16, r2 = [];
      for (let a2 = 0; a2 < i3; a2++) {
        let i4 = t2.getString(s2 + 0, 2), a3 = t2.getString(s2 + 2, 2), o2 = t2.getUint32(s2 + 4), l2 = t2.getUint32(s2 + 8) + e3, h2 = m(t2.getUnicodeString(l2, o2));
        r2.push({ lang: i4, country: a3, text: h2 }), s2 += n3;
      }
      return 1 === i3 ? r2[0].text : r2;
    }
    translateValue(e3, t2) {
      return "string" == typeof e3 ? t2[e3] || t2[e3.toLowerCase()] || e3 : t2[e3] || e3;
    }
  };
  c(pt, "type", "icc"), c(pt, "multiSegment", true), c(pt, "headerLength", 18);
  var gt = { 4: mt, 8: function(e3, t2) {
    return [e3.getUint8(t2), e3.getUint8(t2 + 1) >> 4, e3.getUint8(t2 + 1) % 16].map((e4) => e4.toString(10)).join(".");
  }, 12: mt, 16: mt, 20: mt, 24: function(e3, t2) {
    const i3 = e3.getUint16(t2), n3 = e3.getUint16(t2 + 2) - 1, s2 = e3.getUint16(t2 + 4), r2 = e3.getUint16(t2 + 6), a2 = e3.getUint16(t2 + 8), o2 = e3.getUint16(t2 + 10);
    return new Date(Date.UTC(i3, n3, s2, r2, a2, o2));
  }, 36: mt, 40: mt, 48: mt, 52: mt, 64: (e3, t2) => e3.getUint32(t2), 80: mt };
  function mt(e3, t2) {
    return m(e3.getString(t2, 4));
  }
  T.set("icc", pt), U(E, "icc", [[4, "ProfileCMMType"], [8, "ProfileVersion"], [12, "ProfileClass"], [16, "ColorSpaceData"], [20, "ProfileConnectionSpace"], [24, "ProfileDateTime"], [36, "ProfileFileSignature"], [40, "PrimaryPlatform"], [44, "CMMFlags"], [48, "DeviceManufacturer"], [52, "DeviceModel"], [56, "DeviceAttributes"], [64, "RenderingIntent"], [68, "ConnectionSpaceIlluminant"], [80, "ProfileCreator"], [84, "ProfileID"], ["Header", "ProfileHeader"], ["MS00", "WCSProfiles"], ["bTRC", "BlueTRC"], ["bXYZ", "BlueMatrixColumn"], ["bfd", "UCRBG"], ["bkpt", "MediaBlackPoint"], ["calt", "CalibrationDateTime"], ["chad", "ChromaticAdaptation"], ["chrm", "Chromaticity"], ["ciis", "ColorimetricIntentImageState"], ["clot", "ColorantTableOut"], ["clro", "ColorantOrder"], ["clrt", "ColorantTable"], ["cprt", "ProfileCopyright"], ["crdi", "CRDInfo"], ["desc", "ProfileDescription"], ["devs", "DeviceSettings"], ["dmdd", "DeviceModelDesc"], ["dmnd", "DeviceMfgDesc"], ["dscm", "ProfileDescriptionML"], ["fpce", "FocalPlaneColorimetryEstimates"], ["gTRC", "GreenTRC"], ["gXYZ", "GreenMatrixColumn"], ["gamt", "Gamut"], ["kTRC", "GrayTRC"], ["lumi", "Luminance"], ["meas", "Measurement"], ["meta", "Metadata"], ["mmod", "MakeAndModel"], ["ncl2", "NamedColor2"], ["ncol", "NamedColor"], ["ndin", "NativeDisplayInfo"], ["pre0", "Preview0"], ["pre1", "Preview1"], ["pre2", "Preview2"], ["ps2i", "PS2RenderingIntent"], ["ps2s", "PostScript2CSA"], ["psd0", "PostScript2CRD0"], ["psd1", "PostScript2CRD1"], ["psd2", "PostScript2CRD2"], ["psd3", "PostScript2CRD3"], ["pseq", "ProfileSequenceDesc"], ["psid", "ProfileSequenceIdentifier"], ["psvm", "PS2CRDVMSize"], ["rTRC", "RedTRC"], ["rXYZ", "RedMatrixColumn"], ["resp", "OutputResponse"], ["rhoc", "ReflectionHardcopyOrigColorimetry"], ["rig0", "PerceptualRenderingIntentGamut"], ["rig2", "SaturationRenderingIntentGamut"], ["rpoc", "ReflectionPrintOutputColorimetry"], ["sape", "SceneAppearanceEstimates"], ["scoe", "SceneColorimetryEstimates"], ["scrd", "ScreeningDesc"], ["scrn", "Screening"], ["targ", "CharTarget"], ["tech", "Technology"], ["vcgt", "VideoCardGamma"], ["view", "ViewingConditions"], ["vued", "ViewingCondDesc"], ["wtpt", "MediaWhitePoint"]]);
  var St = { "4d2p": "Erdt Systems", AAMA: "Aamazing Technologies", ACER: "Acer", ACLT: "Acolyte Color Research", ACTI: "Actix Sytems", ADAR: "Adara Technology", ADBE: "Adobe", ADI: "ADI Systems", AGFA: "Agfa Graphics", ALMD: "Alps Electric", ALPS: "Alps Electric", ALWN: "Alwan Color Expertise", AMTI: "Amiable Technologies", AOC: "AOC International", APAG: "Apago", APPL: "Apple Computer", AST: "AST", "AT&T": "AT&T", BAEL: "BARBIERI electronic", BRCO: "Barco NV", BRKP: "Breakpoint", BROT: "Brother", BULL: "Bull", BUS: "Bus Computer Systems", "C-IT": "C-Itoh", CAMR: "Intel", CANO: "Canon", CARR: "Carroll Touch", CASI: "Casio", CBUS: "Colorbus PL", CEL: "Crossfield", CELx: "Crossfield", CGS: "CGS Publishing Technologies International", CHM: "Rochester Robotics", CIGL: "Colour Imaging Group, London", CITI: "Citizen", CL00: "Candela", CLIQ: "Color IQ", CMCO: "Chromaco", CMiX: "CHROMiX", COLO: "Colorgraphic Communications", COMP: "Compaq", COMp: "Compeq/Focus Technology", CONR: "Conrac Display Products", CORD: "Cordata Technologies", CPQ: "Compaq", CPRO: "ColorPro", CRN: "Cornerstone", CTX: "CTX International", CVIS: "ColorVision", CWC: "Fujitsu Laboratories", DARI: "Darius Technology", DATA: "Dataproducts", DCP: "Dry Creek Photo", DCRC: "Digital Contents Resource Center, Chung-Ang University", DELL: "Dell Computer", DIC: "Dainippon Ink and Chemicals", DICO: "Diconix", DIGI: "Digital", "DL&C": "Digital Light & Color", DPLG: "Doppelganger", DS: "Dainippon Screen", DSOL: "DOOSOL", DUPN: "DuPont", EPSO: "Epson", ESKO: "Esko-Graphics", ETRI: "Electronics and Telecommunications Research Institute", EVER: "Everex Systems", EXAC: "ExactCODE", Eizo: "Eizo", FALC: "Falco Data Products", FF: "Fuji Photo Film", FFEI: "FujiFilm Electronic Imaging", FNRD: "Fnord Software", FORA: "Fora", FORE: "Forefront Technology", FP: "Fujitsu", FPA: "WayTech Development", FUJI: "Fujitsu", FX: "Fuji Xerox", GCC: "GCC Technologies", GGSL: "Global Graphics Software", GMB: "Gretagmacbeth", GMG: "GMG", GOLD: "GoldStar Technology", GOOG: "Google", GPRT: "Giantprint", GTMB: "Gretagmacbeth", GVC: "WayTech Development", GW2K: "Sony", HCI: "HCI", HDM: "Heidelberger Druckmaschinen", HERM: "Hermes", HITA: "Hitachi America", HP: "Hewlett-Packard", HTC: "Hitachi", HiTi: "HiTi Digital", IBM: "IBM", IDNT: "Scitex", IEC: "Hewlett-Packard", IIYA: "Iiyama North America", IKEG: "Ikegami Electronics", IMAG: "Image Systems", IMI: "Ingram Micro", INTC: "Intel", INTL: "N/A (INTL)", INTR: "Intra Electronics", IOCO: "Iocomm International Technology", IPS: "InfoPrint Solutions Company", IRIS: "Scitex", ISL: "Ichikawa Soft Laboratory", ITNL: "N/A (ITNL)", IVM: "IVM", IWAT: "Iwatsu Electric", Idnt: "Scitex", Inca: "Inca Digital Printers", Iris: "Scitex", JPEG: "Joint Photographic Experts Group", JSFT: "Jetsoft Development", JVC: "JVC Information Products", KART: "Scitex", KFC: "KFC Computek Components", KLH: "KLH Computers", KMHD: "Konica Minolta", KNCA: "Konica", KODA: "Kodak", KYOC: "Kyocera", Kart: "Scitex", LCAG: "Leica", LCCD: "Leeds Colour", LDAK: "Left Dakota", LEAD: "Leading Technology", LEXM: "Lexmark International", LINK: "Link Computer", LINO: "Linotronic", LITE: "Lite-On", Leaf: "Leaf", Lino: "Linotronic", MAGC: "Mag Computronic", MAGI: "MAG Innovision", MANN: "Mannesmann", MICN: "Micron Technology", MICR: "Microtek", MICV: "Microvitec", MINO: "Minolta", MITS: "Mitsubishi Electronics America", MITs: "Mitsuba", MNLT: "Minolta", MODG: "Modgraph", MONI: "Monitronix", MONS: "Monaco Systems", MORS: "Morse Technology", MOTI: "Motive Systems", MSFT: "Microsoft", MUTO: "MUTOH INDUSTRIES", Mits: "Mitsubishi Electric", NANA: "NANAO", NEC: "NEC", NEXP: "NexPress Solutions", NISS: "Nissei Sangyo America", NKON: "Nikon", NONE: "none", OCE: "Oce Technologies", OCEC: "OceColor", OKI: "Oki", OKID: "Okidata", OKIP: "Okidata", OLIV: "Olivetti", OLYM: "Olympus", ONYX: "Onyx Graphics", OPTI: "Optiquest", PACK: "Packard Bell", PANA: "Matsushita Electric Industrial", PANT: "Pantone", PBN: "Packard Bell", PFU: "PFU", PHIL: "Philips Consumer Electronics", PNTX: "HOYA", POne: "Phase One A/S", PREM: "Premier Computer Innovations", PRIN: "Princeton Graphic Systems", PRIP: "Princeton Publishing Labs", QLUX: "Hong Kong", QMS: "QMS", QPCD: "QPcard AB", QUAD: "QuadLaser", QUME: "Qume", RADI: "Radius", RDDx: "Integrated Color Solutions", RDG: "Roland DG", REDM: "REDMS Group", RELI: "Relisys", RGMS: "Rolf Gierling Multitools", RICO: "Ricoh", RNLD: "Edmund Ronald", ROYA: "Royal", RPC: "Ricoh Printing Systems", RTL: "Royal Information Electronics", SAMP: "Sampo", SAMS: "Samsung", SANT: "Jaime Santana Pomares", SCIT: "Scitex", SCRN: "Dainippon Screen", SDP: "Scitex", SEC: "Samsung", SEIK: "Seiko Instruments", SEIk: "Seikosha", SGUY: "ScanGuy.com", SHAR: "Sharp Laboratories", SICC: "International Color Consortium", SONY: "Sony", SPCL: "SpectraCal", STAR: "Star", STC: "Sampo Technology", Scit: "Scitex", Sdp: "Scitex", Sony: "Sony", TALO: "Talon Technology", TAND: "Tandy", TATU: "Tatung", TAXA: "TAXAN America", TDS: "Tokyo Denshi Sekei", TECO: "TECO Information Systems", TEGR: "Tegra", TEKT: "Tektronix", TI: "Texas Instruments", TMKR: "TypeMaker", TOSB: "Toshiba", TOSH: "Toshiba", TOTK: "TOTOKU ELECTRIC", TRIU: "Triumph", TSBT: "Toshiba", TTX: "TTX Computer Products", TVM: "TVM Professional Monitor", TW: "TW Casper", ULSX: "Ulead Systems", UNIS: "Unisys", UTZF: "Utz Fehlau & Sohn", VARI: "Varityper", VIEW: "Viewsonic", VISL: "Visual communication", VIVO: "Vivo Mobile Communication", WANG: "Wang", WLBR: "Wilbur Imaging", WTG2: "Ware To Go", WYSE: "WYSE Technology", XERX: "Xerox", XRIT: "X-Rite", ZRAN: "Zoran", Zebr: "Zebra Technologies", appl: "Apple Computer", bICC: "basICColor", berg: "bergdesign", ceyd: "Integrated Color Solutions", clsp: "MacDermid ColorSpan", ds: "Dainippon Screen", dupn: "DuPont", ffei: "FujiFilm Electronic Imaging", flux: "FluxData", iris: "Scitex", kart: "Scitex", lcms: "Little CMS", lino: "Linotronic", none: "none", ob4d: "Erdt Systems", obic: "Medigraph", quby: "Qubyx Sarl", scit: "Scitex", scrn: "Dainippon Screen", sdp: "Scitex", siwi: "SIWI GRAFIKA", yxym: "YxyMaster" };
  var Ct = { scnr: "Scanner", mntr: "Monitor", prtr: "Printer", link: "Device Link", abst: "Abstract", spac: "Color Space Conversion Profile", nmcl: "Named Color", cenc: "ColorEncodingSpace profile", mid: "MultiplexIdentification profile", mlnk: "MultiplexLink profile", mvis: "MultiplexVisualization profile", nkpf: "Nikon Input Device Profile (NON-STANDARD!)" };
  U(B, "icc", [[4, St], [12, Ct], [40, Object.assign({}, St, Ct)], [48, St], [80, St], [64, { 0: "Perceptual", 1: "Relative Colorimetric", 2: "Saturation", 3: "Absolute Colorimetric" }], ["tech", { amd: "Active Matrix Display", crt: "Cathode Ray Tube Display", kpcd: "Photo CD", pmd: "Passive Matrix Display", dcam: "Digital Camera", dcpj: "Digital Cinema Projector", dmpc: "Digital Motion Picture Camera", dsub: "Dye Sublimation Printer", epho: "Electrophotographic Printer", esta: "Electrostatic Printer", flex: "Flexography", fprn: "Film Writer", fscn: "Film Scanner", grav: "Gravure", ijet: "Ink Jet Printer", imgs: "Photo Image Setter", mpfr: "Motion Picture Film Recorder", mpfs: "Motion Picture Film Scanner", offs: "Offset Lithography", pjtv: "Projection Television", rpho: "Photographic Paper Printer", rscn: "Reflective Scanner", silk: "Silkscreen", twax: "Thermal Wax Printer", vidc: "Video Camera", vidm: "Video Monitor" }]]);
  var yt = class extends re2 {
    static canHandle(e3, t2, i3) {
      return 237 === e3.getUint8(t2 + 1) && "Photoshop" === e3.getString(t2 + 4, 9) && void 0 !== this.containsIptc8bim(e3, t2, i3);
    }
    static headerLength(e3, t2, i3) {
      let n3, s2 = this.containsIptc8bim(e3, t2, i3);
      if (void 0 !== s2)
        return n3 = e3.getUint8(t2 + s2 + 7), n3 % 2 != 0 && (n3 += 1), 0 === n3 && (n3 = 4), s2 + 8 + n3;
    }
    static containsIptc8bim(e3, t2, i3) {
      for (let n3 = 0; n3 < i3; n3++)
        if (this.isIptcSegmentHead(e3, t2 + n3))
          return n3;
    }
    static isIptcSegmentHead(e3, t2) {
      return 56 === e3.getUint8(t2) && 943868237 === e3.getUint32(t2) && 1028 === e3.getUint16(t2 + 4);
    }
    parse() {
      let { raw: e3 } = this, t2 = this.chunk.byteLength - 1, i3 = false;
      for (let n3 = 0; n3 < t2; n3++)
        if (28 === this.chunk.getUint8(n3) && 2 === this.chunk.getUint8(n3 + 1)) {
          i3 = true;
          let t3 = this.chunk.getUint16(n3 + 3), s2 = this.chunk.getUint8(n3 + 2), r2 = this.chunk.getLatin1String(n3 + 5, t3);
          e3.set(s2, this.pluralizeValue(e3.get(s2), r2)), n3 += 4 + t3;
        } else if (i3)
          break;
      return this.translate(), this.output;
    }
    pluralizeValue(e3, t2) {
      return void 0 !== e3 ? e3 instanceof Array ? (e3.push(t2), e3) : [e3, t2] : t2;
    }
  };
  c(yt, "type", "iptc"), c(yt, "translateValues", false), c(yt, "reviveValues", false), T.set("iptc", yt), U(E, "iptc", [[0, "ApplicationRecordVersion"], [3, "ObjectTypeReference"], [4, "ObjectAttributeReference"], [5, "ObjectName"], [7, "EditStatus"], [8, "EditorialUpdate"], [10, "Urgency"], [12, "SubjectReference"], [15, "Category"], [20, "SupplementalCategories"], [22, "FixtureIdentifier"], [25, "Keywords"], [26, "ContentLocationCode"], [27, "ContentLocationName"], [30, "ReleaseDate"], [35, "ReleaseTime"], [37, "ExpirationDate"], [38, "ExpirationTime"], [40, "SpecialInstructions"], [42, "ActionAdvised"], [45, "ReferenceService"], [47, "ReferenceDate"], [50, "ReferenceNumber"], [55, "DateCreated"], [60, "TimeCreated"], [62, "DigitalCreationDate"], [63, "DigitalCreationTime"], [65, "OriginatingProgram"], [70, "ProgramVersion"], [75, "ObjectCycle"], [80, "Byline"], [85, "BylineTitle"], [90, "City"], [92, "Sublocation"], [95, "State"], [100, "CountryCode"], [101, "Country"], [103, "OriginalTransmissionReference"], [105, "Headline"], [110, "Credit"], [115, "Source"], [116, "CopyrightNotice"], [118, "Contact"], [120, "Caption"], [121, "LocalCaption"], [122, "Writer"], [125, "RasterizedCaption"], [130, "ImageType"], [131, "ImageOrientation"], [135, "LanguageIdentifier"], [150, "AudioType"], [151, "AudioSamplingRate"], [152, "AudioSamplingResolution"], [153, "AudioDuration"], [154, "AudioOutcue"], [184, "JobID"], [185, "MasterDocumentID"], [186, "ShortDocumentID"], [187, "UniqueDocumentID"], [188, "OwnerID"], [200, "ObjectPreviewFileFormat"], [201, "ObjectPreviewFileVersion"], [202, "ObjectPreviewData"], [221, "Prefs"], [225, "ClassifyState"], [228, "SimilarityIndex"], [230, "DocumentNotes"], [231, "DocumentHistory"], [232, "ExifCameraInfo"], [255, "CatalogSets"]]), U(B, "iptc", [[10, { 0: "0 (reserved)", 1: "1 (most urgent)", 2: "2", 3: "3", 4: "4", 5: "5 (normal urgency)", 6: "6", 7: "7", 8: "8 (least urgent)", 9: "9 (user-defined priority)" }], [75, { a: "Morning", b: "Both Morning and Evening", p: "Evening" }], [131, { L: "Landscape", P: "Portrait", S: "Square" }]]);
  var full_esm_default = tt;

  // modules/services/plane_photo.js
  var dispatch6 = dispatch_default("viewerChanged");
  var _photo;
  var _wrapper;
  var imgZoom;
  var _widthOverflow;
  function zoomPan(d3_event) {
    let t2 = d3_event.transform;
    _photo.call(utilSetTransform, t2.x, t2.y, t2.k);
  }
  function zoomBeahvior() {
    const { width: wrapperWidth, height: wrapperHeight } = _wrapper.node().getBoundingClientRect();
    const { naturalHeight, naturalWidth } = _photo.node();
    const intrinsicRatio = naturalWidth / naturalHeight;
    _widthOverflow = wrapperHeight * intrinsicRatio - wrapperWidth;
    return zoom_default2().extent([[0, 0], [wrapperWidth, wrapperHeight]]).translateExtent([[0, 0], [wrapperWidth + _widthOverflow, wrapperHeight]]).scaleExtent([1, 15]).on("zoom", zoomPan);
  }
  function loadImage(selection2, path) {
    return new Promise((resolve) => {
      selection2.attr("src", path);
      selection2.on("load", () => {
        resolve(selection2);
      });
    });
  }
  var plane_photo_default = {
    init: async function(context, selection2) {
      this.event = utilRebind(this, dispatch6, "on");
      _wrapper = selection2.append("div").attr("class", "photo-frame plane-frame").classed("hide", true);
      _photo = _wrapper.append("img").attr("class", "plane-photo");
      context.ui().photoviewer.on("resize.plane", () => {
        imgZoom = zoomBeahvior();
        _wrapper.call(imgZoom);
      });
      await Promise.resolve();
      return this;
    },
    showPhotoFrame: function(context) {
      const isHidden = context.selectAll(".photo-frame.plane-frame.hide").size();
      if (isHidden) {
        context.selectAll(".photo-frame:not(.plane-frame)").classed("hide", true);
        context.selectAll(".photo-frame.plane-frame").classed("hide", false);
      }
      return this;
    },
    hidePhotoFrame: function(context) {
      context.select("photo-frame.plane-frame").classed("hide", false);
      return this;
    },
    selectPhoto: function(data, keepOrientation) {
      dispatch6.call("viewerChanged");
      loadImage(_photo, "");
      loadImage(_photo, data.image_path).then(() => {
        if (!keepOrientation) {
          imgZoom = zoomBeahvior();
          _wrapper.call(imgZoom);
          _wrapper.call(imgZoom.transform, identity2.translate(-_widthOverflow / 2, 0));
        }
      });
      return this;
    },
    getYaw: function() {
      return 0;
    }
  };

  // modules/svg/local_photos.js
  var _initialized2 = false;
  var _enabled2 = false;
  var minViewfieldZoom = 16;
  function svgLocalPhotos(projection2, context, dispatch14) {
    const detected = utilDetect();
    let layer = select_default2(null);
    let _fileList;
    let _photos = [];
    let _idAutoinc = 0;
    let _photoFrame;
    function init2() {
      if (_initialized2)
        return;
      _enabled2 = true;
      function over(d3_event) {
        d3_event.stopPropagation();
        d3_event.preventDefault();
        d3_event.dataTransfer.dropEffect = "copy";
      }
      context.container().attr("dropzone", "copy").on("drop.svgLocalPhotos", function(d3_event) {
        d3_event.stopPropagation();
        d3_event.preventDefault();
        if (!detected.filedrop)
          return;
        drawPhotos.fileList(d3_event.dataTransfer.files, (loaded) => {
          if (loaded.length > 0) {
            drawPhotos.fitZoom(false);
          }
        });
      }).on("dragenter.svgLocalPhotos", over).on("dragexit.svgLocalPhotos", over).on("dragover.svgLocalPhotos", over);
      _initialized2 = true;
    }
    function ensureViewerLoaded(context2) {
      if (_photoFrame) {
        return Promise.resolve(_photoFrame);
      }
      const viewer = context2.container().select(".photoviewer").selectAll(".local-photos-wrapper").data([0]);
      const viewerEnter = viewer.enter().append("div").attr("class", "photo-wrapper local-photos-wrapper").classed("hide", true);
      viewerEnter.append("div").attr("class", "photo-attribution photo-attribution-dual fillD");
      return plane_photo_default.init(context2, viewerEnter).then((planePhotoFrame) => {
        _photoFrame = planePhotoFrame;
      });
    }
    function click(d3_event, image, zoomTo) {
      ensureViewerLoaded(context).then(() => {
        const viewer = context.container().select(".photoviewer").datum(image).classed("hide", false);
        const viewerWrap = viewer.select(".local-photos-wrapper").classed("hide", false);
        const attribution = viewerWrap.selectAll(".photo-attribution").text("");
        if (image.date) {
          attribution.append("span").text(image.date.toLocaleString());
        }
        if (image.name) {
          attribution.append("span").classed("filename", true).text(image.name);
        }
        _photoFrame.selectPhoto({ image_path: "" });
        image.getSrc().then((src) => {
          _photoFrame.selectPhoto({ image_path: src }).showPhotoFrame(viewerWrap);
          setStyles();
        });
      });
      if (zoomTo) {
        context.map().centerEase(image.loc);
      }
    }
    function transform2(d2) {
      var svgpoint = projection2(d2.loc);
      return "translate(" + svgpoint[0] + "," + svgpoint[1] + ")";
    }
    function setStyles(hovered) {
      const viewer = context.container().select(".photoviewer");
      const selected = viewer.empty() ? void 0 : viewer.datum();
      context.container().selectAll(".layer-local-photos .viewfield-group").classed("hovered", (d2) => d2.id === (hovered == null ? void 0 : hovered.id)).classed("highlighted", (d2) => d2.id === (hovered == null ? void 0 : hovered.id) || d2.id === (selected == null ? void 0 : selected.id)).classed("currentView", (d2) => d2.id === (selected == null ? void 0 : selected.id));
    }
    function display_markers(imageList) {
      imageList = imageList.filter((image) => isArray_default(image.loc) && isNumber_default(image.loc[0]) && isNumber_default(image.loc[1]));
      const groups = layer.selectAll(".markers").selectAll(".viewfield-group").data(imageList, function(d2) {
        return d2.id;
      });
      groups.exit().remove();
      const groupsEnter = groups.enter().append("g").attr("class", "viewfield-group").on("mouseenter", (d3_event, d2) => setStyles(d2)).on("mouseleave", () => setStyles(null)).on("click", click);
      groupsEnter.append("g").attr("class", "viewfield-scale");
      const markers = groups.merge(groupsEnter).attr("transform", transform2).select(".viewfield-scale");
      markers.selectAll("circle").data([0]).enter().append("circle").attr("dx", "0").attr("dy", "0").attr("r", "6");
      const showViewfields = context.map().zoom() >= minViewfieldZoom;
      const viewfields = markers.selectAll(".viewfield").data(showViewfields ? [0] : []);
      viewfields.exit().remove();
      viewfields.enter().insert("path", "circle").attr("class", "viewfield").attr("transform", function() {
        var _a2;
        const d2 = this.parentNode.__data__;
        return "rotate(".concat(Math.round((_a2 = d2.direction) != null ? _a2 : 0), ",0,0),scale(1.5,1.5),translate(-8,-13)");
      }).attr("d", "M 6,9 C 8,8.4 8,8.4 10,9 L 16,-2 C 12,-5 4,-5 0,-2 z").style("visibility", function() {
        const d2 = this.parentNode.__data__;
        return isNumber_default(d2.direction) ? "visible" : "hidden";
      });
    }
    function drawPhotos(selection2) {
      layer = selection2.selectAll(".layer-local-photos").data(_photos ? [0] : []);
      layer.exit().remove();
      const layerEnter = layer.enter().append("g").attr("class", "layer-local-photos");
      layerEnter.append("g").attr("class", "markers");
      layer = layerEnter.merge(layer);
      if (_photos) {
        display_markers(_photos);
      }
    }
    function readFileAsDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = (error) => reject(error);
        reader.readAsDataURL(file);
      });
    }
    async function readmultifiles(files, callback) {
      const loaded = [];
      for (const file of files) {
        try {
          const exifData = await full_esm_default.parse(file);
          const photo = {
            id: _idAutoinc++,
            name: file.name,
            getSrc: () => readFileAsDataURL(file),
            file,
            loc: [exifData.longitude, exifData.latitude],
            direction: exifData.GPSImgDirection,
            date: exifData.CreateDate || exifData.DateTimeOriginal || exifData.ModifyDate
          };
          loaded.push(photo);
          const sameName = _photos.filter((i3) => i3.name === photo.name);
          if (sameName.length === 0) {
            _photos.push(photo);
          } else {
            const thisContent = await photo.getSrc();
            const sameNameContent = await Promise.allSettled(sameName.map((i3) => i3.getSrc()));
            if (!sameNameContent.some((i3) => i3.value === thisContent)) {
              _photos.push(photo);
            }
          }
        } catch {
        }
      }
      if (typeof callback === "function")
        callback(loaded);
      dispatch14.call("change");
    }
    drawPhotos.setFiles = function(fileList, callback) {
      readmultifiles(Array.from(fileList), callback);
      return this;
    };
    drawPhotos.fileList = function(fileList, callback) {
      if (!arguments.length)
        return _fileList;
      _fileList = fileList;
      if (!fileList || !fileList.length)
        return this;
      drawPhotos.setFiles(_fileList, callback);
      return this;
    };
    drawPhotos.getPhotos = function() {
      return _photos;
    };
    drawPhotos.removePhoto = function(id2) {
      _photos = _photos.filter((i3) => i3.id !== id2);
      dispatch14.call("change");
      return _photos;
    };
    drawPhotos.openPhoto = click;
    drawPhotos.fitZoom = function(force) {
      const coords = _photos.map((image) => image.loc).filter((l2) => isArray_default(l2) && isNumber_default(l2[0]) && isNumber_default(l2[1]));
      if (coords.length === 0)
        return;
      const extent = coords.map((l2) => geoExtent(l2, l2)).reduce((a2, b2) => a2.extend(b2));
      const map2 = context.map();
      var viewport = map2.trimmedExtent().polygon();
      if (force !== false || !geoPolygonIntersectsPolygon(viewport, coords, true)) {
        map2.centerZoom(extent.center(), Math.min(18, map2.trimmedExtentZoom(extent)));
      }
    };
    function showLayer() {
      layer.style("display", "block");
      layer.style("opacity", 0).transition().duration(250).style("opacity", 1).on("end", function() {
        dispatch14.call("change");
      });
    }
    function hideLayer() {
      layer.transition().duration(250).style("opacity", 0).on("end", () => {
        layer.selectAll(".viewfield-group").remove();
        layer.style("display", "none");
      });
    }
    drawPhotos.enabled = function(val) {
      if (!arguments.length)
        return _enabled2;
      _enabled2 = val;
      if (_enabled2) {
        showLayer();
      } else {
        hideLayer();
      }
      dispatch14.call("change");
      return this;
    };
    drawPhotos.hasData = function() {
      return isArray_default(_photos) && _photos.length > 0;
    };
    init2();
    return drawPhotos;
  }

  // modules/svg/improveOSM.js
  var _layerEnabled2 = false;
  var _qaService2;
  function svgImproveOSM(projection2, context, dispatch14) {
    const throttledRedraw = throttle_default(() => dispatch14.call("change"), 1e3);
    const minZoom4 = 12;
    let touchLayer = select_default2(null);
    let drawLayer = select_default2(null);
    let layerVisible = false;
    function markerPath(selection2, klass) {
      selection2.attr("class", klass).attr("transform", "translate(-10, -28)").attr("points", "16,3 4,3 1,6 1,17 4,20 7,20 10,27 13,20 16,20 19,17.033 19,6");
    }
    function getService() {
      if (services.improveOSM && !_qaService2) {
        _qaService2 = services.improveOSM;
        _qaService2.on("loaded", throttledRedraw);
      } else if (!services.improveOSM && _qaService2) {
        _qaService2 = null;
      }
      return _qaService2;
    }
    function editOn() {
      if (!layerVisible) {
        layerVisible = true;
        drawLayer.style("display", "block");
      }
    }
    function editOff() {
      if (layerVisible) {
        layerVisible = false;
        drawLayer.style("display", "none");
        drawLayer.selectAll(".qaItem.improveOSM").remove();
        touchLayer.selectAll(".qaItem.improveOSM").remove();
      }
    }
    function layerOn() {
      editOn();
      drawLayer.style("opacity", 0).transition().duration(250).style("opacity", 1).on("end interrupt", () => dispatch14.call("change"));
    }
    function layerOff() {
      throttledRedraw.cancel();
      drawLayer.interrupt();
      touchLayer.selectAll(".qaItem.improveOSM").remove();
      drawLayer.transition().duration(250).style("opacity", 0).on("end interrupt", () => {
        editOff();
        dispatch14.call("change");
      });
    }
    function updateMarkers() {
      if (!layerVisible || !_layerEnabled2)
        return;
      const service = getService();
      const selectedID = context.selectedErrorID();
      const data = service ? service.getItems(projection2) : [];
      const getTransform = svgPointTransform(projection2);
      const markers = drawLayer.selectAll(".qaItem.improveOSM").data(data, (d2) => d2.id);
      markers.exit().remove();
      const markersEnter = markers.enter().append("g").attr("class", (d2) => "qaItem ".concat(d2.service, " itemId-").concat(d2.id, " itemType-").concat(d2.itemType));
      markersEnter.append("polygon").call(markerPath, "shadow");
      markersEnter.append("ellipse").attr("cx", 0).attr("cy", 0).attr("rx", 4.5).attr("ry", 2).attr("class", "stroke");
      markersEnter.append("polygon").attr("fill", "currentColor").call(markerPath, "qaItem-fill");
      markersEnter.append("use").attr("class", "icon-annotation").attr("transform", "translate(-6, -22)").attr("width", "12px").attr("height", "12px").attr("xlink:href", (d2) => d2.icon ? "#" + d2.icon : "");
      markers.merge(markersEnter).sort(sortY).classed("selected", (d2) => d2.id === selectedID).attr("transform", getTransform);
      if (touchLayer.empty())
        return;
      const fillClass = context.getDebug("target") ? "pink " : "nocolor ";
      const targets = touchLayer.selectAll(".qaItem.improveOSM").data(data, (d2) => d2.id);
      targets.exit().remove();
      targets.enter().append("rect").attr("width", "20px").attr("height", "30px").attr("x", "-10px").attr("y", "-28px").merge(targets).sort(sortY).attr("class", (d2) => "qaItem ".concat(d2.service, " target ").concat(fillClass, " itemId-").concat(d2.id)).attr("transform", getTransform);
      function sortY(a2, b2) {
        return a2.id === selectedID ? 1 : b2.id === selectedID ? -1 : b2.loc[1] - a2.loc[1];
      }
    }
    function drawImproveOSM(selection2) {
      const service = getService();
      const surface = context.surface();
      if (surface && !surface.empty()) {
        touchLayer = surface.selectAll(".data-layer.touch .layer-touch.markers");
      }
      drawLayer = selection2.selectAll(".layer-improveOSM").data(service ? [0] : []);
      drawLayer.exit().remove();
      drawLayer = drawLayer.enter().append("g").attr("class", "layer-improveOSM").style("display", _layerEnabled2 ? "block" : "none").merge(drawLayer);
      if (_layerEnabled2) {
        if (service && ~~context.map().zoom() >= minZoom4) {
          editOn();
          service.loadIssues(projection2);
          updateMarkers();
        } else {
          editOff();
        }
      }
    }
    drawImproveOSM.enabled = function(val) {
      if (!arguments.length)
        return _layerEnabled2;
      _layerEnabled2 = val;
      if (_layerEnabled2) {
        layerOn();
      } else {
        layerOff();
        if (context.selectedErrorID()) {
          context.enter(modeBrowse(context));
        }
      }
      dispatch14.call("change");
      return this;
    };
    drawImproveOSM.supported = () => !!getService();
    return drawImproveOSM;
  }

  // modules/svg/osmose.js
  var _layerEnabled3 = false;
  var _qaService3;
  function svgOsmose(projection2, context, dispatch14) {
    const throttledRedraw = throttle_default(() => dispatch14.call("change"), 1e3);
    const minZoom4 = 12;
    let touchLayer = select_default2(null);
    let drawLayer = select_default2(null);
    let layerVisible = false;
    function markerPath(selection2, klass) {
      selection2.attr("class", klass).attr("transform", "translate(-10, -28)").attr("points", "16,3 4,3 1,6 1,17 4,20 7,20 10,27 13,20 16,20 19,17.033 19,6");
    }
    function getService() {
      if (services.osmose && !_qaService3) {
        _qaService3 = services.osmose;
        _qaService3.on("loaded", throttledRedraw);
      } else if (!services.osmose && _qaService3) {
        _qaService3 = null;
      }
      return _qaService3;
    }
    function editOn() {
      if (!layerVisible) {
        layerVisible = true;
        drawLayer.style("display", "block");
      }
    }
    function editOff() {
      if (layerVisible) {
        layerVisible = false;
        drawLayer.style("display", "none");
        drawLayer.selectAll(".qaItem.osmose").remove();
        touchLayer.selectAll(".qaItem.osmose").remove();
      }
    }
    function layerOn() {
      editOn();
      drawLayer.style("opacity", 0).transition().duration(250).style("opacity", 1).on("end interrupt", () => dispatch14.call("change"));
    }
    function layerOff() {
      throttledRedraw.cancel();
      drawLayer.interrupt();
      touchLayer.selectAll(".qaItem.osmose").remove();
      drawLayer.transition().duration(250).style("opacity", 0).on("end interrupt", () => {
        editOff();
        dispatch14.call("change");
      });
    }
    function updateMarkers() {
      if (!layerVisible || !_layerEnabled3)
        return;
      const service = getService();
      const selectedID = context.selectedErrorID();
      const data = service ? service.getItems(projection2) : [];
      const getTransform = svgPointTransform(projection2);
      const markers = drawLayer.selectAll(".qaItem.osmose").data(data, (d2) => d2.id);
      markers.exit().remove();
      const markersEnter = markers.enter().append("g").attr("class", (d2) => "qaItem ".concat(d2.service, " itemId-").concat(d2.id, " itemType-").concat(d2.itemType));
      markersEnter.append("polygon").call(markerPath, "shadow");
      markersEnter.append("ellipse").attr("cx", 0).attr("cy", 0).attr("rx", 4.5).attr("ry", 2).attr("class", "stroke");
      markersEnter.append("polygon").attr("fill", (d2) => service.getColor(d2.item)).call(markerPath, "qaItem-fill");
      markersEnter.append("use").attr("class", "icon-annotation").attr("transform", "translate(-6, -22)").attr("width", "12px").attr("height", "12px").attr("xlink:href", (d2) => d2.icon ? "#" + d2.icon : "");
      markers.merge(markersEnter).sort(sortY).classed("selected", (d2) => d2.id === selectedID).attr("transform", getTransform);
      if (touchLayer.empty())
        return;
      const fillClass = context.getDebug("target") ? "pink" : "nocolor";
      const targets = touchLayer.selectAll(".qaItem.osmose").data(data, (d2) => d2.id);
      targets.exit().remove();
      targets.enter().append("rect").attr("width", "20px").attr("height", "30px").attr("x", "-10px").attr("y", "-28px").merge(targets).sort(sortY).attr("class", (d2) => "qaItem ".concat(d2.service, " target ").concat(fillClass, " itemId-").concat(d2.id)).attr("transform", getTransform);
      function sortY(a2, b2) {
        return a2.id === selectedID ? 1 : b2.id === selectedID ? -1 : b2.loc[1] - a2.loc[1];
      }
    }
    function drawOsmose(selection2) {
      const service = getService();
      const surface = context.surface();
      if (surface && !surface.empty()) {
        touchLayer = surface.selectAll(".data-layer.touch .layer-touch.markers");
      }
      drawLayer = selection2.selectAll(".layer-osmose").data(service ? [0] : []);
      drawLayer.exit().remove();
      drawLayer = drawLayer.enter().append("g").attr("class", "layer-osmose").style("display", _layerEnabled3 ? "block" : "none").merge(drawLayer);
      if (_layerEnabled3) {
        if (service && ~~context.map().zoom() >= minZoom4) {
          editOn();
          service.loadIssues(projection2);
          updateMarkers();
        } else {
          editOff();
        }
      }
    }
    drawOsmose.enabled = function(val) {
      if (!arguments.length)
        return _layerEnabled3;
      _layerEnabled3 = val;
      if (_layerEnabled3) {
        getService().loadStrings().then(layerOn).catch((err) => {
          console.log(err);
        });
      } else {
        layerOff();
        if (context.selectedErrorID()) {
          context.enter(modeBrowse(context));
        }
      }
      dispatch14.call("change");
      return this;
    };
    drawOsmose.supported = () => !!getService();
    return drawOsmose;
  }

  // modules/svg/streetside.js
  function svgStreetside(projection2, context, dispatch14) {
    var throttledRedraw = throttle_default(function() {
      dispatch14.call("change");
    }, 1e3);
    var minZoom4 = 14;
    var minMarkerZoom = 16;
    var minViewfieldZoom2 = 18;
    var layer = select_default2(null);
    var _viewerYaw = 0;
    var _selectedSequence = null;
    var _streetside;
    function init2() {
      if (svgStreetside.initialized)
        return;
      svgStreetside.enabled = false;
      svgStreetside.initialized = true;
    }
    function getService() {
      if (services.streetside && !_streetside) {
        _streetside = services.streetside;
        _streetside.event.on("viewerChanged.svgStreetside", viewerChanged).on("loadedImages.svgStreetside", throttledRedraw);
      } else if (!services.streetside && _streetside) {
        _streetside = null;
      }
      return _streetside;
    }
    function showLayer() {
      var service = getService();
      if (!service)
        return;
      editOn();
      layer.style("opacity", 0).transition().duration(250).style("opacity", 1).on("end", function() {
        dispatch14.call("change");
      });
    }
    function hideLayer() {
      throttledRedraw.cancel();
      layer.transition().duration(250).style("opacity", 0).on("end", editOff);
    }
    function editOn() {
      layer.style("display", "block");
    }
    function editOff() {
      layer.selectAll(".viewfield-group").remove();
      layer.style("display", "none");
    }
    function click(d3_event, d2) {
      var service = getService();
      if (!service)
        return;
      if (d2.sequenceKey !== _selectedSequence) {
        _viewerYaw = 0;
      }
      _selectedSequence = d2.sequenceKey;
      service.ensureViewerLoaded(context).then(function() {
        service.selectImage(context, d2.key).yaw(_viewerYaw).showViewer(context);
      });
      context.map().centerEase(d2.loc);
    }
    function mouseover(d3_event, d2) {
      var service = getService();
      if (service)
        service.setStyles(context, d2);
    }
    function mouseout() {
      var service = getService();
      if (service)
        service.setStyles(context, null);
    }
    function transform2(d2) {
      var t2 = svgPointTransform(projection2)(d2);
      var rot = d2.ca + _viewerYaw;
      if (rot) {
        t2 += " rotate(" + Math.floor(rot) + ",0,0)";
      }
      return t2;
    }
    function viewerChanged() {
      var service = getService();
      if (!service)
        return;
      var viewer = service.viewer();
      if (!viewer)
        return;
      _viewerYaw = viewer.getYaw();
      if (context.map().isTransformed())
        return;
      layer.selectAll(".viewfield-group.currentView").attr("transform", transform2);
    }
    function filterBubbles(bubbles) {
      var fromDate = context.photos().fromDate();
      var toDate = context.photos().toDate();
      var usernames = context.photos().usernames();
      if (fromDate) {
        var fromTimestamp = new Date(fromDate).getTime();
        bubbles = bubbles.filter(function(bubble) {
          return new Date(bubble.captured_at).getTime() >= fromTimestamp;
        });
      }
      if (toDate) {
        var toTimestamp = new Date(toDate).getTime();
        bubbles = bubbles.filter(function(bubble) {
          return new Date(bubble.captured_at).getTime() <= toTimestamp;
        });
      }
      if (usernames) {
        bubbles = bubbles.filter(function(bubble) {
          return usernames.indexOf(bubble.captured_by) !== -1;
        });
      }
      return bubbles;
    }
    function filterSequences(sequences) {
      var fromDate = context.photos().fromDate();
      var toDate = context.photos().toDate();
      var usernames = context.photos().usernames();
      if (fromDate) {
        var fromTimestamp = new Date(fromDate).getTime();
        sequences = sequences.filter(function(sequences2) {
          return new Date(sequences2.properties.captured_at).getTime() >= fromTimestamp;
        });
      }
      if (toDate) {
        var toTimestamp = new Date(toDate).getTime();
        sequences = sequences.filter(function(sequences2) {
          return new Date(sequences2.properties.captured_at).getTime() <= toTimestamp;
        });
      }
      if (usernames) {
        sequences = sequences.filter(function(sequences2) {
          return usernames.indexOf(sequences2.properties.captured_by) !== -1;
        });
      }
      return sequences;
    }
    function update() {
      var viewer = context.container().select(".photoviewer");
      var selected = viewer.empty() ? void 0 : viewer.datum();
      var z2 = ~~context.map().zoom();
      var showMarkers = z2 >= minMarkerZoom;
      var showViewfields = z2 >= minViewfieldZoom2;
      var service = getService();
      var sequences = [];
      var bubbles = [];
      if (context.photos().showsPanoramic()) {
        sequences = service ? service.sequences(projection2) : [];
        bubbles = service && showMarkers ? service.bubbles(projection2) : [];
        sequences = filterSequences(sequences);
        bubbles = filterBubbles(bubbles);
      }
      var traces = layer.selectAll(".sequences").selectAll(".sequence").data(sequences, function(d2) {
        return d2.properties.key;
      });
      traces.exit().remove();
      traces = traces.enter().append("path").attr("class", "sequence").merge(traces).attr("d", svgPath(projection2).geojson);
      var groups = layer.selectAll(".markers").selectAll(".viewfield-group").data(bubbles, function(d2) {
        return d2.key + (d2.sequenceKey ? "v1" : "v0");
      });
      groups.exit().remove();
      var groupsEnter = groups.enter().append("g").attr("class", "viewfield-group").on("mouseenter", mouseover).on("mouseleave", mouseout).on("click", click);
      groupsEnter.append("g").attr("class", "viewfield-scale");
      var markers = groups.merge(groupsEnter).sort(function(a2, b2) {
        return a2 === selected ? 1 : b2 === selected ? -1 : b2.loc[1] - a2.loc[1];
      }).attr("transform", transform2).select(".viewfield-scale");
      markers.selectAll("circle").data([0]).enter().append("circle").attr("dx", "0").attr("dy", "0").attr("r", "6");
      var viewfields = markers.selectAll(".viewfield").data(showViewfields ? [0] : []);
      viewfields.exit().remove();
      viewfields.enter().insert("path", "circle").attr("class", "viewfield").attr("transform", "scale(1.5,1.5),translate(-8, -13)").attr("d", viewfieldPath);
      function viewfieldPath() {
        var d2 = this.parentNode.__data__;
        if (d2.pano) {
          return "M 8,13 m -10,0 a 10,10 0 1,0 20,0 a 10,10 0 1,0 -20,0";
        } else {
          return "M 6,9 C 8,8.4 8,8.4 10,9 L 16,-2 C 12,-5 4,-5 0,-2 z";
        }
      }
    }
    function drawImages(selection2) {
      var enabled = svgStreetside.enabled;
      var service = getService();
      layer = selection2.selectAll(".layer-streetside-images").data(service ? [0] : []);
      layer.exit().remove();
      var layerEnter = layer.enter().append("g").attr("class", "layer-streetside-images").style("display", enabled ? "block" : "none");
      layerEnter.append("g").attr("class", "sequences");
      layerEnter.append("g").attr("class", "markers");
      layer = layerEnter.merge(layer);
      if (enabled) {
        if (service && ~~context.map().zoom() >= minZoom4) {
          editOn();
          update();
          service.loadBubbles(projection2);
        } else {
          editOff();
        }
      }
    }
    drawImages.enabled = function(_2) {
      if (!arguments.length)
        return svgStreetside.enabled;
      svgStreetside.enabled = _2;
      if (svgStreetside.enabled) {
        showLayer();
        context.photos().on("change.streetside", update);
      } else {
        hideLayer();
        context.photos().on("change.streetside", null);
      }
      dispatch14.call("change");
      return this;
    };
    drawImages.supported = function() {
      return !!getService();
    };
    drawImages.rendered = function(zoom) {
      return zoom >= minZoom4;
    };
    init2();
    return drawImages;
  }

  // modules/svg/vegbilder.js
  function svgVegbilder(projection2, context, dispatch14) {
    const throttledRedraw = throttle_default(() => dispatch14.call("change"), 1e3);
    const minZoom4 = 14;
    const minMarkerZoom = 16;
    const minViewfieldZoom2 = 18;
    let layer = select_default2(null);
    let _viewerYaw = 0;
    let _vegbilder;
    function init2() {
      if (svgVegbilder.initialized)
        return;
      svgVegbilder.enabled = false;
      svgVegbilder.initialized = true;
    }
    function getService() {
      if (services.vegbilder && !_vegbilder) {
        _vegbilder = services.vegbilder;
        _vegbilder.event.on("viewerChanged.svgVegbilder", viewerChanged).on("loadedImages.svgVegbilder", throttledRedraw);
      } else if (!services.vegbilder && _vegbilder) {
        _vegbilder = null;
      }
      return _vegbilder;
    }
    function showLayer() {
      const service = getService();
      if (!service)
        return;
      editOn();
      layer.style("opacity", 0).transition().duration(250).style("opacity", 1).on("end", () => dispatch14.call("change"));
    }
    function hideLayer() {
      throttledRedraw.cancel();
      layer.transition().duration(250).style("opacity", 0).on("end", editOff);
    }
    function editOn() {
      layer.style("display", "block");
    }
    function editOff() {
      layer.selectAll(".viewfield-group").remove();
      layer.style("display", "none");
    }
    function click(d3_event, d2) {
      const service = getService();
      if (!service)
        return;
      service.ensureViewerLoaded(context).then(() => {
        service.selectImage(context, d2.key).showViewer(context);
      });
      context.map().centerEase(d2.loc);
    }
    function mouseover(d3_event, d2) {
      const service = getService();
      if (service)
        service.setStyles(context, d2);
    }
    function mouseout() {
      const service = getService();
      if (service)
        service.setStyles(context, null);
    }
    function transform2(d2, selected) {
      let t2 = svgPointTransform(projection2)(d2);
      let rot = d2.ca;
      if (d2 === selected) {
        rot += _viewerYaw;
      }
      if (rot) {
        t2 += " rotate(" + Math.floor(rot) + ",0,0)";
      }
      return t2;
    }
    function viewerChanged() {
      const service = getService();
      if (!service)
        return;
      const frame2 = service.photoFrame();
      _viewerYaw = frame2.getYaw();
      if (context.map().isTransformed())
        return;
      layer.selectAll(".viewfield-group.currentView").attr("transform", (d2) => transform2(d2, d2));
    }
    function filterImages(images) {
      const photoContext = context.photos();
      const fromDateString = photoContext.fromDate();
      const toDateString = photoContext.toDate();
      const showsFlat = photoContext.showsFlat();
      const showsPano = photoContext.showsPanoramic();
      if (fromDateString) {
        const fromDate = new Date(fromDateString);
        images = images.filter((image) => image.captured_at.getTime() >= fromDate.getTime());
      }
      if (toDateString) {
        const toDate = new Date(toDateString);
        images = images.filter((image) => image.captured_at.getTime() <= toDate.getTime());
      }
      if (!showsPano) {
        images = images.filter((image) => !image.is_sphere);
      }
      if (!showsFlat) {
        images = images.filter((image) => image.is_sphere);
      }
      return images;
    }
    function filterSequences(sequences) {
      const photoContext = context.photos();
      const fromDateString = photoContext.fromDate();
      const toDateString = photoContext.toDate();
      const showsFlat = photoContext.showsFlat();
      const showsPano = photoContext.showsPanoramic();
      if (fromDateString) {
        const fromDate = new Date(fromDateString);
        sequences = sequences.filter(({ images }) => images[0].captured_at.getTime() >= fromDate.getTime());
      }
      if (toDateString) {
        const toDate = new Date(toDateString);
        sequences = sequences.filter(({ images }) => images[images.length - 1].captured_at.getTime() <= toDate.getTime());
      }
      if (!showsPano) {
        sequences = sequences.filter(({ images }) => !images[0].is_sphere);
      }
      if (!showsFlat) {
        sequences = sequences.filter(({ images }) => images[0].is_sphere);
      }
      return sequences;
    }
    function update() {
      const viewer = context.container().select(".photoviewer");
      const selected = viewer.empty() ? void 0 : viewer.datum();
      const z2 = ~~context.map().zoom();
      const showMarkers = z2 >= minMarkerZoom;
      const showViewfields = z2 >= minViewfieldZoom2;
      const service = getService();
      let sequences = [];
      let images = [];
      if (service) {
        service.loadImages(context);
        sequences = service.sequences(projection2);
        images = showMarkers ? service.images(projection2) : [];
        images = filterImages(images);
        sequences = filterSequences(sequences);
      }
      let traces = layer.selectAll(".sequences").selectAll(".sequence").data(sequences, (d2) => d2.key);
      traces.exit().remove();
      traces.enter().append("path").attr("class", "sequence").merge(traces).attr("d", svgPath(projection2).geojson);
      const groups = layer.selectAll(".markers").selectAll(".viewfield-group").data(images, (d2) => d2.key);
      groups.exit().remove();
      const groupsEnter = groups.enter().append("g").attr("class", "viewfield-group").on("mouseenter", mouseover).on("mouseleave", mouseout).on("click", click);
      groupsEnter.append("g").attr("class", "viewfield-scale");
      const markers = groups.merge(groupsEnter).sort((a2, b2) => {
        return a2 === selected ? 1 : b2 === selected ? -1 : b2.loc[1] - a2.loc[1];
      }).attr("transform", (d2) => transform2(d2, selected)).select(".viewfield-scale");
      markers.selectAll("circle").data([0]).enter().append("circle").attr("dx", "0").attr("dy", "0").attr("r", "6");
      const viewfields = markers.selectAll(".viewfield").data(showViewfields ? [0] : []);
      viewfields.exit().remove();
      viewfields.enter().insert("path", "circle").attr("class", "viewfield").attr("transform", "scale(1.5,1.5),translate(-8, -13)").attr("d", viewfieldPath);
      function viewfieldPath() {
        const d2 = this.parentNode.__data__;
        if (d2.is_sphere) {
          return "M 8,13 m -10,0 a 10,10 0 1,0 20,0 a 10,10 0 1,0 -20,0";
        } else {
          return "M 6,9 C 8,8.4 8,8.4 10,9 L 16,-2 C 12,-5 4,-5 0,-2 z";
        }
      }
    }
    function drawImages(selection2) {
      const enabled = svgVegbilder.enabled;
      const service = getService();
      layer = selection2.selectAll(".layer-vegbilder").data(service ? [0] : []);
      layer.exit().remove();
      const layerEnter = layer.enter().append("g").attr("class", "layer-vegbilder").style("display", enabled ? "block" : "none");
      layerEnter.append("g").attr("class", "sequences");
      layerEnter.append("g").attr("class", "markers");
      layer = layerEnter.merge(layer);
      if (enabled) {
        if (service && ~~context.map().zoom() >= minZoom4) {
          editOn();
          update();
          service.loadImages(context);
        } else {
          editOff();
        }
      }
    }
    drawImages.enabled = function(_2) {
      if (!arguments.length)
        return svgVegbilder.enabled;
      svgVegbilder.enabled = _2;
      if (svgVegbilder.enabled) {
        showLayer();
        context.photos().on("change.vegbilder", update);
      } else {
        hideLayer();
        context.photos().on("change.vegbilder", null);
      }
      dispatch14.call("change");
      return this;
    };
    drawImages.supported = function() {
      return !!getService();
    };
    drawImages.rendered = function(zoom) {
      return zoom >= minZoom4;
    };
    drawImages.validHere = function(extent, zoom) {
      return zoom >= minZoom4 - 2 && getService().validHere(extent);
    };
    init2();
    return drawImages;
  }

  // modules/svg/mapillary_images.js
  function svgMapillaryImages(projection2, context, dispatch14) {
    const throttledRedraw = throttle_default(function() {
      dispatch14.call("change");
    }, 1e3);
    const minZoom4 = 12;
    const minMarkerZoom = 16;
    const minViewfieldZoom2 = 18;
    let layer = select_default2(null);
    let _mapillary;
    function init2() {
      if (svgMapillaryImages.initialized)
        return;
      svgMapillaryImages.enabled = false;
      svgMapillaryImages.initialized = true;
    }
    function getService() {
      if (services.mapillary && !_mapillary) {
        _mapillary = services.mapillary;
        _mapillary.event.on("loadedImages", throttledRedraw);
      } else if (!services.mapillary && _mapillary) {
        _mapillary = null;
      }
      return _mapillary;
    }
    function showLayer() {
      const service = getService();
      if (!service)
        return;
      editOn();
      layer.style("opacity", 0).transition().duration(250).style("opacity", 1).on("end", function() {
        dispatch14.call("change");
      });
    }
    function hideLayer() {
      throttledRedraw.cancel();
      layer.transition().duration(250).style("opacity", 0).on("end", editOff);
    }
    function editOn() {
      layer.style("display", "block");
    }
    function editOff() {
      layer.selectAll(".viewfield-group").remove();
      layer.style("display", "none");
    }
    function click(d3_event, image) {
      const service = getService();
      if (!service)
        return;
      service.ensureViewerLoaded(context).then(function() {
        service.selectImage(context, image.id).showViewer(context);
      });
      context.map().centerEase(image.loc);
    }
    function mouseover(d3_event, image) {
      const service = getService();
      if (service)
        service.setStyles(context, image);
    }
    function mouseout() {
      const service = getService();
      if (service)
        service.setStyles(context, null);
    }
    function transform2(d2) {
      let t2 = svgPointTransform(projection2)(d2);
      if (d2.ca) {
        t2 += " rotate(" + Math.floor(d2.ca) + ",0,0)";
      }
      return t2;
    }
    function filterImages(images) {
      const showsPano = context.photos().showsPanoramic();
      const showsFlat = context.photos().showsFlat();
      const fromDate = context.photos().fromDate();
      const toDate = context.photos().toDate();
      if (!showsPano || !showsFlat) {
        images = images.filter(function(image) {
          if (image.is_pano)
            return showsPano;
          return showsFlat;
        });
      }
      if (fromDate) {
        images = images.filter(function(image) {
          return new Date(image.captured_at).getTime() >= new Date(fromDate).getTime();
        });
      }
      if (toDate) {
        images = images.filter(function(image) {
          return new Date(image.captured_at).getTime() <= new Date(toDate).getTime();
        });
      }
      return images;
    }
    function filterSequences(sequences) {
      const showsPano = context.photos().showsPanoramic();
      const showsFlat = context.photos().showsFlat();
      const fromDate = context.photos().fromDate();
      const toDate = context.photos().toDate();
      if (!showsPano || !showsFlat) {
        sequences = sequences.filter(function(sequence) {
          if (sequence.properties.hasOwnProperty("is_pano")) {
            if (sequence.properties.is_pano)
              return showsPano;
            return showsFlat;
          }
          return false;
        });
      }
      if (fromDate) {
        sequences = sequences.filter(function(sequence) {
          return new Date(sequence.properties.captured_at).getTime() >= new Date(fromDate).getTime().toString();
        });
      }
      if (toDate) {
        sequences = sequences.filter(function(sequence) {
          return new Date(sequence.properties.captured_at).getTime() <= new Date(toDate).getTime().toString();
        });
      }
      return sequences;
    }
    function update() {
      const z2 = ~~context.map().zoom();
      const showMarkers = z2 >= minMarkerZoom;
      const showViewfields = z2 >= minViewfieldZoom2;
      const service = getService();
      let sequences = service ? service.sequences(projection2) : [];
      let images = service && showMarkers ? service.images(projection2) : [];
      images = filterImages(images);
      sequences = filterSequences(sequences, service);
      service.filterViewer(context);
      let traces = layer.selectAll(".sequences").selectAll(".sequence").data(sequences, function(d2) {
        return d2.properties.id;
      });
      traces.exit().remove();
      traces = traces.enter().append("path").attr("class", "sequence").merge(traces).attr("d", svgPath(projection2).geojson);
      const groups = layer.selectAll(".markers").selectAll(".viewfield-group").data(images, function(d2) {
        return d2.id;
      });
      groups.exit().remove();
      const groupsEnter = groups.enter().append("g").attr("class", "viewfield-group").on("mouseenter", mouseover).on("mouseleave", mouseout).on("click", click);
      groupsEnter.append("g").attr("class", "viewfield-scale");
      const markers = groups.merge(groupsEnter).sort(function(a2, b2) {
        return b2.loc[1] - a2.loc[1];
      }).attr("transform", transform2).select(".viewfield-scale");
      markers.selectAll("circle").data([0]).enter().append("circle").attr("dx", "0").attr("dy", "0").attr("r", "6");
      const viewfields = markers.selectAll(".viewfield").data(showViewfields ? [0] : []);
      viewfields.exit().remove();
      viewfields.enter().insert("path", "circle").attr("class", "viewfield").classed("pano", function() {
        return this.parentNode.__data__.is_pano;
      }).attr("transform", "scale(1.5,1.5),translate(-8, -13)").attr("d", viewfieldPath);
      function viewfieldPath() {
        if (this.parentNode.__data__.is_pano) {
          return "M 8,13 m -10,0 a 10,10 0 1,0 20,0 a 10,10 0 1,0 -20,0";
        } else {
          return "M 6,9 C 8,8.4 8,8.4 10,9 L 16,-2 C 12,-5 4,-5 0,-2 z";
        }
      }
    }
    function drawImages(selection2) {
      const enabled = svgMapillaryImages.enabled;
      const service = getService();
      layer = selection2.selectAll(".layer-mapillary").data(service ? [0] : []);
      layer.exit().remove();
      const layerEnter = layer.enter().append("g").attr("class", "layer-mapillary").style("display", enabled ? "block" : "none");
      layerEnter.append("g").attr("class", "sequences");
      layerEnter.append("g").attr("class", "markers");
      layer = layerEnter.merge(layer);
      if (enabled) {
        if (service && ~~context.map().zoom() >= minZoom4) {
          editOn();
          update();
          service.loadImages(projection2);
        } else {
          editOff();
        }
      }
    }
    drawImages.enabled = function(_2) {
      if (!arguments.length)
        return svgMapillaryImages.enabled;
      svgMapillaryImages.enabled = _2;
      if (svgMapillaryImages.enabled) {
        showLayer();
        context.photos().on("change.mapillary_images", update);
      } else {
        hideLayer();
        context.photos().on("change.mapillary_images", null);
      }
      dispatch14.call("change");
      return this;
    };
    drawImages.supported = function() {
      return !!getService();
    };
    drawImages.rendered = function(zoom) {
      return zoom >= minZoom4;
    };
    init2();
    return drawImages;
  }

  // modules/svg/mapillary_position.js
  function svgMapillaryPosition(projection2, context) {
    const throttledRedraw = throttle_default(function() {
      update();
    }, 1e3);
    const minZoom4 = 12;
    const minViewfieldZoom2 = 18;
    let layer = select_default2(null);
    let _mapillary;
    let viewerCompassAngle;
    function init2() {
      if (svgMapillaryPosition.initialized)
        return;
      svgMapillaryPosition.initialized = true;
    }
    function getService() {
      if (services.mapillary && !_mapillary) {
        _mapillary = services.mapillary;
        _mapillary.event.on("imageChanged", throttledRedraw);
        _mapillary.event.on("bearingChanged", function(e3) {
          viewerCompassAngle = e3.bearing;
          if (context.map().isTransformed())
            return;
          layer.selectAll(".viewfield-group.currentView").filter(function(d2) {
            return d2.is_pano;
          }).attr("transform", transform2);
        });
      } else if (!services.mapillary && _mapillary) {
        _mapillary = null;
      }
      return _mapillary;
    }
    function editOn() {
      layer.style("display", "block");
    }
    function editOff() {
      layer.selectAll(".viewfield-group").remove();
      layer.style("display", "none");
    }
    function transform2(d2) {
      let t2 = svgPointTransform(projection2)(d2);
      if (d2.is_pano && viewerCompassAngle !== null && isFinite(viewerCompassAngle)) {
        t2 += " rotate(" + Math.floor(viewerCompassAngle) + ",0,0)";
      } else if (d2.ca) {
        t2 += " rotate(" + Math.floor(d2.ca) + ",0,0)";
      }
      return t2;
    }
    function update() {
      const z2 = ~~context.map().zoom();
      const showViewfields = z2 >= minViewfieldZoom2;
      const service = getService();
      const image = service && service.getActiveImage();
      const groups = layer.selectAll(".markers").selectAll(".viewfield-group").data(image ? [image] : [], function(d2) {
        return d2.id;
      });
      groups.exit().remove();
      const groupsEnter = groups.enter().append("g").attr("class", "viewfield-group currentView highlighted");
      groupsEnter.append("g").attr("class", "viewfield-scale");
      const markers = groups.merge(groupsEnter).attr("transform", transform2).select(".viewfield-scale");
      markers.selectAll("circle").data([0]).enter().append("circle").attr("dx", "0").attr("dy", "0").attr("r", "6");
      const viewfields = markers.selectAll(".viewfield").data(showViewfields ? [0] : []);
      viewfields.exit().remove();
      viewfields.enter().insert("path", "circle").attr("class", "viewfield").attr("transform", "scale(1.5,1.5),translate(-8, -13)").attr("d", "M 6,9 C 8,8.4 8,8.4 10,9 L 16,-2 C 12,-5 4,-5 0,-2 z");
    }
    function drawImages(selection2) {
      const service = getService();
      layer = selection2.selectAll(".layer-mapillary-position").data(service ? [0] : []);
      layer.exit().remove();
      const layerEnter = layer.enter().append("g").attr("class", "layer-mapillary-position");
      layerEnter.append("g").attr("class", "markers");
      layer = layerEnter.merge(layer);
      if (service && ~~context.map().zoom() >= minZoom4) {
        editOn();
        update();
      } else {
        editOff();
      }
    }
    drawImages.enabled = function() {
      update();
      return this;
    };
    drawImages.supported = function() {
      return !!getService();
    };
    drawImages.rendered = function(zoom) {
      return zoom >= minZoom4;
    };
    init2();
    return drawImages;
  }

  // modules/svg/mapillary_signs.js
  function svgMapillarySigns(projection2, context, dispatch14) {
    const throttledRedraw = throttle_default(function() {
      dispatch14.call("change");
    }, 1e3);
    const minZoom4 = 12;
    let layer = select_default2(null);
    let _mapillary;
    function init2() {
      if (svgMapillarySigns.initialized)
        return;
      svgMapillarySigns.enabled = false;
      svgMapillarySigns.initialized = true;
    }
    function getService() {
      if (services.mapillary && !_mapillary) {
        _mapillary = services.mapillary;
        _mapillary.event.on("loadedSigns", throttledRedraw);
      } else if (!services.mapillary && _mapillary) {
        _mapillary = null;
      }
      return _mapillary;
    }
    function showLayer() {
      const service = getService();
      if (!service)
        return;
      service.loadSignResources(context);
      editOn();
    }
    function hideLayer() {
      throttledRedraw.cancel();
      editOff();
    }
    function editOn() {
      layer.style("display", "block");
    }
    function editOff() {
      layer.selectAll(".icon-sign").remove();
      layer.style("display", "none");
    }
    function click(d3_event, d2) {
      const service = getService();
      if (!service)
        return;
      context.map().centerEase(d2.loc);
      const selectedImageId = service.getActiveImage() && service.getActiveImage().id;
      service.getDetections(d2.id).then((detections) => {
        if (detections.length) {
          const imageId = detections[0].image.id;
          if (imageId === selectedImageId) {
            service.highlightDetection(detections[0]).selectImage(context, imageId);
          } else {
            service.ensureViewerLoaded(context).then(function() {
              service.highlightDetection(detections[0]).selectImage(context, imageId).showViewer(context);
            });
          }
        }
      });
    }
    function filterData(detectedFeatures) {
      var fromDate = context.photos().fromDate();
      var toDate = context.photos().toDate();
      if (fromDate) {
        var fromTimestamp = new Date(fromDate).getTime();
        detectedFeatures = detectedFeatures.filter(function(feature3) {
          return new Date(feature3.last_seen_at).getTime() >= fromTimestamp;
        });
      }
      if (toDate) {
        var toTimestamp = new Date(toDate).getTime();
        detectedFeatures = detectedFeatures.filter(function(feature3) {
          return new Date(feature3.first_seen_at).getTime() <= toTimestamp;
        });
      }
      return detectedFeatures;
    }
    function update() {
      const service = getService();
      let data = service ? service.signs(projection2) : [];
      data = filterData(data);
      const transform2 = svgPointTransform(projection2);
      const signs = layer.selectAll(".icon-sign").data(data, function(d2) {
        return d2.id;
      });
      signs.exit().remove();
      const enter = signs.enter().append("g").attr("class", "icon-sign icon-detected").on("click", click);
      enter.append("use").attr("width", "24px").attr("height", "24px").attr("x", "-12px").attr("y", "-12px").attr("xlink:href", function(d2) {
        return "#" + d2.value;
      });
      enter.append("rect").attr("width", "24px").attr("height", "24px").attr("x", "-12px").attr("y", "-12px");
      signs.merge(enter).attr("transform", transform2);
    }
    function drawSigns(selection2) {
      const enabled = svgMapillarySigns.enabled;
      const service = getService();
      layer = selection2.selectAll(".layer-mapillary-signs").data(service ? [0] : []);
      layer.exit().remove();
      layer = layer.enter().append("g").attr("class", "layer-mapillary-signs layer-mapillary-detections").style("display", enabled ? "block" : "none").merge(layer);
      if (enabled) {
        if (service && ~~context.map().zoom() >= minZoom4) {
          editOn();
          update();
          service.loadSigns(projection2);
          service.showSignDetections(true);
        } else {
          editOff();
        }
      } else if (service) {
        service.showSignDetections(false);
      }
    }
    drawSigns.enabled = function(_2) {
      if (!arguments.length)
        return svgMapillarySigns.enabled;
      svgMapillarySigns.enabled = _2;
      if (svgMapillarySigns.enabled) {
        showLayer();
        context.photos().on("change.mapillary_signs", update);
      } else {
        hideLayer();
        context.photos().on("change.mapillary_signs", null);
      }
      dispatch14.call("change");
      return this;
    };
    drawSigns.supported = function() {
      return !!getService();
    };
    drawSigns.rendered = function(zoom) {
      return zoom >= minZoom4;
    };
    init2();
    return drawSigns;
  }

  // modules/svg/mapillary_map_features.js
  function svgMapillaryMapFeatures(projection2, context, dispatch14) {
    const throttledRedraw = throttle_default(function() {
      dispatch14.call("change");
    }, 1e3);
    const minZoom4 = 12;
    let layer = select_default2(null);
    let _mapillary;
    function init2() {
      if (svgMapillaryMapFeatures.initialized)
        return;
      svgMapillaryMapFeatures.enabled = false;
      svgMapillaryMapFeatures.initialized = true;
    }
    function getService() {
      if (services.mapillary && !_mapillary) {
        _mapillary = services.mapillary;
        _mapillary.event.on("loadedMapFeatures", throttledRedraw);
      } else if (!services.mapillary && _mapillary) {
        _mapillary = null;
      }
      return _mapillary;
    }
    function showLayer() {
      const service = getService();
      if (!service)
        return;
      service.loadObjectResources(context);
      editOn();
    }
    function hideLayer() {
      throttledRedraw.cancel();
      editOff();
    }
    function editOn() {
      layer.style("display", "block");
    }
    function editOff() {
      layer.selectAll(".icon-map-feature").remove();
      layer.style("display", "none");
    }
    function click(d3_event, d2) {
      const service = getService();
      if (!service)
        return;
      context.map().centerEase(d2.loc);
      const selectedImageId = service.getActiveImage() && service.getActiveImage().id;
      service.getDetections(d2.id).then((detections) => {
        if (detections.length) {
          const imageId = detections[0].image.id;
          if (imageId === selectedImageId) {
            service.highlightDetection(detections[0]).selectImage(context, imageId);
          } else {
            service.ensureViewerLoaded(context).then(function() {
              service.highlightDetection(detections[0]).selectImage(context, imageId).showViewer(context);
            });
          }
        }
      });
    }
    function filterData(detectedFeatures) {
      const fromDate = context.photos().fromDate();
      const toDate = context.photos().toDate();
      if (fromDate) {
        detectedFeatures = detectedFeatures.filter(function(feature3) {
          return new Date(feature3.last_seen_at).getTime() >= new Date(fromDate).getTime();
        });
      }
      if (toDate) {
        detectedFeatures = detectedFeatures.filter(function(feature3) {
          return new Date(feature3.first_seen_at).getTime() <= new Date(toDate).getTime();
        });
      }
      return detectedFeatures;
    }
    function update() {
      const service = getService();
      let data = service ? service.mapFeatures(projection2) : [];
      data = filterData(data);
      const transform2 = svgPointTransform(projection2);
      const mapFeatures = layer.selectAll(".icon-map-feature").data(data, function(d2) {
        return d2.id;
      });
      mapFeatures.exit().remove();
      const enter = mapFeatures.enter().append("g").attr("class", "icon-map-feature icon-detected").on("click", click);
      enter.append("title").text(function(d2) {
        var id2 = d2.value.replace(/--/g, ".").replace(/-/g, "_");
        return _t("mapillary_map_features." + id2);
      });
      enter.append("use").attr("width", "24px").attr("height", "24px").attr("x", "-12px").attr("y", "-12px").attr("xlink:href", function(d2) {
        if (d2.value === "object--billboard") {
          return "#object--sign--advertisement";
        }
        return "#" + d2.value;
      });
      enter.append("rect").attr("width", "24px").attr("height", "24px").attr("x", "-12px").attr("y", "-12px");
      mapFeatures.merge(enter).attr("transform", transform2);
    }
    function drawMapFeatures(selection2) {
      const enabled = svgMapillaryMapFeatures.enabled;
      const service = getService();
      layer = selection2.selectAll(".layer-mapillary-map-features").data(service ? [0] : []);
      layer.exit().remove();
      layer = layer.enter().append("g").attr("class", "layer-mapillary-map-features layer-mapillary-detections").style("display", enabled ? "block" : "none").merge(layer);
      if (enabled) {
        if (service && ~~context.map().zoom() >= minZoom4) {
          editOn();
          update();
          service.loadMapFeatures(projection2);
          service.showFeatureDetections(true);
        } else {
          editOff();
        }
      } else if (service) {
        service.showFeatureDetections(false);
      }
    }
    drawMapFeatures.enabled = function(_2) {
      if (!arguments.length)
        return svgMapillaryMapFeatures.enabled;
      svgMapillaryMapFeatures.enabled = _2;
      if (svgMapillaryMapFeatures.enabled) {
        showLayer();
        context.photos().on("change.mapillary_map_features", update);
      } else {
        hideLayer();
        context.photos().on("change.mapillary_map_features", null);
      }
      dispatch14.call("change");
      return this;
    };
    drawMapFeatures.supported = function() {
      return !!getService();
    };
    drawMapFeatures.rendered = function(zoom) {
      return zoom >= minZoom4;
    };
    init2();
    return drawMapFeatures;
  }

  // modules/svg/kartaview_images.js
  function svgKartaviewImages(projection2, context, dispatch14) {
    var throttledRedraw = throttle_default(function() {
      dispatch14.call("change");
    }, 1e3);
    var minZoom4 = 12;
    var minMarkerZoom = 16;
    var minViewfieldZoom2 = 18;
    var layer = select_default2(null);
    var _kartaview;
    function init2() {
      if (svgKartaviewImages.initialized)
        return;
      svgKartaviewImages.enabled = false;
      svgKartaviewImages.initialized = true;
    }
    function getService() {
      if (services.kartaview && !_kartaview) {
        _kartaview = services.kartaview;
        _kartaview.event.on("loadedImages", throttledRedraw);
      } else if (!services.kartaview && _kartaview) {
        _kartaview = null;
      }
      return _kartaview;
    }
    function showLayer() {
      var service = getService();
      if (!service)
        return;
      editOn();
      layer.style("opacity", 0).transition().duration(250).style("opacity", 1).on("end", function() {
        dispatch14.call("change");
      });
    }
    function hideLayer() {
      throttledRedraw.cancel();
      layer.transition().duration(250).style("opacity", 0).on("end", editOff);
    }
    function editOn() {
      layer.style("display", "block");
    }
    function editOff() {
      layer.selectAll(".viewfield-group").remove();
      layer.style("display", "none");
    }
    function click(d3_event, d2) {
      var service = getService();
      if (!service)
        return;
      service.ensureViewerLoaded(context).then(function() {
        service.selectImage(context, d2.key).showViewer(context);
      });
      context.map().centerEase(d2.loc);
    }
    function mouseover(d3_event, d2) {
      var service = getService();
      if (service)
        service.setStyles(context, d2);
    }
    function mouseout() {
      var service = getService();
      if (service)
        service.setStyles(context, null);
    }
    function transform2(d2) {
      var t2 = svgPointTransform(projection2)(d2);
      if (d2.ca) {
        t2 += " rotate(" + Math.floor(d2.ca) + ",0,0)";
      }
      return t2;
    }
    function filterImages(images) {
      var fromDate = context.photos().fromDate();
      var toDate = context.photos().toDate();
      var usernames = context.photos().usernames();
      if (fromDate) {
        var fromTimestamp = new Date(fromDate).getTime();
        images = images.filter(function(item) {
          return new Date(item.captured_at).getTime() >= fromTimestamp;
        });
      }
      if (toDate) {
        var toTimestamp = new Date(toDate).getTime();
        images = images.filter(function(item) {
          return new Date(item.captured_at).getTime() <= toTimestamp;
        });
      }
      if (usernames) {
        images = images.filter(function(item) {
          return usernames.indexOf(item.captured_by) !== -1;
        });
      }
      return images;
    }
    function filterSequences(sequences) {
      var fromDate = context.photos().fromDate();
      var toDate = context.photos().toDate();
      var usernames = context.photos().usernames();
      if (fromDate) {
        var fromTimestamp = new Date(fromDate).getTime();
        sequences = sequences.filter(function(image) {
          return new Date(image.properties.captured_at).getTime() >= fromTimestamp;
        });
      }
      if (toDate) {
        var toTimestamp = new Date(toDate).getTime();
        sequences = sequences.filter(function(image) {
          return new Date(image.properties.captured_at).getTime() <= toTimestamp;
        });
      }
      if (usernames) {
        sequences = sequences.filter(function(image) {
          return usernames.indexOf(image.properties.captured_by) !== -1;
        });
      }
      return sequences;
    }
    function update() {
      var viewer = context.container().select(".photoviewer");
      var selected = viewer.empty() ? void 0 : viewer.datum();
      var z2 = ~~context.map().zoom();
      var showMarkers = z2 >= minMarkerZoom;
      var showViewfields = z2 >= minViewfieldZoom2;
      var service = getService();
      var sequences = [];
      var images = [];
      if (context.photos().showsFlat()) {
        sequences = service ? service.sequences(projection2) : [];
        images = service && showMarkers ? service.images(projection2) : [];
        sequences = filterSequences(sequences);
        images = filterImages(images);
      }
      var traces = layer.selectAll(".sequences").selectAll(".sequence").data(sequences, function(d2) {
        return d2.properties.key;
      });
      traces.exit().remove();
      traces = traces.enter().append("path").attr("class", "sequence").merge(traces).attr("d", svgPath(projection2).geojson);
      var groups = layer.selectAll(".markers").selectAll(".viewfield-group").data(images, function(d2) {
        return d2.key;
      });
      groups.exit().remove();
      var groupsEnter = groups.enter().append("g").attr("class", "viewfield-group").on("mouseenter", mouseover).on("mouseleave", mouseout).on("click", click);
      groupsEnter.append("g").attr("class", "viewfield-scale");
      var markers = groups.merge(groupsEnter).sort(function(a2, b2) {
        return a2 === selected ? 1 : b2 === selected ? -1 : b2.loc[1] - a2.loc[1];
      }).attr("transform", transform2).select(".viewfield-scale");
      markers.selectAll("circle").data([0]).enter().append("circle").attr("dx", "0").attr("dy", "0").attr("r", "6");
      var viewfields = markers.selectAll(".viewfield").data(showViewfields ? [0] : []);
      viewfields.exit().remove();
      viewfields.enter().insert("path", "circle").attr("class", "viewfield").attr("transform", "scale(1.5,1.5),translate(-8, -13)").attr("d", "M 6,9 C 8,8.4 8,8.4 10,9 L 16,-2 C 12,-5 4,-5 0,-2 z");
    }
    function drawImages(selection2) {
      var enabled = svgKartaviewImages.enabled, service = getService();
      layer = selection2.selectAll(".layer-kartaview").data(service ? [0] : []);
      layer.exit().remove();
      var layerEnter = layer.enter().append("g").attr("class", "layer-kartaview").style("display", enabled ? "block" : "none");
      layerEnter.append("g").attr("class", "sequences");
      layerEnter.append("g").attr("class", "markers");
      layer = layerEnter.merge(layer);
      if (enabled) {
        if (service && ~~context.map().zoom() >= minZoom4) {
          editOn();
          update();
          service.loadImages(projection2);
        } else {
          editOff();
        }
      }
    }
    drawImages.enabled = function(_2) {
      if (!arguments.length)
        return svgKartaviewImages.enabled;
      svgKartaviewImages.enabled = _2;
      if (svgKartaviewImages.enabled) {
        showLayer();
        context.photos().on("change.kartaview_images", update);
      } else {
        hideLayer();
        context.photos().on("change.kartaview_images", null);
      }
      dispatch14.call("change");
      return this;
    };
    drawImages.supported = function() {
      return !!getService();
    };
    drawImages.rendered = function(zoom) {
      return zoom >= minZoom4;
    };
    init2();
    return drawImages;
  }

  // modules/svg/mapilio_images.js
  function svgMapilioImages(projection2, context, dispatch14) {
    const throttledRedraw = throttle_default(function() {
      dispatch14.call("change");
    }, 1e3);
    const minZoom4 = 12;
    let layer = select_default2(null);
    let _mapilio;
    const viewFieldZoomLevel = 18;
    function init2() {
      if (svgMapilioImages.initialized)
        return;
      svgMapilioImages.enabled = false;
      svgMapilioImages.initialized = true;
    }
    function getService() {
      if (services.mapilio && !_mapilio) {
        _mapilio = services.mapilio;
        _mapilio.event.on("loadedImages", throttledRedraw);
      } else if (!services.mapilio && _mapilio) {
        _mapilio = null;
      }
      return _mapilio;
    }
    function showLayer() {
      const service = getService();
      if (!service)
        return;
      editOn();
      layer.style("opacity", 0).transition().duration(250).style("opacity", 1).on("end", function() {
        dispatch14.call("change");
      });
    }
    function hideLayer() {
      throttledRedraw.cancel();
      layer.transition().duration(250).style("opacity", 0).on("end", editOff);
    }
    function transform2(d2) {
      let t2 = svgPointTransform(projection2)(d2);
      if (d2.heading) {
        t2 += " rotate(" + Math.floor(d2.heading) + ",0,0)";
      }
      return t2;
    }
    function editOn() {
      layer.style("display", "block");
    }
    function editOff() {
      layer.selectAll(".viewfield-group").remove();
      layer.style("display", "none");
    }
    function click(d3_event, image) {
      const service = getService();
      if (!service)
        return;
      service.ensureViewerLoaded(context, image.id).then(function() {
        service.selectImage(context, image.id).showViewer(context);
      });
      context.map().centerEase(image.loc);
    }
    function mouseover(d3_event, image) {
      const service = getService();
      if (service)
        service.setStyles(context, image);
    }
    function mouseout() {
      const service = getService();
      if (service)
        service.setStyles(context, null);
    }
    function update() {
      const z2 = ~~context.map().zoom();
      const showViewfields = z2 >= viewFieldZoomLevel;
      const service = getService();
      let sequences = service ? service.sequences(projection2) : [];
      let images = service ? service.images(projection2) : [];
      let traces = layer.selectAll(".sequences").selectAll(".sequence").data(sequences, function(d2) {
        return d2.properties.id;
      });
      traces.exit().remove();
      traces.enter().append("path").attr("class", "sequence").merge(traces).attr("d", svgPath(projection2).geojson);
      const groups = layer.selectAll(".markers").selectAll(".viewfield-group").data(images, function(d2) {
        return d2.id;
      });
      groups.exit().remove();
      const groupsEnter = groups.enter().append("g").attr("class", "viewfield-group").on("mouseenter", mouseover).on("mouseleave", mouseout).on("click", click);
      groupsEnter.append("g").attr("class", "viewfield-scale");
      const markers = groups.merge(groupsEnter).sort(function(a2, b2) {
        return b2.loc[1] - a2.loc[1];
      }).attr("transform", transform2).select(".viewfield-scale");
      markers.selectAll("circle").data([0]).enter().append("circle").attr("dx", "0").attr("dy", "0").attr("r", "6");
      const viewfields = markers.selectAll(".viewfield").data(showViewfields ? [0] : []);
      viewfields.exit().remove();
      viewfields.enter().insert("path", "circle").attr("class", "viewfield").attr("transform", "scale(1.5,1.5),translate(-8, -13)").attr("d", viewfieldPath);
      function viewfieldPath() {
        if (this.parentNode.__data__.isPano) {
          return "M 8,13 m -10,0 a 10,10 0 1,0 20,0 a 10,10 0 1,0 -20,0";
        } else {
          return "M 6,9 C 8,8.4 8,8.4 10,9 L 16,-2 C 12,-5 4,-5 0,-2 z";
        }
      }
    }
    function drawImages(selection2) {
      const enabled = svgMapilioImages.enabled;
      const service = getService();
      layer = selection2.selectAll(".layer-mapilio").data(service ? [0] : []);
      layer.exit().remove();
      const layerEnter = layer.enter().append("g").attr("class", "layer-mapilio").style("display", enabled ? "block" : "none");
      layerEnter.append("g").attr("class", "sequences");
      layerEnter.append("g").attr("class", "markers");
      layer = layerEnter.merge(layer);
      if (enabled) {
        if (service && ~~context.map().zoom() >= minZoom4) {
          editOn();
          update();
          service.loadImages(projection2);
          service.loadLines(projection2);
        } else {
          editOff();
        }
      }
    }
    drawImages.enabled = function(_2) {
      if (!arguments.length)
        return svgMapilioImages.enabled;
      svgMapilioImages.enabled = _2;
      if (svgMapilioImages.enabled) {
        showLayer();
        context.photos().on("change.mapilio_images", null);
      } else {
        hideLayer();
        context.photos().on("change.mapilio_images", null);
      }
      dispatch14.call("change");
      return this;
    };
    drawImages.supported = function() {
      return !!getService();
    };
    drawImages.rendered = function(zoom) {
      return zoom >= minZoom4;
    };
    init2();
    return drawImages;
  }

  // modules/svg/osm.js
  function svgOsm(projection2, context, dispatch14) {
    var enabled = true;
    function drawOsm(selection2) {
      selection2.selectAll(".layer-osm").data(["covered", "areas", "lines", "points", "labels"]).enter().append("g").attr("class", function(d2) {
        return "layer-osm " + d2;
      });
      selection2.selectAll(".layer-osm.points").selectAll(".points-group").data(["points", "midpoints", "vertices", "turns"]).enter().append("g").attr("class", function(d2) {
        return "points-group " + d2;
      });
    }
    function showLayer() {
      var layer = context.surface().selectAll(".data-layer.osm");
      layer.interrupt();
      layer.classed("disabled", false).style("opacity", 0).transition().duration(250).style("opacity", 1).on("end interrupt", function() {
        dispatch14.call("change");
      });
    }
    function hideLayer() {
      var layer = context.surface().selectAll(".data-layer.osm");
      layer.interrupt();
      layer.transition().duration(250).style("opacity", 0).on("end interrupt", function() {
        layer.classed("disabled", true);
        dispatch14.call("change");
      });
    }
    drawOsm.enabled = function(val) {
      if (!arguments.length)
        return enabled;
      enabled = val;
      if (enabled) {
        showLayer();
      } else {
        hideLayer();
      }
      dispatch14.call("change");
      return this;
    };
    return drawOsm;
  }

  // modules/svg/notes.js
  var _notesEnabled = false;
  var _osmService;
  function svgNotes(projection2, context, dispatch14) {
    if (!dispatch14) {
      dispatch14 = dispatch_default("change");
    }
    var throttledRedraw = throttle_default(function() {
      dispatch14.call("change");
    }, 1e3);
    var minZoom4 = 12;
    var touchLayer = select_default2(null);
    var drawLayer = select_default2(null);
    var _notesVisible = false;
    function markerPath(selection2, klass) {
      selection2.attr("class", klass).attr("transform", "translate(-8, -22)").attr("d", "m17.5,0l-15,0c-1.37,0 -2.5,1.12 -2.5,2.5l0,11.25c0,1.37 1.12,2.5 2.5,2.5l3.75,0l0,3.28c0,0.38 0.43,0.6 0.75,0.37l4.87,-3.65l5.62,0c1.37,0 2.5,-1.12 2.5,-2.5l0,-11.25c0,-1.37 -1.12,-2.5 -2.5,-2.5z");
    }
    function getService() {
      if (services.osm && !_osmService) {
        _osmService = services.osm;
        _osmService.on("loadedNotes", throttledRedraw);
      } else if (!services.osm && _osmService) {
        _osmService = null;
      }
      return _osmService;
    }
    function editOn() {
      if (!_notesVisible) {
        _notesVisible = true;
        drawLayer.style("display", "block");
      }
    }
    function editOff() {
      if (_notesVisible) {
        _notesVisible = false;
        drawLayer.style("display", "none");
        drawLayer.selectAll(".note").remove();
        touchLayer.selectAll(".note").remove();
      }
    }
    function layerOn() {
      editOn();
      drawLayer.style("opacity", 0).transition().duration(250).style("opacity", 1).on("end interrupt", function() {
        dispatch14.call("change");
      });
    }
    function layerOff() {
      throttledRedraw.cancel();
      drawLayer.interrupt();
      touchLayer.selectAll(".note").remove();
      drawLayer.transition().duration(250).style("opacity", 0).on("end interrupt", function() {
        editOff();
        dispatch14.call("change");
      });
    }
    function updateMarkers() {
      if (!_notesVisible || !_notesEnabled)
        return;
      var service = getService();
      var selectedID = context.selectedNoteID();
      var data = service ? service.notes(projection2) : [];
      var getTransform = svgPointTransform(projection2);
      var notes = drawLayer.selectAll(".note").data(data, function(d2) {
        return d2.status + d2.id;
      });
      notes.exit().remove();
      var notesEnter = notes.enter().append("g").attr("class", function(d2) {
        return "note note-" + d2.id + " " + d2.status;
      }).classed("new", function(d2) {
        return d2.id < 0;
      });
      notesEnter.append("ellipse").attr("cx", 0.5).attr("cy", 1).attr("rx", 6.5).attr("ry", 3).attr("class", "stroke");
      notesEnter.append("path").call(markerPath, "shadow");
      notesEnter.append("use").attr("class", "note-fill").attr("width", "20px").attr("height", "20px").attr("x", "-8px").attr("y", "-22px").attr("xlink:href", "#iD-icon-note");
      notesEnter.selectAll(".icon-annotation").data(function(d2) {
        return [d2];
      }).enter().append("use").attr("class", "icon-annotation").attr("width", "10px").attr("height", "10px").attr("x", "-3px").attr("y", "-19px").attr("xlink:href", function(d2) {
        if (d2.id < 0)
          return "#iD-icon-plus";
        if (d2.status === "open")
          return "#iD-icon-close";
        return "#iD-icon-apply";
      });
      notes.merge(notesEnter).sort(sortY).classed("selected", function(d2) {
        var mode = context.mode();
        var isMoving = mode && mode.id === "drag-note";
        return !isMoving && d2.id === selectedID;
      }).attr("transform", getTransform);
      if (touchLayer.empty())
        return;
      var fillClass = context.getDebug("target") ? "pink " : "nocolor ";
      var targets = touchLayer.selectAll(".note").data(data, function(d2) {
        return d2.id;
      });
      targets.exit().remove();
      targets.enter().append("rect").attr("width", "20px").attr("height", "20px").attr("x", "-8px").attr("y", "-22px").merge(targets).sort(sortY).attr("class", function(d2) {
        var newClass = d2.id < 0 ? "new" : "";
        return "note target note-" + d2.id + " " + fillClass + newClass;
      }).attr("transform", getTransform);
      function sortY(a2, b2) {
        if (a2.id === selectedID)
          return 1;
        if (b2.id === selectedID)
          return -1;
        return b2.loc[1] - a2.loc[1];
      }
    }
    function drawNotes(selection2) {
      var service = getService();
      var surface = context.surface();
      if (surface && !surface.empty()) {
        touchLayer = surface.selectAll(".data-layer.touch .layer-touch.markers");
      }
      drawLayer = selection2.selectAll(".layer-notes").data(service ? [0] : []);
      drawLayer.exit().remove();
      drawLayer = drawLayer.enter().append("g").attr("class", "layer-notes").style("display", _notesEnabled ? "block" : "none").merge(drawLayer);
      if (_notesEnabled) {
        if (service && ~~context.map().zoom() >= minZoom4) {
          editOn();
          service.loadNotes(projection2);
          updateMarkers();
        } else {
          editOff();
        }
      }
    }
    drawNotes.enabled = function(val) {
      if (!arguments.length)
        return _notesEnabled;
      _notesEnabled = val;
      if (_notesEnabled) {
        layerOn();
      } else {
        layerOff();
        if (context.selectedNoteID()) {
          context.enter(modeBrowse(context));
        }
      }
      dispatch14.call("change");
      return this;
    };
    return drawNotes;
  }

  // modules/svg/touch.js
  function svgTouch() {
    function drawTouch(selection2) {
      selection2.selectAll(".layer-touch").data(["areas", "lines", "points", "turns", "markers"]).enter().append("g").attr("class", function(d2) {
        return "layer-touch " + d2;
      });
    }
    return drawTouch;
  }

  // modules/util/dimensions.js
  function refresh(selection2, node) {
    var cr = node.getBoundingClientRect();
    var prop = [cr.width, cr.height];
    selection2.property("__dimensions__", prop);
    return prop;
  }
  function utilGetDimensions(selection2, force) {
    if (!selection2 || selection2.empty()) {
      return [0, 0];
    }
    var node = selection2.node(), cached = selection2.property("__dimensions__");
    return !cached || force ? refresh(selection2, node) : cached;
  }
  function utilSetDimensions(selection2, dimensions) {
    if (!selection2 || selection2.empty()) {
      return selection2;
    }
    var node = selection2.node();
    if (dimensions === null) {
      refresh(selection2, node);
      return selection2;
    }
    return selection2.property("__dimensions__", [dimensions[0], dimensions[1]]).attr("width", dimensions[0]).attr("height", dimensions[1]);
  }

  // modules/svg/layers.js
  function svgLayers(projection2, context) {
    var dispatch14 = dispatch_default("change");
    var svg2 = select_default2(null);
    var _layers = [
      { id: "osm", layer: svgOsm(projection2, context, dispatch14) },
      { id: "notes", layer: svgNotes(projection2, context, dispatch14) },
      { id: "data", layer: svgData(projection2, context, dispatch14) },
      { id: "keepRight", layer: svgKeepRight(projection2, context, dispatch14) },
      { id: "improveOSM", layer: svgImproveOSM(projection2, context, dispatch14) },
      { id: "osmose", layer: svgOsmose(projection2, context, dispatch14) },
      { id: "streetside", layer: svgStreetside(projection2, context, dispatch14) },
      { id: "mapillary", layer: svgMapillaryImages(projection2, context, dispatch14) },
      { id: "mapillary-position", layer: svgMapillaryPosition(projection2, context, dispatch14) },
      { id: "mapillary-map-features", layer: svgMapillaryMapFeatures(projection2, context, dispatch14) },
      { id: "mapillary-signs", layer: svgMapillarySigns(projection2, context, dispatch14) },
      { id: "kartaview", layer: svgKartaviewImages(projection2, context, dispatch14) },
      { id: "mapilio", layer: svgMapilioImages(projection2, context, dispatch14) },
      { id: "vegbilder", layer: svgVegbilder(projection2, context, dispatch14) },
      { id: "local-photos", layer: svgLocalPhotos(projection2, context, dispatch14) },
      { id: "debug", layer: svgDebug(projection2, context, dispatch14) },
      { id: "geolocate", layer: svgGeolocate(projection2, context, dispatch14) },
      { id: "touch", layer: svgTouch(projection2, context, dispatch14) }
    ];
    function drawLayers(selection2) {
      svg2 = selection2.selectAll(".surface").data([0]);
      svg2 = svg2.enter().append("svg").attr("class", "surface").merge(svg2);
      var defs = svg2.selectAll(".surface-defs").data([0]);
      defs.enter().append("defs").attr("class", "surface-defs");
      var groups = svg2.selectAll(".data-layer").data(_layers);
      groups.exit().remove();
      groups.enter().append("g").attr("class", function(d2) {
        return "data-layer " + d2.id;
      }).merge(groups).each(function(d2) {
        select_default2(this).call(d2.layer);
      });
    }
    drawLayers.all = function() {
      return _layers;
    };
    drawLayers.layer = function(id2) {
      var obj = _layers.find(function(o2) {
        return o2.id === id2;
      });
      return obj && obj.layer;
    };
    drawLayers.only = function(what) {
      var arr = [].concat(what);
      var all = _layers.map(function(layer) {
        return layer.id;
      });
      return drawLayers.remove(utilArrayDifference(all, arr));
    };
    drawLayers.remove = function(what) {
      var arr = [].concat(what);
      arr.forEach(function(id2) {
        _layers = _layers.filter(function(o2) {
          return o2.id !== id2;
        });
      });
      dispatch14.call("change");
      return this;
    };
    drawLayers.add = function(what) {
      var arr = [].concat(what);
      arr.forEach(function(obj) {
        if ("id" in obj && "layer" in obj) {
          _layers.push(obj);
        }
      });
      dispatch14.call("change");
      return this;
    };
    drawLayers.dimensions = function(val) {
      if (!arguments.length)
        return utilGetDimensions(svg2);
      utilSetDimensions(svg2, val);
      return this;
    };
    return utilRebind(drawLayers, dispatch14, "on");
  }

  // modules/svg/lines.js
  var import_fast_deep_equal6 = __toESM(require_fast_deep_equal());
  function svgLines(projection2, context) {
    var detected = utilDetect();
    var highway_stack = {
      motorway: 0,
      motorway_link: 1,
      trunk: 2,
      trunk_link: 3,
      primary: 4,
      primary_link: 5,
      secondary: 6,
      tertiary: 7,
      unclassified: 8,
      residential: 9,
      service: 10,
      busway: 11,
      footway: 12
    };
    function drawTargets(selection2, graph, entities, filter2) {
      var targetClass = context.getDebug("target") ? "pink " : "nocolor ";
      var nopeClass = context.getDebug("target") ? "red " : "nocolor ";
      var getPath = svgPath(projection2).geojson;
      var activeID = context.activeID();
      var base = context.history().base();
      var data = { targets: [], nopes: [] };
      entities.forEach(function(way) {
        var features = svgSegmentWay(way, graph, activeID);
        data.targets.push.apply(data.targets, features.passive);
        data.nopes.push.apply(data.nopes, features.active);
      });
      var targetData = data.targets.filter(getPath);
      var targets = selection2.selectAll(".line.target-allowed").filter(function(d2) {
        return filter2(d2.properties.entity);
      }).data(targetData, function key(d2) {
        return d2.id;
      });
      targets.exit().remove();
      var segmentWasEdited = function(d2) {
        var wayID = d2.properties.entity.id;
        if (!base.entities[wayID] || !(0, import_fast_deep_equal6.default)(graph.entities[wayID].nodes, base.entities[wayID].nodes)) {
          return false;
        }
        return d2.properties.nodes.some(function(n3) {
          return !base.entities[n3.id] || !(0, import_fast_deep_equal6.default)(graph.entities[n3.id].loc, base.entities[n3.id].loc);
        });
      };
      targets.enter().append("path").merge(targets).attr("d", getPath).attr("class", function(d2) {
        return "way line target target-allowed " + targetClass + d2.id;
      }).classed("segment-edited", segmentWasEdited);
      var nopeData = data.nopes.filter(getPath);
      var nopes = selection2.selectAll(".line.target-nope").filter(function(d2) {
        return filter2(d2.properties.entity);
      }).data(nopeData, function key(d2) {
        return d2.id;
      });
      nopes.exit().remove();
      nopes.enter().append("path").merge(nopes).attr("d", getPath).attr("class", function(d2) {
        return "way line target target-nope " + nopeClass + d2.id;
      }).classed("segment-edited", segmentWasEdited);
    }
    function drawLines(selection2, graph, entities, filter2) {
      var base = context.history().base();
      function waystack(a2, b2) {
        var selected = context.selectedIDs();
        var scoreA = selected.indexOf(a2.id) !== -1 ? 20 : 0;
        var scoreB = selected.indexOf(b2.id) !== -1 ? 20 : 0;
        if (a2.tags.highway) {
          scoreA -= highway_stack[a2.tags.highway];
        }
        if (b2.tags.highway) {
          scoreB -= highway_stack[b2.tags.highway];
        }
        return scoreA - scoreB;
      }
      function drawLineGroup(selection3, klass, isSelected) {
        var mode = context.mode();
        var isDrawing = mode && /^draw/.test(mode.id);
        var selectedClass = !isDrawing && isSelected ? "selected " : "";
        var lines = selection3.selectAll("path").filter(filter2).data(getPathData(isSelected), osmEntity.key);
        lines.exit().remove();
        lines.enter().append("path").attr("class", function(d2) {
          var prefix = "way line";
          if (!d2.hasInterestingTags()) {
            var parentRelations = graph.parentRelations(d2);
            var parentMultipolygons = parentRelations.filter(function(relation) {
              return relation.isMultipolygon();
            });
            if (parentMultipolygons.length > 0 && // and only multipolygon relations
            parentRelations.length === parentMultipolygons.length) {
              prefix = "relation area";
            }
          }
          var oldMPClass = oldMultiPolygonOuters[d2.id] ? "old-multipolygon " : "";
          return prefix + " " + klass + " " + selectedClass + oldMPClass + d2.id;
        }).classed("added", function(d2) {
          return !base.entities[d2.id];
        }).classed("geometry-edited", function(d2) {
          return graph.entities[d2.id] && base.entities[d2.id] && !(0, import_fast_deep_equal6.default)(graph.entities[d2.id].nodes, base.entities[d2.id].nodes);
        }).classed("retagged", function(d2) {
          return graph.entities[d2.id] && base.entities[d2.id] && !(0, import_fast_deep_equal6.default)(graph.entities[d2.id].tags, base.entities[d2.id].tags);
        }).call(svgTagClasses()).merge(lines).sort(waystack).attr("d", getPath).call(svgTagClasses().tags(svgRelationMemberTags(graph)));
        return selection3;
      }
      function getPathData(isSelected) {
        return function() {
          var layer = this.parentNode.__data__;
          var data = pathdata[layer] || [];
          return data.filter(function(d2) {
            if (isSelected) {
              return context.selectedIDs().indexOf(d2.id) !== -1;
            } else {
              return context.selectedIDs().indexOf(d2.id) === -1;
            }
          });
        };
      }
      function addMarkers(layergroup, pathclass, groupclass, groupdata, marker) {
        var markergroup = layergroup.selectAll("g." + groupclass).data([pathclass]);
        markergroup = markergroup.enter().append("g").attr("class", groupclass).merge(markergroup);
        var markers = markergroup.selectAll("path").filter(filter2).data(
          function data() {
            return groupdata[this.parentNode.__data__] || [];
          },
          function key(d2) {
            return [d2.id, d2.index];
          }
        );
        markers.exit().remove();
        markers = markers.enter().append("path").attr("class", pathclass).merge(markers).attr("marker-mid", marker).attr("d", function(d2) {
          return d2.d;
        });
        if (detected.ie) {
          markers.each(function() {
            this.parentNode.insertBefore(this, this);
          });
        }
      }
      var getPath = svgPath(projection2, graph);
      var ways = [];
      var onewaydata = {};
      var sideddata = {};
      var oldMultiPolygonOuters = {};
      for (var i3 = 0; i3 < entities.length; i3++) {
        var entity = entities[i3];
        if (entity.geometry(graph) === "line" || entity.geometry(graph) === "area" && entity.sidednessIdentifier && entity.sidednessIdentifier() === "coastline") {
          ways.push(entity);
        }
      }
      ways = ways.filter(getPath);
      var pathdata = utilArrayGroupBy(ways, function(way) {
        return way.layer();
      });
      Object.keys(pathdata).forEach(function(k2) {
        var v2 = pathdata[k2];
        var onewayArr = v2.filter(function(d2) {
          return d2.isOneWay();
        });
        var onewaySegments = svgMarkerSegments(
          projection2,
          graph,
          35,
          function shouldReverse(entity2) {
            return entity2.tags.oneway === "-1";
          },
          function bothDirections(entity2) {
            return entity2.tags.oneway === "reversible" || entity2.tags.oneway === "alternating";
          }
        );
        onewaydata[k2] = utilArrayFlatten(onewayArr.map(onewaySegments));
        var sidedArr = v2.filter(function(d2) {
          return d2.isSided();
        });
        var sidedSegments = svgMarkerSegments(
          projection2,
          graph,
          30,
          function shouldReverse() {
            return false;
          },
          function bothDirections() {
            return false;
          }
        );
        sideddata[k2] = utilArrayFlatten(sidedArr.map(sidedSegments));
      });
      var covered = selection2.selectAll(".layer-osm.covered");
      var uncovered = selection2.selectAll(".layer-osm.lines");
      var touchLayer = selection2.selectAll(".layer-touch.lines");
      [covered, uncovered].forEach(function(selection3) {
        var range3 = selection3 === covered ? range(-10, 0) : range(0, 11);
        var layergroup = selection3.selectAll("g.layergroup").data(range3);
        layergroup = layergroup.enter().append("g").attr("class", function(d2) {
          return "layergroup layer" + String(d2);
        }).merge(layergroup);
        layergroup.selectAll("g.linegroup").data(["shadow", "casing", "stroke", "shadow-highlighted", "casing-highlighted", "stroke-highlighted"]).enter().append("g").attr("class", function(d2) {
          return "linegroup line-" + d2;
        });
        layergroup.selectAll("g.line-shadow").call(drawLineGroup, "shadow", false);
        layergroup.selectAll("g.line-casing").call(drawLineGroup, "casing", false);
        layergroup.selectAll("g.line-stroke").call(drawLineGroup, "stroke", false);
        layergroup.selectAll("g.line-shadow-highlighted").call(drawLineGroup, "shadow", true);
        layergroup.selectAll("g.line-casing-highlighted").call(drawLineGroup, "casing", true);
        layergroup.selectAll("g.line-stroke-highlighted").call(drawLineGroup, "stroke", true);
        addMarkers(layergroup, "oneway", "onewaygroup", onewaydata, "url(#ideditor-oneway-marker)");
        addMarkers(
          layergroup,
          "sided",
          "sidedgroup",
          sideddata,
          function marker(d2) {
            var category = graph.entity(d2.id).sidednessIdentifier();
            return "url(#ideditor-sided-marker-" + category + ")";
          }
        );
      });
      touchLayer.call(drawTargets, graph, ways, filter2);
    }
    return drawLines;
  }

  // modules/svg/midpoints.js
  function svgMidpoints(projection2, context) {
    var targetRadius = 8;
    function drawTargets(selection2, graph, entities, filter2) {
      var fillClass = context.getDebug("target") ? "pink " : "nocolor ";
      var getTransform = svgPointTransform(projection2).geojson;
      var data = entities.map(function(midpoint) {
        return {
          type: "Feature",
          id: midpoint.id,
          properties: {
            target: true,
            entity: midpoint
          },
          geometry: {
            type: "Point",
            coordinates: midpoint.loc
          }
        };
      });
      var targets = selection2.selectAll(".midpoint.target").filter(function(d2) {
        return filter2(d2.properties.entity);
      }).data(data, function key(d2) {
        return d2.id;
      });
      targets.exit().remove();
      targets.enter().append("circle").attr("r", targetRadius).merge(targets).attr("class", function(d2) {
        return "node midpoint target " + fillClass + d2.id;
      }).attr("transform", getTransform);
    }
    function drawMidpoints(selection2, graph, entities, filter2, extent) {
      var drawLayer = selection2.selectAll(".layer-osm.points .points-group.midpoints");
      var touchLayer = selection2.selectAll(".layer-touch.points");
      var mode = context.mode();
      if (mode && mode.id !== "select" || !context.map().withinEditableZoom()) {
        drawLayer.selectAll(".midpoint").remove();
        touchLayer.selectAll(".midpoint.target").remove();
        return;
      }
      var poly = extent.polygon();
      var midpoints = {};
      for (var i3 = 0; i3 < entities.length; i3++) {
        var entity = entities[i3];
        if (entity.type !== "way")
          continue;
        if (!filter2(entity))
          continue;
        if (context.selectedIDs().indexOf(entity.id) < 0)
          continue;
        var nodes = graph.childNodes(entity);
        for (var j2 = 0; j2 < nodes.length - 1; j2++) {
          var a2 = nodes[j2];
          var b2 = nodes[j2 + 1];
          var id2 = [a2.id, b2.id].sort().join("-");
          if (midpoints[id2]) {
            midpoints[id2].parents.push(entity);
          } else if (geoVecLength(projection2(a2.loc), projection2(b2.loc)) > 40) {
            var point2 = geoVecInterp(a2.loc, b2.loc, 0.5);
            var loc = null;
            if (extent.intersects(point2)) {
              loc = point2;
            } else {
              for (var k2 = 0; k2 < 4; k2++) {
                point2 = geoLineIntersection([a2.loc, b2.loc], [poly[k2], poly[k2 + 1]]);
                if (point2 && geoVecLength(projection2(a2.loc), projection2(point2)) > 20 && geoVecLength(projection2(b2.loc), projection2(point2)) > 20) {
                  loc = point2;
                  break;
                }
              }
            }
            if (loc) {
              midpoints[id2] = {
                type: "midpoint",
                id: id2,
                loc,
                edge: [a2.id, b2.id],
                parents: [entity]
              };
            }
          }
        }
      }
      function midpointFilter(d2) {
        if (midpoints[d2.id])
          return true;
        for (var i4 = 0; i4 < d2.parents.length; i4++) {
          if (filter2(d2.parents[i4])) {
            return true;
          }
        }
        return false;
      }
      var groups = drawLayer.selectAll(".midpoint").filter(midpointFilter).data(Object.values(midpoints), function(d2) {
        return d2.id;
      });
      groups.exit().remove();
      var enter = groups.enter().insert("g", ":first-child").attr("class", "midpoint");
      enter.append("polygon").attr("points", "-6,8 10,0 -6,-8").attr("class", "shadow");
      enter.append("polygon").attr("points", "-3,4 5,0 -3,-4").attr("class", "fill");
      groups = groups.merge(enter).attr("transform", function(d2) {
        var translate = svgPointTransform(projection2);
        var a3 = graph.entity(d2.edge[0]);
        var b3 = graph.entity(d2.edge[1]);
        var angle2 = geoAngle(a3, b3, projection2) * (180 / Math.PI);
        return translate(d2) + " rotate(" + angle2 + ")";
      }).call(svgTagClasses().tags(
        function(d2) {
          return d2.parents[0].tags;
        }
      ));
      groups.select("polygon.shadow");
      groups.select("polygon.fill");
      touchLayer.call(drawTargets, graph, Object.values(midpoints), midpointFilter);
    }
    return drawMidpoints;
  }

  // modules/svg/points.js
  var import_fast_deep_equal7 = __toESM(require_fast_deep_equal());
  function svgPoints(projection2, context) {
    function markerPath(selection2, klass) {
      selection2.attr("class", klass).attr("transform", "translate(-8, -23)").attr("d", "M 17,8 C 17,13 11,21 8.5,23.5 C 6,21 0,13 0,8 C 0,4 4,-0.5 8.5,-0.5 C 13,-0.5 17,4 17,8 z");
    }
    function sortY(a2, b2) {
      return b2.loc[1] - a2.loc[1];
    }
    function fastEntityKey(d2) {
      var mode = context.mode();
      var isMoving = mode && /^(add|draw|drag|move|rotate)/.test(mode.id);
      return isMoving ? d2.id : osmEntity.key(d2);
    }
    function drawTargets(selection2, graph, entities, filter2) {
      var fillClass = context.getDebug("target") ? "pink " : "nocolor ";
      var getTransform = svgPointTransform(projection2).geojson;
      var activeID = context.activeID();
      var data = [];
      entities.forEach(function(node) {
        if (activeID === node.id)
          return;
        data.push({
          type: "Feature",
          id: node.id,
          properties: {
            target: true,
            entity: node
          },
          geometry: node.asGeoJSON()
        });
      });
      var targets = selection2.selectAll(".point.target").filter(function(d2) {
        return filter2(d2.properties.entity);
      }).data(data, function key(d2) {
        return d2.id;
      });
      targets.exit().remove();
      targets.enter().append("rect").attr("x", -10).attr("y", -26).attr("width", 20).attr("height", 30).merge(targets).attr("class", function(d2) {
        return "node point target " + fillClass + d2.id;
      }).attr("transform", getTransform);
    }
    function drawPoints(selection2, graph, entities, filter2) {
      var wireframe = context.surface().classed("fill-wireframe");
      var zoom = geoScaleToZoom(projection2.scale());
      var base = context.history().base();
      function renderAsPoint(entity) {
        return entity.geometry(graph) === "point" && !(zoom >= 18 && entity.directions(graph, projection2).length);
      }
      var points = wireframe ? [] : entities.filter(renderAsPoint);
      points.sort(sortY);
      var drawLayer = selection2.selectAll(".layer-osm.points .points-group.points");
      var touchLayer = selection2.selectAll(".layer-touch.points");
      var groups = drawLayer.selectAll("g.point").filter(filter2).data(points, fastEntityKey);
      groups.exit().remove();
      var enter = groups.enter().append("g").attr("class", function(d2) {
        return "node point " + d2.id;
      }).order();
      enter.append("path").call(markerPath, "shadow");
      enter.append("ellipse").attr("cx", 0.5).attr("cy", 1).attr("rx", 6.5).attr("ry", 3).attr("class", "stroke");
      enter.append("path").call(markerPath, "stroke");
      enter.append("use").attr("transform", "translate(-5.5, -20)").attr("class", "icon").attr("width", "12px").attr("height", "12px");
      groups = groups.merge(enter).attr("transform", svgPointTransform(projection2)).classed("added", function(d2) {
        return !base.entities[d2.id];
      }).classed("moved", function(d2) {
        return base.entities[d2.id] && !(0, import_fast_deep_equal7.default)(graph.entities[d2.id].loc, base.entities[d2.id].loc);
      }).classed("retagged", function(d2) {
        return base.entities[d2.id] && !(0, import_fast_deep_equal7.default)(graph.entities[d2.id].tags, base.entities[d2.id].tags);
      }).call(svgTagClasses());
      groups.select(".shadow");
      groups.select(".stroke");
      groups.select(".icon").attr("xlink:href", function(entity) {
        var preset = _mainPresetIndex.match(entity, graph);
        var picon = preset && preset.icon;
        return picon ? "#" + picon : "";
      });
      touchLayer.call(drawTargets, graph, points, filter2);
    }
    return drawPoints;
  }

  // modules/svg/turns.js
  function svgTurns(projection2, context) {
    function icon2(turn) {
      var u2 = turn.u ? "-u" : "";
      if (turn.no)
        return "#iD-turn-no" + u2;
      if (turn.only)
        return "#iD-turn-only" + u2;
      return "#iD-turn-yes" + u2;
    }
    function drawTurns(selection2, graph, turns) {
      function turnTransform(d2) {
        var pxRadius = 50;
        var toWay = graph.entity(d2.to.way);
        var toPoints = graph.childNodes(toWay).map(function(n3) {
          return n3.loc;
        }).map(projection2);
        var toLength = geoPathLength(toPoints);
        var mid = toLength / 2;
        var toNode = graph.entity(d2.to.node);
        var toVertex = graph.entity(d2.to.vertex);
        var a2 = geoAngle(toVertex, toNode, projection2);
        var o2 = projection2(toVertex.loc);
        var r2 = d2.u ? 0 : !toWay.__via ? pxRadius : Math.min(mid, pxRadius);
        return "translate(" + (r2 * Math.cos(a2) + o2[0]) + "," + (r2 * Math.sin(a2) + o2[1]) + ") rotate(" + a2 * 180 / Math.PI + ")";
      }
      var drawLayer = selection2.selectAll(".layer-osm.points .points-group.turns");
      var touchLayer = selection2.selectAll(".layer-touch.turns");
      var groups = drawLayer.selectAll("g.turn").data(turns, function(d2) {
        return d2.key;
      });
      groups.exit().remove();
      var groupsEnter = groups.enter().append("g").attr("class", function(d2) {
        return "turn " + d2.key;
      });
      var turnsEnter = groupsEnter.filter(function(d2) {
        return !d2.u;
      });
      turnsEnter.append("rect").attr("transform", "translate(-22, -12)").attr("width", "44").attr("height", "24");
      turnsEnter.append("use").attr("transform", "translate(-22, -12)").attr("width", "44").attr("height", "24");
      var uEnter = groupsEnter.filter(function(d2) {
        return d2.u;
      });
      uEnter.append("circle").attr("r", "16");
      uEnter.append("use").attr("transform", "translate(-16, -16)").attr("width", "32").attr("height", "32");
      groups = groups.merge(groupsEnter).attr("opacity", function(d2) {
        return d2.direct === false ? "0.7" : null;
      }).attr("transform", turnTransform);
      groups.select("use").attr("xlink:href", icon2);
      groups.select("rect");
      groups.select("circle");
      var fillClass = context.getDebug("target") ? "pink " : "nocolor ";
      groups = touchLayer.selectAll("g.turn").data(turns, function(d2) {
        return d2.key;
      });
      groups.exit().remove();
      groupsEnter = groups.enter().append("g").attr("class", function(d2) {
        return "turn " + d2.key;
      });
      turnsEnter = groupsEnter.filter(function(d2) {
        return !d2.u;
      });
      turnsEnter.append("rect").attr("class", "target " + fillClass).attr("transform", "translate(-22, -12)").attr("width", "44").attr("height", "24");
      uEnter = groupsEnter.filter(function(d2) {
        return d2.u;
      });
      uEnter.append("circle").attr("class", "target " + fillClass).attr("r", "16");
      groups = groups.merge(groupsEnter).attr("transform", turnTransform);
      groups.select("rect");
      groups.select("circle");
      return this;
    }
    return drawTurns;
  }

  // modules/svg/vertices.js
  var import_fast_deep_equal8 = __toESM(require_fast_deep_equal());
  function svgVertices(projection2, context) {
    var radiuses = {
      //       z16-, z17,   z18+,  w/icon
      shadow: [6, 7.5, 7.5, 12],
      stroke: [2.5, 3.5, 3.5, 8],
      fill: [1, 1.5, 1.5, 1.5]
    };
    var _currHoverTarget;
    var _currPersistent = {};
    var _currHover = {};
    var _prevHover = {};
    var _currSelected = {};
    var _prevSelected = {};
    var _radii = {};
    function sortY(a2, b2) {
      return b2.loc[1] - a2.loc[1];
    }
    function fastEntityKey(d2) {
      var mode = context.mode();
      var isMoving = mode && /^(add|draw|drag|move|rotate)/.test(mode.id);
      return isMoving ? d2.id : osmEntity.key(d2);
    }
    function draw(selection2, graph, vertices, sets2, filter2) {
      sets2 = sets2 || { selected: {}, important: {}, hovered: {} };
      var icons = {};
      var directions = {};
      var wireframe = context.surface().classed("fill-wireframe");
      var zoom = geoScaleToZoom(projection2.scale());
      var z2 = zoom < 17 ? 0 : zoom < 18 ? 1 : 2;
      var activeID = context.activeID();
      var base = context.history().base();
      function getIcon(d2) {
        var entity = graph.entity(d2.id);
        if (entity.id in icons)
          return icons[entity.id];
        icons[entity.id] = entity.hasInterestingTags() && _mainPresetIndex.match(entity, graph).icon;
        return icons[entity.id];
      }
      function getDirections(entity) {
        if (entity.id in directions)
          return directions[entity.id];
        var angles = entity.directions(graph, projection2);
        directions[entity.id] = angles.length ? angles : false;
        return angles;
      }
      function updateAttributes(selection3) {
        ["shadow", "stroke", "fill"].forEach(function(klass) {
          var rads = radiuses[klass];
          selection3.selectAll("." + klass).each(function(entity) {
            var i3 = z2 && getIcon(entity);
            var r2 = rads[i3 ? 3 : z2];
            if (entity.id !== activeID && entity.isEndpoint(graph) && !entity.isConnected(graph)) {
              r2 += 1.5;
            }
            if (klass === "shadow") {
              _radii[entity.id] = r2;
            }
            select_default2(this).attr("r", r2).attr("visibility", i3 && klass === "fill" ? "hidden" : null);
          });
        });
      }
      vertices.sort(sortY);
      var groups = selection2.selectAll("g.vertex").filter(filter2).data(vertices, fastEntityKey);
      groups.exit().remove();
      var enter = groups.enter().append("g").attr("class", function(d2) {
        return "node vertex " + d2.id;
      }).order();
      enter.append("circle").attr("class", "shadow");
      enter.append("circle").attr("class", "stroke");
      enter.filter(function(d2) {
        return d2.hasInterestingTags();
      }).append("circle").attr("class", "fill");
      groups = groups.merge(enter).attr("transform", svgPointTransform(projection2)).classed("sibling", function(d2) {
        return d2.id in sets2.selected;
      }).classed("shared", function(d2) {
        return graph.isShared(d2);
      }).classed("endpoint", function(d2) {
        return d2.isEndpoint(graph);
      }).classed("added", function(d2) {
        return !base.entities[d2.id];
      }).classed("moved", function(d2) {
        return base.entities[d2.id] && !(0, import_fast_deep_equal8.default)(graph.entities[d2.id].loc, base.entities[d2.id].loc);
      }).classed("retagged", function(d2) {
        return base.entities[d2.id] && !(0, import_fast_deep_equal8.default)(graph.entities[d2.id].tags, base.entities[d2.id].tags);
      }).call(updateAttributes);
      var iconUse = groups.selectAll(".icon").data(function data(d2) {
        return zoom >= 17 && getIcon(d2) ? [d2] : [];
      }, fastEntityKey);
      iconUse.exit().remove();
      iconUse.enter().append("use").attr("class", "icon").attr("width", "12px").attr("height", "12px").attr("transform", "translate(-6, -6)").attr("xlink:href", function(d2) {
        var picon = getIcon(d2);
        return picon ? "#" + picon : "";
      });
      var dgroups = groups.selectAll(".viewfieldgroup").data(function data(d2) {
        return zoom >= 18 && getDirections(d2) ? [d2] : [];
      }, fastEntityKey);
      dgroups.exit().remove();
      dgroups = dgroups.enter().insert("g", ".shadow").attr("class", "viewfieldgroup").merge(dgroups);
      var viewfields = dgroups.selectAll(".viewfield").data(getDirections, function key(d2) {
        return osmEntity.key(d2);
      });
      viewfields.exit().remove();
      viewfields.enter().append("path").attr("class", "viewfield").attr("d", "M0,0H0").merge(viewfields).attr("marker-start", "url(#ideditor-viewfield-marker" + (wireframe ? "-wireframe" : "") + ")").attr("transform", function(d2) {
        return "rotate(" + d2 + ")";
      });
    }
    function drawTargets(selection2, graph, entities, filter2) {
      var targetClass = context.getDebug("target") ? "pink " : "nocolor ";
      var nopeClass = context.getDebug("target") ? "red " : "nocolor ";
      var getTransform = svgPointTransform(projection2).geojson;
      var activeID = context.activeID();
      var data = { targets: [], nopes: [] };
      entities.forEach(function(node) {
        if (activeID === node.id)
          return;
        var vertexType = svgPassiveVertex(node, graph, activeID);
        if (vertexType !== 0) {
          data.targets.push({
            type: "Feature",
            id: node.id,
            properties: {
              target: true,
              entity: node
            },
            geometry: node.asGeoJSON()
          });
        } else {
          data.nopes.push({
            type: "Feature",
            id: node.id + "-nope",
            properties: {
              nope: true,
              target: true,
              entity: node
            },
            geometry: node.asGeoJSON()
          });
        }
      });
      var targets = selection2.selectAll(".vertex.target-allowed").filter(function(d2) {
        return filter2(d2.properties.entity);
      }).data(data.targets, function key(d2) {
        return d2.id;
      });
      targets.exit().remove();
      targets.enter().append("circle").attr("r", function(d2) {
        return _radii[d2.id] || radiuses.shadow[3];
      }).merge(targets).attr("class", function(d2) {
        return "node vertex target target-allowed " + targetClass + d2.id;
      }).attr("transform", getTransform);
      var nopes = selection2.selectAll(".vertex.target-nope").filter(function(d2) {
        return filter2(d2.properties.entity);
      }).data(data.nopes, function key(d2) {
        return d2.id;
      });
      nopes.exit().remove();
      nopes.enter().append("circle").attr("r", function(d2) {
        return _radii[d2.properties.entity.id] || radiuses.shadow[3];
      }).merge(nopes).attr("class", function(d2) {
        return "node vertex target target-nope " + nopeClass + d2.id;
      }).attr("transform", getTransform);
    }
    function renderAsVertex(entity, graph, wireframe, zoom) {
      var geometry = entity.geometry(graph);
      return geometry === "vertex" || geometry === "point" && (wireframe || zoom >= 18 && entity.directions(graph, projection2).length);
    }
    function isEditedNode(node, base, head) {
      var baseNode = base.entities[node.id];
      var headNode = head.entities[node.id];
      return !headNode || !baseNode || !(0, import_fast_deep_equal8.default)(headNode.tags, baseNode.tags) || !(0, import_fast_deep_equal8.default)(headNode.loc, baseNode.loc);
    }
    function getSiblingAndChildVertices(ids, graph, wireframe, zoom) {
      var results = {};
      var seenIds = {};
      function addChildVertices(entity) {
        if (seenIds[entity.id])
          return;
        seenIds[entity.id] = true;
        var geometry = entity.geometry(graph);
        if (!context.features().isHiddenFeature(entity, graph, geometry)) {
          var i3;
          if (entity.type === "way") {
            for (i3 = 0; i3 < entity.nodes.length; i3++) {
              var child = graph.hasEntity(entity.nodes[i3]);
              if (child) {
                addChildVertices(child);
              }
            }
          } else if (entity.type === "relation") {
            for (i3 = 0; i3 < entity.members.length; i3++) {
              var member = graph.hasEntity(entity.members[i3].id);
              if (member) {
                addChildVertices(member);
              }
            }
          } else if (renderAsVertex(entity, graph, wireframe, zoom)) {
            results[entity.id] = entity;
          }
        }
      }
      ids.forEach(function(id2) {
        var entity = graph.hasEntity(id2);
        if (!entity)
          return;
        if (entity.type === "node") {
          if (renderAsVertex(entity, graph, wireframe, zoom)) {
            results[entity.id] = entity;
            graph.parentWays(entity).forEach(function(entity2) {
              addChildVertices(entity2);
            });
          }
        } else {
          addChildVertices(entity);
        }
      });
      return results;
    }
    function drawVertices(selection2, graph, entities, filter2, extent, fullRedraw) {
      var wireframe = context.surface().classed("fill-wireframe");
      var visualDiff = context.surface().classed("highlight-edited");
      var zoom = geoScaleToZoom(projection2.scale());
      var mode = context.mode();
      var isMoving = mode && /^(add|draw|drag|move|rotate)/.test(mode.id);
      var base = context.history().base();
      var drawLayer = selection2.selectAll(".layer-osm.points .points-group.vertices");
      var touchLayer = selection2.selectAll(".layer-touch.points");
      if (fullRedraw) {
        _currPersistent = {};
        _radii = {};
      }
      for (var i3 = 0; i3 < entities.length; i3++) {
        var entity = entities[i3];
        var geometry = entity.geometry(graph);
        var keep = false;
        if (geometry === "point" && renderAsVertex(entity, graph, wireframe, zoom)) {
          _currPersistent[entity.id] = entity;
          keep = true;
        } else if (geometry === "vertex" && (entity.hasInterestingTags() || entity.isEndpoint(graph) || entity.isConnected(graph) || visualDiff && isEditedNode(entity, base, graph))) {
          _currPersistent[entity.id] = entity;
          keep = true;
        }
        if (!keep && !fullRedraw) {
          delete _currPersistent[entity.id];
        }
      }
      var sets2 = {
        persistent: _currPersistent,
        // persistent = important vertices (render always)
        selected: _currSelected,
        // selected + siblings of selected (render always)
        hovered: _currHover
        // hovered + siblings of hovered (render only in draw modes)
      };
      var all = Object.assign({}, isMoving ? _currHover : {}, _currSelected, _currPersistent);
      var filterRendered = function(d2) {
        return d2.id in _currPersistent || d2.id in _currSelected || d2.id in _currHover || filter2(d2);
      };
      drawLayer.call(draw, graph, currentVisible(all), sets2, filterRendered);
      var filterTouch = function(d2) {
        return isMoving ? true : filterRendered(d2);
      };
      touchLayer.call(drawTargets, graph, currentVisible(all), filterTouch);
      function currentVisible(which) {
        return Object.keys(which).map(graph.hasEntity, graph).filter(function(entity2) {
          return entity2 && entity2.intersects(extent, graph);
        });
      }
    }
    drawVertices.drawSelected = function(selection2, graph, extent) {
      var wireframe = context.surface().classed("fill-wireframe");
      var zoom = geoScaleToZoom(projection2.scale());
      _prevSelected = _currSelected || {};
      if (context.map().isInWideSelection()) {
        _currSelected = {};
        context.selectedIDs().forEach(function(id2) {
          var entity = graph.hasEntity(id2);
          if (!entity)
            return;
          if (entity.type === "node") {
            if (renderAsVertex(entity, graph, wireframe, zoom)) {
              _currSelected[entity.id] = entity;
            }
          }
        });
      } else {
        _currSelected = getSiblingAndChildVertices(context.selectedIDs(), graph, wireframe, zoom);
      }
      var filter2 = function(d2) {
        return d2.id in _prevSelected;
      };
      drawVertices(selection2, graph, Object.values(_prevSelected), filter2, extent, false);
    };
    drawVertices.drawHover = function(selection2, graph, target, extent) {
      if (target === _currHoverTarget)
        return;
      var wireframe = context.surface().classed("fill-wireframe");
      var zoom = geoScaleToZoom(projection2.scale());
      _prevHover = _currHover || {};
      _currHoverTarget = target;
      var entity = target && target.properties && target.properties.entity;
      if (entity) {
        _currHover = getSiblingAndChildVertices([entity.id], graph, wireframe, zoom);
      } else {
        _currHover = {};
      }
      var filter2 = function(d2) {
        return d2.id in _prevHover;
      };
      drawVertices(selection2, graph, Object.values(_prevHover), filter2, extent, false);
    };
    return drawVertices;
  }

  // modules/util/bind_once.js
  function utilBindOnce(target, type2, listener, capture) {
    var typeOnce = type2 + ".once";
    function one2() {
      target.on(typeOnce, null);
      listener.apply(this, arguments);
    }
    target.on(typeOnce, one2, capture);
    return this;
  }

  // modules/util/zoom_pan.js
  function defaultFilter3(d3_event) {
    return !d3_event.ctrlKey && !d3_event.button;
  }
  function defaultExtent2() {
    var e3 = this;
    if (e3 instanceof SVGElement) {
      e3 = e3.ownerSVGElement || e3;
      if (e3.hasAttribute("viewBox")) {
        e3 = e3.viewBox.baseVal;
        return [[e3.x, e3.y], [e3.x + e3.width, e3.y + e3.height]];
      }
      return [[0, 0], [e3.width.baseVal.value, e3.height.baseVal.value]];
    }
    return [[0, 0], [e3.clientWidth, e3.clientHeight]];
  }
  function defaultWheelDelta2(d3_event) {
    return -d3_event.deltaY * (d3_event.deltaMode === 1 ? 0.05 : d3_event.deltaMode ? 1 : 2e-3);
  }
  function defaultConstrain2(transform2, extent, translateExtent) {
    var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
    return transform2.translate(
      dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
      dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
    );
  }
  function utilZoomPan() {
    var filter2 = defaultFilter3, extent = defaultExtent2, constrain = defaultConstrain2, wheelDelta = defaultWheelDelta2, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], interpolate = zoom_default, dispatch14 = dispatch_default("start", "zoom", "end"), _wheelDelay = 150, _transform = identity2, _activeGesture;
    function zoom(selection2) {
      selection2.on("pointerdown.zoom", pointerdown).on("wheel.zoom", wheeled).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      select_default2(window).on("pointermove.zoompan", pointermove).on("pointerup.zoompan pointercancel.zoompan", pointerup);
    }
    zoom.transform = function(collection, transform2, point2) {
      var selection2 = collection.selection ? collection.selection() : collection;
      if (collection !== selection2) {
        schedule(collection, transform2, point2);
      } else {
        selection2.interrupt().each(function() {
          gesture(this, arguments).start(null).zoom(null, null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end(null);
        });
      }
    };
    zoom.scaleBy = function(selection2, k2, p2) {
      zoom.scaleTo(selection2, function() {
        var k0 = _transform.k, k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
        return k0 * k1;
      }, p2);
    };
    zoom.scaleTo = function(selection2, k2, p2) {
      zoom.transform(selection2, function() {
        var e3 = extent.apply(this, arguments), t0 = _transform, p02 = !p2 ? centroid(e3) : typeof p2 === "function" ? p2.apply(this, arguments) : p2, p1 = t0.invert(p02), k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
        return constrain(translate(scale(t0, k1), p02, p1), e3, translateExtent);
      }, p2);
    };
    zoom.translateBy = function(selection2, x2, y2) {
      zoom.transform(selection2, function() {
        return constrain(_transform.translate(
          typeof x2 === "function" ? x2.apply(this, arguments) : x2,
          typeof y2 === "function" ? y2.apply(this, arguments) : y2
        ), extent.apply(this, arguments), translateExtent);
      });
    };
    zoom.translateTo = function(selection2, x2, y2, p2) {
      zoom.transform(selection2, function() {
        var e3 = extent.apply(this, arguments), t2 = _transform, p02 = !p2 ? centroid(e3) : typeof p2 === "function" ? p2.apply(this, arguments) : p2;
        return constrain(identity2.translate(p02[0], p02[1]).scale(t2.k).translate(
          typeof x2 === "function" ? -x2.apply(this, arguments) : -x2,
          typeof y2 === "function" ? -y2.apply(this, arguments) : -y2
        ), e3, translateExtent);
      }, p2);
    };
    function scale(transform2, k2) {
      k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));
      return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);
    }
    function translate(transform2, p02, p1) {
      var x2 = p02[0] - p1[0] * transform2.k, y2 = p02[1] - p1[1] * transform2.k;
      return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
    }
    function centroid(extent2) {
      return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
    }
    function schedule(transition2, transform2, point2) {
      transition2.on("start.zoom", function() {
        gesture(this, arguments).start(null);
      }).on("interrupt.zoom end.zoom", function() {
        gesture(this, arguments).end(null);
      }).tween("zoom", function() {
        var that = this, args = arguments, g3 = gesture(that, args), e3 = extent.apply(that, args), p2 = !point2 ? centroid(e3) : typeof point2 === "function" ? point2.apply(that, args) : point2, w2 = Math.max(e3[1][0] - e3[0][0], e3[1][1] - e3[0][1]), a2 = _transform, b2 = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i3 = interpolate(a2.invert(p2).concat(w2 / a2.k), b2.invert(p2).concat(w2 / b2.k));
        return function(t2) {
          if (t2 === 1) {
            t2 = b2;
          } else {
            var l2 = i3(t2);
            var k2 = w2 / l2[2];
            t2 = new Transform(k2, p2[0] - l2[0] * k2, p2[1] - l2[1] * k2);
          }
          g3.zoom(null, null, t2);
        };
      });
    }
    function gesture(that, args, clean2) {
      return !clean2 && _activeGesture || new Gesture(that, args);
    }
    function Gesture(that, args) {
      this.that = that;
      this.args = args;
      this.active = 0;
      this.extent = extent.apply(that, args);
    }
    Gesture.prototype = {
      start: function(d3_event) {
        if (++this.active === 1) {
          _activeGesture = this;
          dispatch14.call("start", this, d3_event);
        }
        return this;
      },
      zoom: function(d3_event, key, transform2) {
        if (this.mouse && key !== "mouse")
          this.mouse[1] = transform2.invert(this.mouse[0]);
        if (this.pointer0 && key !== "touch")
          this.pointer0[1] = transform2.invert(this.pointer0[0]);
        if (this.pointer1 && key !== "touch")
          this.pointer1[1] = transform2.invert(this.pointer1[0]);
        _transform = transform2;
        dispatch14.call("zoom", this, d3_event, key, transform2);
        return this;
      },
      end: function(d3_event) {
        if (--this.active === 0) {
          _activeGesture = null;
          dispatch14.call("end", this, d3_event);
        }
        return this;
      }
    };
    function wheeled(d3_event) {
      if (!filter2.apply(this, arguments))
        return;
      var g3 = gesture(this, arguments), t2 = _transform, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t2.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p2 = utilFastMouse(this)(d3_event);
      if (g3.wheel) {
        if (g3.mouse[0][0] !== p2[0] || g3.mouse[0][1] !== p2[1]) {
          g3.mouse[1] = t2.invert(g3.mouse[0] = p2);
        }
        clearTimeout(g3.wheel);
      } else {
        g3.mouse = [p2, t2.invert(p2)];
        interrupt_default(this);
        g3.start(d3_event);
      }
      d3_event.preventDefault();
      d3_event.stopImmediatePropagation();
      g3.wheel = setTimeout(wheelidled, _wheelDelay);
      g3.zoom(d3_event, "mouse", constrain(translate(scale(t2, k2), g3.mouse[0], g3.mouse[1]), g3.extent, translateExtent));
      function wheelidled() {
        g3.wheel = null;
        g3.end(d3_event);
      }
    }
    var _downPointerIDs = /* @__PURE__ */ new Set();
    var _pointerLocGetter;
    function pointerdown(d3_event) {
      _downPointerIDs.add(d3_event.pointerId);
      if (!filter2.apply(this, arguments))
        return;
      var g3 = gesture(this, arguments, _downPointerIDs.size === 1);
      var started;
      d3_event.stopImmediatePropagation();
      _pointerLocGetter = utilFastMouse(this);
      var loc = _pointerLocGetter(d3_event);
      var p2 = [loc, _transform.invert(loc), d3_event.pointerId];
      if (!g3.pointer0) {
        g3.pointer0 = p2;
        started = true;
      } else if (!g3.pointer1 && g3.pointer0[2] !== p2[2]) {
        g3.pointer1 = p2;
      }
      if (started) {
        interrupt_default(this);
        g3.start(d3_event);
      }
    }
    function pointermove(d3_event) {
      if (!_downPointerIDs.has(d3_event.pointerId))
        return;
      if (!_activeGesture || !_pointerLocGetter)
        return;
      var g3 = gesture(this, arguments);
      var isPointer0 = g3.pointer0 && g3.pointer0[2] === d3_event.pointerId;
      var isPointer1 = !isPointer0 && g3.pointer1 && g3.pointer1[2] === d3_event.pointerId;
      if ((isPointer0 || isPointer1) && "buttons" in d3_event && !d3_event.buttons) {
        if (g3.pointer0)
          _downPointerIDs.delete(g3.pointer0[2]);
        if (g3.pointer1)
          _downPointerIDs.delete(g3.pointer1[2]);
        g3.end(d3_event);
        return;
      }
      d3_event.preventDefault();
      d3_event.stopImmediatePropagation();
      var loc = _pointerLocGetter(d3_event);
      var t2, p2, l2;
      if (isPointer0)
        g3.pointer0[0] = loc;
      else if (isPointer1)
        g3.pointer1[0] = loc;
      t2 = _transform;
      if (g3.pointer1) {
        var p02 = g3.pointer0[0], l0 = g3.pointer0[1], p1 = g3.pointer1[0], l1 = g3.pointer1[1], dp = (dp = p1[0] - p02[0]) * dp + (dp = p1[1] - p02[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
        t2 = scale(t2, Math.sqrt(dp / dl));
        p2 = [(p02[0] + p1[0]) / 2, (p02[1] + p1[1]) / 2];
        l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      } else if (g3.pointer0) {
        p2 = g3.pointer0[0];
        l2 = g3.pointer0[1];
      } else {
        return;
      }
      g3.zoom(d3_event, "touch", constrain(translate(t2, p2, l2), g3.extent, translateExtent));
    }
    function pointerup(d3_event) {
      if (!_downPointerIDs.has(d3_event.pointerId))
        return;
      _downPointerIDs.delete(d3_event.pointerId);
      if (!_activeGesture)
        return;
      var g3 = gesture(this, arguments);
      d3_event.stopImmediatePropagation();
      if (g3.pointer0 && g3.pointer0[2] === d3_event.pointerId)
        delete g3.pointer0;
      else if (g3.pointer1 && g3.pointer1[2] === d3_event.pointerId)
        delete g3.pointer1;
      if (g3.pointer1 && !g3.pointer0) {
        g3.pointer0 = g3.pointer1;
        delete g3.pointer1;
      }
      if (g3.pointer0) {
        g3.pointer0[1] = _transform.invert(g3.pointer0[0]);
      } else {
        g3.end(d3_event);
      }
    }
    zoom.wheelDelta = function(_2) {
      return arguments.length ? (wheelDelta = utilFunctor(+_2), zoom) : wheelDelta;
    };
    zoom.filter = function(_2) {
      return arguments.length ? (filter2 = utilFunctor(!!_2), zoom) : filter2;
    };
    zoom.extent = function(_2) {
      return arguments.length ? (extent = utilFunctor([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom) : extent;
    };
    zoom.scaleExtent = function(_2) {
      return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom) : [scaleExtent[0], scaleExtent[1]];
    };
    zoom.translateExtent = function(_2) {
      return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
    };
    zoom.constrain = function(_2) {
      return arguments.length ? (constrain = _2, zoom) : constrain;
    };
    zoom.interpolate = function(_2) {
      return arguments.length ? (interpolate = _2, zoom) : interpolate;
    };
    zoom._transform = function(_2) {
      return arguments.length ? (_transform = _2, zoom) : _transform;
    };
    return utilRebind(zoom, dispatch14, "on");
  }

  // modules/util/double_up.js
  function utilDoubleUp() {
    var dispatch14 = dispatch_default("doubleUp");
    var _maxTimespan = 500;
    var _maxDistance = 20;
    var _pointer;
    function pointerIsValidFor(loc) {
      return (/* @__PURE__ */ new Date()).getTime() - _pointer.startTime <= _maxTimespan && // all pointer events must occur within a small distance of the first pointerdown
      geoVecLength(_pointer.startLoc, loc) <= _maxDistance;
    }
    function pointerdown(d3_event) {
      if (d3_event.ctrlKey || d3_event.button === 2)
        return;
      var loc = [d3_event.clientX, d3_event.clientY];
      if (_pointer && !pointerIsValidFor(loc)) {
        _pointer = void 0;
      }
      if (!_pointer) {
        _pointer = {
          startLoc: loc,
          startTime: (/* @__PURE__ */ new Date()).getTime(),
          upCount: 0,
          pointerId: d3_event.pointerId
        };
      } else {
        _pointer.pointerId = d3_event.pointerId;
      }
    }
    function pointerup(d3_event) {
      if (d3_event.ctrlKey || d3_event.button === 2)
        return;
      if (!_pointer || _pointer.pointerId !== d3_event.pointerId)
        return;
      _pointer.upCount += 1;
      if (_pointer.upCount === 2) {
        var loc = [d3_event.clientX, d3_event.clientY];
        if (pointerIsValidFor(loc)) {
          var locInThis = utilFastMouse(this)(d3_event);
          dispatch14.call("doubleUp", this, d3_event, locInThis);
        }
        _pointer = void 0;
      }
    }
    function doubleUp(selection2) {
      if ("PointerEvent" in window) {
        selection2.on("pointerdown.doubleUp", pointerdown).on("pointerup.doubleUp", pointerup);
      } else {
        selection2.on("dblclick.doubleUp", function(d3_event) {
          dispatch14.call("doubleUp", this, d3_event, utilFastMouse(this)(d3_event));
        });
      }
    }
    doubleUp.off = function(selection2) {
      selection2.on("pointerdown.doubleUp", null).on("pointerup.doubleUp", null).on("dblclick.doubleUp", null);
    };
    return utilRebind(doubleUp, dispatch14, "on");
  }

  // modules/renderer/map.js
  var TILESIZE = 256;
  var minZoom2 = 2;
  var maxZoom = 24;
  var kMin = geoZoomToScale(minZoom2, TILESIZE);
  var kMax = geoZoomToScale(maxZoom, TILESIZE);
  function clamp2(num, min3, max3) {
    return Math.max(min3, Math.min(num, max3));
  }
  function rendererMap(context) {
    var dispatch14 = dispatch_default(
      "move",
      "drawn",
      "crossEditableZoom",
      "hitMinZoom",
      "changeHighlighting",
      "changeAreaFill"
    );
    var projection2 = context.projection;
    var curtainProjection = context.curtainProjection;
    var drawLayers;
    var drawPoints;
    var drawVertices;
    var drawLines;
    var drawAreas;
    var drawMidpoints;
    var drawLabels;
    var _selection = select_default2(null);
    var supersurface = select_default2(null);
    var wrapper = select_default2(null);
    var surface = select_default2(null);
    var _dimensions = [1, 1];
    var _dblClickZoomEnabled = true;
    var _redrawEnabled = true;
    var _gestureTransformStart;
    var _transformStart = projection2.transform();
    var _transformLast;
    var _isTransformed = false;
    var _minzoom = 0;
    var _getMouseCoords;
    var _lastPointerEvent;
    var _lastWithinEditableZoom;
    var _pointerDown = false;
    var _pointerPrefix = "PointerEvent" in window ? "pointer" : "mouse";
    var _zoomerPannerFunction = "PointerEvent" in window ? utilZoomPan : zoom_default2;
    var _zoomerPanner = _zoomerPannerFunction().scaleExtent([kMin, kMax]).interpolate(value_default).filter(zoomEventFilter).on("zoom.map", zoomPan2).on("start.map", function(d3_event) {
      _pointerDown = d3_event && (d3_event.type === "pointerdown" || d3_event.sourceEvent && d3_event.sourceEvent.type === "pointerdown");
    }).on("end.map", function() {
      _pointerDown = false;
    });
    var _doubleUpHandler = utilDoubleUp();
    var scheduleRedraw = throttle_default(redraw, 750);
    function cancelPendingRedraw() {
      scheduleRedraw.cancel();
    }
    function map2(selection2) {
      _selection = selection2;
      context.on("change.map", immediateRedraw);
      var osm = context.connection();
      if (osm) {
        osm.on("change.map", immediateRedraw);
      }
      function didUndoOrRedo(targetTransform) {
        var mode = context.mode().id;
        if (mode !== "browse" && mode !== "select")
          return;
        if (targetTransform) {
          map2.transformEase(targetTransform);
        }
      }
      context.history().on("merge.map", function() {
        scheduleRedraw();
      }).on("change.map", immediateRedraw).on("undone.map", function(stack, fromStack) {
        didUndoOrRedo(fromStack.transform);
      }).on("redone.map", function(stack) {
        didUndoOrRedo(stack.transform);
      });
      context.background().on("change.map", immediateRedraw);
      context.features().on("redraw.map", immediateRedraw);
      drawLayers.on("change.map", function() {
        context.background().updateImagery();
        immediateRedraw();
      });
      selection2.on("wheel.map mousewheel.map", function(d3_event) {
        d3_event.preventDefault();
      }).call(_zoomerPanner).call(_zoomerPanner.transform, projection2.transform()).on("dblclick.zoom", null);
      map2.supersurface = supersurface = selection2.append("div").attr("class", "supersurface").call(utilSetTransform, 0, 0);
      wrapper = supersurface.append("div").attr("class", "layer layer-data");
      map2.surface = surface = wrapper.call(drawLayers).selectAll(".surface");
      surface.call(drawLabels.observe).call(_doubleUpHandler).on(_pointerPrefix + "down.zoom", function(d3_event) {
        _lastPointerEvent = d3_event;
        if (d3_event.button === 2) {
          d3_event.stopPropagation();
        }
      }, true).on(_pointerPrefix + "up.zoom", function(d3_event) {
        _lastPointerEvent = d3_event;
        if (resetTransform()) {
          immediateRedraw();
        }
      }).on(_pointerPrefix + "move.map", function(d3_event) {
        _lastPointerEvent = d3_event;
      }).on(_pointerPrefix + "over.vertices", function(d3_event) {
        if (map2.editableDataEnabled() && !_isTransformed) {
          var hover = d3_event.target.__data__;
          surface.call(drawVertices.drawHover, context.graph(), hover, map2.extent());
          dispatch14.call("drawn", this, { full: false });
        }
      }).on(_pointerPrefix + "out.vertices", function(d3_event) {
        if (map2.editableDataEnabled() && !_isTransformed) {
          var hover = d3_event.relatedTarget && d3_event.relatedTarget.__data__;
          surface.call(drawVertices.drawHover, context.graph(), hover, map2.extent());
          dispatch14.call("drawn", this, { full: false });
        }
      });
      var detected = utilDetect();
      if ("GestureEvent" in window && // Listening for gesture events on iOS 13.4+ breaks double-tapping,
      // but we only need to do this on desktop Safari anyway. – #7694
      !detected.isMobileWebKit) {
        surface.on("gesturestart.surface", function(d3_event) {
          d3_event.preventDefault();
          _gestureTransformStart = projection2.transform();
        }).on("gesturechange.surface", gestureChange);
      }
      updateAreaFill();
      _doubleUpHandler.on("doubleUp.map", function(d3_event, p02) {
        if (!_dblClickZoomEnabled)
          return;
        if (typeof d3_event.target.__data__ === "object" && // or area fills
        !select_default2(d3_event.target).classed("fill"))
          return;
        var zoomOut2 = d3_event.shiftKey;
        var t2 = projection2.transform();
        var p1 = t2.invert(p02);
        t2 = t2.scale(zoomOut2 ? 0.5 : 2);
        t2.x = p02[0] - p1[0] * t2.k;
        t2.y = p02[1] - p1[1] * t2.k;
        map2.transformEase(t2);
      });
      context.on("enter.map", function() {
        if (!map2.editableDataEnabled(
          true
          /* skip zoom check */
        ))
          return;
        if (_isTransformed)
          return;
        var graph = context.graph();
        var selectedAndParents = {};
        context.selectedIDs().forEach(function(id2) {
          var entity = graph.hasEntity(id2);
          if (entity) {
            selectedAndParents[entity.id] = entity;
            if (entity.type === "node") {
              graph.parentWays(entity).forEach(function(parent) {
                selectedAndParents[parent.id] = parent;
              });
            }
          }
        });
        var data = Object.values(selectedAndParents);
        var filter2 = function(d2) {
          return d2.id in selectedAndParents;
        };
        data = context.features().filter(data, graph);
        surface.call(drawVertices.drawSelected, graph, map2.extent()).call(drawLines, graph, data, filter2).call(drawAreas, graph, data, filter2).call(drawMidpoints, graph, data, filter2, map2.trimmedExtent());
        dispatch14.call("drawn", this, { full: false });
        scheduleRedraw();
      });
      map2.dimensions(utilGetDimensions(selection2));
    }
    function zoomEventFilter(d3_event) {
      if (d3_event.type === "mousedown") {
        var hasOrphan = false;
        var listeners = window.__on;
        for (var i3 = 0; i3 < listeners.length; i3++) {
          var listener = listeners[i3];
          if (listener.name === "zoom" && listener.type === "mouseup") {
            hasOrphan = true;
            break;
          }
        }
        if (hasOrphan) {
          var event = window.CustomEvent;
          if (event) {
            event = new event("mouseup");
          } else {
            event = window.document.createEvent("Event");
            event.initEvent("mouseup", false, false);
          }
          event.view = window;
          window.dispatchEvent(event);
        }
      }
      return d3_event.button !== 2;
    }
    function pxCenter() {
      return [_dimensions[0] / 2, _dimensions[1] / 2];
    }
    function drawEditable(difference2, extent) {
      var mode = context.mode();
      var graph = context.graph();
      var features = context.features();
      var all = context.history().intersects(map2.extent());
      var fullRedraw = false;
      var data;
      var set4;
      var filter2;
      var applyFeatureLayerFilters = true;
      if (map2.isInWideSelection()) {
        data = [];
        utilEntityAndDeepMemberIDs(mode.selectedIDs(), context.graph()).forEach(function(id2) {
          var entity = context.hasEntity(id2);
          if (entity)
            data.push(entity);
        });
        fullRedraw = true;
        filter2 = utilFunctor(true);
        applyFeatureLayerFilters = false;
      } else if (difference2) {
        var complete = difference2.complete(map2.extent());
        data = Object.values(complete).filter(Boolean);
        set4 = new Set(Object.keys(complete));
        filter2 = function(d2) {
          return set4.has(d2.id);
        };
        features.clear(data);
      } else {
        if (features.gatherStats(all, graph, _dimensions)) {
          extent = void 0;
        }
        if (extent) {
          data = context.history().intersects(map2.extent().intersection(extent));
          set4 = new Set(data.map(function(entity) {
            return entity.id;
          }));
          filter2 = function(d2) {
            return set4.has(d2.id);
          };
        } else {
          data = all;
          fullRedraw = true;
          filter2 = utilFunctor(true);
        }
      }
      if (applyFeatureLayerFilters) {
        data = features.filter(data, graph);
      } else {
        context.features().resetStats();
      }
      if (mode && mode.id === "select") {
        surface.call(drawVertices.drawSelected, graph, map2.extent());
      }
      surface.call(drawVertices, graph, data, filter2, map2.extent(), fullRedraw).call(drawLines, graph, data, filter2).call(drawAreas, graph, data, filter2).call(drawMidpoints, graph, data, filter2, map2.trimmedExtent()).call(drawLabels, graph, data, filter2, _dimensions, fullRedraw).call(drawPoints, graph, data, filter2);
      dispatch14.call("drawn", this, { full: true });
    }
    map2.init = function() {
      drawLayers = svgLayers(projection2, context);
      drawPoints = svgPoints(projection2, context);
      drawVertices = svgVertices(projection2, context);
      drawLines = svgLines(projection2, context);
      drawAreas = svgAreas(projection2, context);
      drawMidpoints = svgMidpoints(projection2, context);
      drawLabels = svgLabels(projection2, context);
    };
    function editOff() {
      context.features().resetStats();
      surface.selectAll(".layer-osm *").remove();
      surface.selectAll(".layer-touch:not(.markers) *").remove();
      var allowed = {
        "browse": true,
        "save": true,
        "select-note": true,
        "select-data": true,
        "select-error": true
      };
      var mode = context.mode();
      if (mode && !allowed[mode.id]) {
        context.enter(modeBrowse(context));
      }
      dispatch14.call("drawn", this, { full: true });
    }
    function gestureChange(d3_event) {
      var e3 = d3_event;
      e3.preventDefault();
      var props = {
        deltaMode: 0,
        // dummy values to ignore in zoomPan
        deltaY: 1,
        // dummy values to ignore in zoomPan
        clientX: e3.clientX,
        clientY: e3.clientY,
        screenX: e3.screenX,
        screenY: e3.screenY,
        x: e3.x,
        y: e3.y
      };
      var e22 = new WheelEvent("wheel", props);
      e22._scale = e3.scale;
      e22._rotation = e3.rotation;
      _selection.node().dispatchEvent(e22);
    }
    function zoomPan2(event, key, transform2) {
      var source = event && event.sourceEvent || event;
      var eventTransform = transform2 || event && event.transform;
      var x2 = eventTransform.x;
      var y2 = eventTransform.y;
      var k2 = eventTransform.k;
      if (source && source.type === "wheel") {
        if (_pointerDown)
          return;
        var detected = utilDetect();
        var dX = source.deltaX;
        var dY = source.deltaY;
        var x22 = x2;
        var y22 = y2;
        var k22 = k2;
        var t0, p02, p1;
        if (source.deltaMode === 1) {
          var lines = Math.abs(source.deltaY);
          var sign2 = source.deltaY > 0 ? 1 : -1;
          dY = sign2 * clamp2(
            Math.exp((lines - 1) * 0.75) * 4.000244140625,
            4.000244140625,
            // min
            350.000244140625
            // max
          );
          if (detected.os !== "mac") {
            dY *= 5;
          }
          t0 = _isTransformed ? _transformLast : _transformStart;
          p02 = _getMouseCoords(source);
          p1 = t0.invert(p02);
          k22 = t0.k * Math.pow(2, -dY / 500);
          k22 = clamp2(k22, kMin, kMax);
          x22 = p02[0] - p1[0] * k22;
          y22 = p02[1] - p1[1] * k22;
        } else if (source._scale) {
          t0 = _gestureTransformStart;
          p02 = _getMouseCoords(source);
          p1 = t0.invert(p02);
          k22 = t0.k * source._scale;
          k22 = clamp2(k22, kMin, kMax);
          x22 = p02[0] - p1[0] * k22;
          y22 = p02[1] - p1[1] * k22;
        } else if (source.ctrlKey && !isInteger(dY)) {
          dY *= 6;
          t0 = _isTransformed ? _transformLast : _transformStart;
          p02 = _getMouseCoords(source);
          p1 = t0.invert(p02);
          k22 = t0.k * Math.pow(2, -dY / 500);
          k22 = clamp2(k22, kMin, kMax);
          x22 = p02[0] - p1[0] * k22;
          y22 = p02[1] - p1[1] * k22;
        } else if ((source.altKey || source.shiftKey) && isInteger(dY)) {
          t0 = _isTransformed ? _transformLast : _transformStart;
          p02 = _getMouseCoords(source);
          p1 = t0.invert(p02);
          k22 = t0.k * Math.pow(2, -dY / 500);
          k22 = clamp2(k22, kMin, kMax);
          x22 = p02[0] - p1[0] * k22;
          y22 = p02[1] - p1[1] * k22;
        } else if (detected.os === "mac" && detected.browser !== "Firefox" && !source.ctrlKey && isInteger(dX) && isInteger(dY)) {
          p1 = projection2.translate();
          x22 = p1[0] - dX;
          y22 = p1[1] - dY;
          k22 = projection2.scale();
          k22 = clamp2(k22, kMin, kMax);
        }
        if (x22 !== x2 || y22 !== y2 || k22 !== k2) {
          x2 = x22;
          y2 = y22;
          k2 = k22;
          eventTransform = identity2.translate(x22, y22).scale(k22);
          if (_zoomerPanner._transform) {
            _zoomerPanner._transform(eventTransform);
          } else {
            _selection.node().__zoom = eventTransform;
          }
        }
      }
      if (_transformStart.x === x2 && _transformStart.y === y2 && _transformStart.k === k2) {
        return;
      }
      if (geoScaleToZoom(k2, TILESIZE) < _minzoom) {
        surface.interrupt();
        dispatch14.call("hitMinZoom", this, map2);
        setCenterZoom(map2.center(), context.minEditableZoom(), 0, true);
        scheduleRedraw();
        dispatch14.call("move", this, map2);
        return;
      }
      projection2.transform(eventTransform);
      var withinEditableZoom = map2.withinEditableZoom();
      if (_lastWithinEditableZoom !== withinEditableZoom) {
        if (_lastWithinEditableZoom !== void 0) {
          dispatch14.call("crossEditableZoom", this, withinEditableZoom);
        }
        _lastWithinEditableZoom = withinEditableZoom;
      }
      var scale = k2 / _transformStart.k;
      var tX = (x2 / scale - _transformStart.x) * scale;
      var tY = (y2 / scale - _transformStart.y) * scale;
      if (context.inIntro()) {
        curtainProjection.transform({
          x: x2 - tX,
          y: y2 - tY,
          k: k2
        });
      }
      if (source) {
        _lastPointerEvent = event;
      }
      _isTransformed = true;
      _transformLast = eventTransform;
      utilSetTransform(supersurface, tX, tY, scale);
      scheduleRedraw();
      dispatch14.call("move", this, map2);
      function isInteger(val) {
        return typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      }
    }
    function resetTransform() {
      if (!_isTransformed)
        return false;
      utilSetTransform(supersurface, 0, 0);
      _isTransformed = false;
      if (context.inIntro()) {
        curtainProjection.transform(projection2.transform());
      }
      return true;
    }
    function redraw(difference2, extent) {
      if (surface.empty() || !_redrawEnabled)
        return;
      if (resetTransform()) {
        difference2 = extent = void 0;
      }
      var zoom = map2.zoom();
      var z2 = String(~~zoom);
      if (surface.attr("data-zoom") !== z2) {
        surface.attr("data-zoom", z2);
      }
      var lat = map2.center()[1];
      var lowzoom = linear3().domain([-60, 0, 60]).range([17, 18.5, 17]).clamp(true);
      surface.classed("low-zoom", zoom <= lowzoom(lat));
      if (!difference2) {
        supersurface.call(context.background());
        wrapper.call(drawLayers);
      }
      if (map2.editableDataEnabled() || map2.isInWideSelection()) {
        context.loadTiles(projection2);
        drawEditable(difference2, extent);
      } else {
        editOff();
      }
      _transformStart = projection2.transform();
      return map2;
    }
    var immediateRedraw = function(difference2, extent) {
      if (!difference2 && !extent)
        cancelPendingRedraw();
      redraw(difference2, extent);
    };
    map2.lastPointerEvent = function() {
      return _lastPointerEvent;
    };
    map2.mouse = function(d3_event) {
      var event = d3_event || _lastPointerEvent;
      if (event) {
        var s2;
        while (s2 = event.sourceEvent) {
          event = s2;
        }
        return _getMouseCoords(event);
      }
      return null;
    };
    map2.mouseCoordinates = function() {
      var coord2 = map2.mouse() || pxCenter();
      return projection2.invert(coord2);
    };
    map2.dblclickZoomEnable = function(val) {
      if (!arguments.length)
        return _dblClickZoomEnabled;
      _dblClickZoomEnabled = val;
      return map2;
    };
    map2.redrawEnable = function(val) {
      if (!arguments.length)
        return _redrawEnabled;
      _redrawEnabled = val;
      return map2;
    };
    map2.isTransformed = function() {
      return _isTransformed;
    };
    function setTransform(t2, duration, force) {
      var t3 = projection2.transform();
      if (!force && t2.k === t3.k && t2.x === t3.x && t2.y === t3.y)
        return false;
      if (duration) {
        _selection.transition().duration(duration).on("start", function() {
          map2.startEase();
        }).call(_zoomerPanner.transform, identity2.translate(t2.x, t2.y).scale(t2.k));
      } else {
        projection2.transform(t2);
        _transformStart = t2;
        _selection.call(_zoomerPanner.transform, _transformStart);
      }
      return true;
    }
    function setCenterZoom(loc2, z2, duration, force) {
      var c2 = map2.center();
      var z3 = map2.zoom();
      if (loc2[0] === c2[0] && loc2[1] === c2[1] && z2 === z3 && !force)
        return false;
      var proj = geoRawMercator().transform(projection2.transform());
      var k2 = clamp2(geoZoomToScale(z2, TILESIZE), kMin, kMax);
      proj.scale(k2);
      var t2 = proj.translate();
      var point2 = proj(loc2);
      var center = pxCenter();
      t2[0] += center[0] - point2[0];
      t2[1] += center[1] - point2[1];
      return setTransform(identity2.translate(t2[0], t2[1]).scale(k2), duration, force);
    }
    map2.pan = function(delta, duration) {
      var t2 = projection2.translate();
      var k2 = projection2.scale();
      t2[0] += delta[0];
      t2[1] += delta[1];
      if (duration) {
        _selection.transition().duration(duration).on("start", function() {
          map2.startEase();
        }).call(_zoomerPanner.transform, identity2.translate(t2[0], t2[1]).scale(k2));
      } else {
        projection2.translate(t2);
        _transformStart = projection2.transform();
        _selection.call(_zoomerPanner.transform, _transformStart);
        dispatch14.call("move", this, map2);
        immediateRedraw();
      }
      return map2;
    };
    map2.dimensions = function(val) {
      if (!arguments.length)
        return _dimensions;
      _dimensions = val;
      drawLayers.dimensions(_dimensions);
      context.background().dimensions(_dimensions);
      projection2.clipExtent([[0, 0], _dimensions]);
      _getMouseCoords = utilFastMouse(supersurface.node());
      scheduleRedraw();
      return map2;
    };
    function zoomIn(delta) {
      setCenterZoom(map2.center(), ~~map2.zoom() + delta, 250, true);
    }
    function zoomOut(delta) {
      setCenterZoom(map2.center(), ~~map2.zoom() - delta, 250, true);
    }
    map2.zoomIn = function() {
      zoomIn(1);
    };
    map2.zoomInFurther = function() {
      zoomIn(4);
    };
    map2.canZoomIn = function() {
      return map2.zoom() < maxZoom;
    };
    map2.zoomOut = function() {
      zoomOut(1);
    };
    map2.zoomOutFurther = function() {
      zoomOut(4);
    };
    map2.canZoomOut = function() {
      return map2.zoom() > minZoom2;
    };
    map2.center = function(loc2) {
      if (!arguments.length) {
        return projection2.invert(pxCenter());
      }
      if (setCenterZoom(loc2, map2.zoom())) {
        dispatch14.call("move", this, map2);
      }
      scheduleRedraw();
      return map2;
    };
    map2.unobscuredCenterZoomEase = function(loc, zoom) {
      var offset = map2.unobscuredOffsetPx();
      var proj = geoRawMercator().transform(projection2.transform());
      proj.scale(geoZoomToScale(zoom, TILESIZE));
      var locPx = proj(loc);
      var offsetLocPx = [locPx[0] + offset[0], locPx[1] + offset[1]];
      var offsetLoc = proj.invert(offsetLocPx);
      map2.centerZoomEase(offsetLoc, zoom);
    };
    map2.unobscuredOffsetPx = function() {
      var openPane = context.container().select(".map-panes .map-pane.shown");
      if (!openPane.empty()) {
        return [openPane.node().offsetWidth / 2, 0];
      }
      return [0, 0];
    };
    map2.zoom = function(z2) {
      if (!arguments.length) {
        return Math.max(geoScaleToZoom(projection2.scale(), TILESIZE), 0);
      }
      if (z2 < _minzoom) {
        surface.interrupt();
        dispatch14.call("hitMinZoom", this, map2);
        z2 = context.minEditableZoom();
      }
      if (setCenterZoom(map2.center(), z2)) {
        dispatch14.call("move", this, map2);
      }
      scheduleRedraw();
      return map2;
    };
    map2.centerZoom = function(loc2, z2) {
      if (setCenterZoom(loc2, z2)) {
        dispatch14.call("move", this, map2);
      }
      scheduleRedraw();
      return map2;
    };
    map2.zoomTo = function(entity) {
      var extent = entity.extent(context.graph());
      if (!isFinite(extent.area()))
        return map2;
      var z2 = clamp2(map2.trimmedExtentZoom(extent), 0, 20);
      return map2.centerZoom(extent.center(), z2);
    };
    map2.centerEase = function(loc2, duration) {
      duration = duration || 250;
      setCenterZoom(loc2, map2.zoom(), duration);
      return map2;
    };
    map2.zoomEase = function(z2, duration) {
      duration = duration || 250;
      setCenterZoom(map2.center(), z2, duration, false);
      return map2;
    };
    map2.centerZoomEase = function(loc2, z2, duration) {
      duration = duration || 250;
      setCenterZoom(loc2, z2, duration, false);
      return map2;
    };
    map2.transformEase = function(t2, duration) {
      duration = duration || 250;
      setTransform(
        t2,
        duration,
        false
        /* don't force */
      );
      return map2;
    };
    map2.zoomToEase = function(obj, duration) {
      var extent;
      if (Array.isArray(obj)) {
        obj.forEach(function(entity) {
          var entityExtent = entity.extent(context.graph());
          if (!extent) {
            extent = entityExtent;
          } else {
            extent = extent.extend(entityExtent);
          }
        });
      } else {
        extent = obj.extent(context.graph());
      }
      if (!isFinite(extent.area()))
        return map2;
      var z2 = clamp2(map2.trimmedExtentZoom(extent), 0, 20);
      return map2.centerZoomEase(extent.center(), z2, duration);
    };
    map2.startEase = function() {
      utilBindOnce(surface, _pointerPrefix + "down.ease", function() {
        map2.cancelEase();
      });
      return map2;
    };
    map2.cancelEase = function() {
      _selection.interrupt();
      return map2;
    };
    map2.extent = function(val) {
      if (!arguments.length) {
        return new geoExtent(
          projection2.invert([0, _dimensions[1]]),
          projection2.invert([_dimensions[0], 0])
        );
      } else {
        var extent = geoExtent(val);
        map2.centerZoom(extent.center(), map2.extentZoom(extent));
      }
    };
    map2.trimmedExtent = function(val) {
      if (!arguments.length) {
        var headerY = 71;
        var footerY = 30;
        var pad2 = 10;
        return new geoExtent(
          projection2.invert([pad2, _dimensions[1] - footerY - pad2]),
          projection2.invert([_dimensions[0] - pad2, headerY + pad2])
        );
      } else {
        var extent = geoExtent(val);
        map2.centerZoom(extent.center(), map2.trimmedExtentZoom(extent));
      }
    };
    function calcExtentZoom(extent, dim) {
      var tl = projection2([extent[0][0], extent[1][1]]);
      var br2 = projection2([extent[1][0], extent[0][1]]);
      var hFactor = (br2[0] - tl[0]) / dim[0];
      var vFactor = (br2[1] - tl[1]) / dim[1];
      var hZoomDiff = Math.log(Math.abs(hFactor)) / Math.LN2;
      var vZoomDiff = Math.log(Math.abs(vFactor)) / Math.LN2;
      var newZoom = map2.zoom() - Math.max(hZoomDiff, vZoomDiff);
      return newZoom;
    }
    map2.extentZoom = function(val) {
      return calcExtentZoom(geoExtent(val), _dimensions);
    };
    map2.trimmedExtentZoom = function(val) {
      var trimY = 120;
      var trimX = 40;
      var trimmed = [_dimensions[0] - trimX, _dimensions[1] - trimY];
      return calcExtentZoom(geoExtent(val), trimmed);
    };
    map2.withinEditableZoom = function() {
      return map2.zoom() >= context.minEditableZoom();
    };
    map2.isInWideSelection = function() {
      return !map2.withinEditableZoom() && context.selectedIDs().length;
    };
    map2.editableDataEnabled = function(skipZoomCheck) {
      var layer = context.layers().layer("osm");
      if (!layer || !layer.enabled())
        return false;
      return skipZoomCheck || map2.withinEditableZoom();
    };
    map2.notesEditable = function() {
      var layer = context.layers().layer("notes");
      if (!layer || !layer.enabled())
        return false;
      return map2.withinEditableZoom();
    };
    map2.minzoom = function(val) {
      if (!arguments.length)
        return _minzoom;
      _minzoom = val;
      return map2;
    };
    map2.toggleHighlightEdited = function() {
      surface.classed("highlight-edited", !surface.classed("highlight-edited"));
      map2.pan([0, 0]);
      dispatch14.call("changeHighlighting", this);
    };
    map2.areaFillOptions = ["wireframe", "partial", "full"];
    map2.activeAreaFill = function(val) {
      if (!arguments.length)
        return corePreferences("area-fill") || "partial";
      corePreferences("area-fill", val);
      if (val !== "wireframe") {
        corePreferences("area-fill-toggle", val);
      }
      updateAreaFill();
      map2.pan([0, 0]);
      dispatch14.call("changeAreaFill", this);
      return map2;
    };
    map2.toggleWireframe = function() {
      var activeFill = map2.activeAreaFill();
      if (activeFill === "wireframe") {
        activeFill = corePreferences("area-fill-toggle") || "partial";
      } else {
        activeFill = "wireframe";
      }
      map2.activeAreaFill(activeFill);
    };
    function updateAreaFill() {
      var activeFill = map2.activeAreaFill();
      map2.areaFillOptions.forEach(function(opt) {
        surface.classed("fill-" + opt, Boolean(opt === activeFill));
      });
    }
    map2.layers = () => drawLayers;
    map2.doubleUpHandler = function() {
      return _doubleUpHandler;
    };
    return utilRebind(map2, dispatch14, "on");
  }

  // modules/renderer/photos.js
  function rendererPhotos(context) {
    var dispatch14 = dispatch_default("change");
    var _layerIDs = ["streetside", "mapillary", "mapillary-map-features", "mapillary-signs", "kartaview", "mapilio", "vegbilder"];
    var _allPhotoTypes = ["flat", "panoramic"];
    var _shownPhotoTypes = _allPhotoTypes.slice();
    var _dateFilters = ["fromDate", "toDate"];
    var _fromDate;
    var _toDate;
    var _usernames;
    function photos() {
    }
    function updateStorage() {
      if (window.mocha)
        return;
      var hash = utilStringQs(window.location.hash);
      var enabled = context.layers().all().filter(function(d2) {
        return _layerIDs.indexOf(d2.id) !== -1 && d2.layer && d2.layer.supported() && d2.layer.enabled();
      }).map(function(d2) {
        return d2.id;
      });
      if (enabled.length) {
        hash.photo_overlay = enabled.join(",");
      } else {
        delete hash.photo_overlay;
      }
      window.location.replace("#" + utilQsString(hash, true));
    }
    photos.overlayLayerIDs = function() {
      return _layerIDs;
    };
    photos.allPhotoTypes = function() {
      return _allPhotoTypes;
    };
    photos.dateFilters = function() {
      return _dateFilters;
    };
    photos.dateFilterValue = function(val) {
      return val === _dateFilters[0] ? _fromDate : _toDate;
    };
    photos.setDateFilter = function(type2, val, updateUrl) {
      var date = val && new Date(val);
      if (date && !isNaN(date)) {
        val = date.toISOString().slice(0, 10);
      } else {
        val = null;
      }
      if (type2 === _dateFilters[0]) {
        _fromDate = val;
        if (_fromDate && _toDate && new Date(_toDate) < new Date(_fromDate)) {
          _toDate = _fromDate;
        }
      }
      if (type2 === _dateFilters[1]) {
        _toDate = val;
        if (_fromDate && _toDate && new Date(_toDate) < new Date(_fromDate)) {
          _fromDate = _toDate;
        }
      }
      dispatch14.call("change", this);
      if (updateUrl) {
        var rangeString;
        if (_fromDate || _toDate) {
          rangeString = (_fromDate || "") + "_" + (_toDate || "");
        }
        setUrlFilterValue("photo_dates", rangeString);
      }
    };
    photos.setUsernameFilter = function(val, updateUrl) {
      if (val && typeof val === "string")
        val = val.replace(/;/g, ",").split(",");
      if (val) {
        val = val.map((d2) => d2.trim()).filter(Boolean);
        if (!val.length) {
          val = null;
        }
      }
      _usernames = val;
      dispatch14.call("change", this);
      if (updateUrl) {
        var hashString;
        if (_usernames) {
          hashString = _usernames.join(",");
        }
        setUrlFilterValue("photo_username", hashString);
      }
    };
    function setUrlFilterValue(property, val) {
      if (!window.mocha) {
        var hash = utilStringQs(window.location.hash);
        if (val) {
          if (hash[property] === val)
            return;
          hash[property] = val;
        } else {
          if (!(property in hash))
            return;
          delete hash[property];
        }
        window.location.replace("#" + utilQsString(hash, true));
      }
    }
    function showsLayer(id2) {
      var layer = context.layers().layer(id2);
      return layer && layer.supported() && layer.enabled();
    }
    photos.shouldFilterByDate = function() {
      return showsLayer("mapillary") || showsLayer("kartaview") || showsLayer("streetside") || showsLayer("vegbilder");
    };
    photos.shouldFilterByPhotoType = function() {
      return showsLayer("mapillary") || showsLayer("streetside") && showsLayer("kartaview") || showsLayer("vegbilder");
    };
    photos.shouldFilterByUsername = function() {
      return !showsLayer("mapillary") && showsLayer("kartaview") && !showsLayer("streetside");
    };
    photos.showsPhotoType = function(val) {
      if (!photos.shouldFilterByPhotoType())
        return true;
      return _shownPhotoTypes.indexOf(val) !== -1;
    };
    photos.showsFlat = function() {
      return photos.showsPhotoType("flat");
    };
    photos.showsPanoramic = function() {
      return photos.showsPhotoType("panoramic");
    };
    photos.fromDate = function() {
      return _fromDate;
    };
    photos.toDate = function() {
      return _toDate;
    };
    photos.togglePhotoType = function(val) {
      var index = _shownPhotoTypes.indexOf(val);
      if (index !== -1) {
        _shownPhotoTypes.splice(index, 1);
      } else {
        _shownPhotoTypes.push(val);
      }
      dispatch14.call("change", this);
      return photos;
    };
    photos.usernames = function() {
      return _usernames;
    };
    photos.init = function() {
      var hash = utilStringQs(window.location.hash);
      if (hash.photo_dates) {
        var parts = /^(.*)[–_](.*)$/g.exec(hash.photo_dates.trim());
        this.setDateFilter("fromDate", parts && parts.length >= 2 && parts[1], false);
        this.setDateFilter("toDate", parts && parts.length >= 3 && parts[2], false);
      }
      if (hash.photo_username) {
        this.setUsernameFilter(hash.photo_username, false);
      }
      if (hash.photo_overlay) {
        var hashOverlayIDs = hash.photo_overlay.replace(/;/g, ",").split(",");
        hashOverlayIDs.forEach(function(id2) {
          if (id2 === "openstreetcam")
            id2 = "kartaview";
          var layer2 = _layerIDs.indexOf(id2) !== -1 && context.layers().layer(id2);
          if (layer2 && !layer2.enabled())
            layer2.enabled(true);
        });
      }
      if (hash.photo) {
        var photoIds = hash.photo.replace(/;/g, ",").split(",");
        var photoId = photoIds.length && photoIds[0].trim();
        var results = /(.*)\/(.*)/g.exec(photoId);
        if (results && results.length >= 3) {
          var serviceId = results[1];
          if (serviceId === "openstreetcam")
            serviceId = "kartaview";
          var photoKey = results[2];
          var service = services[serviceId];
          if (service && service.ensureViewerLoaded) {
            var layer = _layerIDs.indexOf(serviceId) !== -1 && context.layers().layer(serviceId);
            if (layer && !layer.enabled())
              layer.enabled(true);
            var baselineTime = Date.now();
            service.on("loadedImages.rendererPhotos", function() {
              if (Date.now() - baselineTime > 45e3) {
                service.on("loadedImages.rendererPhotos", null);
                return;
              }
              if (!service.cachedImage(photoKey))
                return;
              service.on("loadedImages.rendererPhotos", null);
              service.ensureViewerLoaded(context).then(function() {
                service.selectImage(context, photoKey).showViewer(context);
              });
            });
          }
        }
      }
      context.layers().on("change.rendererPhotos", updateStorage);
    };
    return utilRebind(photos, dispatch14, "on");
  }

  // modules/ui/account.js
  function uiAccount(context) {
    const osm = context.connection();
    function updateUserDetails(selection2) {
      if (!osm)
        return;
      if (!osm.authenticated()) {
        render(selection2, null);
      } else {
        osm.userDetails((err, user) => render(selection2, user));
      }
    }
    function render(selection2, user) {
      let userInfo = selection2.select(".userInfo");
      let loginLogout = selection2.select(".loginLogout");
      if (user) {
        userInfo.html("").classed("hide", false);
        let userLink = userInfo.append("a").attr("href", osm.userURL(user.display_name)).attr("target", "_blank");
        if (user.image_url) {
          userLink.append("img").attr("class", "icon pre-text user-icon").attr("src", user.image_url);
        } else {
          userLink.call(svgIcon("#iD-icon-avatar", "pre-text light"));
        }
        userLink.append("span").attr("class", "label").text(user.display_name);
        loginLogout.classed("hide", false).select("a").text(_t("logout")).on("click", (e3) => {
          e3.preventDefault();
          osm.logout();
          tryLogout();
        });
      } else {
        userInfo.html("").classed("hide", true);
        loginLogout.classed("hide", false).select("a").text(_t("login")).on("click", (e3) => {
          e3.preventDefault();
          osm.authenticate();
        });
      }
    }
    function tryLogout() {
      if (!osm)
        return;
      const url = osm.getUrlRoot() + "/logout?referer=%2Flogin";
      const w2 = 600;
      const h2 = 550;
      const settings = [
        ["width", w2],
        ["height", h2],
        ["left", window.screen.width / 2 - w2 / 2],
        ["top", window.screen.height / 2 - h2 / 2]
      ].map((x2) => x2.join("=")).join(",");
      window.open(url, "_blank", settings);
    }
    return function(selection2) {
      if (!osm)
        return;
      selection2.append("li").attr("class", "userInfo").classed("hide", true);
      selection2.append("li").attr("class", "loginLogout").classed("hide", true).append("a").attr("href", "#");
      osm.on("change.account", () => updateUserDetails(selection2));
      updateUserDetails(selection2);
    };
  }

  // modules/ui/attribution.js
  function uiAttribution(context) {
    let _selection = select_default2(null);
    function render(selection2, data, klass) {
      let div = selection2.selectAll(".".concat(klass)).data([0]);
      div = div.enter().append("div").attr("class", klass).merge(div);
      let attributions = div.selectAll(".attribution").data(data, (d2) => d2.id);
      attributions.exit().remove();
      attributions = attributions.enter().append("span").attr("class", "attribution").each((d2, i3, nodes) => {
        let attribution = select_default2(nodes[i3]);
        if (d2.terms_html) {
          attribution.html(d2.terms_html);
          return;
        }
        if (d2.terms_url) {
          attribution = attribution.append("a").attr("href", d2.terms_url).attr("target", "_blank");
        }
        const sourceID = d2.id.replace(/\./g, "<TX_DOT>");
        const terms_text = _t(
          "imagery.".concat(sourceID, ".attribution.text"),
          { default: d2.terms_text || d2.id || d2.name() }
        );
        if (d2.icon && !d2.overlay) {
          attribution.append("img").attr("class", "source-image").attr("src", d2.icon);
        }
        attribution.append("span").attr("class", "attribution-text").text(terms_text);
      }).merge(attributions);
      let copyright = attributions.selectAll(".copyright-notice").data((d2) => {
        let notice = d2.copyrightNotices(context.map().zoom(), context.map().extent());
        return notice ? [notice] : [];
      });
      copyright.exit().remove();
      copyright = copyright.enter().append("span").attr("class", "copyright-notice").merge(copyright);
      copyright.text(String);
    }
    function update() {
      let baselayer = context.background().baseLayerSource();
      _selection.call(render, baselayer ? [baselayer] : [], "base-layer-attribution");
      const z2 = context.map().zoom();
      let overlays = context.background().overlayLayerSources() || [];
      _selection.call(render, overlays.filter((s2) => s2.validZoom(z2)), "overlay-layer-attribution");
    }
    return function(selection2) {
      _selection = selection2;
      context.background().on("change.attribution", update);
      context.map().on("move.attribution", throttle_default(update, 400, { leading: false }));
      update();
    };
  }

  // modules/ui/contributors.js
  function uiContributors(context) {
    var osm = context.connection(), debouncedUpdate = debounce_default(function() {
      update();
    }, 1e3), limit = 4, hidden = false, wrap2 = select_default2(null);
    function update() {
      if (!osm)
        return;
      var users = {}, entities = context.history().intersects(context.map().extent());
      entities.forEach(function(entity) {
        if (entity && entity.user)
          users[entity.user] = true;
      });
      var u2 = Object.keys(users), subset = u2.slice(0, u2.length > limit ? limit - 1 : limit);
      wrap2.html("").call(svgIcon("#iD-icon-nearby", "pre-text light"));
      var userList = select_default2(document.createElement("span"));
      userList.selectAll().data(subset).enter().append("a").attr("class", "user-link").attr("href", function(d2) {
        return osm.userURL(d2);
      }).attr("target", "_blank").text(String);
      if (u2.length > limit) {
        var count = select_default2(document.createElement("span"));
        var othersNum = u2.length - limit + 1;
        count.append("a").attr("target", "_blank").attr("href", function() {
          return osm.changesetsURL(context.map().center(), context.map().zoom());
        }).text(othersNum);
        wrap2.append("span").html(_t.html("contributors.truncated_list", { n: othersNum, users: { html: userList.html() }, count: { html: count.html() } }));
      } else {
        wrap2.append("span").html(_t.html("contributors.list", { users: { html: userList.html() } }));
      }
      if (!u2.length) {
        hidden = true;
        wrap2.transition().style("opacity", 0);
      } else if (hidden) {
        wrap2.transition().style("opacity", 1);
      }
    }
    return function(selection2) {
      if (!osm)
        return;
      wrap2 = selection2;
      update();
      osm.on("loaded.contributors", debouncedUpdate);
      context.map().on("move.contributors", debouncedUpdate);
    };
  }

  // modules/ui/popover.js
  var _popoverID = 0;
  function uiPopover(klass) {
    var _id = _popoverID++;
    var _anchorSelection = select_default2(null);
    var popover = function(selection2) {
      _anchorSelection = selection2;
      selection2.each(setup);
    };
    var _animation = utilFunctor(false);
    var _placement = utilFunctor("top");
    var _alignment = utilFunctor("center");
    var _scrollContainer = utilFunctor(select_default2(null));
    var _content;
    var _displayType = utilFunctor("");
    var _hasArrow = utilFunctor(true);
    var _pointerPrefix = "PointerEvent" in window ? "pointer" : "mouse";
    popover.displayType = function(val) {
      if (arguments.length) {
        _displayType = utilFunctor(val);
        return popover;
      } else {
        return _displayType;
      }
    };
    popover.hasArrow = function(val) {
      if (arguments.length) {
        _hasArrow = utilFunctor(val);
        return popover;
      } else {
        return _hasArrow;
      }
    };
    popover.placement = function(val) {
      if (arguments.length) {
        _placement = utilFunctor(val);
        return popover;
      } else {
        return _placement;
      }
    };
    popover.alignment = function(val) {
      if (arguments.length) {
        _alignment = utilFunctor(val);
        return popover;
      } else {
        return _alignment;
      }
    };
    popover.scrollContainer = function(val) {
      if (arguments.length) {
        _scrollContainer = utilFunctor(val);
        return popover;
      } else {
        return _scrollContainer;
      }
    };
    popover.content = function(val) {
      if (arguments.length) {
        _content = val;
        return popover;
      } else {
        return _content;
      }
    };
    popover.isShown = function() {
      var popoverSelection = _anchorSelection.select(".popover-" + _id);
      return !popoverSelection.empty() && popoverSelection.classed("in");
    };
    popover.show = function() {
      _anchorSelection.each(show);
    };
    popover.updateContent = function() {
      _anchorSelection.each(updateContent);
    };
    popover.hide = function() {
      _anchorSelection.each(hide);
    };
    popover.toggle = function() {
      _anchorSelection.each(toggle);
    };
    popover.destroy = function(selection2, selector) {
      selector = selector || ".popover-" + _id;
      selection2.on(_pointerPrefix + "enter.popover", null).on(_pointerPrefix + "leave.popover", null).on(_pointerPrefix + "up.popover", null).on(_pointerPrefix + "down.popover", null).on("click.popover", null).attr("title", function() {
        return this.getAttribute("data-original-title") || this.getAttribute("title");
      }).attr("data-original-title", null).selectAll(selector).remove();
    };
    popover.destroyAny = function(selection2) {
      selection2.call(popover.destroy, ".popover");
    };
    function setup() {
      var anchor = select_default2(this);
      var animate = _animation.apply(this, arguments);
      var popoverSelection = anchor.selectAll(".popover-" + _id).data([0]);
      var enter = popoverSelection.enter().append("div").attr("class", "popover popover-" + _id + " " + (klass ? klass : "")).classed("arrowed", _hasArrow.apply(this, arguments));
      enter.append("div").attr("class", "popover-arrow");
      enter.append("div").attr("class", "popover-inner");
      popoverSelection = enter.merge(popoverSelection);
      if (animate) {
        popoverSelection.classed("fade", true);
      }
      var display = _displayType.apply(this, arguments);
      if (display === "hover") {
        var _lastNonMouseEnterTime;
        anchor.on(_pointerPrefix + "enter.popover", function(d3_event) {
          if (d3_event.pointerType) {
            if (d3_event.pointerType !== "mouse") {
              _lastNonMouseEnterTime = d3_event.timeStamp;
              return;
            } else if (_lastNonMouseEnterTime && d3_event.timeStamp - _lastNonMouseEnterTime < 1500) {
              return;
            }
          }
          if (d3_event.buttons !== 0)
            return;
          show.apply(this, arguments);
        }).on(_pointerPrefix + "leave.popover", function() {
          hide.apply(this, arguments);
        }).on("focus.popover", function() {
          show.apply(this, arguments);
        }).on("blur.popover", function() {
          hide.apply(this, arguments);
        });
      } else if (display === "clickFocus") {
        anchor.on(_pointerPrefix + "down.popover", function(d3_event) {
          d3_event.preventDefault();
          d3_event.stopPropagation();
        }).on(_pointerPrefix + "up.popover", function(d3_event) {
          d3_event.preventDefault();
          d3_event.stopPropagation();
        }).on("click.popover", toggle);
        popoverSelection.attr("tabindex", 0).on("blur.popover", function() {
          anchor.each(function() {
            hide.apply(this, arguments);
          });
        });
      }
    }
    function show() {
      var anchor = select_default2(this);
      var popoverSelection = anchor.selectAll(".popover-" + _id);
      if (popoverSelection.empty()) {
        anchor.call(popover.destroy);
        anchor.each(setup);
        popoverSelection = anchor.selectAll(".popover-" + _id);
      }
      popoverSelection.classed("in", true);
      var displayType = _displayType.apply(this, arguments);
      if (displayType === "clickFocus") {
        anchor.classed("active", true);
        popoverSelection.node().focus();
      }
      anchor.each(updateContent);
    }
    function updateContent() {
      var anchor = select_default2(this);
      if (_content) {
        anchor.selectAll(".popover-" + _id + " > .popover-inner").call(_content.apply(this, arguments));
      }
      updatePosition.apply(this, arguments);
      updatePosition.apply(this, arguments);
      updatePosition.apply(this, arguments);
    }
    function updatePosition() {
      var anchor = select_default2(this);
      var popoverSelection = anchor.selectAll(".popover-" + _id);
      var scrollContainer = _scrollContainer && _scrollContainer.apply(this, arguments);
      var scrollNode = scrollContainer && !scrollContainer.empty() && scrollContainer.node();
      var scrollLeft = scrollNode ? scrollNode.scrollLeft : 0;
      var scrollTop = scrollNode ? scrollNode.scrollTop : 0;
      var placement = _placement.apply(this, arguments);
      popoverSelection.classed("left", false).classed("right", false).classed("top", false).classed("bottom", false).classed(placement, true);
      var alignment = _alignment.apply(this, arguments);
      var alignFactor = 0.5;
      if (alignment === "leading") {
        alignFactor = 0;
      } else if (alignment === "trailing") {
        alignFactor = 1;
      }
      var anchorFrame = getFrame(anchor.node());
      var popoverFrame = getFrame(popoverSelection.node());
      var position;
      switch (placement) {
        case "top":
          position = {
            x: anchorFrame.x + (anchorFrame.w - popoverFrame.w) * alignFactor,
            y: anchorFrame.y - popoverFrame.h
          };
          break;
        case "bottom":
          position = {
            x: anchorFrame.x + (anchorFrame.w - popoverFrame.w) * alignFactor,
            y: anchorFrame.y + anchorFrame.h
          };
          break;
        case "left":
          position = {
            x: anchorFrame.x - popoverFrame.w,
            y: anchorFrame.y + (anchorFrame.h - popoverFrame.h) * alignFactor
          };
          break;
        case "right":
          position = {
            x: anchorFrame.x + anchorFrame.w,
            y: anchorFrame.y + (anchorFrame.h - popoverFrame.h) * alignFactor
          };
          break;
      }
      if (position) {
        if (scrollNode && (placement === "top" || placement === "bottom")) {
          var initialPosX = position.x;
          if (position.x + popoverFrame.w > scrollNode.offsetWidth - 10) {
            position.x = scrollNode.offsetWidth - 10 - popoverFrame.w;
          } else if (position.x < 10) {
            position.x = 10;
          }
          var arrow = anchor.selectAll(".popover-" + _id + " > .popover-arrow");
          var arrowPosX = Math.min(Math.max(popoverFrame.w / 2 - (position.x - initialPosX), 10), popoverFrame.w - 10);
          arrow.style("left", ~~arrowPosX + "px");
        }
        popoverSelection.style("left", ~~position.x + "px").style("top", ~~position.y + "px");
      } else {
        popoverSelection.style("left", null).style("top", null);
      }
      function getFrame(node) {
        var positionStyle = select_default2(node).style("position");
        if (positionStyle === "absolute" || positionStyle === "static") {
          return {
            x: node.offsetLeft - scrollLeft,
            y: node.offsetTop - scrollTop,
            w: node.offsetWidth,
            h: node.offsetHeight
          };
        } else {
          return {
            x: 0,
            y: 0,
            w: node.offsetWidth,
            h: node.offsetHeight
          };
        }
      }
    }
    function hide() {
      var anchor = select_default2(this);
      if (_displayType.apply(this, arguments) === "clickFocus") {
        anchor.classed("active", false);
      }
      anchor.selectAll(".popover-" + _id).classed("in", false);
    }
    function toggle() {
      if (select_default2(this).select(".popover-" + _id).classed("in")) {
        hide.apply(this, arguments);
      } else {
        show.apply(this, arguments);
      }
    }
    return popover;
  }

  // modules/ui/tooltip.js
  function uiTooltip(klass) {
    var tooltip = uiPopover((klass || "") + " tooltip").displayType("hover");
    var _title = function() {
      var title = this.getAttribute("data-original-title");
      if (title) {
        return title;
      } else {
        title = this.getAttribute("title");
        this.removeAttribute("title");
        this.setAttribute("data-original-title", title);
      }
      return title;
    };
    var _heading = utilFunctor(null);
    var _keys = utilFunctor(null);
    tooltip.title = function(val) {
      if (!arguments.length)
        return _title;
      _title = utilFunctor(val);
      return tooltip;
    };
    tooltip.heading = function(val) {
      if (!arguments.length)
        return _heading;
      _heading = utilFunctor(val);
      return tooltip;
    };
    tooltip.keys = function(val) {
      if (!arguments.length)
        return _keys;
      _keys = utilFunctor(val);
      return tooltip;
    };
    tooltip.content(function() {
      var heading2 = _heading.apply(this, arguments);
      var text = _title.apply(this, arguments);
      var keys2 = _keys.apply(this, arguments);
      var headingCallback = typeof heading2 === "function" ? heading2 : (s2) => s2.text(heading2);
      var textCallback = typeof text === "function" ? text : (s2) => s2.text(text);
      return function(selection2) {
        var headingSelect = selection2.selectAll(".tooltip-heading").data(heading2 ? [heading2] : []);
        headingSelect.exit().remove();
        headingSelect.enter().append("div").attr("class", "tooltip-heading").merge(headingSelect).text("").call(headingCallback);
        var textSelect = selection2.selectAll(".tooltip-text").data(text ? [text] : []);
        textSelect.exit().remove();
        textSelect.enter().append("div").attr("class", "tooltip-text").merge(textSelect).text("").call(textCallback);
        var keyhintWrap = selection2.selectAll(".keyhint-wrap").data(keys2 && keys2.length ? [0] : []);
        keyhintWrap.exit().remove();
        var keyhintWrapEnter = keyhintWrap.enter().append("div").attr("class", "keyhint-wrap");
        keyhintWrapEnter.append("span").call(_t.append("tooltip_keyhint"));
        keyhintWrap = keyhintWrapEnter.merge(keyhintWrap);
        keyhintWrap.selectAll("kbd.shortcut").data(keys2 && keys2.length ? keys2 : []).enter().append("kbd").attr("class", "shortcut").text(function(d2) {
          return d2;
        });
      };
    });
    return tooltip;
  }

  // modules/ui/edit_menu.js
  function uiEditMenu(context) {
    var dispatch14 = dispatch_default("toggled");
    var _menu = select_default2(null);
    var _operations = [];
    var _anchorLoc = [0, 0];
    var _anchorLocLonLat = [0, 0];
    var _triggerType = "";
    var _vpTopMargin = 85;
    var _vpBottomMargin = 45;
    var _vpSideMargin = 35;
    var _menuTop = false;
    var _menuHeight;
    var _menuWidth;
    var _verticalPadding = 4;
    var _tooltipWidth = 210;
    var _menuSideMargin = 10;
    var _tooltips = [];
    var editMenu = function(selection2) {
      var isTouchMenu = _triggerType.includes("touch") || _triggerType.includes("pen");
      var ops = _operations.filter(function(op) {
        return !isTouchMenu || !op.mouseOnly;
      });
      if (!ops.length)
        return;
      _tooltips = [];
      _menuTop = isTouchMenu;
      var showLabels = isTouchMenu;
      var buttonHeight = showLabels ? 32 : 34;
      if (showLabels) {
        _menuWidth = 52 + Math.min(120, 6 * Math.max.apply(Math, ops.map(function(op) {
          return op.title.length;
        })));
      } else {
        _menuWidth = 44;
      }
      _menuHeight = _verticalPadding * 2 + ops.length * buttonHeight;
      _menu = selection2.append("div").attr("class", "edit-menu").classed("touch-menu", isTouchMenu).style("padding", _verticalPadding + "px 0");
      var buttons = _menu.selectAll(".edit-menu-item").data(ops);
      var buttonsEnter = buttons.enter().append("button").attr("class", function(d2) {
        return "edit-menu-item edit-menu-item-" + d2.id;
      }).style("height", buttonHeight + "px").on("click", click).on("pointerup", pointerup).on("pointerdown mousedown", function pointerdown(d3_event) {
        d3_event.stopPropagation();
      }).on("mouseenter.highlight", function(d3_event, d2) {
        if (!d2.relatedEntityIds || select_default2(this).classed("disabled"))
          return;
        utilHighlightEntities(d2.relatedEntityIds(), true, context);
      }).on("mouseleave.highlight", function(d3_event, d2) {
        if (!d2.relatedEntityIds)
          return;
        utilHighlightEntities(d2.relatedEntityIds(), false, context);
      });
      buttonsEnter.each(function(d2) {
        var tooltip = uiTooltip().heading(() => d2.title).title(d2.tooltip).keys([d2.keys[0]]);
        _tooltips.push(tooltip);
        select_default2(this).call(tooltip).append("div").attr("class", "icon-wrap").call(svgIcon(d2.icon && d2.icon() || "#iD-operation-" + d2.id, "operation"));
      });
      if (showLabels) {
        buttonsEnter.append("span").attr("class", "label").each(function(d2) {
          select_default2(this).call(d2.title);
        });
      }
      buttonsEnter.merge(buttons).classed("disabled", function(d2) {
        return d2.disabled();
      });
      updatePosition();
      var initialScale = context.projection.scale();
      context.map().on("move.edit-menu", function() {
        if (initialScale !== context.projection.scale()) {
          editMenu.close();
        }
      }).on("drawn.edit-menu", function(info) {
        if (info.full)
          updatePosition();
      });
      var lastPointerUpType;
      function pointerup(d3_event) {
        lastPointerUpType = d3_event.pointerType;
      }
      function click(d3_event, operation2) {
        d3_event.stopPropagation();
        if (operation2.relatedEntityIds) {
          utilHighlightEntities(operation2.relatedEntityIds(), false, context);
        }
        if (operation2.disabled()) {
          if (lastPointerUpType === "touch" || lastPointerUpType === "pen") {
            context.ui().flash.duration(4e3).iconName("#iD-operation-" + operation2.id).iconClass("operation disabled").label(operation2.tooltip())();
          }
        } else {
          if (lastPointerUpType === "touch" || lastPointerUpType === "pen") {
            context.ui().flash.duration(2e3).iconName("#iD-operation-" + operation2.id).iconClass("operation").label(operation2.annotation() || operation2.title)();
          }
          operation2();
          editMenu.close();
        }
        lastPointerUpType = null;
      }
      dispatch14.call("toggled", this, true);
    };
    function updatePosition() {
      if (!_menu || _menu.empty())
        return;
      var anchorLoc = context.projection(_anchorLocLonLat);
      var viewport = context.surfaceRect();
      if (anchorLoc[0] < 0 || anchorLoc[0] > viewport.width || anchorLoc[1] < 0 || anchorLoc[1] > viewport.height) {
        editMenu.close();
        return;
      }
      var menuLeft = displayOnLeft(viewport);
      var offset = [0, 0];
      offset[0] = menuLeft ? -1 * (_menuSideMargin + _menuWidth) : _menuSideMargin;
      if (_menuTop) {
        if (anchorLoc[1] - _menuHeight < _vpTopMargin) {
          offset[1] = -anchorLoc[1] + _vpTopMargin;
        } else {
          offset[1] = -_menuHeight;
        }
      } else {
        if (anchorLoc[1] + _menuHeight > viewport.height - _vpBottomMargin) {
          offset[1] = -anchorLoc[1] - _menuHeight + viewport.height - _vpBottomMargin;
        } else {
          offset[1] = 0;
        }
      }
      var origin = geoVecAdd(anchorLoc, offset);
      _menu.style("left", origin[0] + "px").style("top", origin[1] + "px");
      var tooltipSide = tooltipPosition(viewport, menuLeft);
      _tooltips.forEach(function(tooltip) {
        tooltip.placement(tooltipSide);
      });
      function displayOnLeft(viewport2) {
        if (_mainLocalizer.textDirection() === "ltr") {
          if (anchorLoc[0] + _menuSideMargin + _menuWidth > viewport2.width - _vpSideMargin) {
            return true;
          }
          return false;
        } else {
          if (anchorLoc[0] - _menuSideMargin - _menuWidth < _vpSideMargin) {
            return false;
          }
          return true;
        }
      }
      function tooltipPosition(viewport2, menuLeft2) {
        if (_mainLocalizer.textDirection() === "ltr") {
          if (menuLeft2) {
            return "left";
          }
          if (anchorLoc[0] + _menuSideMargin + _menuWidth + _tooltipWidth > viewport2.width - _vpSideMargin) {
            return "left";
          }
          return "right";
        } else {
          if (!menuLeft2) {
            return "right";
          }
          if (anchorLoc[0] - _menuSideMargin - _menuWidth - _tooltipWidth < _vpSideMargin) {
            return "right";
          }
          return "left";
        }
      }
    }
    editMenu.close = function() {
      context.map().on("move.edit-menu", null).on("drawn.edit-menu", null);
      _menu.remove();
      _tooltips = [];
      dispatch14.call("toggled", this, false);
    };
    editMenu.anchorLoc = function(val) {
      if (!arguments.length)
        return _anchorLoc;
      _anchorLoc = val;
      _anchorLocLonLat = context.projection.invert(_anchorLoc);
      return editMenu;
    };
    editMenu.triggerType = function(val) {
      if (!arguments.length)
        return _triggerType;
      _triggerType = val;
      return editMenu;
    };
    editMenu.operations = function(val) {
      if (!arguments.length)
        return _operations;
      _operations = val;
      return editMenu;
    };
    return utilRebind(editMenu, dispatch14, "on");
  }

  // modules/ui/feature_info.js
  function uiFeatureInfo(context) {
    function update(selection2) {
      var features = context.features();
      var stats = features.stats();
      var count = 0;
      var hiddenList = features.hidden().map(function(k2) {
        if (stats[k2]) {
          count += stats[k2];
          return _t.append("inspector.title_count", {
            title: _t("feature." + k2 + ".description"),
            count: stats[k2]
          });
        }
        return null;
      }).filter(Boolean);
      selection2.text("");
      if (hiddenList.length) {
        var tooltipBehavior = uiTooltip().placement("top").title(function() {
          return (selection3) => {
            hiddenList.forEach((hiddenFeature) => {
              selection3.append("div").call(hiddenFeature);
            });
          };
        });
        selection2.append("a").attr("class", "chip").attr("href", "#").call(_t.append("feature_info.hidden_warning", { count })).call(tooltipBehavior).on("click", function(d3_event) {
          tooltipBehavior.hide();
          d3_event.preventDefault();
          context.ui().togglePanes(context.container().select(".map-panes .map-data-pane"));
        });
      }
      selection2.classed("hide", !hiddenList.length);
    }
    return function(selection2) {
      update(selection2);
      context.features().on("change.feature_info", function() {
        update(selection2);
      });
    };
  }

  // modules/ui/flash.js
  function uiFlash(context) {
    var _flashTimer;
    var _duration = 2e3;
    var _iconName = "#iD-icon-no";
    var _iconClass = "disabled";
    var _label = (s2) => s2.text("");
    function flash() {
      if (_flashTimer) {
        _flashTimer.stop();
      }
      context.container().select(".main-footer-wrap").classed("footer-hide", true).classed("footer-show", false);
      context.container().select(".flash-wrap").classed("footer-hide", false).classed("footer-show", true);
      var content = context.container().select(".flash-wrap").selectAll(".flash-content").data([0]);
      var contentEnter = content.enter().append("div").attr("class", "flash-content");
      var iconEnter = contentEnter.append("svg").attr("class", "flash-icon icon").append("g").attr("transform", "translate(10,10)");
      iconEnter.append("circle").attr("r", 9);
      iconEnter.append("use").attr("transform", "translate(-7,-7)").attr("width", "14").attr("height", "14");
      contentEnter.append("div").attr("class", "flash-text");
      content = content.merge(contentEnter);
      content.selectAll(".flash-icon").attr("class", "icon flash-icon " + (_iconClass || ""));
      content.selectAll(".flash-icon use").attr("xlink:href", _iconName);
      content.selectAll(".flash-text").attr("class", "flash-text").call(_label);
      _flashTimer = timeout_default(function() {
        _flashTimer = null;
        context.container().select(".main-footer-wrap").classed("footer-hide", false).classed("footer-show", true);
        context.container().select(".flash-wrap").classed("footer-hide", true).classed("footer-show", false);
      }, _duration);
      return content;
    }
    flash.duration = function(_2) {
      if (!arguments.length)
        return _duration;
      _duration = _2;
      return flash;
    };
    flash.label = function(_2) {
      if (!arguments.length)
        return _label;
      if (typeof _2 !== "function") {
        _label = (selection2) => selection2.text(_2);
      } else {
        _label = (selection2) => selection2.text("").call(_2);
      }
      return flash;
    };
    flash.iconName = function(_2) {
      if (!arguments.length)
        return _iconName;
      _iconName = _2;
      return flash;
    };
    flash.iconClass = function(_2) {
      if (!arguments.length)
        return _iconClass;
      _iconClass = _2;
      return flash;
    };
    return flash;
  }

  // modules/ui/full_screen.js
  function uiFullScreen(context) {
    var element = context.container().node();
    function getFullScreenFn() {
      if (element.requestFullscreen) {
        return element.requestFullscreen;
      } else if (element.msRequestFullscreen) {
        return element.msRequestFullscreen;
      } else if (element.mozRequestFullScreen) {
        return element.mozRequestFullScreen;
      } else if (element.webkitRequestFullscreen) {
        return element.webkitRequestFullscreen;
      }
    }
    function getExitFullScreenFn() {
      if (document.exitFullscreen) {
        return document.exitFullscreen;
      } else if (document.msExitFullscreen) {
        return document.msExitFullscreen;
      } else if (document.mozCancelFullScreen) {
        return document.mozCancelFullScreen;
      } else if (document.webkitExitFullscreen) {
        return document.webkitExitFullscreen;
      }
    }
    function isFullScreen() {
      return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
    }
    function isSupported() {
      return !!getFullScreenFn();
    }
    function fullScreen(d3_event) {
      d3_event.preventDefault();
      if (!isFullScreen()) {
        getFullScreenFn().apply(element);
      } else {
        getExitFullScreenFn().apply(document);
      }
    }
    return function() {
      if (!isSupported())
        return;
      var detected = utilDetect();
      var keys2 = detected.os === "mac" ? [uiCmd("\u2303\u2318F"), "f11"] : ["f11"];
      context.keybinding().on(keys2, fullScreen);
    };
  }

  // modules/ui/geolocate.js
  function uiGeolocate(context) {
    var _geolocationOptions = {
      // prioritize speed and power usage over precision
      enableHighAccuracy: false,
      // don't hang indefinitely getting the location
      timeout: 6e3
      // 6sec
    };
    var _locating = uiLoading(context).message(_t.html("geolocate.locating")).blocking(true);
    var _layer = context.layers().layer("geolocate");
    var _position;
    var _extent;
    var _timeoutID;
    var _button = select_default2(null);
    function click() {
      if (context.inIntro())
        return;
      if (!_layer.enabled() && !_locating.isShown()) {
        _timeoutID = setTimeout(
          error,
          1e4
          /* 10sec */
        );
        context.container().call(_locating);
        navigator.geolocation.getCurrentPosition(success, error, _geolocationOptions);
      } else {
        _locating.close();
        _layer.enabled(null, false);
        updateButtonState();
      }
    }
    function zoomTo() {
      context.enter(modeBrowse(context));
      var map2 = context.map();
      _layer.enabled(_position, true);
      updateButtonState();
      map2.centerZoomEase(_extent.center(), Math.min(20, map2.extentZoom(_extent)));
    }
    function success(geolocation) {
      _position = geolocation;
      var coords = _position.coords;
      _extent = geoExtent([coords.longitude, coords.latitude]).padByMeters(coords.accuracy);
      zoomTo();
      finish();
    }
    function error() {
      if (_position) {
        zoomTo();
      } else {
        context.ui().flash.label(_t.append("geolocate.location_unavailable")).iconName("#iD-icon-geolocate")();
      }
      finish();
    }
    function finish() {
      _locating.close();
      if (_timeoutID) {
        clearTimeout(_timeoutID);
      }
      _timeoutID = void 0;
    }
    function updateButtonState() {
      _button.classed("active", _layer.enabled());
      _button.attr("aria-pressed", _layer.enabled());
    }
    return function(selection2) {
      if (!navigator.geolocation || !navigator.geolocation.getCurrentPosition)
        return;
      _button = selection2.append("button").on("click", click).attr("aria-pressed", false).call(svgIcon("#iD-icon-geolocate", "light")).call(
        uiTooltip().placement(_mainLocalizer.textDirection() === "rtl" ? "right" : "left").title(() => _t.append("geolocate.title")).keys([_t("geolocate.key")])
      );
      context.keybinding().on(_t("geolocate.key"), click);
    };
  }

  // modules/ui/panels/background.js
  function uiPanelBackground(context) {
    var background = context.background();
    var _currSourceName = null;
    var _metadata = {};
    var _metadataKeys = [
      "zoom",
      "vintage",
      "source",
      "description",
      "resolution",
      "accuracy"
    ];
    var debouncedRedraw = debounce_default(redraw, 250);
    function redraw(selection2) {
      var source = background.baseLayerSource();
      if (!source)
        return;
      var isDG = source.id.match(/^DigitalGlobe/i) !== null;
      var sourceLabel = source.label();
      if (_currSourceName !== sourceLabel) {
        _currSourceName = sourceLabel;
        _metadata = {};
      }
      selection2.text("");
      var list2 = selection2.append("ul").attr("class", "background-info");
      list2.append("li").call(_currSourceName);
      _metadataKeys.forEach(function(k2) {
        if (isDG && k2 === "vintage")
          return;
        list2.append("li").attr("class", "background-info-list-" + k2).classed("hide", !_metadata[k2]).call(_t.append("info_panels.background." + k2, { suffix: ":" })).append("span").attr("class", "background-info-span-" + k2).text(_metadata[k2]);
      });
      debouncedGetMetadata(selection2);
      var toggleTiles = context.getDebug("tile") ? "hide_tiles" : "show_tiles";
      selection2.append("a").call(_t.append("info_panels.background." + toggleTiles)).attr("href", "#").attr("class", "button button-toggle-tiles").on("click", function(d3_event) {
        d3_event.preventDefault();
        context.setDebug("tile", !context.getDebug("tile"));
        selection2.call(redraw);
      });
      if (isDG) {
        var key = source.id + "-vintage";
        var sourceVintage = context.background().findSource(key);
        var showsVintage = context.background().showsLayer(sourceVintage);
        var toggleVintage = showsVintage ? "hide_vintage" : "show_vintage";
        selection2.append("a").call(_t.append("info_panels.background." + toggleVintage)).attr("href", "#").attr("class", "button button-toggle-vintage").on("click", function(d3_event) {
          d3_event.preventDefault();
          context.background().toggleOverlayLayer(sourceVintage);
          selection2.call(redraw);
        });
      }
      ["DigitalGlobe-Premium", "DigitalGlobe-Standard"].forEach(function(layerId) {
        if (source.id !== layerId) {
          var key2 = layerId + "-vintage";
          var sourceVintage2 = context.background().findSource(key2);
          if (context.background().showsLayer(sourceVintage2)) {
            context.background().toggleOverlayLayer(sourceVintage2);
          }
        }
      });
    }
    var debouncedGetMetadata = debounce_default(getMetadata, 250);
    function getMetadata(selection2) {
      var tile = context.container().select(".layer-background img.tile-center");
      if (tile.empty())
        return;
      var sourceName = _currSourceName;
      var d2 = tile.datum();
      var zoom = d2 && d2.length >= 3 && d2[2] || Math.floor(context.map().zoom());
      var center = context.map().center();
      _metadata.zoom = String(zoom);
      selection2.selectAll(".background-info-list-zoom").classed("hide", false).selectAll(".background-info-span-zoom").text(_metadata.zoom);
      if (!d2 || !d2.length >= 3)
        return;
      background.baseLayerSource().getMetadata(center, d2, function(err, result) {
        if (err || _currSourceName !== sourceName)
          return;
        var vintage = result.vintage;
        _metadata.vintage = vintage && vintage.range || _t("info_panels.background.unknown");
        selection2.selectAll(".background-info-list-vintage").classed("hide", false).selectAll(".background-info-span-vintage").text(_metadata.vintage);
        _metadataKeys.forEach(function(k2) {
          if (k2 === "zoom" || k2 === "vintage")
            return;
          var val = result[k2];
          _metadata[k2] = val;
          selection2.selectAll(".background-info-list-" + k2).classed("hide", !val).selectAll(".background-info-span-" + k2).text(val);
        });
      });
    }
    var panel = function(selection2) {
      selection2.call(redraw);
      context.map().on("drawn.info-background", function() {
        selection2.call(debouncedRedraw);
      }).on("move.info-background", function() {
        selection2.call(debouncedGetMetadata);
      });
    };
    panel.off = function() {
      context.map().on("drawn.info-background", null).on("move.info-background", null);
    };
    panel.id = "background";
    panel.label = _t.append("info_panels.background.title");
    panel.key = _t("info_panels.background.key");
    return panel;
  }

  // modules/ui/panels/history.js
  function uiPanelHistory(context) {
    var osm;
    function displayTimestamp(timestamp) {
      if (!timestamp)
        return _t("info_panels.history.unknown");
      var options2 = {
        day: "numeric",
        month: "short",
        year: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric"
      };
      var d2 = new Date(timestamp);
      if (isNaN(d2.getTime()))
        return _t("info_panels.history.unknown");
      return d2.toLocaleString(_mainLocalizer.localeCode(), options2);
    }
    function displayUser(selection2, userName) {
      if (!userName) {
        selection2.append("span").call(_t.append("info_panels.history.unknown"));
        return;
      }
      selection2.append("span").attr("class", "user-name").text(userName);
      var links = selection2.append("div").attr("class", "links");
      if (osm) {
        links.append("a").attr("class", "user-osm-link").attr("href", osm.userURL(userName)).attr("target", "_blank").call(_t.append("info_panels.history.profile_link"));
      }
      links.append("a").attr("class", "user-hdyc-link").attr("href", "https://hdyc.neis-one.org/?" + userName).attr("target", "_blank").attr("tabindex", -1).text("HDYC");
    }
    function displayChangeset(selection2, changeset) {
      if (!changeset) {
        selection2.append("span").call(_t.append("info_panels.history.unknown"));
        return;
      }
      selection2.append("span").attr("class", "changeset-id").text(changeset);
      var links = selection2.append("div").attr("class", "links");
      if (osm) {
        links.append("a").attr("class", "changeset-osm-link").attr("href", osm.changesetURL(changeset)).attr("target", "_blank").call(_t.append("info_panels.history.changeset_link"));
      }
      links.append("a").attr("class", "changeset-osmcha-link").attr("href", "https://osmcha.org/changesets/" + changeset).attr("target", "_blank").text("OSMCha");
      links.append("a").attr("class", "changeset-achavi-link").attr("href", "https://overpass-api.de/achavi/?changeset=" + changeset).attr("target", "_blank").text("Achavi");
    }
    function redraw(selection2) {
      var selectedNoteID = context.selectedNoteID();
      osm = context.connection();
      var selected, note, entity;
      if (selectedNoteID && osm) {
        selected = [_t.html("note.note") + " " + selectedNoteID];
        note = osm.getNote(selectedNoteID);
      } else {
        selected = context.selectedIDs().filter(function(e3) {
          return context.hasEntity(e3);
        });
        if (selected.length) {
          entity = context.entity(selected[0]);
        }
      }
      var singular = selected.length === 1 ? selected[0] : null;
      selection2.html("");
      if (singular) {
        selection2.append("h4").attr("class", "history-heading").html(singular);
      } else {
        selection2.append("h4").attr("class", "history-heading").call(_t.append("info_panels.selected", { n: selected.length }));
      }
      if (!singular)
        return;
      if (entity) {
        selection2.call(redrawEntity, entity);
      } else if (note) {
        selection2.call(redrawNote, note);
      }
    }
    function redrawNote(selection2, note) {
      if (!note || note.isNew()) {
        selection2.append("div").call(_t.append("info_panels.history.note_no_history"));
        return;
      }
      var list2 = selection2.append("ul");
      list2.append("li").call(_t.append("info_panels.history.note_comments", { suffix: ":" })).append("span").text(note.comments.length);
      if (note.comments.length) {
        list2.append("li").call(_t.append("info_panels.history.note_created_date", { suffix: ":" })).append("span").text(displayTimestamp(note.comments[0].date));
        list2.append("li").call(_t.append("info_panels.history.note_created_user", { suffix: ":" })).call(displayUser, note.comments[0].user);
      }
      if (osm) {
        selection2.append("a").attr("class", "view-history-on-osm").attr("target", "_blank").attr("href", osm.noteURL(note)).call(svgIcon("#iD-icon-out-link", "inline")).append("span").call(_t.append("info_panels.history.note_link_text"));
      }
    }
    function redrawEntity(selection2, entity) {
      if (!entity || entity.isNew()) {
        selection2.append("div").call(_t.append("info_panels.history.no_history"));
        return;
      }
      var links = selection2.append("div").attr("class", "links");
      if (osm) {
        links.append("a").attr("class", "view-history-on-osm").attr("href", osm.historyURL(entity)).attr("target", "_blank").call(_t.append("info_panels.history.history_link"));
      }
      links.append("a").attr("class", "pewu-history-viewer-link").attr("href", "https://pewu.github.io/osm-history/#/" + entity.type + "/" + entity.osmId()).attr("target", "_blank").attr("tabindex", -1).text("PeWu");
      var list2 = selection2.append("ul");
      list2.append("li").call(_t.append("info_panels.history.version", { suffix: ":" })).append("span").text(entity.version);
      list2.append("li").call(_t.append("info_panels.history.last_edit", { suffix: ":" })).append("span").text(displayTimestamp(entity.timestamp));
      list2.append("li").call(_t.append("info_panels.history.edited_by", { suffix: ":" })).call(displayUser, entity.user);
      list2.append("li").call(_t.append("info_panels.history.changeset", { suffix: ":" })).call(displayChangeset, entity.changeset);
    }
    var panel = function(selection2) {
      selection2.call(redraw);
      context.map().on("drawn.info-history", function() {
        selection2.call(redraw);
      });
      context.on("enter.info-history", function() {
        selection2.call(redraw);
      });
    };
    panel.off = function() {
      context.map().on("drawn.info-history", null);
      context.on("enter.info-history", null);
    };
    panel.id = "history";
    panel.label = _t.append("info_panels.history.title");
    panel.key = _t("info_panels.history.key");
    return panel;
  }

  // modules/ui/panels/location.js
  function uiPanelLocation(context) {
    var currLocation = "";
    function redraw(selection2) {
      selection2.html("");
      var list2 = selection2.append("ul");
      var coord2 = context.map().mouseCoordinates();
      if (coord2.some(isNaN)) {
        coord2 = context.map().center();
      }
      list2.append("li").text(dmsCoordinatePair(coord2)).append("li").text(decimalCoordinatePair(coord2));
      selection2.append("div").attr("class", "location-info").text(currLocation || " ");
      debouncedGetLocation(selection2, coord2);
    }
    var debouncedGetLocation = debounce_default(getLocation, 250);
    function getLocation(selection2, coord2) {
      if (!services.geocoder) {
        currLocation = _t("info_panels.location.unknown_location");
        selection2.selectAll(".location-info").text(currLocation);
      } else {
        services.geocoder.reverse(coord2, function(err, result) {
          currLocation = result ? result.display_name : _t("info_panels.location.unknown_location");
          selection2.selectAll(".location-info").text(currLocation);
        });
      }
    }
    var panel = function(selection2) {
      selection2.call(redraw);
      context.surface().on(("PointerEvent" in window ? "pointer" : "mouse") + "move.info-location", function() {
        selection2.call(redraw);
      });
    };
    panel.off = function() {
      context.surface().on(".info-location", null);
    };
    panel.id = "location";
    panel.label = _t.append("info_panels.location.title");
    panel.key = _t("info_panels.location.key");
    return panel;
  }

  // modules/ui/panels/measurement.js
  function uiPanelMeasurement(context) {
    function radiansToMeters(r2) {
      return r2 * 63710071809e-4;
    }
    function steradiansToSqmeters(r2) {
      return r2 / (4 * Math.PI) * 510065621724e3;
    }
    function toLineString(feature3) {
      if (feature3.type === "LineString")
        return feature3;
      var result = { type: "LineString", coordinates: [] };
      if (feature3.type === "Polygon") {
        result.coordinates = feature3.coordinates[0];
      } else if (feature3.type === "MultiPolygon") {
        result.coordinates = feature3.coordinates[0][0];
      }
      return result;
    }
    var _isImperial = !_mainLocalizer.usesMetric();
    function redraw(selection2) {
      var graph = context.graph();
      var selectedNoteID = context.selectedNoteID();
      var osm = services.osm;
      var localeCode = _mainLocalizer.localeCode();
      var heading2;
      var center, location, centroid;
      var closed, geometry;
      var totalNodeCount, length2 = 0, area = 0, distance;
      if (selectedNoteID && osm) {
        var note = osm.getNote(selectedNoteID);
        heading2 = _t.html("note.note") + " " + selectedNoteID;
        location = note.loc;
        geometry = "note";
      } else {
        var selectedIDs = context.selectedIDs().filter(function(id2) {
          return context.hasEntity(id2);
        });
        var selected = selectedIDs.map(function(id2) {
          return context.entity(id2);
        });
        heading2 = selected.length === 1 ? selected[0].id : _t.html("info_panels.selected", { n: selected.length });
        if (selected.length) {
          var extent = geoExtent();
          for (var i3 in selected) {
            var entity = selected[i3];
            extent._extend(entity.extent(graph));
            geometry = entity.geometry(graph);
            if (geometry === "line" || geometry === "area") {
              closed = entity.type === "relation" || entity.isClosed() && !entity.isDegenerate();
              var feature3 = entity.asGeoJSON(graph);
              length2 += radiansToMeters(length_default(toLineString(feature3)));
              centroid = path_default(context.projection).centroid(entity.asGeoJSON(graph));
              centroid = centroid && context.projection.invert(centroid);
              if (!centroid || !isFinite(centroid[0]) || !isFinite(centroid[1])) {
                centroid = entity.extent(graph).center();
              }
              if (closed) {
                area += steradiansToSqmeters(entity.area(graph));
              }
            }
          }
          if (selected.length > 1) {
            geometry = null;
            closed = null;
            centroid = null;
          }
          if (selected.length === 2 && selected[0].type === "node" && selected[1].type === "node") {
            distance = geoSphericalDistance(selected[0].loc, selected[1].loc);
          }
          if (selected.length === 1 && selected[0].type === "node") {
            location = selected[0].loc;
          } else {
            totalNodeCount = utilGetAllNodes(selectedIDs, context.graph()).length;
          }
          if (!location && !centroid) {
            center = extent.center();
          }
        }
      }
      selection2.html("");
      if (heading2) {
        selection2.append("h4").attr("class", "measurement-heading").html(heading2);
      }
      var list2 = selection2.append("ul");
      var coordItem;
      if (geometry) {
        list2.append("li").call(_t.append("info_panels.measurement.geometry", { suffix: ":" })).append("span").html(
          closed ? _t.html("info_panels.measurement.closed_" + geometry) : _t.html("geometry." + geometry)
        );
      }
      if (totalNodeCount) {
        list2.append("li").call(_t.append("info_panels.measurement.node_count", { suffix: ":" })).append("span").text(totalNodeCount.toLocaleString(localeCode));
      }
      if (area) {
        list2.append("li").call(_t.append("info_panels.measurement.area", { suffix: ":" })).append("span").text(displayArea(area, _isImperial));
      }
      if (length2) {
        list2.append("li").call(_t.append("info_panels.measurement." + (closed ? "perimeter" : "length"), { suffix: ":" })).append("span").text(displayLength(length2, _isImperial));
      }
      if (typeof distance === "number") {
        list2.append("li").call(_t.append("info_panels.measurement.distance", { suffix: ":" })).append("span").text(displayLength(distance, _isImperial));
      }
      if (location) {
        coordItem = list2.append("li").call(_t.append("info_panels.measurement.location", { suffix: ":" }));
        coordItem.append("span").text(dmsCoordinatePair(location));
        coordItem.append("span").text(decimalCoordinatePair(location));
      }
      if (centroid) {
        coordItem = list2.append("li").call(_t.append("info_panels.measurement.centroid", { suffix: ":" }));
        coordItem.append("span").text(dmsCoordinatePair(centroid));
        coordItem.append("span").text(decimalCoordinatePair(centroid));
      }
      if (center) {
        coordItem = list2.append("li").call(_t.append("info_panels.measurement.center", { suffix: ":" }));
        coordItem.append("span").text(dmsCoordinatePair(center));
        coordItem.append("span").text(decimalCoordinatePair(center));
      }
      if (length2 || area || typeof distance === "number") {
        var toggle = _isImperial ? "imperial" : "metric";
        selection2.append("a").call(_t.append("info_panels.measurement." + toggle)).attr("href", "#").attr("class", "button button-toggle-units").on("click", function(d3_event) {
          d3_event.preventDefault();
          _isImperial = !_isImperial;
          selection2.call(redraw);
        });
      }
    }
    var panel = function(selection2) {
      selection2.call(redraw);
      context.map().on("drawn.info-measurement", function() {
        selection2.call(redraw);
      });
      context.on("enter.info-measurement", function() {
        selection2.call(redraw);
      });
    };
    panel.off = function() {
      context.map().on("drawn.info-measurement", null);
      context.on("enter.info-measurement", null);
    };
    panel.id = "measurement";
    panel.label = _t.append("info_panels.measurement.title");
    panel.key = _t("info_panels.measurement.key");
    return panel;
  }

  // modules/ui/panels/index.js
  var uiInfoPanels = {
    background: uiPanelBackground,
    history: uiPanelHistory,
    location: uiPanelLocation,
    measurement: uiPanelMeasurement
  };

  // modules/ui/info.js
  function uiInfo(context) {
    var ids = Object.keys(uiInfoPanels);
    var wasActive = ["measurement"];
    var panels = {};
    var active = {};
    ids.forEach(function(k2) {
      if (!panels[k2]) {
        panels[k2] = uiInfoPanels[k2](context);
        active[k2] = false;
      }
    });
    function info(selection2) {
      function redraw() {
        var activeids = ids.filter(function(k2) {
          return active[k2];
        }).sort();
        var containers = infoPanels.selectAll(".panel-container").data(activeids, function(k2) {
          return k2;
        });
        containers.exit().style("opacity", 1).transition().duration(200).style("opacity", 0).on("end", function(d2) {
          select_default2(this).call(panels[d2].off).remove();
        });
        var enter = containers.enter().append("div").attr("class", function(d2) {
          return "fillD2 panel-container panel-container-" + d2;
        });
        enter.style("opacity", 0).transition().duration(200).style("opacity", 1);
        var title = enter.append("div").attr("class", "panel-title fillD2");
        title.append("h3").each(function(d2) {
          return panels[d2].label(select_default2(this));
        });
        title.append("button").attr("class", "close").attr("title", _t("icons.close")).on("click", function(d3_event, d2) {
          d3_event.stopImmediatePropagation();
          d3_event.preventDefault();
          info.toggle(d2);
        }).call(svgIcon("#iD-icon-close"));
        enter.append("div").attr("class", function(d2) {
          return "panel-content panel-content-" + d2;
        });
        infoPanels.selectAll(".panel-content").each(function(d2) {
          select_default2(this).call(panels[d2]);
        });
      }
      info.toggle = function(which) {
        var activeids = ids.filter(function(k2) {
          return active[k2];
        });
        if (which) {
          active[which] = !active[which];
          if (activeids.length === 1 && activeids[0] === which) {
            wasActive = [which];
          }
          context.container().select("." + which + "-panel-toggle-item").classed("active", active[which]).select("input").property("checked", active[which]);
        } else {
          if (activeids.length) {
            wasActive = activeids;
            activeids.forEach(function(k2) {
              active[k2] = false;
            });
          } else {
            wasActive.forEach(function(k2) {
              active[k2] = true;
            });
          }
        }
        redraw();
      };
      var infoPanels = selection2.selectAll(".info-panels").data([0]);
      infoPanels = infoPanels.enter().append("div").attr("class", "info-panels").merge(infoPanels);
      redraw();
      context.keybinding().on(uiCmd("\u2318" + _t("info_panels.key")), function(d3_event) {
        d3_event.stopImmediatePropagation();
        d3_event.preventDefault();
        info.toggle();
      });
      ids.forEach(function(k2) {
        var key = _t("info_panels." + k2 + ".key", { default: null });
        if (!key)
          return;
        context.keybinding().on(uiCmd("\u2318\u21E7" + key), function(d3_event) {
          d3_event.stopImmediatePropagation();
          d3_event.preventDefault();
          info.toggle(k2);
        });
      });
    }
    return info;
  }

  // modules/ui/intro/helper.js
  function pointBox(loc, context) {
    var rect = context.surfaceRect();
    var point2 = context.curtainProjection(loc);
    return {
      left: point2[0] + rect.left - 40,
      top: point2[1] + rect.top - 60,
      width: 80,
      height: 90
    };
  }
  function pad(locOrBox, padding, context) {
    var box;
    if (locOrBox instanceof Array) {
      var rect = context.surfaceRect();
      var point2 = context.curtainProjection(locOrBox);
      box = {
        left: point2[0] + rect.left,
        top: point2[1] + rect.top
      };
    } else {
      box = locOrBox;
    }
    return {
      left: box.left - padding,
      top: box.top - padding,
      width: (box.width || 0) + 2 * padding,
      height: (box.width || 0) + 2 * padding
    };
  }
  function icon(name, svgklass, useklass) {
    return '<svg class="icon ' + (svgklass || "") + '"><use xlink:href="' + name + '"' + (useklass ? ' class="' + useklass + '"' : "") + "></use></svg>";
  }
  var helpStringReplacements;
  function helpHtml(id2, replacements) {
    if (!helpStringReplacements) {
      helpStringReplacements = {
        // insert icons corresponding to various UI elements
        point_icon: icon("#iD-icon-point", "inline"),
        line_icon: icon("#iD-icon-line", "inline"),
        area_icon: icon("#iD-icon-area", "inline"),
        note_icon: icon("#iD-icon-note", "inline add-note"),
        plus: icon("#iD-icon-plus", "inline"),
        minus: icon("#iD-icon-minus", "inline"),
        layers_icon: icon("#iD-icon-layers", "inline"),
        data_icon: icon("#iD-icon-data", "inline"),
        inspect: icon("#iD-icon-inspect", "inline"),
        help_icon: icon("#iD-icon-help", "inline"),
        undo_icon: icon(_mainLocalizer.textDirection() === "rtl" ? "#iD-icon-redo" : "#iD-icon-undo", "inline"),
        redo_icon: icon(_mainLocalizer.textDirection() === "rtl" ? "#iD-icon-undo" : "#iD-icon-redo", "inline"),
        save_icon: icon("#iD-icon-save", "inline"),
        // operation icons
        circularize_icon: icon("#iD-operation-circularize", "inline operation"),
        continue_icon: icon("#iD-operation-continue", "inline operation"),
        copy_icon: icon("#iD-operation-copy", "inline operation"),
        delete_icon: icon("#iD-operation-delete", "inline operation"),
        disconnect_icon: icon("#iD-operation-disconnect", "inline operation"),
        downgrade_icon: icon("#iD-operation-downgrade", "inline operation"),
        extract_icon: icon("#iD-operation-extract", "inline operation"),
        merge_icon: icon("#iD-operation-merge", "inline operation"),
        move_icon: icon("#iD-operation-move", "inline operation"),
        orthogonalize_icon: icon("#iD-operation-orthogonalize", "inline operation"),
        paste_icon: icon("#iD-operation-paste", "inline operation"),
        reflect_long_icon: icon("#iD-operation-reflect-long", "inline operation"),
        reflect_short_icon: icon("#iD-operation-reflect-short", "inline operation"),
        reverse_icon: icon("#iD-operation-reverse", "inline operation"),
        rotate_icon: icon("#iD-operation-rotate", "inline operation"),
        split_icon: icon("#iD-operation-split", "inline operation"),
        straighten_icon: icon("#iD-operation-straighten", "inline operation"),
        // interaction icons
        leftclick: icon("#iD-walkthrough-mouse-left", "inline operation"),
        rightclick: icon("#iD-walkthrough-mouse-right", "inline operation"),
        mousewheel_icon: icon("#iD-walkthrough-mousewheel", "inline operation"),
        tap_icon: icon("#iD-walkthrough-tap", "inline operation"),
        doubletap_icon: icon("#iD-walkthrough-doubletap", "inline operation"),
        longpress_icon: icon("#iD-walkthrough-longpress", "inline operation"),
        touchdrag_icon: icon("#iD-walkthrough-touchdrag", "inline operation"),
        pinch_icon: icon("#iD-walkthrough-pinch-apart", "inline operation"),
        // insert keys; may be localized and platform-dependent
        shift: uiCmd.display("\u21E7"),
        alt: uiCmd.display("\u2325"),
        return: uiCmd.display("\u21B5"),
        esc: _t.html("shortcuts.key.esc"),
        space: _t.html("shortcuts.key.space"),
        add_note_key: _t.html("modes.add_note.key"),
        help_key: _t.html("help.key"),
        shortcuts_key: _t.html("shortcuts.toggle.key"),
        // reference localized UI labels directly so that they'll always match
        save: _t.html("save.title"),
        undo: _t.html("undo.title"),
        redo: _t.html("redo.title"),
        upload: _t.html("commit.save"),
        point: _t.html("modes.add_point.title"),
        line: _t.html("modes.add_line.title"),
        area: _t.html("modes.add_area.title"),
        note: _t.html("modes.add_note.label"),
        circularize: _t.html("operations.circularize.title"),
        continue: _t.html("operations.continue.title"),
        copy: _t.html("operations.copy.title"),
        delete: _t.html("operations.delete.title"),
        disconnect: _t.html("operations.disconnect.title"),
        downgrade: _t.html("operations.downgrade.title"),
        extract: _t.html("operations.extract.title"),
        merge: _t.html("operations.merge.title"),
        move: _t.html("operations.move.title"),
        orthogonalize: _t.html("operations.orthogonalize.title"),
        paste: _t.html("operations.paste.title"),
        reflect_long: _t.html("operations.reflect.title.long"),
        reflect_short: _t.html("operations.reflect.title.short"),
        reverse: _t.html("operations.reverse.title"),
        rotate: _t.html("operations.rotate.title"),
        split: _t.html("operations.split.title"),
        straighten: _t.html("operations.straighten.title"),
        map_data: _t.html("map_data.title"),
        osm_notes: _t.html("map_data.layers.notes.title"),
        fields: _t.html("inspector.fields"),
        tags: _t.html("inspector.tags"),
        relations: _t.html("inspector.relations"),
        new_relation: _t.html("inspector.new_relation"),
        turn_restrictions: _t.html("_tagging.presets.fields.restrictions.label"),
        background_settings: _t.html("background.description"),
        imagery_offset: _t.html("background.fix_misalignment"),
        start_the_walkthrough: _t.html("splash.walkthrough"),
        help: _t.html("help.title"),
        ok: _t.html("intro.ok")
      };
      for (var key in helpStringReplacements) {
        helpStringReplacements[key] = { html: helpStringReplacements[key] };
      }
    }
    var reps;
    if (replacements) {
      reps = Object.assign(replacements, helpStringReplacements);
    } else {
      reps = helpStringReplacements;
    }
    return _t.html(id2, reps).replace(/\`(.*?)\`/g, "<kbd>$1</kbd>");
  }
  function slugify(text) {
    return text.toString().toLowerCase().replace(/\s+/g, "-").replace(/[^\w\-]+/g, "").replace(/\-\-+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
  }
  var missingStrings = {};
  function checkKey(key, text) {
    if (_t(key, { default: void 0 }) === void 0) {
      if (missingStrings.hasOwnProperty(key))
        return;
      missingStrings[key] = text;
      var missing = key + ": " + text;
      if (typeof console !== "undefined")
        console.log(missing);
    }
  }
  function localize(obj) {
    var key;
    var name = obj.tags && obj.tags.name;
    if (name) {
      key = "intro.graph.name." + slugify(name);
      obj.tags.name = _t(key, { default: name });
      checkKey(key, name);
    }
    var street = obj.tags && obj.tags["addr:street"];
    if (street) {
      key = "intro.graph.name." + slugify(street);
      obj.tags["addr:street"] = _t(key, { default: street });
      checkKey(key, street);
      var addrTags = [
        "block_number",
        "city",
        "county",
        "district",
        "hamlet",
        "neighbourhood",
        "postcode",
        "province",
        "quarter",
        "state",
        "subdistrict",
        "suburb"
      ];
      addrTags.forEach(function(k2) {
        var key2 = "intro.graph." + k2;
        var tag2 = "addr:" + k2;
        var val = obj.tags && obj.tags[tag2];
        var str = _t(key2, { default: val });
        if (str) {
          if (str.match(/^<.*>$/) !== null) {
            delete obj.tags[tag2];
          } else {
            obj.tags[tag2] = str;
          }
        }
      });
    }
    return obj;
  }
  function isMostlySquare(points) {
    var threshold = 15;
    var lowerBound = Math.cos((90 - threshold) * Math.PI / 180);
    var upperBound = Math.cos(threshold * Math.PI / 180);
    for (var i3 = 0; i3 < points.length; i3++) {
      var a2 = points[(i3 - 1 + points.length) % points.length];
      var origin = points[i3];
      var b2 = points[(i3 + 1) % points.length];
      var dotp = geoVecNormalizedDot(a2, b2, origin);
      var mag = Math.abs(dotp);
      if (mag > lowerBound && mag < upperBound) {
        return false;
      }
    }
    return true;
  }
  function selectMenuItem(context, operation2) {
    return context.container().select(".edit-menu .edit-menu-item-" + operation2);
  }
  function transitionTime(point1, point2) {
    var distance = geoSphericalDistance(point1, point2);
    if (distance === 0) {
      return 0;
    } else if (distance < 80) {
      return 500;
    } else {
      return 1e3;
    }
  }

  // modules/ui/toggle.js
  function uiToggle(show, callback) {
    return function(selection2) {
      selection2.style("opacity", show ? 0 : 1).classed("hide", false).transition().style("opacity", show ? 1 : 0).on("end", function() {
        select_default2(this).classed("hide", !show).style("opacity", null);
        if (callback)
          callback.apply(this);
      });
    };
  }

  // modules/ui/curtain.js
  function uiCurtain(containerNode) {
    var surface = select_default2(null), tooltip = select_default2(null), darkness = select_default2(null);
    function curtain(selection2) {
      surface = selection2.append("svg").attr("class", "curtain").style("top", 0).style("left", 0);
      darkness = surface.append("path").attr("x", 0).attr("y", 0).attr("class", "curtain-darkness");
      select_default2(window).on("resize.curtain", resize);
      tooltip = selection2.append("div").attr("class", "tooltip");
      tooltip.append("div").attr("class", "popover-arrow");
      tooltip.append("div").attr("class", "popover-inner");
      resize();
      function resize() {
        surface.attr("width", containerNode.clientWidth).attr("height", containerNode.clientHeight);
        curtain.cut(darkness.datum());
      }
    }
    curtain.reveal = function(box, html3, options2) {
      options2 = options2 || {};
      if (typeof box === "string") {
        box = select_default2(box).node();
      }
      if (box && box.getBoundingClientRect) {
        box = copyBox(box.getBoundingClientRect());
        var containerRect = containerNode.getBoundingClientRect();
        box.top -= containerRect.top;
        box.left -= containerRect.left;
      }
      if (box && options2.padding) {
        box.top -= options2.padding;
        box.left -= options2.padding;
        box.bottom += options2.padding;
        box.right += options2.padding;
        box.height += options2.padding * 2;
        box.width += options2.padding * 2;
      }
      var tooltipBox;
      if (options2.tooltipBox) {
        tooltipBox = options2.tooltipBox;
        if (typeof tooltipBox === "string") {
          tooltipBox = select_default2(tooltipBox).node();
        }
        if (tooltipBox && tooltipBox.getBoundingClientRect) {
          tooltipBox = copyBox(tooltipBox.getBoundingClientRect());
        }
      } else {
        tooltipBox = box;
      }
      if (tooltipBox && html3) {
        if (html3.indexOf("**") !== -1) {
          if (html3.indexOf("<span") === 0) {
            html3 = html3.replace(/^(<span.*?>)(.+?)(\*\*)/, "$1<span>$2</span>$3");
          } else {
            html3 = html3.replace(/^(.+?)(\*\*)/, "<span>$1</span>$2");
          }
          html3 = html3.replace(/\*\*(.*?)\*\*/g, '<span class="instruction">$1</span>');
        }
        html3 = html3.replace(/\*(.*?)\*/g, "<em>$1</em>");
        html3 = html3.replace(/\{br\}/g, "<br/><br/>");
        if (options2.buttonText && options2.buttonCallback) {
          html3 += '<div class="button-section"><button href="#" class="button action">' + options2.buttonText + "</button></div>";
        }
        var classes = "curtain-tooltip popover tooltip arrowed in " + (options2.tooltipClass || "");
        tooltip.classed(classes, true).selectAll(".popover-inner").html(html3);
        if (options2.buttonText && options2.buttonCallback) {
          var button = tooltip.selectAll(".button-section .button.action");
          button.on("click", function(d3_event) {
            d3_event.preventDefault();
            options2.buttonCallback();
          });
        }
        var tip = copyBox(tooltip.node().getBoundingClientRect()), w2 = containerNode.clientWidth, h2 = containerNode.clientHeight, tooltipWidth = 200, tooltipArrow = 5, side, pos;
        if (options2.tooltipClass === "intro-mouse") {
          tip.height += 80;
        }
        if (tooltipBox.top + tooltipBox.height > h2) {
          tooltipBox.height -= tooltipBox.top + tooltipBox.height - h2;
        }
        if (tooltipBox.left + tooltipBox.width > w2) {
          tooltipBox.width -= tooltipBox.left + tooltipBox.width - w2;
        }
        if (tooltipBox.top + tooltipBox.height < 100) {
          side = "bottom";
          pos = [
            tooltipBox.left + tooltipBox.width / 2 - tip.width / 2,
            tooltipBox.top + tooltipBox.height
          ];
        } else if (tooltipBox.top > h2 - 140) {
          side = "top";
          pos = [
            tooltipBox.left + tooltipBox.width / 2 - tip.width / 2,
            tooltipBox.top - tip.height
          ];
        } else {
          var tipY = tooltipBox.top + tooltipBox.height / 2 - tip.height / 2;
          if (_mainLocalizer.textDirection() === "rtl") {
            if (tooltipBox.left - tooltipWidth - tooltipArrow < 70) {
              side = "right";
              pos = [tooltipBox.left + tooltipBox.width + tooltipArrow, tipY];
            } else {
              side = "left";
              pos = [tooltipBox.left - tooltipWidth - tooltipArrow, tipY];
            }
          } else {
            if (tooltipBox.left + tooltipBox.width + tooltipArrow + tooltipWidth > w2 - 70) {
              side = "left";
              pos = [tooltipBox.left - tooltipWidth - tooltipArrow, tipY];
            } else {
              side = "right";
              pos = [tooltipBox.left + tooltipBox.width + tooltipArrow, tipY];
            }
          }
        }
        if (options2.duration !== 0 || !tooltip.classed(side)) {
          tooltip.call(uiToggle(true));
        }
        tooltip.style("top", pos[1] + "px").style("left", pos[0] + "px").attr("class", classes + " " + side);
        var shiftY = 0;
        if (side === "left" || side === "right") {
          if (pos[1] < 60) {
            shiftY = 60 - pos[1];
          } else if (pos[1] + tip.height > h2 - 100) {
            shiftY = h2 - pos[1] - tip.height - 100;
          }
        }
        tooltip.selectAll(".popover-inner").style("top", shiftY + "px");
      } else {
        tooltip.classed("in", false).call(uiToggle(false));
      }
      curtain.cut(box, options2.duration);
      return tooltip;
    };
    curtain.cut = function(datum2, duration) {
      darkness.datum(datum2).interrupt();
      var selection2;
      if (duration === 0) {
        selection2 = darkness;
      } else {
        selection2 = darkness.transition().duration(duration || 600).ease(linear2);
      }
      selection2.attr("d", function(d2) {
        var containerWidth = containerNode.clientWidth;
        var containerHeight = containerNode.clientHeight;
        var string = "M 0,0 L 0," + containerHeight + " L " + containerWidth + "," + containerHeight + "L" + containerWidth + ",0 Z";
        if (!d2)
          return string;
        return string + "M" + d2.left + "," + d2.top + "L" + d2.left + "," + (d2.top + d2.height) + "L" + (d2.left + d2.width) + "," + (d2.top + d2.height) + "L" + (d2.left + d2.width) + "," + d2.top + "Z";
      });
    };
    curtain.remove = function() {
      surface.remove();
      tooltip.remove();
      select_default2(window).on("resize.curtain", null);
    };
    function copyBox(src) {
      return {
        top: src.top,
        right: src.right,
        bottom: src.bottom,
        left: src.left,
        width: src.width,
        height: src.height
      };
    }
    return curtain;
  }

  // modules/ui/intro/welcome.js
  function uiIntroWelcome(context, reveal) {
    var dispatch14 = dispatch_default("done");
    var chapter = {
      title: "intro.welcome.title"
    };
    function welcome() {
      context.map().centerZoom([-85.63591, 41.94285], 19);
      reveal(
        ".intro-nav-wrap .chapter-welcome",
        helpHtml("intro.welcome.welcome"),
        { buttonText: _t.html("intro.ok"), buttonCallback: practice }
      );
    }
    function practice() {
      reveal(
        ".intro-nav-wrap .chapter-welcome",
        helpHtml("intro.welcome.practice"),
        { buttonText: _t.html("intro.ok"), buttonCallback: words }
      );
    }
    function words() {
      reveal(
        ".intro-nav-wrap .chapter-welcome",
        helpHtml("intro.welcome.words"),
        { buttonText: _t.html("intro.ok"), buttonCallback: chapters }
      );
    }
    function chapters() {
      dispatch14.call("done");
      reveal(
        ".intro-nav-wrap .chapter-navigation",
        helpHtml("intro.welcome.chapters", { next: _t("intro.navigation.title") })
      );
    }
    chapter.enter = function() {
      welcome();
    };
    chapter.exit = function() {
      context.container().select(".curtain-tooltip.intro-mouse").selectAll(".counter").remove();
    };
    chapter.restart = function() {
      chapter.exit();
      chapter.enter();
    };
    return utilRebind(chapter, dispatch14, "on");
  }

  // modules/ui/intro/navigation.js
  function uiIntroNavigation(context, reveal) {
    var dispatch14 = dispatch_default("done");
    var timeouts = [];
    var hallId = "n2061";
    var townHall = [-85.63591, 41.94285];
    var springStreetId = "w397";
    var springStreetEndId = "n1834";
    var springStreet = [-85.63582, 41.94255];
    var onewayField = _mainPresetIndex.field("oneway");
    var maxspeedField = _mainPresetIndex.field("maxspeed");
    var chapter = {
      title: "intro.navigation.title"
    };
    function timeout2(f2, t2) {
      timeouts.push(window.setTimeout(f2, t2));
    }
    function eventCancel(d3_event) {
      d3_event.stopPropagation();
      d3_event.preventDefault();
    }
    function isTownHallSelected() {
      var ids = context.selectedIDs();
      return ids.length === 1 && ids[0] === hallId;
    }
    function dragMap() {
      context.enter(modeBrowse(context));
      context.history().reset("initial");
      var msec = transitionTime(townHall, context.map().center());
      if (msec) {
        reveal(null, null, { duration: 0 });
      }
      context.map().centerZoomEase(townHall, 19, msec);
      timeout2(function() {
        var centerStart = context.map().center();
        var textId = context.lastPointerType() === "mouse" ? "drag" : "drag_touch";
        var dragString = helpHtml("intro.navigation.map_info") + "{br}" + helpHtml("intro.navigation." + textId);
        reveal(".surface", dragString);
        context.map().on("drawn.intro", function() {
          reveal(".surface", dragString, { duration: 0 });
        });
        context.map().on("move.intro", function() {
          var centerNow = context.map().center();
          if (centerStart[0] !== centerNow[0] || centerStart[1] !== centerNow[1]) {
            context.map().on("move.intro", null);
            timeout2(function() {
              continueTo(zoomMap);
            }, 3e3);
          }
        });
      }, msec + 100);
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        nextStep();
      }
    }
    function zoomMap() {
      var zoomStart = context.map().zoom();
      var textId = context.lastPointerType() === "mouse" ? "zoom" : "zoom_touch";
      var zoomString = helpHtml("intro.navigation." + textId);
      reveal(".surface", zoomString);
      context.map().on("drawn.intro", function() {
        reveal(".surface", zoomString, { duration: 0 });
      });
      context.map().on("move.intro", function() {
        if (context.map().zoom() !== zoomStart) {
          context.map().on("move.intro", null);
          timeout2(function() {
            continueTo(features);
          }, 3e3);
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        nextStep();
      }
    }
    function features() {
      var onClick = function() {
        continueTo(pointsLinesAreas);
      };
      reveal(
        ".surface",
        helpHtml("intro.navigation.features"),
        { buttonText: _t.html("intro.ok"), buttonCallback: onClick }
      );
      context.map().on("drawn.intro", function() {
        reveal(
          ".surface",
          helpHtml("intro.navigation.features"),
          { duration: 0, buttonText: _t.html("intro.ok"), buttonCallback: onClick }
        );
      });
      function continueTo(nextStep) {
        context.map().on("drawn.intro", null);
        nextStep();
      }
    }
    function pointsLinesAreas() {
      var onClick = function() {
        continueTo(nodesWays);
      };
      reveal(
        ".surface",
        helpHtml("intro.navigation.points_lines_areas"),
        { buttonText: _t.html("intro.ok"), buttonCallback: onClick }
      );
      context.map().on("drawn.intro", function() {
        reveal(
          ".surface",
          helpHtml("intro.navigation.points_lines_areas"),
          { duration: 0, buttonText: _t.html("intro.ok"), buttonCallback: onClick }
        );
      });
      function continueTo(nextStep) {
        context.map().on("drawn.intro", null);
        nextStep();
      }
    }
    function nodesWays() {
      var onClick = function() {
        continueTo(clickTownHall);
      };
      reveal(
        ".surface",
        helpHtml("intro.navigation.nodes_ways"),
        { buttonText: _t.html("intro.ok"), buttonCallback: onClick }
      );
      context.map().on("drawn.intro", function() {
        reveal(
          ".surface",
          helpHtml("intro.navigation.nodes_ways"),
          { duration: 0, buttonText: _t.html("intro.ok"), buttonCallback: onClick }
        );
      });
      function continueTo(nextStep) {
        context.map().on("drawn.intro", null);
        nextStep();
      }
    }
    function clickTownHall() {
      context.enter(modeBrowse(context));
      context.history().reset("initial");
      var entity = context.hasEntity(hallId);
      if (!entity)
        return;
      reveal(null, null, { duration: 0 });
      context.map().centerZoomEase(entity.loc, 19, 500);
      timeout2(function() {
        var entity2 = context.hasEntity(hallId);
        if (!entity2)
          return;
        var box = pointBox(entity2.loc, context);
        var textId = context.lastPointerType() === "mouse" ? "click_townhall" : "tap_townhall";
        reveal(box, helpHtml("intro.navigation." + textId));
        context.map().on("move.intro drawn.intro", function() {
          var entity3 = context.hasEntity(hallId);
          if (!entity3)
            return;
          var box2 = pointBox(entity3.loc, context);
          reveal(box2, helpHtml("intro.navigation." + textId), { duration: 0 });
        });
        context.on("enter.intro", function() {
          if (isTownHallSelected())
            continueTo(selectedTownHall);
        });
      }, 550);
      context.history().on("change.intro", function() {
        if (!context.hasEntity(hallId)) {
          continueTo(clickTownHall);
        }
      });
      function continueTo(nextStep) {
        context.on("enter.intro", null);
        context.map().on("move.intro drawn.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function selectedTownHall() {
      if (!isTownHallSelected())
        return clickTownHall();
      var entity = context.hasEntity(hallId);
      if (!entity)
        return clickTownHall();
      var box = pointBox(entity.loc, context);
      var onClick = function() {
        continueTo(editorTownHall);
      };
      reveal(
        box,
        helpHtml("intro.navigation.selected_townhall"),
        { buttonText: _t.html("intro.ok"), buttonCallback: onClick }
      );
      context.map().on("move.intro drawn.intro", function() {
        var entity2 = context.hasEntity(hallId);
        if (!entity2)
          return;
        var box2 = pointBox(entity2.loc, context);
        reveal(
          box2,
          helpHtml("intro.navigation.selected_townhall"),
          { duration: 0, buttonText: _t.html("intro.ok"), buttonCallback: onClick }
        );
      });
      context.history().on("change.intro", function() {
        if (!context.hasEntity(hallId)) {
          continueTo(clickTownHall);
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function editorTownHall() {
      if (!isTownHallSelected())
        return clickTownHall();
      context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
      var onClick = function() {
        continueTo(presetTownHall);
      };
      reveal(
        ".entity-editor-pane",
        helpHtml("intro.navigation.editor_townhall"),
        { buttonText: _t.html("intro.ok"), buttonCallback: onClick }
      );
      context.on("exit.intro", function() {
        continueTo(clickTownHall);
      });
      context.history().on("change.intro", function() {
        if (!context.hasEntity(hallId)) {
          continueTo(clickTownHall);
        }
      });
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        context.history().on("change.intro", null);
        context.container().select(".inspector-wrap").on("wheel.intro", null);
        nextStep();
      }
    }
    function presetTownHall() {
      if (!isTownHallSelected())
        return clickTownHall();
      context.container().select(".inspector-wrap .panewrap").style("right", "0%");
      context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
      var entity = context.entity(context.selectedIDs()[0]);
      var preset = _mainPresetIndex.match(entity, context.graph());
      var onClick = function() {
        continueTo(fieldsTownHall);
      };
      reveal(
        ".entity-editor-pane .section-feature-type",
        helpHtml("intro.navigation.preset_townhall", { preset: preset.name() }),
        { buttonText: _t.html("intro.ok"), buttonCallback: onClick }
      );
      context.on("exit.intro", function() {
        continueTo(clickTownHall);
      });
      context.history().on("change.intro", function() {
        if (!context.hasEntity(hallId)) {
          continueTo(clickTownHall);
        }
      });
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        context.history().on("change.intro", null);
        context.container().select(".inspector-wrap").on("wheel.intro", null);
        nextStep();
      }
    }
    function fieldsTownHall() {
      if (!isTownHallSelected())
        return clickTownHall();
      context.container().select(".inspector-wrap .panewrap").style("right", "0%");
      context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
      var onClick = function() {
        continueTo(closeTownHall);
      };
      reveal(
        ".entity-editor-pane .section-preset-fields",
        helpHtml("intro.navigation.fields_townhall"),
        { buttonText: _t.html("intro.ok"), buttonCallback: onClick }
      );
      context.on("exit.intro", function() {
        continueTo(clickTownHall);
      });
      context.history().on("change.intro", function() {
        if (!context.hasEntity(hallId)) {
          continueTo(clickTownHall);
        }
      });
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        context.history().on("change.intro", null);
        context.container().select(".inspector-wrap").on("wheel.intro", null);
        nextStep();
      }
    }
    function closeTownHall() {
      if (!isTownHallSelected())
        return clickTownHall();
      var selector = ".entity-editor-pane button.close svg use";
      var href = select_default2(selector).attr("href") || "#iD-icon-close";
      reveal(
        ".entity-editor-pane",
        helpHtml("intro.navigation.close_townhall", { button: { html: icon(href, "inline") } })
      );
      context.on("exit.intro", function() {
        continueTo(searchStreet);
      });
      context.history().on("change.intro", function() {
        var selector2 = ".entity-editor-pane button.close svg use";
        var href2 = select_default2(selector2).attr("href") || "#iD-icon-close";
        reveal(
          ".entity-editor-pane",
          helpHtml("intro.navigation.close_townhall", { button: { html: icon(href2, "inline") } }),
          { duration: 0 }
        );
      });
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function searchStreet() {
      context.enter(modeBrowse(context));
      context.history().reset("initial");
      var msec = transitionTime(springStreet, context.map().center());
      if (msec) {
        reveal(null, null, { duration: 0 });
      }
      context.map().centerZoomEase(springStreet, 19, msec);
      timeout2(function() {
        reveal(
          ".search-header input",
          helpHtml("intro.navigation.search_street", { name: _t("intro.graph.name.spring-street") })
        );
        context.container().select(".search-header input").on("keyup.intro", checkSearchResult);
      }, msec + 100);
    }
    function checkSearchResult() {
      var first = context.container().select(".feature-list-item:nth-child(0n+2)");
      var firstName = first.select(".entity-name");
      var name = _t("intro.graph.name.spring-street");
      if (!firstName.empty() && firstName.html() === name) {
        reveal(
          first.node(),
          helpHtml("intro.navigation.choose_street", { name }),
          { duration: 300 }
        );
        context.on("exit.intro", function() {
          continueTo(selectedStreet);
        });
        context.container().select(".search-header input").on("keydown.intro", eventCancel, true).on("keyup.intro", null);
      }
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        context.container().select(".search-header input").on("keydown.intro", null).on("keyup.intro", null);
        nextStep();
      }
    }
    function selectedStreet() {
      if (!context.hasEntity(springStreetEndId) || !context.hasEntity(springStreetId)) {
        return searchStreet();
      }
      var onClick = function() {
        continueTo(editorStreet);
      };
      var entity = context.entity(springStreetEndId);
      var box = pointBox(entity.loc, context);
      box.height = 500;
      reveal(
        box,
        helpHtml("intro.navigation.selected_street", { name: _t("intro.graph.name.spring-street") }),
        { duration: 600, buttonText: _t.html("intro.ok"), buttonCallback: onClick }
      );
      timeout2(function() {
        context.map().on("move.intro drawn.intro", function() {
          var entity2 = context.hasEntity(springStreetEndId);
          if (!entity2)
            return;
          var box2 = pointBox(entity2.loc, context);
          box2.height = 500;
          reveal(
            box2,
            helpHtml("intro.navigation.selected_street", { name: _t("intro.graph.name.spring-street") }),
            { duration: 0, buttonText: _t.html("intro.ok"), buttonCallback: onClick }
          );
        });
      }, 600);
      context.on("enter.intro", function(mode) {
        if (!context.hasEntity(springStreetId)) {
          return continueTo(searchStreet);
        }
        var ids = context.selectedIDs();
        if (mode.id !== "select" || !ids.length || ids[0] !== springStreetId) {
          context.enter(modeSelect(context, [springStreetId]));
        }
      });
      context.history().on("change.intro", function() {
        if (!context.hasEntity(springStreetEndId) || !context.hasEntity(springStreetId)) {
          timeout2(function() {
            continueTo(searchStreet);
          }, 300);
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function editorStreet() {
      var selector = ".entity-editor-pane button.close svg use";
      var href = select_default2(selector).attr("href") || "#iD-icon-close";
      reveal(".entity-editor-pane", helpHtml("intro.navigation.street_different_fields") + "{br}" + helpHtml("intro.navigation.editor_street", {
        button: { html: icon(href, "inline") },
        field1: onewayField.title(),
        field2: maxspeedField.title()
      }));
      context.on("exit.intro", function() {
        continueTo(play);
      });
      context.history().on("change.intro", function() {
        var selector2 = ".entity-editor-pane button.close svg use";
        var href2 = select_default2(selector2).attr("href") || "#iD-icon-close";
        reveal(
          ".entity-editor-pane",
          helpHtml("intro.navigation.street_different_fields") + "{br}" + helpHtml("intro.navigation.editor_street", {
            button: { html: icon(href2, "inline") },
            field1: onewayField.title(),
            field2: maxspeedField.title()
          }),
          { duration: 0 }
        );
      });
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function play() {
      dispatch14.call("done");
      reveal(
        ".ideditor",
        helpHtml("intro.navigation.play", { next: _t("intro.points.title") }),
        {
          tooltipBox: ".intro-nav-wrap .chapter-point",
          buttonText: _t.html("intro.ok"),
          buttonCallback: function() {
            reveal(".ideditor");
          }
        }
      );
    }
    chapter.enter = function() {
      dragMap();
    };
    chapter.exit = function() {
      timeouts.forEach(window.clearTimeout);
      context.on("enter.intro exit.intro", null);
      context.map().on("move.intro drawn.intro", null);
      context.history().on("change.intro", null);
      context.container().select(".inspector-wrap").on("wheel.intro", null);
      context.container().select(".search-header input").on("keydown.intro keyup.intro", null);
    };
    chapter.restart = function() {
      chapter.exit();
      chapter.enter();
    };
    return utilRebind(chapter, dispatch14, "on");
  }

  // modules/ui/intro/point.js
  function uiIntroPoint(context, reveal) {
    var dispatch14 = dispatch_default("done");
    var timeouts = [];
    var intersection2 = [-85.63279, 41.94394];
    var building = [-85.632422, 41.944045];
    var cafePreset = _mainPresetIndex.item("amenity/cafe");
    var _pointID = null;
    var chapter = {
      title: "intro.points.title"
    };
    function timeout2(f2, t2) {
      timeouts.push(window.setTimeout(f2, t2));
    }
    function eventCancel(d3_event) {
      d3_event.stopPropagation();
      d3_event.preventDefault();
    }
    function addPoint() {
      context.enter(modeBrowse(context));
      context.history().reset("initial");
      var msec = transitionTime(intersection2, context.map().center());
      if (msec) {
        reveal(null, null, { duration: 0 });
      }
      context.map().centerZoomEase(intersection2, 19, msec);
      timeout2(function() {
        var tooltip = reveal(
          "button.add-point",
          helpHtml("intro.points.points_info") + "{br}" + helpHtml("intro.points.add_point")
        );
        _pointID = null;
        tooltip.selectAll(".popover-inner").insert("svg", "span").attr("class", "tooltip-illustration").append("use").attr("xlink:href", "#iD-graphic-points");
        context.on("enter.intro", function(mode) {
          if (mode.id !== "add-point")
            return;
          continueTo(placePoint);
        });
      }, msec + 100);
      function continueTo(nextStep) {
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function placePoint() {
      if (context.mode().id !== "add-point") {
        return chapter.restart();
      }
      var pointBox2 = pad(building, 150, context);
      var textId = context.lastPointerType() === "mouse" ? "place_point" : "place_point_touch";
      reveal(pointBox2, helpHtml("intro.points." + textId));
      context.map().on("move.intro drawn.intro", function() {
        pointBox2 = pad(building, 150, context);
        reveal(pointBox2, helpHtml("intro.points." + textId), { duration: 0 });
      });
      context.on("enter.intro", function(mode) {
        if (mode.id !== "select")
          return chapter.restart();
        _pointID = context.mode().selectedIDs()[0];
        if (context.graph().geometry(_pointID) === "vertex") {
          context.map().on("move.intro drawn.intro", null);
          context.on("enter.intro", null);
          reveal(pointBox2, helpHtml("intro.points.place_point_error"), {
            buttonText: _t.html("intro.ok"),
            buttonCallback: function() {
              return chapter.restart();
            }
          });
        } else {
          continueTo(searchPreset);
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function searchPreset() {
      if (context.mode().id !== "select" || !_pointID || !context.hasEntity(_pointID)) {
        return addPoint();
      }
      context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
      context.container().select(".preset-search-input").on("keydown.intro", null).on("keyup.intro", checkPresetSearch);
      reveal(
        ".preset-search-input",
        helpHtml("intro.points.search_cafe", { preset: cafePreset.name() })
      );
      context.on("enter.intro", function(mode) {
        if (!_pointID || !context.hasEntity(_pointID)) {
          return continueTo(addPoint);
        }
        var ids = context.selectedIDs();
        if (mode.id !== "select" || !ids.length || ids[0] !== _pointID) {
          context.enter(modeSelect(context, [_pointID]));
          context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
          context.container().select(".preset-search-input").on("keydown.intro", null).on("keyup.intro", checkPresetSearch);
          reveal(
            ".preset-search-input",
            helpHtml("intro.points.search_cafe", { preset: cafePreset.name() })
          );
          context.history().on("change.intro", null);
        }
      });
      function checkPresetSearch() {
        var first = context.container().select(".preset-list-item:first-child");
        if (first.classed("preset-amenity-cafe")) {
          context.container().select(".preset-search-input").on("keydown.intro", eventCancel, true).on("keyup.intro", null);
          reveal(
            first.select(".preset-list-button").node(),
            helpHtml("intro.points.choose_cafe", { preset: cafePreset.name() }),
            { duration: 300 }
          );
          context.history().on("change.intro", function() {
            continueTo(aboutFeatureEditor);
          });
        }
      }
      function continueTo(nextStep) {
        context.on("enter.intro", null);
        context.history().on("change.intro", null);
        context.container().select(".inspector-wrap").on("wheel.intro", null);
        context.container().select(".preset-search-input").on("keydown.intro keyup.intro", null);
        nextStep();
      }
    }
    function aboutFeatureEditor() {
      if (context.mode().id !== "select" || !_pointID || !context.hasEntity(_pointID)) {
        return addPoint();
      }
      timeout2(function() {
        reveal(".entity-editor-pane", helpHtml("intro.points.feature_editor"), {
          tooltipClass: "intro-points-describe",
          buttonText: _t.html("intro.ok"),
          buttonCallback: function() {
            continueTo(addName);
          }
        });
      }, 400);
      context.on("exit.intro", function() {
        continueTo(reselectPoint);
      });
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        nextStep();
      }
    }
    function addName() {
      if (context.mode().id !== "select" || !_pointID || !context.hasEntity(_pointID)) {
        return addPoint();
      }
      context.container().select(".inspector-wrap .panewrap").style("right", "0%");
      var addNameString = helpHtml("intro.points.fields_info") + "{br}" + helpHtml("intro.points.add_name");
      timeout2(function() {
        var entity = context.entity(_pointID);
        if (entity.tags.name) {
          var tooltip = reveal(".entity-editor-pane", addNameString, {
            tooltipClass: "intro-points-describe",
            buttonText: _t.html("intro.ok"),
            buttonCallback: function() {
              continueTo(addCloseEditor);
            }
          });
          tooltip.select(".instruction").style("display", "none");
        } else {
          reveal(
            ".entity-editor-pane",
            addNameString,
            { tooltipClass: "intro-points-describe" }
          );
        }
      }, 400);
      context.history().on("change.intro", function() {
        continueTo(addCloseEditor);
      });
      context.on("exit.intro", function() {
        continueTo(reselectPoint);
      });
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function addCloseEditor() {
      context.container().select(".inspector-wrap .panewrap").style("right", "0%");
      var selector = ".entity-editor-pane button.close svg use";
      var href = select_default2(selector).attr("href") || "#iD-icon-close";
      context.on("exit.intro", function() {
        continueTo(reselectPoint);
      });
      reveal(
        ".entity-editor-pane",
        helpHtml("intro.points.add_close", { button: { html: icon(href, "inline") } })
      );
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        nextStep();
      }
    }
    function reselectPoint() {
      if (!_pointID)
        return chapter.restart();
      var entity = context.hasEntity(_pointID);
      if (!entity)
        return chapter.restart();
      var oldPreset = _mainPresetIndex.match(entity, context.graph());
      context.replace(actionChangePreset(_pointID, oldPreset, cafePreset));
      context.enter(modeBrowse(context));
      var msec = transitionTime(entity.loc, context.map().center());
      if (msec) {
        reveal(null, null, { duration: 0 });
      }
      context.map().centerEase(entity.loc, msec);
      timeout2(function() {
        var box = pointBox(entity.loc, context);
        reveal(box, helpHtml("intro.points.reselect"), { duration: 600 });
        timeout2(function() {
          context.map().on("move.intro drawn.intro", function() {
            var entity2 = context.hasEntity(_pointID);
            if (!entity2)
              return chapter.restart();
            var box2 = pointBox(entity2.loc, context);
            reveal(box2, helpHtml("intro.points.reselect"), { duration: 0 });
          });
        }, 600);
        context.on("enter.intro", function(mode) {
          if (mode.id !== "select")
            return;
          continueTo(updatePoint);
        });
      }, msec + 100);
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function updatePoint() {
      if (context.mode().id !== "select" || !_pointID || !context.hasEntity(_pointID)) {
        return continueTo(reselectPoint);
      }
      context.container().select(".inspector-wrap .panewrap").style("right", "0%");
      context.on("exit.intro", function() {
        continueTo(reselectPoint);
      });
      context.history().on("change.intro", function() {
        continueTo(updateCloseEditor);
      });
      timeout2(function() {
        reveal(
          ".entity-editor-pane",
          helpHtml("intro.points.update"),
          { tooltipClass: "intro-points-describe" }
        );
      }, 400);
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function updateCloseEditor() {
      if (context.mode().id !== "select" || !_pointID || !context.hasEntity(_pointID)) {
        return continueTo(reselectPoint);
      }
      context.container().select(".inspector-wrap .panewrap").style("right", "0%");
      context.on("exit.intro", function() {
        continueTo(rightClickPoint);
      });
      timeout2(function() {
        reveal(
          ".entity-editor-pane",
          helpHtml("intro.points.update_close", { button: { html: icon("#iD-icon-close", "inline") } })
        );
      }, 500);
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        nextStep();
      }
    }
    function rightClickPoint() {
      if (!_pointID)
        return chapter.restart();
      var entity = context.hasEntity(_pointID);
      if (!entity)
        return chapter.restart();
      context.enter(modeBrowse(context));
      var box = pointBox(entity.loc, context);
      var textId = context.lastPointerType() === "mouse" ? "rightclick" : "edit_menu_touch";
      reveal(box, helpHtml("intro.points." + textId), { duration: 600 });
      timeout2(function() {
        context.map().on("move.intro", function() {
          var entity2 = context.hasEntity(_pointID);
          if (!entity2)
            return chapter.restart();
          var box2 = pointBox(entity2.loc, context);
          reveal(box2, helpHtml("intro.points." + textId), { duration: 0 });
        });
      }, 600);
      context.on("enter.intro", function(mode) {
        if (mode.id !== "select")
          return;
        var ids = context.selectedIDs();
        if (ids.length !== 1 || ids[0] !== _pointID)
          return;
        timeout2(function() {
          var node = selectMenuItem(context, "delete").node();
          if (!node)
            return;
          continueTo(enterDelete);
        }, 50);
      });
      function continueTo(nextStep) {
        context.on("enter.intro", null);
        context.map().on("move.intro", null);
        nextStep();
      }
    }
    function enterDelete() {
      if (!_pointID)
        return chapter.restart();
      var entity = context.hasEntity(_pointID);
      if (!entity)
        return chapter.restart();
      var node = selectMenuItem(context, "delete").node();
      if (!node) {
        return continueTo(rightClickPoint);
      }
      reveal(
        ".edit-menu",
        helpHtml("intro.points.delete"),
        { padding: 50 }
      );
      timeout2(function() {
        context.map().on("move.intro", function() {
          reveal(
            ".edit-menu",
            helpHtml("intro.points.delete"),
            { duration: 0, padding: 50 }
          );
        });
      }, 300);
      context.on("exit.intro", function() {
        if (!_pointID)
          return chapter.restart();
        var entity2 = context.hasEntity(_pointID);
        if (entity2)
          return continueTo(rightClickPoint);
      });
      context.history().on("change.intro", function(changed) {
        if (changed.deleted().length) {
          continueTo(undo);
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro", null);
        context.history().on("change.intro", null);
        context.on("exit.intro", null);
        nextStep();
      }
    }
    function undo() {
      context.history().on("change.intro", function() {
        continueTo(play);
      });
      reveal(
        ".top-toolbar button.undo-button",
        helpHtml("intro.points.undo")
      );
      function continueTo(nextStep) {
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function play() {
      dispatch14.call("done");
      reveal(
        ".ideditor",
        helpHtml("intro.points.play", { next: _t("intro.areas.title") }),
        {
          tooltipBox: ".intro-nav-wrap .chapter-area",
          buttonText: _t.html("intro.ok"),
          buttonCallback: function() {
            reveal(".ideditor");
          }
        }
      );
    }
    chapter.enter = function() {
      addPoint();
    };
    chapter.exit = function() {
      timeouts.forEach(window.clearTimeout);
      context.on("enter.intro exit.intro", null);
      context.map().on("move.intro drawn.intro", null);
      context.history().on("change.intro", null);
      context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
      context.container().select(".preset-search-input").on("keydown.intro keyup.intro", null);
    };
    chapter.restart = function() {
      chapter.exit();
      chapter.enter();
    };
    return utilRebind(chapter, dispatch14, "on");
  }

  // modules/ui/intro/area.js
  function uiIntroArea(context, reveal) {
    var dispatch14 = dispatch_default("done");
    var playground = [-85.63552, 41.94159];
    var playgroundPreset = _mainPresetIndex.item("leisure/playground");
    var nameField = _mainPresetIndex.field("name");
    var descriptionField = _mainPresetIndex.field("description");
    var timeouts = [];
    var _areaID;
    var chapter = {
      title: "intro.areas.title"
    };
    function timeout2(f2, t2) {
      timeouts.push(window.setTimeout(f2, t2));
    }
    function eventCancel(d3_event) {
      d3_event.stopPropagation();
      d3_event.preventDefault();
    }
    function revealPlayground(center, text, options2) {
      var padding = 180 * Math.pow(2, context.map().zoom() - 19.5);
      var box = pad(center, padding, context);
      reveal(box, text, options2);
    }
    function addArea() {
      context.enter(modeBrowse(context));
      context.history().reset("initial");
      _areaID = null;
      var msec = transitionTime(playground, context.map().center());
      if (msec) {
        reveal(null, null, { duration: 0 });
      }
      context.map().centerZoomEase(playground, 19, msec);
      timeout2(function() {
        var tooltip = reveal(
          "button.add-area",
          helpHtml("intro.areas.add_playground")
        );
        tooltip.selectAll(".popover-inner").insert("svg", "span").attr("class", "tooltip-illustration").append("use").attr("xlink:href", "#iD-graphic-areas");
        context.on("enter.intro", function(mode) {
          if (mode.id !== "add-area")
            return;
          continueTo(startPlayground);
        });
      }, msec + 100);
      function continueTo(nextStep) {
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function startPlayground() {
      if (context.mode().id !== "add-area") {
        return chapter.restart();
      }
      _areaID = null;
      context.map().zoomEase(19.5, 500);
      timeout2(function() {
        var textId = context.lastPointerType() === "mouse" ? "starting_node_click" : "starting_node_tap";
        var startDrawString = helpHtml("intro.areas.start_playground") + helpHtml("intro.areas." + textId);
        revealPlayground(
          playground,
          startDrawString,
          { duration: 250 }
        );
        timeout2(function() {
          context.map().on("move.intro drawn.intro", function() {
            revealPlayground(
              playground,
              startDrawString,
              { duration: 0 }
            );
          });
          context.on("enter.intro", function(mode) {
            if (mode.id !== "draw-area")
              return chapter.restart();
            continueTo(continuePlayground);
          });
        }, 250);
      }, 550);
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function continuePlayground() {
      if (context.mode().id !== "draw-area") {
        return chapter.restart();
      }
      _areaID = null;
      revealPlayground(
        playground,
        helpHtml("intro.areas.continue_playground"),
        { duration: 250 }
      );
      timeout2(function() {
        context.map().on("move.intro drawn.intro", function() {
          revealPlayground(
            playground,
            helpHtml("intro.areas.continue_playground"),
            { duration: 0 }
          );
        });
      }, 250);
      context.on("enter.intro", function(mode) {
        if (mode.id === "draw-area") {
          var entity = context.hasEntity(context.selectedIDs()[0]);
          if (entity && entity.nodes.length >= 6) {
            return continueTo(finishPlayground);
          } else {
            return;
          }
        } else if (mode.id === "select") {
          _areaID = context.selectedIDs()[0];
          return continueTo(searchPresets);
        } else {
          return chapter.restart();
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function finishPlayground() {
      if (context.mode().id !== "draw-area") {
        return chapter.restart();
      }
      _areaID = null;
      var finishString = helpHtml("intro.areas.finish_area_" + (context.lastPointerType() === "mouse" ? "click" : "tap")) + helpHtml("intro.areas.finish_playground");
      revealPlayground(
        playground,
        finishString,
        { duration: 250 }
      );
      timeout2(function() {
        context.map().on("move.intro drawn.intro", function() {
          revealPlayground(
            playground,
            finishString,
            { duration: 0 }
          );
        });
      }, 250);
      context.on("enter.intro", function(mode) {
        if (mode.id === "draw-area") {
          return;
        } else if (mode.id === "select") {
          _areaID = context.selectedIDs()[0];
          return continueTo(searchPresets);
        } else {
          return chapter.restart();
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function searchPresets() {
      if (!_areaID || !context.hasEntity(_areaID)) {
        return addArea();
      }
      var ids = context.selectedIDs();
      if (context.mode().id !== "select" || !ids.length || ids[0] !== _areaID) {
        context.enter(modeSelect(context, [_areaID]));
      }
      context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
      timeout2(function() {
        context.container().select(".inspector-wrap .panewrap").style("right", "-100%");
        context.container().select(".preset-search-input").on("keydown.intro", null).on("keyup.intro", checkPresetSearch);
        reveal(
          ".preset-search-input",
          helpHtml("intro.areas.search_playground", { preset: playgroundPreset.name() })
        );
      }, 400);
      context.on("enter.intro", function(mode) {
        if (!_areaID || !context.hasEntity(_areaID)) {
          return continueTo(addArea);
        }
        var ids2 = context.selectedIDs();
        if (mode.id !== "select" || !ids2.length || ids2[0] !== _areaID) {
          context.enter(modeSelect(context, [_areaID]));
          context.container().select(".inspector-wrap .panewrap").style("right", "-100%");
          context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
          context.container().select(".preset-search-input").on("keydown.intro", null).on("keyup.intro", checkPresetSearch);
          reveal(
            ".preset-search-input",
            helpHtml("intro.areas.search_playground", { preset: playgroundPreset.name() })
          );
          context.history().on("change.intro", null);
        }
      });
      function checkPresetSearch() {
        var first = context.container().select(".preset-list-item:first-child");
        if (first.classed("preset-leisure-playground")) {
          reveal(
            first.select(".preset-list-button").node(),
            helpHtml("intro.areas.choose_playground", { preset: playgroundPreset.name() }),
            { duration: 300 }
          );
          context.container().select(".preset-search-input").on("keydown.intro", eventCancel, true).on("keyup.intro", null);
          context.history().on("change.intro", function() {
            continueTo(clickAddField);
          });
        }
      }
      function continueTo(nextStep) {
        context.container().select(".inspector-wrap").on("wheel.intro", null);
        context.on("enter.intro", null);
        context.history().on("change.intro", null);
        context.container().select(".preset-search-input").on("keydown.intro keyup.intro", null);
        nextStep();
      }
    }
    function clickAddField() {
      if (!_areaID || !context.hasEntity(_areaID)) {
        return addArea();
      }
      var ids = context.selectedIDs();
      if (context.mode().id !== "select" || !ids.length || ids[0] !== _areaID) {
        return searchPresets();
      }
      if (!context.container().select(".form-field-description").empty()) {
        return continueTo(describePlayground);
      }
      context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
      timeout2(function() {
        context.container().select(".inspector-wrap .panewrap").style("right", "0%");
        var entity = context.entity(_areaID);
        if (entity.tags.description) {
          return continueTo(play);
        }
        var box = context.container().select(".more-fields").node().getBoundingClientRect();
        if (box.top > 300) {
          var pane = context.container().select(".entity-editor-pane .inspector-body");
          var start2 = pane.node().scrollTop;
          var end = start2 + (box.top - 300);
          pane.transition().duration(250).tween("scroll.inspector", function() {
            var node = this;
            var i3 = number_default(start2, end);
            return function(t2) {
              node.scrollTop = i3(t2);
            };
          });
        }
        timeout2(function() {
          reveal(
            ".more-fields .combobox-input",
            helpHtml("intro.areas.add_field", {
              name: nameField.title(),
              description: descriptionField.title()
            }),
            { duration: 300 }
          );
          context.container().select(".more-fields .combobox-input").on("click.intro", function() {
            var watcher;
            watcher = window.setInterval(function() {
              if (!context.container().select("div.combobox").empty()) {
                window.clearInterval(watcher);
                continueTo(chooseDescriptionField);
              }
            }, 300);
          });
        }, 300);
      }, 400);
      context.on("exit.intro", function() {
        return continueTo(searchPresets);
      });
      function continueTo(nextStep) {
        context.container().select(".inspector-wrap").on("wheel.intro", null);
        context.container().select(".more-fields .combobox-input").on("click.intro", null);
        context.on("exit.intro", null);
        nextStep();
      }
    }
    function chooseDescriptionField() {
      if (!_areaID || !context.hasEntity(_areaID)) {
        return addArea();
      }
      var ids = context.selectedIDs();
      if (context.mode().id !== "select" || !ids.length || ids[0] !== _areaID) {
        return searchPresets();
      }
      if (!context.container().select(".form-field-description").empty()) {
        return continueTo(describePlayground);
      }
      if (context.container().select("div.combobox").empty()) {
        return continueTo(clickAddField);
      }
      var watcher;
      watcher = window.setInterval(function() {
        if (context.container().select("div.combobox").empty()) {
          window.clearInterval(watcher);
          timeout2(function() {
            if (context.container().select(".form-field-description").empty()) {
              continueTo(retryChooseDescription);
            } else {
              continueTo(describePlayground);
            }
          }, 300);
        }
      }, 300);
      reveal(
        "div.combobox",
        helpHtml("intro.areas.choose_field", { field: descriptionField.title() }),
        { duration: 300 }
      );
      context.on("exit.intro", function() {
        return continueTo(searchPresets);
      });
      function continueTo(nextStep) {
        if (watcher)
          window.clearInterval(watcher);
        context.on("exit.intro", null);
        nextStep();
      }
    }
    function describePlayground() {
      if (!_areaID || !context.hasEntity(_areaID)) {
        return addArea();
      }
      var ids = context.selectedIDs();
      if (context.mode().id !== "select" || !ids.length || ids[0] !== _areaID) {
        return searchPresets();
      }
      context.container().select(".inspector-wrap .panewrap").style("right", "0%");
      if (context.container().select(".form-field-description").empty()) {
        return continueTo(retryChooseDescription);
      }
      context.on("exit.intro", function() {
        continueTo(play);
      });
      reveal(
        ".entity-editor-pane",
        helpHtml("intro.areas.describe_playground", { button: { html: icon("#iD-icon-close", "inline") } }),
        { duration: 300 }
      );
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        nextStep();
      }
    }
    function retryChooseDescription() {
      if (!_areaID || !context.hasEntity(_areaID)) {
        return addArea();
      }
      var ids = context.selectedIDs();
      if (context.mode().id !== "select" || !ids.length || ids[0] !== _areaID) {
        return searchPresets();
      }
      context.container().select(".inspector-wrap .panewrap").style("right", "0%");
      reveal(
        ".entity-editor-pane",
        helpHtml("intro.areas.retry_add_field", { field: descriptionField.title() }),
        {
          buttonText: _t.html("intro.ok"),
          buttonCallback: function() {
            continueTo(clickAddField);
          }
        }
      );
      context.on("exit.intro", function() {
        return continueTo(searchPresets);
      });
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        nextStep();
      }
    }
    function play() {
      dispatch14.call("done");
      reveal(
        ".ideditor",
        helpHtml("intro.areas.play", { next: _t("intro.lines.title") }),
        {
          tooltipBox: ".intro-nav-wrap .chapter-line",
          buttonText: _t.html("intro.ok"),
          buttonCallback: function() {
            reveal(".ideditor");
          }
        }
      );
    }
    chapter.enter = function() {
      addArea();
    };
    chapter.exit = function() {
      timeouts.forEach(window.clearTimeout);
      context.on("enter.intro exit.intro", null);
      context.map().on("move.intro drawn.intro", null);
      context.history().on("change.intro", null);
      context.container().select(".inspector-wrap").on("wheel.intro", null);
      context.container().select(".preset-search-input").on("keydown.intro keyup.intro", null);
      context.container().select(".more-fields .combobox-input").on("click.intro", null);
    };
    chapter.restart = function() {
      chapter.exit();
      chapter.enter();
    };
    return utilRebind(chapter, dispatch14, "on");
  }

  // modules/ui/intro/line.js
  function uiIntroLine(context, reveal) {
    var dispatch14 = dispatch_default("done");
    var timeouts = [];
    var _tulipRoadID = null;
    var flowerRoadID = "w646";
    var tulipRoadStart = [-85.6297754121684, 41.95805253325314];
    var tulipRoadMidpoint = [-85.62975395449628, 41.95787501510204];
    var tulipRoadIntersection = [-85.62974496187628, 41.95742515554585];
    var roadCategory = _mainPresetIndex.item("category-road_minor");
    var residentialPreset = _mainPresetIndex.item("highway/residential");
    var woodRoadID = "w525";
    var woodRoadEndID = "n2862";
    var woodRoadAddNode = [-85.62390110349587, 41.95397111462291];
    var woodRoadDragEndpoint = [-85.623867390213, 41.95466987786487];
    var woodRoadDragMidpoint = [-85.62386254803509, 41.95430395953872];
    var washingtonStreetID = "w522";
    var twelfthAvenueID = "w1";
    var eleventhAvenueEndID = "n3550";
    var twelfthAvenueEndID = "n5";
    var _washingtonSegmentID = null;
    var eleventhAvenueEnd = context.entity(eleventhAvenueEndID).loc;
    var twelfthAvenueEnd = context.entity(twelfthAvenueEndID).loc;
    var deleteLinesLoc = [-85.6219395542764, 41.95228033922477];
    var twelfthAvenue = [-85.62219310052491, 41.952505413152956];
    var chapter = {
      title: "intro.lines.title"
    };
    function timeout2(f2, t2) {
      timeouts.push(window.setTimeout(f2, t2));
    }
    function eventCancel(d3_event) {
      d3_event.stopPropagation();
      d3_event.preventDefault();
    }
    function addLine() {
      context.enter(modeBrowse(context));
      context.history().reset("initial");
      var msec = transitionTime(tulipRoadStart, context.map().center());
      if (msec) {
        reveal(null, null, { duration: 0 });
      }
      context.map().centerZoomEase(tulipRoadStart, 18.5, msec);
      timeout2(function() {
        var tooltip = reveal(
          "button.add-line",
          helpHtml("intro.lines.add_line")
        );
        tooltip.selectAll(".popover-inner").insert("svg", "span").attr("class", "tooltip-illustration").append("use").attr("xlink:href", "#iD-graphic-lines");
        context.on("enter.intro", function(mode) {
          if (mode.id !== "add-line")
            return;
          continueTo(startLine);
        });
      }, msec + 100);
      function continueTo(nextStep) {
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function startLine() {
      if (context.mode().id !== "add-line")
        return chapter.restart();
      _tulipRoadID = null;
      var padding = 70 * Math.pow(2, context.map().zoom() - 18);
      var box = pad(tulipRoadStart, padding, context);
      box.height = box.height + 100;
      var textId = context.lastPointerType() === "mouse" ? "start_line" : "start_line_tap";
      var startLineString = helpHtml("intro.lines.missing_road") + "{br}" + helpHtml("intro.lines.line_draw_info") + helpHtml("intro.lines." + textId);
      reveal(box, startLineString);
      context.map().on("move.intro drawn.intro", function() {
        padding = 70 * Math.pow(2, context.map().zoom() - 18);
        box = pad(tulipRoadStart, padding, context);
        box.height = box.height + 100;
        reveal(box, startLineString, { duration: 0 });
      });
      context.on("enter.intro", function(mode) {
        if (mode.id !== "draw-line")
          return chapter.restart();
        continueTo(drawLine);
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function drawLine() {
      if (context.mode().id !== "draw-line")
        return chapter.restart();
      _tulipRoadID = context.mode().selectedIDs()[0];
      context.map().centerEase(tulipRoadMidpoint, 500);
      timeout2(function() {
        var padding = 200 * Math.pow(2, context.map().zoom() - 18.5);
        var box = pad(tulipRoadMidpoint, padding, context);
        box.height = box.height * 2;
        reveal(
          box,
          helpHtml("intro.lines.intersect", { name: _t("intro.graph.name.flower-street") })
        );
        context.map().on("move.intro drawn.intro", function() {
          padding = 200 * Math.pow(2, context.map().zoom() - 18.5);
          box = pad(tulipRoadMidpoint, padding, context);
          box.height = box.height * 2;
          reveal(
            box,
            helpHtml("intro.lines.intersect", { name: _t("intro.graph.name.flower-street") }),
            { duration: 0 }
          );
        });
      }, 550);
      context.history().on("change.intro", function() {
        if (isLineConnected()) {
          continueTo(continueLine);
        }
      });
      context.on("enter.intro", function(mode) {
        if (mode.id === "draw-line") {
          return;
        } else if (mode.id === "select") {
          continueTo(retryIntersect);
          return;
        } else {
          return chapter.restart();
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.history().on("change.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function isLineConnected() {
      var entity = _tulipRoadID && context.hasEntity(_tulipRoadID);
      if (!entity)
        return false;
      var drawNodes = context.graph().childNodes(entity);
      return drawNodes.some(function(node) {
        return context.graph().parentWays(node).some(function(parent) {
          return parent.id === flowerRoadID;
        });
      });
    }
    function retryIntersect() {
      select_default2(window).on("pointerdown.intro mousedown.intro", eventCancel, true);
      var box = pad(tulipRoadIntersection, 80, context);
      reveal(
        box,
        helpHtml("intro.lines.retry_intersect", { name: _t("intro.graph.name.flower-street") })
      );
      timeout2(chapter.restart, 3e3);
    }
    function continueLine() {
      if (context.mode().id !== "draw-line")
        return chapter.restart();
      var entity = _tulipRoadID && context.hasEntity(_tulipRoadID);
      if (!entity)
        return chapter.restart();
      context.map().centerEase(tulipRoadIntersection, 500);
      var continueLineText = helpHtml("intro.lines.continue_line") + "{br}" + helpHtml("intro.lines.finish_line_" + (context.lastPointerType() === "mouse" ? "click" : "tap")) + helpHtml("intro.lines.finish_road");
      reveal(".surface", continueLineText);
      context.on("enter.intro", function(mode) {
        if (mode.id === "draw-line") {
          return;
        } else if (mode.id === "select") {
          return continueTo(chooseCategoryRoad);
        } else {
          return chapter.restart();
        }
      });
      function continueTo(nextStep) {
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function chooseCategoryRoad() {
      if (context.mode().id !== "select")
        return chapter.restart();
      context.on("exit.intro", function() {
        return chapter.restart();
      });
      var button = context.container().select(".preset-category-road_minor .preset-list-button");
      if (button.empty())
        return chapter.restart();
      context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
      timeout2(function() {
        context.container().select(".inspector-wrap .panewrap").style("right", "-100%");
        reveal(
          button.node(),
          helpHtml("intro.lines.choose_category_road", { category: roadCategory.name() })
        );
        button.on("click.intro", function() {
          continueTo(choosePresetResidential);
        });
      }, 400);
      function continueTo(nextStep) {
        context.container().select(".inspector-wrap").on("wheel.intro", null);
        context.container().select(".preset-list-button").on("click.intro", null);
        context.on("exit.intro", null);
        nextStep();
      }
    }
    function choosePresetResidential() {
      if (context.mode().id !== "select")
        return chapter.restart();
      context.on("exit.intro", function() {
        return chapter.restart();
      });
      var subgrid = context.container().select(".preset-category-road_minor .subgrid");
      if (subgrid.empty())
        return chapter.restart();
      subgrid.selectAll(":not(.preset-highway-residential) .preset-list-button").on("click.intro", function() {
        continueTo(retryPresetResidential);
      });
      subgrid.selectAll(".preset-highway-residential .preset-list-button").on("click.intro", function() {
        continueTo(nameRoad);
      });
      timeout2(function() {
        reveal(
          subgrid.node(),
          helpHtml("intro.lines.choose_preset_residential", { preset: residentialPreset.name() }),
          { tooltipBox: ".preset-highway-residential .preset-list-button", duration: 300 }
        );
      }, 300);
      function continueTo(nextStep) {
        context.container().select(".preset-list-button").on("click.intro", null);
        context.on("exit.intro", null);
        nextStep();
      }
    }
    function retryPresetResidential() {
      if (context.mode().id !== "select")
        return chapter.restart();
      context.on("exit.intro", function() {
        return chapter.restart();
      });
      context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
      timeout2(function() {
        var button = context.container().select(".entity-editor-pane .preset-list-button");
        reveal(
          button.node(),
          helpHtml("intro.lines.retry_preset_residential", { preset: residentialPreset.name() })
        );
        button.on("click.intro", function() {
          continueTo(chooseCategoryRoad);
        });
      }, 500);
      function continueTo(nextStep) {
        context.container().select(".inspector-wrap").on("wheel.intro", null);
        context.container().select(".preset-list-button").on("click.intro", null);
        context.on("exit.intro", null);
        nextStep();
      }
    }
    function nameRoad() {
      context.on("exit.intro", function() {
        continueTo(didNameRoad);
      });
      timeout2(function() {
        reveal(
          ".entity-editor-pane",
          helpHtml("intro.lines.name_road", { button: { html: icon("#iD-icon-close", "inline") } }),
          { tooltipClass: "intro-lines-name_road" }
        );
      }, 500);
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        nextStep();
      }
    }
    function didNameRoad() {
      context.history().checkpoint("doneAddLine");
      timeout2(function() {
        reveal(".surface", helpHtml("intro.lines.did_name_road"), {
          buttonText: _t.html("intro.ok"),
          buttonCallback: function() {
            continueTo(updateLine);
          }
        });
      }, 500);
      function continueTo(nextStep) {
        nextStep();
      }
    }
    function updateLine() {
      context.history().reset("doneAddLine");
      if (!context.hasEntity(woodRoadID) || !context.hasEntity(woodRoadEndID)) {
        return chapter.restart();
      }
      var msec = transitionTime(woodRoadDragMidpoint, context.map().center());
      if (msec) {
        reveal(null, null, { duration: 0 });
      }
      context.map().centerZoomEase(woodRoadDragMidpoint, 19, msec);
      timeout2(function() {
        var padding = 250 * Math.pow(2, context.map().zoom() - 19);
        var box = pad(woodRoadDragMidpoint, padding, context);
        var advance = function() {
          continueTo(addNode);
        };
        reveal(
          box,
          helpHtml("intro.lines.update_line"),
          { buttonText: _t.html("intro.ok"), buttonCallback: advance }
        );
        context.map().on("move.intro drawn.intro", function() {
          var padding2 = 250 * Math.pow(2, context.map().zoom() - 19);
          var box2 = pad(woodRoadDragMidpoint, padding2, context);
          reveal(
            box2,
            helpHtml("intro.lines.update_line"),
            { duration: 0, buttonText: _t.html("intro.ok"), buttonCallback: advance }
          );
        });
      }, msec + 100);
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        nextStep();
      }
    }
    function addNode() {
      context.history().reset("doneAddLine");
      if (!context.hasEntity(woodRoadID) || !context.hasEntity(woodRoadEndID)) {
        return chapter.restart();
      }
      var padding = 40 * Math.pow(2, context.map().zoom() - 19);
      var box = pad(woodRoadAddNode, padding, context);
      var addNodeString = helpHtml("intro.lines.add_node" + (context.lastPointerType() === "mouse" ? "" : "_touch"));
      reveal(box, addNodeString);
      context.map().on("move.intro drawn.intro", function() {
        var padding2 = 40 * Math.pow(2, context.map().zoom() - 19);
        var box2 = pad(woodRoadAddNode, padding2, context);
        reveal(box2, addNodeString, { duration: 0 });
      });
      context.history().on("change.intro", function(changed) {
        if (!context.hasEntity(woodRoadID) || !context.hasEntity(woodRoadEndID)) {
          return continueTo(updateLine);
        }
        if (changed.created().length === 1) {
          timeout2(function() {
            continueTo(startDragEndpoint);
          }, 500);
        }
      });
      context.on("enter.intro", function(mode) {
        if (mode.id !== "select") {
          continueTo(updateLine);
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.history().on("change.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function startDragEndpoint() {
      if (!context.hasEntity(woodRoadID) || !context.hasEntity(woodRoadEndID)) {
        return continueTo(updateLine);
      }
      var padding = 100 * Math.pow(2, context.map().zoom() - 19);
      var box = pad(woodRoadDragEndpoint, padding, context);
      var startDragString = helpHtml("intro.lines.start_drag_endpoint" + (context.lastPointerType() === "mouse" ? "" : "_touch")) + helpHtml("intro.lines.drag_to_intersection");
      reveal(box, startDragString);
      context.map().on("move.intro drawn.intro", function() {
        if (!context.hasEntity(woodRoadID) || !context.hasEntity(woodRoadEndID)) {
          return continueTo(updateLine);
        }
        var padding2 = 100 * Math.pow(2, context.map().zoom() - 19);
        var box2 = pad(woodRoadDragEndpoint, padding2, context);
        reveal(box2, startDragString, { duration: 0 });
        var entity = context.entity(woodRoadEndID);
        if (geoSphericalDistance(entity.loc, woodRoadDragEndpoint) <= 4) {
          continueTo(finishDragEndpoint);
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        nextStep();
      }
    }
    function finishDragEndpoint() {
      if (!context.hasEntity(woodRoadID) || !context.hasEntity(woodRoadEndID)) {
        return continueTo(updateLine);
      }
      var padding = 100 * Math.pow(2, context.map().zoom() - 19);
      var box = pad(woodRoadDragEndpoint, padding, context);
      var finishDragString = helpHtml("intro.lines.spot_looks_good") + helpHtml("intro.lines.finish_drag_endpoint" + (context.lastPointerType() === "mouse" ? "" : "_touch"));
      reveal(box, finishDragString);
      context.map().on("move.intro drawn.intro", function() {
        if (!context.hasEntity(woodRoadID) || !context.hasEntity(woodRoadEndID)) {
          return continueTo(updateLine);
        }
        var padding2 = 100 * Math.pow(2, context.map().zoom() - 19);
        var box2 = pad(woodRoadDragEndpoint, padding2, context);
        reveal(box2, finishDragString, { duration: 0 });
        var entity = context.entity(woodRoadEndID);
        if (geoSphericalDistance(entity.loc, woodRoadDragEndpoint) > 4) {
          continueTo(startDragEndpoint);
        }
      });
      context.on("enter.intro", function() {
        continueTo(startDragMidpoint);
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function startDragMidpoint() {
      if (!context.hasEntity(woodRoadID) || !context.hasEntity(woodRoadEndID)) {
        return continueTo(updateLine);
      }
      if (context.selectedIDs().indexOf(woodRoadID) === -1) {
        context.enter(modeSelect(context, [woodRoadID]));
      }
      var padding = 80 * Math.pow(2, context.map().zoom() - 19);
      var box = pad(woodRoadDragMidpoint, padding, context);
      reveal(box, helpHtml("intro.lines.start_drag_midpoint"));
      context.map().on("move.intro drawn.intro", function() {
        if (!context.hasEntity(woodRoadID) || !context.hasEntity(woodRoadEndID)) {
          return continueTo(updateLine);
        }
        var padding2 = 80 * Math.pow(2, context.map().zoom() - 19);
        var box2 = pad(woodRoadDragMidpoint, padding2, context);
        reveal(box2, helpHtml("intro.lines.start_drag_midpoint"), { duration: 0 });
      });
      context.history().on("change.intro", function(changed) {
        if (changed.created().length === 1) {
          continueTo(continueDragMidpoint);
        }
      });
      context.on("enter.intro", function(mode) {
        if (mode.id !== "select") {
          context.enter(modeSelect(context, [woodRoadID]));
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.history().on("change.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function continueDragMidpoint() {
      if (!context.hasEntity(woodRoadID) || !context.hasEntity(woodRoadEndID)) {
        return continueTo(updateLine);
      }
      var padding = 100 * Math.pow(2, context.map().zoom() - 19);
      var box = pad(woodRoadDragEndpoint, padding, context);
      box.height += 400;
      var advance = function() {
        context.history().checkpoint("doneUpdateLine");
        continueTo(deleteLines);
      };
      reveal(
        box,
        helpHtml("intro.lines.continue_drag_midpoint"),
        { buttonText: _t.html("intro.ok"), buttonCallback: advance }
      );
      context.map().on("move.intro drawn.intro", function() {
        if (!context.hasEntity(woodRoadID) || !context.hasEntity(woodRoadEndID)) {
          return continueTo(updateLine);
        }
        var padding2 = 100 * Math.pow(2, context.map().zoom() - 19);
        var box2 = pad(woodRoadDragEndpoint, padding2, context);
        box2.height += 400;
        reveal(
          box2,
          helpHtml("intro.lines.continue_drag_midpoint"),
          { duration: 0, buttonText: _t.html("intro.ok"), buttonCallback: advance }
        );
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        nextStep();
      }
    }
    function deleteLines() {
      context.history().reset("doneUpdateLine");
      context.enter(modeBrowse(context));
      if (!context.hasEntity(washingtonStreetID) || !context.hasEntity(twelfthAvenueID) || !context.hasEntity(eleventhAvenueEndID)) {
        return chapter.restart();
      }
      var msec = transitionTime(deleteLinesLoc, context.map().center());
      if (msec) {
        reveal(null, null, { duration: 0 });
      }
      context.map().centerZoomEase(deleteLinesLoc, 18, msec);
      timeout2(function() {
        var padding = 200 * Math.pow(2, context.map().zoom() - 18);
        var box = pad(deleteLinesLoc, padding, context);
        box.top -= 200;
        box.height += 400;
        var advance = function() {
          continueTo(rightClickIntersection);
        };
        reveal(
          box,
          helpHtml("intro.lines.delete_lines", { street: _t("intro.graph.name.12th-avenue") }),
          { buttonText: _t.html("intro.ok"), buttonCallback: advance }
        );
        context.map().on("move.intro drawn.intro", function() {
          var padding2 = 200 * Math.pow(2, context.map().zoom() - 18);
          var box2 = pad(deleteLinesLoc, padding2, context);
          box2.top -= 200;
          box2.height += 400;
          reveal(
            box2,
            helpHtml("intro.lines.delete_lines", { street: _t("intro.graph.name.12th-avenue") }),
            { duration: 0, buttonText: _t.html("intro.ok"), buttonCallback: advance }
          );
        });
        context.history().on("change.intro", function() {
          timeout2(function() {
            continueTo(deleteLines);
          }, 500);
        });
      }, msec + 100);
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function rightClickIntersection() {
      context.history().reset("doneUpdateLine");
      context.enter(modeBrowse(context));
      context.map().centerZoomEase(eleventhAvenueEnd, 18, 500);
      var rightClickString = helpHtml("intro.lines.split_street", {
        street1: _t("intro.graph.name.11th-avenue"),
        street2: _t("intro.graph.name.washington-street")
      }) + helpHtml("intro.lines." + (context.lastPointerType() === "mouse" ? "rightclick_intersection" : "edit_menu_intersection_touch"));
      timeout2(function() {
        var padding = 60 * Math.pow(2, context.map().zoom() - 18);
        var box = pad(eleventhAvenueEnd, padding, context);
        reveal(box, rightClickString);
        context.map().on("move.intro drawn.intro", function() {
          var padding2 = 60 * Math.pow(2, context.map().zoom() - 18);
          var box2 = pad(eleventhAvenueEnd, padding2, context);
          reveal(
            box2,
            rightClickString,
            { duration: 0 }
          );
        });
        context.on("enter.intro", function(mode) {
          if (mode.id !== "select")
            return;
          var ids = context.selectedIDs();
          if (ids.length !== 1 || ids[0] !== eleventhAvenueEndID)
            return;
          timeout2(function() {
            var node = selectMenuItem(context, "split").node();
            if (!node)
              return;
            continueTo(splitIntersection);
          }, 50);
        });
        context.history().on("change.intro", function() {
          timeout2(function() {
            continueTo(deleteLines);
          }, 300);
        });
      }, 600);
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function splitIntersection() {
      if (!context.hasEntity(washingtonStreetID) || !context.hasEntity(twelfthAvenueID) || !context.hasEntity(eleventhAvenueEndID)) {
        return continueTo(deleteLines);
      }
      var node = selectMenuItem(context, "split").node();
      if (!node) {
        return continueTo(rightClickIntersection);
      }
      var wasChanged = false;
      _washingtonSegmentID = null;
      reveal(
        ".edit-menu",
        helpHtml(
          "intro.lines.split_intersection",
          { street: _t("intro.graph.name.washington-street") }
        ),
        { padding: 50 }
      );
      context.map().on("move.intro drawn.intro", function() {
        var node2 = selectMenuItem(context, "split").node();
        if (!wasChanged && !node2) {
          return continueTo(rightClickIntersection);
        }
        reveal(
          ".edit-menu",
          helpHtml(
            "intro.lines.split_intersection",
            { street: _t("intro.graph.name.washington-street") }
          ),
          { duration: 0, padding: 50 }
        );
      });
      context.history().on("change.intro", function(changed) {
        wasChanged = true;
        timeout2(function() {
          if (context.history().undoAnnotation() === _t("operations.split.annotation.line", { n: 1 })) {
            _washingtonSegmentID = changed.created()[0].id;
            continueTo(didSplit);
          } else {
            _washingtonSegmentID = null;
            continueTo(retrySplit);
          }
        }, 300);
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function retrySplit() {
      context.enter(modeBrowse(context));
      context.map().centerZoomEase(eleventhAvenueEnd, 18, 500);
      var advance = function() {
        continueTo(rightClickIntersection);
      };
      var padding = 60 * Math.pow(2, context.map().zoom() - 18);
      var box = pad(eleventhAvenueEnd, padding, context);
      reveal(
        box,
        helpHtml("intro.lines.retry_split"),
        { buttonText: _t.html("intro.ok"), buttonCallback: advance }
      );
      context.map().on("move.intro drawn.intro", function() {
        var padding2 = 60 * Math.pow(2, context.map().zoom() - 18);
        var box2 = pad(eleventhAvenueEnd, padding2, context);
        reveal(
          box2,
          helpHtml("intro.lines.retry_split"),
          { duration: 0, buttonText: _t.html("intro.ok"), buttonCallback: advance }
        );
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        nextStep();
      }
    }
    function didSplit() {
      if (!_washingtonSegmentID || !context.hasEntity(_washingtonSegmentID) || !context.hasEntity(washingtonStreetID) || !context.hasEntity(twelfthAvenueID) || !context.hasEntity(eleventhAvenueEndID)) {
        return continueTo(rightClickIntersection);
      }
      var ids = context.selectedIDs();
      var string = "intro.lines.did_split_" + (ids.length > 1 ? "multi" : "single");
      var street = _t("intro.graph.name.washington-street");
      var padding = 200 * Math.pow(2, context.map().zoom() - 18);
      var box = pad(twelfthAvenue, padding, context);
      box.width = box.width / 2;
      reveal(
        box,
        helpHtml(string, { street1: street, street2: street }),
        { duration: 500 }
      );
      timeout2(function() {
        context.map().centerZoomEase(twelfthAvenue, 18, 500);
        context.map().on("move.intro drawn.intro", function() {
          var padding2 = 200 * Math.pow(2, context.map().zoom() - 18);
          var box2 = pad(twelfthAvenue, padding2, context);
          box2.width = box2.width / 2;
          reveal(
            box2,
            helpHtml(string, { street1: street, street2: street }),
            { duration: 0 }
          );
        });
      }, 600);
      context.on("enter.intro", function() {
        var ids2 = context.selectedIDs();
        if (ids2.length === 1 && ids2[0] === _washingtonSegmentID) {
          continueTo(multiSelect);
        }
      });
      context.history().on("change.intro", function() {
        if (!_washingtonSegmentID || !context.hasEntity(_washingtonSegmentID) || !context.hasEntity(washingtonStreetID) || !context.hasEntity(twelfthAvenueID) || !context.hasEntity(eleventhAvenueEndID)) {
          return continueTo(rightClickIntersection);
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function multiSelect() {
      if (!_washingtonSegmentID || !context.hasEntity(_washingtonSegmentID) || !context.hasEntity(washingtonStreetID) || !context.hasEntity(twelfthAvenueID) || !context.hasEntity(eleventhAvenueEndID)) {
        return continueTo(rightClickIntersection);
      }
      var ids = context.selectedIDs();
      var hasWashington = ids.indexOf(_washingtonSegmentID) !== -1;
      var hasTwelfth = ids.indexOf(twelfthAvenueID) !== -1;
      if (hasWashington && hasTwelfth) {
        return continueTo(multiRightClick);
      } else if (!hasWashington && !hasTwelfth) {
        return continueTo(didSplit);
      }
      context.map().centerZoomEase(twelfthAvenue, 18, 500);
      timeout2(function() {
        var selected, other, padding, box;
        if (hasWashington) {
          selected = _t("intro.graph.name.washington-street");
          other = _t("intro.graph.name.12th-avenue");
          padding = 60 * Math.pow(2, context.map().zoom() - 18);
          box = pad(twelfthAvenueEnd, padding, context);
          box.width *= 3;
        } else {
          selected = _t("intro.graph.name.12th-avenue");
          other = _t("intro.graph.name.washington-street");
          padding = 200 * Math.pow(2, context.map().zoom() - 18);
          box = pad(twelfthAvenue, padding, context);
          box.width /= 2;
        }
        reveal(
          box,
          helpHtml(
            "intro.lines.multi_select",
            { selected, other1: other }
          ) + " " + helpHtml(
            "intro.lines.add_to_selection_" + (context.lastPointerType() === "mouse" ? "click" : "touch"),
            { selected, other2: other }
          )
        );
        context.map().on("move.intro drawn.intro", function() {
          if (hasWashington) {
            selected = _t("intro.graph.name.washington-street");
            other = _t("intro.graph.name.12th-avenue");
            padding = 60 * Math.pow(2, context.map().zoom() - 18);
            box = pad(twelfthAvenueEnd, padding, context);
            box.width *= 3;
          } else {
            selected = _t("intro.graph.name.12th-avenue");
            other = _t("intro.graph.name.washington-street");
            padding = 200 * Math.pow(2, context.map().zoom() - 18);
            box = pad(twelfthAvenue, padding, context);
            box.width /= 2;
          }
          reveal(
            box,
            helpHtml(
              "intro.lines.multi_select",
              { selected, other1: other }
            ) + " " + helpHtml(
              "intro.lines.add_to_selection_" + (context.lastPointerType() === "mouse" ? "click" : "touch"),
              { selected, other2: other }
            ),
            { duration: 0 }
          );
        });
        context.on("enter.intro", function() {
          continueTo(multiSelect);
        });
        context.history().on("change.intro", function() {
          if (!_washingtonSegmentID || !context.hasEntity(_washingtonSegmentID) || !context.hasEntity(washingtonStreetID) || !context.hasEntity(twelfthAvenueID) || !context.hasEntity(eleventhAvenueEndID)) {
            return continueTo(rightClickIntersection);
          }
        });
      }, 600);
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function multiRightClick() {
      if (!_washingtonSegmentID || !context.hasEntity(_washingtonSegmentID) || !context.hasEntity(washingtonStreetID) || !context.hasEntity(twelfthAvenueID) || !context.hasEntity(eleventhAvenueEndID)) {
        return continueTo(rightClickIntersection);
      }
      var padding = 200 * Math.pow(2, context.map().zoom() - 18);
      var box = pad(twelfthAvenue, padding, context);
      var rightClickString = helpHtml("intro.lines.multi_select_success") + helpHtml("intro.lines.multi_" + (context.lastPointerType() === "mouse" ? "rightclick" : "edit_menu_touch"));
      reveal(box, rightClickString);
      context.map().on("move.intro drawn.intro", function() {
        var padding2 = 200 * Math.pow(2, context.map().zoom() - 18);
        var box2 = pad(twelfthAvenue, padding2, context);
        reveal(box2, rightClickString, { duration: 0 });
      });
      context.ui().editMenu().on("toggled.intro", function(open) {
        if (!open)
          return;
        timeout2(function() {
          var ids = context.selectedIDs();
          if (ids.length === 2 && ids.indexOf(twelfthAvenueID) !== -1 && ids.indexOf(_washingtonSegmentID) !== -1) {
            var node = selectMenuItem(context, "delete").node();
            if (!node)
              return;
            continueTo(multiDelete);
          } else if (ids.length === 1 && ids.indexOf(_washingtonSegmentID) !== -1) {
            return continueTo(multiSelect);
          } else {
            return continueTo(didSplit);
          }
        }, 300);
      });
      context.history().on("change.intro", function() {
        if (!_washingtonSegmentID || !context.hasEntity(_washingtonSegmentID) || !context.hasEntity(washingtonStreetID) || !context.hasEntity(twelfthAvenueID) || !context.hasEntity(eleventhAvenueEndID)) {
          return continueTo(rightClickIntersection);
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.ui().editMenu().on("toggled.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function multiDelete() {
      if (!_washingtonSegmentID || !context.hasEntity(_washingtonSegmentID) || !context.hasEntity(washingtonStreetID) || !context.hasEntity(twelfthAvenueID) || !context.hasEntity(eleventhAvenueEndID)) {
        return continueTo(rightClickIntersection);
      }
      var node = selectMenuItem(context, "delete").node();
      if (!node)
        return continueTo(multiRightClick);
      reveal(
        ".edit-menu",
        helpHtml("intro.lines.multi_delete"),
        { padding: 50 }
      );
      context.map().on("move.intro drawn.intro", function() {
        reveal(
          ".edit-menu",
          helpHtml("intro.lines.multi_delete"),
          { duration: 0, padding: 50 }
        );
      });
      context.on("exit.intro", function() {
        if (context.hasEntity(_washingtonSegmentID) || context.hasEntity(twelfthAvenueID)) {
          return continueTo(multiSelect);
        }
      });
      context.history().on("change.intro", function() {
        if (context.hasEntity(_washingtonSegmentID) || context.hasEntity(twelfthAvenueID)) {
          continueTo(retryDelete);
        } else {
          continueTo(play);
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("exit.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function retryDelete() {
      context.enter(modeBrowse(context));
      var padding = 200 * Math.pow(2, context.map().zoom() - 18);
      var box = pad(twelfthAvenue, padding, context);
      reveal(box, helpHtml("intro.lines.retry_delete"), {
        buttonText: _t.html("intro.ok"),
        buttonCallback: function() {
          continueTo(multiSelect);
        }
      });
      function continueTo(nextStep) {
        nextStep();
      }
    }
    function play() {
      dispatch14.call("done");
      reveal(
        ".ideditor",
        helpHtml("intro.lines.play", { next: _t("intro.buildings.title") }),
        {
          tooltipBox: ".intro-nav-wrap .chapter-building",
          buttonText: _t.html("intro.ok"),
          buttonCallback: function() {
            reveal(".ideditor");
          }
        }
      );
    }
    chapter.enter = function() {
      addLine();
    };
    chapter.exit = function() {
      timeouts.forEach(window.clearTimeout);
      select_default2(window).on("pointerdown.intro mousedown.intro", null, true);
      context.on("enter.intro exit.intro", null);
      context.map().on("move.intro drawn.intro", null);
      context.history().on("change.intro", null);
      context.container().select(".inspector-wrap").on("wheel.intro", null);
      context.container().select(".preset-list-button").on("click.intro", null);
    };
    chapter.restart = function() {
      chapter.exit();
      chapter.enter();
    };
    return utilRebind(chapter, dispatch14, "on");
  }

  // modules/ui/intro/building.js
  function uiIntroBuilding(context, reveal) {
    var dispatch14 = dispatch_default("done");
    var house = [-85.62815, 41.95638];
    var tank = [-85.62732, 41.95347];
    var buildingCatetory = _mainPresetIndex.item("category-building");
    var housePreset = _mainPresetIndex.item("building/house");
    var tankPreset = _mainPresetIndex.item("man_made/storage_tank");
    var timeouts = [];
    var _houseID = null;
    var _tankID = null;
    var chapter = {
      title: "intro.buildings.title"
    };
    function timeout2(f2, t2) {
      timeouts.push(window.setTimeout(f2, t2));
    }
    function eventCancel(d3_event) {
      d3_event.stopPropagation();
      d3_event.preventDefault();
    }
    function revealHouse(center, text, options2) {
      var padding = 160 * Math.pow(2, context.map().zoom() - 20);
      var box = pad(center, padding, context);
      reveal(box, text, options2);
    }
    function revealTank(center, text, options2) {
      var padding = 190 * Math.pow(2, context.map().zoom() - 19.5);
      var box = pad(center, padding, context);
      reveal(box, text, options2);
    }
    function addHouse() {
      context.enter(modeBrowse(context));
      context.history().reset("initial");
      _houseID = null;
      var msec = transitionTime(house, context.map().center());
      if (msec) {
        reveal(null, null, { duration: 0 });
      }
      context.map().centerZoomEase(house, 19, msec);
      timeout2(function() {
        var tooltip = reveal(
          "button.add-area",
          helpHtml("intro.buildings.add_building")
        );
        tooltip.selectAll(".popover-inner").insert("svg", "span").attr("class", "tooltip-illustration").append("use").attr("xlink:href", "#iD-graphic-buildings");
        context.on("enter.intro", function(mode) {
          if (mode.id !== "add-area")
            return;
          continueTo(startHouse);
        });
      }, msec + 100);
      function continueTo(nextStep) {
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function startHouse() {
      if (context.mode().id !== "add-area") {
        return continueTo(addHouse);
      }
      _houseID = null;
      context.map().zoomEase(20, 500);
      timeout2(function() {
        var startString = helpHtml("intro.buildings.start_building") + helpHtml("intro.buildings.building_corner_" + (context.lastPointerType() === "mouse" ? "click" : "tap"));
        revealHouse(house, startString);
        context.map().on("move.intro drawn.intro", function() {
          revealHouse(house, startString, { duration: 0 });
        });
        context.on("enter.intro", function(mode) {
          if (mode.id !== "draw-area")
            return chapter.restart();
          continueTo(continueHouse);
        });
      }, 550);
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function continueHouse() {
      if (context.mode().id !== "draw-area") {
        return continueTo(addHouse);
      }
      _houseID = null;
      var continueString = helpHtml("intro.buildings.continue_building") + "{br}" + helpHtml("intro.areas.finish_area_" + (context.lastPointerType() === "mouse" ? "click" : "tap")) + helpHtml("intro.buildings.finish_building");
      revealHouse(house, continueString);
      context.map().on("move.intro drawn.intro", function() {
        revealHouse(house, continueString, { duration: 0 });
      });
      context.on("enter.intro", function(mode) {
        if (mode.id === "draw-area") {
          return;
        } else if (mode.id === "select") {
          var graph = context.graph();
          var way = context.entity(context.selectedIDs()[0]);
          var nodes = graph.childNodes(way);
          var points = utilArrayUniq(nodes).map(function(n3) {
            return context.projection(n3.loc);
          });
          if (isMostlySquare(points)) {
            _houseID = way.id;
            return continueTo(chooseCategoryBuilding);
          } else {
            return continueTo(retryHouse);
          }
        } else {
          return chapter.restart();
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function retryHouse() {
      var onClick = function() {
        continueTo(addHouse);
      };
      revealHouse(
        house,
        helpHtml("intro.buildings.retry_building"),
        { buttonText: _t.html("intro.ok"), buttonCallback: onClick }
      );
      context.map().on("move.intro drawn.intro", function() {
        revealHouse(
          house,
          helpHtml("intro.buildings.retry_building"),
          { duration: 0, buttonText: _t.html("intro.ok"), buttonCallback: onClick }
        );
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        nextStep();
      }
    }
    function chooseCategoryBuilding() {
      if (!_houseID || !context.hasEntity(_houseID)) {
        return addHouse();
      }
      var ids = context.selectedIDs();
      if (context.mode().id !== "select" || !ids.length || ids[0] !== _houseID) {
        context.enter(modeSelect(context, [_houseID]));
      }
      context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
      timeout2(function() {
        context.container().select(".inspector-wrap .panewrap").style("right", "-100%");
        var button = context.container().select(".preset-category-building .preset-list-button");
        reveal(
          button.node(),
          helpHtml("intro.buildings.choose_category_building", { category: buildingCatetory.name() })
        );
        button.on("click.intro", function() {
          button.on("click.intro", null);
          continueTo(choosePresetHouse);
        });
      }, 400);
      context.on("enter.intro", function(mode) {
        if (!_houseID || !context.hasEntity(_houseID)) {
          return continueTo(addHouse);
        }
        var ids2 = context.selectedIDs();
        if (mode.id !== "select" || !ids2.length || ids2[0] !== _houseID) {
          return continueTo(chooseCategoryBuilding);
        }
      });
      function continueTo(nextStep) {
        context.container().select(".inspector-wrap").on("wheel.intro", null);
        context.container().select(".preset-list-button").on("click.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function choosePresetHouse() {
      if (!_houseID || !context.hasEntity(_houseID)) {
        return addHouse();
      }
      var ids = context.selectedIDs();
      if (context.mode().id !== "select" || !ids.length || ids[0] !== _houseID) {
        context.enter(modeSelect(context, [_houseID]));
      }
      context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
      timeout2(function() {
        context.container().select(".inspector-wrap .panewrap").style("right", "-100%");
        var button = context.container().select(".preset-building-house .preset-list-button");
        reveal(
          button.node(),
          helpHtml("intro.buildings.choose_preset_house", { preset: housePreset.name() }),
          { duration: 300 }
        );
        button.on("click.intro", function() {
          button.on("click.intro", null);
          continueTo(closeEditorHouse);
        });
      }, 400);
      context.on("enter.intro", function(mode) {
        if (!_houseID || !context.hasEntity(_houseID)) {
          return continueTo(addHouse);
        }
        var ids2 = context.selectedIDs();
        if (mode.id !== "select" || !ids2.length || ids2[0] !== _houseID) {
          return continueTo(chooseCategoryBuilding);
        }
      });
      function continueTo(nextStep) {
        context.container().select(".inspector-wrap").on("wheel.intro", null);
        context.container().select(".preset-list-button").on("click.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function closeEditorHouse() {
      if (!_houseID || !context.hasEntity(_houseID)) {
        return addHouse();
      }
      var ids = context.selectedIDs();
      if (context.mode().id !== "select" || !ids.length || ids[0] !== _houseID) {
        context.enter(modeSelect(context, [_houseID]));
      }
      context.history().checkpoint("hasHouse");
      context.on("exit.intro", function() {
        continueTo(rightClickHouse);
      });
      timeout2(function() {
        reveal(
          ".entity-editor-pane",
          helpHtml("intro.buildings.close", { button: { html: icon("#iD-icon-close", "inline") } })
        );
      }, 500);
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        nextStep();
      }
    }
    function rightClickHouse() {
      if (!_houseID)
        return chapter.restart();
      context.enter(modeBrowse(context));
      context.history().reset("hasHouse");
      var zoom = context.map().zoom();
      if (zoom < 20) {
        zoom = 20;
      }
      context.map().centerZoomEase(house, zoom, 500);
      context.on("enter.intro", function(mode) {
        if (mode.id !== "select")
          return;
        var ids = context.selectedIDs();
        if (ids.length !== 1 || ids[0] !== _houseID)
          return;
        timeout2(function() {
          var node = selectMenuItem(context, "orthogonalize").node();
          if (!node)
            return;
          continueTo(clickSquare);
        }, 50);
      });
      context.map().on("move.intro drawn.intro", function() {
        var rightclickString = helpHtml("intro.buildings." + (context.lastPointerType() === "mouse" ? "rightclick_building" : "edit_menu_building_touch"));
        revealHouse(house, rightclickString, { duration: 0 });
      });
      context.history().on("change.intro", function() {
        continueTo(rightClickHouse);
      });
      function continueTo(nextStep) {
        context.on("enter.intro", null);
        context.map().on("move.intro drawn.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function clickSquare() {
      if (!_houseID)
        return chapter.restart();
      var entity = context.hasEntity(_houseID);
      if (!entity)
        return continueTo(rightClickHouse);
      var node = selectMenuItem(context, "orthogonalize").node();
      if (!node) {
        return continueTo(rightClickHouse);
      }
      var wasChanged = false;
      reveal(
        ".edit-menu",
        helpHtml("intro.buildings.square_building"),
        { padding: 50 }
      );
      context.on("enter.intro", function(mode) {
        if (mode.id === "browse") {
          continueTo(rightClickHouse);
        } else if (mode.id === "move" || mode.id === "rotate") {
          continueTo(retryClickSquare);
        }
      });
      context.map().on("move.intro", function() {
        var node2 = selectMenuItem(context, "orthogonalize").node();
        if (!wasChanged && !node2) {
          return continueTo(rightClickHouse);
        }
        reveal(
          ".edit-menu",
          helpHtml("intro.buildings.square_building"),
          { duration: 0, padding: 50 }
        );
      });
      context.history().on("change.intro", function() {
        wasChanged = true;
        context.history().on("change.intro", null);
        timeout2(function() {
          if (context.history().undoAnnotation() === _t("operations.orthogonalize.annotation.feature", { n: 1 })) {
            continueTo(doneSquare);
          } else {
            continueTo(retryClickSquare);
          }
        }, 500);
      });
      function continueTo(nextStep) {
        context.on("enter.intro", null);
        context.map().on("move.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function retryClickSquare() {
      context.enter(modeBrowse(context));
      revealHouse(house, helpHtml("intro.buildings.retry_square"), {
        buttonText: _t.html("intro.ok"),
        buttonCallback: function() {
          continueTo(rightClickHouse);
        }
      });
      function continueTo(nextStep) {
        nextStep();
      }
    }
    function doneSquare() {
      context.history().checkpoint("doneSquare");
      revealHouse(house, helpHtml("intro.buildings.done_square"), {
        buttonText: _t.html("intro.ok"),
        buttonCallback: function() {
          continueTo(addTank);
        }
      });
      function continueTo(nextStep) {
        nextStep();
      }
    }
    function addTank() {
      context.enter(modeBrowse(context));
      context.history().reset("doneSquare");
      _tankID = null;
      var msec = transitionTime(tank, context.map().center());
      if (msec) {
        reveal(null, null, { duration: 0 });
      }
      context.map().centerZoomEase(tank, 19.5, msec);
      timeout2(function() {
        reveal(
          "button.add-area",
          helpHtml("intro.buildings.add_tank")
        );
        context.on("enter.intro", function(mode) {
          if (mode.id !== "add-area")
            return;
          continueTo(startTank);
        });
      }, msec + 100);
      function continueTo(nextStep) {
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function startTank() {
      if (context.mode().id !== "add-area") {
        return continueTo(addTank);
      }
      _tankID = null;
      timeout2(function() {
        var startString = helpHtml("intro.buildings.start_tank") + helpHtml("intro.buildings.tank_edge_" + (context.lastPointerType() === "mouse" ? "click" : "tap"));
        revealTank(tank, startString);
        context.map().on("move.intro drawn.intro", function() {
          revealTank(tank, startString, { duration: 0 });
        });
        context.on("enter.intro", function(mode) {
          if (mode.id !== "draw-area")
            return chapter.restart();
          continueTo(continueTank);
        });
      }, 550);
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function continueTank() {
      if (context.mode().id !== "draw-area") {
        return continueTo(addTank);
      }
      _tankID = null;
      var continueString = helpHtml("intro.buildings.continue_tank") + "{br}" + helpHtml("intro.areas.finish_area_" + (context.lastPointerType() === "mouse" ? "click" : "tap")) + helpHtml("intro.buildings.finish_tank");
      revealTank(tank, continueString);
      context.map().on("move.intro drawn.intro", function() {
        revealTank(tank, continueString, { duration: 0 });
      });
      context.on("enter.intro", function(mode) {
        if (mode.id === "draw-area") {
          return;
        } else if (mode.id === "select") {
          _tankID = context.selectedIDs()[0];
          return continueTo(searchPresetTank);
        } else {
          return continueTo(addTank);
        }
      });
      function continueTo(nextStep) {
        context.map().on("move.intro drawn.intro", null);
        context.on("enter.intro", null);
        nextStep();
      }
    }
    function searchPresetTank() {
      if (!_tankID || !context.hasEntity(_tankID)) {
        return addTank();
      }
      var ids = context.selectedIDs();
      if (context.mode().id !== "select" || !ids.length || ids[0] !== _tankID) {
        context.enter(modeSelect(context, [_tankID]));
      }
      context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
      timeout2(function() {
        context.container().select(".inspector-wrap .panewrap").style("right", "-100%");
        context.container().select(".preset-search-input").on("keydown.intro", null).on("keyup.intro", checkPresetSearch);
        reveal(
          ".preset-search-input",
          helpHtml("intro.buildings.search_tank", { preset: tankPreset.name() })
        );
      }, 400);
      context.on("enter.intro", function(mode) {
        if (!_tankID || !context.hasEntity(_tankID)) {
          return continueTo(addTank);
        }
        var ids2 = context.selectedIDs();
        if (mode.id !== "select" || !ids2.length || ids2[0] !== _tankID) {
          context.enter(modeSelect(context, [_tankID]));
          context.container().select(".inspector-wrap .panewrap").style("right", "-100%");
          context.container().select(".inspector-wrap").on("wheel.intro", eventCancel);
          context.container().select(".preset-search-input").on("keydown.intro", null).on("keyup.intro", checkPresetSearch);
          reveal(
            ".preset-search-input",
            helpHtml("intro.buildings.search_tank", { preset: tankPreset.name() })
          );
          context.history().on("change.intro", null);
        }
      });
      function checkPresetSearch() {
        var first = context.container().select(".preset-list-item:first-child");
        if (first.classed("preset-man_made-storage_tank")) {
          reveal(
            first.select(".preset-list-button").node(),
            helpHtml("intro.buildings.choose_tank", { preset: tankPreset.name() }),
            { duration: 300 }
          );
          context.container().select(".preset-search-input").on("keydown.intro", eventCancel, true).on("keyup.intro", null);
          context.history().on("change.intro", function() {
            continueTo(closeEditorTank);
          });
        }
      }
      function continueTo(nextStep) {
        context.container().select(".inspector-wrap").on("wheel.intro", null);
        context.on("enter.intro", null);
        context.history().on("change.intro", null);
        context.container().select(".preset-search-input").on("keydown.intro keyup.intro", null);
        nextStep();
      }
    }
    function closeEditorTank() {
      if (!_tankID || !context.hasEntity(_tankID)) {
        return addTank();
      }
      var ids = context.selectedIDs();
      if (context.mode().id !== "select" || !ids.length || ids[0] !== _tankID) {
        context.enter(modeSelect(context, [_tankID]));
      }
      context.history().checkpoint("hasTank");
      context.on("exit.intro", function() {
        continueTo(rightClickTank);
      });
      timeout2(function() {
        reveal(
          ".entity-editor-pane",
          helpHtml("intro.buildings.close", { button: { html: icon("#iD-icon-close", "inline") } })
        );
      }, 500);
      function continueTo(nextStep) {
        context.on("exit.intro", null);
        nextStep();
      }
    }
    function rightClickTank() {
      if (!_tankID)
        return continueTo(addTank);
      context.enter(modeBrowse(context));
      context.history().reset("hasTank");
      context.map().centerEase(tank, 500);
      timeout2(function() {
        context.on("enter.intro", function(mode) {
          if (mode.id !== "select")
            return;
          var ids = context.selectedIDs();
          if (ids.length !== 1 || ids[0] !== _tankID)
            return;
          timeout2(function() {
            var node = selectMenuItem(context, "circularize").node();
            if (!node)
              return;
            continueTo(clickCircle);
          }, 50);
        });
        var rightclickString = helpHtml("intro.buildings." + (context.lastPointerType() === "mouse" ? "rightclick_tank" : "edit_menu_tank_touch"));
        revealTank(tank, rightclickString);
        context.map().on("move.intro drawn.intro", function() {
          revealTank(tank, rightclickString, { duration: 0 });
        });
        context.history().on("change.intro", function() {
          continueTo(rightClickTank);
        });
      }, 600);
      function continueTo(nextStep) {
        context.on("enter.intro", null);
        context.map().on("move.intro drawn.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function clickCircle() {
      if (!_tankID)
        return chapter.restart();
      var entity = context.hasEntity(_tankID);
      if (!entity)
        return continueTo(rightClickTank);
      var node = selectMenuItem(context, "circularize").node();
      if (!node) {
        return continueTo(rightClickTank);
      }
      var wasChanged = false;
      reveal(
        ".edit-menu",
        helpHtml("intro.buildings.circle_tank"),
        { padding: 50 }
      );
      context.on("enter.intro", function(mode) {
        if (mode.id === "browse") {
          continueTo(rightClickTank);
        } else if (mode.id === "move" || mode.id === "rotate") {
          continueTo(retryClickCircle);
        }
      });
      context.map().on("move.intro", function() {
        var node2 = selectMenuItem(context, "circularize").node();
        if (!wasChanged && !node2) {
          return continueTo(rightClickTank);
        }
        reveal(
          ".edit-menu",
          helpHtml("intro.buildings.circle_tank"),
          { duration: 0, padding: 50 }
        );
      });
      context.history().on("change.intro", function() {
        wasChanged = true;
        context.history().on("change.intro", null);
        timeout2(function() {
          if (context.history().undoAnnotation() === _t("operations.circularize.annotation.feature", { n: 1 })) {
            continueTo(play);
          } else {
            continueTo(retryClickCircle);
          }
        }, 500);
      });
      function continueTo(nextStep) {
        context.on("enter.intro", null);
        context.map().on("move.intro", null);
        context.history().on("change.intro", null);
        nextStep();
      }
    }
    function retryClickCircle() {
      context.enter(modeBrowse(context));
      revealTank(tank, helpHtml("intro.buildings.retry_circle"), {
        buttonText: _t.html("intro.ok"),
        buttonCallback: function() {
          continueTo(rightClickTank);
        }
      });
      function continueTo(nextStep) {
        nextStep();
      }
    }
    function play() {
      dispatch14.call("done");
      reveal(
        ".ideditor",
        helpHtml("intro.buildings.play", { next: _t("intro.startediting.title") }),
        {
          tooltipBox: ".intro-nav-wrap .chapter-startEditing",
          buttonText: _t.html("intro.ok"),
          buttonCallback: function() {
            reveal(".ideditor");
          }
        }
      );
    }
    chapter.enter = function() {
      addHouse();
    };
    chapter.exit = function() {
      timeouts.forEach(window.clearTimeout);
      context.on("enter.intro exit.intro", null);
      context.map().on("move.intro drawn.intro", null);
      context.history().on("change.intro", null);
      context.container().select(".inspector-wrap").on("wheel.intro", null);
      context.container().select(".preset-search-input").on("keydown.intro keyup.intro", null);
      context.container().select(".more-fields .combobox-input").on("click.intro", null);
    };
    chapter.restart = function() {
      chapter.exit();
      chapter.enter();
    };
    return utilRebind(chapter, dispatch14, "on");
  }

  // modules/ui/intro/start_editing.js
  function uiIntroStartEditing(context, reveal) {
    var dispatch14 = dispatch_default("done", "startEditing");
    var modalSelection = select_default2(null);
    var chapter = {
      title: "intro.startediting.title"
    };
    function showHelp() {
      reveal(
        ".map-control.help-control",
        helpHtml("intro.startediting.help"),
        {
          buttonText: _t.html("intro.ok"),
          buttonCallback: function() {
            shortcuts();
          }
        }
      );
    }
    function shortcuts() {
      reveal(
        ".map-control.help-control",
        helpHtml("intro.startediting.shortcuts"),
        {
          buttonText: _t.html("intro.ok"),
          buttonCallback: function() {
            showSave();
          }
        }
      );
    }
    function showSave() {
      context.container().selectAll(".shaded").remove();
      reveal(
        ".top-toolbar button.save",
        helpHtml("intro.startediting.save"),
        {
          buttonText: _t.html("intro.ok"),
          buttonCallback: function() {
            showStart();
          }
        }
      );
    }
    function showStart() {
      context.container().selectAll(".shaded").remove();
      modalSelection = uiModal(context.container());
      modalSelection.select(".modal").attr("class", "modal-splash modal");
      modalSelection.selectAll(".close").remove();
      var startbutton = modalSelection.select(".content").attr("class", "fillL").append("button").attr("class", "modal-section huge-modal-button").on("click", function() {
        modalSelection.remove();
      });
      startbutton.append("svg").attr("class", "illustration").append("use").attr("xlink:href", "#iD-logo-walkthrough");
      startbutton.append("h2").call(_t.append("intro.startediting.start"));
      dispatch14.call("startEditing");
    }
    chapter.enter = function() {
      showHelp();
    };
    chapter.exit = function() {
      modalSelection.remove();
      context.container().selectAll(".shaded").remove();
    };
    return utilRebind(chapter, dispatch14, "on");
  }

  // modules/ui/intro/intro.js
  var chapterUi = {
    welcome: uiIntroWelcome,
    navigation: uiIntroNavigation,
    point: uiIntroPoint,
    area: uiIntroArea,
    line: uiIntroLine,
    building: uiIntroBuilding,
    startEditing: uiIntroStartEditing
  };
  var chapterFlow = [
    "welcome",
    "navigation",
    "point",
    "area",
    "line",
    "building",
    "startEditing"
  ];
  function uiIntro(context) {
    const INTRO_IMAGERY = "EsriWorldImageryClarity";
    let _introGraph = {};
    let _currChapter;
    function intro(selection2) {
      _mainFileFetcher.get("intro_graph").then((dataIntroGraph) => {
        for (let id2 in dataIntroGraph) {
          if (!_introGraph[id2]) {
            _introGraph[id2] = osmEntity(localize(dataIntroGraph[id2]));
          }
        }
        selection2.call(startIntro);
      }).catch(function() {
      });
    }
    function startIntro(selection2) {
      context.enter(modeBrowse(context));
      let osm = context.connection();
      let history = context.history().toJSON();
      let hash = window.location.hash;
      let center = context.map().center();
      let zoom = context.map().zoom();
      let background = context.background().baseLayerSource();
      let overlays = context.background().overlayLayerSources();
      let opacity = context.container().selectAll(".main-map .layer-background").style("opacity");
      let caches = osm && osm.caches();
      let baseEntities = context.history().graph().base().entities;
      context.ui().sidebar.expand();
      context.container().selectAll("button.sidebar-toggle").classed("disabled", true);
      context.inIntro(true);
      if (osm) {
        osm.toggle(false).reset();
      }
      context.history().reset();
      context.history().merge(Object.values(coreGraph().load(_introGraph).entities));
      context.history().checkpoint("initial");
      let imagery = context.background().findSource(INTRO_IMAGERY);
      if (imagery) {
        context.background().baseLayerSource(imagery);
      } else {
        context.background().bing();
      }
      overlays.forEach((d2) => context.background().toggleOverlayLayer(d2));
      let layers = context.layers();
      layers.all().forEach((item) => {
        if (typeof item.layer.enabled === "function") {
          item.layer.enabled(item.id === "osm");
        }
      });
      context.container().selectAll(".main-map .layer-background").style("opacity", 1);
      let curtain = uiCurtain(context.container().node());
      selection2.call(curtain);
      corePreferences("walkthrough_started", "yes");
      let storedProgress = corePreferences("walkthrough_progress") || "";
      let progress = storedProgress.split(";").filter(Boolean);
      let chapters = chapterFlow.map((chapter, i3) => {
        let s2 = chapterUi[chapter](context, curtain.reveal).on("done", () => {
          buttons.filter((d2) => d2.title === s2.title).classed("finished", true);
          if (i3 < chapterFlow.length - 1) {
            const next = chapterFlow[i3 + 1];
            context.container().select("button.chapter-".concat(next)).classed("next", true);
          }
          progress.push(chapter);
          corePreferences("walkthrough_progress", utilArrayUniq(progress).join(";"));
        });
        return s2;
      });
      chapters[chapters.length - 1].on("startEditing", () => {
        progress.push("startEditing");
        corePreferences("walkthrough_progress", utilArrayUniq(progress).join(";"));
        let incomplete = utilArrayDifference(chapterFlow, progress);
        if (!incomplete.length) {
          corePreferences("walkthrough_completed", "yes");
        }
        curtain.remove();
        navwrap.remove();
        context.container().selectAll(".main-map .layer-background").style("opacity", opacity);
        context.container().selectAll("button.sidebar-toggle").classed("disabled", false);
        if (osm) {
          osm.toggle(true).reset().caches(caches);
        }
        context.history().reset().merge(Object.values(baseEntities));
        context.background().baseLayerSource(background);
        overlays.forEach((d2) => context.background().toggleOverlayLayer(d2));
        if (history) {
          context.history().fromJSON(history, false);
        }
        context.map().centerZoom(center, zoom);
        window.location.replace(hash);
        context.inIntro(false);
      });
      let navwrap = selection2.append("div").attr("class", "intro-nav-wrap fillD");
      navwrap.append("svg").attr("class", "intro-nav-wrap-logo").append("use").attr("xlink:href", "#iD-logo-walkthrough");
      let buttonwrap = navwrap.append("div").attr("class", "joined").selectAll("button.chapter");
      let buttons = buttonwrap.data(chapters).enter().append("button").attr("class", (d2, i3) => "chapter chapter-".concat(chapterFlow[i3])).on("click", enterChapter);
      buttons.append("span").html((d2) => _t.html(d2.title));
      buttons.append("span").attr("class", "status").call(svgIcon(_mainLocalizer.textDirection() === "rtl" ? "#iD-icon-backward" : "#iD-icon-forward", "inline"));
      enterChapter(null, chapters[0]);
      function enterChapter(d3_event, newChapter) {
        if (_currChapter) {
          _currChapter.exit();
        }
        context.enter(modeBrowse(context));
        _currChapter = newChapter;
        _currChapter.enter();
        buttons.classed("next", false).classed("active", (d2) => d2.title === _currChapter.title);
      }
    }
    return intro;
  }

  // modules/ui/issues_info.js
  function uiIssuesInfo(context) {
    var warningsItem = {
      id: "warnings",
      count: 0,
      iconID: "iD-icon-alert",
      descriptionID: "issues.warnings_and_errors"
    };
    var resolvedItem = {
      id: "resolved",
      count: 0,
      iconID: "iD-icon-apply",
      descriptionID: "issues.user_resolved_issues"
    };
    function update(selection2) {
      var shownItems = [];
      var liveIssues = context.validator().getIssues({
        what: corePreferences("validate-what") || "edited",
        where: corePreferences("validate-where") || "all"
      });
      if (liveIssues.length) {
        warningsItem.count = liveIssues.length;
        shownItems.push(warningsItem);
      }
      if (corePreferences("validate-what") === "all") {
        var resolvedIssues = context.validator().getResolvedIssues();
        if (resolvedIssues.length) {
          resolvedItem.count = resolvedIssues.length;
          shownItems.push(resolvedItem);
        }
      }
      var chips = selection2.selectAll(".chip").data(shownItems, function(d2) {
        return d2.id;
      });
      chips.exit().remove();
      var enter = chips.enter().append("a").attr("class", function(d2) {
        return "chip " + d2.id + "-count";
      }).attr("href", "#").each(function(d2) {
        var chipSelection = select_default2(this);
        var tooltipBehavior = uiTooltip().placement("top").title(() => _t.append(d2.descriptionID));
        chipSelection.call(tooltipBehavior).on("click", function(d3_event) {
          d3_event.preventDefault();
          tooltipBehavior.hide(select_default2(this));
          context.ui().togglePanes(context.container().select(".map-panes .issues-pane"));
        });
        chipSelection.call(svgIcon("#" + d2.iconID));
      });
      enter.append("span").attr("class", "count");
      enter.merge(chips).selectAll("span.count").text(function(d2) {
        return d2.count.toString();
      });
    }
    return function(selection2) {
      update(selection2);
      context.validator().on("validated.infobox", function() {
        update(selection2);
      });
    };
  }

  // modules/ui/map_in_map.js
  function uiMapInMap(context) {
    function mapInMap(selection2) {
      var backgroundLayer = rendererTileLayer(context);
      var overlayLayers = {};
      var projection2 = geoRawMercator();
      var dataLayer = svgData(projection2, context).showLabels(false);
      var debugLayer = svgDebug(projection2, context);
      var zoom = zoom_default2().scaleExtent([geoZoomToScale(0.5), geoZoomToScale(24)]).on("start", zoomStarted).on("zoom", zoomed).on("end", zoomEnded);
      var wrap2 = select_default2(null);
      var tiles = select_default2(null);
      var viewport = select_default2(null);
      var _isTransformed = false;
      var _isHidden = true;
      var _skipEvents = false;
      var _gesture = null;
      var _zDiff = 6;
      var _dMini;
      var _cMini;
      var _tStart;
      var _tCurr;
      var _timeoutID;
      function zoomStarted() {
        if (_skipEvents)
          return;
        _tStart = _tCurr = projection2.transform();
        _gesture = null;
      }
      function zoomed(d3_event) {
        if (_skipEvents)
          return;
        var x2 = d3_event.transform.x;
        var y2 = d3_event.transform.y;
        var k2 = d3_event.transform.k;
        var isZooming = k2 !== _tStart.k;
        var isPanning = x2 !== _tStart.x || y2 !== _tStart.y;
        if (!isZooming && !isPanning) {
          return;
        }
        if (!_gesture) {
          _gesture = isZooming ? "zoom" : "pan";
        }
        var tMini = projection2.transform();
        var tX, tY, scale;
        if (_gesture === "zoom") {
          scale = k2 / tMini.k;
          tX = (_cMini[0] / scale - _cMini[0]) * scale;
          tY = (_cMini[1] / scale - _cMini[1]) * scale;
        } else {
          k2 = tMini.k;
          scale = 1;
          tX = x2 - tMini.x;
          tY = y2 - tMini.y;
        }
        utilSetTransform(tiles, tX, tY, scale);
        utilSetTransform(viewport, 0, 0, scale);
        _isTransformed = true;
        _tCurr = identity2.translate(x2, y2).scale(k2);
        var zMain = geoScaleToZoom(context.projection.scale());
        var zMini = geoScaleToZoom(k2);
        _zDiff = zMain - zMini;
        queueRedraw();
      }
      function zoomEnded() {
        if (_skipEvents)
          return;
        if (_gesture !== "pan")
          return;
        updateProjection();
        _gesture = null;
        context.map().center(projection2.invert(_cMini));
      }
      function updateProjection() {
        var loc = context.map().center();
        var tMain = context.projection.transform();
        var zMain = geoScaleToZoom(tMain.k);
        var zMini = Math.max(zMain - _zDiff, 0.5);
        var kMini = geoZoomToScale(zMini);
        projection2.translate([tMain.x, tMain.y]).scale(kMini);
        var point2 = projection2(loc);
        var mouse = _gesture === "pan" ? geoVecSubtract([_tCurr.x, _tCurr.y], [_tStart.x, _tStart.y]) : [0, 0];
        var xMini = _cMini[0] - point2[0] + tMain.x + mouse[0];
        var yMini = _cMini[1] - point2[1] + tMain.y + mouse[1];
        projection2.translate([xMini, yMini]).clipExtent([[0, 0], _dMini]);
        _tCurr = projection2.transform();
        if (_isTransformed) {
          utilSetTransform(tiles, 0, 0);
          utilSetTransform(viewport, 0, 0);
          _isTransformed = false;
        }
        zoom.scaleExtent([geoZoomToScale(0.5), geoZoomToScale(zMain - 3)]);
        _skipEvents = true;
        wrap2.call(zoom.transform, _tCurr);
        _skipEvents = false;
      }
      function redraw() {
        clearTimeout(_timeoutID);
        if (_isHidden)
          return;
        updateProjection();
        var zMini = geoScaleToZoom(projection2.scale());
        tiles = wrap2.selectAll(".map-in-map-tiles").data([0]);
        tiles = tiles.enter().append("div").attr("class", "map-in-map-tiles").merge(tiles);
        backgroundLayer.source(context.background().baseLayerSource()).projection(projection2).dimensions(_dMini);
        var background = tiles.selectAll(".map-in-map-background").data([0]);
        background.enter().append("div").attr("class", "map-in-map-background").merge(background).call(backgroundLayer);
        var overlaySources = context.background().overlayLayerSources();
        var activeOverlayLayers = [];
        for (var i3 = 0; i3 < overlaySources.length; i3++) {
          if (overlaySources[i3].validZoom(zMini)) {
            if (!overlayLayers[i3])
              overlayLayers[i3] = rendererTileLayer(context);
            activeOverlayLayers.push(overlayLayers[i3].source(overlaySources[i3]).projection(projection2).dimensions(_dMini));
          }
        }
        var overlay = tiles.selectAll(".map-in-map-overlay").data([0]);
        overlay = overlay.enter().append("div").attr("class", "map-in-map-overlay").merge(overlay);
        var overlays = overlay.selectAll("div").data(activeOverlayLayers, function(d2) {
          return d2.source().name();
        });
        overlays.exit().remove();
        overlays = overlays.enter().append("div").merge(overlays).each(function(layer) {
          select_default2(this).call(layer);
        });
        var dataLayers = tiles.selectAll(".map-in-map-data").data([0]);
        dataLayers.exit().remove();
        dataLayers = dataLayers.enter().append("svg").attr("class", "map-in-map-data").merge(dataLayers).call(dataLayer).call(debugLayer);
        if (_gesture !== "pan") {
          var getPath = path_default(projection2);
          var bbox2 = { type: "Polygon", coordinates: [context.map().extent().polygon()] };
          viewport = wrap2.selectAll(".map-in-map-viewport").data([0]);
          viewport = viewport.enter().append("svg").attr("class", "map-in-map-viewport").merge(viewport);
          var path = viewport.selectAll(".map-in-map-bbox").data([bbox2]);
          path.enter().append("path").attr("class", "map-in-map-bbox").merge(path).attr("d", getPath).classed("thick", function(d2) {
            return getPath.area(d2) < 30;
          });
        }
      }
      function queueRedraw() {
        clearTimeout(_timeoutID);
        _timeoutID = setTimeout(function() {
          redraw();
        }, 750);
      }
      function toggle(d3_event) {
        if (d3_event)
          d3_event.preventDefault();
        _isHidden = !_isHidden;
        context.container().select(".minimap-toggle-item").classed("active", !_isHidden).select("input").property("checked", !_isHidden);
        if (_isHidden) {
          wrap2.style("display", "block").style("opacity", "1").transition().duration(200).style("opacity", "0").on("end", function() {
            selection2.selectAll(".map-in-map").style("display", "none");
          });
        } else {
          wrap2.style("display", "block").style("opacity", "0").transition().duration(200).style("opacity", "1").on("end", function() {
            redraw();
          });
        }
      }
      uiMapInMap.toggle = toggle;
      wrap2 = selection2.selectAll(".map-in-map").data([0]);
      wrap2 = wrap2.enter().append("div").attr("class", "map-in-map").style("display", _isHidden ? "none" : "block").call(zoom).on("dblclick.zoom", null).merge(wrap2);
      _dMini = [200, 150];
      _cMini = geoVecScale(_dMini, 0.5);
      context.map().on("drawn.map-in-map", function(drawn) {
        if (drawn.full === true) {
          redraw();
        }
      });
      redraw();
      context.keybinding().on(_t("background.minimap.key"), toggle);
    }
    return mapInMap;
  }

  // modules/ui/notice.js
  function uiNotice(context) {
    return function(selection2) {
      var div = selection2.append("div").attr("class", "notice");
      var button = div.append("button").attr("class", "zoom-to notice fillD").on("click", function() {
        context.map().zoomEase(context.minEditableZoom());
      }).on("wheel", function(d3_event) {
        var e22 = new WheelEvent(d3_event.type, d3_event);
        context.surface().node().dispatchEvent(e22);
      });
      button.call(svgIcon("#iD-icon-plus", "pre-text")).append("span").attr("class", "label").call(_t.append("zoom_in_edit"));
      function disableTooHigh() {
        var canEdit = context.map().zoom() >= context.minEditableZoom();
        div.style("display", canEdit ? "none" : "block");
      }
      context.map().on("move.notice", debounce_default(disableTooHigh, 500));
      disableTooHigh();
    };
  }

  // modules/ui/photoviewer.js
  function uiPhotoviewer(context) {
    var dispatch14 = dispatch_default("resize");
    var _pointerPrefix = "PointerEvent" in window ? "pointer" : "mouse";
    function photoviewer(selection2) {
      selection2.append("button").attr("class", "thumb-hide").attr("title", _t("icons.close")).on("click", function() {
        if (services.streetside) {
          services.streetside.hideViewer(context);
        }
        if (services.mapillary) {
          services.mapillary.hideViewer(context);
        }
        if (services.kartaview) {
          services.kartaview.hideViewer(context);
        }
        if (services.mapilio) {
          services.mapilio.hideViewer(context);
        }
        if (services.vegbilder) {
          services.vegbilder.hideViewer(context);
        }
      }).append("div").call(svgIcon("#iD-icon-close"));
      function preventDefault(d3_event) {
        d3_event.preventDefault();
      }
      selection2.append("button").attr("class", "resize-handle-xy").on("touchstart touchdown touchend", preventDefault).on(
        _pointerPrefix + "down",
        buildResizeListener(selection2, "resize", dispatch14, { resizeOnX: true, resizeOnY: true })
      );
      selection2.append("button").attr("class", "resize-handle-x").on("touchstart touchdown touchend", preventDefault).on(
        _pointerPrefix + "down",
        buildResizeListener(selection2, "resize", dispatch14, { resizeOnX: true })
      );
      selection2.append("button").attr("class", "resize-handle-y").on("touchstart touchdown touchend", preventDefault).on(
        _pointerPrefix + "down",
        buildResizeListener(selection2, "resize", dispatch14, { resizeOnY: true })
      );
      function buildResizeListener(target, eventName, dispatch15, options2) {
        var resizeOnX = !!options2.resizeOnX;
        var resizeOnY = !!options2.resizeOnY;
        var minHeight = options2.minHeight || 240;
        var minWidth = options2.minWidth || 320;
        var pointerId;
        var startX;
        var startY;
        var startWidth;
        var startHeight;
        function startResize(d3_event) {
          if (pointerId !== (d3_event.pointerId || "mouse"))
            return;
          d3_event.preventDefault();
          d3_event.stopPropagation();
          var mapSize = context.map().dimensions();
          if (resizeOnX) {
            var maxWidth = mapSize[0];
            var newWidth = clamp3(startWidth + d3_event.clientX - startX, minWidth, maxWidth);
            target.style("width", newWidth + "px");
          }
          if (resizeOnY) {
            var maxHeight = mapSize[1] - 90;
            var newHeight = clamp3(startHeight + startY - d3_event.clientY, minHeight, maxHeight);
            target.style("height", newHeight + "px");
          }
          dispatch15.call(eventName, target, subtractPadding(utilGetDimensions(target, true), target));
        }
        function clamp3(num, min3, max3) {
          return Math.max(min3, Math.min(num, max3));
        }
        function stopResize(d3_event) {
          if (pointerId !== (d3_event.pointerId || "mouse"))
            return;
          d3_event.preventDefault();
          d3_event.stopPropagation();
          select_default2(window).on("." + eventName, null);
        }
        return function initResize(d3_event) {
          d3_event.preventDefault();
          d3_event.stopPropagation();
          pointerId = d3_event.pointerId || "mouse";
          startX = d3_event.clientX;
          startY = d3_event.clientY;
          var targetRect = target.node().getBoundingClientRect();
          startWidth = targetRect.width;
          startHeight = targetRect.height;
          select_default2(window).on(_pointerPrefix + "move." + eventName, startResize, false).on(_pointerPrefix + "up." + eventName, stopResize, false);
          if (_pointerPrefix === "pointer") {
            select_default2(window).on("pointercancel." + eventName, stopResize, false);
          }
        };
      }
    }
    photoviewer.onMapResize = function() {
      var photoviewer2 = context.container().select(".photoviewer");
      var content = context.container().select(".main-content");
      var mapDimensions = utilGetDimensions(content, true);
      var photoDimensions = utilGetDimensions(photoviewer2, true);
      if (photoDimensions[0] > mapDimensions[0] || photoDimensions[1] > mapDimensions[1] - 90) {
        var setPhotoDimensions = [
          Math.min(photoDimensions[0], mapDimensions[0]),
          Math.min(photoDimensions[1], mapDimensions[1] - 90)
        ];
        photoviewer2.style("width", setPhotoDimensions[0] + "px").style("height", setPhotoDimensions[1] + "px");
        dispatch14.call("resize", photoviewer2, subtractPadding(setPhotoDimensions, photoviewer2));
      }
    };
    function subtractPadding(dimensions, selection2) {
      return [
        dimensions[0] - parseFloat(selection2.style("padding-left")) - parseFloat(selection2.style("padding-right")),
        dimensions[1] - parseFloat(selection2.style("padding-top")) - parseFloat(selection2.style("padding-bottom"))
      ];
    }
    return utilRebind(photoviewer, dispatch14, "on");
  }

  // modules/ui/restore.js
  function uiRestore(context) {
    return function(selection2) {
      if (!context.history().hasRestorableChanges())
        return;
      let modalSelection = uiModal(selection2, true);
      modalSelection.select(".modal").attr("class", "modal fillL");
      let introModal = modalSelection.select(".content");
      introModal.append("div").attr("class", "modal-section").append("h3").call(_t.append("restore.heading"));
      introModal.append("div").attr("class", "modal-section").append("p").call(_t.append("restore.description"));
      let buttonWrap = introModal.append("div").attr("class", "modal-actions");
      let restore = buttonWrap.append("button").attr("class", "restore").on("click", () => {
        context.history().restore();
        modalSelection.remove();
      });
      restore.append("svg").attr("class", "logo logo-restore").append("use").attr("xlink:href", "#iD-logo-restore");
      restore.append("div").call(_t.append("restore.restore"));
      let reset = buttonWrap.append("button").attr("class", "reset").on("click", () => {
        context.history().clearSaved();
        modalSelection.remove();
      });
      reset.append("svg").attr("class", "logo logo-reset").append("use").attr("xlink:href", "#iD-logo-reset");
      reset.append("div").call(_t.append("restore.reset"));
      restore.node().focus();
    };
  }

  // modules/ui/scale.js
  function uiScale(context) {
    var projection2 = context.projection, isImperial = !_mainLocalizer.usesMetric(), maxLength = 180, tickHeight = 8;
    function scaleDefs(loc1, loc2) {
      var lat = (loc2[1] + loc1[1]) / 2, conversion = isImperial ? 3.28084 : 1, dist = geoLonToMeters(loc2[0] - loc1[0], lat) * conversion, scale = { dist: 0, px: 0, text: "" }, buckets, i3, val, dLon;
      if (isImperial) {
        buckets = [528e4, 528e3, 52800, 5280, 500, 50, 5, 1];
      } else {
        buckets = [5e6, 5e5, 5e4, 5e3, 500, 50, 5, 1];
      }
      for (i3 = 0; i3 < buckets.length; i3++) {
        val = buckets[i3];
        if (dist >= val) {
          scale.dist = Math.floor(dist / val) * val;
          break;
        } else {
          scale.dist = +dist.toFixed(2);
        }
      }
      dLon = geoMetersToLon(scale.dist / conversion, lat);
      scale.px = Math.round(projection2([loc1[0] + dLon, loc1[1]])[0]);
      scale.text = displayLength(scale.dist / conversion, isImperial);
      return scale;
    }
    function update(selection2) {
      var dims = context.map().dimensions(), loc1 = projection2.invert([0, dims[1]]), loc2 = projection2.invert([maxLength, dims[1]]), scale = scaleDefs(loc1, loc2);
      selection2.select(".scale-path").attr("d", "M0.5,0.5v" + tickHeight + "h" + scale.px + "v-" + tickHeight);
      selection2.select(".scale-text").style(_mainLocalizer.textDirection() === "ltr" ? "left" : "right", scale.px + 16 + "px").text(scale.text);
    }
    return function(selection2) {
      function switchUnits() {
        isImperial = !isImperial;
        selection2.call(update);
      }
      var scalegroup = selection2.append("svg").attr("class", "scale").on("click", switchUnits).append("g").attr("transform", "translate(10,11)");
      scalegroup.append("path").attr("class", "scale-path");
      selection2.append("div").attr("class", "scale-text");
      selection2.call(update);
      context.map().on("move.scale", function() {
        update(selection2);
      });
    };
  }

  // modules/ui/shortcuts.js
  function uiShortcuts(context) {
    var detected = utilDetect();
    var _activeTab = 0;
    var _modalSelection;
    var _selection = select_default2(null);
    var _dataShortcuts;
    function shortcutsModal(_modalSelection2) {
      _modalSelection2.select(".modal").classed("modal-shortcuts", true);
      var content = _modalSelection2.select(".content");
      content.append("div").attr("class", "modal-section header").append("h2").call(_t.append("shortcuts.title"));
      _mainFileFetcher.get("shortcuts").then(function(data) {
        _dataShortcuts = data;
        content.call(render);
      }).catch(function() {
      });
    }
    function render(selection2) {
      if (!_dataShortcuts)
        return;
      var wrapper = selection2.selectAll(".wrapper").data([0]);
      var wrapperEnter = wrapper.enter().append("div").attr("class", "wrapper modal-section");
      var tabsBar = wrapperEnter.append("div").attr("class", "tabs-bar");
      var shortcutsList = wrapperEnter.append("div").attr("class", "shortcuts-list");
      wrapper = wrapper.merge(wrapperEnter);
      var tabs = tabsBar.selectAll(".tab").data(_dataShortcuts);
      var tabsEnter = tabs.enter().append("a").attr("class", "tab").attr("href", "#").on("click", function(d3_event, d2) {
        d3_event.preventDefault();
        var i3 = _dataShortcuts.indexOf(d2);
        _activeTab = i3;
        render(selection2);
      });
      tabsEnter.append("span").html(function(d2) {
        return _t.html(d2.text);
      });
      wrapper.selectAll(".tab").classed("active", function(d2, i3) {
        return i3 === _activeTab;
      });
      var shortcuts = shortcutsList.selectAll(".shortcut-tab").data(_dataShortcuts);
      var shortcutsEnter = shortcuts.enter().append("div").attr("class", function(d2) {
        return "shortcut-tab shortcut-tab-" + d2.tab;
      });
      var columnsEnter = shortcutsEnter.selectAll(".shortcut-column").data(function(d2) {
        return d2.columns;
      }).enter().append("table").attr("class", "shortcut-column");
      var rowsEnter = columnsEnter.selectAll(".shortcut-row").data(function(d2) {
        return d2.rows;
      }).enter().append("tr").attr("class", "shortcut-row");
      var sectionRows = rowsEnter.filter(function(d2) {
        return !d2.shortcuts;
      });
      sectionRows.append("td");
      sectionRows.append("td").attr("class", "shortcut-section").append("h3").html(function(d2) {
        return _t.html(d2.text);
      });
      var shortcutRows = rowsEnter.filter(function(d2) {
        return d2.shortcuts;
      });
      var shortcutKeys = shortcutRows.append("td").attr("class", "shortcut-keys");
      var modifierKeys = shortcutKeys.filter(function(d2) {
        return d2.modifiers;
      });
      modifierKeys.selectAll("kbd.modifier").data(function(d2) {
        if (detected.os === "win" && d2.text === "shortcuts.editing.commands.redo") {
          return ["\u2318"];
        } else if (detected.os !== "mac" && d2.text === "shortcuts.browsing.display_options.fullscreen") {
          return [];
        } else {
          return d2.modifiers;
        }
      }).enter().each(function() {
        var selection3 = select_default2(this);
        selection3.append("kbd").attr("class", "modifier").text(function(d2) {
          return uiCmd.display(d2);
        });
        selection3.append("span").text("+");
      });
      shortcutKeys.selectAll("kbd.shortcut").data(function(d2) {
        var arr = d2.shortcuts;
        if (detected.os === "win" && d2.text === "shortcuts.editing.commands.redo") {
          arr = ["Y"];
        } else if (detected.os !== "mac" && d2.text === "shortcuts.browsing.display_options.fullscreen") {
          arr = ["F11"];
        }
        arr = arr.map(function(s2) {
          return uiCmd.display(s2.indexOf(".") !== -1 ? _t(s2) : s2);
        });
        return utilArrayUniq(arr).map(function(s2) {
          return {
            shortcut: s2,
            separator: d2.separator,
            suffix: d2.suffix
          };
        });
      }).enter().each(function(d2, i3, nodes) {
        var selection3 = select_default2(this);
        var click = d2.shortcut.toLowerCase().match(/(.*).click/);
        if (click && click[1]) {
          selection3.call(svgIcon("#iD-walkthrough-mouse-" + click[1], "operation"));
        } else if (d2.shortcut.toLowerCase() === "long-press") {
          selection3.call(svgIcon("#iD-walkthrough-longpress", "longpress operation"));
        } else if (d2.shortcut.toLowerCase() === "tap") {
          selection3.call(svgIcon("#iD-walkthrough-tap", "tap operation"));
        } else {
          selection3.append("kbd").attr("class", "shortcut").text(function(d4) {
            return d4.shortcut;
          });
        }
        if (i3 < nodes.length - 1) {
          selection3.append("span").html(d2.separator || "\xA0" + _t.html("shortcuts.or") + "\xA0");
        } else if (i3 === nodes.length - 1 && d2.suffix) {
          selection3.append("span").text(d2.suffix);
        }
      });
      shortcutKeys.filter(function(d2) {
        return d2.gesture;
      }).each(function() {
        var selection3 = select_default2(this);
        selection3.append("span").text("+");
        selection3.append("span").attr("class", "gesture").html(function(d2) {
          return _t.html(d2.gesture);
        });
      });
      shortcutRows.append("td").attr("class", "shortcut-desc").html(function(d2) {
        return d2.text ? _t.html(d2.text) : "\xA0";
      });
      wrapper.selectAll(".shortcut-tab").style("display", function(d2, i3) {
        return i3 === _activeTab ? "flex" : "none";
      });
    }
    return function(selection2, show) {
      _selection = selection2;
      if (show) {
        _modalSelection = uiModal(selection2);
        _modalSelection.call(shortcutsModal);
      } else {
        context.keybinding().on([_t("shortcuts.toggle.key"), "?"], function() {
          if (context.container().selectAll(".modal-shortcuts").size()) {
            if (_modalSelection) {
              _modalSelection.close();
              _modalSelection = null;
            }
          } else {
            _modalSelection = uiModal(_selection);
            _modalSelection.call(shortcutsModal);
          }
        });
      }
    };
  }

  // modules/ui/data_header.js
  function uiDataHeader() {
    var _datum;
    function dataHeader(selection2) {
      var header = selection2.selectAll(".data-header").data(
        _datum ? [_datum] : [],
        function(d2) {
          return d2.__featurehash__;
        }
      );
      header.exit().remove();
      var headerEnter = header.enter().append("div").attr("class", "data-header");
      var iconEnter = headerEnter.append("div").attr("class", "data-header-icon");
      iconEnter.append("div").attr("class", "preset-icon-28").call(svgIcon("#iD-icon-data", "note-fill"));
      headerEnter.append("div").attr("class", "data-header-label").call(_t.append("map_data.layers.custom.title"));
    }
    dataHeader.datum = function(val) {
      if (!arguments.length)
        return _datum;
      _datum = val;
      return this;
    };
    return dataHeader;
  }

  // modules/ui/combobox.js
  var _comboHideTimerID;
  function uiCombobox(context, klass) {
    var dispatch14 = dispatch_default("accept", "cancel", "update");
    var container = context.container();
    var _suggestions = [];
    var _data = [];
    var _fetched = {};
    var _selected = null;
    var _canAutocomplete = true;
    var _caseSensitive = false;
    var _cancelFetch = false;
    var _minItems = 2;
    var _tDown = 0;
    var _mouseEnterHandler, _mouseLeaveHandler;
    var _fetcher = function(val, cb) {
      cb(_data.filter(function(d2) {
        var terms = d2.terms || [];
        terms.push(d2.value);
        if (d2.key) {
          terms.push(d2.key);
        }
        return terms.some(function(term) {
          return term.toString().toLowerCase().indexOf(val.toLowerCase()) !== -1;
        });
      }));
    };
    var combobox = function(input, attachTo) {
      if (!input || input.empty())
        return;
      input.classed("combobox-input", true).on("focus.combo-input", focus).on("blur.combo-input", blur).on("keydown.combo-input", keydown).on("keyup.combo-input", keyup).on("input.combo-input", change).on("mousedown.combo-input", mousedown).each(function() {
        var parent = this.parentNode;
        var sibling = this.nextSibling;
        select_default2(parent).selectAll(".combobox-caret").filter(function(d2) {
          return d2 === input.node();
        }).data([input.node()]).enter().insert("div", function() {
          return sibling;
        }).attr("class", "combobox-caret").on("mousedown.combo-caret", function(d3_event) {
          d3_event.preventDefault();
          input.node().focus();
          mousedown(d3_event);
        }).on("mouseup.combo-caret", function(d3_event) {
          d3_event.preventDefault();
          mouseup(d3_event);
        });
      });
      function mousedown(d3_event) {
        if (d3_event.button !== 0)
          return;
        if (input.classed("disabled"))
          return;
        _tDown = +/* @__PURE__ */ new Date();
        var start2 = input.property("selectionStart");
        var end = input.property("selectionEnd");
        if (start2 !== end) {
          var val = utilGetSetValue(input);
          input.node().setSelectionRange(val.length, val.length);
          return;
        }
        input.on("mouseup.combo-input", mouseup);
      }
      function mouseup(d3_event) {
        input.on("mouseup.combo-input", null);
        if (d3_event.button !== 0)
          return;
        if (input.classed("disabled"))
          return;
        if (input.node() !== document.activeElement)
          return;
        var start2 = input.property("selectionStart");
        var end = input.property("selectionEnd");
        if (start2 !== end)
          return;
        var combo = container.selectAll(".combobox");
        if (combo.empty() || combo.datum() !== input.node()) {
          var tOrig = _tDown;
          window.setTimeout(function() {
            if (tOrig !== _tDown)
              return;
            fetchComboData("", function() {
              show();
              render();
            });
          }, 250);
        } else {
          hide();
        }
      }
      function focus() {
        fetchComboData("");
      }
      function blur() {
        _comboHideTimerID = window.setTimeout(hide, 75);
      }
      function show() {
        hide();
        container.insert("div", ":first-child").datum(input.node()).attr("class", "combobox" + (klass ? " combobox-" + klass : "")).style("position", "absolute").style("display", "block").style("left", "0px").on("mousedown.combo-container", function(d3_event) {
          d3_event.preventDefault();
        });
        container.on("scroll.combo-scroll", render, true);
      }
      function hide() {
        if (_comboHideTimerID) {
          window.clearTimeout(_comboHideTimerID);
          _comboHideTimerID = void 0;
        }
        container.selectAll(".combobox").remove();
        container.on("scroll.combo-scroll", null);
      }
      function keydown(d3_event) {
        var shown = !container.selectAll(".combobox").empty();
        var tagName = input.node() ? input.node().tagName.toLowerCase() : "";
        switch (d3_event.keyCode) {
          case 8:
          case 46:
            d3_event.stopPropagation();
            _selected = null;
            render();
            input.on("input.combo-input", function() {
              var start2 = input.property("selectionStart");
              input.node().setSelectionRange(start2, start2);
              input.on("input.combo-input", change);
              change(false);
            });
            break;
          case 9:
            accept(d3_event);
            break;
          case 13:
            d3_event.preventDefault();
            d3_event.stopPropagation();
            accept(d3_event);
            break;
          case 38:
            if (tagName === "textarea" && !shown)
              return;
            d3_event.preventDefault();
            if (tagName === "input" && !shown) {
              show();
            }
            nav(-1);
            break;
          case 40:
            if (tagName === "textarea" && !shown)
              return;
            d3_event.preventDefault();
            if (tagName === "input" && !shown) {
              show();
            }
            nav(1);
            break;
        }
      }
      function keyup(d3_event) {
        switch (d3_event.keyCode) {
          case 27:
            cancel();
            break;
        }
      }
      function change(doAutoComplete) {
        if (doAutoComplete === void 0)
          doAutoComplete = true;
        fetchComboData(value(), function(skipAutosuggest) {
          _selected = null;
          var val = input.property("value");
          if (_suggestions.length) {
            if (doAutoComplete && !skipAutosuggest && input.property("selectionEnd") === val.length) {
              _selected = tryAutocomplete();
            }
            if (!_selected) {
              _selected = val;
            }
          }
          if (val.length) {
            var combo = container.selectAll(".combobox");
            if (combo.empty()) {
              show();
            }
          } else {
            hide();
          }
          render();
        });
      }
      function nav(dir) {
        if (_suggestions.length) {
          var index = -1;
          for (var i3 = 0; i3 < _suggestions.length; i3++) {
            if (_selected && _suggestions[i3].value === _selected) {
              index = i3;
              break;
            }
          }
          index = Math.max(Math.min(index + dir, _suggestions.length - 1), 0);
          _selected = _suggestions[index].value;
          utilGetSetValue(input, _selected);
          dispatch14.call("update");
        }
        render();
        ensureVisible();
      }
      function ensureVisible() {
        var combo = container.selectAll(".combobox");
        if (combo.empty())
          return;
        var containerRect = container.node().getBoundingClientRect();
        var comboRect = combo.node().getBoundingClientRect();
        if (comboRect.bottom > containerRect.bottom) {
          var node = attachTo ? attachTo.node() : input.node();
          node.scrollIntoView({ behavior: "instant", block: "center" });
          render();
        }
        var selected = combo.selectAll(".combobox-option.selected").node();
        if (selected) {
          selected.scrollIntoView({ behavior: "smooth", block: "nearest" });
        }
      }
      function value() {
        var value2 = input.property("value");
        var start2 = input.property("selectionStart");
        var end = input.property("selectionEnd");
        if (start2 && end) {
          value2 = value2.substring(0, start2);
        }
        return value2;
      }
      function fetchComboData(v2, cb) {
        _cancelFetch = false;
        _fetcher.call(input, v2, function(results, skipAutosuggest) {
          if (_cancelFetch)
            return;
          _suggestions = results;
          results.forEach(function(d2) {
            _fetched[d2.value] = d2;
          });
          if (cb) {
            cb(skipAutosuggest);
          }
        });
      }
      function tryAutocomplete() {
        if (!_canAutocomplete)
          return;
        var val = _caseSensitive ? value() : value().toLowerCase();
        if (!val)
          return;
        if (isFinite(val))
          return;
        const suggestionValues = [];
        _suggestions.forEach((s2) => {
          suggestionValues.push(s2.value);
          if (s2.key && s2.key !== s2.value) {
            suggestionValues.push(s2.key);
          }
        });
        var bestIndex = -1;
        for (var i3 = 0; i3 < suggestionValues.length; i3++) {
          var suggestion = suggestionValues[i3];
          var compare2 = _caseSensitive ? suggestion : suggestion.toLowerCase();
          if (compare2 === val) {
            bestIndex = i3;
            break;
          } else if (bestIndex === -1 && compare2.indexOf(val) === 0) {
            bestIndex = i3;
          }
        }
        if (bestIndex !== -1) {
          var bestVal = suggestionValues[bestIndex];
          input.property("value", bestVal);
          input.node().setSelectionRange(val.length, bestVal.length);
          dispatch14.call("update");
          return bestVal;
        }
      }
      function render() {
        if (_suggestions.length < _minItems || document.activeElement !== input.node()) {
          hide();
          return;
        }
        var shown = !container.selectAll(".combobox").empty();
        if (!shown)
          return;
        var combo = container.selectAll(".combobox");
        var options2 = combo.selectAll(".combobox-option").data(_suggestions, function(d2) {
          return d2.value;
        });
        options2.exit().remove();
        options2.enter().append("a").attr("class", function(d2) {
          return "combobox-option " + (d2.klass || "");
        }).attr("title", function(d2) {
          return d2.title;
        }).each(function(d2) {
          if (d2.display) {
            d2.display(select_default2(this));
          } else {
            select_default2(this).text(d2.value);
          }
        }).on("mouseenter", _mouseEnterHandler).on("mouseleave", _mouseLeaveHandler).merge(options2).classed("selected", function(d2) {
          return d2.value === _selected || d2.key === _selected;
        }).on("click.combo-option", accept).order();
        var node = attachTo ? attachTo.node() : input.node();
        var containerRect = container.node().getBoundingClientRect();
        var rect = node.getBoundingClientRect();
        combo.style("left", rect.left + 5 - containerRect.left + "px").style("width", rect.width - 10 + "px").style("top", rect.height + rect.top - containerRect.top + "px");
      }
      function accept(d3_event, d2) {
        _cancelFetch = true;
        var thiz = input.node();
        if (d2) {
          utilGetSetValue(input, d2.value);
          utilTriggerEvent(input, "change");
        }
        var val = utilGetSetValue(input);
        thiz.setSelectionRange(val.length, val.length);
        d2 = _fetched[val];
        dispatch14.call("accept", thiz, d2, val);
        hide();
      }
      function cancel() {
        _cancelFetch = true;
        var thiz = input.node();
        var val = utilGetSetValue(input);
        var start2 = input.property("selectionStart");
        var end = input.property("selectionEnd");
        val = val.slice(0, start2) + val.slice(end);
        utilGetSetValue(input, val);
        thiz.setSelectionRange(val.length, val.length);
        dispatch14.call("cancel", thiz);
        hide();
      }
    };
    combobox.canAutocomplete = function(val) {
      if (!arguments.length)
        return _canAutocomplete;
      _canAutocomplete = val;
      return combobox;
    };
    combobox.caseSensitive = function(val) {
      if (!arguments.length)
        return _caseSensitive;
      _caseSensitive = val;
      return combobox;
    };
    combobox.data = function(val) {
      if (!arguments.length)
        return _data;
      _data = val;
      return combobox;
    };
    combobox.fetcher = function(val) {
      if (!arguments.length)
        return _fetcher;
      _fetcher = val;
      return combobox;
    };
    combobox.minItems = function(val) {
      if (!arguments.length)
        return _minItems;
      _minItems = val;
      return combobox;
    };
    combobox.itemsMouseEnter = function(val) {
      if (!arguments.length)
        return _mouseEnterHandler;
      _mouseEnterHandler = val;
      return combobox;
    };
    combobox.itemsMouseLeave = function(val) {
      if (!arguments.length)
        return _mouseLeaveHandler;
      _mouseLeaveHandler = val;
      return combobox;
    };
    return utilRebind(combobox, dispatch14, "on");
  }
  uiCombobox.off = function(input, context) {
    input.on("focus.combo-input", null).on("blur.combo-input", null).on("keydown.combo-input", null).on("keyup.combo-input", null).on("input.combo-input", null).on("mousedown.combo-input", null).on("mouseup.combo-input", null);
    context.container().on("scroll.combo-scroll", null);
  };

  // modules/ui/disclosure.js
  function uiDisclosure(context, key, expandedDefault) {
    var dispatch14 = dispatch_default("toggled");
    var _expanded;
    var _label = utilFunctor("");
    var _updatePreference = true;
    var _content = function() {
    };
    var disclosure = function(selection2) {
      if (_expanded === void 0 || _expanded === null) {
        var preference = corePreferences("disclosure." + key + ".expanded");
        _expanded = preference === null ? !!expandedDefault : preference === "true";
      }
      var hideToggle = selection2.selectAll(".hide-toggle-" + key).data([0]);
      var hideToggleEnter = hideToggle.enter().append("h3").append("a").attr("role", "button").attr("href", "#").attr("class", "hide-toggle hide-toggle-" + key).call(svgIcon("", "pre-text", "hide-toggle-icon"));
      hideToggleEnter.append("span").attr("class", "hide-toggle-text");
      hideToggle = hideToggleEnter.merge(hideToggle);
      hideToggle.on("click", toggle).attr("title", _t("icons.".concat(_expanded ? "collapse" : "expand"))).attr("aria-expanded", _expanded).classed("expanded", _expanded);
      const label = _label();
      const labelSelection = hideToggle.selectAll(".hide-toggle-text");
      if (typeof label !== "function") {
        labelSelection.text(_label());
      } else {
        labelSelection.text("").call(label);
      }
      hideToggle.selectAll(".hide-toggle-icon").attr(
        "xlink:href",
        _expanded ? "#iD-icon-down" : _mainLocalizer.textDirection() === "rtl" ? "#iD-icon-backward" : "#iD-icon-forward"
      );
      var wrap2 = selection2.selectAll(".disclosure-wrap").data([0]);
      wrap2 = wrap2.enter().append("div").attr("class", "disclosure-wrap disclosure-wrap-" + key).merge(wrap2).classed("hide", !_expanded);
      if (_expanded) {
        wrap2.call(_content);
      }
      function toggle(d3_event) {
        d3_event.preventDefault();
        _expanded = !_expanded;
        if (_updatePreference) {
          corePreferences("disclosure." + key + ".expanded", _expanded);
        }
        hideToggle.classed("expanded", _expanded).attr("aria-expanded", _expanded).attr("title", _t("icons.".concat(_expanded ? "collapse" : "expand")));
        hideToggle.selectAll(".hide-toggle-icon").attr(
          "xlink:href",
          _expanded ? "#iD-icon-down" : _mainLocalizer.textDirection() === "rtl" ? "#iD-icon-backward" : "#iD-icon-forward"
        );
        wrap2.call(uiToggle(_expanded));
        if (_expanded) {
          wrap2.call(_content);
        }
        dispatch14.call("toggled", this, _expanded);
      }
    };
    disclosure.label = function(val) {
      if (!arguments.length)
        return _label;
      _label = utilFunctor(val);
      return disclosure;
    };
    disclosure.expanded = function(val) {
      if (!arguments.length)
        return _expanded;
      _expanded = val;
      return disclosure;
    };
    disclosure.updatePreference = function(val) {
      if (!arguments.length)
        return _updatePreference;
      _updatePreference = val;
      return disclosure;
    };
    disclosure.content = function(val) {
      if (!arguments.length)
        return _content;
      _content = val;
      return disclosure;
    };
    return utilRebind(disclosure, dispatch14, "on");
  }

  // modules/ui/section.js
  function uiSection(id2, context) {
    var _classes = utilFunctor("");
    var _shouldDisplay;
    var _content;
    var _disclosure;
    var _label;
    var _expandedByDefault = utilFunctor(true);
    var _disclosureContent;
    var _disclosureExpanded;
    var _containerSelection = select_default2(null);
    var section = {
      id: id2
    };
    section.classes = function(val) {
      if (!arguments.length)
        return _classes;
      _classes = utilFunctor(val);
      return section;
    };
    section.label = function(val) {
      if (!arguments.length)
        return _label;
      _label = utilFunctor(val);
      return section;
    };
    section.expandedByDefault = function(val) {
      if (!arguments.length)
        return _expandedByDefault;
      _expandedByDefault = utilFunctor(val);
      return section;
    };
    section.shouldDisplay = function(val) {
      if (!arguments.length)
        return _shouldDisplay;
      _shouldDisplay = utilFunctor(val);
      return section;
    };
    section.content = function(val) {
      if (!arguments.length)
        return _content;
      _content = val;
      return section;
    };
    section.disclosureContent = function(val) {
      if (!arguments.length)
        return _disclosureContent;
      _disclosureContent = val;
      return section;
    };
    section.disclosureExpanded = function(val) {
      if (!arguments.length)
        return _disclosureExpanded;
      _disclosureExpanded = val;
      return section;
    };
    section.render = function(selection2) {
      _containerSelection = selection2.selectAll(".section-" + id2).data([0]);
      var sectionEnter = _containerSelection.enter().append("div").attr("class", "section section-" + id2 + " " + (_classes && _classes() || ""));
      _containerSelection = sectionEnter.merge(_containerSelection);
      _containerSelection.call(renderContent);
    };
    section.reRender = function() {
      _containerSelection.call(renderContent);
    };
    section.selection = function() {
      return _containerSelection;
    };
    section.disclosure = function() {
      return _disclosure;
    };
    function renderContent(selection2) {
      if (_shouldDisplay) {
        var shouldDisplay = _shouldDisplay();
        selection2.classed("hide", !shouldDisplay);
        if (!shouldDisplay) {
          selection2.html("");
          return;
        }
      }
      if (_disclosureContent) {
        if (!_disclosure) {
          _disclosure = uiDisclosure(context, id2.replace(/-/g, "_"), _expandedByDefault()).label(_label || "").content(_disclosureContent);
        }
        if (_disclosureExpanded !== void 0) {
          _disclosure.expanded(_disclosureExpanded);
          _disclosureExpanded = void 0;
        }
        selection2.call(_disclosure);
        return;
      }
      if (_content) {
        selection2.call(_content);
      }
    }
    return section;
  }

  // modules/ui/tag_reference.js
  function uiTagReference(what) {
    var wikibase = what.qid ? services.wikidata : services.osmWikibase;
    var tagReference = {};
    var _button = select_default2(null);
    var _body = select_default2(null);
    var _loaded;
    var _showing;
    function load() {
      if (!wikibase)
        return;
      _button.classed("tag-reference-loading", true);
      wikibase.getDocs(what, gotDocs);
    }
    function gotDocs(err, docs) {
      _body.html("");
      if (!docs || !docs.title) {
        _body.append("p").attr("class", "tag-reference-description").call(_t.append("inspector.no_documentation_key"));
        done();
        return;
      }
      if (docs.imageURL) {
        _body.append("img").attr("class", "tag-reference-wiki-image").attr("alt", docs.description).attr("src", docs.imageURL).on("load", function() {
          done();
        }).on("error", function() {
          select_default2(this).remove();
          done();
        });
      } else {
        done();
      }
      var tagReferenceDescription = _body.append("p").attr("class", "tag-reference-description").append("span");
      if (docs.description) {
        tagReferenceDescription = tagReferenceDescription.attr("class", "localized-text").attr("lang", docs.descriptionLocaleCode || "und").text(docs.description);
      } else {
        tagReferenceDescription = tagReferenceDescription.call(_t.append("inspector.no_documentation_key"));
      }
      tagReferenceDescription.append("a").attr("class", "tag-reference-edit").attr("target", "_blank").attr("title", _t("inspector.edit_reference")).attr("href", docs.editURL).call(svgIcon("#iD-icon-edit", "inline"));
      if (docs.wiki) {
        _body.append("a").attr("class", "tag-reference-link").attr("target", "_blank").attr("href", docs.wiki.url).call(svgIcon("#iD-icon-out-link", "inline")).append("span").call(_t.append(docs.wiki.text));
      }
      if (what.key === "comment") {
        _body.append("a").attr("class", "tag-reference-comment-link").attr("target", "_blank").call(svgIcon("#iD-icon-out-link", "inline")).attr("href", _t("commit.about_changeset_comments_link")).append("span").call(_t.append("commit.about_changeset_comments"));
      }
    }
    function done() {
      _loaded = true;
      _button.classed("tag-reference-loading", false);
      _body.classed("expanded", true).transition().duration(200).style("max-height", "200px").style("opacity", "1");
      _showing = true;
      _button.selectAll("svg.icon use").each(function() {
        var iconUse = select_default2(this);
        if (iconUse.attr("href") === "#iD-icon-info") {
          iconUse.attr("href", "#iD-icon-info-filled");
        }
      });
    }
    function hide() {
      _body.transition().duration(200).style("max-height", "0px").style("opacity", "0").on("end", function() {
        _body.classed("expanded", false);
      });
      _showing = false;
      _button.selectAll("svg.icon use").each(function() {
        var iconUse = select_default2(this);
        if (iconUse.attr("href") === "#iD-icon-info-filled") {
          iconUse.attr("href", "#iD-icon-info");
        }
      });
    }
    tagReference.button = function(selection2, klass, iconName) {
      _button = selection2.selectAll(".tag-reference-button").data([0]);
      _button = _button.enter().append("button").attr("class", "tag-reference-button " + (klass || "")).attr("title", _t("icons.information")).call(svgIcon("#iD-icon-" + (iconName || "inspect"))).merge(_button);
      _button.on("click", function(d3_event) {
        d3_event.stopPropagation();
        d3_event.preventDefault();
        this.blur();
        if (_showing) {
          hide();
        } else if (_loaded) {
          done();
        } else {
          load();
        }
      });
    };
    tagReference.body = function(selection2) {
      var itemID = what.qid || what.key + "-" + (what.value || "");
      _body = selection2.selectAll(".tag-reference-body").data([itemID], function(d2) {
        return d2;
      });
      _body.exit().remove();
      _body = _body.enter().append("div").attr("class", "tag-reference-body").style("max-height", "0").style("opacity", "0").merge(_body);
      if (_showing === false) {
        hide();
      }
    };
    tagReference.showing = function(val) {
      if (!arguments.length)
        return _showing;
      _showing = val;
      return tagReference;
    };
    return tagReference;
  }

  // modules/ui/field_help.js
  function uiFieldHelp(context, fieldName) {
    var fieldHelp = {};
    var _inspector = select_default2(null);
    var _wrap = select_default2(null);
    var _body = select_default2(null);
    var fieldHelpKeys = {
      restrictions: [
        ["about", [
          "about",
          "from_via_to",
          "maxdist",
          "maxvia"
        ]],
        ["inspecting", [
          "about",
          "from_shadow",
          "allow_shadow",
          "restrict_shadow",
          "only_shadow",
          "restricted",
          "only"
        ]],
        ["modifying", [
          "about",
          "indicators",
          "allow_turn",
          "restrict_turn",
          "only_turn"
        ]],
        ["tips", [
          "simple",
          "simple_example",
          "indirect",
          "indirect_example",
          "indirect_noedit"
        ]]
      ]
    };
    var fieldHelpHeadings = {};
    var replacements = {
      distField: { html: _t.html("restriction.controls.distance") },
      viaField: { html: _t.html("restriction.controls.via") },
      fromShadow: { html: icon("#iD-turn-shadow", "inline shadow from") },
      allowShadow: { html: icon("#iD-turn-shadow", "inline shadow allow") },
      restrictShadow: { html: icon("#iD-turn-shadow", "inline shadow restrict") },
      onlyShadow: { html: icon("#iD-turn-shadow", "inline shadow only") },
      allowTurn: { html: icon("#iD-turn-yes", "inline turn") },
      restrictTurn: { html: icon("#iD-turn-no", "inline turn") },
      onlyTurn: { html: icon("#iD-turn-only", "inline turn") }
    };
    var docs = fieldHelpKeys[fieldName].map(function(key) {
      var helpkey = "help.field." + fieldName + "." + key[0];
      var text = key[1].reduce(function(all, part) {
        var subkey = helpkey + "." + part;
        var depth = fieldHelpHeadings[subkey];
        var hhh = depth ? Array(depth + 1).join("#") + " " : "";
        return all + hhh + _t.html(subkey, replacements) + "\n\n";
      }, "");
      return {
        key: helpkey,
        title: _t.html(helpkey + ".title"),
        html: marked(text.trim())
      };
    });
    function show() {
      updatePosition();
      _body.classed("hide", false).style("opacity", "0").transition().duration(200).style("opacity", "1");
    }
    function hide() {
      _body.classed("hide", true).transition().duration(200).style("opacity", "0").on("end", function() {
        _body.classed("hide", true);
      });
    }
    function clickHelp(index) {
      var d2 = docs[index];
      var tkeys = fieldHelpKeys[fieldName][index][1];
      _body.selectAll(".field-help-nav-item").classed("active", function(d4, i3) {
        return i3 === index;
      });
      var content = _body.selectAll(".field-help-content").html(d2.html);
      content.selectAll("p").attr("class", function(d4, i3) {
        return tkeys[i3];
      });
      if (d2.key === "help.field.restrictions.inspecting") {
        content.insert("img", "p.from_shadow").attr("class", "field-help-image cf").attr("src", context.imagePath("tr_inspect.gif"));
      } else if (d2.key === "help.field.restrictions.modifying") {
        content.insert("img", "p.allow_turn").attr("class", "field-help-image cf").attr("src", context.imagePath("tr_modify.gif"));
      }
    }
    fieldHelp.button = function(selection2) {
      if (_body.empty())
        return;
      var button = selection2.selectAll(".field-help-button").data([0]);
      button.enter().append("button").attr("class", "field-help-button").call(svgIcon("#iD-icon-help")).merge(button).on("click", function(d3_event) {
        d3_event.stopPropagation();
        d3_event.preventDefault();
        if (_body.classed("hide")) {
          show();
        } else {
          hide();
        }
      });
    };
    function updatePosition() {
      var wrap2 = _wrap.node();
      var inspector = _inspector.node();
      var wRect = wrap2.getBoundingClientRect();
      var iRect = inspector.getBoundingClientRect();
      _body.style("top", wRect.top + inspector.scrollTop - iRect.top + "px");
    }
    fieldHelp.body = function(selection2) {
      _wrap = selection2.selectAll(".form-field-input-wrap");
      if (_wrap.empty())
        return;
      _inspector = context.container().select(".sidebar .entity-editor-pane .inspector-body");
      if (_inspector.empty())
        return;
      _body = _inspector.selectAll(".field-help-body").data([0]);
      var enter = _body.enter().append("div").attr("class", "field-help-body hide");
      var titleEnter = enter.append("div").attr("class", "field-help-title cf");
      titleEnter.append("h2").attr("class", _mainLocalizer.textDirection() === "rtl" ? "fr" : "fl").call(_t.append("help.field." + fieldName + ".title"));
      titleEnter.append("button").attr("class", "fr close").attr("title", _t("icons.close")).on("click", function(d3_event) {
        d3_event.stopPropagation();
        d3_event.preventDefault();
        hide();
      }).call(svgIcon("#iD-icon-close"));
      var navEnter = enter.append("div").attr("class", "field-help-nav cf");
      var titles = docs.map(function(d2) {
        return d2.title;
      });
      navEnter.selectAll(".field-help-nav-item").data(titles).enter().append("div").attr("class", "field-help-nav-item").html(function(d2) {
        return d2;
      }).on("click", function(d3_event, d2) {
        d3_event.stopPropagation();
        d3_event.preventDefault();
        clickHelp(titles.indexOf(d2));
      });
      enter.append("div").attr("class", "field-help-content");
      _body = _body.merge(enter);
      clickHelp(0);
    };
    return fieldHelp;
  }

  // modules/ui/fields/check.js
  function uiFieldCheck(field, context) {
    var dispatch14 = dispatch_default("change");
    var options2 = field.options;
    var values = [];
    var texts = [];
    var _tags;
    var input = select_default2(null);
    var text = select_default2(null);
    var label = select_default2(null);
    var reverser = select_default2(null);
    var _impliedYes;
    var _entityIDs = [];
    var _value;
    var stringsField = field.resolveReference("stringsCrossReference");
    if (!options2 && stringsField.options) {
      options2 = stringsField.options;
    }
    if (options2) {
      for (var i3 in options2) {
        var v2 = options2[i3];
        values.push(v2 === "undefined" ? void 0 : v2);
        texts.push(stringsField.t.html("options." + v2, { "default": v2 }));
      }
    } else {
      values = [void 0, "yes"];
      texts = [_t.html("inspector.unknown"), _t.html("inspector.check.yes")];
      if (field.type !== "defaultCheck") {
        values.push("no");
        texts.push(_t.html("inspector.check.no"));
      }
    }
    function checkImpliedYes() {
      _impliedYes = field.id === "oneway_yes";
      if (field.id === "oneway") {
        var entity = context.entity(_entityIDs[0]);
        for (var key in entity.tags) {
          if (key in osmOneWayTags && entity.tags[key] in osmOneWayTags[key]) {
            _impliedYes = true;
            texts[0] = _t.html("_tagging.presets.fields.oneway_yes.options.undefined");
            break;
          }
        }
      }
    }
    function reverserHidden() {
      if (!context.container().select("div.inspector-hover").empty())
        return true;
      return !(_value === "yes" || _impliedYes && !_value);
    }
    function reverserSetText(selection2) {
      var entity = _entityIDs.length && context.hasEntity(_entityIDs[0]);
      if (reverserHidden() || !entity)
        return selection2;
      var first = entity.first();
      var last = entity.isClosed() ? entity.nodes[entity.nodes.length - 2] : entity.last();
      var pseudoDirection = first < last;
      var icon2 = pseudoDirection ? "#iD-icon-forward" : "#iD-icon-backward";
      selection2.selectAll(".reverser-span").html("").call(_t.append("inspector.check.reverser")).call(svgIcon(icon2, "inline"));
      return selection2;
    }
    var check = function(selection2) {
      checkImpliedYes();
      label = selection2.selectAll(".form-field-input-wrap").data([0]);
      var enter = label.enter().append("label").attr("class", "form-field-input-wrap form-field-input-check");
      enter.append("input").property("indeterminate", field.type !== "defaultCheck").attr("type", "checkbox").attr("id", field.domId);
      enter.append("span").html(texts[0]).attr("class", "value");
      if (field.type === "onewayCheck") {
        enter.append("button").attr("class", "reverser" + (reverserHidden() ? " hide" : "")).append("span").attr("class", "reverser-span");
      }
      label = label.merge(enter);
      input = label.selectAll("input");
      text = label.selectAll("span.value");
      input.on("click", function(d3_event) {
        d3_event.stopPropagation();
        var t2 = {};
        if (Array.isArray(_tags[field.key])) {
          if (values.indexOf("yes") !== -1) {
            t2[field.key] = "yes";
          } else {
            t2[field.key] = values[0];
          }
        } else {
          t2[field.key] = values[(values.indexOf(_value) + 1) % values.length];
        }
        if (t2[field.key] === "reversible" || t2[field.key] === "alternating") {
          t2[field.key] = values[0];
        }
        dispatch14.call("change", this, t2);
      });
      if (field.type === "onewayCheck") {
        reverser = label.selectAll(".reverser");
        reverser.call(reverserSetText).on("click", function(d3_event) {
          d3_event.preventDefault();
          d3_event.stopPropagation();
          context.perform(
            function(graph) {
              for (var i4 in _entityIDs) {
                graph = actionReverse(_entityIDs[i4])(graph);
              }
              return graph;
            },
            _t("operations.reverse.annotation.line", { n: 1 })
          );
          context.validator().validate();
          select_default2(this).call(reverserSetText);
        });
      }
    };
    check.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      _entityIDs = val;
      return check;
    };
    check.tags = function(tags) {
      _tags = tags;
      function isChecked(val) {
        return val !== "no" && val !== "" && val !== void 0 && val !== null;
      }
      function textFor(val) {
        if (val === "")
          val = void 0;
        var index = values.indexOf(val);
        return index !== -1 ? texts[index] : '"' + val + '"';
      }
      checkImpliedYes();
      var isMixed = Array.isArray(tags[field.key]);
      _value = !isMixed && tags[field.key] && tags[field.key].toLowerCase();
      if (field.type === "onewayCheck" && (_value === "1" || _value === "-1")) {
        _value = "yes";
      }
      input.property("indeterminate", isMixed || field.type !== "defaultCheck" && !_value).property("checked", isChecked(_value));
      text.html(isMixed ? _t.html("inspector.multiple_values") : textFor(_value)).classed("mixed", isMixed);
      label.classed("set", !!_value);
      if (field.type === "onewayCheck") {
        reverser.classed("hide", reverserHidden()).call(reverserSetText);
      }
    };
    check.focus = function() {
      input.node().focus();
    };
    return utilRebind(check, dispatch14, "on");
  }

  // modules/ui/length_indicator.js
  function uiLengthIndicator(maxChars) {
    var _wrap = select_default2(null);
    var _tooltip = uiPopover("tooltip max-length-warning").placement("bottom").hasArrow(true).content(() => (selection2) => {
      selection2.text("");
      selection2.call(svgIcon("#iD-icon-alert", "inline"));
      selection2.call(_t.append("inspector.max_length_reached", { maxChars }));
    });
    var _silent = false;
    var lengthIndicator = function(selection2) {
      _wrap = selection2.selectAll("span.length-indicator-wrap").data([0]);
      _wrap = _wrap.enter().append("span").merge(_wrap).classed("length-indicator-wrap", true);
      selection2.call(_tooltip);
    };
    lengthIndicator.update = function(val) {
      const strLen = utilUnicodeCharsCount(utilCleanOsmString(val, Number.POSITIVE_INFINITY));
      let indicator = _wrap.selectAll("span.length-indicator").data([strLen]);
      indicator.enter().append("span").merge(indicator).classed("length-indicator", true).classed("limit-reached", (d2) => d2 > maxChars).style("border-right-width", (d2) => "".concat(Math.abs(maxChars - d2) * 2, "px")).style("margin-right", (d2) => d2 > maxChars ? "".concat((maxChars - d2) * 2, "px") : 0).style("opacity", (d2) => d2 > maxChars * 0.8 ? Math.min(1, (d2 / maxChars - 0.8) / (1 - 0.8)) : 0).style("pointer-events", (d2) => d2 > maxChars * 0.8 ? null : "none");
      if (_silent)
        return;
      if (strLen > maxChars) {
        _tooltip.show();
      } else {
        _tooltip.hide();
      }
    };
    lengthIndicator.silent = function(val) {
      if (!arguments.length)
        return _silent;
      _silent = val;
      return lengthIndicator;
    };
    return lengthIndicator;
  }

  // modules/ui/fields/combo.js
  function uiFieldCombo(field, context) {
    var dispatch14 = dispatch_default("change");
    var _isMulti = field.type === "multiCombo" || field.type === "manyCombo";
    var _isNetwork = field.type === "networkCombo";
    var _isSemi = field.type === "semiCombo";
    var _showTagInfoSuggestions = field.type !== "manyCombo" && field.autoSuggestions !== false;
    var _allowCustomValues = field.type !== "manyCombo" && field.customValues !== false;
    var _snake_case = field.snake_case || field.snake_case === void 0;
    var _combobox = uiCombobox(context, "combo-" + field.safeid).caseSensitive(field.caseSensitive).minItems(1);
    var _container = select_default2(null);
    var _inputWrap = select_default2(null);
    var _input = select_default2(null);
    var _lengthIndicator = uiLengthIndicator(context.maxCharsForTagValue());
    var _comboData = [];
    var _multiData = [];
    var _entityIDs = [];
    var _tags;
    var _countryCode;
    var _staticPlaceholder;
    var _dataDeprecated = [];
    _mainFileFetcher.get("deprecated").then(function(d2) {
      _dataDeprecated = d2;
    }).catch(function() {
    });
    if (_isMulti && field.key && /[^:]$/.test(field.key)) {
      field.key += ":";
    }
    function snake(s2) {
      return s2.replace(/\s+/g, "_");
    }
    function clean2(s2) {
      return s2.split(";").map(function(s3) {
        return s3.trim();
      }).join(";");
    }
    function tagValue(dval) {
      dval = clean2(dval || "");
      var found = getOptions(true).find(function(o2) {
        return o2.key && clean2(o2.value) === dval;
      });
      if (found)
        return found.key;
      if (field.type === "typeCombo" && !dval) {
        return "yes";
      }
      return restrictTagValueSpelling(dval) || void 0;
    }
    function restrictTagValueSpelling(dval) {
      if (_snake_case) {
        dval = snake(dval);
      }
      if (!field.caseSensitive) {
        dval = dval.toLowerCase();
      }
      return dval;
    }
    function getLabelId(field2, v2) {
      return field2.hasTextForStringId("options.".concat(v2, ".title")) ? "options.".concat(v2, ".title") : "options.".concat(v2);
    }
    function displayValue(tval) {
      tval = tval || "";
      var stringsField = field.resolveReference("stringsCrossReference");
      const labelId = getLabelId(stringsField, tval);
      if (stringsField.hasTextForStringId(labelId)) {
        return stringsField.t(labelId, { default: tval });
      }
      if (field.type === "typeCombo" && tval.toLowerCase() === "yes") {
        return "";
      }
      return tval;
    }
    function renderValue(tval) {
      tval = tval || "";
      var stringsField = field.resolveReference("stringsCrossReference");
      const labelId = getLabelId(stringsField, tval);
      if (stringsField.hasTextForStringId(labelId)) {
        return stringsField.t.append(labelId, { default: tval });
      }
      if (field.type === "typeCombo" && tval.toLowerCase() === "yes") {
        tval = "";
      }
      return (selection2) => selection2.text(tval);
    }
    function objectDifference(a2, b2) {
      return a2.filter(function(d1) {
        return !b2.some(function(d2) {
          return d1.value === d2.value;
        });
      });
    }
    function initCombo(selection2, attachTo) {
      if (!_allowCustomValues) {
        selection2.attr("readonly", "readonly");
      }
      if (_showTagInfoSuggestions && services.taginfo) {
        selection2.call(_combobox.fetcher(setTaginfoValues), attachTo);
        setTaginfoValues("", setPlaceholder);
      } else {
        selection2.call(_combobox, attachTo);
        setTimeout(() => setStaticValues(setPlaceholder), 0);
      }
    }
    function getOptions(allOptions) {
      var stringsField = field.resolveReference("stringsCrossReference");
      if (!(field.options || stringsField.options))
        return [];
      let options2;
      if (allOptions !== true) {
        options2 = field.options || stringsField.options;
      } else {
        options2 = [].concat(field.options, stringsField.options).filter(Boolean);
      }
      return options2.map(function(v2) {
        const labelId = getLabelId(stringsField, v2);
        return {
          key: v2,
          value: stringsField.t(labelId, { default: v2 }),
          title: stringsField.t("options.".concat(v2, ".description"), { default: v2 }),
          display: addComboboxIcons(stringsField.t.append(labelId, { default: v2 }), v2),
          klass: stringsField.hasTextForStringId(labelId) ? "" : "raw-option"
        };
      });
    }
    function hasStaticValues() {
      return getOptions().length > 0;
    }
    function setStaticValues(callback, filter2) {
      _comboData = getOptions();
      if (filter2 !== void 0) {
        _comboData = _comboData.filter(filter2);
      }
      _comboData = objectDifference(_comboData, _multiData);
      _combobox.data(_comboData);
      if (callback)
        callback(_comboData);
    }
    function setTaginfoValues(q2, callback) {
      var queryFilter = (d2) => d2.value.toLowerCase().includes(q2.toLowerCase()) || d2.key.toLowerCase().includes(q2.toLowerCase());
      if (hasStaticValues()) {
        setStaticValues(callback, queryFilter);
      }
      var stringsField = field.resolveReference("stringsCrossReference");
      var fn = _isMulti ? "multikeys" : "values";
      var query = (_isMulti ? field.key : "") + q2;
      var hasCountryPrefix = _isNetwork && _countryCode && _countryCode.indexOf(q2.toLowerCase()) === 0;
      if (hasCountryPrefix) {
        query = _countryCode + ":";
      }
      var params = {
        debounce: q2 !== "",
        key: field.key,
        query
      };
      if (_entityIDs.length) {
        params.geometry = context.graph().geometry(_entityIDs[0]);
      }
      services.taginfo[fn](params, function(err, data) {
        if (err)
          return;
        data = data.filter((d2) => field.type !== "typeCombo" || d2.value !== "yes");
        data = data.filter((d2) => {
          var value = d2.value;
          if (_isMulti) {
            value = value.slice(field.key.length);
          }
          return value === restrictTagValueSpelling(value);
        });
        var deprecatedValues = osmEntity.deprecatedTagValuesByKey(_dataDeprecated)[field.key];
        if (deprecatedValues) {
          data = data.filter((d2) => !deprecatedValues.includes(d2.value));
        }
        if (hasCountryPrefix) {
          data = data.filter((d2) => d2.value.toLowerCase().indexOf(_countryCode + ":") === 0);
        }
        const additionalOptions = (field.options || stringsField.options || []).filter((v2) => !data.some((dv) => dv.value === (_isMulti ? field.key + v2 : v2))).map((v2) => ({ value: v2 }));
        _container.classed("empty-combobox", data.length === 0);
        _comboData = data.concat(additionalOptions).map(function(d2) {
          var v2 = d2.value;
          if (_isMulti)
            v2 = v2.replace(field.key, "");
          const labelId = getLabelId(stringsField, v2);
          var isLocalizable = stringsField.hasTextForStringId(labelId);
          var label = stringsField.t(labelId, { default: v2 });
          return {
            key: v2,
            value: label,
            title: stringsField.t("options.".concat(v2, ".description"), { default: isLocalizable ? v2 : d2.title !== label ? d2.title : "" }),
            display: addComboboxIcons(stringsField.t.append(labelId, { default: v2 }), v2),
            klass: isLocalizable ? "" : "raw-option"
          };
        });
        _comboData = _comboData.filter(queryFilter);
        _comboData = objectDifference(_comboData, _multiData);
        if (callback)
          callback(_comboData, hasStaticValues());
      });
    }
    function addComboboxIcons(disp, value) {
      const iconsField = field.resolveReference("iconsCrossReference");
      if (iconsField.icons) {
        return function(selection2) {
          var span = selection2.insert("span", ":first-child").attr("class", "tag-value-icon");
          if (iconsField.icons[value]) {
            span.call(svgIcon("#".concat(iconsField.icons[value])));
          }
          disp.call(this, selection2);
        };
      }
      return disp;
    }
    function setPlaceholder(values) {
      if (_isMulti || _isSemi) {
        _staticPlaceholder = field.placeholder() || _t("inspector.add");
      } else {
        var vals = values.map(function(d2) {
          return d2.value;
        }).filter(function(s2) {
          return s2.length < 20;
        });
        var placeholders = vals.length > 1 ? vals : values.map(function(d2) {
          return d2.key;
        });
        _staticPlaceholder = field.placeholder() || placeholders.slice(0, 3).join(", ");
      }
      if (!/(…|\.\.\.)$/.test(_staticPlaceholder)) {
        _staticPlaceholder += "\u2026";
      }
      var ph;
      if (!_isMulti && !_isSemi && _tags && Array.isArray(_tags[field.key])) {
        ph = _t("inspector.multiple_values");
      } else {
        ph = _staticPlaceholder;
      }
      _container.selectAll("input").attr("placeholder", ph);
      var hideAdd = !_allowCustomValues && !values.length;
      _container.selectAll(".chiplist .input-wrap").style("display", hideAdd ? "none" : null);
    }
    function change() {
      var t2 = {};
      var val;
      if (_isMulti || _isSemi) {
        var vals;
        if (_isMulti) {
          vals = [tagValue(utilGetSetValue(_input))];
        } else if (_isSemi) {
          val = tagValue(utilGetSetValue(_input)) || "";
          val = val.replace(/,/g, ";");
          vals = val.split(";");
        }
        vals = vals.filter(Boolean);
        if (!vals.length)
          return;
        _container.classed("active", false);
        utilGetSetValue(_input, "");
        if (_isMulti) {
          utilArrayUniq(vals).forEach(function(v2) {
            var key = (field.key || "") + v2;
            if (_tags) {
              var old = _tags[key];
              if (typeof old === "string" && old.toLowerCase() !== "no")
                return;
            }
            key = context.cleanTagKey(key);
            field.keys.push(key);
            t2[key] = "yes";
          });
        } else if (_isSemi) {
          var arr = _multiData.map(function(d2) {
            return d2.key;
          });
          arr = arr.concat(vals);
          t2[field.key] = context.cleanTagValue(utilArrayUniq(arr).filter(Boolean).join(";"));
        }
        window.setTimeout(function() {
          _input.node().focus();
        }, 10);
      } else {
        var rawValue = utilGetSetValue(_input);
        if (!rawValue && Array.isArray(_tags[field.key]))
          return;
        val = context.cleanTagValue(tagValue(rawValue));
        t2[field.key] = val || void 0;
      }
      dispatch14.call("change", this, t2);
    }
    function removeMultikey(d3_event, d2) {
      d3_event.preventDefault();
      d3_event.stopPropagation();
      var t2 = {};
      if (_isMulti) {
        t2[d2.key] = void 0;
      } else if (_isSemi) {
        var arr = _multiData.map(function(md) {
          return md.key === d2.key ? null : md.key;
        }).filter(Boolean);
        arr = utilArrayUniq(arr);
        t2[field.key] = arr.length ? arr.join(";") : void 0;
        _lengthIndicator.update(t2[field.key]);
      }
      dispatch14.call("change", this, t2);
    }
    function invertMultikey(d3_event, d2) {
      d3_event.preventDefault();
      d3_event.stopPropagation();
      var t2 = {};
      if (_isMulti) {
        t2[d2.key] = _tags[d2.key] === "yes" ? "no" : "yes";
      }
      dispatch14.call("change", this, t2);
    }
    function combo(selection2) {
      _container = selection2.selectAll(".form-field-input-wrap").data([0]);
      var type2 = _isMulti || _isSemi ? "multicombo" : "combo";
      _container = _container.enter().append("div").attr("class", "form-field-input-wrap form-field-input-" + type2).merge(_container);
      if (_isMulti || _isSemi) {
        _container = _container.selectAll(".chiplist").data([0]);
        var listClass = "chiplist";
        if (field.key === "destination" || field.key === "via") {
          listClass += " full-line-chips";
        }
        _container = _container.enter().append("ul").attr("class", listClass).on("click", function() {
          window.setTimeout(function() {
            _input.node().focus();
          }, 10);
        }).merge(_container);
        _inputWrap = _container.selectAll(".input-wrap").data([0]);
        _inputWrap = _inputWrap.enter().append("li").attr("class", "input-wrap").merge(_inputWrap);
        var hideAdd = !_allowCustomValues && !_comboData.length;
        _inputWrap.style("display", hideAdd ? "none" : null);
        _input = _inputWrap.selectAll("input").data([0]);
      } else {
        _input = _container.selectAll("input").data([0]);
      }
      _input = _input.enter().append("input").attr("type", "text").attr("id", field.domId).call(utilNoAuto).call(initCombo, _container).merge(_input);
      if (_isSemi) {
        _inputWrap.call(_lengthIndicator);
      } else if (!_isMulti) {
        _container.call(_lengthIndicator);
      }
      if (_isNetwork) {
        var extent = combinedEntityExtent();
        var countryCode = extent && iso1A2Code(extent.center());
        _countryCode = countryCode && countryCode.toLowerCase();
      }
      _input.on("change", change).on("blur", change).on("input", function() {
        let val = utilGetSetValue(_input);
        updateIcon(val);
        if (_isSemi && _tags[field.key]) {
          val += ";" + _tags[field.key];
        }
        _lengthIndicator.update(val);
      });
      _input.on("keydown.field", function(d3_event) {
        switch (d3_event.keyCode) {
          case 13:
            _input.node().blur();
            d3_event.stopPropagation();
            break;
        }
      });
      if (_isMulti || _isSemi) {
        _combobox.on("accept", function() {
          _input.node().blur();
          _input.node().focus();
        });
        _input.on("focus", function() {
          _container.classed("active", true);
        });
      }
      _combobox.on("cancel", function() {
        _input.node().blur();
      }).on("update", function() {
        updateIcon(utilGetSetValue(_input));
      });
    }
    function updateIcon(value) {
      value = tagValue(value);
      let container = _container;
      if (field.type === "multiCombo" || field.type === "semiCombo") {
        container = _container.select(".input-wrap");
      }
      const iconsField = field.resolveReference("iconsCrossReference");
      if (iconsField.icons) {
        container.selectAll(".tag-value-icon").remove();
        if (iconsField.icons[value]) {
          container.selectAll(".tag-value-icon").data([value]).enter().insert("div", "input").attr("class", "tag-value-icon").call(svgIcon("#".concat(iconsField.icons[value])));
        }
      }
    }
    combo.tags = function(tags) {
      _tags = tags;
      var stringsField = field.resolveReference("stringsCrossReference");
      var isMixed = Array.isArray(tags[field.key]);
      var showsValue = (value) => !isMixed && value && !(field.type === "typeCombo" && value === "yes");
      var isRawValue = (value) => showsValue(value) && !stringsField.hasTextForStringId("options.".concat(value)) && !stringsField.hasTextForStringId("options.".concat(value, ".title"));
      var isKnownValue = (value) => showsValue(value) && !isRawValue(value);
      var isReadOnly = !_allowCustomValues;
      if (_isMulti || _isSemi) {
        _multiData = [];
        var maxLength;
        if (_isMulti) {
          for (var k2 in tags) {
            if (field.key && k2.indexOf(field.key) !== 0)
              continue;
            if (!field.key && field.keys.indexOf(k2) === -1)
              continue;
            var v2 = tags[k2];
            var suffix = field.key ? k2.slice(field.key.length) : k2;
            _multiData.push({
              key: k2,
              value: displayValue(suffix),
              display: addComboboxIcons(renderValue(suffix), suffix),
              state: typeof v2 === "string" ? v2.toLowerCase() : "",
              isMixed: Array.isArray(v2)
            });
          }
          if (field.key) {
            field.keys = _multiData.map(function(d2) {
              return d2.key;
            });
            maxLength = context.maxCharsForTagKey() - utilUnicodeCharsCount(field.key);
          } else {
            maxLength = context.maxCharsForTagKey();
          }
        } else if (_isSemi) {
          var allValues = [];
          var commonValues;
          if (Array.isArray(tags[field.key])) {
            tags[field.key].forEach(function(tagVal) {
              var thisVals = utilArrayUniq((tagVal || "").split(";")).filter(Boolean);
              allValues = allValues.concat(thisVals);
              if (!commonValues) {
                commonValues = thisVals;
              } else {
                commonValues = commonValues.filter((value) => thisVals.includes(value));
              }
            });
            allValues = utilArrayUniq(allValues).filter(Boolean);
          } else {
            allValues = utilArrayUniq((tags[field.key] || "").split(";")).filter(Boolean);
            commonValues = allValues;
          }
          _multiData = allValues.map(function(v3) {
            return {
              key: v3,
              value: displayValue(v3),
              display: addComboboxIcons(renderValue(v3), v3),
              isMixed: !commonValues.includes(v3)
            };
          });
          var currLength = utilUnicodeCharsCount(commonValues.join(";"));
          maxLength = context.maxCharsForTagValue() - currLength;
          if (currLength > 0) {
            maxLength -= 1;
          }
        }
        maxLength = Math.max(0, maxLength);
        var hideAdd = maxLength <= 0 || !_allowCustomValues && !_comboData.length;
        _container.selectAll(".chiplist .input-wrap").style("display", hideAdd ? "none" : null);
        var allowDragAndDrop = _isSemi && !Array.isArray(tags[field.key]);
        var chips = _container.selectAll(".chip").data(_multiData);
        chips.exit().remove();
        var enter = chips.enter().insert("li", ".input-wrap").attr("class", "chip");
        enter.append("span");
        const field_buttons = enter.append("div").attr("class", "field_buttons");
        field_buttons.append("a").attr("class", "remove");
        chips = chips.merge(enter).order().classed("raw-value", function(d2) {
          var k3 = d2.key;
          if (_isMulti)
            k3 = k3.replace(field.key, "");
          return !stringsField.hasTextForStringId("options." + k3);
        }).classed("draggable", allowDragAndDrop).classed("mixed", function(d2) {
          return d2.isMixed;
        }).attr("title", function(d2) {
          if (d2.isMixed) {
            return _t("inspector.unshared_value_tooltip");
          }
          if (!["yes", "no"].includes(d2.state)) {
            return d2.state;
          }
          return null;
        }).classed("negated", (d2) => d2.state === "no");
        if (!_isSemi) {
          chips.selectAll("input[type=checkbox]").remove();
          chips.insert("input", "span").attr("type", "checkbox").property("checked", (d2) => d2.state === "yes").property("indeterminate", (d2) => d2.isMixed || !["yes", "no"].includes(d2.state)).on("click", invertMultikey);
        }
        if (allowDragAndDrop) {
          registerDragAndDrop(chips);
        }
        chips.each(function(d2) {
          const selection2 = select_default2(this);
          const text_span = selection2.select("span");
          const field_buttons2 = selection2.select(".field_buttons");
          const clean_value = d2.value.trim();
          text_span.text("");
          if (!field_buttons2.select("button").empty()) {
            field_buttons2.select("button").remove();
          }
          if (clean_value.startsWith("https://")) {
            text_span.text(clean_value);
            field_buttons2.append("button").call(svgIcon("#iD-icon-out-link")).attr("class", "form-field-button foreign-id-permalink").attr("title", () => _t("icons.visit_website")).attr("aria-label", () => _t("icons.visit_website")).on("click", function(d3_event) {
              d3_event.preventDefault();
              window.open(clean_value, "_blank");
            });
            return;
          }
          if (d2.display) {
            d2.display(text_span);
            return;
          }
          text_span.text(d2.value);
        });
        chips.select("a.remove").attr("href", "#").on("click", removeMultikey).attr("class", "remove").text("\xD7");
        updateIcon("");
      } else {
        var mixedValues = isMixed && tags[field.key].map(function(val) {
          return displayValue(val);
        }).filter(Boolean);
        utilGetSetValue(_input, !isMixed ? displayValue(tags[field.key]) : "").data([tags[field.key]]).classed("raw-value", isRawValue).classed("known-value", isKnownValue).attr("readonly", isReadOnly ? "readonly" : void 0).attr("title", isMixed ? mixedValues.join("\n") : void 0).attr("placeholder", isMixed ? _t("inspector.multiple_values") : _staticPlaceholder || "").classed("mixed", isMixed).on("keydown.deleteCapture", function(d3_event) {
          if (isReadOnly && isKnownValue(tags[field.key]) && (d3_event.keyCode === utilKeybinding.keyCodes["\u232B"] || d3_event.keyCode === utilKeybinding.keyCodes["\u2326"])) {
            d3_event.preventDefault();
            d3_event.stopPropagation();
            var t2 = {};
            t2[field.key] = void 0;
            dispatch14.call("change", this, t2);
          }
        });
        if (!Array.isArray(tags[field.key])) {
          updateIcon(tags[field.key]);
        }
        if (!isMixed) {
          _lengthIndicator.update(tags[field.key]);
        }
      }
      const refreshStyles = () => {
        _input.data([tagValue(utilGetSetValue(_input))]).classed("raw-value", isRawValue).classed("known-value", isKnownValue);
      };
      _input.on("input.refreshStyles", refreshStyles);
      _combobox.on("update.refreshStyles", refreshStyles);
      refreshStyles();
    };
    function registerDragAndDrop(selection2) {
      var dragOrigin, targetIndex;
      selection2.call(
        drag_default().on("start", function(d3_event) {
          dragOrigin = {
            x: d3_event.x,
            y: d3_event.y
          };
          targetIndex = null;
        }).on("drag", function(d3_event) {
          var x2 = d3_event.x - dragOrigin.x, y2 = d3_event.y - dragOrigin.y;
          if (!select_default2(this).classed("dragging") && // don't display drag until dragging beyond a distance threshold
          Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2)) <= 5)
            return;
          var index = selection2.nodes().indexOf(this);
          select_default2(this).classed("dragging", true);
          targetIndex = null;
          var targetIndexOffsetTop = null;
          var draggedTagWidth = select_default2(this).node().offsetWidth;
          if (field.key === "destination" || field.key === "via") {
            _container.selectAll(".chip").style("transform", function(d2, index2) {
              var node = select_default2(this).node();
              if (index === index2) {
                return "translate(" + x2 + "px, " + y2 + "px)";
              } else if (index2 > index && d3_event.y > node.offsetTop) {
                if (targetIndex === null || index2 > targetIndex) {
                  targetIndex = index2;
                }
                return "translateY(-100%)";
              } else if (index2 < index && d3_event.y < node.offsetTop + node.offsetHeight) {
                if (targetIndex === null || index2 < targetIndex) {
                  targetIndex = index2;
                }
                return "translateY(100%)";
              }
              return null;
            });
          } else {
            _container.selectAll(".chip").each(function(d2, index2) {
              var node = select_default2(this).node();
              if (index !== index2 && d3_event.x < node.offsetLeft + node.offsetWidth + 5 && d3_event.x > node.offsetLeft && d3_event.y < node.offsetTop + node.offsetHeight && d3_event.y > node.offsetTop) {
                targetIndex = index2;
                targetIndexOffsetTop = node.offsetTop;
              }
            }).style("transform", function(d2, index2) {
              var node = select_default2(this).node();
              if (index === index2) {
                return "translate(" + x2 + "px, " + y2 + "px)";
              }
              if (node.offsetTop === targetIndexOffsetTop) {
                if (index2 < index && index2 >= targetIndex) {
                  return "translateX(" + draggedTagWidth + "px)";
                } else if (index2 > index && index2 <= targetIndex) {
                  return "translateX(-" + draggedTagWidth + "px)";
                }
              }
              return null;
            });
          }
        }).on("end", function() {
          if (!select_default2(this).classed("dragging")) {
            return;
          }
          var index = selection2.nodes().indexOf(this);
          select_default2(this).classed("dragging", false);
          _container.selectAll(".chip").style("transform", null);
          if (typeof targetIndex === "number") {
            var element = _multiData[index];
            _multiData.splice(index, 1);
            _multiData.splice(targetIndex, 0, element);
            var t2 = {};
            if (_multiData.length) {
              t2[field.key] = _multiData.map(function(element2) {
                return element2.key;
              }).join(";");
            } else {
              t2[field.key] = void 0;
            }
            dispatch14.call("change", this, t2);
          }
          dragOrigin = void 0;
          targetIndex = void 0;
        })
      );
    }
    combo.focus = function() {
      _input.node().focus();
    };
    combo.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      _entityIDs = val;
      return combo;
    };
    function combinedEntityExtent() {
      return _entityIDs && _entityIDs.length && utilTotalExtent(_entityIDs, context.graph());
    }
    return utilRebind(combo, dispatch14, "on");
  }

  // modules/ui/fields/input.js
  var likelyRawNumberFormat = /^-?(0\.\d*|\d*\.\d{0,2}(\d{4,})?|\d{4,}\.\d{3})$/;
  function uiFieldText(field, context) {
    var dispatch14 = dispatch_default("change");
    var input = select_default2(null);
    var outlinkButton = select_default2(null);
    var wrap2 = select_default2(null);
    var _lengthIndicator = uiLengthIndicator(context.maxCharsForTagValue());
    var _entityIDs = [];
    var _tags;
    var _phoneFormats = {};
    const isDirectionField = field.key.split(":").some((keyPart) => keyPart === "direction");
    const formatFloat = _mainLocalizer.floatFormatter(_mainLocalizer.languageCode());
    const parseLocaleFloat = _mainLocalizer.floatParser(_mainLocalizer.languageCode());
    const countDecimalPlaces = _mainLocalizer.decimalPlaceCounter(_mainLocalizer.languageCode());
    if (field.type === "tel") {
      _mainFileFetcher.get("phone_formats").then(function(d2) {
        _phoneFormats = d2;
        updatePhonePlaceholder();
      }).catch(function() {
      });
    }
    function calcLocked() {
      var isLocked = (field.id === "brand" || field.id === "network" || field.id === "operator" || field.id === "flag") && _entityIDs.length && _entityIDs.some(function(entityID) {
        var entity = context.graph().hasEntity(entityID);
        if (!entity)
          return false;
        if (entity.tags.wikidata)
          return true;
        var preset = _mainPresetIndex.match(entity, context.graph());
        var isSuggestion = preset && preset.suggestion;
        var which = field.id;
        return isSuggestion && !!entity.tags[which] && !!entity.tags[which + ":wikidata"];
      });
      field.locked(isLocked);
    }
    function i3(selection2) {
      calcLocked();
      var isLocked = field.locked();
      wrap2 = selection2.selectAll(".form-field-input-wrap").data([0]);
      wrap2 = wrap2.enter().append("div").attr("class", "form-field-input-wrap form-field-input-" + field.type).merge(wrap2);
      input = wrap2.selectAll("input").data([0]);
      input = input.enter().append("input").attr("type", field.type === "identifier" ? "text" : field.type).attr("id", field.domId).classed(field.type, true).call(utilNoAuto).merge(input);
      input.classed("disabled", !!isLocked).attr("readonly", isLocked || null).on("input", change(true)).on("blur", change()).on("change", change());
      wrap2.call(_lengthIndicator);
      if (field.type === "tel") {
        updatePhonePlaceholder();
      } else if (field.type === "number") {
        var rtl = _mainLocalizer.textDirection() === "rtl";
        input.attr("type", "text");
        var inc = field.increment;
        var buttons = wrap2.selectAll(".increment, .decrement").data(rtl ? [inc, -inc] : [-inc, inc]);
        buttons.enter().append("button").attr("class", function(d2) {
          var which = d2 > 0 ? "increment" : "decrement";
          return "form-field-button " + which;
        }).attr("title", function(d2) {
          var which = d2 > 0 ? "increment" : "decrement";
          return _t("inspector.".concat(which));
        }).merge(buttons).on("click", function(d3_event, d2) {
          d3_event.preventDefault();
          var isMixed = Array.isArray(_tags[field.key]);
          if (isMixed)
            return;
          var raw_vals = input.node().value || "0";
          var vals = raw_vals.split(";");
          vals = vals.map(function(v2) {
            v2 = v2.trim();
            const isRawNumber = likelyRawNumberFormat.test(v2);
            var num = isRawNumber ? parseFloat(v2) : parseLocaleFloat(v2);
            if (isDirectionField) {
              const compassDir = cardinal[v2.toLowerCase()];
              if (compassDir !== void 0) {
                num = compassDir;
              }
            }
            if (!isFinite(num))
              return v2;
            num = parseFloat(num);
            if (!isFinite(num))
              return v2;
            num += d2;
            if (isDirectionField) {
              num = (num % 360 + 360) % 360;
            }
            return formatFloat(clamped(num), isRawNumber ? v2.includes(".") ? v2.split(".")[1].length : 0 : countDecimalPlaces(v2));
          });
          input.node().value = vals.join(";");
          change()();
        });
      } else if (field.type === "identifier" && field.urlFormat && field.pattern) {
        input.attr("type", "text");
        outlinkButton = wrap2.selectAll(".foreign-id-permalink").data([0]);
        outlinkButton = outlinkButton.enter().append("button").call(svgIcon("#iD-icon-out-link")).attr("class", "form-field-button foreign-id-permalink").attr("title", function() {
          var domainResults = /^https?:\/\/(.{1,}?)\//.exec(field.urlFormat);
          if (domainResults.length >= 2 && domainResults[1]) {
            var domain = domainResults[1];
            return _t("icons.view_on", { domain });
          }
          return "";
        }).merge(outlinkButton);
        outlinkButton.on("click", function(d3_event) {
          d3_event.preventDefault();
          var value = validIdentifierValueForLink();
          if (value) {
            var url = field.urlFormat.replace(/{value}/, encodeURIComponent(value));
            window.open(url, "_blank");
          }
        }).classed("disabled", () => !validIdentifierValueForLink()).merge(outlinkButton);
      } else if (field.type === "url") {
        input.attr("type", "text");
        outlinkButton = wrap2.selectAll(".foreign-id-permalink").data([0]);
        outlinkButton.enter().append("button").call(svgIcon("#iD-icon-out-link")).attr("class", "form-field-button foreign-id-permalink").attr("title", () => _t("icons.visit_website")).on("click", function(d3_event) {
          d3_event.preventDefault();
          const value = validIdentifierValueForLink();
          if (value)
            window.open(value, "_blank");
        }).merge(outlinkButton);
      } else if (field.type === "colour") {
        input.attr("type", "text");
        updateColourPreview();
      } else if (field.type === "date") {
        input.attr("type", "text");
        updateDateField();
      }
    }
    function updateColourPreview() {
      wrap2.selectAll(".colour-preview").remove();
      const colour = utilGetSetValue(input);
      if (!isColourValid(colour) && colour !== "") {
        wrap2.selectAll("input.colour-selector").remove();
        wrap2.selectAll(".form-field-button").remove();
        return;
      }
      var colourSelector = wrap2.selectAll(".colour-selector").data([0]);
      colourSelector.enter().append("input").attr("type", "color").attr("class", "colour-selector").on("input", debounce_default(function(d3_event) {
        d3_event.preventDefault();
        var colour2 = this.value;
        if (!isColourValid(colour2))
          return;
        utilGetSetValue(input, this.value);
        change()();
        updateColourPreview();
      }, 100));
      wrap2.selectAll("input.colour-selector").attr("value", colour);
      var chooserButton = wrap2.selectAll(".colour-preview").data([colour]);
      chooserButton = chooserButton.enter().append("div").attr("class", "form-field-button colour-preview").append("div").style("background-color", (d2) => d2).attr("class", "colour-box");
      if (colour === "") {
        chooserButton = chooserButton.call(svgIcon("#iD-icon-edit"));
      }
      chooserButton.on("click", () => wrap2.select(".colour-selector").node().showPicker());
    }
    function updateDateField() {
      function isDateValid(date2) {
        return date2.match(/^[0-9]{4}(-[0-9]{2}(-[0-9]{2})?)?$/);
      }
      const date = utilGetSetValue(input);
      const now3 = /* @__PURE__ */ new Date();
      const today = new Date(now3.getTime() - now3.getTimezoneOffset() * 6e4).toISOString().split("T")[0];
      if ((field.key === "check_date" || field.key === "survey:date") && date !== today) {
        wrap2.selectAll(".date-set-today").data([0]).enter().append("button").attr("class", "form-field-button date-set-today").call(svgIcon("#fas-rotate")).call(uiTooltip().title(() => _t.append("inspector.set_today"))).on("click", () => {
          utilGetSetValue(input, today);
          change()();
          updateDateField();
        });
      } else {
        wrap2.selectAll(".date-set-today").remove();
      }
      if (!isDateValid(date) && date !== "") {
        wrap2.selectAll("input.date-selector").remove();
        wrap2.selectAll(".date-calendar").remove();
        return;
      }
      if (utilDetect().browser !== "Safari") {
        var dateSelector = wrap2.selectAll(".date-selector").data([0]);
        dateSelector.enter().append("input").attr("type", "date").attr("class", "date-selector").on("input", debounce_default(function(d3_event) {
          d3_event.preventDefault();
          var date2 = this.value;
          if (!isDateValid(date2))
            return;
          utilGetSetValue(input, this.value);
          change()();
          updateDateField();
        }, 100));
        wrap2.selectAll("input.date-selector").attr("value", date);
        var calendarButton = wrap2.selectAll(".date-calendar").data([date]);
        calendarButton = calendarButton.enter().append("button").attr("class", "form-field-button date-calendar").call(svgIcon("#fas-calendar-days"));
        calendarButton.on("click", () => wrap2.select(".date-selector").node().showPicker());
      }
    }
    function updatePhonePlaceholder() {
      if (input.empty() || !Object.keys(_phoneFormats).length)
        return;
      var extent = combinedEntityExtent();
      var countryCode = extent && iso1A2Code(extent.center());
      var format2 = countryCode && _phoneFormats[countryCode.toLowerCase()];
      if (format2)
        input.attr("placeholder", format2);
    }
    function validIdentifierValueForLink() {
      var _a2;
      const value = utilGetSetValue(input).trim();
      if (field.type === "url" && value) {
        try {
          return new URL(value).href;
        } catch {
          return null;
        }
      }
      if (field.type === "identifier" && field.pattern) {
        return value && ((_a2 = value.match(new RegExp(field.pattern))) == null ? void 0 : _a2[0]);
      }
      return null;
    }
    function clamped(num) {
      if (field.minValue !== void 0) {
        num = Math.max(num, field.minValue);
      }
      if (field.maxValue !== void 0) {
        num = Math.min(num, field.maxValue);
      }
      return num;
    }
    function getVals(tags) {
      if (field.keys) {
        const multiSelection = context.selectedIDs();
        tags = multiSelection.length > 1 ? context.selectedIDs().map((id2) => context.graph().entity(id2)).map((entity) => entity.tags) : [tags];
        return tags.map((tags2) => new Set(field.keys.reduce((acc, key) => acc.concat(tags2[key]), []).filter(Boolean))).map((vals) => vals.size === 0 ? /* @__PURE__ */ new Set([void 0]) : vals).reduce((a2, b2) => /* @__PURE__ */ new Set([...a2, ...b2]));
      } else {
        return new Set([].concat(tags[field.key]));
      }
    }
    function change(onInput) {
      return function() {
        var t2 = {};
        var val = utilGetSetValue(input);
        if (!onInput)
          val = context.cleanTagValue(val);
        if (!val && getVals(_tags).size > 1)
          return;
        var displayVal = val;
        if (field.type === "number" && val) {
          var numbers2 = val.split(";");
          numbers2 = numbers2.map(function(v2) {
            if (likelyRawNumberFormat.test(v2)) {
              return v2;
            }
            var num = parseLocaleFloat(v2);
            const fractionDigits = countDecimalPlaces(v2);
            return isFinite(num) ? clamped(num).toFixed(fractionDigits) : v2;
          });
          val = numbers2.join(";");
        }
        if (!onInput)
          utilGetSetValue(input, displayVal);
        t2[field.key] = val || void 0;
        if (field.keys) {
          dispatch14.call("change", this, (tags) => {
            if (field.keys.some((key) => tags[key])) {
              field.keys.filter((key) => tags[key]).forEach((key) => {
                tags[key] = val || void 0;
              });
            } else {
              tags[field.key] = val || void 0;
            }
            return tags;
          }, onInput);
        } else {
          dispatch14.call("change", this, t2, onInput);
        }
      };
    }
    i3.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      _entityIDs = val;
      return i3;
    };
    i3.tags = function(tags) {
      var _a2;
      _tags = tags;
      const vals = getVals(tags);
      const isMixed = vals.size > 1;
      var val = vals.size === 1 ? (_a2 = [...vals][0]) != null ? _a2 : "" : "";
      var shouldUpdate;
      if (field.type === "number" && val) {
        var numbers2 = val.split(";");
        var oriNumbers = utilGetSetValue(input).split(";");
        if (numbers2.length !== oriNumbers.length)
          shouldUpdate = true;
        numbers2 = numbers2.map(function(v2) {
          v2 = v2.trim();
          var num = Number(v2);
          if (!isFinite(num) || v2 === "")
            return v2;
          const fractionDigits = v2.includes(".") ? v2.split(".")[1].length : 0;
          return formatFloat(num, fractionDigits);
        });
        val = numbers2.join(";");
        shouldUpdate = (inputValue, setValue) => {
          const inputNums = inputValue.split(";").map(
            (setVal) => likelyRawNumberFormat.test(setVal) ? parseFloat(setVal) : parseLocaleFloat(setVal)
          );
          const setNums = setValue.split(";").map(parseLocaleFloat);
          return !isEqual_default(inputNums, setNums);
        };
      }
      utilGetSetValue(input, val, shouldUpdate).attr("title", isMixed ? [...vals].join("\n") : void 0).attr("placeholder", isMixed ? _t("inspector.multiple_values") : field.placeholder() || _t("inspector.unknown")).classed("mixed", isMixed);
      if (field.type === "number") {
        const buttons = wrap2.selectAll(".increment, .decrement");
        if (isMixed) {
          buttons.attr("disabled", "disabled").classed("disabled", true);
        } else {
          var raw_vals = tags[field.key] || "0";
          const canIncDec = raw_vals.split(";").some((val2) => isFinite(Number(val2)) || isDirectionField && cardinal[val2.trim().toLowerCase()]);
          buttons.attr("disabled", canIncDec ? null : "disabled").classed("disabled", !canIncDec);
        }
      }
      if (field.type === "tel")
        updatePhonePlaceholder();
      if (field.type === "colour")
        updateColourPreview();
      if (field.type === "date")
        updateDateField();
      if (outlinkButton && !outlinkButton.empty()) {
        var disabled = !validIdentifierValueForLink();
        outlinkButton.classed("disabled", disabled);
      }
      if (!isMixed) {
        _lengthIndicator.update(tags[field.key]);
      }
    };
    i3.focus = function() {
      var node = input.node();
      if (node)
        node.focus();
    };
    function combinedEntityExtent() {
      return _entityIDs && _entityIDs.length && utilTotalExtent(_entityIDs, context.graph());
    }
    return utilRebind(i3, dispatch14, "on");
  }

  // modules/ui/fields/access.js
  function uiFieldAccess(field, context) {
    var dispatch14 = dispatch_default("change");
    var items = select_default2(null);
    var _tags;
    function access(selection2) {
      var wrap2 = selection2.selectAll(".form-field-input-wrap").data([0]);
      wrap2 = wrap2.enter().append("div").attr("class", "form-field-input-wrap form-field-input-" + field.type).merge(wrap2);
      var list2 = wrap2.selectAll("ul").data([0]);
      list2 = list2.enter().append("ul").attr("class", "rows").merge(list2);
      items = list2.selectAll("li").data(field.keys);
      var enter = items.enter().append("li").attr("class", function(d2) {
        return "labeled-input preset-access-" + d2;
      });
      enter.append("div").attr("class", "label preset-label-access").attr("for", function(d2) {
        return "preset-input-access-" + d2;
      }).html(function(d2) {
        return field.t.html("types." + d2);
      });
      enter.append("div").attr("class", "preset-input-access-wrap").append("input").attr("type", "text").attr("class", function(d2) {
        return "preset-input-access preset-input-access-" + d2;
      }).call(utilNoAuto).each(function(d2) {
        select_default2(this).call(
          uiCombobox(context, "access-" + d2).data(access.options(d2))
        );
      });
      items = items.merge(enter);
      wrap2.selectAll(".preset-input-access").on("change", change).on("blur", change);
    }
    function change(d3_event, d2) {
      var tag2 = {};
      var value = context.cleanTagValue(utilGetSetValue(select_default2(this)));
      if (!value && typeof _tags[d2] !== "string")
        return;
      tag2[d2] = value || void 0;
      dispatch14.call("change", this, tag2);
    }
    access.options = function(type2) {
      var options2 = [
        "yes",
        "no",
        "designated",
        "permissive",
        "destination",
        "customers",
        "private",
        "permit",
        "unknown"
      ];
      if (type2 === "access") {
        options2 = options2.filter((v2) => v2 !== "yes" && v2 !== "designated");
      }
      if (type2 === "bicycle") {
        options2.splice(options2.length - 4, 0, "dismount");
      }
      var stringsField = field.resolveReference("stringsCrossReference");
      return options2.map(function(option) {
        return {
          title: stringsField.t("options." + option + ".description"),
          value: option
        };
      });
    };
    const placeholdersByTag = {
      highway: {
        footway: {
          foot: "designated",
          motor_vehicle: "no"
        },
        steps: {
          foot: "yes",
          motor_vehicle: "no",
          bicycle: "no",
          horse: "no"
        },
        pedestrian: {
          foot: "yes",
          motor_vehicle: "no"
        },
        cycleway: {
          motor_vehicle: "no",
          bicycle: "designated"
        },
        bridleway: {
          motor_vehicle: "no",
          horse: "designated"
        },
        path: {
          foot: "yes",
          motor_vehicle: "no",
          bicycle: "yes",
          horse: "yes"
        },
        motorway: {
          foot: "no",
          motor_vehicle: "yes",
          bicycle: "no",
          horse: "no"
        },
        trunk: {
          motor_vehicle: "yes"
        },
        primary: {
          foot: "yes",
          motor_vehicle: "yes",
          bicycle: "yes",
          horse: "yes"
        },
        secondary: {
          foot: "yes",
          motor_vehicle: "yes",
          bicycle: "yes",
          horse: "yes"
        },
        tertiary: {
          foot: "yes",
          motor_vehicle: "yes",
          bicycle: "yes",
          horse: "yes"
        },
        residential: {
          foot: "yes",
          motor_vehicle: "yes",
          bicycle: "yes",
          horse: "yes"
        },
        unclassified: {
          foot: "yes",
          motor_vehicle: "yes",
          bicycle: "yes",
          horse: "yes"
        },
        service: {
          foot: "yes",
          motor_vehicle: "yes",
          bicycle: "yes",
          horse: "yes"
        },
        motorway_link: {
          foot: "no",
          motor_vehicle: "yes",
          bicycle: "no",
          horse: "no"
        },
        trunk_link: {
          motor_vehicle: "yes"
        },
        primary_link: {
          foot: "yes",
          motor_vehicle: "yes",
          bicycle: "yes",
          horse: "yes"
        },
        secondary_link: {
          foot: "yes",
          motor_vehicle: "yes",
          bicycle: "yes",
          horse: "yes"
        },
        tertiary_link: {
          foot: "yes",
          motor_vehicle: "yes",
          bicycle: "yes",
          horse: "yes"
        },
        construction: {
          access: "no"
        },
        busway: {
          access: "no",
          bus: "designated",
          emergency: "yes"
        }
      },
      barrier: {
        bollard: {
          access: "no",
          bicycle: "yes",
          foot: "yes"
        },
        bus_trap: {
          motor_vehicle: "no",
          psv: "yes",
          foot: "yes",
          bicycle: "yes"
        },
        city_wall: {
          access: "no"
        },
        coupure: {
          access: "yes"
        },
        cycle_barrier: {
          motor_vehicle: "no"
        },
        ditch: {
          access: "no"
        },
        entrance: {
          access: "yes"
        },
        fence: {
          access: "no"
        },
        hedge: {
          access: "no"
        },
        jersey_barrier: {
          access: "no"
        },
        motorcycle_barrier: {
          motor_vehicle: "no"
        },
        rail_guard: {
          access: "no"
        }
      }
    };
    access.tags = function(tags) {
      _tags = tags;
      utilGetSetValue(items.selectAll(".preset-input-access"), function(d2) {
        return typeof tags[d2] === "string" ? tags[d2] : "";
      }).classed("mixed", function(d2) {
        return tags[d2] && Array.isArray(tags[d2]);
      }).attr("title", function(d2) {
        return tags[d2] && Array.isArray(tags[d2]) && tags[d2].filter(Boolean).join("\n");
      }).attr("placeholder", function(d2) {
        if (tags[d2] && Array.isArray(tags[d2])) {
          return _t("inspector.multiple_values");
        }
        if (d2 === "bicycle" || d2 === "motor_vehicle") {
          if (tags.vehicle && typeof tags.vehicle === "string") {
            return tags.vehicle;
          }
        }
        if (tags.access && typeof tags.access === "string") {
          return tags.access;
        }
        function getPlaceholdersByTag(key, placeholdersByKey) {
          if (typeof tags[key] === "string") {
            if (placeholdersByKey[tags[key]] && placeholdersByKey[tags[key]][d2]) {
              return placeholdersByKey[tags[key]][d2];
            }
          } else {
            var impliedAccesses = tags[key].filter(Boolean).map(function(val) {
              return placeholdersByKey[val] && placeholdersByKey[val][d2];
            }).filter(Boolean);
            if (impliedAccesses.length === tags[key].length && new Set(impliedAccesses).size === 1) {
              return impliedAccesses[0];
            }
          }
        }
        for (const key in placeholdersByTag) {
          if (tags[key]) {
            const impliedAccess = getPlaceholdersByTag(key, placeholdersByTag[key]);
            if (impliedAccess) {
              return impliedAccess;
            }
          }
        }
        if (d2 === "access" && !tags.barrier) {
          return "yes";
        }
        return field.placeholder();
      });
    };
    access.focus = function() {
      items.selectAll(".preset-input-access").node().focus();
    };
    return utilRebind(access, dispatch14, "on");
  }

  // modules/ui/fields/address.js
  function uiFieldAddress(field, context) {
    var dispatch14 = dispatch_default("change");
    var _selection = select_default2(null);
    var _wrap = select_default2(null);
    var addrField = _mainPresetIndex.field("address");
    var _entityIDs = [];
    var _tags;
    var _countryCode;
    var _addressFormats = [{
      format: [
        ["housenumber", "street"],
        ["city", "postcode"]
      ]
    }];
    _mainFileFetcher.get("address_formats").then(function(d2) {
      _addressFormats = d2;
      if (!_selection.empty()) {
        _selection.call(address);
      }
    }).catch(function() {
    });
    function getNear(isAddressable, type2, searchRadius, resultProp) {
      var extent = combinedEntityExtent();
      var l2 = extent.center();
      var box = geoExtent(l2).padByMeters(searchRadius);
      var features = context.history().intersects(box).filter(isAddressable).map((d2) => {
        let dist = geoSphericalDistance(d2.extent(context.graph()).center(), l2);
        if (d2.geometry(context.graph()) === "line") {
          var loc = context.projection([
            (extent[0][0] + extent[1][0]) / 2,
            (extent[0][1] + extent[1][1]) / 2
          ]);
          var choice = geoChooseEdge(context.graph().childNodes(d2), loc, context.projection);
          dist = geoSphericalDistance(choice.loc, l2);
        }
        const value = resultProp && d2.tags[resultProp] ? d2.tags[resultProp] : d2.tags.name;
        let title = value;
        if (type2 === "street") {
          title = "".concat(addrField.t("placeholders.street"), ": ").concat(title);
        } else if (type2 === "place") {
          title = "".concat(addrField.t("placeholders.place"), ": ").concat(title);
        }
        return {
          title,
          value,
          dist,
          type: type2,
          klass: "address-".concat(type2)
        };
      }).sort(function(a2, b2) {
        return a2.dist - b2.dist;
      });
      return utilArrayUniqBy(features, "value");
    }
    function getNearStreets() {
      function isAddressable(d2) {
        return d2.tags.highway && d2.tags.name && d2.type === "way";
      }
      return getNear(isAddressable, "street", 200);
    }
    function getNearPlaces() {
      function isAddressable(d2) {
        if (d2.tags.name) {
          if (d2.tags.place)
            return true;
          if (d2.tags.boundary === "administrative" && d2.tags.admin_level > 8)
            return true;
        }
        return false;
      }
      return getNear(isAddressable, "place", 200);
    }
    function getNearCities() {
      function isAddressable(d2) {
        if (d2.tags.name) {
          if (d2.tags.boundary === "administrative" && d2.tags.admin_level === "8")
            return true;
          if (d2.tags.border_type === "city")
            return true;
          if (d2.tags.place === "city" || d2.tags.place === "town" || d2.tags.place === "village")
            return true;
        }
        if (d2.tags["".concat(field.key, ":city")])
          return true;
        return false;
      }
      return getNear(isAddressable, "city", 200, "".concat(field.key, ":city"));
    }
    function getNearPostcodes() {
      return [...new Set([].concat(getNearValues("postcode")).concat(getNear((d2) => d2.tags.postal_code, "postcode", 200, "postal_code")))];
    }
    function getNearValues(key) {
      const tagKey = "".concat(field.key, ":").concat(key);
      function hasTag(d2) {
        return _entityIDs.indexOf(d2.id) === -1 && d2.tags[tagKey];
      }
      return getNear(hasTag, key, 200, tagKey);
    }
    function updateForCountryCode() {
      if (!_countryCode)
        return;
      var addressFormat;
      for (var i3 = 0; i3 < _addressFormats.length; i3++) {
        var format2 = _addressFormats[i3];
        if (!format2.countryCodes) {
          addressFormat = format2;
        } else if (format2.countryCodes.indexOf(_countryCode) !== -1) {
          addressFormat = format2;
          break;
        }
      }
      var dropdowns = addressFormat.dropdowns || [
        "city",
        "county",
        "country",
        "district",
        "hamlet",
        "neighbourhood",
        "place",
        "postcode",
        "province",
        "quarter",
        "state",
        "street",
        "street+place",
        "subdistrict",
        "suburb"
      ];
      var widths = addressFormat.widths || {
        housenumber: 1 / 5,
        unit: 1 / 5,
        street: 1 / 2,
        place: 1 / 2,
        city: 2 / 3,
        state: 1 / 4,
        postcode: 1 / 3
      };
      function row(r2) {
        var total = r2.reduce(function(sum, key) {
          return sum + (widths[key] || 0.5);
        }, 0);
        return r2.map(function(key) {
          return {
            id: key,
            width: (widths[key] || 0.5) / total
          };
        });
      }
      var rows = _wrap.selectAll(".addr-row").data(addressFormat.format, function(d2) {
        return d2.toString();
      });
      rows.exit().remove();
      rows.enter().append("div").attr("class", "addr-row").selectAll("input").data(row).enter().append("input").property("type", "text").call(updatePlaceholder).attr("class", function(d2) {
        return "addr-" + d2.id;
      }).call(utilNoAuto).each(addDropdown).style("width", function(d2) {
        return d2.width * 100 + "%";
      });
      function addDropdown(d2) {
        if (dropdowns.indexOf(d2.id) === -1)
          return;
        var nearValues;
        switch (d2.id) {
          case "street":
            nearValues = getNearStreets;
            break;
          case "place":
            nearValues = getNearPlaces;
            break;
          case "street+place":
            nearValues = () => [].concat(getNearStreets()).concat(getNearPlaces());
            d2.isAutoStreetPlace = true;
            d2.id = _tags["".concat(field.key, ":place")] ? "place" : "street";
            break;
          case "city":
            nearValues = getNearCities;
            break;
          case "postcode":
            nearValues = getNearPostcodes;
            break;
          default:
            nearValues = getNearValues;
        }
        select_default2(this).call(
          uiCombobox(context, "address-".concat(d2.isAutoStreetPlace ? "street-place" : d2.id)).minItems(1).caseSensitive(true).fetcher(function(typedValue, callback) {
            typedValue = typedValue.toLowerCase();
            callback(nearValues(d2.id).filter((v2) => v2.value.toLowerCase().indexOf(typedValue) !== -1));
          }).on("accept", function(selected) {
            if (d2.isAutoStreetPlace) {
              d2.id = selected ? selected.type : "street";
            }
          })
        );
      }
      _wrap.selectAll("input").on("blur", change()).on("change", change());
      _wrap.selectAll("input:not(.combobox-input)").on("input", change(true));
      if (_tags)
        updateTags(_tags);
    }
    function address(selection2) {
      _selection = selection2;
      _wrap = selection2.selectAll(".form-field-input-wrap").data([0]);
      _wrap = _wrap.enter().append("div").attr("class", "form-field-input-wrap form-field-input-" + field.type).merge(_wrap);
      var extent = combinedEntityExtent();
      if (extent) {
        var countryCode;
        if (context.inIntro()) {
          countryCode = _t("intro.graph.countrycode");
        } else {
          var center = extent.center();
          countryCode = iso1A2Code(center);
        }
        if (countryCode) {
          _countryCode = countryCode.toLowerCase();
          updateForCountryCode();
        }
      }
    }
    function change(onInput) {
      return function() {
        setTimeout(() => {
          var tags = {};
          _wrap.selectAll("input").each(function(subfield) {
            var key = field.key + ":" + subfield.id;
            var value = this.value;
            if (!onInput)
              value = context.cleanTagValue(value);
            if (Array.isArray(_tags[key]) && !value)
              return;
            if (subfield.isAutoStreetPlace) {
              if (subfield.id === "street") {
                tags["".concat(field.key, ":place")] = void 0;
              } else if (subfield.id === "place") {
                tags["".concat(field.key, ":street")] = void 0;
              }
            }
            tags[key] = value || void 0;
          });
          Object.keys(tags).filter((k2) => tags[k2]).forEach((k2) => _tags[k2] = tags[k2]);
          dispatch14.call("change", this, tags, onInput);
        }, 0);
      };
    }
    function updatePlaceholder(inputSelection) {
      return inputSelection.attr("placeholder", function(subfield) {
        if (_tags && Array.isArray(_tags[field.key + ":" + subfield.id])) {
          return _t("inspector.multiple_values");
        }
        if (subfield.isAutoStreetPlace) {
          return "".concat(getLocalPlaceholder("street"), " / ").concat(getLocalPlaceholder("place"));
        }
        return getLocalPlaceholder(subfield.id);
      });
    }
    function getLocalPlaceholder(key) {
      if (_countryCode) {
        var localkey = key + "!" + _countryCode;
        var tkey = addrField.hasTextForStringId("placeholders." + localkey) ? localkey : key;
        return addrField.t("placeholders." + tkey);
      }
    }
    function updateTags(tags) {
      utilGetSetValue(_wrap.selectAll("input"), (subfield) => {
        var val;
        if (subfield.isAutoStreetPlace) {
          const streetKey = "".concat(field.key, ":street");
          const placeKey = "".concat(field.key, ":place");
          if (tags[streetKey] !== void 0 || tags[placeKey] === void 0) {
            val = tags[streetKey];
            subfield.id = "street";
          } else {
            val = tags[placeKey];
            subfield.id = "place";
          }
        } else {
          val = tags["".concat(field.key, ":").concat(subfield.id)];
        }
        return typeof val === "string" ? val : "";
      }).attr("title", function(subfield) {
        var val = tags[field.key + ":" + subfield.id];
        return val && Array.isArray(val) ? val.filter(Boolean).join("\n") : void 0;
      }).classed("mixed", function(subfield) {
        return Array.isArray(tags[field.key + ":" + subfield.id]);
      }).call(updatePlaceholder);
    }
    function combinedEntityExtent() {
      return _entityIDs && _entityIDs.length && utilTotalExtent(_entityIDs, context.graph());
    }
    address.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      _entityIDs = val;
      return address;
    };
    address.tags = function(tags) {
      _tags = tags;
      updateTags(tags);
    };
    address.focus = function() {
      var node = _wrap.selectAll("input").node();
      if (node)
        node.focus();
    };
    return utilRebind(address, dispatch14, "on");
  }

  // modules/ui/fields/directional_combo.js
  function uiFieldDirectionalCombo(field, context) {
    var dispatch14 = dispatch_default("change");
    var items = select_default2(null);
    var wrap2 = select_default2(null);
    var _tags;
    var _combos = {};
    if (field.type === "cycleway") {
      field = {
        ...field,
        key: field.keys[0],
        keys: field.keys.slice(1)
      };
    }
    function directionalCombo(selection2) {
      function stripcolon(s2) {
        return s2.replace(":", "");
      }
      wrap2 = selection2.selectAll(".form-field-input-wrap").data([0]);
      wrap2 = wrap2.enter().append("div").attr("class", "form-field-input-wrap form-field-input-" + field.type).merge(wrap2);
      var div = wrap2.selectAll("ul").data([0]);
      div = div.enter().append("ul").attr("class", "rows rows-table").merge(div);
      items = div.selectAll("li").data(field.keys);
      var enter = items.enter().append("li").attr("class", function(d2) {
        return "labeled-input preset-directionalcombo-" + stripcolon(d2);
      });
      enter.append("div").attr("class", "label preset-label-directionalcombo").attr("for", function(d2) {
        return "preset-input-directionalcombo-" + stripcolon(d2);
      }).html(function(d2) {
        return field.t.html("types." + d2);
      });
      enter.append("div").attr("class", "preset-input-directionalcombo-wrap form-field-input-wrap").each(function(key) {
        const subField = {
          ...field,
          type: "combo",
          key
        };
        const combo = uiFieldCombo(subField, context);
        combo.on("change", (t2) => change(key, t2[key]));
        _combos[key] = combo;
        select_default2(this).call(combo);
      });
      items = items.merge(enter);
      wrap2.selectAll(".preset-input-directionalcombo").on("change", change).on("blur", change);
    }
    function change(key, newValue) {
      const commonKey = field.key;
      const otherKey = key === field.keys[0] ? field.keys[1] : field.keys[0];
      dispatch14.call("change", this, (tags) => {
        const otherValue = tags[otherKey] || tags[commonKey];
        if (newValue === otherValue) {
          tags[commonKey] = newValue;
          delete tags[key];
          delete tags[otherKey];
        } else {
          tags[key] = newValue;
          delete tags[commonKey];
          tags[otherKey] = otherValue;
        }
        return tags;
      });
    }
    directionalCombo.tags = function(tags) {
      _tags = tags;
      const commonKey = field.key;
      for (let key in _combos) {
        const uniqueValues = [...new Set([].concat(_tags[commonKey]).concat(_tags[key]).filter(Boolean))];
        _combos[key].tags({ [key]: uniqueValues.length > 1 ? uniqueValues : uniqueValues[0] });
      }
    };
    directionalCombo.focus = function() {
      var node = wrap2.selectAll("input").node();
      if (node)
        node.focus();
    };
    return utilRebind(directionalCombo, dispatch14, "on");
  }

  // modules/ui/fields/lanes.js
  function uiFieldLanes(field, context) {
    var dispatch14 = dispatch_default("change");
    var LANE_WIDTH = 40;
    var LANE_HEIGHT = 200;
    var _entityIDs = [];
    function lanes(selection2) {
      var lanesData = context.entity(_entityIDs[0]).lanes();
      if (!context.container().select(".inspector-wrap.inspector-hidden").empty() || !selection2.node().parentNode) {
        selection2.call(lanes.off);
        return;
      }
      var wrap2 = selection2.selectAll(".form-field-input-wrap").data([0]);
      wrap2 = wrap2.enter().append("div").attr("class", "form-field-input-wrap form-field-input-" + field.type).merge(wrap2);
      var surface = wrap2.selectAll(".surface").data([0]);
      var d2 = utilGetDimensions(wrap2);
      var freeSpace = d2[0] - lanesData.lanes.length * LANE_WIDTH * 1.5 + LANE_WIDTH * 0.5;
      surface = surface.enter().append("svg").attr("width", d2[0]).attr("height", 300).attr("class", "surface").merge(surface);
      var lanesSelection = surface.selectAll(".lanes").data([0]);
      lanesSelection = lanesSelection.enter().append("g").attr("class", "lanes").merge(lanesSelection);
      lanesSelection.attr("transform", function() {
        return "translate(" + freeSpace / 2 + ", 0)";
      });
      var lane = lanesSelection.selectAll(".lane").data(lanesData.lanes);
      lane.exit().remove();
      var enter = lane.enter().append("g").attr("class", "lane");
      enter.append("g").append("rect").attr("y", 50).attr("width", LANE_WIDTH).attr("height", LANE_HEIGHT);
      enter.append("g").attr("class", "forward").append("text").attr("y", 40).attr("x", 14).text("\u25B2");
      enter.append("g").attr("class", "bothways").append("text").attr("y", 40).attr("x", 14).text("\u25B2\u25BC");
      enter.append("g").attr("class", "backward").append("text").attr("y", 40).attr("x", 14).text("\u25BC");
      lane = lane.merge(enter);
      lane.attr("transform", function(d4) {
        return "translate(" + LANE_WIDTH * d4.index * 1.5 + ", 0)";
      });
      lane.select(".forward").style("visibility", function(d4) {
        return d4.direction === "forward" ? "visible" : "hidden";
      });
      lane.select(".bothways").style("visibility", function(d4) {
        return d4.direction === "bothways" ? "visible" : "hidden";
      });
      lane.select(".backward").style("visibility", function(d4) {
        return d4.direction === "backward" ? "visible" : "hidden";
      });
    }
    lanes.entityIDs = function(val) {
      _entityIDs = val;
    };
    lanes.tags = function() {
    };
    lanes.focus = function() {
    };
    lanes.off = function() {
    };
    return utilRebind(lanes, dispatch14, "on");
  }
  uiFieldLanes.supportsMultiselection = false;

  // modules/ui/fields/localized.js
  var _languagesArray = [];
  function uiFieldLocalized(field, context) {
    var dispatch14 = dispatch_default("change", "input");
    var wikipedia = services.wikipedia;
    var input = select_default2(null);
    var localizedInputs = select_default2(null);
    var _lengthIndicator = uiLengthIndicator(context.maxCharsForTagValue());
    var _countryCode;
    var _tags;
    _mainFileFetcher.get("languages").then(loadLanguagesArray).catch(function() {
    });
    var _territoryLanguages = {};
    _mainFileFetcher.get("territory_languages").then(function(d2) {
      _territoryLanguages = d2;
    }).catch(function() {
    });
    var langCombo = uiCombobox(context, "localized-lang").fetcher(fetchLanguages).minItems(0);
    var _selection = select_default2(null);
    var _multilingual = [];
    var _buttonTip = uiTooltip().title(() => _t.append("translate.translate")).placement("left");
    var _wikiTitles;
    var _entityIDs = [];
    function loadLanguagesArray(dataLanguages) {
      if (_languagesArray.length !== 0)
        return;
      var replacements = {
        sr: "sr-Cyrl",
        // in OSM, `sr` implies Cyrillic
        "sr-Cyrl": false
        // `sr-Cyrl` isn't used in OSM
      };
      for (var code in dataLanguages) {
        if (replacements[code] === false)
          continue;
        var metaCode = code;
        if (replacements[code])
          metaCode = replacements[code];
        _languagesArray.push({
          localName: _mainLocalizer.languageName(metaCode, { localOnly: true }),
          nativeName: dataLanguages[metaCode].nativeName,
          code,
          label: _mainLocalizer.languageName(metaCode)
        });
      }
    }
    function calcLocked() {
      var isLocked = field.id === "name" && _entityIDs.length && _entityIDs.some(function(entityID) {
        var entity = context.graph().hasEntity(entityID);
        if (!entity)
          return false;
        if (entity.tags.wikidata)
          return true;
        if (entity.tags["name:etymology:wikidata"])
          return true;
        var preset = _mainPresetIndex.match(entity, context.graph());
        if (preset) {
          var isSuggestion = preset.suggestion;
          var fields = preset.fields(entity.extent(context.graph()).center());
          var showsBrandField = fields.some(function(d2) {
            return d2.id === "brand";
          });
          var showsOperatorField = fields.some(function(d2) {
            return d2.id === "operator";
          });
          var setsName = preset.addTags.name;
          var setsBrandWikidata = preset.addTags["brand:wikidata"];
          var setsOperatorWikidata = preset.addTags["operator:wikidata"];
          return isSuggestion && setsName && (setsBrandWikidata && !showsBrandField || setsOperatorWikidata && !showsOperatorField);
        }
        return false;
      });
      field.locked(isLocked);
    }
    function calcMultilingual(tags) {
      var existingLangsOrdered = _multilingual.map(function(item2) {
        return item2.lang;
      });
      var existingLangs = new Set(existingLangsOrdered.filter(Boolean));
      for (var k2 in tags) {
        var m2 = k2.match(/^(.*):([a-z]{2,3}(?:-[A-Z][a-z]{3})?(?:-[A-Z]{2})?)$/);
        if (m2 && m2[1] === field.key && m2[2]) {
          var item = { lang: m2[2], value: tags[k2] };
          if (existingLangs.has(item.lang)) {
            _multilingual[existingLangsOrdered.indexOf(item.lang)].value = item.value;
            existingLangs.delete(item.lang);
          } else {
            _multilingual.push(item);
          }
        }
      }
      _multilingual.forEach(function(item2) {
        if (item2.lang && existingLangs.has(item2.lang)) {
          item2.value = "";
        }
      });
    }
    function localized(selection2) {
      _selection = selection2;
      calcLocked();
      var isLocked = field.locked();
      var wrap2 = selection2.selectAll(".form-field-input-wrap").data([0]);
      wrap2 = wrap2.enter().append("div").attr("class", "form-field-input-wrap form-field-input-" + field.type).merge(wrap2);
      input = wrap2.selectAll(".localized-main").data([0]);
      input = input.enter().append("input").attr("type", "text").attr("id", field.domId).attr("class", "localized-main").call(utilNoAuto).merge(input);
      input.classed("disabled", !!isLocked).attr("readonly", isLocked || null).on("input", change(true)).on("blur", change()).on("change", change());
      wrap2.call(_lengthIndicator);
      var translateButton = wrap2.selectAll(".localized-add").data([0]);
      translateButton = translateButton.enter().append("button").attr("class", "localized-add form-field-button").attr("aria-label", _t("icons.plus")).call(svgIcon("#iD-icon-plus")).merge(translateButton);
      translateButton.classed("disabled", !!isLocked).call(isLocked ? _buttonTip.destroy : _buttonTip).on("click", addNew);
      if (_tags && !_multilingual.length) {
        calcMultilingual(_tags);
      }
      localizedInputs = selection2.selectAll(".localized-multilingual").data([0]);
      localizedInputs = localizedInputs.enter().append("div").attr("class", "localized-multilingual").merge(localizedInputs);
      localizedInputs.call(renderMultilingual);
      localizedInputs.selectAll("button, input").classed("disabled", !!isLocked).attr("readonly", isLocked || null);
      selection2.selectAll(".combobox-caret").classed("nope", true);
      function addNew(d3_event) {
        d3_event.preventDefault();
        if (field.locked())
          return;
        var defaultLang = _mainLocalizer.languageCode().toLowerCase();
        var langExists = _multilingual.find(function(datum2) {
          return datum2.lang === defaultLang;
        });
        var isLangEn = defaultLang.indexOf("en") > -1;
        if (isLangEn || langExists) {
          defaultLang = "";
          langExists = _multilingual.find(function(datum2) {
            return datum2.lang === defaultLang;
          });
        }
        if (!langExists) {
          _multilingual.unshift({ lang: defaultLang, value: "" });
          localizedInputs.call(renderMultilingual);
        }
      }
      function change(onInput) {
        return function(d3_event) {
          if (field.locked()) {
            d3_event.preventDefault();
            return;
          }
          var val = utilGetSetValue(select_default2(this));
          if (!onInput)
            val = context.cleanTagValue(val);
          if (!val && Array.isArray(_tags[field.key]))
            return;
          var t2 = {};
          t2[field.key] = val || void 0;
          dispatch14.call("change", this, t2, onInput);
        };
      }
    }
    function key(lang) {
      return field.key + ":" + lang;
    }
    function changeLang(d3_event, d2) {
      var tags = {};
      var lang = utilGetSetValue(select_default2(this)).toLowerCase();
      var language = _languagesArray.find(function(d4) {
        return d4.label.toLowerCase() === lang || d4.localName && d4.localName.toLowerCase() === lang || d4.nativeName && d4.nativeName.toLowerCase() === lang;
      });
      if (language)
        lang = language.code;
      if (d2.lang && d2.lang !== lang) {
        tags[key(d2.lang)] = void 0;
      }
      var newKey = lang && context.cleanTagKey(key(lang));
      var value = utilGetSetValue(select_default2(this.parentNode).selectAll(".localized-value"));
      if (newKey && value) {
        tags[newKey] = value;
      } else if (newKey && _wikiTitles && _wikiTitles[d2.lang]) {
        tags[newKey] = _wikiTitles[d2.lang];
      }
      d2.lang = lang;
      dispatch14.call("change", this, tags);
    }
    function changeValue(d3_event, d2) {
      if (!d2.lang)
        return;
      var value = context.cleanTagValue(utilGetSetValue(select_default2(this))) || void 0;
      if (!value && Array.isArray(d2.value))
        return;
      var t2 = {};
      t2[key(d2.lang)] = value;
      d2.value = value;
      dispatch14.call("change", this, t2);
    }
    function fetchLanguages(value, cb) {
      var v2 = value.toLowerCase();
      var langCodes = [_mainLocalizer.localeCode(), _mainLocalizer.languageCode()];
      if (_countryCode && _territoryLanguages[_countryCode]) {
        langCodes = langCodes.concat(_territoryLanguages[_countryCode]);
      }
      var langItems = [];
      langCodes.forEach(function(code) {
        var langItem = _languagesArray.find(function(item) {
          return item.code === code;
        });
        if (langItem)
          langItems.push(langItem);
      });
      langItems = utilArrayUniq(langItems.concat(_languagesArray));
      cb(langItems.filter(function(d2) {
        return d2.label.toLowerCase().indexOf(v2) >= 0 || d2.localName && d2.localName.toLowerCase().indexOf(v2) >= 0 || d2.nativeName && d2.nativeName.toLowerCase().indexOf(v2) >= 0 || d2.code.toLowerCase().indexOf(v2) >= 0;
      }).map(function(d2) {
        return { value: d2.label };
      }));
    }
    function renderMultilingual(selection2) {
      var entries = selection2.selectAll("div.entry").data(_multilingual, function(d2) {
        return d2.lang;
      });
      entries.exit().style("top", "0").style("max-height", "240px").transition().duration(200).style("opacity", "0").style("max-height", "0px").remove();
      var entriesEnter = entries.enter().append("div").attr("class", "entry").each(function(_2, index) {
        var wrap2 = select_default2(this);
        var domId = utilUniqueDomId(index);
        var label = wrap2.append("label").attr("class", "field-label").attr("for", domId);
        var text = label.append("span").attr("class", "label-text");
        text.append("span").attr("class", "label-textvalue").call(_t.append("translate.localized_translation_label"));
        text.append("span").attr("class", "label-textannotation");
        label.append("button").attr("class", "remove-icon-multilingual").attr("title", _t("icons.remove")).on("click", function(d3_event, d2) {
          if (field.locked())
            return;
          d3_event.preventDefault();
          _multilingual.splice(_multilingual.indexOf(d2), 1);
          var langKey = d2.lang && key(d2.lang);
          if (langKey && langKey in _tags) {
            delete _tags[langKey];
            var t2 = {};
            t2[langKey] = void 0;
            dispatch14.call("change", this, t2);
            return;
          }
          renderMultilingual(selection2);
        }).call(svgIcon("#iD-operation-delete"));
        wrap2.append("input").attr("class", "localized-lang").attr("id", domId).attr("type", "text").attr("placeholder", _t("translate.localized_translation_language")).on("blur", changeLang).on("change", changeLang).call(langCombo);
        wrap2.append("input").attr("type", "text").attr("class", "localized-value").on("blur", changeValue).on("change", changeValue);
      });
      entriesEnter.style("margin-top", "0px").style("max-height", "0px").style("opacity", "0").transition().duration(200).style("margin-top", "10px").style("max-height", "240px").style("opacity", "1").on("end", function() {
        select_default2(this).style("max-height", "").style("overflow", "visible");
      });
      entries = entries.merge(entriesEnter);
      entries.order();
      entries.classed("present", true);
      utilGetSetValue(entries.select(".localized-lang"), function(d2) {
        var langItem = _languagesArray.find(function(item) {
          return item.code === d2.lang;
        });
        if (langItem)
          return langItem.label;
        return d2.lang;
      });
      utilGetSetValue(entries.select(".localized-value"), function(d2) {
        return typeof d2.value === "string" ? d2.value : "";
      }).attr("title", function(d2) {
        return Array.isArray(d2.value) ? d2.value.filter(Boolean).join("\n") : null;
      }).attr("placeholder", function(d2) {
        return Array.isArray(d2.value) ? _t("inspector.multiple_values") : _t("translate.localized_translation_name");
      }).classed("mixed", function(d2) {
        return Array.isArray(d2.value);
      });
    }
    localized.tags = function(tags) {
      _tags = tags;
      if (typeof tags.wikipedia === "string" && !_wikiTitles) {
        _wikiTitles = {};
        var wm = tags.wikipedia.match(/([^:]+):(.+)/);
        if (wm && wm[0] && wm[1]) {
          wikipedia.translations(wm[1], wm[2], function(err, d2) {
            if (err || !d2)
              return;
            _wikiTitles = d2;
          });
        }
      }
      var isMixed = Array.isArray(tags[field.key]);
      utilGetSetValue(input, typeof tags[field.key] === "string" ? tags[field.key] : "").attr("title", isMixed ? tags[field.key].filter(Boolean).join("\n") : void 0).attr("placeholder", isMixed ? _t("inspector.multiple_values") : field.placeholder()).classed("mixed", isMixed);
      calcMultilingual(tags);
      _selection.call(localized);
      if (!isMixed) {
        _lengthIndicator.update(tags[field.key]);
      }
    };
    localized.focus = function() {
      input.node().focus();
    };
    localized.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      _entityIDs = val;
      _multilingual = [];
      loadCountryCode();
      return localized;
    };
    function loadCountryCode() {
      var extent = combinedEntityExtent();
      var countryCode = extent && iso1A2Code(extent.center());
      _countryCode = countryCode && countryCode.toLowerCase();
    }
    function combinedEntityExtent() {
      return _entityIDs && _entityIDs.length && utilTotalExtent(_entityIDs, context.graph());
    }
    return utilRebind(localized, dispatch14, "on");
  }

  // modules/ui/fields/roadheight.js
  function uiFieldRoadheight(field, context) {
    var dispatch14 = dispatch_default("change");
    var primaryUnitInput = select_default2(null);
    var primaryInput = select_default2(null);
    var secondaryInput = select_default2(null);
    var secondaryUnitInput = select_default2(null);
    var _entityIDs = [];
    var _tags;
    var _isImperial;
    var formatFloat = _mainLocalizer.floatFormatter(_mainLocalizer.languageCode());
    var parseLocaleFloat = _mainLocalizer.floatParser(_mainLocalizer.languageCode());
    var primaryUnits = [
      {
        value: "m",
        title: _t("inspector.roadheight.meter")
      },
      {
        value: "ft",
        title: _t("inspector.roadheight.foot")
      }
    ];
    var unitCombo = uiCombobox(context, "roadheight-unit").data(primaryUnits);
    function roadheight(selection2) {
      var wrap2 = selection2.selectAll(".form-field-input-wrap").data([0]);
      wrap2 = wrap2.enter().append("div").attr("class", "form-field-input-wrap form-field-input-" + field.type).merge(wrap2);
      primaryInput = wrap2.selectAll("input.roadheight-number").data([0]);
      primaryInput = primaryInput.enter().append("input").attr("type", "text").attr("class", "roadheight-number").attr("id", field.domId).call(utilNoAuto).merge(primaryInput);
      primaryInput.on("change", change).on("blur", change);
      var loc = combinedEntityExtent().center();
      _isImperial = roadHeightUnit(loc) === "ft";
      primaryUnitInput = wrap2.selectAll("input.roadheight-unit").data([0]);
      primaryUnitInput = primaryUnitInput.enter().append("input").attr("type", "text").attr("class", "roadheight-unit").call(unitCombo).merge(primaryUnitInput);
      primaryUnitInput.on("blur", changeUnits).on("change", changeUnits);
      secondaryInput = wrap2.selectAll("input.roadheight-secondary-number").data([0]);
      secondaryInput = secondaryInput.enter().append("input").attr("type", "text").attr("class", "roadheight-secondary-number").call(utilNoAuto).merge(secondaryInput);
      secondaryInput.on("change", change).on("blur", change);
      secondaryUnitInput = wrap2.selectAll("input.roadheight-secondary-unit").data([0]);
      secondaryUnitInput = secondaryUnitInput.enter().append("input").attr("type", "text").call(utilNoAuto).classed("disabled", true).classed("roadheight-secondary-unit", true).attr("readonly", "readonly").merge(secondaryUnitInput);
      function changeUnits() {
        var primaryUnit = utilGetSetValue(primaryUnitInput);
        if (primaryUnit === "m") {
          _isImperial = false;
        } else if (primaryUnit === "ft") {
          _isImperial = true;
        }
        utilGetSetValue(primaryUnitInput, _isImperial ? "ft" : "m");
        setUnitSuggestions();
        change();
      }
    }
    function setUnitSuggestions() {
      utilGetSetValue(primaryUnitInput, _isImperial ? "ft" : "m");
    }
    function change() {
      var tag2 = {};
      var primaryValue = utilGetSetValue(primaryInput).trim();
      var secondaryValue = utilGetSetValue(secondaryInput).trim();
      if (!primaryValue && !secondaryValue && Array.isArray(_tags[field.key]))
        return;
      if (!primaryValue && !secondaryValue) {
        tag2[field.key] = void 0;
      } else {
        var rawPrimaryValue = likelyRawNumberFormat.test(primaryValue) ? parseFloat(primaryValue) : parseLocaleFloat(primaryValue);
        if (isNaN(rawPrimaryValue))
          rawPrimaryValue = primaryValue;
        var rawSecondaryValue = likelyRawNumberFormat.test(secondaryValue) ? parseFloat(secondaryValue) : parseLocaleFloat(secondaryValue);
        if (isNaN(rawSecondaryValue))
          rawSecondaryValue = secondaryValue;
        if (isNaN(rawPrimaryValue) || isNaN(rawSecondaryValue) || !_isImperial) {
          tag2[field.key] = context.cleanTagValue(rawPrimaryValue);
        } else {
          if (rawPrimaryValue !== "") {
            rawPrimaryValue = rawPrimaryValue + "'";
          }
          if (rawSecondaryValue !== "") {
            rawSecondaryValue = rawSecondaryValue + '"';
          }
          tag2[field.key] = context.cleanTagValue(rawPrimaryValue + rawSecondaryValue);
        }
      }
      dispatch14.call("change", this, tag2);
    }
    roadheight.tags = function(tags) {
      _tags = tags;
      var primaryValue = tags[field.key];
      var secondaryValue;
      var isMixed = Array.isArray(primaryValue);
      if (!isMixed) {
        if (primaryValue && (primaryValue.indexOf("'") >= 0 || primaryValue.indexOf('"') >= 0)) {
          secondaryValue = primaryValue.match(/(-?[\d.]+)"/);
          if (secondaryValue !== null) {
            secondaryValue = formatFloat(parseFloat(secondaryValue[1]));
          }
          primaryValue = primaryValue.match(/(-?[\d.]+)'/);
          if (primaryValue !== null) {
            primaryValue = formatFloat(parseFloat(primaryValue[1]));
          }
          _isImperial = true;
        } else if (primaryValue) {
          var rawValue = primaryValue;
          primaryValue = parseFloat(rawValue);
          if (isNaN(primaryValue)) {
            primaryValue = rawValue;
          } else {
            primaryValue = formatFloat(primaryValue);
          }
          _isImperial = false;
        }
      }
      setUnitSuggestions();
      var inchesPlaceholder = formatFloat(0);
      utilGetSetValue(primaryInput, typeof primaryValue === "string" ? primaryValue : "").attr("title", isMixed ? primaryValue.filter(Boolean).join("\n") : null).attr("placeholder", isMixed ? _t("inspector.multiple_values") : _t("inspector.unknown")).classed("mixed", isMixed);
      utilGetSetValue(secondaryInput, typeof secondaryValue === "string" ? secondaryValue : "").attr("placeholder", isMixed ? _t("inspector.multiple_values") : _isImperial ? inchesPlaceholder : null).classed("mixed", isMixed).classed("disabled", !_isImperial).attr("readonly", _isImperial ? null : "readonly");
      secondaryUnitInput.attr("value", _isImperial ? _t("inspector.roadheight.inch") : null);
    };
    roadheight.focus = function() {
      primaryInput.node().focus();
    };
    roadheight.entityIDs = function(val) {
      _entityIDs = val;
    };
    function combinedEntityExtent() {
      return _entityIDs && _entityIDs.length && utilTotalExtent(_entityIDs, context.graph());
    }
    return utilRebind(roadheight, dispatch14, "on");
  }

  // modules/ui/fields/roadspeed.js
  function uiFieldRoadspeed(field, context) {
    var dispatch14 = dispatch_default("change");
    var unitInput = select_default2(null);
    var input = select_default2(null);
    var _entityIDs = [];
    var _tags;
    var _isImperial;
    var formatFloat = _mainLocalizer.floatFormatter(_mainLocalizer.languageCode());
    var parseLocaleFloat = _mainLocalizer.floatParser(_mainLocalizer.languageCode());
    var speedCombo = uiCombobox(context, "roadspeed");
    var unitCombo = uiCombobox(context, "roadspeed-unit").data(["km/h", "mph"].map(comboValues));
    var metricValues = [20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120];
    var imperialValues = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80];
    function roadspeed(selection2) {
      var wrap2 = selection2.selectAll(".form-field-input-wrap").data([0]);
      wrap2 = wrap2.enter().append("div").attr("class", "form-field-input-wrap form-field-input-" + field.type).merge(wrap2);
      input = wrap2.selectAll("input.roadspeed-number").data([0]);
      input = input.enter().append("input").attr("type", "text").attr("class", "roadspeed-number").attr("id", field.domId).call(utilNoAuto).call(speedCombo).merge(input);
      input.on("change", change).on("blur", change);
      var loc = combinedEntityExtent().center();
      _isImperial = roadSpeedUnit(loc) === "mph";
      unitInput = wrap2.selectAll("input.roadspeed-unit").data([0]);
      unitInput = unitInput.enter().append("input").attr("type", "text").attr("class", "roadspeed-unit").attr("aria-label", _t("inspector.speed_unit")).call(unitCombo).merge(unitInput);
      unitInput.on("blur", changeUnits).on("change", changeUnits);
      function changeUnits() {
        var unit2 = utilGetSetValue(unitInput);
        if (unit2 === "km/h") {
          _isImperial = false;
        } else if (unit2 === "mph") {
          _isImperial = true;
        }
        utilGetSetValue(unitInput, _isImperial ? "mph" : "km/h");
        setUnitSuggestions();
        change();
      }
    }
    function setUnitSuggestions() {
      speedCombo.data((_isImperial ? imperialValues : metricValues).map(comboValues));
      utilGetSetValue(unitInput, _isImperial ? "mph" : "km/h");
    }
    function comboValues(d2) {
      return {
        value: formatFloat(d2),
        title: formatFloat(d2)
      };
    }
    function change() {
      var tag2 = {};
      var value = utilGetSetValue(input).trim();
      if (!value && Array.isArray(_tags[field.key]))
        return;
      if (!value) {
        tag2[field.key] = void 0;
      } else {
        var rawValue = likelyRawNumberFormat.test(value) ? parseFloat(value) : parseLocaleFloat(value);
        if (isNaN(rawValue))
          rawValue = value;
        if (isNaN(rawValue) || !_isImperial) {
          tag2[field.key] = context.cleanTagValue(rawValue);
        } else {
          tag2[field.key] = context.cleanTagValue(rawValue + " mph");
        }
      }
      dispatch14.call("change", this, tag2);
    }
    roadspeed.tags = function(tags) {
      _tags = tags;
      var rawValue = tags[field.key];
      var value = rawValue;
      var isMixed = Array.isArray(value);
      if (!isMixed) {
        if (rawValue && rawValue.indexOf("mph") >= 0) {
          _isImperial = true;
        } else if (rawValue) {
          _isImperial = false;
        }
        value = parseInt(value, 10);
        if (isNaN(value)) {
          value = rawValue;
        } else {
          value = formatFloat(value);
        }
      }
      setUnitSuggestions();
      utilGetSetValue(input, typeof value === "string" ? value : "").attr("title", isMixed ? value.filter(Boolean).join("\n") : null).attr("placeholder", isMixed ? _t("inspector.multiple_values") : field.placeholder()).classed("mixed", isMixed);
    };
    roadspeed.focus = function() {
      input.node().focus();
    };
    roadspeed.entityIDs = function(val) {
      _entityIDs = val;
    };
    function combinedEntityExtent() {
      return _entityIDs && _entityIDs.length && utilTotalExtent(_entityIDs, context.graph());
    }
    return utilRebind(roadspeed, dispatch14, "on");
  }

  // modules/ui/fields/radio.js
  function uiFieldRadio(field, context) {
    var dispatch14 = dispatch_default("change");
    var placeholder = select_default2(null);
    var wrap2 = select_default2(null);
    var labels = select_default2(null);
    var radios = select_default2(null);
    var radioData = (field.options || field.keys).slice();
    var typeField;
    var layerField;
    var _oldType = {};
    var _entityIDs = [];
    function selectedKey() {
      var node = wrap2.selectAll(".form-field-input-radio label.active input");
      return !node.empty() && node.datum();
    }
    function radio(selection2) {
      selection2.classed("preset-radio", true);
      wrap2 = selection2.selectAll(".form-field-input-wrap").data([0]);
      var enter = wrap2.enter().append("div").attr("class", "form-field-input-wrap form-field-input-radio");
      enter.append("span").attr("class", "placeholder");
      wrap2 = wrap2.merge(enter);
      placeholder = wrap2.selectAll(".placeholder");
      labels = wrap2.selectAll("label").data(radioData);
      enter = labels.enter().append("label");
      var stringsField = field.resolveReference("stringsCrossReference");
      enter.append("input").attr("type", "radio").attr("name", field.id).attr("value", function(d2) {
        return stringsField.t("options." + d2, { "default": d2 });
      }).attr("checked", false);
      enter.append("span").each(function(d2) {
        stringsField.t.append("options." + d2, { "default": d2 })(select_default2(this));
      });
      labels = labels.merge(enter);
      radios = labels.selectAll("input").on("change", changeRadio);
    }
    function structureExtras(selection2, tags) {
      var selected = selectedKey() || tags.layer !== void 0;
      var type2 = _mainPresetIndex.field(selected);
      var layer = _mainPresetIndex.field("layer");
      var showLayer = selected === "bridge" || selected === "tunnel" || tags.layer !== void 0;
      var extrasWrap = selection2.selectAll(".structure-extras-wrap").data(selected ? [0] : []);
      extrasWrap.exit().remove();
      extrasWrap = extrasWrap.enter().append("div").attr("class", "structure-extras-wrap").merge(extrasWrap);
      var list2 = extrasWrap.selectAll("ul").data([0]);
      list2 = list2.enter().append("ul").attr("class", "rows").merge(list2);
      if (type2) {
        if (!typeField || typeField.id !== selected) {
          typeField = uiField(context, type2, _entityIDs, { wrap: false }).on("change", changeType);
        }
        typeField.tags(tags);
      } else {
        typeField = null;
      }
      var typeItem = list2.selectAll(".structure-type-item").data(typeField ? [typeField] : [], function(d2) {
        return d2.id;
      });
      typeItem.exit().remove();
      var typeEnter = typeItem.enter().insert("li", ":first-child").attr("class", "labeled-input structure-type-item");
      typeEnter.append("div").attr("class", "label structure-label-type").attr("for", "preset-input-" + selected).call(_t.append("inspector.radio.structure.type"));
      typeEnter.append("div").attr("class", "structure-input-type-wrap");
      typeItem = typeItem.merge(typeEnter);
      if (typeField) {
        typeItem.selectAll(".structure-input-type-wrap").call(typeField.render);
      }
      if (layer && showLayer) {
        if (!layerField) {
          layerField = uiField(context, layer, _entityIDs, { wrap: false }).on("change", changeLayer);
        }
        layerField.tags(tags);
        field.keys = utilArrayUnion(field.keys, ["layer"]);
      } else {
        layerField = null;
        field.keys = field.keys.filter(function(k2) {
          return k2 !== "layer";
        });
      }
      var layerItem = list2.selectAll(".structure-layer-item").data(layerField ? [layerField] : []);
      layerItem.exit().remove();
      var layerEnter = layerItem.enter().append("li").attr("class", "labeled-input structure-layer-item");
      layerEnter.append("div").attr("class", "label structure-label-layer").attr("for", "preset-input-layer").call(_t.append("inspector.radio.structure.layer"));
      layerEnter.append("div").attr("class", "structure-input-layer-wrap");
      layerItem = layerItem.merge(layerEnter);
      if (layerField) {
        layerItem.selectAll(".structure-input-layer-wrap").call(layerField.render);
      }
    }
    function changeType(t2, onInput) {
      var key = selectedKey();
      if (!key)
        return;
      var val = t2[key];
      if (val !== "no") {
        _oldType[key] = val;
      }
      if (field.type === "structureRadio") {
        if (val === "no" || key !== "bridge" && key !== "tunnel" || key === "tunnel" && val === "building_passage") {
          t2.layer = void 0;
        }
        if (t2.layer === void 0) {
          if (key === "bridge" && val !== "no") {
            t2.layer = "1";
          }
          if (key === "tunnel" && val !== "no" && val !== "building_passage") {
            t2.layer = "-1";
          }
        }
      }
      dispatch14.call("change", this, t2, onInput);
    }
    function changeLayer(t2, onInput) {
      if (t2.layer === "0") {
        t2.layer = void 0;
      }
      dispatch14.call("change", this, t2, onInput);
    }
    function changeRadio() {
      var t2 = {};
      var activeKey;
      if (field.key) {
        t2[field.key] = void 0;
      }
      radios.each(function(d2) {
        var active = select_default2(this).property("checked");
        if (active)
          activeKey = d2;
        if (field.key) {
          if (active)
            t2[field.key] = d2;
        } else {
          var val = _oldType[activeKey] || "yes";
          t2[d2] = active ? val : void 0;
        }
      });
      if (field.type === "structureRadio") {
        if (activeKey === "bridge") {
          t2.layer = "1";
        } else if (activeKey === "tunnel" && t2.tunnel !== "building_passage") {
          t2.layer = "-1";
        } else {
          t2.layer = void 0;
        }
      }
      dispatch14.call("change", this, t2);
    }
    radio.tags = function(tags) {
      function isOptionChecked(d2) {
        if (field.key) {
          return tags[field.key] === d2;
        }
        return !!(typeof tags[d2] === "string" && tags[d2].toLowerCase() !== "no");
      }
      function isMixed(d2) {
        if (field.key) {
          return Array.isArray(tags[field.key]) && tags[field.key].includes(d2);
        }
        return Array.isArray(tags[d2]);
      }
      radios.property("checked", function(d2) {
        return isOptionChecked(d2) && (field.key || field.options.filter(isOptionChecked).length === 1);
      });
      labels.classed("active", function(d2) {
        if (field.key) {
          return Array.isArray(tags[field.key]) && tags[field.key].includes(d2) || tags[field.key] === d2;
        }
        return Array.isArray(tags[d2]) && tags[d2].some((v2) => typeof v2 === "string" && v2.toLowerCase() !== "no") || !!(typeof tags[d2] === "string" && tags[d2].toLowerCase() !== "no");
      }).classed("mixed", isMixed).attr("title", function(d2) {
        return isMixed(d2) ? _t("inspector.unshared_value_tooltip") : null;
      });
      var selection2 = radios.filter(function() {
        return this.checked;
      });
      if (selection2.empty()) {
        placeholder.text("");
        placeholder.call(_t.append("inspector.none"));
      } else {
        placeholder.text(selection2.attr("value"));
        _oldType[selection2.datum()] = tags[selection2.datum()];
      }
      if (field.type === "structureRadio") {
        if (!!tags.waterway && !_oldType.tunnel) {
          _oldType.tunnel = "culvert";
        }
        wrap2.call(structureExtras, tags);
      }
    };
    radio.focus = function() {
      radios.node().focus();
    };
    radio.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      _entityIDs = val;
      _oldType = {};
      return radio;
    };
    radio.isAllowed = function() {
      return _entityIDs.length === 1;
    };
    return utilRebind(radio, dispatch14, "on");
  }

  // modules/ui/fields/restrictions.js
  function uiFieldRestrictions(field, context) {
    var dispatch14 = dispatch_default("change");
    var breathe = behaviorBreathe(context);
    corePreferences("turn-restriction-via-way", null);
    var storedViaWay = corePreferences("turn-restriction-via-way0");
    var storedDistance = corePreferences("turn-restriction-distance");
    var _maxViaWay = storedViaWay !== null ? +storedViaWay : 0;
    var _maxDistance = storedDistance ? +storedDistance : 30;
    var _initialized3 = false;
    var _parent = select_default2(null);
    var _container = select_default2(null);
    var _oldTurns;
    var _graph;
    var _vertexID;
    var _intersection;
    var _fromWayID;
    var _lastXPos;
    function restrictions(selection2) {
      _parent = selection2;
      if (_vertexID && (context.graph() !== _graph || !_intersection)) {
        _graph = context.graph();
        _intersection = osmIntersection(_graph, _vertexID, _maxDistance);
      }
      var isOK = _intersection && _intersection.vertices.length && // has vertices
      _intersection.vertices.filter(function(vertex) {
        return vertex.id === _vertexID;
      }).length && _intersection.ways.length > 2;
      select_default2(selection2.node().parentNode).classed("hide", !isOK);
      if (!isOK || !context.container().select(".inspector-wrap.inspector-hidden").empty() || !selection2.node().parentNode || !selection2.node().parentNode.parentNode) {
        selection2.call(restrictions.off);
        return;
      }
      var wrap2 = selection2.selectAll(".form-field-input-wrap").data([0]);
      wrap2 = wrap2.enter().append("div").attr("class", "form-field-input-wrap form-field-input-" + field.type).merge(wrap2);
      var container = wrap2.selectAll(".restriction-container").data([0]);
      var containerEnter = container.enter().append("div").attr("class", "restriction-container");
      containerEnter.append("div").attr("class", "restriction-help");
      _container = containerEnter.merge(container).call(renderViewer);
      var controls = wrap2.selectAll(".restriction-controls").data([0]);
      controls.enter().append("div").attr("class", "restriction-controls-container").append("div").attr("class", "restriction-controls").merge(controls).call(renderControls);
    }
    function renderControls(selection2) {
      var distControl = selection2.selectAll(".restriction-distance").data([0]);
      distControl.exit().remove();
      var distControlEnter = distControl.enter().append("div").attr("class", "restriction-control restriction-distance");
      distControlEnter.append("span").attr("class", "restriction-control-label restriction-distance-label").call(_t.append("restriction.controls.distance", { suffix: ":" }));
      distControlEnter.append("input").attr("class", "restriction-distance-input").attr("type", "range").attr("min", "20").attr("max", "50").attr("step", "5");
      distControlEnter.append("span").attr("class", "restriction-distance-text");
      selection2.selectAll(".restriction-distance-input").property("value", _maxDistance).on("input", function() {
        var val = select_default2(this).property("value");
        _maxDistance = +val;
        _intersection = null;
        _container.selectAll(".layer-osm .layer-turns *").remove();
        corePreferences("turn-restriction-distance", _maxDistance);
        _parent.call(restrictions);
      });
      selection2.selectAll(".restriction-distance-text").call(displayMaxDistance(_maxDistance));
      var viaControl = selection2.selectAll(".restriction-via-way").data([0]);
      viaControl.exit().remove();
      var viaControlEnter = viaControl.enter().append("div").attr("class", "restriction-control restriction-via-way");
      viaControlEnter.append("span").attr("class", "restriction-control-label restriction-via-way-label").call(_t.append("restriction.controls.via", { suffix: ":" }));
      viaControlEnter.append("input").attr("class", "restriction-via-way-input").attr("type", "range").attr("min", "0").attr("max", "2").attr("step", "1");
      viaControlEnter.append("span").attr("class", "restriction-via-way-text");
      selection2.selectAll(".restriction-via-way-input").property("value", _maxViaWay).on("input", function() {
        var val = select_default2(this).property("value");
        _maxViaWay = +val;
        _container.selectAll(".layer-osm .layer-turns *").remove();
        corePreferences("turn-restriction-via-way0", _maxViaWay);
        _parent.call(restrictions);
      });
      selection2.selectAll(".restriction-via-way-text").call(displayMaxVia(_maxViaWay));
    }
    function renderViewer(selection2) {
      if (!_intersection)
        return;
      var vgraph = _intersection.graph;
      var filter2 = utilFunctor(true);
      var projection2 = geoRawMercator();
      var sdims = utilGetDimensions(context.container().select(".sidebar"));
      var d2 = [sdims[0] - 50, 370];
      var c2 = geoVecScale(d2, 0.5);
      var z2 = 22;
      projection2.scale(geoZoomToScale(z2));
      var extent = geoExtent();
      for (var i3 = 0; i3 < _intersection.vertices.length; i3++) {
        extent._extend(_intersection.vertices[i3].extent());
      }
      var padTop = 35;
      if (_intersection.vertices.length > 1) {
        var hPadding = Math.min(160, Math.max(110, d2[0] * 0.4));
        var vPadding = 160;
        var tl = projection2([extent[0][0], extent[1][1]]);
        var br2 = projection2([extent[1][0], extent[0][1]]);
        var hFactor = (br2[0] - tl[0]) / (d2[0] - hPadding);
        var vFactor = (br2[1] - tl[1]) / (d2[1] - vPadding - padTop);
        var hZoomDiff = Math.log(Math.abs(hFactor)) / Math.LN2;
        var vZoomDiff = Math.log(Math.abs(vFactor)) / Math.LN2;
        z2 = z2 - Math.max(hZoomDiff, vZoomDiff);
        projection2.scale(geoZoomToScale(z2));
      }
      var extentCenter = projection2(extent.center());
      extentCenter[1] = extentCenter[1] - padTop / 2;
      projection2.translate(geoVecSubtract(c2, extentCenter)).clipExtent([[0, 0], d2]);
      var drawLayers = svgLayers(projection2, context).only(["osm", "touch"]).dimensions(d2);
      var drawVertices = svgVertices(projection2, context);
      var drawLines = svgLines(projection2, context);
      var drawTurns = svgTurns(projection2, context);
      var firstTime = selection2.selectAll(".surface").empty();
      selection2.call(drawLayers);
      var surface = selection2.selectAll(".surface").classed("tr", true);
      if (firstTime) {
        _initialized3 = true;
        surface.call(breathe);
      }
      if (_fromWayID && !vgraph.hasEntity(_fromWayID)) {
        _fromWayID = null;
        _oldTurns = null;
      }
      surface.call(utilSetDimensions, d2).call(drawVertices, vgraph, _intersection.vertices, filter2, extent, z2).call(drawLines, vgraph, _intersection.ways, filter2).call(drawTurns, vgraph, _intersection.turns(_fromWayID, _maxViaWay));
      surface.on("click.restrictions", click).on("mouseover.restrictions", mouseover);
      surface.selectAll(".selected").classed("selected", false);
      surface.selectAll(".related").classed("related", false);
      var way;
      if (_fromWayID) {
        way = vgraph.entity(_fromWayID);
        surface.selectAll("." + _fromWayID).classed("selected", true).classed("related", true);
      }
      document.addEventListener("resizeWindow", function() {
        utilSetDimensions(_container, null);
        redraw(1);
      }, false);
      updateHints(null);
      function click(d3_event) {
        surface.call(breathe.off).call(breathe);
        var datum2 = d3_event.target.__data__;
        var entity = datum2 && datum2.properties && datum2.properties.entity;
        if (entity) {
          datum2 = entity;
        }
        if (datum2 instanceof osmWay && (datum2.__from || datum2.__via)) {
          _fromWayID = datum2.id;
          _oldTurns = null;
          redraw();
        } else if (datum2 instanceof osmTurn) {
          var actions, extraActions, turns, i4;
          var restrictionType = osmInferRestriction(vgraph, datum2, projection2);
          if (datum2.restrictionID && !datum2.direct) {
            return;
          } else if (datum2.restrictionID && !datum2.only) {
            var seen = {};
            var datumOnly = JSON.parse(JSON.stringify(datum2));
            datumOnly.only = true;
            restrictionType = restrictionType.replace(/^no/, "only");
            turns = _intersection.turns(_fromWayID, 2);
            extraActions = [];
            _oldTurns = [];
            for (i4 = 0; i4 < turns.length; i4++) {
              var turn = turns[i4];
              if (seen[turn.restrictionID])
                continue;
              if (turn.direct && turn.path[1] === datum2.path[1]) {
                seen[turns[i4].restrictionID] = true;
                turn.restrictionType = osmInferRestriction(vgraph, turn, projection2);
                _oldTurns.push(turn);
                extraActions.push(actionUnrestrictTurn(turn));
              }
            }
            actions = _intersection.actions.concat(extraActions, [
              actionRestrictTurn(datumOnly, restrictionType),
              _t("operations.restriction.annotation.create")
            ]);
          } else if (datum2.restrictionID) {
            turns = _oldTurns || [];
            extraActions = [];
            for (i4 = 0; i4 < turns.length; i4++) {
              if (turns[i4].key !== datum2.key) {
                extraActions.push(actionRestrictTurn(turns[i4], turns[i4].restrictionType));
              }
            }
            _oldTurns = null;
            actions = _intersection.actions.concat(extraActions, [
              actionUnrestrictTurn(datum2),
              _t("operations.restriction.annotation.delete")
            ]);
          } else {
            actions = _intersection.actions.concat([
              actionRestrictTurn(datum2, restrictionType),
              _t("operations.restriction.annotation.create")
            ]);
          }
          context.perform.apply(context, actions);
          var s2 = surface.selectAll("." + datum2.key);
          datum2 = s2.empty() ? null : s2.datum();
          updateHints(datum2);
        } else {
          _fromWayID = null;
          _oldTurns = null;
          redraw();
        }
      }
      function mouseover(d3_event) {
        var datum2 = d3_event.target.__data__;
        updateHints(datum2);
      }
      _lastXPos = _lastXPos || sdims[0];
      function redraw(minChange) {
        var xPos = -1;
        if (minChange) {
          xPos = utilGetDimensions(context.container().select(".sidebar"))[0];
        }
        if (!minChange || minChange && Math.abs(xPos - _lastXPos) >= minChange) {
          if (context.hasEntity(_vertexID)) {
            _lastXPos = xPos;
            _container.call(renderViewer);
          }
        }
      }
      function highlightPathsFrom(wayID) {
        surface.selectAll(".related").classed("related", false).classed("allow", false).classed("restrict", false).classed("only", false);
        surface.selectAll("." + wayID).classed("related", true);
        if (wayID) {
          var turns = _intersection.turns(wayID, _maxViaWay);
          for (var i4 = 0; i4 < turns.length; i4++) {
            var turn = turns[i4];
            var ids = [turn.to.way];
            var klass = turn.no ? "restrict" : turn.only ? "only" : "allow";
            if (turn.only || turns.length === 1) {
              if (turn.via.ways) {
                ids = ids.concat(turn.via.ways);
              }
            } else if (turn.to.way === wayID) {
              continue;
            }
            surface.selectAll(utilEntitySelector(ids)).classed("related", true).classed("allow", klass === "allow").classed("restrict", klass === "restrict").classed("only", klass === "only");
          }
        }
      }
      function updateHints(datum2) {
        var help = _container.selectAll(".restriction-help").html("");
        var placeholders = {};
        ["from", "via", "to"].forEach(function(k2) {
          placeholders[k2] = { html: '<span class="qualifier">' + _t("restriction.help." + k2) + "</span>" };
        });
        var entity = datum2 && datum2.properties && datum2.properties.entity;
        if (entity) {
          datum2 = entity;
        }
        if (_fromWayID) {
          way = vgraph.entity(_fromWayID);
          surface.selectAll("." + _fromWayID).classed("selected", true).classed("related", true);
        }
        if (datum2 instanceof osmWay && datum2.__from) {
          way = datum2;
          highlightPathsFrom(_fromWayID ? null : way.id);
          surface.selectAll("." + way.id).classed("related", true);
          var clickSelect = !_fromWayID || _fromWayID !== way.id;
          help.append("div").html(_t.html("restriction.help." + (clickSelect ? "select_from_name" : "from_name"), {
            from: placeholders.from,
            fromName: displayName(way.id, vgraph)
          }));
        } else if (datum2 instanceof osmTurn) {
          var restrictionType = osmInferRestriction(vgraph, datum2, projection2);
          var turnType = restrictionType.replace(/^(only|no)\_/, "");
          var indirect = datum2.direct === false ? _t.html("restriction.help.indirect") : "";
          var klass, turnText, nextText;
          if (datum2.no) {
            klass = "restrict";
            turnText = _t.html("restriction.help.turn.no_" + turnType, { indirect: { html: indirect } });
            nextText = _t.html("restriction.help.turn.only_" + turnType, { indirect: "" });
          } else if (datum2.only) {
            klass = "only";
            turnText = _t.html("restriction.help.turn.only_" + turnType, { indirect: { html: indirect } });
            nextText = _t.html("restriction.help.turn.allowed_" + turnType, { indirect: "" });
          } else {
            klass = "allow";
            turnText = _t.html("restriction.help.turn.allowed_" + turnType, { indirect: { html: indirect } });
            nextText = _t.html("restriction.help.turn.no_" + turnType, { indirect: "" });
          }
          help.append("div").attr("class", "qualifier " + klass).html(turnText);
          help.append("div").html(_t.html("restriction.help.from_name_to_name", {
            from: placeholders.from,
            fromName: displayName(datum2.from.way, vgraph),
            to: placeholders.to,
            toName: displayName(datum2.to.way, vgraph)
          }));
          if (datum2.via.ways && datum2.via.ways.length) {
            var names = [];
            for (var i4 = 0; i4 < datum2.via.ways.length; i4++) {
              var prev = names[names.length - 1];
              var curr = displayName(datum2.via.ways[i4], vgraph);
              if (!prev || curr !== prev) {
                names.push(curr);
              }
            }
            help.append("div").html(_t.html("restriction.help.via_names", {
              via: placeholders.via,
              viaNames: names.join(", ")
            }));
          }
          if (!indirect) {
            help.append("div").html(_t.html("restriction.help.toggle", { turn: { html: nextText.trim() } }));
          }
          highlightPathsFrom(null);
          var alongIDs = datum2.path.slice();
          surface.selectAll(utilEntitySelector(alongIDs)).classed("related", true).classed("allow", klass === "allow").classed("restrict", klass === "restrict").classed("only", klass === "only");
        } else {
          highlightPathsFrom(null);
          if (_fromWayID) {
            help.append("div").html(_t.html("restriction.help.from_name", {
              from: placeholders.from,
              fromName: displayName(_fromWayID, vgraph)
            }));
          } else {
            help.append("div").html(_t.html("restriction.help.select_from", {
              from: placeholders.from
            }));
          }
        }
      }
    }
    function displayMaxDistance(maxDist) {
      return (selection2) => {
        var isImperial = !_mainLocalizer.usesMetric();
        var opts;
        if (isImperial) {
          var distToFeet = {
            // imprecise conversion for prettier display
            20: 70,
            25: 85,
            30: 100,
            35: 115,
            40: 130,
            45: 145,
            50: 160
          }[maxDist];
          opts = { distance: _t("units.feet", { quantity: distToFeet }) };
        } else {
          opts = { distance: _t("units.meters", { quantity: maxDist }) };
        }
        return selection2.html("").call(_t.append("restriction.controls.distance_up_to", opts));
      };
    }
    function displayMaxVia(maxVia) {
      return (selection2) => {
        selection2 = selection2.html("");
        return maxVia === 0 ? selection2.call(_t.append("restriction.controls.via_node_only")) : maxVia === 1 ? selection2.call(_t.append("restriction.controls.via_up_to_one")) : selection2.call(_t.append("restriction.controls.via_up_to_two"));
      };
    }
    function displayName(entityID, graph) {
      var entity = graph.entity(entityID);
      var name = utilDisplayName(entity) || "";
      var matched = _mainPresetIndex.match(entity, graph);
      var type2 = matched && matched.name() || utilDisplayType(entity.id);
      return name || type2;
    }
    restrictions.entityIDs = function(val) {
      _intersection = null;
      _fromWayID = null;
      _oldTurns = null;
      _vertexID = val[0];
    };
    restrictions.tags = function() {
    };
    restrictions.focus = function() {
    };
    restrictions.off = function(selection2) {
      if (!_initialized3)
        return;
      selection2.selectAll(".surface").call(breathe.off).on("click.restrictions", null).on("mouseover.restrictions", null);
      select_default2(window).on("resize.restrictions", null);
    };
    return utilRebind(restrictions, dispatch14, "on");
  }
  uiFieldRestrictions.supportsMultiselection = false;

  // modules/ui/fields/textarea.js
  function uiFieldTextarea(field, context) {
    var dispatch14 = dispatch_default("change");
    var input = select_default2(null);
    var _lengthIndicator = uiLengthIndicator(context.maxCharsForTagValue()).silent(field.usage === "changeset" && field.key === "comment");
    var _tags;
    function textarea(selection2) {
      var wrap2 = selection2.selectAll(".form-field-input-wrap").data([0]);
      wrap2 = wrap2.enter().append("div").attr("class", "form-field-input-wrap form-field-input-" + field.type).style("position", "relative").merge(wrap2);
      input = wrap2.selectAll("textarea").data([0]);
      input = input.enter().append("textarea").attr("id", field.domId).call(utilNoAuto).on("input", change(true)).on("blur", change()).on("change", change()).merge(input);
      wrap2.call(_lengthIndicator);
      function change(onInput) {
        return function() {
          var val = utilGetSetValue(input);
          if (!onInput)
            val = context.cleanTagValue(val);
          if (!val && Array.isArray(_tags[field.key]))
            return;
          var t2 = {};
          t2[field.key] = val || void 0;
          dispatch14.call("change", this, t2, onInput);
        };
      }
    }
    textarea.tags = function(tags) {
      _tags = tags;
      var isMixed = Array.isArray(tags[field.key]);
      utilGetSetValue(input, !isMixed && tags[field.key] ? tags[field.key] : "").attr("title", isMixed ? tags[field.key].filter(Boolean).join("\n") : void 0).attr("placeholder", isMixed ? _t("inspector.multiple_values") : field.placeholder() || _t("inspector.unknown")).classed("mixed", isMixed);
      if (!isMixed) {
        _lengthIndicator.update(tags[field.key]);
      }
    };
    textarea.focus = function() {
      input.node().focus();
    };
    return utilRebind(textarea, dispatch14, "on");
  }

  // modules/ui/fields/wikidata.js
  function uiFieldWikidata(field, context) {
    var wikidata = services.wikidata;
    var dispatch14 = dispatch_default("change");
    var _selection = select_default2(null);
    var _searchInput = select_default2(null);
    var _qid = null;
    var _wikidataEntity = null;
    var _wikiURL = "";
    var _entityIDs = [];
    var _wikipediaKey = field.keys && field.keys.find(function(key) {
      return key.includes("wikipedia");
    });
    var _hintKey = field.key === "wikidata" ? "name" : field.key.split(":")[0];
    var combobox = uiCombobox(context, "combo-" + field.safeid).caseSensitive(true).minItems(1);
    function wiki(selection2) {
      _selection = selection2;
      var wrap2 = selection2.selectAll(".form-field-input-wrap").data([0]);
      wrap2 = wrap2.enter().append("div").attr("class", "form-field-input-wrap form-field-input-" + field.type).merge(wrap2);
      var list2 = wrap2.selectAll("ul").data([0]);
      list2 = list2.enter().append("ul").attr("class", "rows").merge(list2);
      var searchRow = list2.selectAll("li.wikidata-search").data([0]);
      var searchRowEnter = searchRow.enter().append("li").attr("class", "wikidata-search");
      searchRowEnter.append("input").attr("type", "text").attr("id", field.domId).style("flex", "1").call(utilNoAuto).on("focus", function() {
        var node = select_default2(this).node();
        node.setSelectionRange(0, node.value.length);
      }).on("blur", function() {
        setLabelForEntity();
      }).call(combobox.fetcher(fetchWikidataItems));
      combobox.on("accept", function(d2) {
        if (d2) {
          _qid = d2.id;
          change();
        }
      }).on("cancel", function() {
        setLabelForEntity();
      });
      searchRowEnter.append("button").attr("class", "form-field-button wiki-link").attr("title", _t("icons.view_on", { domain: "wikidata.org" })).call(svgIcon("#iD-icon-out-link")).on("click", function(d3_event) {
        d3_event.preventDefault();
        if (_wikiURL)
          window.open(_wikiURL, "_blank");
      });
      searchRow = searchRow.merge(searchRowEnter);
      _searchInput = searchRow.select("input");
      var wikidataProperties = ["description", "identifier"];
      var items = list2.selectAll("li.labeled-input").data(wikidataProperties);
      var enter = items.enter().append("li").attr("class", function(d2) {
        return "labeled-input preset-wikidata-" + d2;
      });
      enter.append("div").attr("class", "label").html(function(d2) {
        return _t.html("wikidata." + d2);
      });
      enter.append("input").attr("type", "text").call(utilNoAuto).classed("disabled", "true").attr("readonly", "true");
      enter.append("button").attr("class", "form-field-button").attr("title", _t("icons.copy")).call(svgIcon("#iD-operation-copy")).on("click", function(d3_event) {
        d3_event.preventDefault();
        select_default2(this.parentNode).select("input").node().select();
        document.execCommand("copy");
      });
    }
    function fetchWikidataItems(q2, callback) {
      if (!q2 && _hintKey) {
        for (var i3 in _entityIDs) {
          var entity = context.hasEntity(_entityIDs[i3]);
          if (entity.tags[_hintKey]) {
            q2 = entity.tags[_hintKey];
            break;
          }
        }
      }
      wikidata.itemsForSearchQuery(q2, function(err, data) {
        if (err) {
          if (err !== "No query")
            console.error(err);
          return;
        }
        var result = data.map(function(item) {
          return {
            id: item.id,
            value: item.display.label.value + " (" + item.id + ")",
            display: (selection2) => selection2.append("span").attr("class", "localized-text").attr("lang", item.display.label.language).text(item.display.label.value),
            title: item.display.description && item.display.description.value,
            terms: item.aliases
          };
        });
        if (callback)
          callback(result);
      });
    }
    function change() {
      var syncTags = {};
      syncTags[field.key] = _qid;
      dispatch14.call("change", this, syncTags);
      var initGraph = context.graph();
      var initEntityIDs = _entityIDs;
      wikidata.entityByQID(_qid, function(err, entity) {
        if (err)
          return;
        if (context.graph() !== initGraph)
          return;
        if (!entity.sitelinks)
          return;
        var langs = wikidata.languagesToQuery();
        ["labels", "descriptions"].forEach(function(key) {
          if (!entity[key])
            return;
          var valueLangs = Object.keys(entity[key]);
          if (valueLangs.length === 0)
            return;
          var valueLang = valueLangs[0];
          if (langs.indexOf(valueLang) === -1) {
            langs.push(valueLang);
          }
        });
        var newWikipediaValue;
        if (_wikipediaKey) {
          var foundPreferred;
          for (var i3 in langs) {
            var lang = langs[i3];
            var siteID = lang.replace("-", "_") + "wiki";
            if (entity.sitelinks[siteID]) {
              foundPreferred = true;
              newWikipediaValue = lang + ":" + entity.sitelinks[siteID].title;
              break;
            }
          }
          if (!foundPreferred) {
            var wikiSiteKeys = Object.keys(entity.sitelinks).filter(function(site) {
              return site.endsWith("wiki");
            });
            if (wikiSiteKeys.length === 0) {
              newWikipediaValue = null;
            } else {
              var wikiLang = wikiSiteKeys[0].slice(0, -4).replace("_", "-");
              var wikiTitle = entity.sitelinks[wikiSiteKeys[0]].title;
              newWikipediaValue = wikiLang + ":" + wikiTitle;
            }
          }
        }
        if (newWikipediaValue) {
          newWikipediaValue = context.cleanTagValue(newWikipediaValue);
        }
        if (typeof newWikipediaValue === "undefined")
          return;
        var actions = initEntityIDs.map(function(entityID) {
          var entity2 = context.hasEntity(entityID);
          if (!entity2)
            return null;
          var currTags = Object.assign({}, entity2.tags);
          if (newWikipediaValue === null) {
            if (!currTags[_wikipediaKey])
              return null;
            delete currTags[_wikipediaKey];
          } else {
            currTags[_wikipediaKey] = newWikipediaValue;
          }
          return actionChangeTags(entityID, currTags);
        }).filter(Boolean);
        if (!actions.length)
          return;
        context.overwrite(
          function actionUpdateWikipediaTags(graph) {
            actions.forEach(function(action) {
              graph = action(graph);
            });
            return graph;
          },
          context.history().undoAnnotation()
        );
      });
    }
    function setLabelForEntity() {
      var label = "";
      if (_wikidataEntity) {
        label = entityPropertyForDisplay(_wikidataEntity, "labels");
        if (label.length === 0) {
          label = _wikidataEntity.id.toString();
        }
      }
      utilGetSetValue(_searchInput, label);
    }
    wiki.tags = function(tags) {
      var isMixed = Array.isArray(tags[field.key]);
      _searchInput.attr("title", isMixed ? tags[field.key].filter(Boolean).join("\n") : null).attr("placeholder", isMixed ? _t("inspector.multiple_values") : "").classed("mixed", isMixed);
      _qid = typeof tags[field.key] === "string" && tags[field.key] || "";
      if (!/^Q[0-9]*$/.test(_qid)) {
        unrecognized();
        return;
      }
      _wikiURL = "https://wikidata.org/wiki/" + _qid;
      wikidata.entityByQID(_qid, function(err, entity) {
        if (err) {
          unrecognized();
          return;
        }
        _wikidataEntity = entity;
        setLabelForEntity();
        var description = entityPropertyForDisplay(entity, "descriptions");
        _selection.select("button.wiki-link").classed("disabled", false);
        _selection.select(".preset-wikidata-description").style("display", function() {
          return description.length > 0 ? "flex" : "none";
        }).select("input").attr("value", description);
        _selection.select(".preset-wikidata-identifier").style("display", function() {
          return entity.id ? "flex" : "none";
        }).select("input").attr("value", entity.id);
      });
      function unrecognized() {
        _wikidataEntity = null;
        setLabelForEntity();
        _selection.select(".preset-wikidata-description").style("display", "none");
        _selection.select(".preset-wikidata-identifier").style("display", "none");
        _selection.select("button.wiki-link").classed("disabled", true);
        if (_qid && _qid !== "") {
          _wikiURL = "https://wikidata.org/wiki/Special:Search?search=" + _qid;
        } else {
          _wikiURL = "";
        }
      }
    };
    function entityPropertyForDisplay(wikidataEntity, propKey) {
      if (!wikidataEntity[propKey])
        return "";
      var propObj = wikidataEntity[propKey];
      var langKeys = Object.keys(propObj);
      if (langKeys.length === 0)
        return "";
      var langs = wikidata.languagesToQuery();
      for (var i3 in langs) {
        var lang = langs[i3];
        var valueObj = propObj[lang];
        if (valueObj && valueObj.value && valueObj.value.length > 0)
          return valueObj.value;
      }
      return propObj[langKeys[0]].value;
    }
    wiki.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      _entityIDs = val;
      return wiki;
    };
    wiki.focus = function() {
      _searchInput.node().focus();
    };
    return utilRebind(wiki, dispatch14, "on");
  }

  // modules/ui/fields/wikipedia.js
  function uiFieldWikipedia(field, context) {
    const scheme = "https://";
    const domain = "wikipedia.org";
    const dispatch14 = dispatch_default("change");
    const wikipedia = services.wikipedia;
    const wikidata = services.wikidata;
    let _langInput = select_default2(null);
    let _titleInput = select_default2(null);
    let _wikiURL = "";
    let _entityIDs;
    let _tags;
    let _dataWikipedia = [];
    _mainFileFetcher.get("wmf_sitematrix").then((d2) => {
      _dataWikipedia = d2;
      if (_tags)
        updateForTags(_tags);
    }).catch(() => {
    });
    const langCombo = uiCombobox(context, "wikipedia-lang").fetcher((value, callback) => {
      const v2 = value.toLowerCase();
      callback(
        _dataWikipedia.filter((d2) => {
          return d2[0].toLowerCase().indexOf(v2) >= 0 || d2[1].toLowerCase().indexOf(v2) >= 0 || d2[2].toLowerCase().indexOf(v2) >= 0;
        }).map((d2) => ({ value: d2[1] }))
      );
    });
    const titleCombo = uiCombobox(context, "wikipedia-title").fetcher((value, callback) => {
      if (!value) {
        value = "";
        for (let i3 in _entityIDs) {
          let entity = context.hasEntity(_entityIDs[i3]);
          if (entity.tags.name) {
            value = entity.tags.name;
            break;
          }
        }
      }
      const searchfn = value.length > 7 ? wikipedia.search : wikipedia.suggestions;
      searchfn(language()[2], value, (query, data) => {
        callback(data.map((d2) => ({ value: d2 })));
      });
    });
    function wiki(selection2) {
      let wrap2 = selection2.selectAll(".form-field-input-wrap").data([0]);
      wrap2 = wrap2.enter().append("div").attr("class", "form-field-input-wrap form-field-input-".concat(field.type)).merge(wrap2);
      let langContainer = wrap2.selectAll(".wiki-lang-container").data([0]);
      langContainer = langContainer.enter().append("div").attr("class", "wiki-lang-container").merge(langContainer);
      _langInput = langContainer.selectAll("input.wiki-lang").data([0]);
      _langInput = _langInput.enter().append("input").attr("type", "text").attr("class", "wiki-lang").attr("placeholder", _t("translate.localized_translation_language")).call(utilNoAuto).call(langCombo).merge(_langInput);
      _langInput.on("blur", changeLang).on("change", changeLang);
      let titleContainer = wrap2.selectAll(".wiki-title-container").data([0]);
      titleContainer = titleContainer.enter().append("div").attr("class", "wiki-title-container").merge(titleContainer);
      _titleInput = titleContainer.selectAll("input.wiki-title").data([0]);
      _titleInput = _titleInput.enter().append("input").attr("type", "text").attr("class", "wiki-title").attr("id", field.domId).call(utilNoAuto).call(titleCombo).merge(_titleInput);
      _titleInput.on("blur", function() {
        change(true);
      }).on("change", function() {
        change(false);
      });
      let link3 = titleContainer.selectAll(".wiki-link").data([0]);
      link3 = link3.enter().append("button").attr("class", "form-field-button wiki-link").attr("title", _t("icons.view_on", { domain })).call(svgIcon("#iD-icon-out-link")).merge(link3);
      link3.on("click", (d3_event) => {
        d3_event.preventDefault();
        if (_wikiURL)
          window.open(_wikiURL, "_blank");
      });
    }
    function defaultLanguageInfo(skipEnglishFallback) {
      const langCode = _mainLocalizer.languageCode().toLowerCase();
      for (let i3 in _dataWikipedia) {
        let d2 = _dataWikipedia[i3];
        if (d2[2] === langCode)
          return d2;
      }
      return skipEnglishFallback ? ["", "", ""] : ["English", "English", "en"];
    }
    function language(skipEnglishFallback) {
      const value = utilGetSetValue(_langInput).toLowerCase();
      for (let i3 in _dataWikipedia) {
        let d2 = _dataWikipedia[i3];
        if (d2[0].toLowerCase() === value || d2[1].toLowerCase() === value || d2[2] === value)
          return d2;
      }
      return defaultLanguageInfo(skipEnglishFallback);
    }
    function changeLang() {
      utilGetSetValue(_langInput, language()[1]);
      change(true);
    }
    function change(skipWikidata) {
      let value = utilGetSetValue(_titleInput);
      const m2 = value.match(/https?:\/\/([-a-z]+)\.wikipedia\.org\/(?:wiki|\1-[-a-z]+)\/([^#]+)(?:#(.+))?/);
      const langInfo = m2 && _dataWikipedia.find((d2) => m2[1] === d2[2]);
      let syncTags = {};
      if (langInfo) {
        const nativeLangName = langInfo[1];
        value = decodeURIComponent(m2[2]).replace(/_/g, " ");
        if (m2[3]) {
          let anchor;
          anchor = decodeURIComponent(m2[3]);
          value += "#" + anchor.replace(/_/g, " ");
        }
        value = value.slice(0, 1).toUpperCase() + value.slice(1);
        utilGetSetValue(_langInput, nativeLangName);
        utilGetSetValue(_titleInput, value);
      }
      if (value) {
        syncTags.wikipedia = context.cleanTagValue(language()[2] + ":" + value);
      } else {
        syncTags.wikipedia = void 0;
      }
      dispatch14.call("change", this, syncTags);
      if (skipWikidata || !value || !language()[2])
        return;
      const initGraph = context.graph();
      const initEntityIDs = _entityIDs;
      wikidata.itemsByTitle(language()[2], value, (err, data) => {
        if (err || !data || !Object.keys(data).length)
          return;
        if (context.graph() !== initGraph)
          return;
        const qids = Object.keys(data);
        const value2 = qids && qids.find((id2) => id2.match(/^Q\d+$/));
        let actions = initEntityIDs.map((entityID) => {
          let entity = context.entity(entityID).tags;
          let currTags = Object.assign({}, entity);
          if (currTags.wikidata !== value2) {
            currTags.wikidata = value2;
            return actionChangeTags(entityID, currTags);
          }
          return null;
        }).filter(Boolean);
        if (!actions.length)
          return;
        context.overwrite(
          function actionUpdateWikidataTags(graph) {
            actions.forEach(function(action) {
              graph = action(graph);
            });
            return graph;
          },
          context.history().undoAnnotation()
        );
      });
    }
    wiki.tags = (tags) => {
      _tags = tags;
      updateForTags(tags);
    };
    function updateForTags(tags) {
      const value = typeof tags[field.key] === "string" ? tags[field.key] : "";
      const m2 = value.match(/([^:]+):([^#]+)(?:#(.+))?/);
      const tagLang = m2 && m2[1];
      const tagArticleTitle = m2 && m2[2];
      let anchor = m2 && m2[3];
      const tagLangInfo = tagLang && _dataWikipedia.find((d2) => tagLang === d2[2]);
      if (tagLangInfo) {
        const nativeLangName = tagLangInfo[1];
        utilGetSetValue(_langInput, nativeLangName);
        utilGetSetValue(_titleInput, tagArticleTitle + (anchor ? "#" + anchor : ""));
        _wikiURL = "".concat(scheme).concat(tagLang, ".").concat(domain, "/wiki/").concat(wiki.encodePath(tagArticleTitle, anchor));
      } else {
        utilGetSetValue(_titleInput, value);
        if (value && value !== "") {
          utilGetSetValue(_langInput, "");
          const defaultLangInfo = defaultLanguageInfo();
          _wikiURL = "".concat(scheme).concat(defaultLangInfo[2], ".").concat(domain, "/w/index.php?fulltext=1&search=").concat(value);
        } else {
          const shownOrDefaultLangInfo = language(
            true
            /* skipEnglishFallback */
          );
          utilGetSetValue(_langInput, shownOrDefaultLangInfo[1]);
          _wikiURL = "";
        }
      }
    }
    wiki.encodePath = (tagArticleTitle, anchor) => {
      const underscoredTitle = tagArticleTitle.replace(/ /g, "_");
      const uriEncodedUnderscoredTitle = encodeURIComponent(underscoredTitle);
      const uriEncodedAnchorFragment = wiki.encodeURIAnchorFragment(anchor);
      return "".concat(uriEncodedUnderscoredTitle).concat(uriEncodedAnchorFragment);
    };
    wiki.encodeURIAnchorFragment = (anchor) => {
      if (!anchor)
        return "";
      const underscoredAnchor = anchor.replace(/ /g, "_");
      return "#" + encodeURIComponent(underscoredAnchor);
    };
    wiki.entityIDs = (val) => {
      if (!arguments.length)
        return _entityIDs;
      _entityIDs = val;
      return wiki;
    };
    wiki.focus = () => {
      _titleInput.node().focus();
    };
    return utilRebind(wiki, dispatch14, "on");
  }
  uiFieldWikipedia.supportsMultiselection = false;

  // modules/ui/fields/index.js
  var uiFields = {
    access: uiFieldAccess,
    address: uiFieldAddress,
    check: uiFieldCheck,
    colour: uiFieldText,
    combo: uiFieldCombo,
    cycleway: uiFieldDirectionalCombo,
    date: uiFieldText,
    defaultCheck: uiFieldCheck,
    directionalCombo: uiFieldDirectionalCombo,
    email: uiFieldText,
    identifier: uiFieldText,
    lanes: uiFieldLanes,
    localized: uiFieldLocalized,
    roadheight: uiFieldRoadheight,
    roadspeed: uiFieldRoadspeed,
    manyCombo: uiFieldCombo,
    multiCombo: uiFieldCombo,
    networkCombo: uiFieldCombo,
    number: uiFieldText,
    onewayCheck: uiFieldCheck,
    radio: uiFieldRadio,
    restrictions: uiFieldRestrictions,
    semiCombo: uiFieldCombo,
    structureRadio: uiFieldRadio,
    tel: uiFieldText,
    text: uiFieldText,
    textarea: uiFieldTextarea,
    typeCombo: uiFieldCombo,
    url: uiFieldText,
    wikidata: uiFieldWikidata,
    wikipedia: uiFieldWikipedia
  };

  // modules/ui/field.js
  function uiField(context, presetField2, entityIDs, options2) {
    options2 = Object.assign({
      show: true,
      wrap: true,
      remove: true,
      revert: true,
      info: true
    }, options2);
    var dispatch14 = dispatch_default("change", "revert");
    var field = Object.assign({}, presetField2);
    field.domId = utilUniqueDomId("form-field-" + field.safeid);
    var _show = options2.show;
    var _state = "";
    var _tags = {};
    var _entityExtent;
    if (entityIDs && entityIDs.length) {
      _entityExtent = entityIDs.reduce(function(extent, entityID) {
        var entity = context.graph().entity(entityID);
        return extent.extend(entity.extent(context.graph()));
      }, geoExtent());
    }
    var _locked = false;
    var _lockedTip = uiTooltip().title(() => _t.append("inspector.lock.suggestion", { label: field.title })).placement("bottom");
    if (_show && !field.impl) {
      createField();
    }
    function createField() {
      field.impl = uiFields[field.type](field, context).on("change", function(t2, onInput) {
        dispatch14.call("change", field, t2, onInput);
      });
      if (entityIDs) {
        field.entityIDs = entityIDs;
        if (field.impl.entityIDs) {
          field.impl.entityIDs(entityIDs);
        }
      }
    }
    function allKeys() {
      let keys2 = field.keys || [field.key];
      if (field.type === "directionalCombo" && field.key) {
        keys2 = keys2.concat(field.key);
      }
      return keys2;
    }
    function isModified() {
      if (!entityIDs || !entityIDs.length)
        return false;
      return entityIDs.some(function(entityID) {
        var original = context.graph().base().entities[entityID];
        var latest = context.graph().entity(entityID);
        return allKeys().some(function(key) {
          return original ? latest.tags[key] !== original.tags[key] : latest.tags[key];
        });
      });
    }
    function tagsContainFieldKey() {
      return allKeys().some(function(key) {
        if (field.type === "multiCombo") {
          for (var tagKey in _tags) {
            if (tagKey.indexOf(key) === 0) {
              return true;
            }
          }
          return false;
        }
        return _tags[key] !== void 0;
      });
    }
    function revert(d3_event, d2) {
      d3_event.stopPropagation();
      d3_event.preventDefault();
      if (!entityIDs || _locked)
        return;
      dispatch14.call("revert", d2, allKeys());
    }
    function remove2(d3_event, d2) {
      d3_event.stopPropagation();
      d3_event.preventDefault();
      if (_locked)
        return;
      var t2 = {};
      allKeys().forEach(function(key) {
        t2[key] = void 0;
      });
      dispatch14.call("change", d2, t2);
    }
    field.render = function(selection2) {
      var container = selection2.selectAll(".form-field").data([field]);
      var enter = container.enter().append("div").attr("class", function(d2) {
        return "form-field form-field-" + d2.safeid;
      }).classed("nowrap", !options2.wrap);
      if (options2.wrap) {
        var labelEnter = enter.append("label").attr("class", "field-label").attr("for", function(d2) {
          return d2.domId;
        });
        var textEnter = labelEnter.append("span").attr("class", "label-text");
        textEnter.append("span").attr("class", "label-textvalue").each(function(d2) {
          d2.label()(select_default2(this));
        });
        textEnter.append("span").attr("class", "label-textannotation");
        if (options2.remove) {
          labelEnter.append("button").attr("class", "remove-icon").attr("title", _t("icons.remove")).call(svgIcon("#iD-operation-delete"));
        }
        if (options2.revert) {
          labelEnter.append("button").attr("class", "modified-icon").attr("title", _t("icons.undo")).call(svgIcon(_mainLocalizer.textDirection() === "rtl" ? "#iD-icon-redo" : "#iD-icon-undo"));
        }
      }
      container = container.merge(enter);
      container.select(".field-label > .remove-icon").on("click", remove2);
      container.select(".field-label > .modified-icon").on("click", revert);
      container.each(function(d2) {
        var selection3 = select_default2(this);
        if (!d2.impl) {
          createField();
        }
        var reference, help;
        if (options2.wrap && field.type === "restrictions") {
          help = uiFieldHelp(context, "restrictions");
        }
        if (options2.wrap && options2.info) {
          var referenceKey = d2.key || "";
          if (d2.type === "multiCombo") {
            referenceKey = referenceKey.replace(/:$/, "");
          }
          var referenceOptions = d2.reference || {
            key: referenceKey,
            value: _tags[referenceKey]
          };
          reference = uiTagReference(referenceOptions, context);
          if (_state === "hover") {
            reference.showing(false);
          }
        }
        selection3.call(d2.impl);
        if (help) {
          selection3.call(help.body).select(".field-label").call(help.button);
        }
        if (reference) {
          selection3.call(reference.body).select(".field-label").call(reference.button);
        }
        d2.impl.tags(_tags);
      });
      container.classed("locked", _locked).classed("modified", isModified()).classed("present", tagsContainFieldKey());
      var annotation = container.selectAll(".field-label .label-textannotation");
      var icon2 = annotation.selectAll(".icon").data(_locked ? [0] : []);
      icon2.exit().remove();
      icon2.enter().append("svg").attr("class", "icon").append("use").attr("xlink:href", "#fas-lock");
      container.call(_locked ? _lockedTip : _lockedTip.destroy);
    };
    field.state = function(val) {
      if (!arguments.length)
        return _state;
      _state = val;
      return field;
    };
    field.tags = function(val) {
      if (!arguments.length)
        return _tags;
      _tags = val;
      if (tagsContainFieldKey() && !_show) {
        _show = true;
        if (!field.impl) {
          createField();
        }
      }
      return field;
    };
    field.locked = function(val) {
      if (!arguments.length)
        return _locked;
      _locked = val;
      return field;
    };
    field.show = function() {
      _show = true;
      if (!field.impl) {
        createField();
      }
      if (field.default && field.key && _tags[field.key] !== field.default) {
        var t2 = {};
        t2[field.key] = field.default;
        dispatch14.call("change", this, t2);
      }
    };
    field.isShown = function() {
      return _show;
    };
    field.isAllowed = function() {
      if (entityIDs && entityIDs.length > 1 && uiFields[field.type].supportsMultiselection === false)
        return false;
      if (field.geometry && !entityIDs.every(function(entityID) {
        return field.matchGeometry(context.graph().geometry(entityID));
      }))
        return false;
      if (entityIDs && _entityExtent && field.locationSetID) {
        var validHere = _sharedLocationManager.locationSetsAt(_entityExtent.center());
        if (!validHere[field.locationSetID])
          return false;
      }
      var prerequisiteTag = field.prerequisiteTag;
      if (entityIDs && !tagsContainFieldKey() && // ignore tagging prerequisites if a value is already present
      prerequisiteTag) {
        if (!entityIDs.every(function(entityID) {
          var entity = context.graph().entity(entityID);
          if (prerequisiteTag.key) {
            var value = entity.tags[prerequisiteTag.key];
            if (!value)
              return false;
            if (prerequisiteTag.valueNot) {
              return prerequisiteTag.valueNot !== value;
            }
            if (prerequisiteTag.value) {
              return prerequisiteTag.value === value;
            }
          } else if (prerequisiteTag.keyNot) {
            if (entity.tags[prerequisiteTag.keyNot])
              return false;
          }
          return true;
        }))
          return false;
      }
      return true;
    };
    field.focus = function() {
      if (field.impl) {
        field.impl.focus();
      }
    };
    return utilRebind(field, dispatch14, "on");
  }

  // modules/ui/form_fields.js
  function uiFormFields(context) {
    var moreCombo = uiCombobox(context, "more-fields").minItems(1);
    var _fieldsArr = [];
    var _lastPlaceholder = "";
    var _state = "";
    var _klass = "";
    function formFields(selection2) {
      var allowedFields = _fieldsArr.filter(function(field) {
        return field.isAllowed();
      });
      var shown = allowedFields.filter(function(field) {
        return field.isShown();
      });
      var notShown = allowedFields.filter(function(field) {
        return !field.isShown();
      });
      var container = selection2.selectAll(".form-fields-container").data([0]);
      container = container.enter().append("div").attr("class", "form-fields-container " + (_klass || "")).merge(container);
      var fields = container.selectAll(".wrap-form-field").data(shown, function(d2) {
        return d2.id + (d2.entityIDs ? d2.entityIDs.join() : "");
      });
      fields.exit().remove();
      var enter = fields.enter().append("div").attr("class", function(d2) {
        return "wrap-form-field wrap-form-field-" + d2.safeid;
      });
      fields = fields.merge(enter);
      fields.order().each(function(d2) {
        select_default2(this).call(d2.render);
      });
      var titles = [];
      var moreFields = notShown.map(function(field) {
        var title = field.title();
        titles.push(title);
        var terms = field.terms();
        if (field.key)
          terms.push(field.key);
        if (field.keys)
          terms = terms.concat(field.keys);
        return {
          display: field.label(),
          value: title,
          title,
          field,
          terms
        };
      });
      var placeholder = titles.slice(0, 3).join(", ") + (titles.length > 3 ? "\u2026" : "");
      var more = selection2.selectAll(".more-fields").data(_state === "hover" || moreFields.length === 0 ? [] : [0]);
      more.exit().remove();
      var moreEnter = more.enter().append("div").attr("class", "more-fields").append("label");
      moreEnter.append("span").call(_t.append("inspector.add_fields"));
      more = moreEnter.merge(more);
      var input = more.selectAll(".value").data([0]);
      input.exit().remove();
      input = input.enter().append("input").attr("class", "value").attr("type", "text").attr("placeholder", placeholder).call(utilNoAuto).merge(input);
      input.call(utilGetSetValue, "").call(
        moreCombo.data(moreFields).on("accept", function(d2) {
          if (!d2)
            return;
          var field = d2.field;
          field.show();
          selection2.call(formFields);
          field.focus();
        })
      );
      if (_lastPlaceholder !== placeholder) {
        input.attr("placeholder", placeholder);
        _lastPlaceholder = placeholder;
      }
    }
    formFields.fieldsArr = function(val) {
      if (!arguments.length)
        return _fieldsArr;
      _fieldsArr = val || [];
      return formFields;
    };
    formFields.state = function(val) {
      if (!arguments.length)
        return _state;
      _state = val;
      return formFields;
    };
    formFields.klass = function(val) {
      if (!arguments.length)
        return _klass;
      _klass = val;
      return formFields;
    };
    return formFields;
  }

  // modules/ui/changeset_editor.js
  function uiChangesetEditor(context) {
    var dispatch14 = dispatch_default("change");
    var formFields = uiFormFields(context);
    var commentCombo = uiCombobox(context, "comment").caseSensitive(true);
    var _fieldsArr;
    var _tags;
    var _changesetID;
    function changesetEditor(selection2) {
      render(selection2);
    }
    function render(selection2) {
      var initial = false;
      if (!_fieldsArr) {
        initial = true;
        var presets = _mainPresetIndex;
        _fieldsArr = [
          uiField(context, presets.field("comment"), null, { show: true, revert: false }),
          uiField(context, presets.field("source"), null, { show: true, revert: false }),
          uiField(context, presets.field("hashtags"), null, { show: false, revert: false })
        ];
        _fieldsArr.forEach(function(field) {
          field.on("change", function(t2, onInput) {
            dispatch14.call("change", field, void 0, t2, onInput);
          });
        });
      }
      _fieldsArr.forEach(function(field) {
        field.tags(_tags);
      });
      selection2.call(formFields.fieldsArr(_fieldsArr));
      if (initial) {
        var commentField = selection2.select(".form-field-comment textarea");
        var commentNode = commentField.node();
        if (commentNode) {
          commentNode.focus();
          commentNode.select();
        }
        utilTriggerEvent(commentField, "blur");
        var osm = context.connection();
        if (osm) {
          osm.userChangesets(function(err, changesets) {
            if (err)
              return;
            var comments = changesets.map(function(changeset) {
              var comment = changeset.tags.comment;
              return comment ? { title: comment, value: comment } : null;
            }).filter(Boolean);
            commentField.call(
              commentCombo.data(utilArrayUniqBy(comments, "title"))
            );
          });
        }
      }
      const warnings = [];
      if (_tags.comment.match(/google/i)) {
        warnings.push({
          id: 'contains "google"',
          msg: _t.append("commit.google_warning"),
          link: _t("commit.google_warning_link")
        });
      }
      const maxChars = context.maxCharsForTagValue();
      const strLen = utilUnicodeCharsCount(utilCleanOsmString(_tags.comment, Number.POSITIVE_INFINITY));
      if (strLen > maxChars || false) {
        warnings.push({
          id: "message too long",
          msg: _t.append("commit.changeset_comment_length_warning", { maxChars })
        });
      }
      var commentWarning = selection2.select(".form-field-comment").selectAll(".comment-warning").data(warnings, (d2) => d2.id);
      commentWarning.exit().transition().duration(200).style("opacity", 0).remove();
      var commentEnter = commentWarning.enter().insert("div", ".comment-warning").attr("class", "comment-warning field-warning").style("opacity", 0);
      commentEnter.call(svgIcon("#iD-icon-alert", "inline")).append("span");
      commentEnter.transition().duration(200).style("opacity", 1);
      commentWarning.merge(commentEnter).selectAll("div > span").text("").each(function(d2) {
        let selection3 = select_default2(this);
        if (d2.link) {
          selection3 = selection3.append("a").attr("target", "_blank").attr("href", d2.link);
        }
        selection3.call(d2.msg);
      });
    }
    changesetEditor.tags = function(_2) {
      if (!arguments.length)
        return _tags;
      _tags = _2;
      return changesetEditor;
    };
    changesetEditor.changesetID = function(_2) {
      if (!arguments.length)
        return _changesetID;
      if (_changesetID === _2)
        return changesetEditor;
      _changesetID = _2;
      _fieldsArr = null;
      return changesetEditor;
    };
    return utilRebind(changesetEditor, dispatch14, "on");
  }

  // modules/ui/commit.js
  var import_fast_deep_equal9 = __toESM(require_fast_deep_equal());

  // modules/util/jxon.js
  var JXON = new function() {
    var sValueProp = "keyValue", sAttributesProp = "keyAttributes", sAttrPref = "@", aCache = [], rIsNull = /^\s*$/, rIsBool = /^(?:true|false)$/i;
    function parseText(sValue) {
      if (rIsNull.test(sValue)) {
        return null;
      }
      if (rIsBool.test(sValue)) {
        return sValue.toLowerCase() === "true";
      }
      if (isFinite(sValue)) {
        return parseFloat(sValue);
      }
      if (isFinite(Date.parse(sValue))) {
        return new Date(sValue);
      }
      return sValue;
    }
    function EmptyTree() {
    }
    EmptyTree.prototype.toString = function() {
      return "null";
    };
    EmptyTree.prototype.valueOf = function() {
      return null;
    };
    function objectify(vValue) {
      return vValue === null ? new EmptyTree() : vValue instanceof Object ? vValue : new vValue.constructor(vValue);
    }
    function createObjTree(oParentNode, nVerb, bFreeze, bNesteAttr) {
      var nLevelStart = aCache.length, bChildren = oParentNode.hasChildNodes(), bAttributes = oParentNode.hasAttributes(), bHighVerb = Boolean(nVerb & 2);
      var sProp, vContent, nLength = 0, sCollectedTxt = "", vResult = bHighVerb ? {} : (
        /* put here the default value for empty nodes: */
        true
      );
      if (bChildren) {
        for (var oNode, nItem = 0; nItem < oParentNode.childNodes.length; nItem++) {
          oNode = oParentNode.childNodes.item(nItem);
          if (oNode.nodeType === 4) {
            sCollectedTxt += oNode.nodeValue;
          } else if (oNode.nodeType === 3) {
            sCollectedTxt += oNode.nodeValue.trim();
          } else if (oNode.nodeType === 1 && !oNode.prefix) {
            aCache.push(oNode);
          }
        }
      }
      var nLevelEnd = aCache.length, vBuiltVal = parseText(sCollectedTxt);
      if (!bHighVerb && (bChildren || bAttributes)) {
        vResult = nVerb === 0 ? objectify(vBuiltVal) : {};
      }
      for (var nElId = nLevelStart; nElId < nLevelEnd; nElId++) {
        sProp = aCache[nElId].nodeName.toLowerCase();
        vContent = createObjTree(aCache[nElId], nVerb, bFreeze, bNesteAttr);
        if (vResult.hasOwnProperty(sProp)) {
          if (vResult[sProp].constructor !== Array) {
            vResult[sProp] = [vResult[sProp]];
          }
          vResult[sProp].push(vContent);
        } else {
          vResult[sProp] = vContent;
          nLength++;
        }
      }
      if (bAttributes) {
        var nAttrLen = oParentNode.attributes.length, sAPrefix = bNesteAttr ? "" : sAttrPref, oAttrParent = bNesteAttr ? {} : vResult;
        for (var oAttrib, nAttrib = 0; nAttrib < nAttrLen; nLength++, nAttrib++) {
          oAttrib = oParentNode.attributes.item(nAttrib);
          oAttrParent[sAPrefix + oAttrib.name.toLowerCase()] = parseText(oAttrib.value.trim());
        }
        if (bNesteAttr) {
          if (bFreeze) {
            Object.freeze(oAttrParent);
          }
          vResult[sAttributesProp] = oAttrParent;
          nLength -= nAttrLen - 1;
        }
      }
      if (nVerb === 3 || (nVerb === 2 || nVerb === 1 && nLength > 0) && sCollectedTxt) {
        vResult[sValueProp] = vBuiltVal;
      } else if (!bHighVerb && nLength === 0 && sCollectedTxt) {
        vResult = vBuiltVal;
      }
      if (bFreeze && (bHighVerb || nLength > 0)) {
        Object.freeze(vResult);
      }
      aCache.length = nLevelStart;
      return vResult;
    }
    function loadObjTree(oXMLDoc, oParentEl, oParentObj) {
      var vValue, oChild;
      if (oParentObj instanceof String || oParentObj instanceof Number || oParentObj instanceof Boolean) {
        oParentEl.appendChild(oXMLDoc.createTextNode(oParentObj.toString()));
      } else if (oParentObj.constructor === Date) {
        oParentEl.appendChild(oXMLDoc.createTextNode(oParentObj.toGMTString()));
      }
      for (var sName in oParentObj) {
        vValue = oParentObj[sName];
        if (isFinite(sName) || vValue instanceof Function) {
          continue;
        }
        if (sName === sValueProp) {
          if (vValue !== null && vValue !== true) {
            oParentEl.appendChild(oXMLDoc.createTextNode(vValue.constructor === Date ? vValue.toGMTString() : String(vValue)));
          }
        } else if (sName === sAttributesProp) {
          for (var sAttrib in vValue) {
            oParentEl.setAttribute(sAttrib, vValue[sAttrib]);
          }
        } else if (sName.charAt(0) === sAttrPref) {
          oParentEl.setAttribute(sName.slice(1), vValue);
        } else if (vValue.constructor === Array) {
          for (var nItem = 0; nItem < vValue.length; nItem++) {
            oChild = oXMLDoc.createElement(sName);
            loadObjTree(oXMLDoc, oChild, vValue[nItem]);
            oParentEl.appendChild(oChild);
          }
        } else {
          oChild = oXMLDoc.createElement(sName);
          if (vValue instanceof Object) {
            loadObjTree(oXMLDoc, oChild, vValue);
          } else if (vValue !== null && vValue !== true) {
            oChild.appendChild(oXMLDoc.createTextNode(vValue.toString()));
          }
          oParentEl.appendChild(oChild);
        }
      }
    }
    this.build = function(oXMLParent, nVerbosity, bFreeze, bNesteAttributes) {
      var _nVerb = arguments.length > 1 && typeof nVerbosity === "number" ? nVerbosity & 3 : (
        /* put here the default verbosity level: */
        1
      );
      return createObjTree(oXMLParent, _nVerb, bFreeze || false, arguments.length > 3 ? bNesteAttributes : _nVerb === 3);
    };
    this.unbuild = function(oObjTree) {
      var oNewDoc = document.implementation.createDocument("", "", null);
      loadObjTree(oNewDoc, oNewDoc, oObjTree);
      return oNewDoc;
    };
    this.stringify = function(oObjTree) {
      return new XMLSerializer().serializeToString(JXON.unbuild(oObjTree));
    };
  }();

  // modules/ui/sections/changes.js
  function uiSectionChanges(context) {
    var _discardTags = {};
    _mainFileFetcher.get("discarded").then(function(d2) {
      _discardTags = d2;
    }).catch(function() {
    });
    var section = uiSection("changes-list", context).label(function() {
      var history = context.history();
      var summary = history.difference().summary();
      return _t.append("inspector.title_count", { title: _t("commit.changes"), count: summary.length });
    }).disclosureContent(renderDisclosureContent);
    function renderDisclosureContent(selection2) {
      var history = context.history();
      var summary = history.difference().summary();
      var container = selection2.selectAll(".commit-section").data([0]);
      var containerEnter = container.enter().append("div").attr("class", "commit-section");
      containerEnter.append("ul").attr("class", "changeset-list");
      container = containerEnter.merge(container);
      var items = container.select("ul").selectAll("li").data(summary);
      var itemsEnter = items.enter().append("li").attr("class", "change-item");
      var buttons = itemsEnter.append("button").on("mouseover", mouseover).on("mouseout", mouseout).on("click", click);
      buttons.each(function(d2) {
        select_default2(this).call(svgIcon("#iD-icon-" + d2.entity.geometry(d2.graph), "pre-text " + d2.changeType));
      });
      buttons.append("span").attr("class", "change-type").html(function(d2) {
        return _t.html("commit." + d2.changeType) + " ";
      });
      buttons.append("strong").attr("class", "entity-type").text(function(d2) {
        var matched = _mainPresetIndex.match(d2.entity, d2.graph);
        return matched && matched.name() || utilDisplayType(d2.entity.id);
      });
      buttons.append("span").attr("class", "entity-name").text(function(d2) {
        var name = utilDisplayName(d2.entity) || "", string = "";
        if (name !== "") {
          string += ":";
        }
        return string += " " + name;
      });
      items = itemsEnter.merge(items);
      var changeset = new osmChangeset().update({ id: void 0 });
      var changes = history.changes(actionDiscardTags(history.difference(), _discardTags));
      delete changeset.id;
      var data = JXON.stringify(changeset.osmChangeJXON(changes));
      var blob = new Blob([data], { type: "text/xml;charset=utf-8;" });
      var fileName = "changes.osc";
      var linkEnter = container.selectAll(".download-changes").data([0]).enter().append("a").attr("class", "download-changes");
      linkEnter.attr("href", window.URL.createObjectURL(blob)).attr("download", fileName);
      linkEnter.call(svgIcon("#iD-icon-load", "inline")).append("span").call(_t.append("commit.download_changes"));
      function mouseover(d2) {
        if (d2.entity) {
          context.surface().selectAll(
            utilEntityOrMemberSelector([d2.entity.id], context.graph())
          ).classed("hover", true);
        }
      }
      function mouseout() {
        context.surface().selectAll(".hover").classed("hover", false);
      }
      function click(d3_event, change) {
        if (change.changeType !== "deleted") {
          var entity = change.entity;
          context.map().zoomToEase(entity);
          context.surface().selectAll(utilEntityOrMemberSelector([entity.id], context.graph())).classed("hover", true);
        }
      }
    }
    return section;
  }

  // modules/ui/commit_warnings.js
  function uiCommitWarnings(context) {
    function commitWarnings(selection2) {
      var issuesBySeverity = context.validator().getIssuesBySeverity({ what: "edited", where: "all", includeDisabledRules: true });
      for (var severity in issuesBySeverity) {
        var issues = issuesBySeverity[severity];
        if (severity !== "error") {
          issues = issues.filter(function(issue) {
            return issue.type !== "help_request";
          });
        }
        var section = severity + "-section";
        var issueItem = severity + "-item";
        var container = selection2.selectAll("." + section).data(issues.length ? [0] : []);
        container.exit().remove();
        var containerEnter = container.enter().append("div").attr("class", "modal-section " + section + " fillL2");
        containerEnter.append("h3").call(severity === "warning" ? _t.append("commit.warnings") : _t.append("commit.errors"));
        containerEnter.append("ul").attr("class", "changeset-list");
        container = containerEnter.merge(container);
        var items = container.select("ul").selectAll("li").data(issues, function(d2) {
          return d2.key;
        });
        items.exit().remove();
        var itemsEnter = items.enter().append("li").attr("class", issueItem);
        var buttons = itemsEnter.append("button").on("mouseover", function(d3_event, d2) {
          if (d2.entityIds) {
            context.surface().selectAll(
              utilEntityOrMemberSelector(
                d2.entityIds,
                context.graph()
              )
            ).classed("hover", true);
          }
        }).on("mouseout", function() {
          context.surface().selectAll(".hover").classed("hover", false);
        }).on("click", function(d3_event, d2) {
          context.validator().focusIssue(d2);
        });
        buttons.call(svgIcon("#iD-icon-alert", "pre-text"));
        buttons.append("strong").attr("class", "issue-message");
        buttons.filter(function(d2) {
          return d2.tooltip;
        }).call(
          uiTooltip().title(function(d2) {
            return d2.tooltip;
          }).placement("top")
        );
        items = itemsEnter.merge(items);
        items.selectAll(".issue-message").text("").each(function(d2) {
          return d2.message(context)(select_default2(this));
        });
      }
    }
    return commitWarnings;
  }

  // modules/ui/commit.js
  var readOnlyTags = [
    /^changesets_count$/,
    /^created_by$/,
    /^ideditor:/,
    /^imagery_used$/,
    /^host$/,
    /^locale$/,
    /^warnings:/,
    /^resolved:/,
    /^closed:note$/,
    /^closed:keepright$/,
    /^closed:improveosm:/,
    /^closed:osmose:/
  ];
  var hashtagRegex = /(#[^\u2000-\u206F\u2E00-\u2E7F\s\\'!"#$%()*,.\/:;<=>?@\[\]^`{|}~]+)/g;
  function uiCommit(context) {
    var dispatch14 = dispatch_default("cancel");
    var _userDetails2;
    var _selection;
    var changesetEditor = uiChangesetEditor(context).on("change", changeTags);
    var rawTagEditor = uiSectionRawTagEditor("changeset-tag-editor", context).on("change", changeTags).readOnlyTags(readOnlyTags);
    var commitChanges = uiSectionChanges(context);
    var commitWarnings = uiCommitWarnings(context);
    function commit(selection2) {
      _selection = selection2;
      if (!context.changeset)
        initChangeset();
      loadDerivedChangesetTags();
      selection2.call(render);
    }
    function initChangeset() {
      var commentDate = +corePreferences("commentDate") || 0;
      var currDate = Date.now();
      var cutoff = 2 * 86400 * 1e3;
      if (commentDate > currDate || currDate - commentDate > cutoff) {
        corePreferences("comment", null);
        corePreferences("hashtags", null);
        corePreferences("source", null);
      }
      if (context.defaultChangesetComment()) {
        corePreferences("comment", context.defaultChangesetComment());
        corePreferences("commentDate", Date.now());
      }
      if (context.defaultChangesetSource()) {
        corePreferences("source", context.defaultChangesetSource());
        corePreferences("commentDate", Date.now());
      }
      if (context.defaultChangesetHashtags()) {
        corePreferences("hashtags", context.defaultChangesetHashtags());
        corePreferences("commentDate", Date.now());
      }
      var detected = utilDetect();
      var tags = {
        comment: corePreferences("comment") || "",
        created_by: context.cleanTagValue("iD " + context.version),
        host: context.cleanTagValue(detected.host),
        locale: context.cleanTagValue(_mainLocalizer.localeCode())
      };
      findHashtags(tags, true);
      var hashtags = corePreferences("hashtags");
      if (hashtags) {
        tags.hashtags = hashtags;
      }
      var source = corePreferences("source");
      if (source) {
        tags.source = source;
      }
      var photoOverlaysUsed = context.history().photoOverlaysUsed();
      if (photoOverlaysUsed.length) {
        var sources = (tags.source || "").split(";");
        if (sources.indexOf("streetlevel imagery") === -1) {
          sources.push("streetlevel imagery");
        }
        photoOverlaysUsed.forEach(function(photoOverlay) {
          if (sources.indexOf(photoOverlay) === -1) {
            sources.push(photoOverlay);
          }
        });
        tags.source = context.cleanTagValue(sources.join(";"));
      }
      context.changeset = new osmChangeset({ tags });
    }
    function loadDerivedChangesetTags() {
      var osm = context.connection();
      if (!osm)
        return;
      var tags = Object.assign({}, context.changeset.tags);
      var imageryUsed = context.cleanTagValue(context.history().imageryUsed().join(";"));
      tags.imagery_used = imageryUsed || "None";
      var osmClosed = osm.getClosedIDs();
      var itemType;
      if (osmClosed.length) {
        tags["closed:note"] = context.cleanTagValue(osmClosed.join(";"));
      }
      if (services.keepRight) {
        var krClosed = services.keepRight.getClosedIDs();
        if (krClosed.length) {
          tags["closed:keepright"] = context.cleanTagValue(krClosed.join(";"));
        }
      }
      if (services.improveOSM) {
        var iOsmClosed = services.improveOSM.getClosedCounts();
        for (itemType in iOsmClosed) {
          tags["closed:improveosm:" + itemType] = context.cleanTagValue(iOsmClosed[itemType].toString());
        }
      }
      if (services.osmose) {
        var osmoseClosed = services.osmose.getClosedCounts();
        for (itemType in osmoseClosed) {
          tags["closed:osmose:" + itemType] = context.cleanTagValue(osmoseClosed[itemType].toString());
        }
      }
      for (var key in tags) {
        if (key.match(/(^warnings:)|(^resolved:)/)) {
          delete tags[key];
        }
      }
      function addIssueCounts(issues, prefix) {
        var issuesByType = utilArrayGroupBy(issues, "type");
        for (var issueType in issuesByType) {
          var issuesOfType = issuesByType[issueType];
          if (issuesOfType[0].subtype) {
            var issuesBySubtype = utilArrayGroupBy(issuesOfType, "subtype");
            for (var issueSubtype in issuesBySubtype) {
              var issuesOfSubtype = issuesBySubtype[issueSubtype];
              tags[prefix + ":" + issueType + ":" + issueSubtype] = context.cleanTagValue(issuesOfSubtype.length.toString());
            }
          } else {
            tags[prefix + ":" + issueType] = context.cleanTagValue(issuesOfType.length.toString());
          }
        }
      }
      var warnings = context.validator().getIssuesBySeverity({ what: "edited", where: "all", includeIgnored: true, includeDisabledRules: true }).warning.filter(function(issue) {
        return issue.type !== "help_request";
      });
      addIssueCounts(warnings, "warnings");
      var resolvedIssues = context.validator().getResolvedIssues();
      addIssueCounts(resolvedIssues, "resolved");
      context.changeset = context.changeset.update({ tags });
    }
    function render(selection2) {
      var osm = context.connection();
      if (!osm)
        return;
      var header = selection2.selectAll(".header").data([0]);
      var headerTitle = header.enter().append("div").attr("class", "header fillL");
      headerTitle.append("div").append("h2").call(_t.append("commit.title"));
      headerTitle.append("button").attr("class", "close").attr("title", _t("icons.close")).on("click", function() {
        dispatch14.call("cancel", this);
      }).call(svgIcon("#iD-icon-close"));
      var body = selection2.selectAll(".body").data([0]);
      body = body.enter().append("div").attr("class", "body").merge(body);
      var changesetSection = body.selectAll(".changeset-editor").data([0]);
      changesetSection = changesetSection.enter().append("div").attr("class", "modal-section changeset-editor").merge(changesetSection);
      changesetSection.call(
        changesetEditor.changesetID(context.changeset.id).tags(context.changeset.tags)
      );
      body.call(commitWarnings);
      var saveSection = body.selectAll(".save-section").data([0]);
      saveSection = saveSection.enter().append("div").attr("class", "modal-section save-section fillL").merge(saveSection);
      var prose = saveSection.selectAll(".commit-info").data([0]);
      if (prose.enter().size()) {
        _userDetails2 = null;
      }
      prose = prose.enter().append("p").attr("class", "commit-info").call(_t.append("commit.upload_explanation")).merge(prose);
      osm.userDetails(function(err, user) {
        if (err)
          return;
        if (_userDetails2 === user)
          return;
        _userDetails2 = user;
        var userLink = select_default2(document.createElement("div"));
        if (user.image_url) {
          userLink.append("img").attr("src", user.image_url).attr("class", "icon pre-text user-icon");
        }
        userLink.append("a").attr("class", "user-info").text(user.display_name).attr("href", osm.userURL(user.display_name)).attr("target", "_blank");
        prose.html(_t.html("commit.upload_explanation_with_user", { user: { html: userLink.html() } }));
      });
      var requestReview = saveSection.selectAll(".request-review").data([0]);
      var requestReviewEnter = requestReview.enter().append("div").attr("class", "request-review");
      var requestReviewDomId = utilUniqueDomId("commit-input-request-review");
      var labelEnter = requestReviewEnter.append("label").attr("for", requestReviewDomId);
      if (!labelEnter.empty()) {
        labelEnter.call(uiTooltip().title(() => _t.append("commit.request_review_info")).placement("top"));
      }
      labelEnter.append("input").attr("type", "checkbox").attr("id", requestReviewDomId);
      labelEnter.append("span").call(_t.append("commit.request_review"));
      requestReview = requestReview.merge(requestReviewEnter);
      var requestReviewInput = requestReview.selectAll("input").property("checked", isReviewRequested(context.changeset.tags)).on("change", toggleRequestReview);
      var buttonSection = saveSection.selectAll(".buttons").data([0]);
      var buttonEnter = buttonSection.enter().append("div").attr("class", "buttons fillL");
      buttonEnter.append("button").attr("class", "secondary-action button cancel-button").append("span").attr("class", "label").call(_t.append("commit.cancel"));
      var uploadButton = buttonEnter.append("button").attr("class", "action button save-button");
      uploadButton.append("span").attr("class", "label").call(_t.append("commit.save"));
      var uploadBlockerTooltipText = getUploadBlockerMessage();
      buttonSection = buttonSection.merge(buttonEnter);
      buttonSection.selectAll(".cancel-button").on("click.cancel", function() {
        dispatch14.call("cancel", this);
      });
      buttonSection.selectAll(".save-button").classed("disabled", uploadBlockerTooltipText !== null).on("click.save", function() {
        if (!select_default2(this).classed("disabled")) {
          this.blur();
          for (var key in context.changeset.tags) {
            if (!key)
              delete context.changeset.tags[key];
          }
          context.uploader().save(context.changeset);
        }
      });
      uiTooltip().destroyAny(buttonSection.selectAll(".save-button"));
      if (uploadBlockerTooltipText) {
        buttonSection.selectAll(".save-button").call(uiTooltip().title(() => uploadBlockerTooltipText).placement("top"));
      }
      var tagSection = body.selectAll(".tag-section.raw-tag-editor").data([0]);
      tagSection = tagSection.enter().append("div").attr("class", "modal-section tag-section raw-tag-editor").merge(tagSection);
      tagSection.call(
        rawTagEditor.tags(Object.assign({}, context.changeset.tags)).render
      );
      var changesSection = body.selectAll(".commit-changes-section").data([0]);
      changesSection = changesSection.enter().append("div").attr("class", "modal-section commit-changes-section").merge(changesSection);
      changesSection.call(commitChanges.render);
      function toggleRequestReview() {
        var rr = requestReviewInput.property("checked");
        updateChangeset({ review_requested: rr ? "yes" : void 0 });
        tagSection.call(
          rawTagEditor.tags(Object.assign({}, context.changeset.tags)).render
        );
      }
    }
    function getUploadBlockerMessage() {
      var errors = context.validator().getIssuesBySeverity({ what: "edited", where: "all" }).error;
      if (errors.length) {
        return _t.append("commit.outstanding_errors_message", { count: errors.length });
      } else {
        var hasChangesetComment = context.changeset && context.changeset.tags.comment && context.changeset.tags.comment.trim().length;
        if (!hasChangesetComment) {
          return _t.append("commit.comment_needed_message");
        }
      }
      return null;
    }
    function changeTags(_2, changed, onInput) {
      if (changed.hasOwnProperty("comment")) {
        if (changed.comment === void 0) {
          changed.comment = "";
        }
        if (!onInput) {
          corePreferences("comment", changed.comment);
          corePreferences("commentDate", Date.now());
        }
      }
      if (changed.hasOwnProperty("source")) {
        if (changed.source === void 0) {
          corePreferences("source", null);
        } else if (!onInput) {
          corePreferences("source", changed.source);
          corePreferences("commentDate", Date.now());
        }
      }
      updateChangeset(changed, onInput);
      if (_selection) {
        _selection.call(render);
      }
    }
    function findHashtags(tags, commentOnly) {
      var detectedHashtags = commentHashtags();
      if (detectedHashtags.length) {
        corePreferences("hashtags", null);
      }
      if (!detectedHashtags.length || !commentOnly) {
        detectedHashtags = detectedHashtags.concat(hashtagHashtags());
      }
      var allLowerCase = /* @__PURE__ */ new Set();
      return detectedHashtags.filter(function(hashtag) {
        var lowerCase = hashtag.toLowerCase();
        if (!allLowerCase.has(lowerCase)) {
          allLowerCase.add(lowerCase);
          return true;
        }
        return false;
      });
      function commentHashtags() {
        var matches = (tags.comment || "").replace(/http\S*/g, "").match(hashtagRegex);
        return matches || [];
      }
      function hashtagHashtags() {
        var matches = (tags.hashtags || "").split(/[,;\s]+/).map(function(s2) {
          if (s2[0] !== "#") {
            s2 = "#" + s2;
          }
          var matched = s2.match(hashtagRegex);
          return matched && matched[0];
        }).filter(Boolean);
        return matches || [];
      }
    }
    function isReviewRequested(tags) {
      var rr = tags.review_requested;
      if (rr === void 0)
        return false;
      rr = rr.trim().toLowerCase();
      return !(rr === "" || rr === "no");
    }
    function updateChangeset(changed, onInput) {
      var tags = Object.assign({}, context.changeset.tags);
      Object.keys(changed).forEach(function(k2) {
        var v2 = changed[k2];
        k2 = context.cleanTagKey(k2);
        if (readOnlyTags.indexOf(k2) !== -1)
          return;
        if (v2 === void 0) {
          delete tags[k2];
        } else if (onInput) {
          tags[k2] = v2;
        } else {
          tags[k2] = context.cleanTagValue(v2);
        }
      });
      if (!onInput) {
        var commentOnly = changed.hasOwnProperty("comment") && changed.comment !== "";
        var arr = findHashtags(tags, commentOnly);
        if (arr.length) {
          tags.hashtags = context.cleanTagValue(arr.join(";"));
          corePreferences("hashtags", tags.hashtags);
        } else {
          delete tags.hashtags;
          corePreferences("hashtags", null);
        }
      }
      if (_userDetails2 && _userDetails2.changesets_count !== void 0) {
        var changesetsCount = parseInt(_userDetails2.changesets_count, 10) + 1;
        tags.changesets_count = String(changesetsCount);
        if (changesetsCount <= 100) {
          var s2;
          s2 = corePreferences("walkthrough_completed");
          if (s2) {
            tags["ideditor:walkthrough_completed"] = s2;
          }
          s2 = corePreferences("walkthrough_progress");
          if (s2) {
            tags["ideditor:walkthrough_progress"] = s2;
          }
          s2 = corePreferences("walkthrough_started");
          if (s2) {
            tags["ideditor:walkthrough_started"] = s2;
          }
        }
      } else {
        delete tags.changesets_count;
      }
      if (!(0, import_fast_deep_equal9.default)(context.changeset.tags, tags)) {
        context.changeset = context.changeset.update({ tags });
      }
    }
    commit.reset = function() {
      context.changeset = null;
    };
    return utilRebind(commit, dispatch14, "on");
  }

  // modules/ui/confirm.js
  function uiConfirm(selection2) {
    var modalSelection = uiModal(selection2);
    modalSelection.select(".modal").classed("modal-alert", true);
    var section = modalSelection.select(".content");
    section.append("div").attr("class", "modal-section header");
    section.append("div").attr("class", "modal-section message-text");
    var buttons = section.append("div").attr("class", "modal-section buttons cf");
    modalSelection.okButton = function() {
      buttons.append("button").attr("class", "button ok-button action").on("click.confirm", function() {
        modalSelection.remove();
      }).call(_t.append("confirm.okay")).node().focus();
      return modalSelection;
    };
    return modalSelection;
  }

  // modules/ui/conflicts.js
  function uiConflicts(context) {
    var dispatch14 = dispatch_default("cancel", "save");
    var keybinding = utilKeybinding("conflicts");
    var _origChanges;
    var _conflictList;
    var _shownConflictIndex;
    function keybindingOn() {
      select_default2(document).call(keybinding.on("\u238B", cancel, true));
    }
    function keybindingOff() {
      select_default2(document).call(keybinding.unbind);
    }
    function tryAgain() {
      keybindingOff();
      dispatch14.call("save");
    }
    function cancel() {
      keybindingOff();
      dispatch14.call("cancel");
    }
    function conflicts(selection2) {
      keybindingOn();
      var headerEnter = selection2.selectAll(".header").data([0]).enter().append("div").attr("class", "header fillL");
      headerEnter.append("button").attr("class", "fr").attr("title", _t("icons.close")).on("click", cancel).call(svgIcon("#iD-icon-close"));
      headerEnter.append("h2").call(_t.append("save.conflict.header"));
      var bodyEnter = selection2.selectAll(".body").data([0]).enter().append("div").attr("class", "body fillL");
      var conflictsHelpEnter = bodyEnter.append("div").attr("class", "conflicts-help").call(_t.append("save.conflict.help"));
      var changeset = new osmChangeset();
      delete changeset.id;
      var data = JXON.stringify(changeset.osmChangeJXON(_origChanges));
      var blob = new Blob([data], { type: "text/xml;charset=utf-8;" });
      var fileName = "changes.osc";
      var linkEnter = conflictsHelpEnter.selectAll(".download-changes").append("a").attr("class", "download-changes");
      linkEnter.attr("href", window.URL.createObjectURL(blob)).attr("download", fileName);
      linkEnter.call(svgIcon("#iD-icon-load", "inline")).append("span").call(_t.append("save.conflict.download_changes"));
      bodyEnter.append("div").attr("class", "conflict-container fillL3").call(showConflict, 0);
      bodyEnter.append("div").attr("class", "conflicts-done").attr("opacity", 0).style("display", "none").call(_t.append("save.conflict.done"));
      var buttonsEnter = bodyEnter.append("div").attr("class", "buttons col12 joined conflicts-buttons");
      buttonsEnter.append("button").attr("disabled", _conflictList.length > 1).attr("class", "action conflicts-button col6").call(_t.append("save.title")).on("click.try_again", tryAgain);
      buttonsEnter.append("button").attr("class", "secondary-action conflicts-button col6").call(_t.append("confirm.cancel")).on("click.cancel", cancel);
    }
    function showConflict(selection2, index) {
      index = utilWrap(index, _conflictList.length);
      _shownConflictIndex = index;
      var parent = select_default2(selection2.node().parentNode);
      if (index === _conflictList.length - 1) {
        window.setTimeout(function() {
          parent.select(".conflicts-button").attr("disabled", null);
          parent.select(".conflicts-done").transition().attr("opacity", 1).style("display", "block");
        }, 250);
      }
      var conflict = selection2.selectAll(".conflict").data([_conflictList[index]]);
      conflict.exit().remove();
      var conflictEnter = conflict.enter().append("div").attr("class", "conflict");
      conflictEnter.append("h4").attr("class", "conflict-count").call(_t.append("save.conflict.count", { num: index + 1, total: _conflictList.length }));
      conflictEnter.append("a").attr("class", "conflict-description").attr("href", "#").text(function(d2) {
        return d2.name;
      }).on("click", function(d3_event, d2) {
        d3_event.preventDefault();
        zoomToEntity(d2.id);
      });
      var details = conflictEnter.append("div").attr("class", "conflict-detail-container");
      details.append("ul").attr("class", "conflict-detail-list").selectAll("li").data(function(d2) {
        return d2.details || [];
      }).enter().append("li").attr("class", "conflict-detail-item").html(function(d2) {
        return d2;
      });
      details.append("div").attr("class", "conflict-choices").call(addChoices);
      details.append("div").attr("class", "conflict-nav-buttons joined cf").selectAll("button").data(["previous", "next"]).enter().append("button").attr("class", "conflict-nav-button action col6").attr("disabled", function(d2, i3) {
        return i3 === 0 && index === 0 || i3 === 1 && index === _conflictList.length - 1 || null;
      }).on("click", function(d3_event, d2) {
        d3_event.preventDefault();
        var container = parent.selectAll(".conflict-container");
        var sign2 = d2 === "previous" ? -1 : 1;
        container.selectAll(".conflict").remove();
        container.call(showConflict, index + sign2);
      }).each(function(d2) {
        _t.append("save.conflict." + d2)(select_default2(this));
      });
    }
    function addChoices(selection2) {
      var choices = selection2.append("ul").attr("class", "layer-list").selectAll("li").data(function(d2) {
        return d2.choices || [];
      });
      var choicesEnter = choices.enter().append("li").attr("class", "layer");
      var labelEnter = choicesEnter.append("label");
      labelEnter.append("input").attr("type", "radio").attr("name", function(d2) {
        return d2.id;
      }).on("change", function(d3_event, d2) {
        var ul = this.parentNode.parentNode.parentNode;
        ul.__data__.chosen = d2.id;
        choose(d3_event, ul, d2);
      });
      labelEnter.append("span").text(function(d2) {
        return d2.text;
      });
      choicesEnter.merge(choices).each(function(d2) {
        var ul = this.parentNode;
        if (ul.__data__.chosen === d2.id) {
          choose(null, ul, d2);
        }
      });
    }
    function choose(d3_event, ul, datum2) {
      if (d3_event)
        d3_event.preventDefault();
      select_default2(ul).selectAll("li").classed("active", function(d2) {
        return d2 === datum2;
      }).selectAll("input").property("checked", function(d2) {
        return d2 === datum2;
      });
      var extent = geoExtent();
      var entity;
      entity = context.graph().hasEntity(datum2.id);
      if (entity)
        extent._extend(entity.extent(context.graph()));
      datum2.action();
      entity = context.graph().hasEntity(datum2.id);
      if (entity)
        extent._extend(entity.extent(context.graph()));
      zoomToEntity(datum2.id, extent);
    }
    function zoomToEntity(id2, extent) {
      context.surface().selectAll(".hover").classed("hover", false);
      var entity = context.graph().hasEntity(id2);
      if (entity) {
        if (extent) {
          context.map().trimmedExtent(extent);
        } else {
          context.map().zoomToEase(entity);
        }
        context.surface().selectAll(utilEntityOrMemberSelector([entity.id], context.graph())).classed("hover", true);
      }
    }
    conflicts.conflictList = function(_2) {
      if (!arguments.length)
        return _conflictList;
      _conflictList = _2;
      return conflicts;
    };
    conflicts.origChanges = function(_2) {
      if (!arguments.length)
        return _origChanges;
      _origChanges = _2;
      return conflicts;
    };
    conflicts.shownEntityIds = function() {
      if (_conflictList && typeof _shownConflictIndex === "number") {
        return [_conflictList[_shownConflictIndex].id];
      }
      return [];
    };
    return utilRebind(conflicts, dispatch14, "on");
  }

  // modules/ui/entity_editor.js
  var import_fast_deep_equal10 = __toESM(require_fast_deep_equal());

  // modules/ui/sections/entity_issues.js
  function uiSectionEntityIssues(context) {
    var preference = corePreferences("entity-issues.reference.expanded");
    var _expanded = preference === null ? true : preference === "true";
    var _entityIDs = [];
    var _issues = [];
    var _activeIssueID;
    var section = uiSection("entity-issues", context).shouldDisplay(function() {
      return _issues.length > 0;
    }).label(function() {
      return _t.append("inspector.title_count", { title: _t("issues.list_title"), count: _issues.length });
    }).disclosureContent(renderDisclosureContent);
    context.validator().on("validated.entity_issues", function() {
      reloadIssues();
      section.reRender();
    }).on("focusedIssue.entity_issues", function(issue) {
      makeActiveIssue(issue.id);
    });
    function reloadIssues() {
      _issues = context.validator().getSharedEntityIssues(_entityIDs, { includeDisabledRules: true });
    }
    function makeActiveIssue(issueID) {
      _activeIssueID = issueID;
      section.selection().selectAll(".issue-container").classed("active", function(d2) {
        return d2.id === _activeIssueID;
      });
    }
    function renderDisclosureContent(selection2) {
      selection2.classed("grouped-items-area", true);
      _activeIssueID = _issues.length > 0 ? _issues[0].id : null;
      var containers = selection2.selectAll(".issue-container").data(_issues, function(d2) {
        return d2.key;
      });
      containers.exit().remove();
      var containersEnter = containers.enter().append("div").attr("class", "issue-container");
      var itemsEnter = containersEnter.append("div").attr("class", function(d2) {
        return "issue severity-" + d2.severity;
      }).on("mouseover.highlight", function(d3_event, d2) {
        var ids = d2.entityIds.filter(function(e3) {
          return _entityIDs.indexOf(e3) === -1;
        });
        utilHighlightEntities(ids, true, context);
      }).on("mouseout.highlight", function(d3_event, d2) {
        var ids = d2.entityIds.filter(function(e3) {
          return _entityIDs.indexOf(e3) === -1;
        });
        utilHighlightEntities(ids, false, context);
      });
      var labelsEnter = itemsEnter.append("div").attr("class", "issue-label");
      var textEnter = labelsEnter.append("button").attr("class", "issue-text").on("click", function(d3_event, d2) {
        makeActiveIssue(d2.id);
        var extent = d2.extent(context.graph());
        if (extent) {
          var setZoom = Math.max(context.map().zoom(), 19);
          context.map().unobscuredCenterZoomEase(extent.center(), setZoom);
        }
      });
      textEnter.each(function(d2) {
        var iconName = "#iD-icon-" + (d2.severity === "warning" ? "alert" : "error");
        select_default2(this).call(svgIcon(iconName, "issue-icon"));
      });
      textEnter.append("span").attr("class", "issue-message");
      var infoButton = labelsEnter.append("button").attr("class", "issue-info-button").attr("title", _t("icons.information")).call(svgIcon("#iD-icon-inspect"));
      infoButton.on("click", function(d3_event) {
        d3_event.stopPropagation();
        d3_event.preventDefault();
        this.blur();
        var container = select_default2(this.parentNode.parentNode.parentNode);
        var info = container.selectAll(".issue-info");
        var isExpanded = info.classed("expanded");
        _expanded = !isExpanded;
        corePreferences("entity-issues.reference.expanded", _expanded);
        if (isExpanded) {
          info.transition().duration(200).style("max-height", "0px").style("opacity", "0").on("end", function() {
            info.classed("expanded", false);
          });
        } else {
          info.classed("expanded", true).transition().duration(200).style("max-height", "200px").style("opacity", "1").on("end", function() {
            info.style("max-height", null);
          });
        }
      });
      itemsEnter.append("ul").attr("class", "issue-fix-list");
      containersEnter.append("div").attr("class", "issue-info" + (_expanded ? " expanded" : "")).style("max-height", _expanded ? null : "0").style("opacity", _expanded ? "1" : "0").each(function(d2) {
        if (typeof d2.reference === "function") {
          select_default2(this).call(d2.reference);
        } else {
          select_default2(this).call(_t.append("inspector.no_documentation_key"));
        }
      });
      containers = containers.merge(containersEnter).classed("active", function(d2) {
        return d2.id === _activeIssueID;
      });
      containers.selectAll(".issue-message").text("").each(function(d2) {
        return d2.message(context)(select_default2(this));
      });
      var fixLists = containers.selectAll(".issue-fix-list");
      var fixes = fixLists.selectAll(".issue-fix-item").data(function(d2) {
        return d2.fixes ? d2.fixes(context) : [];
      }, function(fix) {
        return fix.id;
      });
      fixes.exit().remove();
      var fixesEnter = fixes.enter().append("li").attr("class", "issue-fix-item");
      var buttons = fixesEnter.append("button").on("click", function(d3_event, d2) {
        if (select_default2(this).attr("disabled") || !d2.onClick)
          return;
        if (d2.issue.dateLastRanFix && /* @__PURE__ */ new Date() - d2.issue.dateLastRanFix < 1e3)
          return;
        d2.issue.dateLastRanFix = /* @__PURE__ */ new Date();
        utilHighlightEntities(d2.issue.entityIds.concat(d2.entityIds), false, context);
        new Promise(function(resolve, reject) {
          d2.onClick(context, resolve, reject);
          if (d2.onClick.length <= 1) {
            resolve();
          }
        }).then(function() {
          context.validator().validate();
        });
      }).on("mouseover.highlight", function(d3_event, d2) {
        utilHighlightEntities(d2.entityIds, true, context);
      }).on("mouseout.highlight", function(d3_event, d2) {
        utilHighlightEntities(d2.entityIds, false, context);
      });
      buttons.each(function(d2) {
        var iconName = d2.icon || "iD-icon-wrench";
        if (iconName.startsWith("maki")) {
          iconName += "-15";
        }
        select_default2(this).call(svgIcon("#" + iconName, "fix-icon"));
      });
      buttons.append("span").attr("class", "fix-message").each(function(d2) {
        return d2.title(select_default2(this));
      });
      fixesEnter.merge(fixes).selectAll("button").classed("actionable", function(d2) {
        return d2.onClick;
      }).attr("disabled", function(d2) {
        return d2.onClick ? null : "true";
      }).attr("title", function(d2) {
        if (d2.disabledReason) {
          return d2.disabledReason;
        }
        return null;
      });
    }
    section.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      if (!_entityIDs || !val || !utilArrayIdentical(_entityIDs, val)) {
        _entityIDs = val;
        _activeIssueID = null;
        reloadIssues();
      }
      return section;
    };
    return section;
  }

  // modules/ui/preset_icon.js
  function uiPresetIcon() {
    let _preset;
    let _geometry;
    function presetIcon(selection2) {
      selection2.each(render);
    }
    function getIcon(p2, geom) {
      if (p2.isFallback && p2.isFallback())
        return geom === "vertex" ? "" : "iD-icon-" + p2.id;
      if (p2.icon)
        return p2.icon;
      if (geom === "line")
        return "iD-other-line";
      if (geom === "vertex")
        return "temaki-vertex";
      return "maki-marker-stroked";
    }
    function renderPointBorder(container, drawPoint) {
      let pointBorder = container.selectAll(".preset-icon-point-border").data(drawPoint ? [0] : []);
      pointBorder.exit().remove();
      let pointBorderEnter = pointBorder.enter();
      const w2 = 40;
      const h2 = 40;
      pointBorderEnter.append("svg").attr("class", "preset-icon-fill preset-icon-point-border").attr("width", w2).attr("height", h2).attr("viewBox", "0 0 ".concat(w2, " ").concat(h2)).append("path").attr("transform", "translate(11.5, 8)").attr("d", "M 17,8 C 17,13 11,21 8.5,23.5 C 6,21 0,13 0,8 C 0,4 4,-0.5 8.5,-0.5 C 13,-0.5 17,4 17,8 z");
      pointBorder = pointBorderEnter.merge(pointBorder);
    }
    function renderCategoryBorder(container, category) {
      let categoryBorder = container.selectAll(".preset-icon-category-border").data(category ? [0] : []);
      categoryBorder.exit().remove();
      let categoryBorderEnter = categoryBorder.enter();
      const d2 = 60;
      let svgEnter = categoryBorderEnter.append("svg").attr("class", "preset-icon-fill preset-icon-category-border").attr("width", d2).attr("height", d2).attr("viewBox", "0 0 ".concat(d2, " ").concat(d2));
      svgEnter.append("path").attr("class", "area").attr("d", "M9.5,7.5 L25.5,7.5 L28.5,12.5 L49.5,12.5 C51.709139,12.5 53.5,14.290861 53.5,16.5 L53.5,43.5 C53.5,45.709139 51.709139,47.5 49.5,47.5 L10.5,47.5 C8.290861,47.5 6.5,45.709139 6.5,43.5 L6.5,12.5 L9.5,7.5 Z");
      categoryBorder = categoryBorderEnter.merge(categoryBorder);
      if (category) {
        categoryBorder.selectAll("path").attr("class", "area ".concat(category.id));
      }
    }
    function renderCircleFill(container, drawVertex) {
      let vertexFill = container.selectAll(".preset-icon-fill-vertex").data(drawVertex ? [0] : []);
      vertexFill.exit().remove();
      let vertexFillEnter = vertexFill.enter();
      const w2 = 60;
      const h2 = 60;
      const d2 = 40;
      vertexFillEnter.append("svg").attr("class", "preset-icon-fill preset-icon-fill-vertex").attr("width", w2).attr("height", h2).attr("viewBox", "0 0 ".concat(w2, " ").concat(h2)).append("circle").attr("cx", w2 / 2).attr("cy", h2 / 2).attr("r", d2 / 2);
      vertexFill = vertexFillEnter.merge(vertexFill);
    }
    function renderSquareFill(container, drawArea, tagClasses) {
      let fill = container.selectAll(".preset-icon-fill-area").data(drawArea ? [0] : []);
      fill.exit().remove();
      let fillEnter = fill.enter();
      const d2 = 60;
      const w2 = d2;
      const h2 = d2;
      const l2 = d2 * 2 / 3;
      const c1 = (w2 - l2) / 2;
      const c2 = c1 + l2;
      fillEnter = fillEnter.append("svg").attr("class", "preset-icon-fill preset-icon-fill-area").attr("width", w2).attr("height", h2).attr("viewBox", "0 0 ".concat(w2, " ").concat(h2));
      ["fill", "stroke"].forEach((klass) => {
        fillEnter.append("path").attr("d", "M".concat(c1, " ").concat(c1, " L").concat(c1, " ").concat(c2, " L").concat(c2, " ").concat(c2, " L").concat(c2, " ").concat(c1, " Z")).attr("class", "area ".concat(klass));
      });
      const rVertex = 2.5;
      [[c1, c1], [c1, c2], [c2, c2], [c2, c1]].forEach((point2) => {
        fillEnter.append("circle").attr("class", "vertex").attr("cx", point2[0]).attr("cy", point2[1]).attr("r", rVertex);
      });
      const rMidpoint = 1.25;
      [[c1, w2 / 2], [c2, w2 / 2], [h2 / 2, c1], [h2 / 2, c2]].forEach((point2) => {
        fillEnter.append("circle").attr("class", "midpoint").attr("cx", point2[0]).attr("cy", point2[1]).attr("r", rMidpoint);
      });
      fill = fillEnter.merge(fill);
      fill.selectAll("path.stroke").attr("class", "area stroke ".concat(tagClasses));
      fill.selectAll("path.fill").attr("class", "area fill ".concat(tagClasses));
    }
    function renderLine(container, drawLine, tagClasses) {
      let line = container.selectAll(".preset-icon-line").data(drawLine ? [0] : []);
      line.exit().remove();
      let lineEnter = line.enter();
      const d2 = 60;
      const w2 = d2;
      const h2 = d2;
      const y2 = Math.round(d2 * 0.72);
      const l2 = Math.round(d2 * 0.6);
      const r2 = 2.5;
      const x12 = (w2 - l2) / 2;
      const x2 = x12 + l2;
      lineEnter = lineEnter.append("svg").attr("class", "preset-icon-line").attr("width", w2).attr("height", h2).attr("viewBox", "0 0 ".concat(w2, " ").concat(h2));
      ["casing", "stroke"].forEach((klass) => {
        lineEnter.append("path").attr("d", "M".concat(x12, " ").concat(y2, " L").concat(x2, " ").concat(y2)).attr("class", "line ".concat(klass));
      });
      [[x12 - 1, y2], [x2 + 1, y2]].forEach((point2) => {
        lineEnter.append("circle").attr("class", "vertex").attr("cx", point2[0]).attr("cy", point2[1]).attr("r", r2);
      });
      line = lineEnter.merge(line);
      line.selectAll("path.stroke").attr("class", "line stroke ".concat(tagClasses));
      line.selectAll("path.casing").attr("class", "line casing ".concat(tagClasses));
    }
    function renderRoute(container, drawRoute, p2) {
      let route = container.selectAll(".preset-icon-route").data(drawRoute ? [0] : []);
      route.exit().remove();
      let routeEnter = route.enter();
      const d2 = 60;
      const w2 = d2;
      const h2 = d2;
      const y12 = Math.round(d2 * 0.8);
      const y2 = Math.round(d2 * 0.68);
      const l2 = Math.round(d2 * 0.6);
      const r2 = 2;
      const x12 = (w2 - l2) / 2;
      const x2 = x12 + l2 / 3;
      const x3 = x2 + l2 / 3;
      const x4 = x3 + l2 / 3;
      routeEnter = routeEnter.append("svg").attr("class", "preset-icon-route").attr("width", w2).attr("height", h2).attr("viewBox", "0 0 ".concat(w2, " ").concat(h2));
      ["casing", "stroke"].forEach((klass) => {
        routeEnter.append("path").attr("d", "M".concat(x12, " ").concat(y12, " L").concat(x2, " ").concat(y2)).attr("class", "segment0 line ".concat(klass));
        routeEnter.append("path").attr("d", "M".concat(x2, " ").concat(y2, " L").concat(x3, " ").concat(y12)).attr("class", "segment1 line ".concat(klass));
        routeEnter.append("path").attr("d", "M".concat(x3, " ").concat(y12, " L").concat(x4, " ").concat(y2)).attr("class", "segment2 line ".concat(klass));
      });
      [[x12, y12], [x2, y2], [x3, y12], [x4, y2]].forEach((point2) => {
        routeEnter.append("circle").attr("class", "vertex").attr("cx", point2[0]).attr("cy", point2[1]).attr("r", r2);
      });
      route = routeEnter.merge(route);
      if (drawRoute) {
        let routeType = p2.tags.type === "waterway" ? "waterway" : p2.tags.route;
        const segmentPresetIDs = routeSegments[routeType];
        for (let i3 in segmentPresetIDs) {
          const segmentPreset = _mainPresetIndex.item(segmentPresetIDs[i3]);
          const segmentTagClasses = svgTagClasses().getClassesString(segmentPreset.tags, "");
          route.selectAll("path.stroke.segment".concat(i3)).attr("class", "segment".concat(i3, " line stroke ").concat(segmentTagClasses));
          route.selectAll("path.casing.segment".concat(i3)).attr("class", "segment".concat(i3, " line casing ").concat(segmentTagClasses));
        }
      }
    }
    function renderSvgIcon(container, picon, geom, isFramed, category, tagClasses) {
      const isMaki = picon && /^maki-/.test(picon);
      const isTemaki = picon && /^temaki-/.test(picon);
      const isFa = picon && /^fa[srb]-/.test(picon);
      const isR\u00F6ntgen = picon && /^roentgen-/.test(picon);
      const isiDIcon = picon && !(isMaki || isTemaki || isFa || isR\u00F6ntgen);
      let icon2 = container.selectAll(".preset-icon").data(picon ? [0] : []);
      icon2.exit().remove();
      icon2 = icon2.enter().append("div").attr("class", "preset-icon").call(svgIcon("")).merge(icon2);
      icon2.attr("class", "preset-icon " + (geom ? geom + "-geom" : "")).classed("category", category).classed("framed", isFramed).classed("preset-icon-iD", isiDIcon);
      icon2.selectAll("svg").attr("class", "icon " + picon + " " + (!isiDIcon && geom !== "line" ? "" : tagClasses));
      icon2.selectAll("use").attr("href", "#" + picon);
    }
    function renderImageIcon(container, imageURL) {
      let imageIcon = container.selectAll("img.image-icon").data(imageURL ? [0] : []);
      imageIcon.exit().remove();
      imageIcon = imageIcon.enter().append("img").attr("class", "image-icon").on("load", () => container.classed("showing-img", true)).on("error", () => container.classed("showing-img", false)).merge(imageIcon);
      imageIcon.attr("src", imageURL);
    }
    const routeSegments = {
      bicycle: ["highway/cycleway", "highway/cycleway", "highway/cycleway"],
      bus: ["highway/unclassified", "highway/secondary", "highway/primary"],
      trolleybus: ["highway/unclassified", "highway/secondary", "highway/primary"],
      detour: ["highway/tertiary", "highway/residential", "highway/unclassified"],
      ferry: ["route/ferry", "route/ferry", "route/ferry"],
      foot: ["highway/footway", "highway/footway", "highway/footway"],
      hiking: ["highway/path", "highway/path", "highway/path"],
      horse: ["highway/bridleway", "highway/bridleway", "highway/bridleway"],
      light_rail: ["railway/light_rail", "railway/light_rail", "railway/light_rail"],
      monorail: ["railway/monorail", "railway/monorail", "railway/monorail"],
      mtb: ["highway/path", "highway/track", "highway/bridleway"],
      pipeline: ["man_made/pipeline", "man_made/pipeline", "man_made/pipeline"],
      piste: ["piste/downhill", "piste/hike", "piste/nordic"],
      power: ["power/line", "power/line", "power/line"],
      road: ["highway/secondary", "highway/primary", "highway/trunk"],
      subway: ["railway/subway", "railway/subway", "railway/subway"],
      train: ["railway/rail", "railway/rail", "railway/rail"],
      tram: ["railway/tram", "railway/tram", "railway/tram"],
      railway: ["railway/rail", "railway/rail", "railway/rail"],
      waterway: ["waterway/stream", "waterway/stream", "waterway/stream"]
    };
    function render() {
      let p2 = _preset.apply(this, arguments);
      let geom = _geometry ? _geometry.apply(this, arguments) : null;
      if (geom === "relation" && p2.tags && (p2.tags.type === "route" && p2.tags.route && routeSegments[p2.tags.route] || p2.tags.type === "waterway")) {
        geom = "route";
      }
      const showThirdPartyIcons = corePreferences("preferences.privacy.thirdpartyicons") || "true";
      const isFallback = p2.isFallback && p2.isFallback();
      const imageURL = showThirdPartyIcons === "true" && p2.imageURL;
      const picon = getIcon(p2, geom);
      const isCategory = !p2.setTags;
      const drawPoint = false;
      const drawVertex = picon !== null && geom === "vertex";
      const drawLine = picon && geom === "line" && !isFallback && !isCategory;
      const drawArea = picon && geom === "area" && !isFallback && !isCategory;
      const drawRoute = picon && geom === "route";
      const isFramed = drawVertex || drawArea || drawLine || drawRoute || isCategory;
      let tags = !isCategory ? p2.setTags({}, geom) : {};
      for (let k2 in tags) {
        if (tags[k2] === "*") {
          tags[k2] = "yes";
        }
      }
      let tagClasses = svgTagClasses().getClassesString(tags, "");
      let selection2 = select_default2(this);
      let container = selection2.selectAll(".preset-icon-container").data([0]);
      container = container.enter().append("div").attr("class", "preset-icon-container").merge(container);
      container.classed("showing-img", !!imageURL).classed("fallback", isFallback);
      renderCategoryBorder(container, isCategory && p2);
      renderPointBorder(container, drawPoint);
      renderCircleFill(container, drawVertex);
      renderSquareFill(container, drawArea, tagClasses);
      renderLine(container, drawLine, tagClasses);
      renderRoute(container, drawRoute, p2);
      renderSvgIcon(container, picon, geom, isFramed, isCategory, tagClasses);
      renderImageIcon(container, imageURL);
    }
    presetIcon.preset = function(val) {
      if (!arguments.length)
        return _preset;
      _preset = utilFunctor(val);
      return presetIcon;
    };
    presetIcon.geometry = function(val) {
      if (!arguments.length)
        return _geometry;
      _geometry = utilFunctor(val);
      return presetIcon;
    };
    return presetIcon;
  }

  // modules/ui/sections/feature_type.js
  function uiSectionFeatureType(context) {
    var dispatch14 = dispatch_default("choose");
    var _entityIDs = [];
    var _presets = [];
    var _tagReference;
    var section = uiSection("feature-type", context).label(() => _t.append("inspector.feature_type")).disclosureContent(renderDisclosureContent);
    function renderDisclosureContent(selection2) {
      selection2.classed("preset-list-item", true);
      selection2.classed("mixed-types", _presets.length > 1);
      var presetButtonWrap = selection2.selectAll(".preset-list-button-wrap").data([0]).enter().append("div").attr("class", "preset-list-button-wrap");
      var presetButton = presetButtonWrap.append("button").attr("class", "preset-list-button preset-reset").call(
        uiTooltip().title(() => _t.append("inspector.back_tooltip")).placement("bottom")
      );
      presetButton.append("div").attr("class", "preset-icon-container");
      presetButton.append("div").attr("class", "label").append("div").attr("class", "label-inner");
      presetButtonWrap.append("div").attr("class", "accessory-buttons");
      var tagReferenceBodyWrap = selection2.selectAll(".tag-reference-body-wrap").data([0]);
      tagReferenceBodyWrap = tagReferenceBodyWrap.enter().append("div").attr("class", "tag-reference-body-wrap").merge(tagReferenceBodyWrap);
      if (_tagReference) {
        selection2.selectAll(".preset-list-button-wrap .accessory-buttons").style("display", _presets.length === 1 ? null : "none").call(_tagReference.button);
        tagReferenceBodyWrap.style("display", _presets.length === 1 ? null : "none").call(_tagReference.body);
      }
      selection2.selectAll(".preset-reset").on("click", function() {
        dispatch14.call("choose", this, _presets);
      }).on("pointerdown pointerup mousedown mouseup", function(d3_event) {
        d3_event.preventDefault();
        d3_event.stopPropagation();
      });
      var geometries = entityGeometries();
      selection2.select(".preset-list-item button").call(
        uiPresetIcon().geometry(_presets.length === 1 ? geometries.length === 1 && geometries[0] : null).preset(_presets.length === 1 ? _presets[0] : _mainPresetIndex.item("point"))
      );
      var names = _presets.length === 1 ? [
        _presets[0].nameLabel(),
        _presets[0].subtitleLabel()
      ].filter(Boolean) : [_t.append("inspector.multiple_types")];
      var label = selection2.select(".label-inner");
      var nameparts = label.selectAll(".namepart").data(names, (d2) => d2.stringId);
      nameparts.exit().remove();
      nameparts.enter().append("div").attr("class", "namepart").text("").each(function(d2) {
        d2(select_default2(this));
      });
    }
    section.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      _entityIDs = val;
      return section;
    };
    section.presets = function(val) {
      if (!arguments.length)
        return _presets;
      if (!utilArrayIdentical(val, _presets)) {
        _presets = val;
        if (_presets.length === 1) {
          _tagReference = uiTagReference(_presets[0].reference(), context).showing(false);
        }
      }
      return section;
    };
    function entityGeometries() {
      var counts = {};
      for (var i3 in _entityIDs) {
        var geometry = context.graph().geometry(_entityIDs[i3]);
        if (!counts[geometry])
          counts[geometry] = 0;
        counts[geometry] += 1;
      }
      return Object.keys(counts).sort(function(geom1, geom2) {
        return counts[geom2] - counts[geom1];
      });
    }
    return utilRebind(section, dispatch14, "on");
  }

  // modules/ui/sections/preset_fields.js
  function uiSectionPresetFields(context) {
    var section = uiSection("preset-fields", context).label(() => _t.append("inspector.fields")).disclosureContent(renderDisclosureContent);
    var dispatch14 = dispatch_default("change", "revert");
    var formFields = uiFormFields(context);
    var _state;
    var _fieldsArr;
    var _presets = [];
    var _tags;
    var _entityIDs;
    function renderDisclosureContent(selection2) {
      if (!_fieldsArr) {
        var graph = context.graph();
        var geometries = Object.keys(_entityIDs.reduce(function(geoms, entityID) {
          geoms[graph.entity(entityID).geometry(graph)] = true;
          return geoms;
        }, {}));
        const loc = _entityIDs.reduce(function(extent, entityID) {
          var entity = context.graph().entity(entityID);
          return extent.extend(entity.extent(context.graph()));
        }, geoExtent()).center();
        var presetsManager = _mainPresetIndex;
        var allFields = [];
        var allMoreFields = [];
        var sharedTotalFields;
        _presets.forEach(function(preset) {
          var fields = preset.fields(loc);
          var moreFields = preset.moreFields(loc);
          allFields = utilArrayUnion(allFields, fields);
          allMoreFields = utilArrayUnion(allMoreFields, moreFields);
          if (!sharedTotalFields) {
            sharedTotalFields = utilArrayUnion(fields, moreFields);
          } else {
            sharedTotalFields = sharedTotalFields.filter(function(field) {
              return fields.indexOf(field) !== -1 || moreFields.indexOf(field) !== -1;
            });
          }
        });
        var sharedFields = allFields.filter(function(field) {
          return sharedTotalFields.indexOf(field) !== -1;
        });
        var sharedMoreFields = allMoreFields.filter(function(field) {
          return sharedTotalFields.indexOf(field) !== -1;
        });
        _fieldsArr = [];
        sharedFields.forEach(function(field) {
          if (field.matchAllGeometry(geometries)) {
            _fieldsArr.push(
              uiField(context, field, _entityIDs)
            );
          }
        });
        var singularEntity = _entityIDs.length === 1 && graph.hasEntity(_entityIDs[0]);
        if (singularEntity && singularEntity.isHighwayIntersection(graph) && presetsManager.field("restrictions")) {
          _fieldsArr.push(
            uiField(context, presetsManager.field("restrictions"), _entityIDs)
          );
        }
        var additionalFields = utilArrayUnion(sharedMoreFields, presetsManager.universal());
        additionalFields.sort(function(field1, field2) {
          return field1.title().localeCompare(field2.title(), _mainLocalizer.localeCode());
        });
        additionalFields.forEach(function(field) {
          if (sharedFields.indexOf(field) === -1 && field.matchAllGeometry(geometries)) {
            _fieldsArr.push(
              uiField(context, field, _entityIDs, { show: false })
            );
          }
        });
        _fieldsArr.forEach(function(field) {
          field.on("change", function(t2, onInput) {
            dispatch14.call("change", field, _entityIDs, t2, onInput);
          }).on("revert", function(keys2) {
            dispatch14.call("revert", field, keys2);
          });
        });
      }
      _fieldsArr.forEach(function(field) {
        field.state(_state).tags(_tags);
      });
      selection2.call(
        formFields.fieldsArr(_fieldsArr).state(_state).klass("grouped-items-area")
      );
    }
    section.presets = function(val) {
      if (!arguments.length)
        return _presets;
      if (!_presets || !val || !utilArrayIdentical(_presets, val)) {
        _presets = val;
        _fieldsArr = null;
      }
      return section;
    };
    section.state = function(val) {
      if (!arguments.length)
        return _state;
      _state = val;
      return section;
    };
    section.tags = function(val) {
      if (!arguments.length)
        return _tags;
      _tags = val;
      return section;
    };
    section.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      if (!val || !_entityIDs || !utilArrayIdentical(_entityIDs, val)) {
        _entityIDs = val;
        _fieldsArr = null;
      }
      return section;
    };
    return utilRebind(section, dispatch14, "on");
  }

  // modules/ui/sections/raw_member_editor.js
  function uiSectionRawMemberEditor(context) {
    var section = uiSection("raw-member-editor", context).shouldDisplay(function() {
      if (!_entityIDs || _entityIDs.length !== 1)
        return false;
      var entity = context.hasEntity(_entityIDs[0]);
      return entity && entity.type === "relation";
    }).label(function() {
      var entity = context.hasEntity(_entityIDs[0]);
      if (!entity)
        return "";
      var gt2 = entity.members.length > _maxMembers ? ">" : "";
      var count = gt2 + entity.members.slice(0, _maxMembers).length;
      return _t.append("inspector.title_count", { title: _t("inspector.members"), count });
    }).disclosureContent(renderDisclosureContent);
    var taginfo = services.taginfo;
    var _entityIDs;
    var _maxMembers = 1e3;
    function downloadMember(d3_event, d2) {
      d3_event.preventDefault();
      select_default2(this).classed("loading", true);
      context.loadEntity(d2.id, function() {
        section.reRender();
      });
    }
    function zoomToMember(d3_event, d2) {
      d3_event.preventDefault();
      var entity = context.entity(d2.id);
      context.map().zoomToEase(entity);
      utilHighlightEntities([d2.id], true, context);
    }
    function selectMember(d3_event, d2) {
      d3_event.preventDefault();
      utilHighlightEntities([d2.id], false, context);
      var entity = context.entity(d2.id);
      var mapExtent = context.map().extent();
      if (!entity.intersects(mapExtent, context.graph())) {
        context.map().zoomToEase(entity);
      }
      context.enter(modeSelect(context, [d2.id]));
    }
    function changeRole(d3_event, d2) {
      var oldRole = d2.role;
      var newRole = context.cleanRelationRole(select_default2(this).property("value"));
      if (oldRole !== newRole) {
        var member = { id: d2.id, type: d2.type, role: newRole };
        context.perform(
          actionChangeMember(d2.relation.id, member, d2.index),
          _t("operations.change_role.annotation", {
            n: 1
          })
        );
        context.validator().validate();
      }
    }
    function deleteMember(d3_event, d2) {
      utilHighlightEntities([d2.id], false, context);
      context.perform(
        actionDeleteMember(d2.relation.id, d2.index),
        _t("operations.delete_member.annotation", {
          n: 1
        })
      );
      if (!context.hasEntity(d2.relation.id)) {
        context.enter(modeBrowse(context));
      } else {
        context.validator().validate();
      }
    }
    function renderDisclosureContent(selection2) {
      var entityID = _entityIDs[0];
      var memberships = [];
      var entity = context.entity(entityID);
      entity.members.slice(0, _maxMembers).forEach(function(member, index) {
        memberships.push({
          index,
          id: member.id,
          type: member.type,
          role: member.role,
          relation: entity,
          member: context.hasEntity(member.id),
          domId: utilUniqueDomId(entityID + "-member-" + index)
        });
      });
      var list2 = selection2.selectAll(".member-list").data([0]);
      list2 = list2.enter().append("ul").attr("class", "member-list").merge(list2);
      var items = list2.selectAll("li").data(memberships, function(d2) {
        return osmEntity.key(d2.relation) + "," + d2.index + "," + (d2.member ? osmEntity.key(d2.member) : "incomplete");
      });
      items.exit().each(unbind).remove();
      var itemsEnter = items.enter().append("li").attr("class", "member-row form-field").classed("member-incomplete", function(d2) {
        return !d2.member;
      });
      itemsEnter.each(function(d2) {
        var item = select_default2(this);
        var label = item.append("label").attr("class", "field-label").attr("for", d2.domId);
        if (d2.member) {
          item.on("mouseover", function() {
            utilHighlightEntities([d2.id], true, context);
          }).on("mouseout", function() {
            utilHighlightEntities([d2.id], false, context);
          });
          var labelLink = label.append("span").attr("class", "label-text").append("a").attr("href", "#").on("click", selectMember);
          labelLink.append("span").attr("class", "member-entity-type").text(function(d4) {
            var matched = _mainPresetIndex.match(d4.member, context.graph());
            return matched && matched.name() || utilDisplayType(d4.member.id);
          });
          labelLink.append("span").attr("class", "member-entity-name").classed("has-colour", (d4) => d4.member.type === "relation" && d4.member.tags.colour && isColourValid(d4.member.tags.colour)).style("border-color", (d4) => d4.member.type === "relation" && d4.member.tags.colour).text(function(d4) {
            return utilDisplayName(d4.member);
          });
          label.append("button").attr("title", _t("icons.remove")).attr("class", "remove member-delete").call(svgIcon("#iD-operation-delete"));
          label.append("button").attr("class", "member-zoom").attr("title", _t("icons.zoom_to")).call(svgIcon("#iD-icon-framed-dot", "monochrome")).on("click", zoomToMember);
        } else {
          var labelText = label.append("span").attr("class", "label-text");
          labelText.append("span").attr("class", "member-entity-type").call(_t.append("inspector." + d2.type, { id: d2.id }));
          labelText.append("span").attr("class", "member-entity-name").call(_t.append("inspector.incomplete", { id: d2.id }));
          label.append("button").attr("class", "member-download").attr("title", _t("icons.download")).call(svgIcon("#iD-icon-load")).on("click", downloadMember);
        }
      });
      var wrapEnter = itemsEnter.append("div").attr("class", "form-field-input-wrap form-field-input-member");
      wrapEnter.append("input").attr("class", "member-role").attr("id", function(d2) {
        return d2.domId;
      }).property("type", "text").attr("placeholder", _t("inspector.role")).call(utilNoAuto);
      if (taginfo) {
        wrapEnter.each(bindTypeahead);
      }
      items = items.merge(itemsEnter).order();
      items.select("input.member-role").property("value", function(d2) {
        return d2.role;
      }).on("blur", changeRole).on("change", changeRole);
      items.select("button.member-delete").on("click", deleteMember);
      var dragOrigin, targetIndex;
      items.call(
        drag_default().on("start", function(d3_event) {
          dragOrigin = {
            x: d3_event.x,
            y: d3_event.y
          };
          targetIndex = null;
        }).on("drag", function(d3_event) {
          var x2 = d3_event.x - dragOrigin.x, y2 = d3_event.y - dragOrigin.y;
          if (!select_default2(this).classed("dragging") && // don't display drag until dragging beyond a distance threshold
          Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2)) <= 5)
            return;
          var index = items.nodes().indexOf(this);
          select_default2(this).classed("dragging", true);
          targetIndex = null;
          selection2.selectAll("li.member-row").style("transform", function(d2, index2) {
            var node = select_default2(this).node();
            if (index === index2) {
              return "translate(" + x2 + "px, " + y2 + "px)";
            } else if (index2 > index && d3_event.y > node.offsetTop) {
              if (targetIndex === null || index2 > targetIndex) {
                targetIndex = index2;
              }
              return "translateY(-100%)";
            } else if (index2 < index && d3_event.y < node.offsetTop + node.offsetHeight) {
              if (targetIndex === null || index2 < targetIndex) {
                targetIndex = index2;
              }
              return "translateY(100%)";
            }
            return null;
          });
        }).on("end", function(d3_event, d2) {
          if (!select_default2(this).classed("dragging"))
            return;
          var index = items.nodes().indexOf(this);
          select_default2(this).classed("dragging", false);
          selection2.selectAll("li.member-row").style("transform", null);
          if (targetIndex !== null) {
            context.perform(
              actionMoveMember(d2.relation.id, index, targetIndex),
              _t("operations.reorder_members.annotation")
            );
            context.validator().validate();
          }
        })
      );
      function bindTypeahead(d2) {
        var row = select_default2(this);
        var role = row.selectAll("input.member-role");
        var origValue = role.property("value");
        function sort(value, data) {
          var sameletter = [];
          var other = [];
          for (var i3 = 0; i3 < data.length; i3++) {
            if (data[i3].value.substring(0, value.length) === value) {
              sameletter.push(data[i3]);
            } else {
              other.push(data[i3]);
            }
          }
          return sameletter.concat(other);
        }
        role.call(
          uiCombobox(context, "member-role").fetcher(function(role2, callback) {
            var geometry;
            if (d2.member) {
              geometry = context.graph().geometry(d2.member.id);
            } else if (d2.type === "relation") {
              geometry = "relation";
            } else if (d2.type === "way") {
              geometry = "line";
            } else {
              geometry = "point";
            }
            var rtype = entity.tags.type;
            taginfo.roles({
              debounce: true,
              rtype: rtype || "",
              geometry,
              query: role2
            }, function(err, data) {
              if (!err)
                callback(sort(role2, data));
            });
          }).on("cancel", function() {
            role.property("value", origValue);
          })
        );
      }
      function unbind() {
        var row = select_default2(this);
        row.selectAll("input.member-role").call(uiCombobox.off, context);
      }
    }
    section.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      _entityIDs = val;
      return section;
    };
    return section;
  }

  // modules/actions/delete_members.js
  function actionDeleteMembers(relationId, memberIndexes) {
    return function(graph) {
      memberIndexes.sort((a2, b2) => b2 - a2);
      for (var i3 in memberIndexes) {
        graph = actionDeleteMember(relationId, memberIndexes[i3])(graph);
      }
      return graph;
    };
  }

  // modules/ui/sections/raw_membership_editor.js
  function uiSectionRawMembershipEditor(context) {
    var section = uiSection("raw-membership-editor", context).shouldDisplay(function() {
      return _entityIDs && _entityIDs.length;
    }).label(function() {
      var parents = getSharedParentRelations();
      var gt2 = parents.length > _maxMemberships ? ">" : "";
      var count = gt2 + parents.slice(0, _maxMemberships).length;
      return _t.append("inspector.title_count", { title: _t("inspector.relations"), count });
    }).disclosureContent(renderDisclosureContent);
    var taginfo = services.taginfo;
    var nearbyCombo = uiCombobox(context, "parent-relation").minItems(1).fetcher(fetchNearbyRelations).itemsMouseEnter(function(d3_event, d2) {
      if (d2.relation)
        utilHighlightEntities([d2.relation.id], true, context);
    }).itemsMouseLeave(function(d3_event, d2) {
      if (d2.relation)
        utilHighlightEntities([d2.relation.id], false, context);
    });
    var _inChange = false;
    var _entityIDs = [];
    var _showBlank;
    var _maxMemberships = 1e3;
    function getSharedParentRelations() {
      var parents = [];
      for (var i3 = 0; i3 < _entityIDs.length; i3++) {
        var entity = context.graph().hasEntity(_entityIDs[i3]);
        if (!entity)
          continue;
        if (i3 === 0) {
          parents = context.graph().parentRelations(entity);
        } else {
          parents = utilArrayIntersection(parents, context.graph().parentRelations(entity));
        }
        if (!parents.length)
          break;
      }
      return parents;
    }
    function getMemberships() {
      var memberships = [];
      var relations = getSharedParentRelations().slice(0, _maxMemberships);
      var isMultiselect = _entityIDs.length > 1;
      var i3, relation, membership, index, member, indexedMember;
      for (i3 = 0; i3 < relations.length; i3++) {
        relation = relations[i3];
        membership = {
          relation,
          members: [],
          hash: osmEntity.key(relation)
        };
        for (index = 0; index < relation.members.length; index++) {
          member = relation.members[index];
          if (_entityIDs.indexOf(member.id) !== -1) {
            indexedMember = Object.assign({}, member, { index });
            membership.members.push(indexedMember);
            membership.hash += "," + index.toString();
            if (!isMultiselect) {
              memberships.push(membership);
              membership = {
                relation,
                members: [],
                hash: osmEntity.key(relation)
              };
            }
          }
        }
        if (membership.members.length)
          memberships.push(membership);
      }
      memberships.forEach(function(membership2) {
        membership2.domId = utilUniqueDomId("membership-" + membership2.relation.id);
        var roles = [];
        membership2.members.forEach(function(member2) {
          if (roles.indexOf(member2.role) === -1)
            roles.push(member2.role);
        });
        membership2.role = roles.length === 1 ? roles[0] : roles;
      });
      return memberships;
    }
    function selectRelation(d3_event, d2) {
      d3_event.preventDefault();
      utilHighlightEntities([d2.relation.id], false, context);
      context.enter(modeSelect(context, [d2.relation.id]));
    }
    function zoomToRelation(d3_event, d2) {
      d3_event.preventDefault();
      var entity = context.entity(d2.relation.id);
      context.map().zoomToEase(entity);
      utilHighlightEntities([d2.relation.id], true, context);
    }
    function changeRole(d3_event, d2) {
      if (d2 === 0)
        return;
      if (_inChange)
        return;
      var newRole = context.cleanRelationRole(select_default2(this).property("value"));
      if (!newRole.trim() && typeof d2.role !== "string")
        return;
      var membersToUpdate = d2.members.filter(function(member) {
        return member.role !== newRole;
      });
      if (membersToUpdate.length) {
        _inChange = true;
        context.perform(
          function actionChangeMemberRoles(graph) {
            membersToUpdate.forEach(function(member) {
              var newMember = Object.assign({}, member, { role: newRole });
              delete newMember.index;
              graph = actionChangeMember(d2.relation.id, newMember, member.index)(graph);
            });
            return graph;
          },
          _t("operations.change_role.annotation", {
            n: membersToUpdate.length
          })
        );
        context.validator().validate();
      }
      _inChange = false;
    }
    function addMembership(d2, role) {
      this.blur();
      _showBlank = false;
      function actionAddMembers(relationId, ids, role2) {
        return function(graph) {
          for (var i3 in ids) {
            var member = { id: ids[i3], type: graph.entity(ids[i3]).type, role: role2 };
            graph = actionAddMember(relationId, member)(graph);
          }
          return graph;
        };
      }
      if (d2.relation) {
        context.perform(
          actionAddMembers(d2.relation.id, _entityIDs, role),
          _t("operations.add_member.annotation", {
            n: _entityIDs.length
          })
        );
        context.validator().validate();
      } else {
        var relation = osmRelation();
        context.perform(
          actionAddEntity(relation),
          actionAddMembers(relation.id, _entityIDs, role),
          _t("operations.add.annotation.relation")
        );
        context.enter(modeSelect(context, [relation.id]).newFeature(true));
      }
    }
    function downloadMembers(d3_event, d2) {
      d3_event.preventDefault();
      const button = select_default2(this);
      button.classed("loading", true);
      context.loadEntity(d2.relation.id, function() {
        section.reRender();
      });
    }
    function deleteMembership(d3_event, d2) {
      this.blur();
      if (d2 === 0)
        return;
      utilHighlightEntities([d2.relation.id], false, context);
      var indexes = d2.members.map(function(member) {
        return member.index;
      });
      context.perform(
        actionDeleteMembers(d2.relation.id, indexes),
        _t("operations.delete_member.annotation", {
          n: _entityIDs.length
        })
      );
      context.validator().validate();
    }
    function fetchNearbyRelations(q2, callback) {
      var newRelation = {
        relation: null,
        value: _t("inspector.new_relation"),
        display: _t.append("inspector.new_relation")
      };
      var entityID = _entityIDs[0];
      var result = [];
      var graph = context.graph();
      function baseDisplayValue(entity) {
        var matched = _mainPresetIndex.match(entity, graph);
        var presetName = matched && matched.name() || _t("inspector.relation");
        var entityName = utilDisplayName(entity) || "";
        return presetName + " " + entityName;
      }
      function baseDisplayLabel(entity) {
        var matched = _mainPresetIndex.match(entity, graph);
        var presetName = matched && matched.name() || _t("inspector.relation");
        var entityName = utilDisplayName(entity) || "";
        return (selection2) => {
          selection2.append("b").text(presetName + " ");
          selection2.append("span").classed("has-colour", entity.tags.colour && isColourValid(entity.tags.colour)).style("border-color", entity.tags.colour).text(entityName);
        };
      }
      var explicitRelation = q2 && context.hasEntity(q2.toLowerCase());
      if (explicitRelation && explicitRelation.type === "relation" && explicitRelation.id !== entityID) {
        result.push({
          relation: explicitRelation,
          value: baseDisplayValue(explicitRelation) + " " + explicitRelation.id,
          display: baseDisplayLabel(explicitRelation)
        });
      } else {
        context.history().intersects(context.map().extent()).forEach(function(entity) {
          if (entity.type !== "relation" || entity.id === entityID)
            return;
          var value = baseDisplayValue(entity);
          if (q2 && (value + " " + entity.id).toLowerCase().indexOf(q2.toLowerCase()) === -1)
            return;
          result.push({
            relation: entity,
            value,
            display: baseDisplayLabel(entity)
          });
        });
        result.sort(function(a2, b2) {
          return osmRelation.creationOrder(a2.relation, b2.relation);
        });
        var dupeGroups = Object.values(utilArrayGroupBy(result, "value")).filter(function(v2) {
          return v2.length > 1;
        });
        dupeGroups.forEach(function(group) {
          group.forEach(function(obj) {
            obj.value += " " + obj.relation.id;
          });
        });
      }
      result.forEach(function(obj) {
        obj.title = obj.value;
      });
      result.unshift(newRelation);
      callback(result);
    }
    function renderDisclosureContent(selection2) {
      var memberships = getMemberships();
      var list2 = selection2.selectAll(".member-list").data([0]);
      list2 = list2.enter().append("ul").attr("class", "member-list").merge(list2);
      var items = list2.selectAll("li.member-row-normal").data(memberships, function(d2) {
        return d2.hash;
      });
      items.exit().each(unbind).remove();
      var itemsEnter = items.enter().append("li").attr("class", "member-row member-row-normal form-field");
      itemsEnter.on("mouseover", function(d3_event, d2) {
        utilHighlightEntities([d2.relation.id], true, context);
      }).on("mouseout", function(d3_event, d2) {
        utilHighlightEntities([d2.relation.id], false, context);
      });
      var labelEnter = itemsEnter.append("label").attr("class", "field-label").attr("for", function(d2) {
        return d2.domId;
      });
      var labelLink = labelEnter.append("span").attr("class", "label-text").append("a").attr("href", "#").on("click", selectRelation);
      labelLink.append("span").attr("class", "member-entity-type").text(function(d2) {
        var matched = _mainPresetIndex.match(d2.relation, context.graph());
        return matched && matched.name() || _t.html("inspector.relation");
      });
      labelLink.append("span").attr("class", "member-entity-name").classed("has-colour", (d2) => d2.relation.tags.colour && isColourValid(d2.relation.tags.colour)).style("border-color", (d2) => d2.relation.tags.colour).text(function(d2) {
        return utilDisplayName(d2.relation);
      });
      labelEnter.append("button").attr("class", "members-download").attr("title", _t("icons.download")).call(svgIcon("#iD-icon-load")).on("click", downloadMembers);
      labelEnter.append("button").attr("class", "remove member-delete").attr("title", _t("icons.remove")).call(svgIcon("#iD-operation-delete")).on("click", deleteMembership);
      labelEnter.append("button").attr("class", "member-zoom").attr("title", _t("icons.zoom_to")).call(svgIcon("#iD-icon-framed-dot", "monochrome")).on("click", zoomToRelation);
      items = items.merge(itemsEnter);
      items.selectAll("button.members-download").classed("hide", (d2) => {
        const graph = context.graph();
        return d2.relation.members.every((m2) => graph.hasEntity(m2.id));
      });
      var wrapEnter = itemsEnter.append("div").attr("class", "form-field-input-wrap form-field-input-member");
      wrapEnter.append("input").attr("class", "member-role").attr("id", function(d2) {
        return d2.domId;
      }).property("type", "text").property("value", function(d2) {
        return typeof d2.role === "string" ? d2.role : "";
      }).attr("title", function(d2) {
        return Array.isArray(d2.role) ? d2.role.filter(Boolean).join("\n") : d2.role;
      }).attr("placeholder", function(d2) {
        return Array.isArray(d2.role) ? _t("inspector.multiple_roles") : _t("inspector.role");
      }).classed("mixed", function(d2) {
        return Array.isArray(d2.role);
      }).call(utilNoAuto).on("blur", changeRole).on("change", changeRole);
      if (taginfo) {
        wrapEnter.each(bindTypeahead);
      }
      var newMembership = list2.selectAll(".member-row-new").data(_showBlank ? [0] : []);
      newMembership.exit().remove();
      var newMembershipEnter = newMembership.enter().append("li").attr("class", "member-row member-row-new form-field");
      var newLabelEnter = newMembershipEnter.append("label").attr("class", "field-label");
      newLabelEnter.append("input").attr("placeholder", _t("inspector.choose_relation")).attr("type", "text").attr("class", "member-entity-input").call(utilNoAuto);
      newLabelEnter.append("button").attr("class", "remove member-delete").attr("title", _t("icons.remove")).call(svgIcon("#iD-operation-delete")).on("click", function() {
        list2.selectAll(".member-row-new").remove();
      });
      var newWrapEnter = newMembershipEnter.append("div").attr("class", "form-field-input-wrap form-field-input-member");
      newWrapEnter.append("input").attr("class", "member-role").property("type", "text").attr("placeholder", _t("inspector.role")).call(utilNoAuto);
      newMembership = newMembership.merge(newMembershipEnter);
      newMembership.selectAll(".member-entity-input").on("blur", cancelEntity).call(
        nearbyCombo.on("accept", acceptEntity).on("cancel", cancelEntity)
      );
      var addRow = selection2.selectAll(".add-row").data([0]);
      var addRowEnter = addRow.enter().append("div").attr("class", "add-row");
      var addRelationButton = addRowEnter.append("button").attr("class", "add-relation").attr("aria-label", _t("inspector.add_to_relation"));
      addRelationButton.call(svgIcon("#iD-icon-plus", "light"));
      addRelationButton.call(uiTooltip().title(() => _t.append("inspector.add_to_relation")).placement(_mainLocalizer.textDirection() === "ltr" ? "right" : "left"));
      addRowEnter.append("div").attr("class", "space-value");
      addRowEnter.append("div").attr("class", "space-buttons");
      addRow = addRow.merge(addRowEnter);
      addRow.select(".add-relation").on("click", function() {
        _showBlank = true;
        section.reRender();
        list2.selectAll(".member-entity-input").node().focus();
      });
      function acceptEntity(d2) {
        if (!d2) {
          cancelEntity();
          return;
        }
        if (d2.relation)
          utilHighlightEntities([d2.relation.id], false, context);
        var role = context.cleanRelationRole(list2.selectAll(".member-row-new .member-role").property("value"));
        addMembership(d2, role);
      }
      function cancelEntity() {
        var input = newMembership.selectAll(".member-entity-input");
        input.property("value", "");
        context.surface().selectAll(".highlighted").classed("highlighted", false);
      }
      function bindTypeahead(d2) {
        var row = select_default2(this);
        var role = row.selectAll("input.member-role");
        var origValue = role.property("value");
        function sort(value, data) {
          var sameletter = [];
          var other = [];
          for (var i3 = 0; i3 < data.length; i3++) {
            if (data[i3].value.substring(0, value.length) === value) {
              sameletter.push(data[i3]);
            } else {
              other.push(data[i3]);
            }
          }
          return sameletter.concat(other);
        }
        role.call(
          uiCombobox(context, "member-role").fetcher(function(role2, callback) {
            var rtype = d2.relation.tags.type;
            taginfo.roles({
              debounce: true,
              rtype: rtype || "",
              geometry: context.graph().geometry(_entityIDs[0]),
              query: role2
            }, function(err, data) {
              if (!err)
                callback(sort(role2, data));
            });
          }).on("cancel", function() {
            role.property("value", origValue);
          })
        );
      }
      function unbind() {
        var row = select_default2(this);
        row.selectAll("input.member-role").call(uiCombobox.off, context);
      }
    }
    section.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      _entityIDs = val;
      _showBlank = false;
      return section;
    };
    return section;
  }

  // modules/ui/sections/selection_list.js
  function uiSectionSelectionList(context) {
    var _selectedIDs = [];
    var section = uiSection("selected-features", context).shouldDisplay(function() {
      return _selectedIDs.length > 1;
    }).label(function() {
      return _t.append("inspector.title_count", { title: _t("inspector.features"), count: _selectedIDs.length });
    }).disclosureContent(renderDisclosureContent);
    context.history().on("change.selectionList", function(difference2) {
      if (difference2) {
        section.reRender();
      }
    });
    section.entityIDs = function(val) {
      if (!arguments.length)
        return _selectedIDs;
      _selectedIDs = val;
      return section;
    };
    function selectEntity(d3_event, entity) {
      context.enter(modeSelect(context, [entity.id]));
    }
    function deselectEntity(d3_event, entity) {
      var selectedIDs = _selectedIDs.slice();
      var index = selectedIDs.indexOf(entity.id);
      if (index > -1) {
        selectedIDs.splice(index, 1);
        context.enter(modeSelect(context, selectedIDs));
      }
    }
    function renderDisclosureContent(selection2) {
      var list2 = selection2.selectAll(".feature-list").data([0]);
      list2 = list2.enter().append("ul").attr("class", "feature-list").merge(list2);
      var entities = _selectedIDs.map(function(id2) {
        return context.hasEntity(id2);
      }).filter(Boolean);
      var items = list2.selectAll(".feature-list-item").data(entities, osmEntity.key);
      items.exit().remove();
      var enter = items.enter().append("li").attr("class", "feature-list-item").each(function(d2) {
        select_default2(this).on("mouseover", function() {
          utilHighlightEntities([d2.id], true, context);
        }).on("mouseout", function() {
          utilHighlightEntities([d2.id], false, context);
        });
      });
      var label = enter.append("button").attr("class", "label").on("click", selectEntity);
      label.append("span").attr("class", "entity-geom-icon").call(svgIcon("", "pre-text"));
      label.append("span").attr("class", "entity-type");
      label.append("span").attr("class", "entity-name");
      enter.append("button").attr("class", "close").attr("title", _t("icons.deselect")).on("click", deselectEntity).call(svgIcon("#iD-icon-close"));
      items = items.merge(enter);
      items.selectAll(".entity-geom-icon use").attr("href", function() {
        var entity = this.parentNode.parentNode.__data__;
        return "#iD-icon-" + entity.geometry(context.graph());
      });
      items.selectAll(".entity-type").text(function(entity) {
        return _mainPresetIndex.match(entity, context.graph()).name();
      });
      items.selectAll(".entity-name").text(function(d2) {
        var entity = context.entity(d2.id);
        return utilDisplayName(entity);
      });
    }
    return section;
  }

  // modules/ui/entity_editor.js
  function uiEntityEditor(context) {
    var dispatch14 = dispatch_default("choose");
    var _state = "select";
    var _coalesceChanges = false;
    var _modified = false;
    var _base;
    var _entityIDs;
    var _activePresets = [];
    var _newFeature;
    var _sections;
    function entityEditor(selection2) {
      var combinedTags = utilCombinedTags(_entityIDs, context.graph());
      var header = selection2.selectAll(".header").data([0]);
      var headerEnter = header.enter().append("div").attr("class", "header fillL");
      var direction = _mainLocalizer.textDirection() === "rtl" ? "forward" : "backward";
      headerEnter.append("button").attr("class", "preset-reset preset-choose").attr("title", _t("inspector.back_tooltip")).call(svgIcon("#iD-icon-".concat(direction)));
      headerEnter.append("button").attr("class", "close").attr("title", _t("icons.close")).on("click", function() {
        context.enter(modeBrowse(context));
      }).call(svgIcon(_modified ? "#iD-icon-apply" : "#iD-icon-close"));
      headerEnter.append("h2");
      header = header.merge(headerEnter);
      header.selectAll("h2").text("").call(_entityIDs.length === 1 ? _t.append("inspector.edit") : _t.append("inspector.edit_features"));
      header.selectAll(".preset-reset").on("click", function() {
        dispatch14.call("choose", this, _activePresets);
      });
      var body = selection2.selectAll(".inspector-body").data([0]);
      var bodyEnter = body.enter().append("div").attr("class", "entity-editor inspector-body sep-top");
      body = body.merge(bodyEnter);
      if (!_sections) {
        _sections = [
          uiSectionSelectionList(context),
          uiSectionFeatureType(context).on("choose", function(presets) {
            dispatch14.call("choose", this, presets);
          }),
          uiSectionEntityIssues(context),
          uiSectionPresetFields(context).on("change", changeTags).on("revert", revertTags),
          uiSectionRawTagEditor("raw-tag-editor", context).on("change", changeTags),
          uiSectionRawMemberEditor(context),
          uiSectionRawMembershipEditor(context)
        ];
      }
      _sections.forEach(function(section) {
        if (section.entityIDs) {
          section.entityIDs(_entityIDs);
        }
        if (section.presets) {
          section.presets(_activePresets);
        }
        if (section.tags) {
          section.tags(combinedTags);
        }
        if (section.state) {
          section.state(_state);
        }
        body.call(section.render);
      });
      context.history().on("change.entity-editor", historyChanged);
      function historyChanged(difference2) {
        if (selection2.selectAll(".entity-editor").empty())
          return;
        if (_state === "hide")
          return;
        var significant = !difference2 || difference2.didChange.properties || difference2.didChange.addition || difference2.didChange.deletion;
        if (!significant)
          return;
        _entityIDs = _entityIDs.filter(context.hasEntity);
        if (!_entityIDs.length)
          return;
        var priorActivePreset = _activePresets.length === 1 && _activePresets[0];
        loadActivePresets();
        var graph = context.graph();
        entityEditor.modified(_base !== graph);
        entityEditor(selection2);
        if (priorActivePreset && _activePresets.length === 1 && priorActivePreset !== _activePresets[0]) {
          context.container().selectAll(".entity-editor button.preset-reset .label").style("background-color", "#fff").transition().duration(750).style("background-color", null);
        }
      }
    }
    function changeTags(entityIDs, changed, onInput) {
      var actions = [];
      for (var i3 in entityIDs) {
        var entityID = entityIDs[i3];
        var entity = context.entity(entityID);
        var tags = Object.assign({}, entity.tags);
        if (typeof changed === "function") {
          tags = changed(tags);
        } else {
          for (var k2 in changed) {
            if (!k2)
              continue;
            var v2 = changed[k2];
            if (typeof v2 === "object") {
              tags[k2] = tags[v2.oldKey];
            } else if (v2 !== void 0 || tags.hasOwnProperty(k2)) {
              tags[k2] = v2;
            }
          }
        }
        if (!onInput) {
          tags = utilCleanTags(tags);
        }
        if (!(0, import_fast_deep_equal10.default)(entity.tags, tags)) {
          actions.push(actionChangeTags(entityID, tags));
        }
      }
      if (actions.length) {
        var combinedAction = function(graph) {
          actions.forEach(function(action) {
            graph = action(graph);
          });
          return graph;
        };
        var annotation = _t("operations.change_tags.annotation");
        if (_coalesceChanges) {
          context.overwrite(combinedAction, annotation);
        } else {
          context.perform(combinedAction, annotation);
          _coalesceChanges = !!onInput;
        }
      }
      if (!onInput) {
        context.validator().validate();
      }
    }
    function revertTags(keys2) {
      var actions = [];
      for (var i3 in _entityIDs) {
        var entityID = _entityIDs[i3];
        var original = context.graph().base().entities[entityID];
        var changed = {};
        for (var j2 in keys2) {
          var key = keys2[j2];
          changed[key] = original ? original.tags[key] : void 0;
        }
        var entity = context.entity(entityID);
        var tags = Object.assign({}, entity.tags);
        for (var k2 in changed) {
          if (!k2)
            continue;
          var v2 = changed[k2];
          if (v2 !== void 0 || tags.hasOwnProperty(k2)) {
            tags[k2] = v2;
          }
        }
        tags = utilCleanTags(tags);
        if (!(0, import_fast_deep_equal10.default)(entity.tags, tags)) {
          actions.push(actionChangeTags(entityID, tags));
        }
      }
      if (actions.length) {
        var combinedAction = function(graph) {
          actions.forEach(function(action) {
            graph = action(graph);
          });
          return graph;
        };
        var annotation = _t("operations.change_tags.annotation");
        if (_coalesceChanges) {
          context.overwrite(combinedAction, annotation);
        } else {
          context.perform(combinedAction, annotation);
          _coalesceChanges = false;
        }
      }
      context.validator().validate();
    }
    entityEditor.modified = function(val) {
      if (!arguments.length)
        return _modified;
      _modified = val;
      return entityEditor;
    };
    entityEditor.state = function(val) {
      if (!arguments.length)
        return _state;
      _state = val;
      return entityEditor;
    };
    entityEditor.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      _base = context.graph();
      _coalesceChanges = false;
      if (val && _entityIDs && utilArrayIdentical(_entityIDs, val))
        return entityEditor;
      _entityIDs = val;
      loadActivePresets(true);
      return entityEditor.modified(false);
    };
    entityEditor.newFeature = function(val) {
      if (!arguments.length)
        return _newFeature;
      _newFeature = val;
      return entityEditor;
    };
    function loadActivePresets(isForNewSelection) {
      var graph = context.graph();
      var counts = {};
      for (var i3 in _entityIDs) {
        var entity = graph.hasEntity(_entityIDs[i3]);
        if (!entity)
          return;
        var match = _mainPresetIndex.match(entity, graph);
        if (!counts[match.id])
          counts[match.id] = 0;
        counts[match.id] += 1;
      }
      var matches = Object.keys(counts).sort(function(p1, p2) {
        return counts[p2] - counts[p1];
      }).map(function(pID) {
        return _mainPresetIndex.item(pID);
      });
      if (!isForNewSelection) {
        var weakPreset = _activePresets.length === 1 && !_activePresets[0].isFallback() && Object.keys(_activePresets[0].addTags || {}).length === 0;
        if (weakPreset && matches.length === 1 && matches[0].isFallback())
          return;
      }
      entityEditor.presets(matches);
    }
    entityEditor.presets = function(val) {
      if (!arguments.length)
        return _activePresets;
      if (!utilArrayIdentical(val, _activePresets)) {
        _activePresets = val;
      }
      return entityEditor;
    };
    return utilRebind(entityEditor, dispatch14, "on");
  }

  // modules/ui/feature_list.js
  var sexagesimal = __toESM(require_sexagesimal());

  // modules/modes/draw_area.js
  function modeDrawArea(context, wayID, startGraph, button) {
    var mode = {
      button,
      id: "draw-area"
    };
    var behavior = behaviorDrawWay(context, wayID, mode, startGraph).on("rejectedSelfIntersection.modeDrawArea", function() {
      context.ui().flash.iconName("#iD-icon-no").label(_t.append("self_intersection.error.areas"))();
    });
    mode.wayID = wayID;
    mode.enter = function() {
      context.install(behavior);
    };
    mode.exit = function() {
      context.uninstall(behavior);
    };
    mode.selectedIDs = function() {
      return [wayID];
    };
    mode.activeID = function() {
      return behavior && behavior.activeID() || [];
    };
    return mode;
  }

  // modules/modes/add_area.js
  function modeAddArea(context, mode) {
    mode.id = "add-area";
    var behavior = behaviorAddWay(context).on("start", start2).on("startFromWay", startFromWay).on("startFromNode", startFromNode);
    function defaultTags(loc) {
      var defaultTags2 = { area: "yes" };
      if (mode.preset)
        defaultTags2 = mode.preset.setTags(defaultTags2, "area", false, loc);
      return defaultTags2;
    }
    function actionClose(wayId) {
      return function(graph) {
        return graph.replace(graph.entity(wayId).close());
      };
    }
    function start2(loc) {
      var startGraph = context.graph();
      var node = osmNode({ loc });
      var way = osmWay({ tags: defaultTags(loc) });
      context.perform(
        actionAddEntity(node),
        actionAddEntity(way),
        actionAddVertex(way.id, node.id),
        actionClose(way.id)
      );
      context.enter(modeDrawArea(context, way.id, startGraph, mode.button));
    }
    function startFromWay(loc, edge) {
      var startGraph = context.graph();
      var node = osmNode({ loc });
      var way = osmWay({ tags: defaultTags(loc) });
      context.perform(
        actionAddEntity(node),
        actionAddEntity(way),
        actionAddVertex(way.id, node.id),
        actionClose(way.id),
        actionAddMidpoint({ loc, edge }, node)
      );
      context.enter(modeDrawArea(context, way.id, startGraph, mode.button));
    }
    function startFromNode(node) {
      var startGraph = context.graph();
      var way = osmWay({ tags: defaultTags(node.loc) });
      context.perform(
        actionAddEntity(way),
        actionAddVertex(way.id, node.id),
        actionClose(way.id)
      );
      context.enter(modeDrawArea(context, way.id, startGraph, mode.button));
    }
    mode.enter = function() {
      context.install(behavior);
    };
    mode.exit = function() {
      context.uninstall(behavior);
    };
    return mode;
  }

  // modules/modes/add_line.js
  function modeAddLine(context, mode) {
    mode.id = "add-line";
    var behavior = behaviorAddWay(context).on("start", start2).on("startFromWay", startFromWay).on("startFromNode", startFromNode);
    function defaultTags(loc) {
      var defaultTags2 = {};
      if (mode.preset)
        defaultTags2 = mode.preset.setTags(defaultTags2, "line", false, loc);
      return defaultTags2;
    }
    function start2(loc) {
      var startGraph = context.graph();
      var node = osmNode({ loc });
      var way = osmWay({ tags: defaultTags(loc) });
      context.perform(
        actionAddEntity(node),
        actionAddEntity(way),
        actionAddVertex(way.id, node.id)
      );
      context.enter(modeDrawLine(context, way.id, startGraph, mode.button));
    }
    function startFromWay(loc, edge) {
      var startGraph = context.graph();
      var node = osmNode({ loc });
      var way = osmWay({ tags: defaultTags(loc) });
      context.perform(
        actionAddEntity(node),
        actionAddEntity(way),
        actionAddVertex(way.id, node.id),
        actionAddMidpoint({ loc, edge }, node)
      );
      context.enter(modeDrawLine(context, way.id, startGraph, mode.button));
    }
    function startFromNode(node) {
      var startGraph = context.graph();
      var way = osmWay({ tags: defaultTags(node.loc) });
      context.perform(
        actionAddEntity(way),
        actionAddVertex(way.id, node.id)
      );
      context.enter(modeDrawLine(context, way.id, startGraph, mode.button));
    }
    mode.enter = function() {
      context.install(behavior);
    };
    mode.exit = function() {
      context.uninstall(behavior);
    };
    return mode;
  }

  // modules/modes/add_point.js
  function modeAddPoint(context, mode) {
    mode.id = "add-point";
    var behavior = behaviorDraw(context).on("click", add).on("clickWay", addWay).on("clickNode", addNode).on("cancel", cancel).on("finish", cancel);
    function defaultTags(loc) {
      var defaultTags2 = {};
      if (mode.preset)
        defaultTags2 = mode.preset.setTags(defaultTags2, "point", false, loc);
      return defaultTags2;
    }
    function add(loc) {
      var node = osmNode({ loc, tags: defaultTags(loc) });
      context.perform(
        actionAddEntity(node),
        _t("operations.add.annotation.point")
      );
      enterSelectMode(node);
    }
    function addWay(loc, edge) {
      var node = osmNode({ tags: defaultTags(loc) });
      context.perform(
        actionAddMidpoint({ loc, edge }, node),
        _t("operations.add.annotation.vertex")
      );
      enterSelectMode(node);
    }
    function enterSelectMode(node) {
      context.enter(
        modeSelect(context, [node.id]).newFeature(true)
      );
    }
    function addNode(node) {
      const _defaultTags = defaultTags(node.loc);
      if (Object.keys(_defaultTags).length === 0) {
        enterSelectMode(node);
        return;
      }
      var tags = Object.assign({}, node.tags);
      for (var key in _defaultTags) {
        tags[key] = _defaultTags[key];
      }
      context.perform(
        actionChangeTags(node.id, tags),
        _t("operations.add.annotation.point")
      );
      enterSelectMode(node);
    }
    function cancel() {
      context.enter(modeBrowse(context));
    }
    mode.enter = function() {
      context.install(behavior);
    };
    mode.exit = function() {
      context.uninstall(behavior);
    };
    return mode;
  }

  // modules/ui/note_comments.js
  function uiNoteComments() {
    var _note;
    function noteComments(selection2) {
      if (_note.isNew())
        return;
      var comments = selection2.selectAll(".comments-container").data([0]);
      comments = comments.enter().append("div").attr("class", "comments-container").merge(comments);
      var commentEnter = comments.selectAll(".comment").data(_note.comments).enter().append("div").attr("class", "comment");
      commentEnter.append("div").attr("class", function(d2) {
        return "comment-avatar user-" + d2.uid;
      }).call(svgIcon("#iD-icon-avatar", "comment-avatar-icon"));
      var mainEnter = commentEnter.append("div").attr("class", "comment-main");
      var metadataEnter = mainEnter.append("div").attr("class", "comment-metadata");
      metadataEnter.append("div").attr("class", "comment-author").each(function(d2) {
        var selection3 = select_default2(this);
        var osm = services.osm;
        if (osm && d2.user) {
          selection3 = selection3.append("a").attr("class", "comment-author-link").attr("href", osm.userURL(d2.user)).attr("target", "_blank");
        }
        if (d2.user) {
          selection3.text(d2.user);
        } else {
          selection3.call(_t.append("note.anonymous"));
        }
      });
      metadataEnter.append("div").attr("class", "comment-date").html(function(d2) {
        return _t.html("note.status." + d2.action, { when: localeDateString2(d2.date) });
      });
      mainEnter.append("div").attr("class", "comment-text").html(function(d2) {
        return d2.html;
      }).selectAll("a").attr("rel", "noopener nofollow").attr("target", "_blank");
      comments.call(replaceAvatars);
    }
    function replaceAvatars(selection2) {
      var showThirdPartyIcons = corePreferences("preferences.privacy.thirdpartyicons") || "true";
      var osm = services.osm;
      if (showThirdPartyIcons !== "true" || !osm)
        return;
      var uids = {};
      _note.comments.forEach(function(d2) {
        if (d2.uid)
          uids[d2.uid] = true;
      });
      Object.keys(uids).forEach(function(uid) {
        osm.loadUser(uid, function(err, user) {
          if (!user || !user.image_url)
            return;
          selection2.selectAll(".comment-avatar.user-" + uid).html("").append("img").attr("class", "icon comment-avatar-icon").attr("src", user.image_url).attr("alt", user.display_name);
        });
      });
    }
    function localeDateString2(s2) {
      if (!s2)
        return null;
      var options2 = { day: "numeric", month: "short", year: "numeric" };
      s2 = s2.replace(/-/g, "/");
      var d2 = new Date(s2);
      if (isNaN(d2.getTime()))
        return null;
      return d2.toLocaleDateString(_mainLocalizer.localeCode(), options2);
    }
    noteComments.note = function(val) {
      if (!arguments.length)
        return _note;
      _note = val;
      return noteComments;
    };
    return noteComments;
  }

  // modules/ui/note_header.js
  function uiNoteHeader() {
    var _note;
    function noteHeader(selection2) {
      var header = selection2.selectAll(".note-header").data(
        _note ? [_note] : [],
        function(d2) {
          return d2.status + d2.id;
        }
      );
      header.exit().remove();
      var headerEnter = header.enter().append("div").attr("class", "note-header");
      var iconEnter = headerEnter.append("div").attr("class", function(d2) {
        return "note-header-icon " + d2.status;
      }).classed("new", function(d2) {
        return d2.id < 0;
      });
      iconEnter.append("div").attr("class", "preset-icon-28").call(svgIcon("#iD-icon-note", "note-fill"));
      iconEnter.each(function(d2) {
        var statusIcon;
        if (d2.id < 0) {
          statusIcon = "#iD-icon-plus";
        } else if (d2.status === "open") {
          statusIcon = "#iD-icon-close";
        } else {
          statusIcon = "#iD-icon-apply";
        }
        iconEnter.append("div").attr("class", "note-icon-annotation").attr("title", _t("icons.close")).call(svgIcon(statusIcon, "icon-annotation"));
      });
      headerEnter.append("div").attr("class", "note-header-label").html(function(d2) {
        if (_note.isNew()) {
          return _t.html("note.new");
        }
        return _t.html("note.note") + " " + d2.id + " " + (d2.status === "closed" ? _t.html("note.closed") : "");
      });
    }
    noteHeader.note = function(val) {
      if (!arguments.length)
        return _note;
      _note = val;
      return noteHeader;
    };
    return noteHeader;
  }

  // modules/ui/note_report.js
  function uiNoteReport() {
    var _note;
    function noteReport(selection2) {
      var url;
      if (services.osm && _note instanceof osmNote && !_note.isNew()) {
        url = services.osm.noteReportURL(_note);
      }
      var link3 = selection2.selectAll(".note-report").data(url ? [url] : []);
      link3.exit().remove();
      var linkEnter = link3.enter().append("a").attr("class", "note-report").attr("target", "_blank").attr("href", function(d2) {
        return d2;
      }).call(svgIcon("#iD-icon-out-link", "inline"));
      linkEnter.append("span").call(_t.append("note.report"));
    }
    noteReport.note = function(val) {
      if (!arguments.length)
        return _note;
      _note = val;
      return noteReport;
    };
    return noteReport;
  }

  // modules/ui/view_on_osm.js
  function uiViewOnOSM(context) {
    var _what;
    function viewOnOSM(selection2) {
      var url;
      if (_what instanceof osmEntity) {
        url = context.connection().entityURL(_what);
      } else if (_what instanceof osmNote) {
        url = context.connection().noteURL(_what);
      }
      var data = !_what || _what.isNew() ? [] : [_what];
      var link3 = selection2.selectAll(".view-on-osm").data(data, function(d2) {
        return d2.id;
      });
      link3.exit().remove();
      var linkEnter = link3.enter().append("a").attr("class", "view-on-osm").attr("target", "_blank").attr("href", url).call(svgIcon("#iD-icon-out-link", "inline"));
      linkEnter.append("span").call(_t.append("inspector.view_on_osm"));
    }
    viewOnOSM.what = function(_2) {
      if (!arguments.length)
        return _what;
      _what = _2;
      return viewOnOSM;
    };
    return viewOnOSM;
  }

  // modules/ui/note_editor.js
  function uiNoteEditor(context) {
    var dispatch14 = dispatch_default("change");
    var noteComments = uiNoteComments(context);
    var noteHeader = uiNoteHeader();
    var _note;
    var _newNote;
    function noteEditor(selection2) {
      var header = selection2.selectAll(".header").data([0]);
      var headerEnter = header.enter().append("div").attr("class", "header fillL");
      headerEnter.append("button").attr("class", "close").attr("title", _t("icons.close")).on("click", function() {
        context.enter(modeBrowse(context));
      }).call(svgIcon("#iD-icon-close"));
      headerEnter.append("h2").call(_t.append("note.title"));
      var body = selection2.selectAll(".body").data([0]);
      body = body.enter().append("div").attr("class", "body").merge(body);
      var editor = body.selectAll(".note-editor").data([0]);
      editor.enter().append("div").attr("class", "modal-section note-editor").merge(editor).call(noteHeader.note(_note)).call(noteComments.note(_note)).call(noteSaveSection);
      var footer = selection2.selectAll(".footer").data([0]);
      footer.enter().append("div").attr("class", "footer").merge(footer).call(uiViewOnOSM(context).what(_note)).call(uiNoteReport(context).note(_note));
      var osm = services.osm;
      if (osm) {
        osm.on("change.note-save", function() {
          selection2.call(noteEditor);
        });
      }
    }
    function noteSaveSection(selection2) {
      var isSelected = _note && _note.id === context.selectedNoteID();
      var noteSave = selection2.selectAll(".note-save").data(isSelected ? [_note] : [], function(d2) {
        return d2.status + d2.id;
      });
      noteSave.exit().remove();
      var noteSaveEnter = noteSave.enter().append("div").attr("class", "note-save save-section cf");
      noteSaveEnter.append("h4").attr("class", ".note-save-header").text("").each(function() {
        if (_note.isNew()) {
          _t.append("note.newDescription")(select_default2(this));
        } else {
          _t.append("note.newComment")(select_default2(this));
        }
      });
      var commentTextarea = noteSaveEnter.append("textarea").attr("class", "new-comment-input").attr("placeholder", _t("note.inputPlaceholder")).attr("maxlength", 1e3).property("value", function(d2) {
        return d2.newComment;
      }).call(utilNoAuto).on("keydown.note-input", keydown).on("input.note-input", changeInput).on("blur.note-input", changeInput);
      if (!commentTextarea.empty() && _newNote) {
        commentTextarea.node().focus();
      }
      noteSave = noteSaveEnter.merge(noteSave).call(userDetails).call(noteSaveButtons);
      function keydown(d3_event) {
        if (!(d3_event.keyCode === 13 && // ↩ Return
        d3_event.metaKey))
          return;
        var osm = services.osm;
        if (!osm)
          return;
        var hasAuth = osm.authenticated();
        if (!hasAuth)
          return;
        if (!_note.newComment)
          return;
        d3_event.preventDefault();
        select_default2(this).on("keydown.note-input", null);
        window.setTimeout(function() {
          if (_note.isNew()) {
            noteSave.selectAll(".save-button").node().focus();
            clickSave(_note);
          } else {
            noteSave.selectAll(".comment-button").node().focus();
            clickComment(_note);
          }
        }, 10);
      }
      function changeInput() {
        var input = select_default2(this);
        var val = input.property("value").trim() || void 0;
        _note = _note.update({ newComment: val });
        var osm = services.osm;
        if (osm) {
          osm.replaceNote(_note);
        }
        noteSave.call(noteSaveButtons);
      }
    }
    function userDetails(selection2) {
      var detailSection = selection2.selectAll(".detail-section").data([0]);
      detailSection = detailSection.enter().append("div").attr("class", "detail-section").merge(detailSection);
      var osm = services.osm;
      if (!osm)
        return;
      var hasAuth = osm.authenticated();
      var authWarning = detailSection.selectAll(".auth-warning").data(hasAuth ? [] : [0]);
      authWarning.exit().transition().duration(200).style("opacity", 0).remove();
      var authEnter = authWarning.enter().insert("div", ".tag-reference-body").attr("class", "field-warning auth-warning").style("opacity", 0);
      authEnter.call(svgIcon("#iD-icon-alert", "inline"));
      authEnter.append("span").call(_t.append("note.login"));
      authEnter.append("a").attr("target", "_blank").call(svgIcon("#iD-icon-out-link", "inline")).append("span").call(_t.append("login")).on("click.note-login", function(d3_event) {
        d3_event.preventDefault();
        osm.authenticate();
      });
      authEnter.transition().duration(200).style("opacity", 1);
      var prose = detailSection.selectAll(".note-save-prose").data(hasAuth ? [0] : []);
      prose.exit().remove();
      prose = prose.enter().append("p").attr("class", "note-save-prose").call(_t.append("note.upload_explanation")).merge(prose);
      osm.userDetails(function(err, user) {
        if (err)
          return;
        var userLink = select_default2(document.createElement("div"));
        if (user.image_url) {
          userLink.append("img").attr("src", user.image_url).attr("class", "icon pre-text user-icon");
        }
        userLink.append("a").attr("class", "user-info").text(user.display_name).attr("href", osm.userURL(user.display_name)).attr("target", "_blank");
        prose.html(_t.html("note.upload_explanation_with_user", { user: { html: userLink.html() } }));
      });
    }
    function noteSaveButtons(selection2) {
      var osm = services.osm;
      var hasAuth = osm && osm.authenticated();
      var isSelected = _note && _note.id === context.selectedNoteID();
      var buttonSection = selection2.selectAll(".buttons").data(isSelected ? [_note] : [], function(d2) {
        return d2.status + d2.id;
      });
      buttonSection.exit().remove();
      var buttonEnter = buttonSection.enter().append("div").attr("class", "buttons");
      if (_note.isNew()) {
        buttonEnter.append("button").attr("class", "button cancel-button secondary-action").call(_t.append("confirm.cancel"));
        buttonEnter.append("button").attr("class", "button save-button action").call(_t.append("note.save"));
      } else {
        buttonEnter.append("button").attr("class", "button status-button action");
        buttonEnter.append("button").attr("class", "button comment-button action").call(_t.append("note.comment"));
      }
      buttonSection = buttonSection.merge(buttonEnter);
      buttonSection.select(".cancel-button").on("click.cancel", clickCancel);
      buttonSection.select(".save-button").attr("disabled", isSaveDisabled).on("click.save", clickSave);
      buttonSection.select(".status-button").attr("disabled", hasAuth ? null : true).text("").each(function(d2) {
        var action = d2.status === "open" ? "close" : "open";
        var andComment = d2.newComment ? "_comment" : "";
        _t.append("note." + action + andComment)(select_default2(this));
      });
      buttonSection.select(".status-button").on("click.status", clickStatus);
      buttonSection.select(".comment-button").attr("disabled", isSaveDisabled).on("click.comment", clickComment);
      function isSaveDisabled(d2) {
        return hasAuth && d2.status === "open" && d2.newComment ? null : true;
      }
    }
    function clickCancel(d3_event, d2) {
      this.blur();
      var osm = services.osm;
      if (osm) {
        osm.removeNote(d2);
      }
      context.enter(modeBrowse(context));
      dispatch14.call("change");
    }
    function clickSave(d3_event, d2) {
      this.blur();
      var osm = services.osm;
      if (osm) {
        osm.postNoteCreate(d2, function(err, note) {
          dispatch14.call("change", note);
        });
      }
    }
    function clickStatus(d3_event, d2) {
      this.blur();
      var osm = services.osm;
      if (osm) {
        var setStatus = d2.status === "open" ? "closed" : "open";
        osm.postNoteUpdate(d2, setStatus, function(err, note) {
          dispatch14.call("change", note);
        });
      }
    }
    function clickComment(d3_event, d2) {
      this.blur();
      var osm = services.osm;
      if (osm) {
        osm.postNoteUpdate(d2, d2.status, function(err, note) {
          dispatch14.call("change", note);
        });
      }
    }
    noteEditor.note = function(val) {
      if (!arguments.length)
        return _note;
      _note = val;
      return noteEditor;
    };
    noteEditor.newNote = function(val) {
      if (!arguments.length)
        return _newNote;
      _newNote = val;
      return noteEditor;
    };
    return utilRebind(noteEditor, dispatch14, "on");
  }

  // modules/modes/select_note.js
  function modeSelectNote(context, selectedNoteID) {
    var mode = {
      id: "select-note",
      button: "browse"
    };
    var _keybinding = utilKeybinding("select-note");
    var _noteEditor = uiNoteEditor(context).on("change", function() {
      context.map().pan([0, 0]);
      var note = checkSelectedID();
      if (!note)
        return;
      context.ui().sidebar.show(_noteEditor.note(note));
    });
    var _behaviors = [
      behaviorBreathe(context),
      behaviorHover(context),
      behaviorSelect(context),
      behaviorLasso(context),
      modeDragNode(context).behavior,
      modeDragNote(context).behavior
    ];
    var _newFeature = false;
    function checkSelectedID() {
      if (!services.osm)
        return;
      var note = services.osm.getNote(selectedNoteID);
      if (!note) {
        context.enter(modeBrowse(context));
      }
      return note;
    }
    function selectNote(d3_event, drawn) {
      if (!checkSelectedID())
        return;
      var selection2 = context.surface().selectAll(".layer-notes .note-" + selectedNoteID);
      if (selection2.empty()) {
        var source = d3_event && d3_event.type === "zoom" && d3_event.sourceEvent;
        if (drawn && source && (source.type === "pointermove" || source.type === "mousemove" || source.type === "touchmove")) {
          context.enter(modeBrowse(context));
        }
      } else {
        selection2.classed("selected", true);
        context.selectedNoteID(selectedNoteID);
      }
    }
    function esc() {
      if (context.container().select(".combobox").size())
        return;
      context.enter(modeBrowse(context));
    }
    mode.zoomToSelected = function() {
      if (!services.osm)
        return;
      var note = services.osm.getNote(selectedNoteID);
      if (note) {
        context.map().centerZoomEase(note.loc, 20);
      }
    };
    mode.newFeature = function(val) {
      if (!arguments.length)
        return _newFeature;
      _newFeature = val;
      return mode;
    };
    mode.enter = function() {
      var note = checkSelectedID();
      if (!note)
        return;
      _behaviors.forEach(context.install);
      _keybinding.on(_t("inspector.zoom_to.key"), mode.zoomToSelected).on("\u238B", esc, true);
      select_default2(document).call(_keybinding);
      selectNote();
      var sidebar = context.ui().sidebar;
      sidebar.show(_noteEditor.note(note).newNote(_newFeature));
      sidebar.expand(sidebar.intersects(note.extent()));
      context.map().on("drawn.select", selectNote);
    };
    mode.exit = function() {
      _behaviors.forEach(context.uninstall);
      select_default2(document).call(_keybinding.unbind);
      context.surface().selectAll(".layer-notes .selected").classed("selected hover", false);
      context.map().on("drawn.select", null);
      context.ui().sidebar.hide();
      context.selectedNoteID(null);
    };
    return mode;
  }

  // modules/modes/add_note.js
  function modeAddNote(context) {
    var mode = {
      id: "add-note",
      button: "note",
      description: _t.append("modes.add_note.description"),
      key: _t("modes.add_note.key")
    };
    var behavior = behaviorDraw(context).on("click", add).on("cancel", cancel).on("finish", cancel);
    function add(loc) {
      var osm = services.osm;
      if (!osm)
        return;
      var note = osmNote({ loc, status: "open", comments: [] });
      osm.replaceNote(note);
      context.map().pan([0, 0]);
      context.selectedNoteID(note.id).enter(modeSelectNote(context, note.id).newFeature(true));
    }
    function cancel() {
      context.enter(modeBrowse(context));
    }
    mode.enter = function() {
      context.install(behavior);
    };
    mode.exit = function() {
      context.uninstall(behavior);
    };
    return mode;
  }

  // node_modules/osm-community-index/lib/simplify.js
  var import_diacritics2 = __toESM(require_diacritics(), 1);
  function simplify(str) {
    if (typeof str !== "string")
      return "";
    return import_diacritics2.default.remove(
      str.replace(/&/g, "and").replace(/(İ|i̇)/ig, "i").replace(/[\s\-=_!"#%'*{},.\/:;?\(\)\[\]@\\$\^*+<>«»~`’\u00a1\u00a7\u00b6\u00b7\u00bf\u037e\u0387\u055a-\u055f\u0589\u05c0\u05c3\u05c6\u05f3\u05f4\u0609\u060a\u060c\u060d\u061b\u061e\u061f\u066a-\u066d\u06d4\u0700-\u070d\u07f7-\u07f9\u0830-\u083e\u085e\u0964\u0965\u0970\u0af0\u0df4\u0e4f\u0e5a\u0e5b\u0f04-\u0f12\u0f14\u0f85\u0fd0-\u0fd4\u0fd9\u0fda\u104a-\u104f\u10fb\u1360-\u1368\u166d\u166e\u16eb-\u16ed\u1735\u1736\u17d4-\u17d6\u17d8-\u17da\u1800-\u1805\u1807-\u180a\u1944\u1945\u1a1e\u1a1f\u1aa0-\u1aa6\u1aa8-\u1aad\u1b5a-\u1b60\u1bfc-\u1bff\u1c3b-\u1c3f\u1c7e\u1c7f\u1cc0-\u1cc7\u1cd3\u2000-\u206f\u2cf9-\u2cfc\u2cfe\u2cff\u2d70\u2e00-\u2e7f\u3001-\u3003\u303d\u30fb\ua4fe\ua4ff\ua60d-\ua60f\ua673\ua67e\ua6f2-\ua6f7\ua874-\ua877\ua8ce\ua8cf\ua8f8-\ua8fa\ua92e\ua92f\ua95f\ua9c1-\ua9cd\ua9de\ua9df\uaa5c-\uaa5f\uaade\uaadf\uaaf0\uaaf1\uabeb\ufe10-\ufe16\ufe19\ufe30\ufe45\ufe46\ufe49-\ufe4c\ufe50-\ufe52\ufe54-\ufe57\ufe5f-\ufe61\ufe68\ufe6a\ufe6b\ufeff\uff01-\uff03\uff05-\uff07\uff0a\uff0c\uff0e\uff0f\uff1a\uff1b\uff1f\uff20\uff3c\uff61\uff64\uff65]+/g, "").toLowerCase()
    );
  }

  // node_modules/osm-community-index/lib/resolve_strings.js
  function resolveStrings(item, defaults, localizerFn) {
    let itemStrings = Object.assign({}, item.strings);
    let defaultStrings = Object.assign({}, defaults[item.type]);
    const anyToken = new RegExp(/(\{\w+\})/, "gi");
    if (localizerFn) {
      if (itemStrings.community) {
        const communityID = simplify(itemStrings.community);
        itemStrings.community = localizerFn("_communities.".concat(communityID));
      }
      ["name", "description", "extendedDescription"].forEach((prop) => {
        if (defaultStrings[prop])
          defaultStrings[prop] = localizerFn("_defaults.".concat(item.type, ".").concat(prop));
        if (itemStrings[prop])
          itemStrings[prop] = localizerFn("".concat(item.id, ".").concat(prop));
      });
    }
    let replacements = {
      account: item.account,
      community: itemStrings.community,
      signupUrl: itemStrings.signupUrl,
      url: itemStrings.url
    };
    if (!replacements.signupUrl) {
      replacements.signupUrl = resolve(itemStrings.signupUrl || defaultStrings.signupUrl);
    }
    if (!replacements.url) {
      replacements.url = resolve(itemStrings.url || defaultStrings.url);
    }
    let resolved = {
      name: resolve(itemStrings.name || defaultStrings.name),
      url: resolve(itemStrings.url || defaultStrings.url),
      signupUrl: resolve(itemStrings.signupUrl || defaultStrings.signupUrl),
      description: resolve(itemStrings.description || defaultStrings.description),
      extendedDescription: resolve(itemStrings.extendedDescription || defaultStrings.extendedDescription)
    };
    resolved.nameHTML = linkify(resolved.url, resolved.name);
    resolved.urlHTML = linkify(resolved.url);
    resolved.signupUrlHTML = linkify(resolved.signupUrl);
    resolved.descriptionHTML = resolve(itemStrings.description || defaultStrings.description, true);
    resolved.extendedDescriptionHTML = resolve(itemStrings.extendedDescription || defaultStrings.extendedDescription, true);
    return resolved;
    function resolve(s2, addLinks) {
      if (!s2)
        return void 0;
      let result = s2;
      for (let key in replacements) {
        const token = "{".concat(key, "}");
        const regex = new RegExp(token, "g");
        if (regex.test(result)) {
          let replacement = replacements[key];
          if (!replacement) {
            throw new Error("Cannot resolve token: ".concat(token));
          } else {
            if (addLinks && (key === "signupUrl" || key === "url")) {
              replacement = linkify(replacement);
            }
            result = result.replace(regex, replacement);
          }
        }
      }
      const leftovers = result.match(anyToken);
      if (leftovers) {
        throw new Error("Cannot resolve tokens: ".concat(leftovers));
      }
      if (addLinks && item.type === "reddit") {
        result = result.replace(/(\/r\/\w+\/*)/i, (match) => linkify(resolved.url, match));
      }
      return result;
    }
    function linkify(url, text) {
      if (!url)
        return void 0;
      text = text || url;
      return '<a target="_blank" href="'.concat(url, '">').concat(text, "</a>");
    }
  }

  // modules/ui/success.js
  var _oci = null;
  function uiSuccess(context) {
    const MAXEVENTS = 2;
    const dispatch14 = dispatch_default("cancel");
    let _changeset2;
    let _location;
    ensureOSMCommunityIndex();
    function ensureOSMCommunityIndex() {
      const data = _mainFileFetcher;
      return Promise.all([
        data.get("oci_features"),
        data.get("oci_resources"),
        data.get("oci_defaults")
      ]).then((vals) => {
        if (_oci)
          return _oci;
        if (vals[0] && Array.isArray(vals[0].features)) {
          _sharedLocationManager.mergeCustomGeoJSON(vals[0]);
        }
        let ociResources = Object.values(vals[1].resources);
        if (ociResources.length) {
          return _sharedLocationManager.mergeLocationSets(ociResources).then(() => {
            _oci = {
              resources: ociResources,
              defaults: vals[2].defaults
            };
            return _oci;
          });
        } else {
          _oci = {
            resources: [],
            // no resources?
            defaults: vals[2].defaults
          };
          return _oci;
        }
      });
    }
    function parseEventDate(when) {
      if (!when)
        return;
      let raw = when.trim();
      if (!raw)
        return;
      if (!/Z$/.test(raw)) {
        raw += "Z";
      }
      const parsed = new Date(raw);
      return new Date(parsed.toUTCString().slice(0, 25));
    }
    function success(selection2) {
      let header = selection2.append("div").attr("class", "header fillL");
      header.append("h2").call(_t.append("success.just_edited"));
      header.append("button").attr("class", "close").attr("title", _t("icons.close")).on("click", () => dispatch14.call("cancel")).call(svgIcon("#iD-icon-close"));
      let body = selection2.append("div").attr("class", "body save-success fillL");
      let summary = body.append("div").attr("class", "save-summary");
      summary.append("h3").call(_t.append("success.thank_you" + (_location ? "_location" : ""), { where: _location }));
      summary.append("p").call(_t.append("success.help_html")).append("a").attr("class", "link-out").attr("target", "_blank").attr("href", _t("success.help_link_url")).call(svgIcon("#iD-icon-out-link", "inline")).append("span").call(_t.append("success.help_link_text"));
      let osm = context.connection();
      if (!osm)
        return;
      let changesetURL = osm.changesetURL(_changeset2.id);
      let table = summary.append("table").attr("class", "summary-table");
      let row = table.append("tr").attr("class", "summary-row");
      row.append("td").attr("class", "cell-icon summary-icon").append("a").attr("target", "_blank").attr("href", changesetURL).append("svg").attr("class", "logo-small").append("use").attr("xlink:href", "#iD-logo-osm");
      let summaryDetail = row.append("td").attr("class", "cell-detail summary-detail");
      summaryDetail.append("a").attr("class", "cell-detail summary-view-on-osm").attr("target", "_blank").attr("href", changesetURL).call(_t.append("success.view_on_osm"));
      summaryDetail.append("div").html(_t.html("success.changeset_id", {
        changeset_id: { html: '<a href="'.concat(changesetURL, '" target="_blank">').concat(_changeset2.id, "</a>") }
      }));
      if (showDonationMessage !== false) {
        const donationUrl = "https://supporting.openstreetmap.org/";
        let supporting = body.append("div").attr("class", "save-supporting");
        supporting.append("h3").call(_t.append("success.supporting.title"));
        supporting.append("p").call(_t.append("success.supporting.details"));
        table = supporting.append("table").attr("class", "supporting-table");
        row = table.append("tr").attr("class", "supporting-row");
        row.append("td").attr("class", "cell-icon supporting-icon").append("a").attr("target", "_blank").attr("href", donationUrl).append("svg").attr("class", "logo-small").append("use").attr("xlink:href", "#iD-donation");
        let supportingDetail = row.append("td").attr("class", "cell-detail supporting-detail");
        supportingDetail.append("a").attr("class", "cell-detail support-the-map").attr("target", "_blank").attr("href", donationUrl).call(_t.append("success.supporting.donation.title"));
        supportingDetail.append("div").call(_t.append("success.supporting.donation.details"));
      }
      ensureOSMCommunityIndex().then((oci) => {
        const loc = context.map().center();
        const validHere = _sharedLocationManager.locationSetsAt(loc);
        let communities = [];
        oci.resources.forEach((resource) => {
          let area = validHere[resource.locationSetID];
          if (!area)
            return;
          const localizer = (stringID) => _t.html("community.".concat(stringID));
          resource.resolved = resolveStrings(resource, oci.defaults, localizer);
          communities.push({
            area,
            order: resource.order || 0,
            resource
          });
        });
        communities.sort((a2, b2) => a2.area - b2.area || b2.order - a2.order);
        body.call(showCommunityLinks, communities.map((c2) => c2.resource));
      });
    }
    function showCommunityLinks(selection2, resources) {
      let communityLinks = selection2.append("div").attr("class", "save-communityLinks");
      communityLinks.append("h3").call(_t.append("success.like_osm"));
      let table = communityLinks.append("table").attr("class", "community-table");
      let row = table.selectAll(".community-row").data(resources);
      let rowEnter = row.enter().append("tr").attr("class", "community-row");
      rowEnter.append("td").attr("class", "cell-icon community-icon").append("a").attr("target", "_blank").attr("href", (d2) => d2.resolved.url).append("svg").attr("class", "logo-small").append("use").attr("xlink:href", (d2) => "#community-".concat(d2.type));
      let communityDetail = rowEnter.append("td").attr("class", "cell-detail community-detail");
      communityDetail.each(showCommunityDetails);
      communityLinks.append("div").attr("class", "community-missing").call(_t.append("success.missing")).append("a").attr("class", "link-out").attr("target", "_blank").call(svgIcon("#iD-icon-out-link", "inline")).attr("href", "https://github.com/osmlab/osm-community-index/issues").append("span").call(_t.append("success.tell_us"));
    }
    function showCommunityDetails(d2) {
      let selection2 = select_default2(this);
      let communityID = d2.id;
      selection2.append("div").attr("class", "community-name").html(d2.resolved.nameHTML);
      selection2.append("div").attr("class", "community-description").html(d2.resolved.descriptionHTML);
      if (d2.resolved.extendedDescriptionHTML || d2.languageCodes && d2.languageCodes.length) {
        selection2.append("div").call(
          uiDisclosure(context, "community-more-".concat(d2.id), false).expanded(false).updatePreference(false).label(() => _t.append("success.more")).content(showMore)
        );
      }
      let nextEvents = (d2.events || []).map((event) => {
        event.date = parseEventDate(event.when);
        return event;
      }).filter((event) => {
        const t2 = event.date.getTime();
        const now3 = (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
        return !isNaN(t2) && t2 >= now3;
      }).sort((a2, b2) => {
        return a2.date < b2.date ? -1 : a2.date > b2.date ? 1 : 0;
      }).slice(0, MAXEVENTS);
      if (nextEvents.length) {
        selection2.append("div").call(
          uiDisclosure(context, "community-events-".concat(d2.id), false).expanded(false).updatePreference(false).label(_t.html("success.events")).content(showNextEvents)
        ).select(".hide-toggle").append("span").attr("class", "badge-text").text(nextEvents.length);
      }
      function showMore(selection3) {
        let more = selection3.selectAll(".community-more").data([0]);
        let moreEnter = more.enter().append("div").attr("class", "community-more");
        if (d2.resolved.extendedDescriptionHTML) {
          moreEnter.append("div").attr("class", "community-extended-description").html(d2.resolved.extendedDescriptionHTML);
        }
        if (d2.languageCodes && d2.languageCodes.length) {
          const languageList = d2.languageCodes.map((code) => _mainLocalizer.languageName(code)).join(", ");
          moreEnter.append("div").attr("class", "community-languages").call(_t.append("success.languages", { languages: languageList }));
        }
      }
      function showNextEvents(selection3) {
        let events = selection3.append("div").attr("class", "community-events");
        let item = events.selectAll(".community-event").data(nextEvents);
        let itemEnter = item.enter().append("div").attr("class", "community-event");
        itemEnter.append("div").attr("class", "community-event-name").append("a").attr("target", "_blank").attr("href", (d4) => d4.url).text((d4) => {
          let name = d4.name;
          if (d4.i18n && d4.id) {
            name = _t("community.".concat(communityID, ".events.").concat(d4.id, ".name"), { default: name });
          }
          return name;
        });
        itemEnter.append("div").attr("class", "community-event-when").text((d4) => {
          let options2 = { weekday: "short", day: "numeric", month: "short", year: "numeric" };
          if (d4.date.getHours() || d4.date.getMinutes()) {
            options2.hour = "numeric";
            options2.minute = "numeric";
          }
          return d4.date.toLocaleString(_mainLocalizer.localeCode(), options2);
        });
        itemEnter.append("div").attr("class", "community-event-where").text((d4) => {
          let where = d4.where;
          if (d4.i18n && d4.id) {
            where = _t("community.".concat(communityID, ".events.").concat(d4.id, ".where"), { default: where });
          }
          return where;
        });
        itemEnter.append("div").attr("class", "community-event-description").text((d4) => {
          let description = d4.description;
          if (d4.i18n && d4.id) {
            description = _t("community.".concat(communityID, ".events.").concat(d4.id, ".description"), { default: description });
          }
          return description;
        });
      }
    }
    success.changeset = function(val) {
      if (!arguments.length)
        return _changeset2;
      _changeset2 = val;
      return success;
    };
    success.location = function(val) {
      if (!arguments.length)
        return _location;
      _location = val;
      return success;
    };
    return utilRebind(success, dispatch14, "on");
  }

  // modules/modes/save.js
  function modeSave(context) {
    var mode = { id: "save" };
    var keybinding = utilKeybinding("modeSave");
    var commit = uiCommit(context).on("cancel", cancel);
    var _conflictsUi;
    var _location;
    var _success;
    var uploader = context.uploader().on("saveStarted.modeSave", function() {
      keybindingOff();
    }).on("willAttemptUpload.modeSave", prepareForSuccess).on("progressChanged.modeSave", showProgress).on("resultNoChanges.modeSave", function() {
      cancel();
    }).on("resultErrors.modeSave", showErrors).on("resultConflicts.modeSave", showConflicts).on("resultSuccess.modeSave", showSuccess);
    function cancel() {
      context.enter(modeBrowse(context));
    }
    function showProgress(num, total) {
      var modal = context.container().select(".loading-modal .modal-section");
      var progress = modal.selectAll(".progress").data([0]);
      progress.enter().append("div").attr("class", "progress").merge(progress).text(_t("save.conflict_progress", { num, total }));
    }
    function showConflicts(changeset, conflicts, origChanges) {
      var selection2 = context.container().select(".sidebar").append("div").attr("class", "sidebar-component");
      context.container().selectAll(".main-content").classed("active", true).classed("inactive", false);
      _conflictsUi = uiConflicts(context).conflictList(conflicts).origChanges(origChanges).on("cancel", function() {
        context.container().selectAll(".main-content").classed("active", false).classed("inactive", true);
        selection2.remove();
        keybindingOn();
        uploader.cancelConflictResolution();
      }).on("save", function() {
        context.container().selectAll(".main-content").classed("active", false).classed("inactive", true);
        selection2.remove();
        uploader.processResolvedConflicts(changeset);
      });
      selection2.call(_conflictsUi);
    }
    function showErrors(errors) {
      keybindingOn();
      var selection2 = uiConfirm(context.container());
      selection2.select(".modal-section.header").append("h3").text(_t("save.error"));
      addErrors(selection2, errors);
      selection2.okButton();
    }
    function addErrors(selection2, data) {
      var message = selection2.select(".modal-section.message-text");
      var items = message.selectAll(".error-container").data(data);
      var enter = items.enter().append("div").attr("class", "error-container");
      enter.append("a").attr("class", "error-description").attr("href", "#").classed("hide-toggle", true).text(function(d2) {
        return d2.msg || _t("save.unknown_error_details");
      }).on("click", function(d3_event) {
        d3_event.preventDefault();
        var error = select_default2(this);
        var detail = select_default2(this.nextElementSibling);
        var exp2 = error.classed("expanded");
        detail.style("display", exp2 ? "none" : "block");
        error.classed("expanded", !exp2);
      });
      var details = enter.append("div").attr("class", "error-detail-container").style("display", "none");
      details.append("ul").attr("class", "error-detail-list").selectAll("li").data(function(d2) {
        return d2.details || [];
      }).enter().append("li").attr("class", "error-detail-item").text(function(d2) {
        return d2;
      });
      items.exit().remove();
    }
    function showSuccess(changeset) {
      commit.reset();
      var ui = _success.changeset(changeset).location(_location).on("cancel", function() {
        context.ui().sidebar.hide();
      });
      context.enter(modeBrowse(context).sidebar(ui));
    }
    function keybindingOn() {
      select_default2(document).call(keybinding.on("\u238B", cancel, true));
    }
    function keybindingOff() {
      select_default2(document).call(keybinding.unbind);
    }
    function prepareForSuccess() {
      _success = uiSuccess(context);
      _location = null;
      if (!services.geocoder)
        return;
      services.geocoder.reverse(context.map().center(), function(err, result) {
        if (err || !result || !result.address)
          return;
        var addr = result.address;
        var place = addr && (addr.town || addr.city || addr.county) || "";
        var region = addr && (addr.state || addr.country) || "";
        var separator = place && region ? _t("success.thank_you_where.separator") : "";
        _location = _t(
          "success.thank_you_where.format",
          { place, separator, region }
        );
      });
    }
    mode.selectedIDs = function() {
      return _conflictsUi ? _conflictsUi.shownEntityIds() : [];
    };
    mode.enter = function() {
      context.ui().sidebar.expand();
      function done() {
        context.ui().sidebar.show(commit);
      }
      keybindingOn();
      context.container().selectAll(".main-content").classed("active", false).classed("inactive", true);
      var osm = context.connection();
      if (!osm) {
        cancel();
        return;
      }
      if (osm.authenticated()) {
        done();
      } else {
        osm.authenticate(function(err) {
          if (err) {
            cancel();
          } else {
            done();
          }
        });
      }
    };
    mode.exit = function() {
      keybindingOff();
      context.container().selectAll(".main-content").classed("active", true).classed("inactive", false);
      context.ui().sidebar.hide();
    };
    return mode;
  }

  // modules/ui/improveOSM_comments.js
  function uiImproveOsmComments() {
    let _qaItem;
    function issueComments(selection2) {
      let comments = selection2.selectAll(".comments-container").data([0]);
      comments = comments.enter().append("div").attr("class", "comments-container").merge(comments);
      services.improveOSM.getComments(_qaItem).then((d2) => {
        if (!d2.comments)
          return;
        const commentEnter = comments.selectAll(".comment").data(d2.comments).enter().append("div").attr("class", "comment");
        commentEnter.append("div").attr("class", "comment-avatar").call(svgIcon("#iD-icon-avatar", "comment-avatar-icon"));
        const mainEnter = commentEnter.append("div").attr("class", "comment-main");
        const metadataEnter = mainEnter.append("div").attr("class", "comment-metadata");
        metadataEnter.append("div").attr("class", "comment-author").each(function(d4) {
          const osm = services.osm;
          let selection3 = select_default2(this);
          if (osm && d4.username) {
            selection3 = selection3.append("a").attr("class", "comment-author-link").attr("href", osm.userURL(d4.username)).attr("target", "_blank");
          }
          selection3.text((d5) => d5.username);
        });
        metadataEnter.append("div").attr("class", "comment-date").html((d4) => _t.html("note.status.commented", { when: localeDateString2(d4.timestamp) }));
        mainEnter.append("div").attr("class", "comment-text").append("p").text((d4) => d4.text);
      }).catch((err) => {
        console.log(err);
      });
    }
    function localeDateString2(s2) {
      if (!s2)
        return null;
      const options2 = { day: "numeric", month: "short", year: "numeric" };
      const d2 = new Date(s2 * 1e3);
      if (isNaN(d2.getTime()))
        return null;
      return d2.toLocaleDateString(_mainLocalizer.localeCode(), options2);
    }
    issueComments.issue = function(val) {
      if (!arguments.length)
        return _qaItem;
      _qaItem = val;
      return issueComments;
    };
    return issueComments;
  }

  // modules/ui/improveOSM_details.js
  function uiImproveOsmDetails(context) {
    let _qaItem;
    function issueDetail(d2) {
      if (d2.desc)
        return d2.desc;
      const issueKey = d2.issueKey;
      d2.replacements = d2.replacements || {};
      d2.replacements.default = { html: _t.html("inspector.unknown") };
      return _t.html("QA.improveOSM.error_types.".concat(issueKey, ".description"), d2.replacements);
    }
    function improveOsmDetails(selection2) {
      const details = selection2.selectAll(".error-details").data(
        _qaItem ? [_qaItem] : [],
        (d2) => "".concat(d2.id, "-").concat(d2.status || 0)
      );
      details.exit().remove();
      const detailsEnter = details.enter().append("div").attr("class", "error-details qa-details-container");
      const descriptionEnter = detailsEnter.append("div").attr("class", "qa-details-subsection");
      descriptionEnter.append("h4").call(_t.append("QA.keepRight.detail_description"));
      descriptionEnter.append("div").attr("class", "qa-details-description-text").html(issueDetail);
      let relatedEntities = [];
      descriptionEnter.selectAll(".error_entity_link, .error_object_link").attr("href", "#").each(function() {
        const link3 = select_default2(this);
        const isObjectLink = link3.classed("error_object_link");
        const entityID = isObjectLink ? utilEntityRoot(_qaItem.objectType) + _qaItem.objectId : this.textContent;
        const entity = context.hasEntity(entityID);
        relatedEntities.push(entityID);
        link3.on("mouseenter", () => {
          utilHighlightEntities([entityID], true, context);
        }).on("mouseleave", () => {
          utilHighlightEntities([entityID], false, context);
        }).on("click", (d3_event) => {
          d3_event.preventDefault();
          utilHighlightEntities([entityID], false, context);
          const osmlayer = context.layers().layer("osm");
          if (!osmlayer.enabled()) {
            osmlayer.enabled(true);
          }
          context.map().centerZoom(_qaItem.loc, 20);
          if (entity) {
            context.enter(modeSelect(context, [entityID]));
          } else {
            context.loadEntity(entityID, (err, result) => {
              if (err)
                return;
              const entity2 = result.data.find((e3) => e3.id === entityID);
              if (entity2)
                context.enter(modeSelect(context, [entityID]));
            });
          }
        });
        if (entity) {
          let name = utilDisplayName(entity);
          if (!name && !isObjectLink) {
            const preset = _mainPresetIndex.match(entity, context.graph());
            name = preset && !preset.isFallback() && preset.name();
          }
          if (name) {
            this.innerText = name;
          }
        }
      });
      context.features().forceVisible(relatedEntities);
      context.map().pan([0, 0]);
    }
    improveOsmDetails.issue = function(val) {
      if (!arguments.length)
        return _qaItem;
      _qaItem = val;
      return improveOsmDetails;
    };
    return improveOsmDetails;
  }

  // modules/ui/improveOSM_header.js
  function uiImproveOsmHeader() {
    let _qaItem;
    function issueTitle(d2) {
      const issueKey = d2.issueKey;
      d2.replacements = d2.replacements || {};
      d2.replacements.default = { html: _t.html("inspector.unknown") };
      return _t.html("QA.improveOSM.error_types.".concat(issueKey, ".title"), d2.replacements);
    }
    function improveOsmHeader(selection2) {
      const header = selection2.selectAll(".qa-header").data(
        _qaItem ? [_qaItem] : [],
        (d2) => "".concat(d2.id, "-").concat(d2.status || 0)
      );
      header.exit().remove();
      const headerEnter = header.enter().append("div").attr("class", "qa-header");
      const svgEnter = headerEnter.append("div").attr("class", "qa-header-icon").classed("new", (d2) => d2.id < 0).append("svg").attr("width", "20px").attr("height", "30px").attr("viewbox", "0 0 20 30").attr("class", (d2) => "preset-icon-28 qaItem ".concat(d2.service, " itemId-").concat(d2.id, " itemType-").concat(d2.itemType));
      svgEnter.append("polygon").attr("fill", "currentColor").attr("class", "qaItem-fill").attr("points", "16,3 4,3 1,6 1,17 4,20 7,20 10,27 13,20 16,20 19,17.033 19,6");
      svgEnter.append("use").attr("class", "icon-annotation").attr("width", "12px").attr("height", "12px").attr("transform", "translate(4, 5.5)").attr("xlink:href", (d2) => d2.icon ? "#" + d2.icon : "");
      headerEnter.append("div").attr("class", "qa-header-label").html(issueTitle);
    }
    improveOsmHeader.issue = function(val) {
      if (!arguments.length)
        return _qaItem;
      _qaItem = val;
      return improveOsmHeader;
    };
    return improveOsmHeader;
  }

  // modules/ui/improveOSM_editor.js
  function uiImproveOsmEditor(context) {
    const dispatch14 = dispatch_default("change");
    const qaDetails = uiImproveOsmDetails(context);
    const qaComments = uiImproveOsmComments(context);
    const qaHeader = uiImproveOsmHeader(context);
    let _qaItem;
    function improveOsmEditor(selection2) {
      const headerEnter = selection2.selectAll(".header").data([0]).enter().append("div").attr("class", "header fillL");
      headerEnter.append("button").attr("class", "close").attr("title", _t("icons.close")).on("click", () => context.enter(modeBrowse(context))).call(svgIcon("#iD-icon-close"));
      headerEnter.append("h2").call(_t.append("QA.improveOSM.title"));
      let body = selection2.selectAll(".body").data([0]);
      body = body.enter().append("div").attr("class", "body").merge(body);
      const editor = body.selectAll(".qa-editor").data([0]);
      editor.enter().append("div").attr("class", "modal-section qa-editor").merge(editor).call(qaHeader.issue(_qaItem)).call(qaDetails.issue(_qaItem)).call(qaComments.issue(_qaItem)).call(improveOsmSaveSection);
    }
    function improveOsmSaveSection(selection2) {
      const isSelected = _qaItem && _qaItem.id === context.selectedErrorID();
      const isShown = _qaItem && (isSelected || _qaItem.newComment || _qaItem.comment);
      let saveSection = selection2.selectAll(".qa-save").data(
        isShown ? [_qaItem] : [],
        (d2) => "".concat(d2.id, "-").concat(d2.status || 0)
      );
      saveSection.exit().remove();
      const saveSectionEnter = saveSection.enter().append("div").attr("class", "qa-save save-section cf");
      saveSectionEnter.append("h4").attr("class", ".qa-save-header").call(_t.append("note.newComment"));
      saveSectionEnter.append("textarea").attr("class", "new-comment-input").attr("placeholder", _t("QA.keepRight.comment_placeholder")).attr("maxlength", 1e3).property("value", (d2) => d2.newComment).call(utilNoAuto).on("input", changeInput).on("blur", changeInput);
      saveSection = saveSectionEnter.merge(saveSection).call(qaSaveButtons);
      function changeInput() {
        const input = select_default2(this);
        let val = input.property("value").trim();
        if (val === "") {
          val = void 0;
        }
        _qaItem = _qaItem.update({ newComment: val });
        const qaService = services.improveOSM;
        if (qaService) {
          qaService.replaceItem(_qaItem);
        }
        saveSection.call(qaSaveButtons);
      }
    }
    function qaSaveButtons(selection2) {
      const isSelected = _qaItem && _qaItem.id === context.selectedErrorID();
      let buttonSection = selection2.selectAll(".buttons").data(isSelected ? [_qaItem] : [], (d2) => d2.status + d2.id);
      buttonSection.exit().remove();
      const buttonEnter = buttonSection.enter().append("div").attr("class", "buttons");
      buttonEnter.append("button").attr("class", "button comment-button action").call(_t.append("QA.keepRight.save_comment"));
      buttonEnter.append("button").attr("class", "button close-button action");
      buttonEnter.append("button").attr("class", "button ignore-button action");
      buttonSection = buttonSection.merge(buttonEnter);
      buttonSection.select(".comment-button").attr("disabled", (d2) => d2.newComment ? null : true).on("click.comment", function(d3_event, d2) {
        this.blur();
        const qaService = services.improveOSM;
        if (qaService) {
          qaService.postUpdate(d2, (err, item) => dispatch14.call("change", item));
        }
      });
      buttonSection.select(".close-button").html((d2) => {
        const andComment = d2.newComment ? "_comment" : "";
        return _t.html("QA.keepRight.close".concat(andComment));
      }).on("click.close", function(d3_event, d2) {
        this.blur();
        const qaService = services.improveOSM;
        if (qaService) {
          d2.newStatus = "SOLVED";
          qaService.postUpdate(d2, (err, item) => dispatch14.call("change", item));
        }
      });
      buttonSection.select(".ignore-button").html((d2) => {
        const andComment = d2.newComment ? "_comment" : "";
        return _t.html("QA.keepRight.ignore".concat(andComment));
      }).on("click.ignore", function(d3_event, d2) {
        this.blur();
        const qaService = services.improveOSM;
        if (qaService) {
          d2.newStatus = "INVALID";
          qaService.postUpdate(d2, (err, item) => dispatch14.call("change", item));
        }
      });
    }
    improveOsmEditor.error = function(val) {
      if (!arguments.length)
        return _qaItem;
      _qaItem = val;
      return improveOsmEditor;
    };
    return utilRebind(improveOsmEditor, dispatch14, "on");
  }

  // modules/ui/keepRight_details.js
  function uiKeepRightDetails(context) {
    let _qaItem;
    function issueDetail(d2) {
      const { itemType, parentIssueType } = d2;
      const unknown = { html: _t.html("inspector.unknown") };
      let replacements = d2.replacements || {};
      replacements.default = unknown;
      if (_mainLocalizer.hasTextForStringId("QA.keepRight.errorTypes.".concat(itemType, ".title"))) {
        return _t.html("QA.keepRight.errorTypes.".concat(itemType, ".description"), replacements);
      } else {
        return _t.html("QA.keepRight.errorTypes.".concat(parentIssueType, ".description"), replacements);
      }
    }
    function keepRightDetails(selection2) {
      const details = selection2.selectAll(".error-details").data(
        _qaItem ? [_qaItem] : [],
        (d2) => "".concat(d2.id, "-").concat(d2.status || 0)
      );
      details.exit().remove();
      const detailsEnter = details.enter().append("div").attr("class", "error-details qa-details-container");
      const descriptionEnter = detailsEnter.append("div").attr("class", "qa-details-subsection");
      descriptionEnter.append("h4").call(_t.append("QA.keepRight.detail_description"));
      descriptionEnter.append("div").attr("class", "qa-details-description-text").html(issueDetail);
      let relatedEntities = [];
      descriptionEnter.selectAll(".error_entity_link, .error_object_link").attr("href", "#").each(function() {
        const link3 = select_default2(this);
        const isObjectLink = link3.classed("error_object_link");
        const entityID = isObjectLink ? utilEntityRoot(_qaItem.objectType) + _qaItem.objectId : this.textContent;
        const entity = context.hasEntity(entityID);
        relatedEntities.push(entityID);
        link3.on("mouseenter", () => {
          utilHighlightEntities([entityID], true, context);
        }).on("mouseleave", () => {
          utilHighlightEntities([entityID], false, context);
        }).on("click", (d3_event) => {
          d3_event.preventDefault();
          utilHighlightEntities([entityID], false, context);
          const osmlayer = context.layers().layer("osm");
          if (!osmlayer.enabled()) {
            osmlayer.enabled(true);
          }
          context.map().centerZoomEase(_qaItem.loc, 20);
          if (entity) {
            context.enter(modeSelect(context, [entityID]));
          } else {
            context.loadEntity(entityID, (err, result) => {
              if (err)
                return;
              const entity2 = result.data.find((e3) => e3.id === entityID);
              if (entity2)
                context.enter(modeSelect(context, [entityID]));
            });
          }
        });
        if (entity) {
          let name = utilDisplayName(entity);
          if (!name && !isObjectLink) {
            const preset = _mainPresetIndex.match(entity, context.graph());
            name = preset && !preset.isFallback() && preset.name();
          }
          if (name) {
            this.innerText = name;
          }
        }
      });
      context.features().forceVisible(relatedEntities);
      context.map().pan([0, 0]);
    }
    keepRightDetails.issue = function(val) {
      if (!arguments.length)
        return _qaItem;
      _qaItem = val;
      return keepRightDetails;
    };
    return keepRightDetails;
  }

  // modules/ui/keepRight_header.js
  function uiKeepRightHeader() {
    let _qaItem;
    function issueTitle(d2) {
      const { itemType, parentIssueType } = d2;
      const unknown = _t.html("inspector.unknown");
      let replacements = d2.replacements || {};
      replacements.default = { html: unknown };
      if (_mainLocalizer.hasTextForStringId("QA.keepRight.errorTypes.".concat(itemType, ".title"))) {
        return _t.html("QA.keepRight.errorTypes.".concat(itemType, ".title"), replacements);
      } else {
        return _t.html("QA.keepRight.errorTypes.".concat(parentIssueType, ".title"), replacements);
      }
    }
    function keepRightHeader(selection2) {
      const header = selection2.selectAll(".qa-header").data(
        _qaItem ? [_qaItem] : [],
        (d2) => "".concat(d2.id, "-").concat(d2.status || 0)
      );
      header.exit().remove();
      const headerEnter = header.enter().append("div").attr("class", "qa-header");
      const iconEnter = headerEnter.append("div").attr("class", "qa-header-icon").classed("new", (d2) => d2.id < 0);
      iconEnter.append("div").attr("class", (d2) => "preset-icon-28 qaItem ".concat(d2.service, " itemId-").concat(d2.id, " itemType-").concat(d2.parentIssueType)).call(svgIcon("#iD-icon-bolt", "qaItem-fill"));
      headerEnter.append("div").attr("class", "qa-header-label").html(issueTitle);
    }
    keepRightHeader.issue = function(val) {
      if (!arguments.length)
        return _qaItem;
      _qaItem = val;
      return keepRightHeader;
    };
    return keepRightHeader;
  }

  // modules/ui/view_on_keepRight.js
  function uiViewOnKeepRight() {
    let _qaItem;
    function viewOnKeepRight(selection2) {
      let url;
      if (services.keepRight && _qaItem instanceof QAItem) {
        url = services.keepRight.issueURL(_qaItem);
      }
      const link3 = selection2.selectAll(".view-on-keepRight").data(url ? [url] : []);
      link3.exit().remove();
      const linkEnter = link3.enter().append("a").attr("class", "view-on-keepRight").attr("target", "_blank").attr("rel", "noopener").attr("href", (d2) => d2).call(svgIcon("#iD-icon-out-link", "inline"));
      linkEnter.append("span").call(_t.append("inspector.view_on_keepRight"));
    }
    viewOnKeepRight.what = function(val) {
      if (!arguments.length)
        return _qaItem;
      _qaItem = val;
      return viewOnKeepRight;
    };
    return viewOnKeepRight;
  }

  // modules/ui/keepRight_editor.js
  function uiKeepRightEditor(context) {
    const dispatch14 = dispatch_default("change");
    const qaDetails = uiKeepRightDetails(context);
    const qaHeader = uiKeepRightHeader(context);
    let _qaItem;
    function keepRightEditor(selection2) {
      const headerEnter = selection2.selectAll(".header").data([0]).enter().append("div").attr("class", "header fillL");
      headerEnter.append("button").attr("class", "close").attr("title", _t("icons.close")).on("click", () => context.enter(modeBrowse(context))).call(svgIcon("#iD-icon-close"));
      headerEnter.append("h2").call(_t.append("QA.keepRight.title"));
      let body = selection2.selectAll(".body").data([0]);
      body = body.enter().append("div").attr("class", "body").merge(body);
      const editor = body.selectAll(".qa-editor").data([0]);
      editor.enter().append("div").attr("class", "modal-section qa-editor").merge(editor).call(qaHeader.issue(_qaItem)).call(qaDetails.issue(_qaItem)).call(keepRightSaveSection);
      const footer = selection2.selectAll(".footer").data([0]);
      footer.enter().append("div").attr("class", "footer").merge(footer).call(uiViewOnKeepRight(context).what(_qaItem));
    }
    function keepRightSaveSection(selection2) {
      const isSelected = _qaItem && _qaItem.id === context.selectedErrorID();
      const isShown = _qaItem && (isSelected || _qaItem.newComment || _qaItem.comment);
      let saveSection = selection2.selectAll(".qa-save").data(
        isShown ? [_qaItem] : [],
        (d2) => "".concat(d2.id, "-").concat(d2.status || 0)
      );
      saveSection.exit().remove();
      const saveSectionEnter = saveSection.enter().append("div").attr("class", "qa-save save-section cf");
      saveSectionEnter.append("h4").attr("class", ".qa-save-header").call(_t.append("QA.keepRight.comment"));
      saveSectionEnter.append("textarea").attr("class", "new-comment-input").attr("placeholder", _t("QA.keepRight.comment_placeholder")).attr("maxlength", 1e3).property("value", (d2) => d2.newComment || d2.comment).call(utilNoAuto).on("input", changeInput).on("blur", changeInput);
      saveSection = saveSectionEnter.merge(saveSection).call(qaSaveButtons);
      function changeInput() {
        const input = select_default2(this);
        let val = input.property("value").trim();
        if (val === _qaItem.comment) {
          val = void 0;
        }
        _qaItem = _qaItem.update({ newComment: val });
        const qaService = services.keepRight;
        if (qaService) {
          qaService.replaceItem(_qaItem);
        }
        saveSection.call(qaSaveButtons);
      }
    }
    function qaSaveButtons(selection2) {
      const isSelected = _qaItem && _qaItem.id === context.selectedErrorID();
      let buttonSection = selection2.selectAll(".buttons").data(isSelected ? [_qaItem] : [], (d2) => d2.status + d2.id);
      buttonSection.exit().remove();
      const buttonEnter = buttonSection.enter().append("div").attr("class", "buttons");
      buttonEnter.append("button").attr("class", "button comment-button action").call(_t.append("QA.keepRight.save_comment"));
      buttonEnter.append("button").attr("class", "button close-button action");
      buttonEnter.append("button").attr("class", "button ignore-button action");
      buttonSection = buttonSection.merge(buttonEnter);
      buttonSection.select(".comment-button").attr("disabled", (d2) => d2.newComment ? null : true).on("click.comment", function(d3_event, d2) {
        this.blur();
        const qaService = services.keepRight;
        if (qaService) {
          qaService.postUpdate(d2, (err, item) => dispatch14.call("change", item));
        }
      });
      buttonSection.select(".close-button").html((d2) => {
        const andComment = d2.newComment ? "_comment" : "";
        return _t.html("QA.keepRight.close".concat(andComment));
      }).on("click.close", function(d3_event, d2) {
        this.blur();
        const qaService = services.keepRight;
        if (qaService) {
          d2.newStatus = "ignore_t";
          qaService.postUpdate(d2, (err, item) => dispatch14.call("change", item));
        }
      });
      buttonSection.select(".ignore-button").html((d2) => {
        const andComment = d2.newComment ? "_comment" : "";
        return _t.html("QA.keepRight.ignore".concat(andComment));
      }).on("click.ignore", function(d3_event, d2) {
        this.blur();
        const qaService = services.keepRight;
        if (qaService) {
          d2.newStatus = "ignore";
          qaService.postUpdate(d2, (err, item) => dispatch14.call("change", item));
        }
      });
    }
    keepRightEditor.error = function(val) {
      if (!arguments.length)
        return _qaItem;
      _qaItem = val;
      return keepRightEditor;
    };
    return utilRebind(keepRightEditor, dispatch14, "on");
  }

  // modules/ui/osmose_details.js
  function uiOsmoseDetails(context) {
    let _qaItem;
    function issueString(d2, type2) {
      if (!d2)
        return "";
      const s2 = services.osmose.getStrings(d2.itemType);
      return type2 in s2 ? s2[type2] : "";
    }
    function osmoseDetails(selection2) {
      const details = selection2.selectAll(".error-details").data(
        _qaItem ? [_qaItem] : [],
        (d2) => "".concat(d2.id, "-").concat(d2.status || 0)
      );
      details.exit().remove();
      const detailsEnter = details.enter().append("div").attr("class", "error-details qa-details-container");
      if (issueString(_qaItem, "detail")) {
        const div = detailsEnter.append("div").attr("class", "qa-details-subsection");
        div.append("h4").call(_t.append("QA.keepRight.detail_description"));
        div.append("p").attr("class", "qa-details-description-text").html((d2) => issueString(d2, "detail")).selectAll("a").attr("rel", "noopener").attr("target", "_blank");
      }
      const detailsDiv = detailsEnter.append("div").attr("class", "qa-details-subsection");
      const elemsDiv = detailsEnter.append("div").attr("class", "qa-details-subsection");
      if (issueString(_qaItem, "fix")) {
        const div = detailsEnter.append("div").attr("class", "qa-details-subsection");
        div.append("h4").call(_t.append("QA.osmose.fix_title"));
        div.append("p").html((d2) => issueString(d2, "fix")).selectAll("a").attr("rel", "noopener").attr("target", "_blank");
      }
      if (issueString(_qaItem, "trap")) {
        const div = detailsEnter.append("div").attr("class", "qa-details-subsection");
        div.append("h4").call(_t.append("QA.osmose.trap_title"));
        div.append("p").html((d2) => issueString(d2, "trap")).selectAll("a").attr("rel", "noopener").attr("target", "_blank");
      }
      const thisItem = _qaItem;
      services.osmose.loadIssueDetail(_qaItem).then((d2) => {
        if (!d2.elems || d2.elems.length === 0)
          return;
        if (context.selectedErrorID() !== thisItem.id && context.container().selectAll(".qaItem.osmose.hover.itemId-".concat(thisItem.id)).empty())
          return;
        if (d2.detail) {
          detailsDiv.append("h4").call(_t.append("QA.osmose.detail_title"));
          detailsDiv.append("p").html((d4) => d4.detail).selectAll("a").attr("rel", "noopener").attr("target", "_blank");
        }
        elemsDiv.append("h4").call(_t.append("QA.osmose.elems_title"));
        elemsDiv.append("ul").selectAll("li").data(d2.elems).enter().append("li").append("a").attr("href", "#").attr("class", "error_entity_link").text((d4) => d4).each(function() {
          const link3 = select_default2(this);
          const entityID = this.textContent;
          const entity = context.hasEntity(entityID);
          link3.on("mouseenter", () => {
            utilHighlightEntities([entityID], true, context);
          }).on("mouseleave", () => {
            utilHighlightEntities([entityID], false, context);
          }).on("click", (d3_event) => {
            d3_event.preventDefault();
            utilHighlightEntities([entityID], false, context);
            const osmlayer = context.layers().layer("osm");
            if (!osmlayer.enabled()) {
              osmlayer.enabled(true);
            }
            context.map().centerZoom(d2.loc, 20);
            if (entity) {
              context.enter(modeSelect(context, [entityID]));
            } else {
              context.loadEntity(entityID, (err, result) => {
                if (err)
                  return;
                const entity2 = result.data.find((e3) => e3.id === entityID);
                if (entity2)
                  context.enter(modeSelect(context, [entityID]));
              });
            }
          });
          if (entity) {
            let name = utilDisplayName(entity);
            if (!name) {
              const preset = _mainPresetIndex.match(entity, context.graph());
              name = preset && !preset.isFallback() && preset.name();
            }
            if (name) {
              this.innerText = name;
            }
          }
        });
        context.features().forceVisible(d2.elems);
        context.map().pan([0, 0]);
      }).catch((err) => {
        console.log(err);
      });
    }
    osmoseDetails.issue = function(val) {
      if (!arguments.length)
        return _qaItem;
      _qaItem = val;
      return osmoseDetails;
    };
    return osmoseDetails;
  }

  // modules/ui/osmose_header.js
  function uiOsmoseHeader() {
    let _qaItem;
    function issueTitle(d2) {
      const unknown = _t("inspector.unknown");
      if (!d2)
        return unknown;
      const s2 = services.osmose.getStrings(d2.itemType);
      return "title" in s2 ? s2.title : unknown;
    }
    function osmoseHeader(selection2) {
      const header = selection2.selectAll(".qa-header").data(
        _qaItem ? [_qaItem] : [],
        (d2) => "".concat(d2.id, "-").concat(d2.status || 0)
      );
      header.exit().remove();
      const headerEnter = header.enter().append("div").attr("class", "qa-header");
      const svgEnter = headerEnter.append("div").attr("class", "qa-header-icon").classed("new", (d2) => d2.id < 0).append("svg").attr("width", "20px").attr("height", "30px").attr("viewbox", "0 0 20 30").attr("class", (d2) => "preset-icon-28 qaItem ".concat(d2.service, " itemId-").concat(d2.id, " itemType-").concat(d2.itemType));
      svgEnter.append("polygon").attr("fill", (d2) => services.osmose.getColor(d2.item)).attr("class", "qaItem-fill").attr("points", "16,3 4,3 1,6 1,17 4,20 7,20 10,27 13,20 16,20 19,17.033 19,6");
      svgEnter.append("use").attr("class", "icon-annotation").attr("width", "12px").attr("height", "12px").attr("transform", "translate(4, 5.5)").attr("xlink:href", (d2) => d2.icon ? "#" + d2.icon : "");
      headerEnter.append("div").attr("class", "qa-header-label").text(issueTitle);
    }
    osmoseHeader.issue = function(val) {
      if (!arguments.length)
        return _qaItem;
      _qaItem = val;
      return osmoseHeader;
    };
    return osmoseHeader;
  }

  // modules/ui/view_on_osmose.js
  function uiViewOnOsmose() {
    let _qaItem;
    function viewOnOsmose(selection2) {
      let url;
      if (services.osmose && _qaItem instanceof QAItem) {
        url = services.osmose.itemURL(_qaItem);
      }
      const link3 = selection2.selectAll(".view-on-osmose").data(url ? [url] : []);
      link3.exit().remove();
      const linkEnter = link3.enter().append("a").attr("class", "view-on-osmose").attr("target", "_blank").attr("rel", "noopener").attr("href", (d2) => d2).call(svgIcon("#iD-icon-out-link", "inline"));
      linkEnter.append("span").call(_t.append("inspector.view_on_osmose"));
    }
    viewOnOsmose.what = function(val) {
      if (!arguments.length)
        return _qaItem;
      _qaItem = val;
      return viewOnOsmose;
    };
    return viewOnOsmose;
  }

  // modules/ui/osmose_editor.js
  function uiOsmoseEditor(context) {
    const dispatch14 = dispatch_default("change");
    const qaDetails = uiOsmoseDetails(context);
    const qaHeader = uiOsmoseHeader(context);
    let _qaItem;
    function osmoseEditor(selection2) {
      const header = selection2.selectAll(".header").data([0]);
      const headerEnter = header.enter().append("div").attr("class", "header fillL");
      headerEnter.append("button").attr("class", "close").attr("title", _t("icons.close")).on("click", () => context.enter(modeBrowse(context))).call(svgIcon("#iD-icon-close"));
      headerEnter.append("h2").call(_t.append("QA.osmose.title"));
      let body = selection2.selectAll(".body").data([0]);
      body = body.enter().append("div").attr("class", "body").merge(body);
      let editor = body.selectAll(".qa-editor").data([0]);
      editor.enter().append("div").attr("class", "modal-section qa-editor").merge(editor).call(qaHeader.issue(_qaItem)).call(qaDetails.issue(_qaItem)).call(osmoseSaveSection);
      const footer = selection2.selectAll(".footer").data([0]);
      footer.enter().append("div").attr("class", "footer").merge(footer).call(uiViewOnOsmose(context).what(_qaItem));
    }
    function osmoseSaveSection(selection2) {
      const isSelected = _qaItem && _qaItem.id === context.selectedErrorID();
      const isShown = _qaItem && isSelected;
      let saveSection = selection2.selectAll(".qa-save").data(
        isShown ? [_qaItem] : [],
        (d2) => "".concat(d2.id, "-").concat(d2.status || 0)
      );
      saveSection.exit().remove();
      const saveSectionEnter = saveSection.enter().append("div").attr("class", "qa-save save-section cf");
      saveSection = saveSectionEnter.merge(saveSection).call(qaSaveButtons);
    }
    function qaSaveButtons(selection2) {
      const isSelected = _qaItem && _qaItem.id === context.selectedErrorID();
      let buttonSection = selection2.selectAll(".buttons").data(isSelected ? [_qaItem] : [], (d2) => d2.status + d2.id);
      buttonSection.exit().remove();
      const buttonEnter = buttonSection.enter().append("div").attr("class", "buttons");
      buttonEnter.append("button").attr("class", "button close-button action");
      buttonEnter.append("button").attr("class", "button ignore-button action");
      buttonSection = buttonSection.merge(buttonEnter);
      buttonSection.select(".close-button").call(_t.append("QA.keepRight.close")).on("click.close", function(d3_event, d2) {
        this.blur();
        const qaService = services.osmose;
        if (qaService) {
          d2.newStatus = "done";
          qaService.postUpdate(d2, (err, item) => dispatch14.call("change", item));
        }
      });
      buttonSection.select(".ignore-button").call(_t.append("QA.keepRight.ignore")).on("click.ignore", function(d3_event, d2) {
        this.blur();
        const qaService = services.osmose;
        if (qaService) {
          d2.newStatus = "false";
          qaService.postUpdate(d2, (err, item) => dispatch14.call("change", item));
        }
      });
    }
    osmoseEditor.error = function(val) {
      if (!arguments.length)
        return _qaItem;
      _qaItem = val;
      return osmoseEditor;
    };
    return utilRebind(osmoseEditor, dispatch14, "on");
  }

  // modules/modes/select_error.js
  function modeSelectError(context, selectedErrorID, selectedErrorService) {
    var mode = {
      id: "select-error",
      button: "browse"
    };
    var keybinding = utilKeybinding("select-error");
    var errorService = services[selectedErrorService];
    var errorEditor;
    switch (selectedErrorService) {
      case "improveOSM":
        errorEditor = uiImproveOsmEditor(context).on("change", function() {
          context.map().pan([0, 0]);
          var error = checkSelectedID();
          if (!error)
            return;
          context.ui().sidebar.show(errorEditor.error(error));
        });
        break;
      case "keepRight":
        errorEditor = uiKeepRightEditor(context).on("change", function() {
          context.map().pan([0, 0]);
          var error = checkSelectedID();
          if (!error)
            return;
          context.ui().sidebar.show(errorEditor.error(error));
        });
        break;
      case "osmose":
        errorEditor = uiOsmoseEditor(context).on("change", function() {
          context.map().pan([0, 0]);
          var error = checkSelectedID();
          if (!error)
            return;
          context.ui().sidebar.show(errorEditor.error(error));
        });
        break;
    }
    var behaviors = [
      behaviorBreathe(context),
      behaviorHover(context),
      behaviorSelect(context),
      behaviorLasso(context),
      modeDragNode(context).behavior,
      modeDragNote(context).behavior
    ];
    function checkSelectedID() {
      if (!errorService)
        return;
      var error = errorService.getError(selectedErrorID);
      if (!error) {
        context.enter(modeBrowse(context));
      }
      return error;
    }
    mode.zoomToSelected = function() {
      if (!errorService)
        return;
      var error = errorService.getError(selectedErrorID);
      if (error) {
        context.map().centerZoomEase(error.loc, 20);
      }
    };
    mode.enter = function() {
      var error = checkSelectedID();
      if (!error)
        return;
      behaviors.forEach(context.install);
      keybinding.on(_t("inspector.zoom_to.key"), mode.zoomToSelected).on("\u238B", esc, true);
      select_default2(document).call(keybinding);
      selectError();
      var sidebar = context.ui().sidebar;
      sidebar.show(errorEditor.error(error));
      context.map().on("drawn.select-error", selectError);
      function selectError(d3_event, drawn) {
        if (!checkSelectedID())
          return;
        var selection2 = context.surface().selectAll(".itemId-" + selectedErrorID + "." + selectedErrorService);
        if (selection2.empty()) {
          var source = d3_event && d3_event.type === "zoom" && d3_event.sourceEvent;
          if (drawn && source && (source.type === "pointermove" || source.type === "mousemove" || source.type === "touchmove")) {
            context.enter(modeBrowse(context));
          }
        } else {
          selection2.classed("selected", true);
          context.selectedErrorID(selectedErrorID);
        }
      }
      function esc() {
        if (context.container().select(".combobox").size())
          return;
        context.enter(modeBrowse(context));
      }
    };
    mode.exit = function() {
      behaviors.forEach(context.uninstall);
      select_default2(document).call(keybinding.unbind);
      context.surface().selectAll(".qaItem.selected").classed("selected hover", false);
      context.map().on("drawn.select-error", null);
      context.ui().sidebar.hide();
      context.selectedErrorID(null);
      context.features().forceVisible([]);
    };
    return mode;
  }

  // modules/ui/feature_list.js
  function uiFeatureList(context) {
    var _geocodeResults;
    function featureList(selection2) {
      var header = selection2.append("div").attr("class", "header fillL");
      header.append("h2").call(_t.append("inspector.feature_list"));
      var searchWrap = selection2.append("div").attr("class", "search-header");
      searchWrap.call(svgIcon("#iD-icon-search", "pre-text"));
      var search = searchWrap.append("input").attr("placeholder", _t("inspector.search")).attr("type", "search").call(utilNoAuto).on("keypress", keypress).on("keydown", keydown).on("input", inputevent);
      var listWrap = selection2.append("div").attr("class", "inspector-body");
      var list2 = listWrap.append("div").attr("class", "feature-list");
      context.on("exit.feature-list", clearSearch);
      context.map().on("drawn.feature-list", mapDrawn);
      context.keybinding().on(uiCmd("\u2318F"), focusSearch);
      function focusSearch(d3_event) {
        var mode = context.mode() && context.mode().id;
        if (mode !== "browse")
          return;
        d3_event.preventDefault();
        search.node().focus();
      }
      function keydown(d3_event) {
        if (d3_event.keyCode === 27) {
          search.node().blur();
        }
      }
      function keypress(d3_event) {
        var q2 = search.property("value"), items = list2.selectAll(".feature-list-item");
        if (d3_event.keyCode === 13 && // ↩ Return
        q2.length && items.size()) {
          click(d3_event, items.datum());
        }
      }
      function inputevent() {
        _geocodeResults = void 0;
        drawList();
      }
      function clearSearch() {
        search.property("value", "");
        drawList();
      }
      function mapDrawn(e3) {
        if (e3.full) {
          drawList();
        }
      }
      function features() {
        var result = [];
        var graph = context.graph();
        var visibleCenter = context.map().extent().center();
        var q2 = search.property("value").toLowerCase();
        if (!q2)
          return result;
        var locationMatch = sexagesimal.pair(q2.toUpperCase()) || dmsMatcher(q2);
        if (locationMatch) {
          var loc = [Number(locationMatch[0]), Number(locationMatch[1])];
          result.push({
            id: -1,
            geometry: "point",
            type: _t("inspector.location"),
            name: dmsCoordinatePair([loc[1], loc[0]]),
            location: loc
          });
        }
        var idMatch = !locationMatch && q2.match(/(?:^|\W)(node|way|relation|note|[nwr])\W{0,2}0*([1-9]\d*)(?:\W|$)/i);
        if (idMatch) {
          var elemType = idMatch[1] === "note" ? idMatch[1] : idMatch[1].charAt(0);
          var elemId = idMatch[2];
          result.push({
            id: elemType + elemId,
            geometry: elemType === "n" ? "point" : elemType === "w" ? "line" : elemType === "note" ? "note" : "relation",
            type: elemType === "n" ? _t("inspector.node") : elemType === "w" ? _t("inspector.way") : elemType === "note" ? _t("note.note") : _t("inspector.relation"),
            name: elemId
          });
        }
        var allEntities = graph.entities;
        var localResults = [];
        for (var id2 in allEntities) {
          var entity = allEntities[id2];
          if (!entity)
            continue;
          var name = utilDisplayName(entity) || "";
          if (name.toLowerCase().indexOf(q2) < 0)
            continue;
          var matched = _mainPresetIndex.match(entity, graph);
          var type2 = matched && matched.name() || utilDisplayType(entity.id);
          var extent = entity.extent(graph);
          var distance = extent ? geoSphericalDistance(visibleCenter, extent.center()) : 0;
          localResults.push({
            id: entity.id,
            entity,
            geometry: entity.geometry(graph),
            type: type2,
            name,
            distance
          });
          if (localResults.length > 100)
            break;
        }
        localResults = localResults.sort(function byDistance(a2, b2) {
          return a2.distance - b2.distance;
        });
        result = result.concat(localResults);
        (_geocodeResults || []).forEach(function(d2) {
          if (d2.osm_type && d2.osm_id) {
            var id3 = osmEntity.id.fromOSM(d2.osm_type, d2.osm_id);
            var tags = {};
            tags[d2.class] = d2.type;
            var attrs = { id: id3, type: d2.osm_type, tags };
            if (d2.osm_type === "way") {
              attrs.nodes = ["a", "a"];
            }
            var tempEntity = osmEntity(attrs);
            var tempGraph = coreGraph([tempEntity]);
            var matched2 = _mainPresetIndex.match(tempEntity, tempGraph);
            var type3 = matched2 && matched2.name() || utilDisplayType(id3);
            result.push({
              id: tempEntity.id,
              geometry: tempEntity.geometry(tempGraph),
              type: type3,
              name: d2.display_name,
              extent: new geoExtent(
                [Number(d2.boundingbox[3]), Number(d2.boundingbox[0])],
                [Number(d2.boundingbox[2]), Number(d2.boundingbox[1])]
              )
            });
          }
        });
        if (q2.match(/^[0-9]+$/)) {
          result.push({
            id: "n" + q2,
            geometry: "point",
            type: _t("inspector.node"),
            name: q2
          });
          result.push({
            id: "w" + q2,
            geometry: "line",
            type: _t("inspector.way"),
            name: q2
          });
          result.push({
            id: "r" + q2,
            geometry: "relation",
            type: _t("inspector.relation"),
            name: q2
          });
          result.push({
            id: "note" + q2,
            geometry: "note",
            type: _t("note.note"),
            name: q2
          });
        }
        return result;
      }
      function drawList() {
        var value = search.property("value");
        var results = features();
        list2.classed("filtered", value.length);
        var resultsIndicator = list2.selectAll(".no-results-item").data([0]).enter().append("button").property("disabled", true).attr("class", "no-results-item").call(svgIcon("#iD-icon-alert", "pre-text"));
        resultsIndicator.append("span").attr("class", "entity-name");
        list2.selectAll(".no-results-item .entity-name").html("").call(_t.append("geocoder.no_results_worldwide"));
        if (services.geocoder) {
          list2.selectAll(".geocode-item").data([0]).enter().append("button").attr("class", "geocode-item secondary-action").on("click", geocoderSearch).append("div").attr("class", "label").append("span").attr("class", "entity-name").call(_t.append("geocoder.search"));
        }
        list2.selectAll(".no-results-item").style("display", value.length && !results.length ? "block" : "none");
        list2.selectAll(".geocode-item").style("display", value && _geocodeResults === void 0 ? "block" : "none");
        list2.selectAll(".feature-list-item").data([-1]).remove();
        var items = list2.selectAll(".feature-list-item").data(results, function(d2) {
          return d2.id;
        });
        var enter = items.enter().insert("button", ".geocode-item").attr("class", "feature-list-item").on("mouseover", mouseover).on("mouseout", mouseout).on("click", click);
        var label = enter.append("div").attr("class", "label");
        label.each(function(d2) {
          select_default2(this).call(svgIcon("#iD-icon-" + d2.geometry, "pre-text"));
        });
        label.append("span").attr("class", "entity-type").text(function(d2) {
          return d2.type;
        });
        label.append("span").attr("class", "entity-name").classed("has-colour", (d2) => d2.entity && d2.entity.type === "relation" && d2.entity.tags.colour && isColourValid(d2.entity.tags.colour)).style("border-color", (d2) => d2.entity && d2.entity.type === "relation" && d2.entity.tags.colour).text(function(d2) {
          return d2.name;
        });
        enter.style("opacity", 0).transition().style("opacity", 1);
        items.order();
        items.exit().remove();
      }
      function mouseover(d3_event, d2) {
        if (d2.id === -1)
          return;
        utilHighlightEntities([d2.id], true, context);
      }
      function mouseout(d3_event, d2) {
        if (d2.id === -1)
          return;
        utilHighlightEntities([d2.id], false, context);
      }
      function click(d3_event, d2) {
        d3_event.preventDefault();
        if (d2.location) {
          context.map().centerZoomEase([d2.location[1], d2.location[0]], 19);
        } else if (d2.entity) {
          utilHighlightEntities([d2.id], false, context);
          context.enter(modeSelect(context, [d2.entity.id]));
          context.map().zoomToEase(d2.entity);
        } else if (d2.geometry === "note") {
          const noteId = d2.id.replace(/\D/g, "");
          context.loadNote(noteId, (err, result) => {
            if (err)
              return;
            const entity = result.data.find((e3) => e3.id === noteId);
            if (entity) {
              const note = services.osm.getNote(noteId);
              context.map().centerZoom(note.loc, 15);
              const noteLayer = context.layers().layer("notes");
              noteLayer.enabled(true);
              context.enter(modeSelectNote(context, noteId));
            }
          });
        } else {
          context.zoomToEntity(d2.id);
        }
      }
      function geocoderSearch() {
        services.geocoder.search(search.property("value"), function(err, resp) {
          _geocodeResults = resp || [];
          drawList();
        });
      }
    }
    return featureList;
  }

  // modules/ui/preset_list.js
  function uiPresetList(context) {
    var dispatch14 = dispatch_default("cancel", "choose");
    var _entityIDs;
    var _currLoc;
    var _currentPresets;
    var _autofocus = false;
    function presetList(selection2) {
      if (!_entityIDs)
        return;
      var presets = _mainPresetIndex.matchAllGeometry(entityGeometries());
      selection2.html("");
      var messagewrap = selection2.append("div").attr("class", "header fillL");
      var message = messagewrap.append("h2").call(_t.append("inspector.choose"));
      var direction = _mainLocalizer.textDirection() === "rtl" ? "backward" : "forward";
      messagewrap.append("button").attr("class", "preset-choose").attr("title", _entityIDs.length === 1 ? _t("inspector.edit") : _t("inspector.edit_features")).on("click", function() {
        dispatch14.call("cancel", this);
      }).call(svgIcon("#iD-icon-".concat(direction)));
      function initialKeydown(d3_event) {
        if (search.property("value").length === 0 && (d3_event.keyCode === utilKeybinding.keyCodes["\u232B"] || d3_event.keyCode === utilKeybinding.keyCodes["\u2326"])) {
          d3_event.preventDefault();
          d3_event.stopPropagation();
          operationDelete(context, _entityIDs)();
        } else if (search.property("value").length === 0 && (d3_event.ctrlKey || d3_event.metaKey) && d3_event.keyCode === utilKeybinding.keyCodes.z) {
          d3_event.preventDefault();
          d3_event.stopPropagation();
          context.undo();
        } else if (!d3_event.ctrlKey && !d3_event.metaKey) {
          select_default2(this).on("keydown", keydown);
          keydown.call(this, d3_event);
        }
      }
      function keydown(d3_event) {
        if (d3_event.keyCode === utilKeybinding.keyCodes["\u2193"] && // if insertion point is at the end of the string
        search.node().selectionStart === search.property("value").length) {
          d3_event.preventDefault();
          d3_event.stopPropagation();
          var buttons = list2.selectAll(".preset-list-button");
          if (!buttons.empty())
            buttons.nodes()[0].focus();
        }
      }
      function keypress(d3_event) {
        var value = search.property("value");
        if (d3_event.keyCode === 13 && // ↩ Return
        value.length) {
          list2.selectAll(".preset-list-item:first-child").each(function(d2) {
            d2.choose.call(this);
          });
        }
      }
      function inputevent() {
        var value = search.property("value");
        list2.classed("filtered", value.length);
        var results, messageText;
        if (value.length) {
          results = presets.search(value, entityGeometries()[0], _currLoc);
          messageText = _t.html("inspector.results", {
            n: results.collection.length,
            search: value
          });
        } else {
          var entityPresets2 = _entityIDs.map((entityID) => _mainPresetIndex.match(context.graph().entity(entityID), context.graph()));
          results = _mainPresetIndex.defaults(entityGeometries()[0], 36, !context.inIntro(), _currLoc, entityPresets2);
          messageText = _t.html("inspector.choose");
        }
        list2.call(drawList, results);
        message.html(messageText);
      }
      var searchWrap = selection2.append("div").attr("class", "search-header");
      searchWrap.call(svgIcon("#iD-icon-search", "pre-text"));
      var search = searchWrap.append("input").attr("class", "preset-search-input").attr("placeholder", _t("inspector.search")).attr("type", "search").call(utilNoAuto).on("keydown", initialKeydown).on("keypress", keypress).on("input", debounce_default(inputevent));
      if (_autofocus) {
        search.node().focus();
        setTimeout(function() {
          search.node().focus();
        }, 0);
      }
      var listWrap = selection2.append("div").attr("class", "inspector-body");
      var entityPresets = _entityIDs.map((entityID) => _mainPresetIndex.match(context.graph().entity(entityID), context.graph()));
      var list2 = listWrap.append("div").attr("class", "preset-list").call(drawList, _mainPresetIndex.defaults(entityGeometries()[0], 36, !context.inIntro(), _currLoc, entityPresets));
      context.features().on("change.preset-list", updateForFeatureHiddenState);
    }
    function drawList(list2, presets) {
      presets = presets.matchAllGeometry(entityGeometries());
      var collection = presets.collection.reduce(function(collection2, preset) {
        if (!preset)
          return collection2;
        if (preset.members) {
          if (preset.members.collection.filter(function(preset2) {
            return preset2.addable();
          }).length > 1) {
            collection2.push(CategoryItem(preset));
          }
        } else if (preset.addable()) {
          collection2.push(PresetItem(preset));
        }
        return collection2;
      }, []);
      var items = list2.selectAll(".preset-list-item").data(collection, function(d2) {
        return d2.preset.id;
      });
      items.order();
      items.exit().remove();
      items.enter().append("div").attr("class", function(item) {
        return "preset-list-item preset-" + item.preset.id.replace("/", "-");
      }).classed("current", function(item) {
        return _currentPresets.indexOf(item.preset) !== -1;
      }).each(function(item) {
        select_default2(this).call(item);
      }).style("opacity", 0).transition().style("opacity", 1);
      updateForFeatureHiddenState();
    }
    function itemKeydown(d3_event) {
      var item = select_default2(this.closest(".preset-list-item"));
      var parentItem = select_default2(item.node().parentNode.closest(".preset-list-item"));
      if (d3_event.keyCode === utilKeybinding.keyCodes["\u2193"]) {
        d3_event.preventDefault();
        d3_event.stopPropagation();
        var nextItem = select_default2(item.node().nextElementSibling);
        if (nextItem.empty()) {
          if (!parentItem.empty()) {
            nextItem = select_default2(parentItem.node().nextElementSibling);
          }
        } else if (select_default2(this).classed("expanded")) {
          nextItem = item.select(".subgrid .preset-list-item:first-child");
        }
        if (!nextItem.empty()) {
          nextItem.select(".preset-list-button").node().focus();
        }
      } else if (d3_event.keyCode === utilKeybinding.keyCodes["\u2191"]) {
        d3_event.preventDefault();
        d3_event.stopPropagation();
        var previousItem = select_default2(item.node().previousElementSibling);
        if (previousItem.empty()) {
          if (!parentItem.empty()) {
            previousItem = parentItem;
          }
        } else if (previousItem.select(".preset-list-button").classed("expanded")) {
          previousItem = previousItem.select(".subgrid .preset-list-item:last-child");
        }
        if (!previousItem.empty()) {
          previousItem.select(".preset-list-button").node().focus();
        } else {
          var search = select_default2(this.closest(".preset-list-pane")).select(".preset-search-input");
          search.node().focus();
        }
      } else if (d3_event.keyCode === utilKeybinding.keyCodes[_mainLocalizer.textDirection() === "rtl" ? "\u2192" : "\u2190"]) {
        d3_event.preventDefault();
        d3_event.stopPropagation();
        if (!parentItem.empty()) {
          parentItem.select(".preset-list-button").node().focus();
        }
      } else if (d3_event.keyCode === utilKeybinding.keyCodes[_mainLocalizer.textDirection() === "rtl" ? "\u2190" : "\u2192"]) {
        d3_event.preventDefault();
        d3_event.stopPropagation();
        item.datum().choose.call(select_default2(this).node());
      }
    }
    function CategoryItem(preset) {
      var box, sublist, shown = false;
      function item(selection2) {
        var wrap2 = selection2.append("div").attr("class", "preset-list-button-wrap category");
        function click() {
          var isExpanded = select_default2(this).classed("expanded");
          var iconName = isExpanded ? _mainLocalizer.textDirection() === "rtl" ? "#iD-icon-backward" : "#iD-icon-forward" : "#iD-icon-down";
          select_default2(this).classed("expanded", !isExpanded).attr("title", !isExpanded ? _t("icons.collapse") : _t("icons.expand"));
          select_default2(this).selectAll("div.label-inner svg.icon use").attr("href", iconName);
          item.choose();
        }
        var geometries = entityGeometries();
        var button = wrap2.append("button").attr("class", "preset-list-button").attr("title", _t("icons.expand")).classed("expanded", false).call(uiPresetIcon().geometry(geometries.length === 1 && geometries[0]).preset(preset)).on("click", click).on("keydown", function(d3_event) {
          if (d3_event.keyCode === utilKeybinding.keyCodes[_mainLocalizer.textDirection() === "rtl" ? "\u2190" : "\u2192"]) {
            d3_event.preventDefault();
            d3_event.stopPropagation();
            if (!select_default2(this).classed("expanded")) {
              click.call(this, d3_event);
            }
          } else if (d3_event.keyCode === utilKeybinding.keyCodes[_mainLocalizer.textDirection() === "rtl" ? "\u2192" : "\u2190"]) {
            d3_event.preventDefault();
            d3_event.stopPropagation();
            if (select_default2(this).classed("expanded")) {
              click.call(this, d3_event);
            }
          } else {
            itemKeydown.call(this, d3_event);
          }
        });
        var label = button.append("div").attr("class", "label").append("div").attr("class", "label-inner");
        label.append("div").attr("class", "namepart").call(svgIcon(_mainLocalizer.textDirection() === "rtl" ? "#iD-icon-backward" : "#iD-icon-forward", "inline")).append("span").call(preset.nameLabel()).append("span").text("\u2026");
        box = selection2.append("div").attr("class", "subgrid").style("max-height", "0px").style("opacity", 0);
        box.append("div").attr("class", "arrow");
        sublist = box.append("div").attr("class", "preset-list fillL3");
      }
      item.choose = function() {
        if (!box || !sublist)
          return;
        if (shown) {
          shown = false;
          box.transition().duration(200).style("opacity", "0").style("max-height", "0px").style("padding-bottom", "0px");
        } else {
          shown = true;
          var members = preset.members.matchAllGeometry(entityGeometries());
          sublist.call(drawList, members);
          box.transition().duration(200).style("opacity", "1").style("max-height", 200 + members.collection.length * 190 + "px").style("padding-bottom", "10px");
        }
      };
      item.preset = preset;
      return item;
    }
    function PresetItem(preset) {
      function item(selection2) {
        var wrap2 = selection2.append("div").attr("class", "preset-list-button-wrap");
        var geometries = entityGeometries();
        var button = wrap2.append("button").attr("class", "preset-list-button").call(uiPresetIcon().geometry(geometries.length === 1 && geometries[0]).preset(preset)).on("click", item.choose).on("keydown", itemKeydown);
        var label = button.append("div").attr("class", "label").append("div").attr("class", "label-inner");
        var nameparts = [
          preset.nameLabel(),
          preset.subtitleLabel()
        ].filter(Boolean);
        label.selectAll(".namepart").data(nameparts, (d2) => d2.stringId).enter().append("div").attr("class", "namepart").text("").each(function(d2) {
          d2(select_default2(this));
        });
        wrap2.call(item.reference.button);
        selection2.call(item.reference.body);
      }
      item.choose = function() {
        if (select_default2(this).classed("disabled"))
          return;
        if (!context.inIntro()) {
          _mainPresetIndex.setMostRecent(preset, entityGeometries()[0]);
        }
        context.perform(
          function(graph) {
            for (var i3 in _entityIDs) {
              var entityID = _entityIDs[i3];
              var oldPreset = _mainPresetIndex.match(graph.entity(entityID), graph);
              graph = actionChangePreset(entityID, oldPreset, preset)(graph);
            }
            return graph;
          },
          _t("operations.change_tags.annotation")
        );
        context.validator().validate();
        dispatch14.call("choose", this, preset);
      };
      item.help = function(d3_event) {
        d3_event.stopPropagation();
        item.reference.toggle();
      };
      item.preset = preset;
      item.reference = uiTagReference(preset.reference(), context);
      return item;
    }
    function updateForFeatureHiddenState() {
      if (!_entityIDs.every(context.hasEntity))
        return;
      var geometries = entityGeometries();
      var button = context.container().selectAll(".preset-list .preset-list-button");
      button.call(uiTooltip().destroyAny);
      button.each(function(item, index) {
        var hiddenPresetFeaturesId;
        for (var i3 in geometries) {
          hiddenPresetFeaturesId = context.features().isHiddenPreset(item.preset, geometries[i3]);
          if (hiddenPresetFeaturesId)
            break;
        }
        var isHiddenPreset = !context.inIntro() && !!hiddenPresetFeaturesId && (_currentPresets.length !== 1 || item.preset !== _currentPresets[0]);
        select_default2(this).classed("disabled", isHiddenPreset);
        if (isHiddenPreset) {
          var isAutoHidden = context.features().autoHidden(hiddenPresetFeaturesId);
          select_default2(this).call(
            uiTooltip().title(() => _t.append("inspector.hidden_preset." + (isAutoHidden ? "zoom" : "manual"), {
              features: _t("feature." + hiddenPresetFeaturesId + ".description")
            })).placement(index < 2 ? "bottom" : "top")
          );
        }
      });
    }
    presetList.autofocus = function(val) {
      if (!arguments.length)
        return _autofocus;
      _autofocus = val;
      return presetList;
    };
    presetList.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      _entityIDs = val;
      _currLoc = null;
      if (_entityIDs && _entityIDs.length) {
        const extent = _entityIDs.reduce(function(extent2, entityID) {
          var entity = context.graph().entity(entityID);
          return extent2.extend(entity.extent(context.graph()));
        }, geoExtent());
        _currLoc = extent.center();
        var presets = _entityIDs.map(function(entityID) {
          return _mainPresetIndex.match(context.entity(entityID), context.graph());
        });
        presetList.presets(presets);
      }
      return presetList;
    };
    presetList.presets = function(val) {
      if (!arguments.length)
        return _currentPresets;
      _currentPresets = val;
      return presetList;
    };
    function entityGeometries() {
      var counts = {};
      for (var i3 in _entityIDs) {
        var entityID = _entityIDs[i3];
        var entity = context.entity(entityID);
        var geometry = entity.geometry(context.graph());
        if (geometry === "vertex" && entity.isOnAddressLine(context.graph())) {
          geometry = "point";
        }
        if (!counts[geometry])
          counts[geometry] = 0;
        counts[geometry] += 1;
      }
      return Object.keys(counts).sort(function(geom1, geom2) {
        return counts[geom2] - counts[geom1];
      });
    }
    return utilRebind(presetList, dispatch14, "on");
  }

  // modules/ui/inspector.js
  function uiInspector(context) {
    var presetList = uiPresetList(context);
    var entityEditor = uiEntityEditor(context);
    var wrap2 = select_default2(null), presetPane = select_default2(null), editorPane = select_default2(null);
    var _state = "select";
    var _entityIDs;
    var _newFeature = false;
    function inspector(selection2) {
      presetList.entityIDs(_entityIDs).autofocus(_newFeature).on("choose", inspector.setPreset).on("cancel", function() {
        inspector.setPreset();
      });
      entityEditor.state(_state).entityIDs(_entityIDs).on("choose", inspector.showList);
      wrap2 = selection2.selectAll(".panewrap").data([0]);
      var enter = wrap2.enter().append("div").attr("class", "panewrap");
      enter.append("div").attr("class", "preset-list-pane pane");
      enter.append("div").attr("class", "entity-editor-pane pane");
      wrap2 = wrap2.merge(enter);
      presetPane = wrap2.selectAll(".preset-list-pane");
      editorPane = wrap2.selectAll(".entity-editor-pane");
      function shouldDefaultToPresetList() {
        if (_state !== "select")
          return false;
        if (_entityIDs.length !== 1)
          return false;
        var entityID = _entityIDs[0];
        var entity = context.hasEntity(entityID);
        if (!entity)
          return false;
        if (entity.hasNonGeometryTags())
          return false;
        if (_newFeature)
          return true;
        if (entity.geometry(context.graph()) !== "vertex")
          return false;
        if (context.graph().parentRelations(entity).length)
          return false;
        if (context.validator().getEntityIssues(entityID).length)
          return false;
        if (entity.isHighwayIntersection(context.graph()))
          return false;
        return true;
      }
      if (shouldDefaultToPresetList()) {
        wrap2.style("right", "-100%");
        editorPane.classed("hide", true);
        presetPane.classed("hide", false).call(presetList);
      } else {
        wrap2.style("right", "0%");
        presetPane.classed("hide", true);
        editorPane.classed("hide", false).call(entityEditor);
      }
      var footer = selection2.selectAll(".footer").data([0]);
      footer = footer.enter().append("div").attr("class", "footer").merge(footer);
      footer.call(
        uiViewOnOSM(context).what(context.hasEntity(_entityIDs.length === 1 && _entityIDs[0]))
      );
    }
    inspector.showList = function(presets) {
      presetPane.classed("hide", false);
      wrap2.transition().styleTween("right", function() {
        return value_default("0%", "-100%");
      }).on("end", function() {
        editorPane.classed("hide", true);
      });
      if (presets) {
        presetList.presets(presets);
      }
      presetPane.call(presetList.autofocus(true));
    };
    inspector.setPreset = function(preset) {
      if (preset && preset.id === "type/multipolygon") {
        presetPane.call(presetList.autofocus(true));
      } else {
        editorPane.classed("hide", false);
        wrap2.transition().styleTween("right", function() {
          return value_default("-100%", "0%");
        }).on("end", function() {
          presetPane.classed("hide", true);
        });
        if (preset) {
          entityEditor.presets([preset]);
        }
        editorPane.call(entityEditor);
      }
    };
    inspector.state = function(val) {
      if (!arguments.length)
        return _state;
      _state = val;
      entityEditor.state(_state);
      context.container().selectAll(".field-help-body").remove();
      return inspector;
    };
    inspector.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      _entityIDs = val;
      return inspector;
    };
    inspector.newFeature = function(val) {
      if (!arguments.length)
        return _newFeature;
      _newFeature = val;
      return inspector;
    };
    return inspector;
  }

  // modules/ui/lasso.js
  function uiLasso(context) {
    var group, polygon2;
    lasso.coordinates = [];
    function lasso(selection2) {
      context.container().classed("lasso", true);
      group = selection2.append("g").attr("class", "lasso hide");
      polygon2 = group.append("path").attr("class", "lasso-path");
      group.call(uiToggle(true));
    }
    function draw() {
      if (polygon2) {
        polygon2.data([lasso.coordinates]).attr("d", function(d2) {
          return "M" + d2.join(" L") + " Z";
        });
      }
    }
    lasso.extent = function() {
      return lasso.coordinates.reduce(function(extent, point2) {
        return extent.extend(geoExtent(point2));
      }, geoExtent());
    };
    lasso.p = function(_2) {
      if (!arguments.length)
        return lasso;
      lasso.coordinates.push(_2);
      draw();
      return lasso;
    };
    lasso.close = function() {
      if (group) {
        group.call(uiToggle(false, function() {
          select_default2(this).remove();
        }));
      }
      context.container().classed("lasso", false);
    };
    return lasso;
  }

  // modules/ui/source_switch.js
  function uiSourceSwitch(context) {
    var keys2;
    function click(d3_event) {
      d3_event.preventDefault();
      var osm = context.connection();
      if (!osm)
        return;
      if (context.inIntro())
        return;
      if (context.history().hasChanges() && !window.confirm(_t("source_switch.lose_changes")))
        return;
      var isLive = select_default2(this).classed("live");
      isLive = !isLive;
      context.enter(modeBrowse(context));
      context.history().clearSaved();
      context.flush();
      select_default2(this).html(isLive ? _t.html("source_switch.live") : _t.html("source_switch.dev")).classed("live", isLive).classed("chip", isLive);
      osm.switch(isLive ? keys2[0] : keys2[1]);
    }
    var sourceSwitch = function(selection2) {
      selection2.append("a").attr("href", "#").call(_t.append("source_switch.live")).attr("class", "live chip").on("click", click);
    };
    sourceSwitch.keys = function(_2) {
      if (!arguments.length)
        return keys2;
      keys2 = _2;
      return sourceSwitch;
    };
    return sourceSwitch;
  }

  // modules/ui/spinner.js
  function uiSpinner(context) {
    var osm = context.connection();
    return function(selection2) {
      var img = selection2.append("img").attr("src", context.imagePath("loader-black.gif")).style("opacity", 0);
      if (osm) {
        osm.on("loading.spinner", function() {
          img.transition().style("opacity", 1);
        }).on("loaded.spinner", function() {
          img.transition().style("opacity", 0);
        });
      }
    };
  }

  // modules/ui/sections/privacy.js
  function uiSectionPrivacy(context) {
    let section = uiSection("preferences-third-party", context).label(() => _t.append("preferences.privacy.title")).disclosureContent(renderDisclosureContent);
    function renderDisclosureContent(selection2) {
      selection2.selectAll(".privacy-options-list").data([0]).enter().append("ul").attr("class", "layer-list privacy-options-list");
      let thirdPartyIconsEnter = selection2.select(".privacy-options-list").selectAll(".privacy-third-party-icons-item").data([corePreferences("preferences.privacy.thirdpartyicons") || "true"]).enter().append("li").attr("class", "privacy-third-party-icons-item").append("label").call(
        uiTooltip().title(() => _t.append("preferences.privacy.third_party_icons.tooltip")).placement("bottom")
      );
      thirdPartyIconsEnter.append("input").attr("type", "checkbox").on("change", (d3_event, d2) => {
        d3_event.preventDefault();
        corePreferences("preferences.privacy.thirdpartyicons", d2 === "true" ? "false" : "true");
      });
      thirdPartyIconsEnter.append("span").call(_t.append("preferences.privacy.third_party_icons.description"));
      selection2.selectAll(".privacy-third-party-icons-item").classed("active", (d2) => d2 === "true").select("input").property("checked", (d2) => d2 === "true");
      selection2.selectAll(".privacy-link").data([0]).enter().append("div").attr("class", "privacy-link").append("a").attr("target", "_blank").call(svgIcon("#iD-icon-out-link", "inline")).attr("href", "https://github.com/openstreetmap/iD/blob/release/PRIVACY.md").append("span").call(_t.append("preferences.privacy.privacy_link"));
    }
    corePreferences.onChange("preferences.privacy.thirdpartyicons", section.reRender);
    return section;
  }

  // modules/ui/splash.js
  function uiSplash(context) {
    return (selection2) => {
      if (context.history().hasRestorableChanges())
        return;
      let updateMessage = "";
      const sawPrivacyVersion = corePreferences("sawPrivacyVersion");
      let showSplash = !corePreferences("sawSplash");
      if (sawPrivacyVersion !== context.privacyVersion) {
        updateMessage = _t("splash.privacy_update");
        showSplash = true;
      }
      if (!showSplash)
        return;
      corePreferences("sawSplash", true);
      corePreferences("sawPrivacyVersion", context.privacyVersion);
      _mainFileFetcher.get("intro_graph");
      let modalSelection = uiModal(selection2);
      modalSelection.select(".modal").attr("class", "modal-splash modal");
      let introModal = modalSelection.select(".content").append("div").attr("class", "fillL");
      introModal.append("div").attr("class", "modal-section").append("h3").call(_t.append("splash.welcome"));
      let modalSection = introModal.append("div").attr("class", "modal-section");
      modalSection.append("p").html(_t.html("splash.text", {
        version: context.version,
        website: { html: '<a target="_blank" href="https://github.com/openstreetmap/iD/blob/develop/CHANGELOG.md#whats-new">' + _t.html("splash.changelog") + "</a>" },
        github: { html: '<a target="_blank" href="https://github.com/openstreetmap/iD/issues">github.com</a>' }
      }));
      modalSection.append("p").html(_t.html("splash.privacy", {
        updateMessage,
        privacyLink: { html: '<a target="_blank" href="https://github.com/openstreetmap/iD/blob/release/PRIVACY.md">' + _t("splash.privacy_policy") + "</a>" }
      }));
      uiSectionPrivacy(context).label(() => _t.append("splash.privacy_settings")).render(modalSection);
      let buttonWrap = introModal.append("div").attr("class", "modal-actions");
      let walkthrough = buttonWrap.append("button").attr("class", "walkthrough").on("click", () => {
        context.container().call(uiIntro(context));
        modalSelection.close();
      });
      walkthrough.append("svg").attr("class", "logo logo-walkthrough").append("use").attr("xlink:href", "#iD-logo-walkthrough");
      walkthrough.append("div").call(_t.append("splash.walkthrough"));
      let startEditing = buttonWrap.append("button").attr("class", "start-editing").on("click", modalSelection.close);
      startEditing.append("svg").attr("class", "logo logo-features").append("use").attr("xlink:href", "#iD-logo-features");
      startEditing.append("div").call(_t.append("splash.start"));
      modalSelection.select("button.close").attr("class", "hide");
    };
  }

  // modules/ui/status.js
  function uiStatus(context) {
    var osm = context.connection();
    return function(selection2) {
      if (!osm)
        return;
      function update(err, apiStatus) {
        selection2.html("");
        if (err) {
          if (apiStatus === "connectionSwitched") {
            return;
          } else if (apiStatus === "rateLimited") {
            selection2.call(_t.append("osm_api_status.message.rateLimit")).append("a").attr("href", "#").attr("class", "api-status-login").attr("target", "_blank").call(svgIcon("#iD-icon-out-link", "inline")).append("span").call(_t.append("login")).on("click.login", function(d3_event) {
              d3_event.preventDefault();
              osm.authenticate();
            });
          } else {
            var throttledRetry = throttle_default(function() {
              context.loadTiles(context.projection);
              osm.reloadApiStatus();
            }, 2e3);
            selection2.call(_t.append("osm_api_status.message.error", { suffix: " " })).append("a").attr("href", "#").call(_t.append("osm_api_status.retry")).on("click.retry", function(d3_event) {
              d3_event.preventDefault();
              throttledRetry();
            });
          }
        } else if (apiStatus === "readonly") {
          selection2.call(_t.append("osm_api_status.message.readonly"));
        } else if (apiStatus === "offline") {
          selection2.call(_t.append("osm_api_status.message.offline"));
        }
        selection2.attr("class", "api-status " + (err ? "error" : apiStatus));
      }
      osm.on("apiStatusChange.uiStatus", update);
      context.history().on("storage_error", () => {
        selection2.selectAll("span.local-storage-full").remove();
        selection2.append("span").attr("class", "local-storage-full").call(_t.append("osm_api_status.message.local_storage_full"));
        selection2.classed("error", true);
      });
      window.setInterval(function() {
        osm.reloadApiStatus();
      }, 9e4);
      osm.reloadApiStatus();
    };
  }

  // modules/ui/version.js
  var sawVersion = null;
  var isNewVersion = false;
  var isNewUser = false;
  function uiVersion(context) {
    var currVersion = context.version;
    var matchedVersion = currVersion.match(/\d+\.\d+\.\d+.*/);
    if (sawVersion === null && matchedVersion !== null) {
      if (corePreferences("sawVersion")) {
        isNewUser = false;
        isNewVersion = corePreferences("sawVersion") !== currVersion && currVersion.indexOf("-") === -1;
      } else {
        isNewUser = true;
        isNewVersion = true;
      }
      corePreferences("sawVersion", currVersion);
      sawVersion = currVersion;
    }
    return function(selection2) {
      selection2.append("a").attr("target", "_blank").attr("href", "https://github.com/openstreetmap/iD").text(currVersion);
      if (isNewVersion && !isNewUser) {
        selection2.append("a").attr("class", "badge").attr("target", "_blank").attr("href", "https://github.com/openstreetmap/iD/blob/release/CHANGELOG.md#whats-new").call(svgIcon("#maki-gift")).call(
          uiTooltip().title(() => _t.append("version.whats_new", { version: currVersion })).placement("top").scrollContainer(context.container().select(".main-footer-wrap"))
        );
      }
    };
  }

  // modules/ui/zoom.js
  function uiZoom(context) {
    var zooms = [{
      id: "zoom-in",
      icon: "iD-icon-plus",
      title: _t.append("zoom.in"),
      action: zoomIn,
      disabled: function() {
        return !context.map().canZoomIn();
      },
      disabledTitle: _t.append("zoom.disabled.in"),
      key: "+"
    }, {
      id: "zoom-out",
      icon: "iD-icon-minus",
      title: _t.append("zoom.out"),
      action: zoomOut,
      disabled: function() {
        return !context.map().canZoomOut();
      },
      disabledTitle: _t.append("zoom.disabled.out"),
      key: "-"
    }];
    function zoomIn(d3_event) {
      if (d3_event.shiftKey)
        return;
      d3_event.preventDefault();
      context.map().zoomIn();
    }
    function zoomOut(d3_event) {
      if (d3_event.shiftKey)
        return;
      d3_event.preventDefault();
      context.map().zoomOut();
    }
    function zoomInFurther(d3_event) {
      if (d3_event.shiftKey)
        return;
      d3_event.preventDefault();
      context.map().zoomInFurther();
    }
    function zoomOutFurther(d3_event) {
      if (d3_event.shiftKey)
        return;
      d3_event.preventDefault();
      context.map().zoomOutFurther();
    }
    return function(selection2) {
      var tooltipBehavior = uiTooltip().placement(_mainLocalizer.textDirection() === "rtl" ? "right" : "left").title(function(d2) {
        if (d2.disabled()) {
          return d2.disabledTitle;
        }
        return d2.title;
      }).keys(function(d2) {
        return [d2.key];
      });
      var lastPointerUpType;
      var buttons = selection2.selectAll("button").data(zooms).enter().append("button").attr("class", function(d2) {
        return d2.id;
      }).on("pointerup.editor", function(d3_event) {
        lastPointerUpType = d3_event.pointerType;
      }).on("click.editor", function(d3_event, d2) {
        if (!d2.disabled()) {
          d2.action(d3_event);
        } else if (lastPointerUpType === "touch" || lastPointerUpType === "pen") {
          context.ui().flash.duration(2e3).iconName("#" + d2.icon).iconClass("disabled").label(d2.disabledTitle)();
        }
        lastPointerUpType = null;
      }).call(tooltipBehavior);
      buttons.each(function(d2) {
        select_default2(this).call(svgIcon("#" + d2.icon, "light"));
      });
      utilKeybinding.plusKeys.forEach(function(key) {
        context.keybinding().on([key], zoomIn);
        context.keybinding().on([uiCmd("\u2325" + key)], zoomInFurther);
      });
      utilKeybinding.minusKeys.forEach(function(key) {
        context.keybinding().on([key], zoomOut);
        context.keybinding().on([uiCmd("\u2325" + key)], zoomOutFurther);
      });
      function updateButtonStates() {
        buttons.classed("disabled", function(d2) {
          return d2.disabled();
        }).each(function() {
          var selection3 = select_default2(this);
          if (!selection3.select(".tooltip.in").empty()) {
            selection3.call(tooltipBehavior.updateContent);
          }
        });
      }
      updateButtonStates();
      context.map().on("move.uiZoom", updateButtonStates);
    };
  }

  // modules/ui/sections/raw_tag_editor.js
  function uiSectionRawTagEditor(id2, context) {
    var section = uiSection(id2, context).classes("raw-tag-editor").label(function() {
      var count = Object.keys(_tags).filter(function(d2) {
        return d2;
      }).length;
      return _t.append("inspector.title_count", { title: _t("inspector.tags"), count });
    }).expandedByDefault(false).disclosureContent(renderDisclosureContent);
    var taginfo = services.taginfo;
    var dispatch14 = dispatch_default("change");
    var availableViews = [
      { id: "list", icon: "#fas-th-list" },
      { id: "text", icon: "#fas-i-cursor" }
    ];
    let _discardTags = {};
    _mainFileFetcher.get("discarded").then((d2) => {
      _discardTags = d2;
    }).catch(() => {
    });
    var _tagView = corePreferences("raw-tag-editor-view") || "list";
    var _readOnlyTags = [];
    var _orderedKeys = [];
    var _showBlank = false;
    var _pendingChange = null;
    var _state;
    var _presets;
    var _tags;
    var _entityIDs;
    var _didInteract = false;
    function interacted() {
      _didInteract = true;
    }
    function renderDisclosureContent(wrap2) {
      _orderedKeys = _orderedKeys.filter(function(key) {
        return _tags[key] !== void 0;
      });
      var all = Object.keys(_tags).sort();
      var missingKeys = utilArrayDifference(all, _orderedKeys);
      for (var i3 in missingKeys) {
        _orderedKeys.push(missingKeys[i3]);
      }
      var rowData = _orderedKeys.map(function(key, i4) {
        return { index: i4, key, value: _tags[key] };
      });
      if (!rowData.length || _showBlank) {
        _showBlank = false;
        rowData.push({ index: rowData.length, key: "", value: "" });
      }
      var options2 = wrap2.selectAll(".raw-tag-options").data([0]);
      options2.exit().remove();
      var optionsEnter = options2.enter().insert("div", ":first-child").attr("class", "raw-tag-options").attr("role", "tablist");
      var optionEnter = optionsEnter.selectAll(".raw-tag-option").data(availableViews, function(d2) {
        return d2.id;
      }).enter();
      optionEnter.append("button").attr("class", function(d2) {
        return "raw-tag-option raw-tag-option-" + d2.id + (_tagView === d2.id ? " selected" : "");
      }).attr("aria-selected", function(d2) {
        return _tagView === d2.id;
      }).attr("role", "tab").attr("title", function(d2) {
        return _t("icons." + d2.id);
      }).on("click", function(d3_event, d2) {
        _tagView = d2.id;
        corePreferences("raw-tag-editor-view", d2.id);
        wrap2.selectAll(".raw-tag-option").classed("selected", function(datum2) {
          return datum2 === d2;
        }).attr("aria-selected", function(datum2) {
          return datum2 === d2;
        });
        wrap2.selectAll(".tag-text").classed("hide", d2.id !== "text").each(setTextareaHeight);
        wrap2.selectAll(".tag-list, .add-row").classed("hide", d2.id !== "list");
      }).each(function(d2) {
        select_default2(this).call(svgIcon(d2.icon));
      });
      var textData = rowsToText(rowData);
      var textarea = wrap2.selectAll(".tag-text").data([0]);
      textarea = textarea.enter().append("textarea").attr("class", "tag-text" + (_tagView !== "text" ? " hide" : "")).call(utilNoAuto).attr("placeholder", _t("inspector.key_value")).attr("spellcheck", "false").merge(textarea);
      textarea.call(utilGetSetValue, textData).each(setTextareaHeight).on("input", setTextareaHeight).on("focus", interacted).on("blur", textChanged).on("change", textChanged);
      var list2 = wrap2.selectAll(".tag-list").data([0]);
      list2 = list2.enter().append("ul").attr("class", "tag-list" + (_tagView !== "list" ? " hide" : "")).merge(list2);
      var addRowEnter = wrap2.selectAll(".add-row").data([0]).enter().append("div").attr("class", "add-row" + (_tagView !== "list" ? " hide" : ""));
      addRowEnter.append("button").attr("class", "add-tag").attr("aria-label", _t("inspector.add_to_tag")).call(svgIcon("#iD-icon-plus", "light")).call(uiTooltip().title(() => _t.append("inspector.add_to_tag")).placement(_mainLocalizer.textDirection() === "ltr" ? "right" : "left")).on("click", addTag);
      addRowEnter.append("div").attr("class", "space-value");
      addRowEnter.append("div").attr("class", "space-buttons");
      var items = list2.selectAll(".tag-row").data(rowData, function(d2) {
        return d2.key;
      });
      items.exit().each(unbind).remove();
      var itemsEnter = items.enter().append("li").attr("class", "tag-row").classed("readonly", isReadOnly);
      var innerWrap = itemsEnter.append("div").attr("class", "inner-wrap");
      innerWrap.append("div").attr("class", "key-wrap").append("input").property("type", "text").attr("class", "key").call(utilNoAuto).on("focus", interacted).on("blur", keyChange).on("change", keyChange);
      innerWrap.append("div").attr("class", "value-wrap").append("input").property("type", "text").attr("class", "value").call(utilNoAuto).on("focus", interacted).on("blur", valueChange).on("change", valueChange).on("keydown.push-more", pushMore);
      innerWrap.append("button").attr("class", "form-field-button remove").attr("title", _t("icons.remove")).call(svgIcon("#iD-operation-delete"));
      items = items.merge(itemsEnter).sort(function(a2, b2) {
        return a2.index - b2.index;
      });
      items.each(function(d2) {
        var row = select_default2(this);
        var key = row.select("input.key");
        var value = row.select("input.value");
        if (_entityIDs && taginfo && _state !== "hover") {
          bindTypeahead(key, value);
        }
        var referenceOptions = { key: d2.key };
        if (typeof d2.value === "string") {
          referenceOptions.value = d2.value;
        }
        var reference = uiTagReference(referenceOptions, context);
        if (_state === "hover") {
          reference.showing(false);
        }
        row.select(".inner-wrap").call(reference.button);
        row.call(reference.body);
        row.select("button.remove");
      });
      items.selectAll("input.key").attr("title", function(d2) {
        return d2.key;
      }).call(utilGetSetValue, function(d2) {
        return d2.key;
      }).attr("readonly", function(d2) {
        return isReadOnly(d2) || null;
      });
      items.selectAll("input.value").attr("title", function(d2) {
        return Array.isArray(d2.value) ? d2.value.filter(Boolean).join("\n") : d2.value;
      }).classed("mixed", function(d2) {
        return Array.isArray(d2.value);
      }).attr("placeholder", function(d2) {
        return typeof d2.value === "string" ? null : _t("inspector.multiple_values");
      }).call(utilGetSetValue, function(d2) {
        return typeof d2.value === "string" ? d2.value : "";
      }).attr("readonly", function(d2) {
        return isReadOnly(d2) || null;
      });
      items.selectAll("button.remove").on(
        ("PointerEvent" in window ? "pointer" : "mouse") + "down",
        // 'click' fires too late - #5878
        (d3_event, d2) => {
          if (d3_event.button !== 0)
            return;
          removeTag(d3_event, d2);
        }
      );
    }
    function isReadOnly(d2) {
      for (var i3 = 0; i3 < _readOnlyTags.length; i3++) {
        if (d2.key.match(_readOnlyTags[i3]) !== null) {
          return true;
        }
      }
      return false;
    }
    function setTextareaHeight() {
      if (_tagView !== "text")
        return;
      var selection2 = select_default2(this);
      var matches = selection2.node().value.match(/\n/g);
      var lineCount = 2 + Number(matches && matches.length);
      var lineHeight = 20;
      selection2.style("height", lineCount * lineHeight + "px");
    }
    function stringify3(s2) {
      return JSON.stringify(s2).slice(1, -1);
    }
    function unstringify(s2) {
      var leading = "";
      var trailing = "";
      if (s2.length < 1 || s2.charAt(0) !== '"') {
        leading = '"';
      }
      if (s2.length < 2 || s2.charAt(s2.length - 1) !== '"' || s2.charAt(s2.length - 1) === '"' && s2.charAt(s2.length - 2) === "\\") {
        trailing = '"';
      }
      return JSON.parse(leading + s2 + trailing);
    }
    function rowsToText(rows) {
      var str = rows.filter(function(row) {
        return row.key && row.key.trim() !== "";
      }).map(function(row) {
        var rawVal = row.value;
        if (typeof rawVal !== "string")
          rawVal = "*";
        var val = rawVal ? stringify3(rawVal) : "";
        return stringify3(row.key) + "=" + val;
      }).join("\n");
      if (_state !== "hover" && str.length) {
        return str + "\n";
      }
      return str;
    }
    function textChanged() {
      var newText = this.value.trim();
      var newTags = {};
      newText.split("\n").forEach(function(row) {
        var m2 = row.match(/^\s*([^=]+)=(.*)$/);
        if (m2 !== null) {
          var k2 = context.cleanTagKey(unstringify(m2[1].trim()));
          var v2 = context.cleanTagValue(unstringify(m2[2].trim()));
          newTags[k2] = v2;
        }
      });
      var tagDiff = utilTagDiff(_tags, newTags);
      if (!tagDiff.length)
        return;
      _pendingChange = _pendingChange || {};
      tagDiff.forEach(function(change) {
        if (isReadOnly({ key: change.key }))
          return;
        if (change.newVal === "*" && typeof change.oldVal !== "string")
          return;
        if (change.type === "-") {
          _pendingChange[change.key] = void 0;
        } else if (change.type === "+") {
          _pendingChange[change.key] = change.newVal || "";
        }
      });
      if (Object.keys(_pendingChange).length === 0) {
        _pendingChange = null;
        return;
      }
      scheduleChange();
    }
    function pushMore(d3_event) {
      if (d3_event.keyCode === 9 && !d3_event.shiftKey && section.selection().selectAll(".tag-list li:last-child input.value").node() === this && utilGetSetValue(select_default2(this))) {
        addTag();
      }
    }
    function bindTypeahead(key, value) {
      if (isReadOnly(key.datum()))
        return;
      if (Array.isArray(value.datum().value)) {
        value.call(uiCombobox(context, "tag-value").minItems(1).fetcher(function(value2, callback) {
          var keyString = utilGetSetValue(key);
          if (!_tags[keyString])
            return;
          var data = _tags[keyString].map(function(tagValue) {
            if (!tagValue) {
              return {
                value: " ",
                title: _t("inspector.empty"),
                display: (selection2) => selection2.text("").classed("virtual-option", true).call(_t.append("inspector.empty"))
              };
            }
            return {
              value: tagValue,
              title: tagValue
            };
          });
          callback(data);
        }));
        return;
      }
      var geometry = context.graph().geometry(_entityIDs[0]);
      key.call(uiCombobox(context, "tag-key").fetcher(function(value2, callback) {
        taginfo.keys({
          debounce: true,
          geometry,
          query: value2
        }, function(err, data) {
          if (!err) {
            const filtered = data.filter((d2) => _tags[d2.value] === void 0).filter((d2) => !(d2.value in _discardTags)).filter((d2) => !/_\d$/.test(d2)).filter((d2) => d2.value.toLowerCase().includes(value2.toLowerCase()));
            callback(sort(value2, filtered));
          }
        });
      }));
      value.call(uiCombobox(context, "tag-value").fetcher(function(value2, callback) {
        taginfo.values({
          debounce: true,
          key: utilGetSetValue(key),
          geometry,
          query: value2
        }, function(err, data) {
          if (!err) {
            const filtered = data.filter((d2) => d2.value.toLowerCase().includes(value2.toLowerCase()));
            callback(sort(value2, filtered));
          }
        });
      }).caseSensitive(allowUpperCaseTagValues.test(utilGetSetValue(key))));
      function sort(value2, data) {
        var sameletter = [];
        var other = [];
        for (var i3 = 0; i3 < data.length; i3++) {
          if (data[i3].value.substring(0, value2.length) === value2) {
            sameletter.push(data[i3]);
          } else {
            other.push(data[i3]);
          }
        }
        return sameletter.concat(other);
      }
    }
    function unbind() {
      var row = select_default2(this);
      row.selectAll("input.key").call(uiCombobox.off, context);
      row.selectAll("input.value").call(uiCombobox.off, context);
    }
    function keyChange(d3_event, d2) {
      if (select_default2(this).attr("readonly"))
        return;
      var kOld = d2.key;
      if (_pendingChange && _pendingChange.hasOwnProperty(kOld) && _pendingChange[kOld] === void 0)
        return;
      var kNew = context.cleanTagKey(this.value.trim());
      if (isReadOnly({ key: kNew })) {
        this.value = kOld;
        return;
      }
      if (kNew && kNew !== kOld && _tags[kNew] !== void 0) {
        this.value = kOld;
        section.selection().selectAll(".tag-list input.value").each(function(d4) {
          if (d4.key === kNew) {
            var input = select_default2(this).node();
            input.focus();
            input.select();
          }
        });
        return;
      }
      _pendingChange = _pendingChange || {};
      if (kOld) {
        if (kOld === kNew)
          return;
        _pendingChange[kNew] = _pendingChange[kOld] || { oldKey: kOld };
        _pendingChange[kOld] = void 0;
      } else {
        let row = this.parentNode.parentNode;
        let inputVal = select_default2(row).selectAll("input.value");
        let vNew = context.cleanTagValue(utilGetSetValue(inputVal));
        _pendingChange[kNew] = vNew;
        utilGetSetValue(inputVal, vNew);
      }
      var existingKeyIndex = _orderedKeys.indexOf(kOld);
      if (existingKeyIndex !== -1)
        _orderedKeys[existingKeyIndex] = kNew;
      d2.key = kNew;
      this.value = kNew;
      scheduleChange();
    }
    function valueChange(d3_event, d2) {
      if (isReadOnly(d2))
        return;
      if (typeof d2.value !== "string" && !this.value)
        return;
      if (_pendingChange && _pendingChange.hasOwnProperty(d2.key) && _pendingChange[d2.key] === void 0)
        return;
      _pendingChange = _pendingChange || {};
      _pendingChange[d2.key] = context.cleanTagValue(this.value);
      scheduleChange();
    }
    function removeTag(d3_event, d2) {
      if (isReadOnly(d2))
        return;
      if (d2.key === "") {
        _showBlank = false;
        section.reRender();
      } else {
        _orderedKeys = _orderedKeys.filter(function(key) {
          return key !== d2.key;
        });
        _pendingChange = _pendingChange || {};
        _pendingChange[d2.key] = void 0;
        scheduleChange();
      }
    }
    function addTag() {
      window.setTimeout(function() {
        _showBlank = true;
        section.reRender();
        section.selection().selectAll(".tag-list li:last-child input.key").node().focus();
      }, 20);
    }
    function scheduleChange() {
      var entityIDs = _entityIDs;
      window.setTimeout(function() {
        if (!_pendingChange)
          return;
        dispatch14.call("change", this, entityIDs, _pendingChange);
        _pendingChange = null;
      }, 10);
    }
    section.state = function(val) {
      if (!arguments.length)
        return _state;
      if (_state !== val) {
        _orderedKeys = [];
        _state = val;
      }
      return section;
    };
    section.presets = function(val) {
      if (!arguments.length)
        return _presets;
      _presets = val;
      if (_presets && _presets.length && _presets[0].isFallback()) {
        section.disclosureExpanded(true);
      } else if (!_didInteract) {
        section.disclosureExpanded(null);
      }
      return section;
    };
    section.tags = function(val) {
      if (!arguments.length)
        return _tags;
      _tags = val;
      return section;
    };
    section.entityIDs = function(val) {
      if (!arguments.length)
        return _entityIDs;
      if (!_entityIDs || !val || !utilArrayIdentical(_entityIDs, val)) {
        _entityIDs = val;
        _orderedKeys = [];
      }
      return section;
    };
    section.readOnlyTags = function(val) {
      if (!arguments.length)
        return _readOnlyTags;
      _readOnlyTags = val;
      return section;
    };
    return utilRebind(section, dispatch14, "on");
  }

  // modules/ui/data_editor.js
  function uiDataEditor(context) {
    var dataHeader = uiDataHeader();
    var rawTagEditor = uiSectionRawTagEditor("custom-data-tag-editor", context).expandedByDefault(true).readOnlyTags([/./]);
    var _datum;
    function dataEditor(selection2) {
      var header = selection2.selectAll(".header").data([0]);
      var headerEnter = header.enter().append("div").attr("class", "header fillL");
      headerEnter.append("button").attr("class", "close").attr("title", _t("icons.close")).on("click", function() {
        context.enter(modeBrowse(context));
      }).call(svgIcon("#iD-icon-close"));
      headerEnter.append("h2").call(_t.append("map_data.title"));
      var body = selection2.selectAll(".body").data([0]);
      body = body.enter().append("div").attr("class", "body").merge(body);
      var editor = body.selectAll(".data-editor").data([0]);
      editor.enter().append("div").attr("class", "modal-section data-editor").merge(editor).call(dataHeader.datum(_datum));
      var rte = body.selectAll(".raw-tag-editor").data([0]);
      rte.enter().append("div").attr("class", "raw-tag-editor data-editor").merge(rte).call(
        rawTagEditor.tags(_datum && _datum.properties || {}).state("hover").render
      ).selectAll("textarea.tag-text").attr("readonly", true).classed("readonly", true);
    }
    dataEditor.datum = function(val) {
      if (!arguments.length)
        return _datum;
      _datum = val;
      return this;
    };
    return dataEditor;
  }

  // modules/ui/sidebar.js
  function uiSidebar(context) {
    var inspector = uiInspector(context);
    var dataEditor = uiDataEditor(context);
    var noteEditor = uiNoteEditor(context);
    var improveOsmEditor = uiImproveOsmEditor(context);
    var keepRightEditor = uiKeepRightEditor(context);
    var osmoseEditor = uiOsmoseEditor(context);
    var _current;
    var _wasData = false;
    var _wasNote = false;
    var _wasQaItem = false;
    var _pointerPrefix = "PointerEvent" in window ? "pointer" : "mouse";
    function sidebar(selection2) {
      var container = context.container();
      var minWidth = 240;
      var sidebarWidth;
      var containerWidth;
      var dragOffset;
      selection2.style("min-width", minWidth + "px").style("max-width", "400px").style("width", "33.3333%");
      var resizer = selection2.append("div").attr("class", "sidebar-resizer").on(_pointerPrefix + "down.sidebar-resizer", pointerdown);
      var downPointerId, lastClientX, containerLocGetter;
      function pointerdown(d3_event) {
        if (downPointerId)
          return;
        if ("button" in d3_event && d3_event.button !== 0)
          return;
        downPointerId = d3_event.pointerId || "mouse";
        lastClientX = d3_event.clientX;
        containerLocGetter = utilFastMouse(container.node());
        dragOffset = utilFastMouse(resizer.node())(d3_event)[0] - 1;
        sidebarWidth = selection2.node().getBoundingClientRect().width;
        containerWidth = container.node().getBoundingClientRect().width;
        var widthPct = sidebarWidth / containerWidth * 100;
        selection2.style("width", widthPct + "%").style("max-width", "85%");
        resizer.classed("dragging", true);
        select_default2(window).on("touchmove.sidebar-resizer", function(d3_event2) {
          d3_event2.preventDefault();
        }, { passive: false }).on(_pointerPrefix + "move.sidebar-resizer", pointermove).on(_pointerPrefix + "up.sidebar-resizer pointercancel.sidebar-resizer", pointerup);
      }
      function pointermove(d3_event) {
        if (downPointerId !== (d3_event.pointerId || "mouse"))
          return;
        d3_event.preventDefault();
        var dx = d3_event.clientX - lastClientX;
        lastClientX = d3_event.clientX;
        var isRTL = _mainLocalizer.textDirection() === "rtl";
        var scaleX = isRTL ? 0 : 1;
        var xMarginProperty = isRTL ? "margin-right" : "margin-left";
        var x2 = containerLocGetter(d3_event)[0] - dragOffset;
        sidebarWidth = isRTL ? containerWidth - x2 : x2;
        var isCollapsed = selection2.classed("collapsed");
        var shouldCollapse = sidebarWidth < minWidth;
        selection2.classed("collapsed", shouldCollapse);
        if (shouldCollapse) {
          if (!isCollapsed) {
            selection2.style(xMarginProperty, "-400px").style("width", "400px");
            context.ui().onResize([(sidebarWidth - dx) * scaleX, 0]);
          }
        } else {
          var widthPct = sidebarWidth / containerWidth * 100;
          selection2.style(xMarginProperty, null).style("width", widthPct + "%");
          if (isCollapsed) {
            context.ui().onResize([-sidebarWidth * scaleX, 0]);
          } else {
            context.ui().onResize([-dx * scaleX, 0]);
          }
        }
      }
      function pointerup(d3_event) {
        if (downPointerId !== (d3_event.pointerId || "mouse"))
          return;
        downPointerId = null;
        resizer.classed("dragging", false);
        select_default2(window).on("touchmove.sidebar-resizer", null).on(_pointerPrefix + "move.sidebar-resizer", null).on(_pointerPrefix + "up.sidebar-resizer pointercancel.sidebar-resizer", null);
      }
      var featureListWrap = selection2.append("div").attr("class", "feature-list-pane").call(uiFeatureList(context));
      var inspectorWrap = selection2.append("div").attr("class", "inspector-hidden inspector-wrap");
      var hoverModeSelect = function(targets) {
        context.container().selectAll(".feature-list-item button").classed("hover", false);
        if (context.selectedIDs().length > 1 && targets && targets.length) {
          var elements = context.container().selectAll(".feature-list-item button").filter(function(node) {
            return targets.indexOf(node) !== -1;
          });
          if (!elements.empty()) {
            elements.classed("hover", true);
          }
        }
      };
      sidebar.hoverModeSelect = throttle_default(hoverModeSelect, 200);
      function hover(targets) {
        var datum2 = targets && targets.length && targets[0];
        if (datum2 && datum2.__featurehash__) {
          _wasData = true;
          sidebar.show(dataEditor.datum(datum2));
          selection2.selectAll(".sidebar-component").classed("inspector-hover", true);
        } else if (datum2 instanceof osmNote) {
          if (context.mode().id === "drag-note")
            return;
          _wasNote = true;
          var osm = services.osm;
          if (osm) {
            datum2 = osm.getNote(datum2.id);
          }
          sidebar.show(noteEditor.note(datum2));
          selection2.selectAll(".sidebar-component").classed("inspector-hover", true);
        } else if (datum2 instanceof QAItem) {
          _wasQaItem = true;
          var errService = services[datum2.service];
          if (errService) {
            datum2 = errService.getError(datum2.id);
          }
          var errEditor;
          if (datum2.service === "keepRight") {
            errEditor = keepRightEditor;
          } else if (datum2.service === "osmose") {
            errEditor = osmoseEditor;
          } else {
            errEditor = improveOsmEditor;
          }
          context.container().selectAll(".qaItem." + datum2.service).classed("hover", function(d2) {
            return d2.id === datum2.id;
          });
          sidebar.show(errEditor.error(datum2));
          selection2.selectAll(".sidebar-component").classed("inspector-hover", true);
        } else if (!_current && datum2 instanceof osmEntity) {
          featureListWrap.classed("inspector-hidden", true);
          inspectorWrap.classed("inspector-hidden", false).classed("inspector-hover", true);
          if (!inspector.entityIDs() || !utilArrayIdentical(inspector.entityIDs(), [datum2.id]) || inspector.state() !== "hover") {
            inspector.state("hover").entityIDs([datum2.id]).newFeature(false);
            inspectorWrap.call(inspector);
          }
        } else if (!_current) {
          featureListWrap.classed("inspector-hidden", false);
          inspectorWrap.classed("inspector-hidden", true);
          inspector.state("hide");
        } else if (_wasData || _wasNote || _wasQaItem) {
          _wasNote = false;
          _wasData = false;
          _wasQaItem = false;
          context.container().selectAll(".note").classed("hover", false);
          context.container().selectAll(".qaItem").classed("hover", false);
          sidebar.hide();
        }
      }
      sidebar.hover = throttle_default(hover, 200);
      sidebar.intersects = function(extent) {
        var rect = selection2.node().getBoundingClientRect();
        return extent.intersects([
          context.projection.invert([0, rect.height]),
          context.projection.invert([rect.width, 0])
        ]);
      };
      sidebar.select = function(ids, newFeature) {
        sidebar.hide();
        if (ids && ids.length) {
          var entity = ids.length === 1 && context.entity(ids[0]);
          if (entity && newFeature && selection2.classed("collapsed")) {
            var extent = entity.extent(context.graph());
            sidebar.expand(sidebar.intersects(extent));
          }
          featureListWrap.classed("inspector-hidden", true);
          inspectorWrap.classed("inspector-hidden", false).classed("inspector-hover", false);
          inspector.state("select").entityIDs(ids).newFeature(newFeature);
          inspectorWrap.call(inspector);
        } else {
          inspector.state("hide");
        }
      };
      sidebar.showPresetList = function() {
        inspector.showList();
      };
      sidebar.show = function(component, element) {
        featureListWrap.classed("inspector-hidden", true);
        inspectorWrap.classed("inspector-hidden", true);
        if (_current)
          _current.remove();
        _current = selection2.append("div").attr("class", "sidebar-component").call(component, element);
      };
      sidebar.hide = function() {
        featureListWrap.classed("inspector-hidden", false);
        inspectorWrap.classed("inspector-hidden", true);
        if (_current)
          _current.remove();
        _current = null;
      };
      sidebar.expand = function(moveMap) {
        if (selection2.classed("collapsed")) {
          sidebar.toggle(moveMap);
        }
      };
      sidebar.collapse = function(moveMap) {
        if (!selection2.classed("collapsed")) {
          sidebar.toggle(moveMap);
        }
      };
      sidebar.toggle = function(moveMap) {
        if (context.inIntro())
          return;
        var isCollapsed = selection2.classed("collapsed");
        var isCollapsing = !isCollapsed;
        var isRTL = _mainLocalizer.textDirection() === "rtl";
        var scaleX = isRTL ? 0 : 1;
        var xMarginProperty = isRTL ? "margin-right" : "margin-left";
        sidebarWidth = selection2.node().getBoundingClientRect().width;
        selection2.style("width", sidebarWidth + "px");
        var startMargin, endMargin, lastMargin;
        if (isCollapsing) {
          startMargin = lastMargin = 0;
          endMargin = -sidebarWidth;
        } else {
          startMargin = lastMargin = -sidebarWidth;
          endMargin = 0;
        }
        if (!isCollapsing) {
          selection2.classed("collapsed", isCollapsing);
        }
        selection2.transition().style(xMarginProperty, endMargin + "px").tween("panner", function() {
          var i3 = number_default(startMargin, endMargin);
          return function(t2) {
            var dx = lastMargin - Math.round(i3(t2));
            lastMargin = lastMargin - dx;
            context.ui().onResize(moveMap ? void 0 : [dx * scaleX, 0]);
          };
        }).on("end", function() {
          if (isCollapsing) {
            selection2.classed("collapsed", isCollapsing);
          }
          if (!isCollapsing) {
            var containerWidth2 = container.node().getBoundingClientRect().width;
            var widthPct = sidebarWidth / containerWidth2 * 100;
            selection2.style(xMarginProperty, null).style("width", widthPct + "%");
          }
        });
      };
      resizer.on("dblclick", function(d3_event) {
        d3_event.preventDefault();
        if (d3_event.sourceEvent) {
          d3_event.sourceEvent.preventDefault();
        }
        sidebar.toggle();
      });
      context.map().on("crossEditableZoom.sidebar", function(within) {
        if (!within && !selection2.select(".inspector-hover").empty()) {
          hover([]);
        }
      });
    }
    sidebar.showPresetList = function() {
    };
    sidebar.hover = function() {
    };
    sidebar.hover.cancel = function() {
    };
    sidebar.intersects = function() {
    };
    sidebar.select = function() {
    };
    sidebar.show = function() {
    };
    sidebar.hide = function() {
    };
    sidebar.expand = function() {
    };
    sidebar.collapse = function() {
    };
    sidebar.toggle = function() {
    };
    return sidebar;
  }

  // modules/ui/tools/modes.js
  function uiToolDrawModes(context) {
    var tool = {
      id: "old_modes",
      label: _t.append("toolbar.add_feature")
    };
    var modes = [
      modeAddPoint(context, {
        title: _t.append("modes.add_point.title"),
        button: "point",
        description: _t.append("modes.add_point.description"),
        preset: _mainPresetIndex.item("point"),
        key: "1"
      }),
      modeAddLine(context, {
        title: _t.append("modes.add_line.title"),
        button: "line",
        description: _t.append("modes.add_line.description"),
        preset: _mainPresetIndex.item("line"),
        key: "2"
      }),
      modeAddArea(context, {
        title: _t.append("modes.add_area.title"),
        button: "area",
        description: _t.append("modes.add_area.description"),
        preset: _mainPresetIndex.item("area"),
        key: "3"
      })
    ];
    function enabled(_mode) {
      return osmEditable();
    }
    function osmEditable() {
      return context.editable();
    }
    modes.forEach(function(mode) {
      context.keybinding().on(mode.key, function() {
        if (!enabled(mode))
          return;
        if (mode.id === context.mode().id) {
          context.enter(modeBrowse(context));
        } else {
          context.enter(mode);
        }
      });
    });
    tool.render = function(selection2) {
      var wrap2 = selection2.append("div").attr("class", "joined").style("display", "flex");
      var debouncedUpdate = debounce_default(update, 500, { leading: true, trailing: true });
      context.map().on("move.modes", debouncedUpdate).on("drawn.modes", debouncedUpdate);
      context.on("enter.modes", update);
      update();
      function update() {
        var buttons = wrap2.selectAll("button.add-button").data(modes, function(d2) {
          return d2.id;
        });
        buttons.exit().remove();
        var buttonsEnter = buttons.enter().append("button").attr("class", function(d2) {
          return d2.id + " add-button bar-button";
        }).on("click.mode-buttons", function(d3_event, d2) {
          if (!enabled(d2))
            return;
          var currMode = context.mode().id;
          if (/^draw/.test(currMode))
            return;
          if (d2.id === currMode) {
            context.enter(modeBrowse(context));
          } else {
            context.enter(d2);
          }
        }).call(
          uiTooltip().placement("bottom").title(function(d2) {
            return d2.description;
          }).keys(function(d2) {
            return [d2.key];
          }).scrollContainer(context.container().select(".top-toolbar"))
        );
        buttonsEnter.each(function(d2) {
          select_default2(this).call(svgIcon("#iD-icon-" + d2.button));
        });
        buttonsEnter.append("span").attr("class", "label").text("").each(function(mode) {
          mode.title(select_default2(this));
        });
        if (buttons.enter().size() || buttons.exit().size()) {
          context.ui().checkOverflow(".top-toolbar", true);
        }
        buttons = buttons.merge(buttonsEnter).attr("aria-disabled", function(d2) {
          return !enabled(d2);
        }).classed("disabled", function(d2) {
          return !enabled(d2);
        }).attr("aria-pressed", function(d2) {
          return context.mode() && context.mode().button === d2.button;
        }).classed("active", function(d2) {
          return context.mode() && context.mode().button === d2.button;
        });
      }
    };
    return tool;
  }

  // modules/ui/tools/notes.js
  function uiToolNotes(context) {
    var tool = {
      id: "notes",
      label: _t.append("modes.add_note.label")
    };
    var mode = modeAddNote(context);
    function enabled() {
      return notesEnabled() && notesEditable();
    }
    function notesEnabled() {
      var noteLayer = context.layers().layer("notes");
      return noteLayer && noteLayer.enabled();
    }
    function notesEditable() {
      var mode2 = context.mode();
      return context.map().notesEditable() && mode2 && mode2.id !== "save";
    }
    context.keybinding().on(mode.key, function() {
      if (!enabled())
        return;
      if (mode.id === context.mode().id) {
        context.enter(modeBrowse(context));
      } else {
        context.enter(mode);
      }
    });
    tool.render = function(selection2) {
      var debouncedUpdate = debounce_default(update, 500, { leading: true, trailing: true });
      context.map().on("move.notes", debouncedUpdate).on("drawn.notes", debouncedUpdate);
      context.on("enter.notes", update);
      update();
      function update() {
        var showNotes = notesEnabled();
        var data = showNotes ? [mode] : [];
        var buttons = selection2.selectAll("button.add-button").data(data, function(d2) {
          return d2.id;
        });
        buttons.exit().remove();
        var buttonsEnter = buttons.enter().append("button").attr("class", function(d2) {
          return d2.id + " add-button bar-button";
        }).on("click.notes", function(d3_event, d2) {
          if (!enabled())
            return;
          var currMode = context.mode().id;
          if (/^draw/.test(currMode))
            return;
          if (d2.id === currMode) {
            context.enter(modeBrowse(context));
          } else {
            context.enter(d2);
          }
        }).call(
          uiTooltip().placement("bottom").title(function(d2) {
            return d2.description;
          }).keys(function(d2) {
            return [d2.key];
          }).scrollContainer(context.container().select(".top-toolbar"))
        );
        buttonsEnter.each(function(d2) {
          select_default2(this).call(svgIcon(d2.icon || "#iD-icon-" + d2.button));
        });
        if (buttons.enter().size() || buttons.exit().size()) {
          context.ui().checkOverflow(".top-toolbar", true);
        }
        buttons = buttons.merge(buttonsEnter).classed("disabled", function() {
          return !enabled();
        }).attr("aria-disabled", function() {
          return !enabled();
        }).classed("active", function(d2) {
          return context.mode() && context.mode().button === d2.button;
        }).attr("aria-pressed", function(d2) {
          return context.mode() && context.mode().button === d2.button;
        });
      }
    };
    tool.uninstall = function() {
      context.on("enter.editor.notes", null).on("exit.editor.notes", null).on("enter.notes", null);
      context.map().on("move.notes", null).on("drawn.notes", null);
    };
    return tool;
  }

  // modules/ui/tools/save.js
  function uiToolSave(context) {
    var tool = {
      id: "save",
      label: _t.append("save.title")
    };
    var button = null;
    var tooltipBehavior = null;
    var history = context.history();
    var key = uiCmd("\u2318S");
    var _numChanges = 0;
    function isSaving() {
      var mode = context.mode();
      return mode && mode.id === "save";
    }
    function isDisabled() {
      return _numChanges === 0 || isSaving();
    }
    function save(d3_event) {
      d3_event.preventDefault();
      if (!context.inIntro() && !isSaving() && history.hasChanges()) {
        context.enter(modeSave(context));
      }
    }
    function bgColor(numChanges) {
      var step;
      if (numChanges === 0) {
        return null;
      } else if (numChanges <= 50) {
        step = numChanges / 50;
        return rgb_default("#fff", "#ff8")(step);
      } else {
        step = Math.min((numChanges - 50) / 50, 1);
        return rgb_default("#ff8", "#f88")(step);
      }
    }
    function updateCount() {
      var val = history.difference().summary().length;
      if (val === _numChanges)
        return;
      _numChanges = val;
      if (tooltipBehavior) {
        tooltipBehavior.title(() => _t.append(_numChanges > 0 ? "save.help" : "save.no_changes")).keys([key]);
      }
      if (button) {
        button.classed("disabled", isDisabled()).style("background", bgColor(_numChanges));
        button.select("span.count").text(_numChanges);
      }
    }
    tool.render = function(selection2) {
      tooltipBehavior = uiTooltip().placement("bottom").title(() => _t.append("save.no_changes")).keys([key]).scrollContainer(context.container().select(".top-toolbar"));
      var lastPointerUpType;
      button = selection2.append("button").attr("class", "save disabled bar-button").on("pointerup", function(d3_event) {
        lastPointerUpType = d3_event.pointerType;
      }).on("click", function(d3_event) {
        save(d3_event);
        if (_numChanges === 0 && (lastPointerUpType === "touch" || lastPointerUpType === "pen")) {
          context.ui().flash.duration(2e3).iconName("#iD-icon-save").iconClass("disabled").label(_t.append("save.no_changes"))();
        }
        lastPointerUpType = null;
      }).call(tooltipBehavior);
      button.call(svgIcon("#iD-icon-save"));
      button.append("span").attr("class", "count").attr("aria-hidden", "true").text("0");
      updateCount();
      context.keybinding().on(key, save, true);
      context.history().on("change.save", updateCount);
      context.on("enter.save", function() {
        if (button) {
          button.classed("disabled", isDisabled());
          if (isSaving()) {
            button.call(tooltipBehavior.hide);
          }
        }
      });
    };
    tool.uninstall = function() {
      context.keybinding().off(key, true);
      context.history().on("change.save", null);
      context.on("enter.save", null);
      button = null;
      tooltipBehavior = null;
    };
    return tool;
  }

  // modules/ui/tools/sidebar_toggle.js
  function uiToolSidebarToggle(context) {
    var tool = {
      id: "sidebar_toggle",
      label: _t.append("toolbar.inspect")
    };
    tool.render = function(selection2) {
      selection2.append("button").attr("class", "bar-button").attr("aria-label", _t("sidebar.tooltip")).on("click", function() {
        context.ui().sidebar.toggle();
      }).call(
        uiTooltip().placement("bottom").title(() => _t.append("sidebar.tooltip")).keys([_t("sidebar.key")]).scrollContainer(context.container().select(".top-toolbar"))
      ).call(svgIcon("#iD-icon-sidebar-" + (_mainLocalizer.textDirection() === "rtl" ? "right" : "left")));
    };
    return tool;
  }

  // modules/ui/tools/undo_redo.js
  function uiToolUndoRedo(context) {
    var tool = {
      id: "undo_redo",
      label: _t.append("toolbar.undo_redo")
    };
    var commands = [{
      id: "undo",
      cmd: uiCmd("\u2318Z"),
      action: function() {
        context.undo();
      },
      annotation: function() {
        return context.history().undoAnnotation();
      },
      icon: "iD-icon-" + (_mainLocalizer.textDirection() === "rtl" ? "redo" : "undo")
    }, {
      id: "redo",
      cmd: uiCmd("\u2318\u21E7Z"),
      action: function() {
        context.redo();
      },
      annotation: function() {
        return context.history().redoAnnotation();
      },
      icon: "iD-icon-" + (_mainLocalizer.textDirection() === "rtl" ? "undo" : "redo")
    }];
    function editable() {
      return context.mode() && context.mode().id !== "save" && context.map().editableDataEnabled(
        true
        /* ignore min zoom */
      );
    }
    tool.render = function(selection2) {
      var tooltipBehavior = uiTooltip().placement("bottom").title(function(d2) {
        return d2.annotation() ? _t.append(d2.id + ".tooltip", { action: d2.annotation() }) : _t.append(d2.id + ".nothing");
      }).keys(function(d2) {
        return [d2.cmd];
      }).scrollContainer(context.container().select(".top-toolbar"));
      var lastPointerUpType;
      var buttons = selection2.selectAll("button").data(commands).enter().append("button").attr("class", function(d2) {
        return "disabled " + d2.id + "-button bar-button";
      }).on("pointerup", function(d3_event) {
        lastPointerUpType = d3_event.pointerType;
      }).on("click", function(d3_event, d2) {
        d3_event.preventDefault();
        var annotation = d2.annotation();
        if (editable() && annotation) {
          d2.action();
        }
        if (editable() && (lastPointerUpType === "touch" || lastPointerUpType === "pen")) {
          var label = annotation ? _t.append(d2.id + ".tooltip", { action: annotation }) : _t.append(d2.id + ".nothing");
          context.ui().flash.duration(2e3).iconName("#" + d2.icon).iconClass(annotation ? "" : "disabled").label(label)();
        }
        lastPointerUpType = null;
      }).call(tooltipBehavior);
      buttons.each(function(d2) {
        select_default2(this).call(svgIcon("#" + d2.icon));
      });
      context.keybinding().on(commands[0].cmd, function(d3_event) {
        d3_event.preventDefault();
        if (editable())
          commands[0].action();
      }).on(commands[1].cmd, function(d3_event) {
        d3_event.preventDefault();
        if (editable())
          commands[1].action();
      });
      var debouncedUpdate = debounce_default(update, 500, { leading: true, trailing: true });
      context.map().on("move.undo_redo", debouncedUpdate).on("drawn.undo_redo", debouncedUpdate);
      context.history().on("change.undo_redo", function(difference2) {
        if (difference2)
          update();
      });
      context.on("enter.undo_redo", update);
      function update() {
        buttons.classed("disabled", function(d2) {
          return !editable() || !d2.annotation();
        }).each(function() {
          var selection3 = select_default2(this);
          if (!selection3.select(".tooltip.in").empty()) {
            selection3.call(tooltipBehavior.updateContent);
          }
        });
      }
    };
    tool.uninstall = function() {
      context.keybinding().off(commands[0].cmd).off(commands[1].cmd);
      context.map().on("move.undo_redo", null).on("drawn.undo_redo", null);
      context.history().on("change.undo_redo", null);
      context.on("enter.undo_redo", null);
    };
    return tool;
  }

  // modules/ui/top_toolbar.js
  function uiTopToolbar(context) {
    var sidebarToggle = uiToolSidebarToggle(context), modes = uiToolDrawModes(context), notes = uiToolNotes(context), undoRedo = uiToolUndoRedo(context), save = uiToolSave(context);
    function notesEnabled() {
      var noteLayer = context.layers().layer("notes");
      return noteLayer && noteLayer.enabled();
    }
    function topToolbar(bar) {
      bar.on("wheel.topToolbar", function(d3_event) {
        if (!d3_event.deltaX) {
          bar.node().scrollLeft += d3_event.deltaY;
        }
      });
      var debouncedUpdate = debounce_default(update, 500, { leading: true, trailing: true });
      context.layers().on("change.topToolbar", debouncedUpdate);
      update();
      function update() {
        var tools = [
          sidebarToggle,
          "spacer",
          modes
        ];
        tools.push("spacer");
        if (notesEnabled()) {
          tools = tools.concat([notes, "spacer"]);
        }
        tools = tools.concat([undoRedo, save]);
        var toolbarItems = bar.selectAll(".toolbar-item").data(tools, function(d2) {
          return d2.id || d2;
        });
        toolbarItems.exit().each(function(d2) {
          if (d2.uninstall) {
            d2.uninstall();
          }
        }).remove();
        var itemsEnter = toolbarItems.enter().append("div").attr("class", function(d2) {
          var classes = "toolbar-item " + (d2.id || d2).replace("_", "-");
          if (d2.klass)
            classes += " " + d2.klass;
          return classes;
        });
        var actionableItems = itemsEnter.filter(function(d2) {
          return d2 !== "spacer";
        });
        actionableItems.append("div").attr("class", "item-content").each(function(d2) {
          select_default2(this).call(d2.render, bar);
        });
        actionableItems.append("div").attr("class", "item-label").each(function(d2) {
          d2.label(select_default2(this));
        });
      }
    }
    return topToolbar;
  }

  // modules/ui/zoom_to_selection.js
  function uiZoomToSelection(context) {
    function isDisabled() {
      var mode = context.mode();
      return !mode || !mode.zoomToSelected;
    }
    var _lastPointerUpType;
    function pointerup(d3_event) {
      _lastPointerUpType = d3_event.pointerType;
    }
    function click(d3_event) {
      d3_event.preventDefault();
      if (isDisabled()) {
        if (_lastPointerUpType === "touch" || _lastPointerUpType === "pen") {
          context.ui().flash.duration(2e3).iconName("#iD-icon-framed-dot").iconClass("disabled").label(_t.append("inspector.zoom_to.no_selection"))();
        }
      } else {
        var mode = context.mode();
        if (mode && mode.zoomToSelected) {
          mode.zoomToSelected();
        }
      }
      _lastPointerUpType = null;
    }
    return function(selection2) {
      var tooltipBehavior = uiTooltip().placement(_mainLocalizer.textDirection() === "rtl" ? "right" : "left").title(function() {
        if (isDisabled()) {
          return _t.append("inspector.zoom_to.no_selection");
        }
        return _t.append("inspector.zoom_to.title");
      }).keys([_t("inspector.zoom_to.key")]);
      var button = selection2.append("button").on("pointerup", pointerup).on("click", click).call(svgIcon("#iD-icon-framed-dot", "light")).call(tooltipBehavior);
      function setEnabledState() {
        button.classed("disabled", isDisabled());
        if (!button.select(".tooltip.in").empty()) {
          button.call(tooltipBehavior.updateContent);
        }
      }
      context.on("enter.uiZoomToSelection", setEnabledState);
      setEnabledState();
    };
  }

  // modules/ui/pane.js
  function uiPane(id2, context) {
    var _key;
    var _label = "";
    var _description = "";
    var _iconName = "";
    var _sections;
    var _paneSelection = select_default2(null);
    var _paneTooltip;
    var pane = {
      id: id2
    };
    pane.label = function(val) {
      if (!arguments.length)
        return _label;
      _label = val;
      return pane;
    };
    pane.key = function(val) {
      if (!arguments.length)
        return _key;
      _key = val;
      return pane;
    };
    pane.description = function(val) {
      if (!arguments.length)
        return _description;
      _description = val;
      return pane;
    };
    pane.iconName = function(val) {
      if (!arguments.length)
        return _iconName;
      _iconName = val;
      return pane;
    };
    pane.sections = function(val) {
      if (!arguments.length)
        return _sections;
      _sections = val;
      return pane;
    };
    pane.selection = function() {
      return _paneSelection;
    };
    function hidePane() {
      context.ui().togglePanes();
    }
    pane.togglePane = function(d3_event) {
      if (d3_event)
        d3_event.preventDefault();
      _paneTooltip.hide();
      context.ui().togglePanes(!_paneSelection.classed("shown") ? _paneSelection : void 0);
    };
    pane.renderToggleButton = function(selection2) {
      if (!_paneTooltip) {
        _paneTooltip = uiTooltip().placement(_mainLocalizer.textDirection() === "rtl" ? "right" : "left").title(() => _description).keys([_key]);
      }
      selection2.append("button").on("click", pane.togglePane).call(svgIcon("#" + _iconName, "light")).call(_paneTooltip);
    };
    pane.renderContent = function(selection2) {
      if (_sections) {
        _sections.forEach(function(section) {
          selection2.call(section.render);
        });
      }
    };
    pane.renderPane = function(selection2) {
      _paneSelection = selection2.append("div").attr("class", "fillL map-pane hide " + id2 + "-pane").attr("pane", id2);
      var heading2 = _paneSelection.append("div").attr("class", "pane-heading");
      heading2.append("h2").text("").call(_label);
      heading2.append("button").attr("title", _t("icons.close")).on("click", hidePane).call(svgIcon("#iD-icon-close"));
      _paneSelection.append("div").attr("class", "pane-content").call(pane.renderContent);
      if (_key) {
        context.keybinding().on(_key, pane.togglePane);
      }
    };
    return pane;
  }

  // modules/ui/sections/background_display_options.js
  function uiSectionBackgroundDisplayOptions(context) {
    var section = uiSection("background-display-options", context).label(() => _t.append("background.display_options")).disclosureContent(renderDisclosureContent);
    var _storedOpacity = corePreferences("background-opacity");
    var _minVal = 0;
    var _maxVal = 3;
    var _sliders = ["brightness", "contrast", "saturation", "sharpness"];
    var _options = {
      brightness: _storedOpacity !== null ? +_storedOpacity : 1,
      contrast: 1,
      saturation: 1,
      sharpness: 1
    };
    function clamp3(x2, min3, max3) {
      return Math.max(min3, Math.min(x2, max3));
    }
    function updateValue(d2, val) {
      val = clamp3(val, _minVal, _maxVal);
      _options[d2] = val;
      context.background()[d2](val);
      if (d2 === "brightness") {
        corePreferences("background-opacity", val);
      }
      section.reRender();
    }
    function renderDisclosureContent(selection2) {
      var container = selection2.selectAll(".display-options-container").data([0]);
      var containerEnter = container.enter().append("div").attr("class", "display-options-container controls-list");
      var slidersEnter = containerEnter.selectAll(".display-control").data(_sliders).enter().append("label").attr("class", function(d2) {
        return "display-control display-control-" + d2;
      });
      slidersEnter.html(function(d2) {
        return _t.html("background." + d2);
      }).append("span").attr("class", function(d2) {
        return "display-option-value display-option-value-" + d2;
      });
      var sildersControlEnter = slidersEnter.append("div").attr("class", "control-wrap");
      sildersControlEnter.append("input").attr("class", function(d2) {
        return "display-option-input display-option-input-" + d2;
      }).attr("type", "range").attr("min", _minVal).attr("max", _maxVal).attr("step", "0.05").on("input", function(d3_event, d2) {
        var val = select_default2(this).property("value");
        if (!val && d3_event && d3_event.target) {
          val = d3_event.target.value;
        }
        updateValue(d2, val);
      });
      sildersControlEnter.append("button").attr("title", function(d2) {
        return "".concat(_t("background.reset"), " ").concat(_t("background." + d2));
      }).attr("class", function(d2) {
        return "display-option-reset display-option-reset-" + d2;
      }).on("click", function(d3_event, d2) {
        if (d3_event.button !== 0)
          return;
        updateValue(d2, 1);
      }).call(svgIcon("#iD-icon-" + (_mainLocalizer.textDirection() === "rtl" ? "redo" : "undo")));
      containerEnter.append("a").attr("class", "display-option-resetlink").attr("role", "button").attr("href", "#").call(_t.append("background.reset_all")).on("click", function(d3_event) {
        d3_event.preventDefault();
        for (var i3 = 0; i3 < _sliders.length; i3++) {
          updateValue(_sliders[i3], 1);
        }
      });
      container = containerEnter.merge(container);
      container.selectAll(".display-option-input").property("value", function(d2) {
        return _options[d2];
      });
      container.selectAll(".display-option-value").text(function(d2) {
        return Math.floor(_options[d2] * 100) + "%";
      });
      container.selectAll(".display-option-reset").classed("disabled", function(d2) {
        return _options[d2] === 1;
      });
      if (containerEnter.size() && _options.brightness !== 1) {
        context.background().brightness(_options.brightness);
      }
    }
    return section;
  }

  // modules/ui/settings/custom_background.js
  function uiSettingsCustomBackground() {
    var dispatch14 = dispatch_default("change");
    function render(selection2) {
      var _origSettings = {
        template: corePreferences("background-custom-template")
      };
      var _currSettings = {
        template: corePreferences("background-custom-template")
      };
      var example = "https://tile.openstreetmap.org/{zoom}/{x}/{y}.png";
      var modal = uiConfirm(selection2).okButton();
      modal.classed("settings-modal settings-custom-background", true);
      modal.select(".modal-section.header").append("h3").call(_t.append("settings.custom_background.header"));
      var textSection = modal.select(".modal-section.message-text");
      var instructions = "".concat(_t.html("settings.custom_background.instructions.info"), "\n") + "\n" + "#### ".concat(_t.html("settings.custom_background.instructions.wms.tokens_label"), "\n") + "* ".concat(_t.html("settings.custom_background.instructions.wms.tokens.proj"), "\n") + "* ".concat(_t.html("settings.custom_background.instructions.wms.tokens.wkid"), "\n") + "* ".concat(_t.html("settings.custom_background.instructions.wms.tokens.dimensions"), "\n") + "* ".concat(_t.html("settings.custom_background.instructions.wms.tokens.bbox"), "\n") + "\n" + "#### ".concat(_t.html("settings.custom_background.instructions.tms.tokens_label"), "\n") + "* ".concat(_t.html("settings.custom_background.instructions.tms.tokens.xyz"), "\n") + "* ".concat(_t.html("settings.custom_background.instructions.tms.tokens.flipped_y"), "\n") + "* ".concat(_t.html("settings.custom_background.instructions.tms.tokens.switch"), "\n") + "* ".concat(_t.html("settings.custom_background.instructions.tms.tokens.quadtile"), "\n") + "* ".concat(_t.html("settings.custom_background.instructions.tms.tokens.scale_factor"), "\n") + "\n" + "#### ".concat(_t.html("settings.custom_background.instructions.example"), "\n") + "`".concat(example, "`");
      textSection.append("div").attr("class", "instructions-template").html(marked(instructions));
      textSection.append("textarea").attr("class", "field-template").attr("placeholder", _t("settings.custom_background.template.placeholder")).call(utilNoAuto).property("value", _currSettings.template);
      var buttonSection = modal.select(".modal-section.buttons");
      buttonSection.insert("button", ".ok-button").attr("class", "button cancel-button secondary-action").call(_t.append("confirm.cancel"));
      buttonSection.select(".cancel-button").on("click.cancel", clickCancel);
      buttonSection.select(".ok-button").attr("disabled", isSaveDisabled).on("click.save", clickSave);
      function isSaveDisabled() {
        return null;
      }
      function clickCancel() {
        textSection.select(".field-template").property("value", _origSettings.template);
        corePreferences("background-custom-template", _origSettings.template);
        this.blur();
        modal.close();
      }
      function clickSave() {
        _currSettings.template = textSection.select(".field-template").property("value");
        corePreferences("background-custom-template", _currSettings.template);
        this.blur();
        modal.close();
        dispatch14.call("change", this, _currSettings);
      }
    }
    return utilRebind(render, dispatch14, "on");
  }

  // modules/ui/sections/background_list.js
  function uiSectionBackgroundList(context) {
    var _backgroundList = select_default2(null);
    var _customSource = context.background().findSource("custom");
    var _settingsCustomBackground = uiSettingsCustomBackground(context).on("change", customChanged);
    var section = uiSection("background-list", context).label(() => _t.append("background.backgrounds")).disclosureContent(renderDisclosureContent);
    function previousBackgroundID() {
      return corePreferences("background-last-used-toggle");
    }
    function renderDisclosureContent(selection2) {
      var container = selection2.selectAll(".layer-background-list").data([0]);
      _backgroundList = container.enter().append("ul").attr("class", "layer-list layer-background-list").attr("dir", "auto").merge(container);
      var bgExtrasListEnter = selection2.selectAll(".bg-extras-list").data([0]).enter().append("ul").attr("class", "layer-list bg-extras-list");
      var minimapLabelEnter = bgExtrasListEnter.append("li").attr("class", "minimap-toggle-item").append("label").call(
        uiTooltip().title(() => _t.append("background.minimap.tooltip")).keys([_t("background.minimap.key")]).placement("top")
      );
      minimapLabelEnter.append("input").attr("type", "checkbox").on("change", function(d3_event) {
        d3_event.preventDefault();
        uiMapInMap.toggle();
      });
      minimapLabelEnter.append("span").call(_t.append("background.minimap.description"));
      var panelLabelEnter = bgExtrasListEnter.append("li").attr("class", "background-panel-toggle-item").append("label").call(
        uiTooltip().title(() => _t.append("background.panel.tooltip")).keys([uiCmd("\u2318\u21E7" + _t("info_panels.background.key"))]).placement("top")
      );
      panelLabelEnter.append("input").attr("type", "checkbox").on("change", function(d3_event) {
        d3_event.preventDefault();
        context.ui().info.toggle("background");
      });
      panelLabelEnter.append("span").call(_t.append("background.panel.description"));
      var locPanelLabelEnter = bgExtrasListEnter.append("li").attr("class", "location-panel-toggle-item").append("label").call(
        uiTooltip().title(() => _t.append("background.location_panel.tooltip")).keys([uiCmd("\u2318\u21E7" + _t("info_panels.location.key"))]).placement("top")
      );
      locPanelLabelEnter.append("input").attr("type", "checkbox").on("change", function(d3_event) {
        d3_event.preventDefault();
        context.ui().info.toggle("location");
      });
      locPanelLabelEnter.append("span").call(_t.append("background.location_panel.description"));
      selection2.selectAll(".imagery-faq").data([0]).enter().append("div").attr("class", "imagery-faq").append("a").attr("target", "_blank").call(svgIcon("#iD-icon-out-link", "inline")).attr("href", "https://github.com/openstreetmap/iD/blob/develop/FAQ.md#how-can-i-report-an-issue-with-background-imagery").append("span").call(_t.append("background.imagery_problem_faq"));
      _backgroundList.call(drawListItems, "radio", function(d3_event, d2) {
        chooseBackground(d2);
      }, function(d2) {
        return !d2.isHidden() && !d2.overlay;
      });
    }
    function setTooltips(selection2) {
      selection2.each(function(d2, i3, nodes) {
        var item = select_default2(this).select("label");
        var span = item.select("span");
        var placement = i3 < nodes.length / 2 ? "bottom" : "top";
        var hasDescription = d2.hasDescription();
        var isOverflowing = span.property("clientWidth") !== span.property("scrollWidth");
        item.call(uiTooltip().destroyAny);
        if (d2.id === previousBackgroundID()) {
          item.call(
            uiTooltip().placement(placement).title(() => _t.append("background.switch")).keys([uiCmd("\u2318" + _t("background.key"))])
          );
        } else if (hasDescription || isOverflowing) {
          item.call(
            uiTooltip().placement(placement).title(() => hasDescription ? d2.description() : d2.label())
          );
        }
      });
    }
    function drawListItems(layerList, type2, change, filter2) {
      var sources = context.background().sources(context.map().extent(), context.map().zoom(), true).filter(filter2).sort(function(a2, b2) {
        return a2.best() && !b2.best() ? -1 : b2.best() && !a2.best() ? 1 : descending(a2.area(), b2.area()) || ascending(a2.name(), b2.name()) || 0;
      });
      var layerLinks = layerList.selectAll("li").data(sources, function(d2, i3) {
        return d2.id + "---" + i3;
      });
      layerLinks.exit().remove();
      var enter = layerLinks.enter().append("li").classed("layer-custom", function(d2) {
        return d2.id === "custom";
      }).classed("best", function(d2) {
        return d2.best();
      });
      var label = enter.append("label");
      label.append("input").attr("type", type2).attr("name", "background-layer").attr("value", function(d2) {
        return d2.id;
      }).on("change", change);
      label.append("span").each(function(d2) {
        d2.label()(select_default2(this));
      });
      enter.filter(function(d2) {
        return d2.id === "custom";
      }).append("button").attr("class", "layer-browse").call(
        uiTooltip().title(() => _t.append("settings.custom_background.tooltip")).placement(_mainLocalizer.textDirection() === "rtl" ? "right" : "left")
      ).on("click", function(d3_event) {
        d3_event.preventDefault();
        editCustom();
      }).call(svgIcon("#iD-icon-more"));
      enter.filter(function(d2) {
        return d2.best();
      }).append("div").attr("class", "best").call(
        uiTooltip().title(() => _t.append("background.best_imagery")).placement(_mainLocalizer.textDirection() === "rtl" ? "right" : "left")
      ).append("span").text("\u2605");
      layerList.call(updateLayerSelections);
    }
    function updateLayerSelections(selection2) {
      function active(d2) {
        return context.background().showsLayer(d2);
      }
      selection2.selectAll("li").classed("active", active).classed("switch", function(d2) {
        return d2.id === previousBackgroundID();
      }).call(setTooltips).selectAll("input").property("checked", active);
    }
    function chooseBackground(d2) {
      if (d2.id === "custom" && !d2.template()) {
        return editCustom();
      }
      var previousBackground = context.background().baseLayerSource();
      corePreferences("background-last-used-toggle", previousBackground.id);
      corePreferences("background-last-used", d2.id);
      context.background().baseLayerSource(d2);
    }
    function customChanged(d2) {
      if (d2 && d2.template) {
        _customSource.template(d2.template);
        chooseBackground(_customSource);
      } else {
        _customSource.template("");
        chooseBackground(context.background().findSource("none"));
      }
    }
    function editCustom() {
      context.container().call(_settingsCustomBackground);
    }
    context.background().on("change.background_list", function() {
      _backgroundList.call(updateLayerSelections);
    });
    context.map().on(
      "move.background_list",
      debounce_default(function() {
        window.requestIdleCallback(section.reRender);
      }, 1e3)
    );
    return section;
  }

  // modules/ui/sections/background_offset.js
  function uiSectionBackgroundOffset(context) {
    var section = uiSection("background-offset", context).label(() => _t.append("background.fix_misalignment")).disclosureContent(renderDisclosureContent).expandedByDefault(false);
    var _pointerPrefix = "PointerEvent" in window ? "pointer" : "mouse";
    var _directions = [
      ["top", [0, -0.5]],
      ["left", [-0.5, 0]],
      ["right", [0.5, 0]],
      ["bottom", [0, 0.5]]
    ];
    function updateValue() {
      var meters = geoOffsetToMeters(context.background().offset());
      var x2 = +meters[0].toFixed(2);
      var y2 = +meters[1].toFixed(2);
      context.container().selectAll(".nudge-inner-rect").select("input").classed("error", false).property("value", x2 + ", " + y2);
      context.container().selectAll(".nudge-reset").classed("disabled", function() {
        return x2 === 0 && y2 === 0;
      });
    }
    function resetOffset() {
      context.background().offset([0, 0]);
      updateValue();
    }
    function nudge(d2) {
      context.background().nudge(d2, context.map().zoom());
      updateValue();
    }
    function inputOffset() {
      var input = select_default2(this);
      var d2 = input.node().value;
      if (d2 === "")
        return resetOffset();
      d2 = d2.replace(/;/g, ",").split(",").map(function(n3) {
        return !isNaN(n3) && n3;
      });
      if (d2.length !== 2 || !d2[0] || !d2[1]) {
        input.classed("error", true);
        return;
      }
      context.background().offset(geoMetersToOffset(d2));
      updateValue();
    }
    function dragOffset(d3_event) {
      if (d3_event.button !== 0)
        return;
      var origin = [d3_event.clientX, d3_event.clientY];
      var pointerId = d3_event.pointerId || "mouse";
      context.container().append("div").attr("class", "nudge-surface");
      select_default2(window).on(_pointerPrefix + "move.drag-bg-offset", pointermove).on(_pointerPrefix + "up.drag-bg-offset", pointerup);
      if (_pointerPrefix === "pointer") {
        select_default2(window).on("pointercancel.drag-bg-offset", pointerup);
      }
      function pointermove(d3_event2) {
        if (pointerId !== (d3_event2.pointerId || "mouse"))
          return;
        var latest = [d3_event2.clientX, d3_event2.clientY];
        var d2 = [
          -(origin[0] - latest[0]) / 4,
          -(origin[1] - latest[1]) / 4
        ];
        origin = latest;
        nudge(d2);
      }
      function pointerup(d3_event2) {
        if (pointerId !== (d3_event2.pointerId || "mouse"))
          return;
        if (d3_event2.button !== 0)
          return;
        context.container().selectAll(".nudge-surface").remove();
        select_default2(window).on(".drag-bg-offset", null);
      }
    }
    function renderDisclosureContent(selection2) {
      var container = selection2.selectAll(".nudge-container").data([0]);
      var containerEnter = container.enter().append("div").attr("class", "nudge-container");
      containerEnter.append("div").attr("class", "nudge-instructions").call(_t.append("background.offset"));
      var nudgeWrapEnter = containerEnter.append("div").attr("class", "nudge-controls-wrap");
      var nudgeEnter = nudgeWrapEnter.append("div").attr("class", "nudge-outer-rect").on(_pointerPrefix + "down", dragOffset);
      nudgeEnter.append("div").attr("class", "nudge-inner-rect").append("input").attr("type", "text").attr("aria-label", _t("background.offset_label")).on("change", inputOffset);
      nudgeWrapEnter.append("div").selectAll("button").data(_directions).enter().append("button").attr("title", function(d2) {
        return _t("background.nudge.".concat(d2[0]));
      }).attr("class", function(d2) {
        return d2[0] + " nudge";
      }).on("click", function(d3_event, d2) {
        nudge(d2[1]);
      });
      nudgeWrapEnter.append("button").attr("title", _t("background.reset")).attr("class", "nudge-reset disabled").on("click", function(d3_event) {
        d3_event.preventDefault();
        resetOffset();
      }).call(svgIcon("#iD-icon-" + (_mainLocalizer.textDirection() === "rtl" ? "redo" : "undo")));
      updateValue();
    }
    context.background().on("change.backgroundOffset-update", updateValue);
    return section;
  }

  // modules/ui/sections/overlay_list.js
  function uiSectionOverlayList(context) {
    var section = uiSection("overlay-list", context).label(() => _t.append("background.overlays")).disclosureContent(renderDisclosureContent);
    var _overlayList = select_default2(null);
    function setTooltips(selection2) {
      selection2.each(function(d2, i3, nodes) {
        var item = select_default2(this).select("label");
        var span = item.select("span");
        var placement = i3 < nodes.length / 2 ? "bottom" : "top";
        var description = d2.description();
        var isOverflowing = span.property("clientWidth") !== span.property("scrollWidth");
        item.call(uiTooltip().destroyAny);
        if (description || isOverflowing) {
          item.call(
            uiTooltip().placement(placement).title(() => description || d2.name())
          );
        }
      });
    }
    function updateLayerSelections(selection2) {
      function active(d2) {
        return context.background().showsLayer(d2);
      }
      selection2.selectAll("li").classed("active", active).call(setTooltips).selectAll("input").property("checked", active);
    }
    function chooseOverlay(d3_event, d2) {
      d3_event.preventDefault();
      context.background().toggleOverlayLayer(d2);
      _overlayList.call(updateLayerSelections);
      document.activeElement.blur();
    }
    function drawListItems(layerList, type2, change, filter2) {
      var sources = context.background().sources(context.map().extent(), context.map().zoom(), true).filter(filter2);
      var layerLinks = layerList.selectAll("li").data(sources, function(d2) {
        return d2.name();
      });
      layerLinks.exit().remove();
      var enter = layerLinks.enter().append("li");
      var label = enter.append("label");
      label.append("input").attr("type", type2).attr("name", "layers").on("change", change);
      label.append("span").each(function(d2) {
        d2.label()(select_default2(this));
      });
      layerList.selectAll("li").sort(sortSources);
      layerList.call(updateLayerSelections);
      function sortSources(a2, b2) {
        return a2.best() && !b2.best() ? -1 : b2.best() && !a2.best() ? 1 : descending(a2.area(), b2.area()) || ascending(a2.name(), b2.name()) || 0;
      }
    }
    function renderDisclosureContent(selection2) {
      var container = selection2.selectAll(".layer-overlay-list").data([0]);
      _overlayList = container.enter().append("ul").attr("class", "layer-list layer-overlay-list").attr("dir", "auto").merge(container);
      _overlayList.call(drawListItems, "checkbox", chooseOverlay, function(d2) {
        return !d2.isHidden() && d2.overlay;
      });
    }
    context.map().on(
      "move.overlay_list",
      debounce_default(function() {
        window.requestIdleCallback(section.reRender);
      }, 1e3)
    );
    return section;
  }

  // modules/ui/panes/background.js
  function uiPaneBackground(context) {
    var backgroundPane = uiPane("background", context).key(_t("background.key")).label(_t.append("background.title")).description(_t.append("background.description")).iconName("iD-icon-layers").sections([
      uiSectionBackgroundList(context),
      uiSectionOverlayList(context),
      uiSectionBackgroundDisplayOptions(context),
      uiSectionBackgroundOffset(context)
    ]);
    return backgroundPane;
  }

  // modules/ui/panes/help.js
  function uiPaneHelp(context) {
    var docKeys = [
      ["help", [
        "welcome",
        "open_data_h",
        "open_data",
        "before_start_h",
        "before_start",
        "open_source_h",
        "open_source",
        "open_source_attribution",
        "open_source_help"
      ]],
      ["overview", [
        "navigation_h",
        "navigation_drag",
        "navigation_zoom",
        "features_h",
        "features",
        "nodes_ways"
      ]],
      ["editing", [
        "select_h",
        "select_left_click",
        "select_right_click",
        "select_space",
        "multiselect_h",
        "multiselect",
        "multiselect_shift_click",
        "multiselect_lasso",
        "undo_redo_h",
        "undo_redo",
        "save_h",
        "save",
        "save_validation",
        "upload_h",
        "upload",
        "backups_h",
        "backups",
        "keyboard_h",
        "keyboard"
      ]],
      ["feature_editor", [
        "intro",
        "definitions",
        "type_h",
        "type",
        "type_picker",
        "fields_h",
        "fields_all_fields",
        "fields_example",
        "fields_add_field",
        "tags_h",
        "tags_all_tags",
        "tags_resources"
      ]],
      ["points", [
        "intro",
        "add_point_h",
        "add_point",
        "add_point_finish",
        "move_point_h",
        "move_point",
        "delete_point_h",
        "delete_point",
        "delete_point_command"
      ]],
      ["lines", [
        "intro",
        "add_line_h",
        "add_line",
        "add_line_draw",
        "add_line_continue",
        "add_line_finish",
        "modify_line_h",
        "modify_line_dragnode",
        "modify_line_addnode",
        "connect_line_h",
        "connect_line",
        "connect_line_display",
        "connect_line_drag",
        "connect_line_tag",
        "disconnect_line_h",
        "disconnect_line_command",
        "move_line_h",
        "move_line_command",
        "move_line_connected",
        "delete_line_h",
        "delete_line",
        "delete_line_command"
      ]],
      ["areas", [
        "intro",
        "point_or_area_h",
        "point_or_area",
        "add_area_h",
        "add_area_command",
        "add_area_draw",
        "add_area_continue",
        "add_area_finish",
        "square_area_h",
        "square_area_command",
        "modify_area_h",
        "modify_area_dragnode",
        "modify_area_addnode",
        "delete_area_h",
        "delete_area",
        "delete_area_command"
      ]],
      ["relations", [
        "intro",
        "edit_relation_h",
        "edit_relation",
        "edit_relation_add",
        "edit_relation_delete",
        "maintain_relation_h",
        "maintain_relation",
        "relation_types_h",
        "multipolygon_h",
        "multipolygon",
        "multipolygon_create",
        "multipolygon_merge",
        "turn_restriction_h",
        "turn_restriction",
        "turn_restriction_field",
        "turn_restriction_editing",
        "route_h",
        "route",
        "route_add",
        "boundary_h",
        "boundary",
        "boundary_add"
      ]],
      ["operations", [
        "intro",
        "intro_2",
        "straighten",
        "orthogonalize",
        "circularize",
        "move",
        "rotate",
        "reflect",
        "continue",
        "reverse",
        "disconnect",
        "split",
        "extract",
        "merge",
        "delete",
        "downgrade",
        "copy_paste"
      ]],
      ["notes", [
        "intro",
        "add_note_h",
        "add_note",
        "place_note",
        "move_note",
        "update_note_h",
        "update_note",
        "save_note_h",
        "save_note"
      ]],
      ["imagery", [
        "intro",
        "sources_h",
        "choosing",
        "sources",
        "offsets_h",
        "offset",
        "offset_change"
      ]],
      ["streetlevel", [
        "intro",
        "using_h",
        "using",
        "photos",
        "viewer"
      ]],
      ["gps", [
        "intro",
        "survey",
        "using_h",
        "using",
        "tracing",
        "upload"
      ]],
      ["qa", [
        "intro",
        "tools_h",
        "tools",
        "issues_h",
        "issues"
      ]]
    ];
    var headings = {
      "help.help.open_data_h": 3,
      "help.help.before_start_h": 3,
      "help.help.open_source_h": 3,
      "help.overview.navigation_h": 3,
      "help.overview.features_h": 3,
      "help.editing.select_h": 3,
      "help.editing.multiselect_h": 3,
      "help.editing.undo_redo_h": 3,
      "help.editing.save_h": 3,
      "help.editing.upload_h": 3,
      "help.editing.backups_h": 3,
      "help.editing.keyboard_h": 3,
      "help.feature_editor.type_h": 3,
      "help.feature_editor.fields_h": 3,
      "help.feature_editor.tags_h": 3,
      "help.points.add_point_h": 3,
      "help.points.move_point_h": 3,
      "help.points.delete_point_h": 3,
      "help.lines.add_line_h": 3,
      "help.lines.modify_line_h": 3,
      "help.lines.connect_line_h": 3,
      "help.lines.disconnect_line_h": 3,
      "help.lines.move_line_h": 3,
      "help.lines.delete_line_h": 3,
      "help.areas.point_or_area_h": 3,
      "help.areas.add_area_h": 3,
      "help.areas.square_area_h": 3,
      "help.areas.modify_area_h": 3,
      "help.areas.delete_area_h": 3,
      "help.relations.edit_relation_h": 3,
      "help.relations.maintain_relation_h": 3,
      "help.relations.relation_types_h": 2,
      "help.relations.multipolygon_h": 3,
      "help.relations.turn_restriction_h": 3,
      "help.relations.route_h": 3,
      "help.relations.boundary_h": 3,
      "help.notes.add_note_h": 3,
      "help.notes.update_note_h": 3,
      "help.notes.save_note_h": 3,
      "help.imagery.sources_h": 3,
      "help.imagery.offsets_h": 3,
      "help.streetlevel.using_h": 3,
      "help.gps.using_h": 3,
      "help.qa.tools_h": 3,
      "help.qa.issues_h": 3
    };
    var docs = docKeys.map(function(key) {
      var helpkey = "help." + key[0];
      var helpPaneReplacements = { version: context.version };
      var text = key[1].reduce(function(all, part) {
        var subkey = helpkey + "." + part;
        var depth = headings[subkey];
        var hhh = depth ? Array(depth + 1).join("#") + " " : "";
        return all + hhh + helpHtml(subkey, helpPaneReplacements) + "\n\n";
      }, "");
      return {
        title: _t.html(helpkey + ".title"),
        content: marked(text.trim()).replace(/<code>/g, "<kbd>").replace(/<\/code>/g, "</kbd>")
      };
    });
    var helpPane = uiPane("help", context).key(_t("help.key")).label(_t.append("help.title")).description(_t.append("help.title")).iconName("iD-icon-help");
    helpPane.renderContent = function(content) {
      function clickHelp(d2, i3) {
        var rtl = _mainLocalizer.textDirection() === "rtl";
        content.property("scrollTop", 0);
        helpPane.selection().select(".pane-heading h2").html(d2.title);
        body.html(d2.content);
        body.selectAll("a").attr("target", "_blank");
        menuItems.classed("selected", function(m2) {
          return m2.title === d2.title;
        });
        nav.html("");
        if (rtl) {
          nav.call(drawNext).call(drawPrevious);
        } else {
          nav.call(drawPrevious).call(drawNext);
        }
        function drawNext(selection2) {
          if (i3 < docs.length - 1) {
            var nextLink = selection2.append("a").attr("href", "#").attr("class", "next").on("click", function(d3_event) {
              d3_event.preventDefault();
              clickHelp(docs[i3 + 1], i3 + 1);
            });
            nextLink.append("span").html(docs[i3 + 1].title).call(svgIcon(rtl ? "#iD-icon-backward" : "#iD-icon-forward", "inline"));
          }
        }
        function drawPrevious(selection2) {
          if (i3 > 0) {
            var prevLink = selection2.append("a").attr("href", "#").attr("class", "previous").on("click", function(d3_event) {
              d3_event.preventDefault();
              clickHelp(docs[i3 - 1], i3 - 1);
            });
            prevLink.call(svgIcon(rtl ? "#iD-icon-forward" : "#iD-icon-backward", "inline")).append("span").html(docs[i3 - 1].title);
          }
        }
      }
      function clickWalkthrough(d3_event) {
        d3_event.preventDefault();
        if (context.inIntro())
          return;
        context.container().call(uiIntro(context));
        context.ui().togglePanes();
      }
      function clickShortcuts(d3_event) {
        d3_event.preventDefault();
        context.container().call(context.ui().shortcuts, true);
      }
      var toc = content.append("ul").attr("class", "toc");
      var menuItems = toc.selectAll("li").data(docs).enter().append("li").append("a").attr("role", "button").attr("href", "#").html(function(d2) {
        return d2.title;
      }).on("click", function(d3_event, d2) {
        d3_event.preventDefault();
        clickHelp(d2, docs.indexOf(d2));
      });
      var shortcuts = toc.append("li").attr("class", "shortcuts").call(
        uiTooltip().title(() => _t.append("shortcuts.tooltip")).keys(["?"]).placement("top")
      ).append("a").attr("href", "#").on("click", clickShortcuts);
      shortcuts.append("div").call(_t.append("shortcuts.title"));
      var walkthrough = toc.append("li").attr("class", "walkthrough").append("a").attr("href", "#").on("click", clickWalkthrough);
      walkthrough.append("svg").attr("class", "logo logo-walkthrough").append("use").attr("xlink:href", "#iD-logo-walkthrough");
      walkthrough.append("div").call(_t.append("splash.walkthrough"));
      var helpContent = content.append("div").attr("class", "left-content");
      var body = helpContent.append("div").attr("class", "body");
      var nav = helpContent.append("div").attr("class", "nav");
      clickHelp(docs[0], 0);
    };
    return helpPane;
  }

  // modules/ui/sections/validation_issues.js
  function uiSectionValidationIssues(id2, severity, context) {
    var _issues = [];
    var section = uiSection(id2, context).label(function() {
      if (!_issues)
        return "";
      var issueCountText = _issues.length > 1e3 ? "1000+" : String(_issues.length);
      return _t.append("inspector.title_count", { title: _t("issues." + severity + "s.list_title"), count: issueCountText });
    }).disclosureContent(renderDisclosureContent).shouldDisplay(function() {
      return _issues && _issues.length;
    });
    function getOptions() {
      return {
        what: corePreferences("validate-what") || "edited",
        where: corePreferences("validate-where") || "all"
      };
    }
    function reloadIssues() {
      _issues = context.validator().getIssuesBySeverity(getOptions())[severity];
    }
    function renderDisclosureContent(selection2) {
      var center = context.map().center();
      var graph = context.graph();
      var issues = _issues.map(function withDistance(issue) {
        var extent = issue.extent(graph);
        var dist = extent ? geoSphericalDistance(center, extent.center()) : 0;
        return Object.assign(issue, { dist });
      }).sort(function byDistance(a2, b2) {
        return a2.dist - b2.dist;
      });
      issues = issues.slice(0, 1e3);
      selection2.call(drawIssuesList, issues);
    }
    function drawIssuesList(selection2, issues) {
      var list2 = selection2.selectAll(".issues-list").data([0]);
      list2 = list2.enter().append("ul").attr("class", "layer-list issues-list " + severity + "s-list").merge(list2);
      var items = list2.selectAll("li").data(issues, function(d2) {
        return d2.key;
      });
      items.exit().remove();
      var itemsEnter = items.enter().append("li").attr("class", function(d2) {
        return "issue severity-" + d2.severity;
      });
      var labelsEnter = itemsEnter.append("button").attr("class", "issue-label").on("click", function(d3_event, d2) {
        context.validator().focusIssue(d2);
      }).on("mouseover", function(d3_event, d2) {
        utilHighlightEntities(d2.entityIds, true, context);
      }).on("mouseout", function(d3_event, d2) {
        utilHighlightEntities(d2.entityIds, false, context);
      });
      var textEnter = labelsEnter.append("span").attr("class", "issue-text");
      textEnter.append("span").attr("class", "issue-icon").each(function(d2) {
        var iconName = "#iD-icon-" + (d2.severity === "warning" ? "alert" : "error");
        select_default2(this).call(svgIcon(iconName));
      });
      textEnter.append("span").attr("class", "issue-message");
      items = items.merge(itemsEnter).order();
      items.selectAll(".issue-message").text("").each(function(d2) {
        return d2.message(context)(select_default2(this));
      });
    }
    context.validator().on("validated.uiSectionValidationIssues" + id2, function() {
      window.requestIdleCallback(function() {
        reloadIssues();
        section.reRender();
      });
    });
    context.map().on(
      "move.uiSectionValidationIssues" + id2,
      debounce_default(function() {
        window.requestIdleCallback(function() {
          if (getOptions().where === "visible") {
            reloadIssues();
          }
          section.reRender();
        });
      }, 1e3)
    );
    return section;
  }

  // modules/ui/sections/validation_options.js
  function uiSectionValidationOptions(context) {
    var section = uiSection("issues-options", context).content(renderContent);
    function renderContent(selection2) {
      var container = selection2.selectAll(".issues-options-container").data([0]);
      container = container.enter().append("div").attr("class", "issues-options-container").merge(container);
      var data = [
        { key: "what", values: ["edited", "all"] },
        { key: "where", values: ["visible", "all"] }
      ];
      var options2 = container.selectAll(".issues-option").data(data, function(d2) {
        return d2.key;
      });
      var optionsEnter = options2.enter().append("div").attr("class", function(d2) {
        return "issues-option issues-option-" + d2.key;
      });
      optionsEnter.append("div").attr("class", "issues-option-title").html(function(d2) {
        return _t.html("issues.options." + d2.key + ".title");
      });
      var valuesEnter = optionsEnter.selectAll("label").data(function(d2) {
        return d2.values.map(function(val) {
          return { value: val, key: d2.key };
        });
      }).enter().append("label");
      valuesEnter.append("input").attr("type", "radio").attr("name", function(d2) {
        return "issues-option-" + d2.key;
      }).attr("value", function(d2) {
        return d2.value;
      }).property("checked", function(d2) {
        return getOptions()[d2.key] === d2.value;
      }).on("change", function(d3_event, d2) {
        updateOptionValue(d3_event, d2.key, d2.value);
      });
      valuesEnter.append("span").html(function(d2) {
        return _t.html("issues.options." + d2.key + "." + d2.value);
      });
    }
    function getOptions() {
      return {
        what: corePreferences("validate-what") || "edited",
        // 'all', 'edited'
        where: corePreferences("validate-where") || "all"
        // 'all', 'visible'
      };
    }
    function updateOptionValue(d3_event, d2, val) {
      if (!val && d3_event && d3_event.target) {
        val = d3_event.target.value;
      }
      corePreferences("validate-" + d2, val);
      context.validator().validate();
    }
    return section;
  }

  // modules/ui/sections/validation_rules.js
  function uiSectionValidationRules(context) {
    var MINSQUARE = 0;
    var MAXSQUARE = 20;
    var DEFAULTSQUARE = 5;
    var section = uiSection("issues-rules", context).disclosureContent(renderDisclosureContent).label(() => _t.append("issues.rules.title"));
    var _ruleKeys = context.validator().getRuleKeys().filter(function(key) {
      return key !== "maprules";
    }).sort(function(key1, key2) {
      return _t("issues." + key1 + ".title") < _t("issues." + key2 + ".title") ? -1 : 1;
    });
    function renderDisclosureContent(selection2) {
      var container = selection2.selectAll(".issues-rulelist-container").data([0]);
      var containerEnter = container.enter().append("div").attr("class", "issues-rulelist-container");
      containerEnter.append("ul").attr("class", "layer-list issue-rules-list");
      var ruleLinks = containerEnter.append("div").attr("class", "issue-rules-links section-footer");
      ruleLinks.append("a").attr("class", "issue-rules-link").attr("role", "button").attr("href", "#").call(_t.append("issues.disable_all")).on("click", function(d3_event) {
        d3_event.preventDefault();
        context.validator().disableRules(_ruleKeys);
      });
      ruleLinks.append("a").attr("class", "issue-rules-link").attr("role", "button").attr("href", "#").call(_t.append("issues.enable_all")).on("click", function(d3_event) {
        d3_event.preventDefault();
        context.validator().disableRules([]);
      });
      container = container.merge(containerEnter);
      container.selectAll(".issue-rules-list").call(drawListItems, _ruleKeys, "checkbox", "rule", toggleRule, isRuleEnabled);
    }
    function drawListItems(selection2, data, type2, name, change, active) {
      var items = selection2.selectAll("li").data(data);
      items.exit().remove();
      var enter = items.enter().append("li");
      if (name === "rule") {
        enter.call(
          uiTooltip().title(function(d2) {
            return _t.append("issues." + d2 + ".tip");
          }).placement("top")
        );
      }
      var label = enter.append("label");
      label.append("input").attr("type", type2).attr("name", name).on("change", change);
      label.append("span").html(function(d2) {
        var params = {};
        if (d2 === "unsquare_way") {
          params.val = { html: '<span class="square-degrees"></span>' };
        }
        return _t.html("issues." + d2 + ".title", params);
      });
      items = items.merge(enter);
      items.classed("active", active).selectAll("input").property("checked", active).property("indeterminate", false);
      var degStr = corePreferences("validate-square-degrees");
      if (degStr === null) {
        degStr = DEFAULTSQUARE.toString();
      }
      var span = items.selectAll(".square-degrees");
      var input = span.selectAll(".square-degrees-input").data([0]);
      input.enter().append("input").attr("type", "number").attr("min", MINSQUARE.toString()).attr("max", MAXSQUARE.toString()).attr("step", "0.5").attr("class", "square-degrees-input").call(utilNoAuto).on("click", function(d3_event) {
        d3_event.preventDefault();
        d3_event.stopPropagation();
        this.select();
      }).on("keyup", function(d3_event) {
        if (d3_event.keyCode === 13) {
          this.blur();
          this.select();
        }
      }).on("blur", changeSquare).merge(input).property("value", degStr);
    }
    function changeSquare() {
      var input = select_default2(this);
      var degStr = utilGetSetValue(input).trim();
      var degNum = Number(degStr);
      if (!isFinite(degNum)) {
        degNum = DEFAULTSQUARE;
      } else if (degNum > MAXSQUARE) {
        degNum = MAXSQUARE;
      } else if (degNum < MINSQUARE) {
        degNum = MINSQUARE;
      }
      degNum = Math.round(degNum * 10) / 10;
      degStr = degNum.toString();
      input.property("value", degStr);
      corePreferences("validate-square-degrees", degStr);
      context.validator().revalidateUnsquare();
    }
    function isRuleEnabled(d2) {
      return context.validator().isRuleEnabled(d2);
    }
    function toggleRule(d3_event, d2) {
      context.validator().toggleRule(d2);
    }
    context.validator().on("validated.uiSectionValidationRules", function() {
      window.requestIdleCallback(section.reRender);
    });
    return section;
  }

  // modules/ui/sections/validation_status.js
  function uiSectionValidationStatus(context) {
    var section = uiSection("issues-status", context).content(renderContent).shouldDisplay(function() {
      var issues = context.validator().getIssues(getOptions());
      return issues.length === 0;
    });
    function getOptions() {
      return {
        what: corePreferences("validate-what") || "edited",
        where: corePreferences("validate-where") || "all"
      };
    }
    function renderContent(selection2) {
      var box = selection2.selectAll(".box").data([0]);
      var boxEnter = box.enter().append("div").attr("class", "box");
      boxEnter.append("div").call(svgIcon("#iD-icon-apply", "pre-text"));
      var noIssuesMessage = boxEnter.append("span");
      noIssuesMessage.append("strong").attr("class", "message");
      noIssuesMessage.append("br");
      noIssuesMessage.append("span").attr("class", "details");
      renderIgnoredIssuesReset(selection2);
      setNoIssuesText(selection2);
    }
    function renderIgnoredIssuesReset(selection2) {
      var ignoredIssues = context.validator().getIssues({ what: "all", where: "all", includeDisabledRules: true, includeIgnored: "only" });
      var resetIgnored = selection2.selectAll(".reset-ignored").data(ignoredIssues.length ? [0] : []);
      resetIgnored.exit().remove();
      var resetIgnoredEnter = resetIgnored.enter().append("div").attr("class", "reset-ignored section-footer");
      resetIgnoredEnter.append("a").attr("href", "#");
      resetIgnored = resetIgnored.merge(resetIgnoredEnter);
      resetIgnored.select("a").html(_t.html("inspector.title_count", { title: { html: _t.html("issues.reset_ignored") }, count: ignoredIssues.length }));
      resetIgnored.on("click", function(d3_event) {
        d3_event.preventDefault();
        context.validator().resetIgnoredIssues();
      });
    }
    function setNoIssuesText(selection2) {
      var opts = getOptions();
      function checkForHiddenIssues(cases) {
        for (var type2 in cases) {
          var hiddenOpts = cases[type2];
          var hiddenIssues = context.validator().getIssues(hiddenOpts);
          if (hiddenIssues.length) {
            selection2.select(".box .details").html("").call(_t.append(
              "issues.no_issues.hidden_issues." + type2,
              { count: hiddenIssues.length.toString() }
            ));
            return;
          }
        }
        selection2.select(".box .details").html("").call(_t.append("issues.no_issues.hidden_issues.none"));
      }
      var messageType;
      if (opts.what === "edited" && opts.where === "visible") {
        messageType = "edits_in_view";
        checkForHiddenIssues({
          elsewhere: { what: "edited", where: "all" },
          everything_else: { what: "all", where: "visible" },
          disabled_rules: { what: "edited", where: "visible", includeDisabledRules: "only" },
          everything_else_elsewhere: { what: "all", where: "all" },
          disabled_rules_elsewhere: { what: "edited", where: "all", includeDisabledRules: "only" },
          ignored_issues: { what: "edited", where: "visible", includeIgnored: "only" },
          ignored_issues_elsewhere: { what: "edited", where: "all", includeIgnored: "only" }
        });
      } else if (opts.what === "edited" && opts.where === "all") {
        messageType = "edits";
        checkForHiddenIssues({
          everything_else: { what: "all", where: "all" },
          disabled_rules: { what: "edited", where: "all", includeDisabledRules: "only" },
          ignored_issues: { what: "edited", where: "all", includeIgnored: "only" }
        });
      } else if (opts.what === "all" && opts.where === "visible") {
        messageType = "everything_in_view";
        checkForHiddenIssues({
          elsewhere: { what: "all", where: "all" },
          disabled_rules: { what: "all", where: "visible", includeDisabledRules: "only" },
          disabled_rules_elsewhere: { what: "all", where: "all", includeDisabledRules: "only" },
          ignored_issues: { what: "all", where: "visible", includeIgnored: "only" },
          ignored_issues_elsewhere: { what: "all", where: "all", includeIgnored: "only" }
        });
      } else if (opts.what === "all" && opts.where === "all") {
        messageType = "everything";
        checkForHiddenIssues({
          disabled_rules: { what: "all", where: "all", includeDisabledRules: "only" },
          ignored_issues: { what: "all", where: "all", includeIgnored: "only" }
        });
      }
      if (opts.what === "edited" && context.history().difference().summary().length === 0) {
        messageType = "no_edits";
      }
      selection2.select(".box .message").html("").call(_t.append("issues.no_issues.message." + messageType));
    }
    context.validator().on("validated.uiSectionValidationStatus", function() {
      window.requestIdleCallback(section.reRender);
    });
    context.map().on(
      "move.uiSectionValidationStatus",
      debounce_default(function() {
        window.requestIdleCallback(section.reRender);
      }, 1e3)
    );
    return section;
  }

  // modules/ui/panes/issues.js
  function uiPaneIssues(context) {
    var issuesPane = uiPane("issues", context).key(_t("issues.key")).label(_t.append("issues.title")).description(_t.append("issues.title")).iconName("iD-icon-alert").sections([
      uiSectionValidationOptions(context),
      uiSectionValidationStatus(context),
      uiSectionValidationIssues("issues-errors", "error", context),
      uiSectionValidationIssues("issues-warnings", "warning", context),
      uiSectionValidationRules(context)
    ]);
    return issuesPane;
  }

  // modules/ui/settings/custom_data.js
  function uiSettingsCustomData(context) {
    var dispatch14 = dispatch_default("change");
    function render(selection2) {
      var dataLayer = context.layers().layer("data");
      var _origSettings = {
        fileList: dataLayer && dataLayer.fileList() || null,
        url: corePreferences("settings-custom-data-url")
      };
      var _currSettings = {
        fileList: dataLayer && dataLayer.fileList() || null
        // url: prefs('settings-custom-data-url')
      };
      var modal = uiConfirm(selection2).okButton();
      modal.classed("settings-modal settings-custom-data", true);
      modal.select(".modal-section.header").append("h3").call(_t.append("settings.custom_data.header"));
      var textSection = modal.select(".modal-section.message-text");
      textSection.append("pre").attr("class", "instructions-file").call(_t.append("settings.custom_data.file.instructions"));
      textSection.append("input").attr("class", "field-file").attr("type", "file").attr("accept", ".gpx,.kml,.geojson,.json,application/gpx+xml,application/vnd.google-earth.kml+xml,application/geo+json,application/json").property("files", _currSettings.fileList).on("change", function(d3_event) {
        var files = d3_event.target.files;
        if (files && files.length) {
          _currSettings.url = "";
          textSection.select(".field-url").property("value", "");
          _currSettings.fileList = files;
        } else {
          _currSettings.fileList = null;
        }
      });
      textSection.append("h4").call(_t.append("settings.custom_data.or"));
      textSection.append("pre").attr("class", "instructions-url").call(_t.append("settings.custom_data.url.instructions"));
      textSection.append("textarea").attr("class", "field-url").attr("placeholder", _t("settings.custom_data.url.placeholder")).call(utilNoAuto).property("value", _currSettings.url);
      var buttonSection = modal.select(".modal-section.buttons");
      buttonSection.insert("button", ".ok-button").attr("class", "button cancel-button secondary-action").call(_t.append("confirm.cancel"));
      buttonSection.select(".cancel-button").on("click.cancel", clickCancel);
      buttonSection.select(".ok-button").attr("disabled", isSaveDisabled).on("click.save", clickSave);
      function isSaveDisabled() {
        return null;
      }
      function clickCancel() {
        textSection.select(".field-url").property("value", _origSettings.url);
        corePreferences("settings-custom-data-url", _origSettings.url);
        this.blur();
        modal.close();
      }
      function clickSave() {
        _currSettings.url = textSection.select(".field-url").property("value").trim();
        if (_currSettings.url) {
          _currSettings.fileList = null;
        }
        if (_currSettings.fileList) {
          _currSettings.url = "";
        }
        corePreferences("settings-custom-data-url", _currSettings.url);
        this.blur();
        modal.close();
        dispatch14.call("change", this, _currSettings);
      }
    }
    return utilRebind(render, dispatch14, "on");
  }

  // modules/ui/sections/data_layers.js
  function uiSectionDataLayers(context) {
    var settingsCustomData = uiSettingsCustomData(context).on("change", customChanged);
    var layers = context.layers();
    var section = uiSection("data-layers", context).label(() => _t.append("map_data.data_layers")).disclosureContent(renderDisclosureContent);
    function renderDisclosureContent(selection2) {
      var container = selection2.selectAll(".data-layer-container").data([0]);
      container.enter().append("div").attr("class", "data-layer-container").merge(container).call(drawOsmItems).call(drawQAItems).call(drawCustomDataItems).call(drawVectorItems).call(drawPanelItems);
    }
    function showsLayer(which) {
      var layer = layers.layer(which);
      if (layer) {
        return layer.enabled();
      }
      return false;
    }
    function setLayer(which, enabled) {
      var mode = context.mode();
      if (mode && /^draw/.test(mode.id))
        return;
      var layer = layers.layer(which);
      if (layer) {
        layer.enabled(enabled);
        if (!enabled && (which === "osm" || which === "notes")) {
          context.enter(modeBrowse(context));
        }
      }
    }
    function toggleLayer(which) {
      setLayer(which, !showsLayer(which));
    }
    function drawOsmItems(selection2) {
      var osmKeys = ["osm", "notes"];
      var osmLayers = layers.all().filter(function(obj) {
        return osmKeys.indexOf(obj.id) !== -1;
      });
      var ul = selection2.selectAll(".layer-list-osm").data([0]);
      ul = ul.enter().append("ul").attr("class", "layer-list layer-list-osm").merge(ul);
      var li = ul.selectAll(".list-item").data(osmLayers);
      li.exit().remove();
      var liEnter = li.enter().append("li").attr("class", function(d2) {
        return "list-item list-item-" + d2.id;
      });
      var labelEnter = liEnter.append("label").each(function(d2) {
        if (d2.id === "osm") {
          select_default2(this).call(
            uiTooltip().title(() => _t.append("map_data.layers." + d2.id + ".tooltip")).keys([uiCmd("\u2325" + _t("area_fill.wireframe.key"))]).placement("bottom")
          );
        } else {
          select_default2(this).call(
            uiTooltip().title(() => _t.append("map_data.layers." + d2.id + ".tooltip")).placement("bottom")
          );
        }
      });
      labelEnter.append("input").attr("type", "checkbox").on("change", function(d3_event, d2) {
        toggleLayer(d2.id);
      });
      labelEnter.append("span").html(function(d2) {
        return _t.html("map_data.layers." + d2.id + ".title");
      });
      li.merge(liEnter).classed("active", function(d2) {
        return d2.layer.enabled();
      }).selectAll("input").property("checked", function(d2) {
        return d2.layer.enabled();
      });
    }
    function drawQAItems(selection2) {
      var qaKeys = ["keepRight", "improveOSM", "osmose"];
      var qaLayers = layers.all().filter(function(obj) {
        return qaKeys.indexOf(obj.id) !== -1;
      });
      var ul = selection2.selectAll(".layer-list-qa").data([0]);
      ul = ul.enter().append("ul").attr("class", "layer-list layer-list-qa").merge(ul);
      var li = ul.selectAll(".list-item").data(qaLayers);
      li.exit().remove();
      var liEnter = li.enter().append("li").attr("class", function(d2) {
        return "list-item list-item-" + d2.id;
      });
      var labelEnter = liEnter.append("label").each(function(d2) {
        select_default2(this).call(
          uiTooltip().title(() => _t.append("map_data.layers." + d2.id + ".tooltip")).placement("bottom")
        );
      });
      labelEnter.append("input").attr("type", "checkbox").on("change", function(d3_event, d2) {
        toggleLayer(d2.id);
      });
      labelEnter.append("span").each(function(d2) {
        _t.append("map_data.layers." + d2.id + ".title")(select_default2(this));
      });
      li.merge(liEnter).classed("active", function(d2) {
        return d2.layer.enabled();
      }).selectAll("input").property("checked", function(d2) {
        return d2.layer.enabled();
      });
    }
    function drawVectorItems(selection2) {
      var dataLayer = layers.layer("data");
      var vtData = [
        {
          name: "Detroit Neighborhoods/Parks",
          src: "neighborhoods-parks",
          tooltip: "Neighborhood boundaries and parks as compiled by City of Detroit in concert with community groups.",
          template: "https://{switch:a,b,c,d}.tiles.mapbox.com/v4/jonahadkins.cjksmur6x34562qp9iv1u3ksf-54hev,jonahadkins.cjksmqxdx33jj2wp90xd9x2md-4e5y2/{z}/{x}/{y}.vector.pbf?access_token=pk.eyJ1Ijoiam9uYWhhZGtpbnMiLCJhIjoiRlVVVkx3VSJ9.9sdVEK_B_VkEXPjssU5MqA"
        },
        {
          name: "Detroit Composite POIs",
          src: "composite-poi",
          tooltip: "Fire Inspections, Business Licenses, and other public location data collated from the City of Detroit.",
          template: "https://{switch:a,b,c,d}.tiles.mapbox.com/v4/jonahadkins.cjksmm6a02sli31myxhsr7zf3-2sw8h/{z}/{x}/{y}.vector.pbf?access_token=pk.eyJ1Ijoiam9uYWhhZGtpbnMiLCJhIjoiRlVVVkx3VSJ9.9sdVEK_B_VkEXPjssU5MqA"
        },
        {
          name: "Detroit All-The-Places POIs",
          src: "alltheplaces-poi",
          tooltip: "Public domain business location data created by web scrapers.",
          template: "https://{switch:a,b,c,d}.tiles.mapbox.com/v4/jonahadkins.cjksmswgk340g2vo06p1w9w0j-8fjjc/{z}/{x}/{y}.vector.pbf?access_token=pk.eyJ1Ijoiam9uYWhhZGtpbnMiLCJhIjoiRlVVVkx3VSJ9.9sdVEK_B_VkEXPjssU5MqA"
        }
      ];
      var detroit = geoExtent([-83.5, 42.1], [-82.8, 42.5]);
      var showVectorItems = context.map().zoom() > 9 && detroit.contains(context.map().center());
      var container = selection2.selectAll(".vectortile-container").data(showVectorItems ? [0] : []);
      container.exit().remove();
      var containerEnter = container.enter().append("div").attr("class", "vectortile-container");
      containerEnter.append("h4").attr("class", "vectortile-header").text("Detroit Vector Tiles (Beta)");
      containerEnter.append("ul").attr("class", "layer-list layer-list-vectortile");
      containerEnter.append("div").attr("class", "vectortile-footer").append("a").attr("target", "_blank").call(svgIcon("#iD-icon-out-link", "inline")).attr("href", "https://github.com/osmus/detroit-mapping-challenge").append("span").text("About these layers");
      container = container.merge(containerEnter);
      var ul = container.selectAll(".layer-list-vectortile");
      var li = ul.selectAll(".list-item").data(vtData);
      li.exit().remove();
      var liEnter = li.enter().append("li").attr("class", function(d2) {
        return "list-item list-item-" + d2.src;
      });
      var labelEnter = liEnter.append("label").each(function(d2) {
        select_default2(this).call(
          uiTooltip().title(d2.tooltip).placement("top")
        );
      });
      labelEnter.append("input").attr("type", "radio").attr("name", "vectortile").on("change", selectVTLayer);
      labelEnter.append("span").text(function(d2) {
        return d2.name;
      });
      li.merge(liEnter).classed("active", isVTLayerSelected).selectAll("input").property("checked", isVTLayerSelected);
      function isVTLayerSelected(d2) {
        return dataLayer && dataLayer.template() === d2.template;
      }
      function selectVTLayer(d3_event, d2) {
        corePreferences("settings-custom-data-url", d2.template);
        if (dataLayer) {
          dataLayer.template(d2.template, d2.src);
          dataLayer.enabled(true);
        }
      }
    }
    function drawCustomDataItems(selection2) {
      var dataLayer = layers.layer("data");
      var hasData = dataLayer && dataLayer.hasData();
      var showsData = hasData && dataLayer.enabled();
      var ul = selection2.selectAll(".layer-list-data").data(dataLayer ? [0] : []);
      ul.exit().remove();
      var ulEnter = ul.enter().append("ul").attr("class", "layer-list layer-list-data");
      var liEnter = ulEnter.append("li").attr("class", "list-item-data");
      var labelEnter = liEnter.append("label").call(
        uiTooltip().title(() => _t.append("map_data.layers.custom.tooltip")).placement("top")
      );
      labelEnter.append("input").attr("type", "checkbox").on("change", function() {
        toggleLayer("data");
      });
      labelEnter.append("span").call(_t.append("map_data.layers.custom.title"));
      liEnter.append("button").attr("class", "open-data-options").call(
        uiTooltip().title(() => _t.append("settings.custom_data.tooltip")).placement(_mainLocalizer.textDirection() === "rtl" ? "right" : "left")
      ).on("click", function(d3_event) {
        d3_event.preventDefault();
        editCustom();
      }).call(svgIcon("#iD-icon-more"));
      liEnter.append("button").attr("class", "zoom-to-data").call(
        uiTooltip().title(() => _t.append("map_data.layers.custom.zoom")).placement(_mainLocalizer.textDirection() === "rtl" ? "right" : "left")
      ).on("click", function(d3_event) {
        if (select_default2(this).classed("disabled"))
          return;
        d3_event.preventDefault();
        d3_event.stopPropagation();
        dataLayer.fitZoom();
      }).call(svgIcon("#iD-icon-framed-dot", "monochrome"));
      ul = ul.merge(ulEnter);
      ul.selectAll(".list-item-data").classed("active", showsData).selectAll("label").classed("deemphasize", !hasData).selectAll("input").property("disabled", !hasData).property("checked", showsData);
      ul.selectAll("button.zoom-to-data").classed("disabled", !hasData);
    }
    function editCustom() {
      context.container().call(settingsCustomData);
    }
    function customChanged(d2) {
      var dataLayer = layers.layer("data");
      if (d2 && d2.url) {
        dataLayer.url(d2.url);
      } else if (d2 && d2.fileList) {
        dataLayer.fileList(d2.fileList);
      }
    }
    function drawPanelItems(selection2) {
      var panelsListEnter = selection2.selectAll(".md-extras-list").data([0]).enter().append("ul").attr("class", "layer-list md-extras-list");
      var historyPanelLabelEnter = panelsListEnter.append("li").attr("class", "history-panel-toggle-item").append("label").call(
        uiTooltip().title(() => _t.append("map_data.history_panel.tooltip")).keys([uiCmd("\u2318\u21E7" + _t("info_panels.history.key"))]).placement("top")
      );
      historyPanelLabelEnter.append("input").attr("type", "checkbox").on("change", function(d3_event) {
        d3_event.preventDefault();
        context.ui().info.toggle("history");
      });
      historyPanelLabelEnter.append("span").call(_t.append("map_data.history_panel.title"));
      var measurementPanelLabelEnter = panelsListEnter.append("li").attr("class", "measurement-panel-toggle-item").append("label").call(
        uiTooltip().title(() => _t.append("map_data.measurement_panel.tooltip")).keys([uiCmd("\u2318\u21E7" + _t("info_panels.measurement.key"))]).placement("top")
      );
      measurementPanelLabelEnter.append("input").attr("type", "checkbox").on("change", function(d3_event) {
        d3_event.preventDefault();
        context.ui().info.toggle("measurement");
      });
      measurementPanelLabelEnter.append("span").call(_t.append("map_data.measurement_panel.title"));
    }
    context.layers().on("change.uiSectionDataLayers", section.reRender);
    context.map().on(
      "move.uiSectionDataLayers",
      debounce_default(function() {
        window.requestIdleCallback(section.reRender);
      }, 1e3)
    );
    return section;
  }

  // modules/ui/sections/map_features.js
  function uiSectionMapFeatures(context) {
    var _features = context.features().keys();
    var section = uiSection("map-features", context).label(() => _t.append("map_data.map_features")).disclosureContent(renderDisclosureContent).expandedByDefault(false);
    function renderDisclosureContent(selection2) {
      var container = selection2.selectAll(".layer-feature-list-container").data([0]);
      var containerEnter = container.enter().append("div").attr("class", "layer-feature-list-container");
      containerEnter.append("ul").attr("class", "layer-list layer-feature-list");
      var footer = containerEnter.append("div").attr("class", "feature-list-links section-footer");
      footer.append("a").attr("class", "feature-list-link").attr("role", "button").attr("href", "#").call(_t.append("issues.disable_all")).on("click", function(d3_event) {
        d3_event.preventDefault();
        context.features().disableAll();
      });
      footer.append("a").attr("class", "feature-list-link").attr("role", "button").attr("href", "#").call(_t.append("issues.enable_all")).on("click", function(d3_event) {
        d3_event.preventDefault();
        context.features().enableAll();
      });
      container = container.merge(containerEnter);
      container.selectAll(".layer-feature-list").call(drawListItems, _features, "checkbox", "feature", clickFeature, showsFeature);
    }
    function drawListItems(selection2, data, type2, name, change, active) {
      var items = selection2.selectAll("li").data(data);
      items.exit().remove();
      var enter = items.enter().append("li").call(
        uiTooltip().title(function(d2) {
          var tip = _t.append(name + "." + d2 + ".tooltip");
          if (autoHiddenFeature(d2)) {
            var msg = showsLayer("osm") ? _t.append("map_data.autohidden") : _t.append("map_data.osmhidden");
            return (selection3) => {
              selection3.call(tip);
              selection3.append("div").call(msg);
            };
          }
          return tip;
        }).placement("top")
      );
      var label = enter.append("label");
      label.append("input").attr("type", type2).attr("name", name).on("change", change);
      label.append("span").html(function(d2) {
        return _t.html(name + "." + d2 + ".description");
      });
      items = items.merge(enter);
      items.classed("active", active).selectAll("input").property("checked", active).property("indeterminate", autoHiddenFeature);
    }
    function autoHiddenFeature(d2) {
      return context.features().autoHidden(d2);
    }
    function showsFeature(d2) {
      return context.features().enabled(d2);
    }
    function clickFeature(d3_event, d2) {
      context.features().toggle(d2);
    }
    function showsLayer(id2) {
      var layer = context.layers().layer(id2);
      return layer && layer.enabled();
    }
    context.features().on("change.map_features", section.reRender);
    return section;
  }

  // modules/ui/sections/map_style_options.js
  function uiSectionMapStyleOptions(context) {
    var section = uiSection("fill-area", context).label(() => _t.append("map_data.style_options")).disclosureContent(renderDisclosureContent).expandedByDefault(false);
    function renderDisclosureContent(selection2) {
      var container = selection2.selectAll(".layer-fill-list").data([0]);
      container.enter().append("ul").attr("class", "layer-list layer-fill-list").merge(container).call(drawListItems, context.map().areaFillOptions, "radio", "area_fill", setFill, isActiveFill);
      var container2 = selection2.selectAll(".layer-visual-diff-list").data([0]);
      container2.enter().append("ul").attr("class", "layer-list layer-visual-diff-list").merge(container2).call(drawListItems, ["highlight_edits"], "checkbox", "visual_diff", toggleHighlightEdited, function() {
        return context.surface().classed("highlight-edited");
      });
    }
    function drawListItems(selection2, data, type2, name, change, active) {
      var items = selection2.selectAll("li").data(data);
      items.exit().remove();
      var enter = items.enter().append("li").call(
        uiTooltip().title(function(d2) {
          return _t.append(name + "." + d2 + ".tooltip");
        }).keys(function(d2) {
          var key = d2 === "wireframe" ? _t("area_fill.wireframe.key") : null;
          if (d2 === "highlight_edits")
            key = _t("map_data.highlight_edits.key");
          return key ? [key] : null;
        }).placement("top")
      );
      var label = enter.append("label");
      label.append("input").attr("type", type2).attr("name", name).on("change", change);
      label.append("span").html(function(d2) {
        return _t.html(name + "." + d2 + ".description");
      });
      items = items.merge(enter);
      items.classed("active", active).selectAll("input").property("checked", active).property("indeterminate", false);
    }
    function isActiveFill(d2) {
      return context.map().activeAreaFill() === d2;
    }
    function toggleHighlightEdited(d3_event) {
      d3_event.preventDefault();
      context.map().toggleHighlightEdited();
    }
    function setFill(d3_event, d2) {
      context.map().activeAreaFill(d2);
    }
    context.map().on("changeHighlighting.ui_style, changeAreaFill.ui_style", section.reRender);
    return section;
  }

  // modules/ui/settings/local_photos.js
  function uiSettingsLocalPhotos(context) {
    var dispatch14 = dispatch_default("change");
    var photoLayer = context.layers().layer("local-photos");
    var modal;
    function render(selection2) {
      modal = uiConfirm(selection2).okButton();
      modal.classed("settings-modal settings-local-photos", true);
      modal.select(".modal-section.header").append("h3").call(_t.append("local_photos.header"));
      modal.select(".modal-section.message-text").append("div").classed("local-photos", true);
      var instructionsSection = modal.select(".modal-section.message-text .local-photos").append("div").classed("instructions", true);
      instructionsSection.append("p").classed("instructions-local-photos", true).call(_t.append("local_photos.file.instructions"));
      instructionsSection.append("input").classed("field-file", true).attr("type", "file").attr("multiple", "multiple").attr("accept", ".jpg,.jpeg,.png,image/png,image/jpeg").style("visibility", "hidden").attr("id", "local-photo-files").on("change", function(d3_event) {
        var files = d3_event.target.files;
        if (files && files.length) {
          photoList.select("ul").append("li").classed("placeholder", true).append("div");
          dispatch14.call("change", this, files);
        }
        d3_event.target.value = null;
      });
      instructionsSection.append("label").attr("for", "local-photo-files").classed("button", true).call(_t.append("local_photos.file.label"));
      const photoList = modal.select(".modal-section.message-text .local-photos").append("div").append("div").classed("list-local-photos", true);
      photoList.append("ul");
      updatePhotoList(photoList.select("ul"));
      context.layers().on("change", () => updatePhotoList(photoList.select("ul")));
    }
    function updatePhotoList(container) {
      var _a2;
      function locationUnavailable(d2) {
        return !(isArray_default(d2.loc) && isNumber_default(d2.loc[0]) && isNumber_default(d2.loc[1]));
      }
      container.selectAll("li.placeholder").remove();
      let selection2 = container.selectAll("li").data((_a2 = photoLayer.getPhotos()) != null ? _a2 : [], (d2) => d2.id);
      selection2.exit().remove();
      const selectionEnter = selection2.enter().append("li");
      selectionEnter.append("span").classed("filename", true);
      selectionEnter.append("button").classed("form-field-button zoom-to-data", true).attr("title", _t("local_photos.zoom_single")).call(svgIcon("#iD-icon-framed-dot"));
      selectionEnter.append("button").classed("form-field-button no-geolocation", true).call(svgIcon("#iD-icon-alert")).call(
        uiTooltip().title(() => _t.append("local_photos.no_geolocation.tooltip")).placement("left")
      );
      selectionEnter.append("button").classed("form-field-button remove", true).attr("title", _t("icons.remove")).call(svgIcon("#iD-operation-delete"));
      selection2 = selection2.merge(selectionEnter);
      selection2.classed("invalid", locationUnavailable);
      selection2.select("span.filename").text((d2) => d2.name).attr("title", (d2) => d2.name);
      selection2.select("span.filename").on("click", (d3_event, d2) => {
        photoLayer.openPhoto(d3_event, d2, false);
      });
      selection2.select("button.zoom-to-data").on("click", (d3_event, d2) => {
        photoLayer.openPhoto(d3_event, d2, true);
      });
      selection2.select("button.remove").on("click", (d3_event, d2) => {
        photoLayer.removePhoto(d2.id);
        updatePhotoList(container);
      });
    }
    return utilRebind(render, dispatch14, "on");
  }

  // modules/ui/sections/photo_overlays.js
  function uiSectionPhotoOverlays(context) {
    var settingsLocalPhotos = uiSettingsLocalPhotos(context).on("change", localPhotosChanged);
    var layers = context.layers();
    var section = uiSection("photo-overlays", context).label(() => _t.append("photo_overlays.title")).disclosureContent(renderDisclosureContent).expandedByDefault(false);
    function renderDisclosureContent(selection2) {
      var container = selection2.selectAll(".photo-overlay-container").data([0]);
      container.enter().append("div").attr("class", "photo-overlay-container").merge(container).call(drawPhotoItems).call(drawPhotoTypeItems).call(drawDateFilter).call(drawUsernameFilter).call(drawLocalPhotos);
    }
    function drawPhotoItems(selection2) {
      var photoKeys = context.photos().overlayLayerIDs();
      var photoLayers = layers.all().filter(function(obj) {
        return photoKeys.indexOf(obj.id) !== -1;
      });
      var data = photoLayers.filter(function(obj) {
        if (!obj.layer.supported())
          return false;
        if (layerEnabled(obj))
          return true;
        if (typeof obj.layer.validHere === "function") {
          return obj.layer.validHere(context.map().extent(), context.map().zoom());
        }
        return true;
      });
      function layerSupported(d2) {
        return d2.layer && d2.layer.supported();
      }
      function layerEnabled(d2) {
        return layerSupported(d2) && d2.layer.enabled();
      }
      function layerRendered(d2) {
        var _a2, _b, _c;
        return (_c = (_b = (_a2 = d2.layer).rendered) == null ? void 0 : _b.call(_a2, context.map().zoom())) != null ? _c : true;
      }
      var ul = selection2.selectAll(".layer-list-photos").data([0]);
      ul = ul.enter().append("ul").attr("class", "layer-list layer-list-photos").merge(ul);
      var li = ul.selectAll(".list-item-photos").data(data);
      li.exit().remove();
      var liEnter = li.enter().append("li").attr("class", function(d2) {
        var classes = "list-item-photos list-item-" + d2.id;
        if (d2.id === "mapillary-signs" || d2.id === "mapillary-map-features") {
          classes += " indented";
        }
        return classes;
      });
      var labelEnter = liEnter.append("label").each(function(d2) {
        var titleID;
        if (d2.id === "mapillary-signs")
          titleID = "mapillary.signs.tooltip";
        else if (d2.id === "mapillary")
          titleID = "mapillary_images.tooltip";
        else if (d2.id === "kartaview")
          titleID = "kartaview_images.tooltip";
        else
          titleID = d2.id.replace(/-/g, "_") + ".tooltip";
        select_default2(this).call(
          uiTooltip().title(() => {
            if (!layerRendered(d2)) {
              return _t.append("street_side.minzoom_tooltip");
            } else {
              return _t.append(titleID);
            }
          }).placement("top")
        );
      });
      labelEnter.append("input").attr("type", "checkbox").on("change", function(d3_event, d2) {
        toggleLayer(d2.id);
      });
      labelEnter.append("span").html(function(d2) {
        var id2 = d2.id;
        if (id2 === "mapillary-signs")
          id2 = "photo_overlays.traffic_signs";
        return _t.html(id2.replace(/-/g, "_") + ".title");
      });
      li.merge(liEnter).classed("active", layerEnabled).selectAll("input").property("disabled", (d2) => !layerRendered(d2)).property("checked", layerEnabled);
    }
    function drawPhotoTypeItems(selection2) {
      var data = context.photos().allPhotoTypes();
      function typeEnabled(d2) {
        return context.photos().showsPhotoType(d2);
      }
      var ul = selection2.selectAll(".layer-list-photo-types").data([0]);
      ul.exit().remove();
      ul = ul.enter().append("ul").attr("class", "layer-list layer-list-photo-types").merge(ul);
      var li = ul.selectAll(".list-item-photo-types").data(context.photos().shouldFilterByPhotoType() ? data : []);
      li.exit().remove();
      var liEnter = li.enter().append("li").attr("class", function(d2) {
        return "list-item-photo-types list-item-" + d2;
      });
      var labelEnter = liEnter.append("label").each(function(d2) {
        select_default2(this).call(
          uiTooltip().title(() => _t.append("photo_overlays.photo_type." + d2 + ".tooltip")).placement("top")
        );
      });
      labelEnter.append("input").attr("type", "checkbox").on("change", function(d3_event, d2) {
        context.photos().togglePhotoType(d2);
      });
      labelEnter.append("span").html(function(d2) {
        return _t.html("photo_overlays.photo_type." + d2 + ".title");
      });
      li.merge(liEnter).classed("active", typeEnabled).selectAll("input").property("checked", typeEnabled);
    }
    function drawDateFilter(selection2) {
      var data = context.photos().dateFilters();
      function filterEnabled(d2) {
        return context.photos().dateFilterValue(d2);
      }
      var ul = selection2.selectAll(".layer-list-date-filter").data([0]);
      ul.exit().remove();
      ul = ul.enter().append("ul").attr("class", "layer-list layer-list-date-filter").merge(ul);
      var li = ul.selectAll(".list-item-date-filter").data(context.photos().shouldFilterByDate() ? data : []);
      li.exit().remove();
      var liEnter = li.enter().append("li").attr("class", "list-item-date-filter");
      var labelEnter = liEnter.append("label").each(function(d2) {
        select_default2(this).call(
          uiTooltip().title(() => _t.append("photo_overlays.date_filter." + d2 + ".tooltip")).placement("top")
        );
      });
      labelEnter.append("span").each(function(d2) {
        _t.append("photo_overlays.date_filter." + d2 + ".title")(select_default2(this));
      });
      labelEnter.append("input").attr("type", "date").attr("class", "list-item-input").attr("placeholder", _t("units.year_month_day")).call(utilNoAuto).each(function(d2) {
        utilGetSetValue(select_default2(this), context.photos().dateFilterValue(d2) || "");
      }).on("change", function(d3_event, d2) {
        var value = utilGetSetValue(select_default2(this)).trim();
        context.photos().setDateFilter(d2, value, true);
        li.selectAll("input").each(function(d4) {
          utilGetSetValue(select_default2(this), context.photos().dateFilterValue(d4) || "");
        });
      });
      li = li.merge(liEnter).classed("active", filterEnabled);
    }
    function drawUsernameFilter(selection2) {
      function filterEnabled() {
        return context.photos().usernames();
      }
      var ul = selection2.selectAll(".layer-list-username-filter").data([0]);
      ul.exit().remove();
      ul = ul.enter().append("ul").attr("class", "layer-list layer-list-username-filter").merge(ul);
      var li = ul.selectAll(".list-item-username-filter").data(context.photos().shouldFilterByUsername() ? ["username-filter"] : []);
      li.exit().remove();
      var liEnter = li.enter().append("li").attr("class", "list-item-username-filter");
      var labelEnter = liEnter.append("label").each(function() {
        select_default2(this).call(
          uiTooltip().title(() => _t.append("photo_overlays.username_filter.tooltip")).placement("top")
        );
      });
      labelEnter.append("span").call(_t.append("photo_overlays.username_filter.title"));
      labelEnter.append("input").attr("type", "text").attr("class", "list-item-input").call(utilNoAuto).property("value", usernameValue).on("change", function() {
        var value = select_default2(this).property("value");
        context.photos().setUsernameFilter(value, true);
        select_default2(this).property("value", usernameValue);
      });
      li.merge(liEnter).classed("active", filterEnabled);
      function usernameValue() {
        var usernames = context.photos().usernames();
        if (usernames)
          return usernames.join("; ");
        return usernames;
      }
    }
    function toggleLayer(which) {
      setLayer(which, !showsLayer(which));
    }
    function showsLayer(which) {
      var layer = layers.layer(which);
      if (layer) {
        return layer.enabled();
      }
      return false;
    }
    function setLayer(which, enabled) {
      var layer = layers.layer(which);
      if (layer) {
        layer.enabled(enabled);
      }
    }
    function drawLocalPhotos(selection2) {
      var photoLayer = layers.layer("local-photos");
      var hasData = photoLayer && photoLayer.hasData();
      var showsData = hasData && photoLayer.enabled();
      var ul = selection2.selectAll(".layer-list-local-photos").data(photoLayer ? [0] : []);
      ul.exit().remove();
      var ulEnter = ul.enter().append("ul").attr("class", "layer-list layer-list-local-photos");
      var localPhotosEnter = ulEnter.append("li").attr("class", "list-item-local-photos");
      var localPhotosLabelEnter = localPhotosEnter.append("label").call(uiTooltip().title(() => _t.append("local_photos.tooltip")));
      localPhotosLabelEnter.append("input").attr("type", "checkbox").on("change", function() {
        toggleLayer("local-photos");
      });
      localPhotosLabelEnter.call(_t.append("local_photos.header"));
      localPhotosEnter.append("button").attr("class", "open-data-options").call(
        uiTooltip().title(() => _t.append("local_photos.tooltip_edit")).placement(_mainLocalizer.textDirection() === "rtl" ? "right" : "left")
      ).on("click", function(d3_event) {
        d3_event.preventDefault();
        editLocalPhotos();
      }).call(svgIcon("#iD-icon-more"));
      localPhotosEnter.append("button").attr("class", "zoom-to-data").call(
        uiTooltip().title(() => _t.append("local_photos.zoom")).placement(_mainLocalizer.textDirection() === "rtl" ? "right" : "left")
      ).on("click", function(d3_event) {
        if (select_default2(this).classed("disabled"))
          return;
        d3_event.preventDefault();
        d3_event.stopPropagation();
        photoLayer.fitZoom();
      }).call(svgIcon("#iD-icon-framed-dot", "monochrome"));
      ul = ul.merge(ulEnter);
      ul.selectAll(".list-item-local-photos").classed("active", showsData).selectAll("label").classed("deemphasize", !hasData).selectAll("input").property("disabled", !hasData).property("checked", showsData);
      ul.selectAll("button.zoom-to-data").classed("disabled", !hasData);
    }
    function editLocalPhotos() {
      context.container().call(settingsLocalPhotos);
    }
    function localPhotosChanged(d2) {
      var localPhotosLayer = layers.layer("local-photos");
      localPhotosLayer.fileList(d2);
    }
    context.layers().on("change.uiSectionPhotoOverlays", section.reRender);
    context.photos().on("change.uiSectionPhotoOverlays", section.reRender);
    context.map().on(
      "move.photo_overlays",
      debounce_default(function() {
        window.requestIdleCallback(section.reRender);
      }, 1e3)
    );
    return section;
  }

  // modules/ui/panes/map_data.js
  function uiPaneMapData(context) {
    var mapDataPane = uiPane("map-data", context).key(_t("map_data.key")).label(_t.append("map_data.title")).description(_t.append("map_data.description")).iconName("iD-icon-data").sections([
      uiSectionDataLayers(context),
      uiSectionPhotoOverlays(context),
      uiSectionMapStyleOptions(context),
      uiSectionMapFeatures(context)
    ]);
    return mapDataPane;
  }

  // modules/ui/panes/preferences.js
  function uiPanePreferences(context) {
    let preferencesPane = uiPane("preferences", context).key(_t("preferences.key")).label(_t.append("preferences.title")).description(_t.append("preferences.description")).iconName("fas-user-cog").sections([
      uiSectionPrivacy(context)
    ]);
    return preferencesPane;
  }

  // modules/ui/init.js
  function uiInit(context) {
    var _initCounter = 0;
    var _needWidth = {};
    var _lastPointerType;
    function render(container) {
      container.on("click.ui", function(d3_event) {
        if (d3_event.button !== 0)
          return;
        if (!d3_event.composedPath)
          return;
        var isOkayTarget = d3_event.composedPath().some(function(node) {
          return node.nodeType === 1 && // clicking <input> focuses it and/or changes a value
          (node.nodeName === "INPUT" || // clicking <label> affects its <input> by default
          node.nodeName === "LABEL" || // clicking <a> opens a hyperlink by default
          node.nodeName === "A");
        });
        if (isOkayTarget)
          return;
        d3_event.preventDefault();
      });
      var detected = utilDetect();
      if ("GestureEvent" in window && // Listening for gesture events on iOS 13.4+ breaks double-tapping,
      // but we only need to do this on desktop Safari anyway. – #7694
      !detected.isMobileWebKit) {
        container.on("gesturestart.ui gesturechange.ui gestureend.ui", function(d3_event) {
          d3_event.preventDefault();
        });
      }
      if ("PointerEvent" in window) {
        select_default2(window).on("pointerdown.ui pointerup.ui", function(d3_event) {
          var pointerType = d3_event.pointerType || "mouse";
          if (_lastPointerType !== pointerType) {
            _lastPointerType = pointerType;
            container.attr("pointer", pointerType);
          }
        }, true);
      } else {
        _lastPointerType = "mouse";
        container.attr("pointer", "mouse");
      }
      container.attr("lang", _mainLocalizer.localeCode()).attr("dir", _mainLocalizer.textDirection());
      container.call(uiFullScreen(context));
      var map2 = context.map();
      map2.redrawEnable(false);
      map2.on("hitMinZoom.ui", function() {
        ui.flash.iconName("#iD-icon-no").label(_t.append("cannot_zoom"))();
      });
      container.append("svg").attr("id", "ideditor-defs").call(ui.svgDefs);
      container.append("div").attr("class", "sidebar").call(ui.sidebar);
      var content = container.append("div").attr("class", "main-content active");
      content.append("div").attr("class", "top-toolbar-wrap").append("div").attr("class", "top-toolbar fillD").call(uiTopToolbar(context));
      content.append("div").attr("class", "main-map").attr("dir", "ltr").call(map2);
      var overMap = content.append("div").attr("class", "over-map");
      overMap.append("div").attr("class", "select-trap").text("t");
      overMap.call(uiMapInMap(context)).call(uiNotice(context));
      overMap.append("div").attr("class", "spinner").call(uiSpinner(context));
      var controlsWrap = overMap.append("div").attr("class", "map-controls-wrap");
      var controls = controlsWrap.append("div").attr("class", "map-controls");
      controls.append("div").attr("class", "map-control zoombuttons").call(uiZoom(context));
      controls.append("div").attr("class", "map-control zoom-to-selection-control").call(uiZoomToSelection(context));
      controls.append("div").attr("class", "map-control geolocate-control").call(uiGeolocate(context));
      controlsWrap.on("wheel.mapControls", function(d3_event) {
        if (!d3_event.deltaX) {
          controlsWrap.node().scrollTop += d3_event.deltaY;
        }
      });
      var panes = overMap.append("div").attr("class", "map-panes");
      var uiPanes = [
        uiPaneBackground(context),
        uiPaneMapData(context),
        uiPaneIssues(context),
        uiPanePreferences(context),
        uiPaneHelp(context)
      ];
      uiPanes.forEach(function(pane) {
        controls.append("div").attr("class", "map-control map-pane-control " + pane.id + "-control").call(pane.renderToggleButton);
        panes.call(pane.renderPane);
      });
      ui.info = uiInfo(context);
      overMap.call(ui.info);
      overMap.append("div").attr("class", "photoviewer").classed("al", true).classed("hide", true).call(ui.photoviewer);
      overMap.append("div").attr("class", "attribution-wrap").attr("dir", "ltr").call(uiAttribution(context));
      var about = content.append("div").attr("class", "map-footer");
      about.append("div").attr("class", "api-status").call(uiStatus(context));
      var footer = about.append("div").attr("class", "map-footer-bar fillD");
      footer.append("div").attr("class", "flash-wrap footer-hide");
      var footerWrap = footer.append("div").attr("class", "main-footer-wrap footer-show");
      footerWrap.append("div").attr("class", "scale-block").call(uiScale(context));
      var aboutList = footerWrap.append("div").attr("class", "info-block").append("ul").attr("class", "map-footer-list");
      aboutList.append("li").attr("class", "user-list").call(uiContributors(context));
      var apiConnections = context.connection().apiConnections();
      if (apiConnections && apiConnections.length > 1) {
        aboutList.append("li").attr("class", "source-switch").call(
          uiSourceSwitch(context).keys(apiConnections)
        );
      }
      aboutList.append("li").attr("class", "issues-info").call(uiIssuesInfo(context));
      aboutList.append("li").attr("class", "feature-warning").call(uiFeatureInfo(context));
      var issueLinks = aboutList.append("li");
      issueLinks.append("a").attr("target", "_blank").attr("href", "https://github.com/openstreetmap/iD/issues").attr("aria-label", _t("report_a_bug")).call(svgIcon("#iD-icon-bug", "light")).call(uiTooltip().title(() => _t.append("report_a_bug")).placement("top"));
      issueLinks.append("a").attr("target", "_blank").attr("href", "https://github.com/openstreetmap/iD/blob/develop/CONTRIBUTING.md#translating").attr("aria-label", _t("help_translate")).call(svgIcon("#iD-icon-translate", "light")).call(uiTooltip().title(() => _t.append("help_translate")).placement("top"));
      aboutList.append("li").attr("class", "version").call(uiVersion(context));
      if (!context.embed()) {
        aboutList.call(uiAccount(context));
      }
      ui.onResize();
      map2.redrawEnable(true);
      ui.hash = behaviorHash(context);
      ui.hash();
      if (!ui.hash.hadLocation) {
        map2.centerZoom([0, 0], 2);
      }
      window.onbeforeunload = function() {
        return context.save();
      };
      window.onunload = function() {
        context.history().unlock();
      };
      select_default2(window).on("resize.editor", function() {
        ui.onResize();
      });
      var panPixels = 80;
      context.keybinding().on("\u232B", function(d3_event) {
        d3_event.preventDefault();
      }).on([_t("sidebar.key"), "`", "\xB2", "@"], ui.sidebar.toggle).on("\u2190", pan([panPixels, 0])).on("\u2191", pan([0, panPixels])).on("\u2192", pan([-panPixels, 0])).on("\u2193", pan([0, -panPixels])).on(uiCmd("\u2325\u2190"), pan([map2.dimensions()[0], 0])).on(uiCmd("\u2325\u2191"), pan([0, map2.dimensions()[1]])).on(uiCmd("\u2325\u2192"), pan([-map2.dimensions()[0], 0])).on(uiCmd("\u2325\u2193"), pan([0, -map2.dimensions()[1]])).on(uiCmd("\u2318" + _t("background.key")), function quickSwitch(d3_event) {
        if (d3_event) {
          d3_event.stopImmediatePropagation();
          d3_event.preventDefault();
        }
        var previousBackground = context.background().findSource(corePreferences("background-last-used-toggle"));
        if (previousBackground) {
          var currentBackground = context.background().baseLayerSource();
          corePreferences("background-last-used-toggle", currentBackground.id);
          corePreferences("background-last-used", previousBackground.id);
          context.background().baseLayerSource(previousBackground);
        }
      }).on(_t("area_fill.wireframe.key"), function toggleWireframe(d3_event) {
        d3_event.preventDefault();
        d3_event.stopPropagation();
        context.map().toggleWireframe();
      }).on(uiCmd("\u2325" + _t("area_fill.wireframe.key")), function toggleOsmData(d3_event) {
        d3_event.preventDefault();
        d3_event.stopPropagation();
        var mode = context.mode();
        if (mode && /^draw/.test(mode.id))
          return;
        var layer = context.layers().layer("osm");
        if (layer) {
          layer.enabled(!layer.enabled());
          if (!layer.enabled()) {
            context.enter(modeBrowse(context));
          }
        }
      }).on(_t("map_data.highlight_edits.key"), function toggleHighlightEdited(d3_event) {
        d3_event.preventDefault();
        context.map().toggleHighlightEdited();
      });
      context.on("enter.editor", function(entered) {
        container.classed("mode-" + entered.id, true);
      }).on("exit.editor", function(exited) {
        container.classed("mode-" + exited.id, false);
      });
      context.enter(modeBrowse(context));
      if (!_initCounter++) {
        if (!ui.hash.startWalkthrough) {
          context.container().call(uiSplash(context)).call(uiRestore(context));
        }
        context.container().call(ui.shortcuts);
      }
      var osm = context.connection();
      var auth = uiLoading(context).message(_t.html("loading_auth")).blocking(true);
      if (osm && auth) {
        osm.on("authLoading.ui", function() {
          context.container().call(auth);
        }).on("authDone.ui", function() {
          auth.close();
        });
      }
      _initCounter++;
      if (ui.hash.startWalkthrough) {
        ui.hash.startWalkthrough = false;
        context.container().call(uiIntro(context));
      }
      function pan(d2) {
        return function(d3_event) {
          if (d3_event.shiftKey)
            return;
          if (context.container().select(".combobox").size())
            return;
          d3_event.preventDefault();
          context.map().pan(d2, 100);
        };
      }
    }
    let ui = {};
    let _loadPromise;
    ui.ensureLoaded = () => {
      if (_loadPromise)
        return _loadPromise;
      return _loadPromise = Promise.all([
        // must have strings and presets before loading the UI
        _mainLocalizer.ensureLoaded(),
        _mainPresetIndex.ensureLoaded()
      ]).then(() => {
        if (!context.container().empty())
          render(context.container());
      }).catch((err) => console.error(err));
    };
    ui.restart = function() {
      context.keybinding().clear();
      _loadPromise = null;
      context.container().selectAll("*").remove();
      ui.ensureLoaded();
    };
    ui.lastPointerType = function() {
      return _lastPointerType;
    };
    ui.svgDefs = svgDefs(context);
    ui.flash = uiFlash(context);
    ui.sidebar = uiSidebar(context);
    ui.photoviewer = uiPhotoviewer(context);
    ui.shortcuts = uiShortcuts(context);
    ui.onResize = function(withPan) {
      var map2 = context.map();
      var mapDimensions = utilGetDimensions(context.container().select(".main-content"), true);
      utilGetDimensions(context.container().select(".sidebar"), true);
      if (withPan !== void 0) {
        map2.redrawEnable(false);
        map2.pan(withPan);
        map2.redrawEnable(true);
      }
      map2.dimensions(mapDimensions);
      ui.photoviewer.onMapResize();
      ui.checkOverflow(".top-toolbar");
      ui.checkOverflow(".map-footer-bar");
      var resizeWindowEvent = document.createEvent("Event");
      resizeWindowEvent.initEvent("resizeWindow", true, true);
      document.dispatchEvent(resizeWindowEvent);
    };
    ui.checkOverflow = function(selector, reset) {
      if (reset) {
        delete _needWidth[selector];
      }
      var selection2 = context.container().select(selector);
      if (selection2.empty())
        return;
      var scrollWidth = selection2.property("scrollWidth");
      var clientWidth = selection2.property("clientWidth");
      var needed = _needWidth[selector] || scrollWidth;
      if (scrollWidth > clientWidth) {
        selection2.classed("narrow", true);
        if (!_needWidth[selector]) {
          _needWidth[selector] = scrollWidth;
        }
      } else if (scrollWidth >= needed) {
        selection2.classed("narrow", false);
      }
    };
    ui.togglePanes = function(showPane) {
      var hidePanes = context.container().selectAll(".map-pane.shown");
      var side = _mainLocalizer.textDirection() === "ltr" ? "right" : "left";
      hidePanes.classed("shown", false).classed("hide", true);
      context.container().selectAll(".map-pane-control button").classed("active", false);
      if (showPane) {
        hidePanes.classed("shown", false).classed("hide", true).style(side, "-500px");
        context.container().selectAll("." + showPane.attr("pane") + "-control button").classed("active", true);
        showPane.classed("shown", true).classed("hide", false);
        if (hidePanes.empty()) {
          showPane.style(side, "-500px").transition().duration(200).style(side, "0px");
        } else {
          showPane.style(side, "0px");
        }
      } else {
        hidePanes.classed("shown", true).classed("hide", false).style(side, "0px").transition().duration(200).style(side, "-500px").on("end", function() {
          select_default2(this).classed("shown", false).classed("hide", true);
        });
      }
    };
    var _editMenu = uiEditMenu(context);
    ui.editMenu = function() {
      return _editMenu;
    };
    ui.showEditMenu = function(anchorPoint, triggerType, operations) {
      ui.closeEditMenu();
      if (!operations && context.mode().operations)
        operations = context.mode().operations();
      if (!operations || !operations.length)
        return;
      if (!context.map().editableDataEnabled())
        return;
      var surfaceNode = context.surface().node();
      if (surfaceNode.focus) {
        surfaceNode.focus();
      }
      operations.forEach(function(operation2) {
        if (operation2.point)
          operation2.point(anchorPoint);
      });
      _editMenu.anchorLoc(anchorPoint).triggerType(triggerType).operations(operations);
      context.map().supersurface.call(_editMenu);
    };
    ui.closeEditMenu = function() {
      context.map().supersurface.select(".edit-menu").remove();
    };
    var _saveLoading = select_default2(null);
    context.uploader().on("saveStarted.ui", function() {
      _saveLoading = uiLoading(context).message(_t.html("save.uploading")).blocking(true);
      context.container().call(_saveLoading);
    }).on("saveEnded.ui", function() {
      _saveLoading.close();
      _saveLoading = select_default2(null);
    });
    marked.use({
      mangle: false,
      headerIds: false
    });
    return ui;
  }

  // modules/core/context.js
  function coreContext() {
    const dispatch14 = dispatch_default("enter", "exit", "change");
    let context = utilRebind({}, dispatch14, "on");
    let _deferred2 = /* @__PURE__ */ new Set();
    context.version = package_default.version;
    context.privacyVersion = "20201202";
    context.initialHashParams = window.location.hash ? utilStringQs(window.location.hash) : {};
    context.changeset = null;
    let _defaultChangesetComment = context.initialHashParams.comment;
    let _defaultChangesetSource = context.initialHashParams.source;
    let _defaultChangesetHashtags = context.initialHashParams.hashtags;
    context.defaultChangesetComment = function(val) {
      if (!arguments.length)
        return _defaultChangesetComment;
      _defaultChangesetComment = val;
      return context;
    };
    context.defaultChangesetSource = function(val) {
      if (!arguments.length)
        return _defaultChangesetSource;
      _defaultChangesetSource = val;
      return context;
    };
    context.defaultChangesetHashtags = function(val) {
      if (!arguments.length)
        return _defaultChangesetHashtags;
      _defaultChangesetHashtags = val;
      return context;
    };
    let _setsDocumentTitle = true;
    context.setsDocumentTitle = function(val) {
      if (!arguments.length)
        return _setsDocumentTitle;
      _setsDocumentTitle = val;
      return context;
    };
    let _documentTitleBase = document.title;
    context.documentTitleBase = function(val) {
      if (!arguments.length)
        return _documentTitleBase;
      _documentTitleBase = val;
      return context;
    };
    let _ui;
    context.ui = () => _ui;
    context.lastPointerType = () => _ui.lastPointerType();
    let _keybinding = utilKeybinding("context");
    context.keybinding = () => _keybinding;
    select_default2(document).call(_keybinding);
    let _connection = services.osm;
    let _history;
    let _validator;
    let _uploader;
    context.connection = () => _connection;
    context.history = () => _history;
    context.validator = () => _validator;
    context.uploader = () => _uploader;
    context.preauth = (options2) => {
      if (_connection) {
        _connection.switch(options2);
      }
      return context;
    };
    context.locale = function(locale2) {
      if (!arguments.length)
        return _mainLocalizer.localeCode();
      _mainLocalizer.preferredLocaleCodes(locale2);
      return context;
    };
    function afterLoad(cid, callback) {
      return (err, result) => {
        if (err) {
          if (err.status === 400 || err.status === 401 || err.status === 403) {
            if (_connection) {
              _connection.logout();
            }
          }
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        } else if (_connection && _connection.getConnectionId() !== cid) {
          if (typeof callback === "function") {
            callback({ message: "Connection Switched", status: -1 });
          }
          return;
        } else {
          _history.merge(result.data, result.extent);
          if (typeof callback === "function") {
            callback(err, result);
          }
          return;
        }
      };
    }
    context.loadTiles = (projection2, callback) => {
      const handle = window.requestIdleCallback(() => {
        _deferred2.delete(handle);
        if (_connection && context.editableDataEnabled()) {
          const cid = _connection.getConnectionId();
          _connection.loadTiles(projection2, afterLoad(cid, callback));
        }
      });
      _deferred2.add(handle);
    };
    context.loadTileAtLoc = (loc, callback) => {
      const handle = window.requestIdleCallback(() => {
        _deferred2.delete(handle);
        if (_connection && context.editableDataEnabled()) {
          const cid = _connection.getConnectionId();
          _connection.loadTileAtLoc(loc, afterLoad(cid, callback));
        }
      });
      _deferred2.add(handle);
    };
    context.loadEntity = (entityID, callback) => {
      if (_connection) {
        const cid = _connection.getConnectionId();
        _connection.loadEntity(entityID, afterLoad(cid, callback));
        _connection.loadEntityRelations(entityID, afterLoad(cid, callback));
      }
    };
    context.loadNote = (entityID, callback) => {
      if (_connection) {
        const cid = _connection.getConnectionId();
        _connection.loadEntityNote(entityID, afterLoad(cid, callback));
      }
    };
    context.zoomToEntity = (entityID, zoomTo) => {
      context.loadEntity(entityID, (err, result) => {
        if (err)
          return;
        if (zoomTo !== false) {
          const entity = result.data.find((e3) => e3.id === entityID);
          if (entity) {
            _map.zoomTo(entity);
          }
        }
      });
      _map.on("drawn.zoomToEntity", () => {
        if (!context.hasEntity(entityID))
          return;
        _map.on("drawn.zoomToEntity", null);
        context.on("enter.zoomToEntity", null);
        context.enter(modeSelect(context, [entityID]));
      });
      context.on("enter.zoomToEntity", () => {
        if (_mode.id !== "browse") {
          _map.on("drawn.zoomToEntity", null);
          context.on("enter.zoomToEntity", null);
        }
      });
    };
    let _minEditableZoom = 16;
    context.minEditableZoom = function(val) {
      if (!arguments.length)
        return _minEditableZoom;
      _minEditableZoom = val;
      if (_connection) {
        _connection.tileZoom(val);
      }
      return context;
    };
    context.maxCharsForTagKey = () => 255;
    context.maxCharsForTagValue = () => 255;
    context.maxCharsForRelationRole = () => 255;
    context.cleanTagKey = (val) => utilCleanOsmString(val, context.maxCharsForTagKey());
    context.cleanTagValue = (val) => utilCleanOsmString(val, context.maxCharsForTagValue());
    context.cleanRelationRole = (val) => utilCleanOsmString(val, context.maxCharsForRelationRole());
    let _inIntro = false;
    context.inIntro = function(val) {
      if (!arguments.length)
        return _inIntro;
      _inIntro = val;
      return context;
    };
    context.save = () => {
      if (_inIntro || context.container().select(".modal").size())
        return;
      let canSave;
      if (_mode && _mode.id === "save") {
        canSave = false;
        if (services.osm && services.osm.isChangesetInflight()) {
          _history.clearSaved();
          return;
        }
      } else {
        canSave = context.selectedIDs().every((id2) => {
          const entity = context.hasEntity(id2);
          return entity && !entity.isDegenerate();
        });
      }
      if (canSave) {
        _history.save();
      }
      if (_history.hasChanges()) {
        return _t("save.unsaved_changes");
      }
    };
    context.debouncedSave = debounce_default(context.save, 350);
    function withDebouncedSave(fn) {
      return function() {
        const result = fn.apply(_history, arguments);
        context.debouncedSave();
        return result;
      };
    }
    context.hasEntity = (id2) => _history.graph().hasEntity(id2);
    context.entity = (id2) => _history.graph().entity(id2);
    let _mode;
    context.mode = () => _mode;
    context.enter = (newMode) => {
      if (_mode) {
        _mode.exit();
        dispatch14.call("exit", this, _mode);
      }
      _mode = newMode;
      _mode.enter();
      dispatch14.call("enter", this, _mode);
    };
    context.selectedIDs = () => _mode && _mode.selectedIDs && _mode.selectedIDs() || [];
    context.activeID = () => _mode && _mode.activeID && _mode.activeID();
    let _selectedNoteID;
    context.selectedNoteID = function(noteID) {
      if (!arguments.length)
        return _selectedNoteID;
      _selectedNoteID = noteID;
      return context;
    };
    let _selectedErrorID;
    context.selectedErrorID = function(errorID) {
      if (!arguments.length)
        return _selectedErrorID;
      _selectedErrorID = errorID;
      return context;
    };
    context.install = (behavior) => context.surface().call(behavior);
    context.uninstall = (behavior) => context.surface().call(behavior.off);
    let _copyGraph;
    context.copyGraph = () => _copyGraph;
    let _copyIDs = [];
    context.copyIDs = function(val) {
      if (!arguments.length)
        return _copyIDs;
      _copyIDs = val;
      _copyGraph = _history.graph();
      return context;
    };
    let _copyLonLat;
    context.copyLonLat = function(val) {
      if (!arguments.length)
        return _copyLonLat;
      _copyLonLat = val;
      return context;
    };
    let _background;
    context.background = () => _background;
    let _features;
    context.features = () => _features;
    context.hasHiddenConnections = (id2) => {
      const graph = _history.graph();
      const entity = graph.entity(id2);
      return _features.hasHiddenConnections(entity, graph);
    };
    let _photos;
    context.photos = () => _photos;
    let _map;
    context.map = () => _map;
    context.layers = () => _map.layers();
    context.surface = () => _map.surface;
    context.editableDataEnabled = () => _map.editableDataEnabled();
    context.surfaceRect = () => _map.surface.node().getBoundingClientRect();
    context.editable = () => {
      const mode = context.mode();
      if (!mode || mode.id === "save")
        return false;
      return _map.editableDataEnabled();
    };
    let _debugFlags = {
      tile: false,
      // tile boundaries
      collision: false,
      // label collision bounding boxes
      imagery: false,
      // imagery bounding polygons
      target: false,
      // touch targets
      downloaded: false
      // downloaded data from osm
    };
    context.debugFlags = () => _debugFlags;
    context.getDebug = (flag) => flag && _debugFlags[flag];
    context.setDebug = function(flag, val) {
      if (arguments.length === 1)
        val = true;
      _debugFlags[flag] = val;
      dispatch14.call("change");
      return context;
    };
    let _container = select_default2(null);
    context.container = function(val) {
      if (!arguments.length)
        return _container;
      _container = val;
      _container.classed("ideditor", true);
      return context;
    };
    context.containerNode = function(val) {
      if (!arguments.length)
        return context.container().node();
      context.container(select_default2(val));
      return context;
    };
    let _embed;
    context.embed = function(val) {
      if (!arguments.length)
        return _embed;
      _embed = val;
      return context;
    };
    let _assetPath = "";
    context.assetPath = function(val) {
      if (!arguments.length)
        return _assetPath;
      _assetPath = val;
      _mainFileFetcher.assetPath(val);
      return context;
    };
    let _assetMap = {};
    context.assetMap = function(val) {
      if (!arguments.length)
        return _assetMap;
      _assetMap = val;
      _mainFileFetcher.assetMap(val);
      return context;
    };
    context.asset = (val) => {
      if (/^http(s)?:\/\//i.test(val))
        return val;
      const filename = _assetPath + val;
      return _assetMap[filename] || filename;
    };
    context.imagePath = (val) => context.asset("img/".concat(val));
    context.reset = context.flush = () => {
      context.debouncedSave.cancel();
      Array.from(_deferred2).forEach((handle) => {
        window.cancelIdleCallback(handle);
        _deferred2.delete(handle);
      });
      Object.values(services).forEach((service) => {
        if (service && typeof service.reset === "function") {
          service.reset(context);
        }
      });
      context.changeset = null;
      _validator.reset();
      _features.reset();
      _history.reset();
      _uploader.reset();
      context.container().select(".inspector-wrap *").remove();
      return context;
    };
    context.projection = geoRawMercator();
    context.curtainProjection = geoRawMercator();
    context.init = () => {
      instantiateInternal();
      initializeDependents();
      return context;
      function instantiateInternal() {
        _history = coreHistory(context);
        context.graph = _history.graph;
        context.pauseChangeDispatch = _history.pauseChangeDispatch;
        context.resumeChangeDispatch = _history.resumeChangeDispatch;
        context.perform = withDebouncedSave(_history.perform);
        context.replace = withDebouncedSave(_history.replace);
        context.pop = withDebouncedSave(_history.pop);
        context.overwrite = withDebouncedSave(_history.overwrite);
        context.undo = withDebouncedSave(_history.undo);
        context.redo = withDebouncedSave(_history.redo);
        _validator = coreValidator(context);
        _uploader = coreUploader(context);
        _background = rendererBackground(context);
        _features = rendererFeatures(context);
        _map = rendererMap(context);
        _photos = rendererPhotos(context);
        _ui = uiInit(context);
      }
      function initializeDependents() {
        if (context.initialHashParams.presets) {
          _mainPresetIndex.addablePresetIDs(new Set(context.initialHashParams.presets.split(",")));
        }
        if (context.initialHashParams.locale) {
          _mainLocalizer.preferredLocaleCodes(context.initialHashParams.locale);
        }
        _mainLocalizer.ensureLoaded();
        _mainPresetIndex.ensureLoaded();
        _background.ensureLoaded();
        Object.values(services).forEach((service) => {
          if (service && typeof service.init === "function") {
            service.init();
          }
        });
        _map.init();
        _validator.init();
        _features.init();
        if (services.maprules && context.initialHashParams.maprules) {
          json_default(context.initialHashParams.maprules).then((mapcss) => {
            services.maprules.init();
            mapcss.forEach((mapcssSelector) => services.maprules.addRule(mapcssSelector));
          }).catch(() => {
          });
        }
        if (!context.container().empty()) {
          _ui.ensureLoaded().then(() => {
            _background.init();
            _photos.init();
          });
        }
      }
    };
    return context;
  }

  // modules/services/nominatim.js
  var apibase = nominatimApiUrl;
  var _inflight = {};
  var _nominatimCache;
  var nominatim_default = {
    init: function() {
      _inflight = {};
      _nominatimCache = new import_rbush7.default();
    },
    reset: function() {
      Object.values(_inflight).forEach(function(controller) {
        controller.abort();
      });
      _inflight = {};
      _nominatimCache = new import_rbush7.default();
    },
    countryCode: function(location, callback) {
      this.reverse(location, function(err, result) {
        if (err) {
          return callback(err);
        } else if (result.address) {
          return callback(null, result.address.country_code);
        } else {
          return callback("Unable to geocode", null);
        }
      });
    },
    reverse: function(loc, callback) {
      var cached = _nominatimCache.search(
        { minX: loc[0], minY: loc[1], maxX: loc[0], maxY: loc[1] }
      );
      if (cached.length > 0) {
        if (callback)
          callback(null, cached[0].data);
        return;
      }
      var params = { zoom: 13, format: "json", addressdetails: 1, lat: loc[1], lon: loc[0] };
      var url = apibase + "reverse?" + utilQsString(params);
      if (_inflight[url])
        return;
      var controller = new AbortController();
      _inflight[url] = controller;
      json_default(url, {
        signal: controller.signal,
        headers: {
          "Accept-Language": _mainLocalizer.localeCodes().join(",")
        }
      }).then(function(result) {
        delete _inflight[url];
        if (result && result.error) {
          throw new Error(result.error);
        }
        var extent = geoExtent(loc).padByMeters(200);
        _nominatimCache.insert(Object.assign(extent.bbox(), { data: result }));
        if (callback)
          callback(null, result);
      }).catch(function(err) {
        delete _inflight[url];
        if (err.name === "AbortError")
          return;
        if (callback)
          callback(err.message);
      });
    },
    search: function(val, callback) {
      const params = {
        q: val,
        limit: 10,
        format: "json"
      };
      var url = apibase + "search?" + utilQsString(params);
      if (_inflight[url])
        return;
      var controller = new AbortController();
      _inflight[url] = controller;
      json_default(url, {
        signal: controller.signal,
        headers: {
          "Accept-Language": _mainLocalizer.localeCodes().join(",")
        }
      }).then(function(result) {
        delete _inflight[url];
        if (result && result.error) {
          throw new Error(result.error);
        }
        if (callback)
          callback(null, result);
      }).catch(function(err) {
        delete _inflight[url];
        if (err.name === "AbortError")
          return;
        if (callback)
          callback(err.message);
      });
    }
  };

  // node_modules/name-suggestion-index/lib/matcher.js
  var import_which_polygon4 = __toESM(require_which_polygon(), 1);

  // node_modules/name-suggestion-index/lib/simplify.js
  var import_diacritics3 = __toESM(require_diacritics(), 1);
  function simplify2(str) {
    if (typeof str !== "string")
      return "";
    return import_diacritics3.default.remove(
      str.replace(/&/g, "and").replace(/İ/ig, "i").replace(/[\s\-=_!"#%'*{},.\/:;?\(\)\[\]@\\$\^*+<>«»~`’\u00a1\u00a7\u00b6\u00b7\u00bf\u037e\u0387\u055a-\u055f\u0589\u05c0\u05c3\u05c6\u05f3\u05f4\u0609\u060a\u060c\u060d\u061b\u061e\u061f\u066a-\u066d\u06d4\u0700-\u070d\u07f7-\u07f9\u0830-\u083e\u085e\u0964\u0965\u0970\u0af0\u0df4\u0e4f\u0e5a\u0e5b\u0f04-\u0f12\u0f14\u0f85\u0fd0-\u0fd4\u0fd9\u0fda\u104a-\u104f\u10fb\u1360-\u1368\u166d\u166e\u16eb-\u16ed\u1735\u1736\u17d4-\u17d6\u17d8-\u17da\u1800-\u1805\u1807-\u180a\u1944\u1945\u1a1e\u1a1f\u1aa0-\u1aa6\u1aa8-\u1aad\u1b5a-\u1b60\u1bfc-\u1bff\u1c3b-\u1c3f\u1c7e\u1c7f\u1cc0-\u1cc7\u1cd3\u2000-\u206f\u2cf9-\u2cfc\u2cfe\u2cff\u2d70\u2e00-\u2e7f\u3001-\u3003\u303d\u30fb\ua4fe\ua4ff\ua60d-\ua60f\ua673\ua67e\ua6f2-\ua6f7\ua874-\ua877\ua8ce\ua8cf\ua8f8-\ua8fa\ua92e\ua92f\ua95f\ua9c1-\ua9cd\ua9de\ua9df\uaa5c-\uaa5f\uaade\uaadf\uaaf0\uaaf1\uabeb\ufe10-\ufe16\ufe19\ufe30\ufe45\ufe46\ufe49-\ufe4c\ufe50-\ufe52\ufe54-\ufe57\ufe5f-\ufe61\ufe68\ufe6a\ufe6b\ufeff\uff01-\uff03\uff05-\uff07\uff0a\uff0c\uff0e\uff0f\uff1a\uff1b\uff1f\uff20\uff3c\uff61\uff64\uff65]+/g, "").toLowerCase()
    );
  }

  // node_modules/name-suggestion-index/config/matchGroups.json
  var matchGroups_default = {
    matchGroups: {
      adult_gaming_centre: [
        "amenity/casino",
        "amenity/gambling",
        "leisure/adult_gaming_centre"
      ],
      beauty: [
        "shop/beauty",
        "shop/hairdresser_supply"
      ],
      bed: [
        "shop/bed",
        "shop/furniture"
      ],
      beverages: [
        "shop/alcohol",
        "shop/beer",
        "shop/beverages",
        "shop/kiosk",
        "shop/wine"
      ],
      camping: [
        "tourism/camp_site",
        "tourism/caravan_site"
      ],
      car_parts: [
        "shop/car_parts",
        "shop/car_repair",
        "shop/tires",
        "shop/tyres"
      ],
      clinic: [
        "amenity/clinic",
        "amenity/doctors",
        "healthcare/clinic",
        "healthcare/laboratory",
        "healthcare/physiotherapist",
        "healthcare/sample_collection",
        "healthcare/dialysis"
      ],
      convenience: [
        "shop/beauty",
        "shop/chemist",
        "shop/convenience",
        "shop/cosmetics",
        "shop/grocery",
        "shop/kiosk",
        "shop/newsagent",
        "shop/perfumery"
      ],
      coworking: [
        "amenity/coworking_space",
        "office/coworking",
        "office/coworking_space"
      ],
      dentist: [
        "amenity/dentist",
        "amenity/doctors",
        "healthcare/dentist"
      ],
      electronics: [
        "office/telecommunication",
        "shop/computer",
        "shop/electronics",
        "shop/hifi",
        "shop/kiosk",
        "shop/mobile",
        "shop/mobile_phone",
        "shop/telecommunication"
      ],
      fabric: [
        "shop/fabric",
        "shop/haberdashery",
        "shop/sewing"
      ],
      fashion: [
        "shop/accessories",
        "shop/bag",
        "shop/boutique",
        "shop/clothes",
        "shop/department_store",
        "shop/fashion",
        "shop/fashion_accessories",
        "shop/sports",
        "shop/shoes"
      ],
      financial: [
        "amenity/bank",
        "office/accountant",
        "office/financial",
        "office/financial_advisor",
        "office/tax_advisor",
        "shop/tax"
      ],
      fitness: [
        "leisure/fitness_centre",
        "leisure/fitness_center",
        "leisure/sports_centre",
        "leisure/sports_center"
      ],
      food: [
        "amenity/bar",
        "amenity/cafe",
        "amenity/fast_food",
        "amenity/ice_cream",
        "amenity/pub",
        "amenity/restaurant",
        "shop/bakery",
        "shop/candy",
        "shop/chocolate",
        "shop/coffee",
        "shop/confectionary",
        "shop/confectionery",
        "shop/food",
        "shop/kiosk",
        "shop/ice_cream",
        "shop/pastry",
        "shop/tea"
      ],
      fuel: [
        "amenity/fuel",
        "shop/gas",
        "shop/convenience;gas",
        "shop/gas;convenience"
      ],
      gift: [
        "shop/gift",
        "shop/card",
        "shop/cards",
        "shop/kiosk",
        "shop/stationery"
      ],
      hardware: [
        "shop/bathroom_furnishing",
        "shop/carpet",
        "shop/diy",
        "shop/doityourself",
        "shop/doors",
        "shop/electrical",
        "shop/flooring",
        "shop/hardware",
        "shop/hardware_store",
        "shop/power_tools",
        "shop/tool_hire",
        "shop/tools",
        "shop/trade"
      ],
      health_food: [
        "shop/health",
        "shop/health_food",
        "shop/herbalist",
        "shop/nutrition_supplements"
      ],
      hobby: [
        "shop/electronics",
        "shop/hobby",
        "shop/books",
        "shop/games",
        "shop/collector",
        "shop/toys",
        "shop/model",
        "shop/video_games",
        "shop/anime"
      ],
      hospital: [
        "amenity/doctors",
        "amenity/hospital",
        "healthcare/hospital"
      ],
      houseware: [
        "shop/houseware",
        "shop/interior_decoration"
      ],
      lifeboat_station: [
        "amenity/lifeboat_station",
        "emergency/lifeboat_station",
        "emergency/marine_rescue"
      ],
      lodging: [
        "tourism/hotel",
        "tourism/motel"
      ],
      money_transfer: [
        "amenity/money_transfer",
        "shop/money_transfer"
      ],
      office_supplies: [
        "shop/office_supplies",
        "shop/stationary",
        "shop/stationery"
      ],
      outdoor: [
        "shop/clothes",
        "shop/outdoor",
        "shop/sports"
      ],
      parcel_locker: [
        "amenity/parcel_locker",
        "amenity/vending_machine"
      ],
      pharmacy: [
        "amenity/doctors",
        "amenity/pharmacy",
        "healthcare/pharmacy"
      ],
      playground: [
        "amenity/theme_park",
        "leisure/amusement_arcade",
        "leisure/playground"
      ],
      rental: [
        "amenity/bicycle_rental",
        "amenity/boat_rental",
        "amenity/car_rental",
        "amenity/truck_rental",
        "amenity/vehicle_rental",
        "shop/kiosk",
        "shop/rental"
      ],
      school: [
        "amenity/childcare",
        "amenity/college",
        "amenity/kindergarten",
        "amenity/language_school",
        "amenity/prep_school",
        "amenity/school",
        "amenity/university"
      ],
      storage: [
        "shop/storage_units",
        "shop/storage_rental"
      ],
      substation: [
        "power/station",
        "power/substation",
        "power/sub_station"
      ],
      supermarket: [
        "shop/food",
        "shop/frozen_food",
        "shop/greengrocer",
        "shop/grocery",
        "shop/supermarket",
        "shop/wholesale"
      ],
      variety_store: [
        "shop/variety_store",
        "shop/discount",
        "shop/convenience"
      ],
      vending: [
        "amenity/vending_machine",
        "shop/kiosk",
        "shop/vending_machine"
      ],
      weight_loss: [
        "amenity/clinic",
        "amenity/doctors",
        "amenity/weight_clinic",
        "healthcare/counselling",
        "leisure/fitness_centre",
        "office/therapist",
        "shop/beauty",
        "shop/diet",
        "shop/food",
        "shop/health_food",
        "shop/herbalist",
        "shop/nutrition",
        "shop/nutrition_supplements",
        "shop/weight_loss"
      ],
      wholesale: [
        "shop/wholesale",
        "shop/supermarket",
        "shop/department_store"
      ]
    }
  };

  // node_modules/name-suggestion-index/config/genericWords.json
  var genericWords_default = {
    genericWords: [
      "^(barn|bazaa?r|bench|bou?tique|building|casa|church)$",
      "^(baseball|basketball|football|soccer|softball|tennis(halle)?)\\s?(field|court)?$",
      "^(club|green|out|ware)\\s?house$",
      "^(driveway|el \xE1rbol|fountain|generic|golf|government|graveyard)$",
      "^(fixme|n\\s?\\/?\\s?a|name|no\\s?name|none|null|temporary|test|unknown)$",
      "^(hofladen|librairie|magazine?|maison)$",
      "^(mobile home|skate)?\\s?park$",
      "^(obuwie|pond|pool|sale|shops?|sklep|stores?)$",
      "^\\?+$",
      "^private$",
      "^tattoo( studio)?$",
      "^windmill$",
      "^\u0446\u0435\u0440\u043A\u043E\u0432\u043D\u0430\u044F( \u043B\u0430\u0432\u043A\u0430)?$"
    ]
  };

  // node_modules/name-suggestion-index/config/trees.json
  var trees_default = {
    trees: {
      brands: {
        emoji: "\u{1F354}",
        mainTag: "brand:wikidata",
        sourceTags: ["brand", "name"],
        nameTags: {
          primary: "^(name|name:\\w+)$",
          alternate: "^(brand|brand:\\w+|operator|operator:\\w+|\\w+_name|\\w+_name:\\w+)$"
        }
      },
      flags: {
        emoji: "\u{1F6A9}",
        mainTag: "flag:wikidata",
        nameTags: {
          primary: "^(flag:name|flag:name:\\w+)$",
          alternate: "^(country|country:\\w+|flag|flag:\\w+|subject|subject:\\w+)$"
        }
      },
      operators: {
        emoji: "\u{1F4BC}",
        mainTag: "operator:wikidata",
        sourceTags: ["operator"],
        nameTags: {
          primary: "^(name|name:\\w+|operator|operator:\\w+)$",
          alternate: "^(brand|brand:\\w+|\\w+_name|\\w+_name:\\w+)$"
        }
      },
      transit: {
        emoji: "\u{1F687}",
        mainTag: "network:wikidata",
        sourceTags: ["network"],
        nameTags: {
          primary: "^network$",
          alternate: "^(operator|operator:\\w+|network:\\w+|\\w+_name|\\w+_name:\\w+)$"
        }
      }
    }
  };

  // node_modules/name-suggestion-index/lib/matcher.js
  var matchGroups = matchGroups_default.matchGroups;
  var trees = trees_default.trees;
  var Matcher = class {
    //
    // `constructor`
    // initialize the genericWords regexes
    constructor() {
      this.matchIndex = void 0;
      this.genericWords = /* @__PURE__ */ new Map();
      (genericWords_default.genericWords || []).forEach((s2) => this.genericWords.set(s2, new RegExp(s2, "i")));
      this.itemLocation = void 0;
      this.locationSets = void 0;
      this.locationIndex = void 0;
      this.warnings = [];
    }
    //
    // `buildMatchIndex()`
    // Call this to prepare the matcher for use
    //
    // `data` needs to be an Object indexed on a 'tree/key/value' path.
    // (e.g. cache filled by `fileTree.read` or data found in `dist/nsi.json`)
    // {
    //    'brands/amenity/bank': { properties: {}, items: [ {}, {}, … ] },
    //    'brands/amenity/bar':  { properties: {}, items: [ {}, {}, … ] },
    //    …
    // }
    //
    buildMatchIndex(data) {
      const that = this;
      if (that.matchIndex)
        return;
      that.matchIndex = /* @__PURE__ */ new Map();
      const seenTree = /* @__PURE__ */ new Map();
      Object.keys(data).forEach((tkv) => {
        const category = data[tkv];
        const parts = tkv.split("/", 3);
        const t2 = parts[0];
        const k2 = parts[1];
        const v2 = parts[2];
        const thiskv = "".concat(k2, "/").concat(v2);
        const tree = trees[t2];
        let branch = that.matchIndex.get(thiskv);
        if (!branch) {
          branch = {
            primary: /* @__PURE__ */ new Map(),
            alternate: /* @__PURE__ */ new Map(),
            excludeGeneric: /* @__PURE__ */ new Map(),
            excludeNamed: /* @__PURE__ */ new Map()
          };
          that.matchIndex.set(thiskv, branch);
        }
        const properties = category.properties || {};
        const exclude = properties.exclude || {};
        (exclude.generic || []).forEach((s2) => branch.excludeGeneric.set(s2, new RegExp(s2, "i")));
        (exclude.named || []).forEach((s2) => branch.excludeNamed.set(s2, new RegExp(s2, "i")));
        const excludeRegexes = [...branch.excludeGeneric.values(), ...branch.excludeNamed.values()];
        let items = category.items;
        if (!Array.isArray(items) || !items.length)
          return;
        const primaryName = new RegExp(tree.nameTags.primary, "i");
        const alternateName = new RegExp(tree.nameTags.alternate, "i");
        const notName = /:(colou?r|type|forward|backward|left|right|etymology|pronunciation|wikipedia)$/i;
        const skipGenericKV = skipGenericKVMatches(t2, k2, v2);
        const genericKV = /* @__PURE__ */ new Set(["".concat(k2, "/yes"), "building/yes"]);
        const matchGroupKV = /* @__PURE__ */ new Set();
        Object.values(matchGroups).forEach((matchGroup) => {
          const inGroup = matchGroup.some((otherkv) => otherkv === thiskv);
          if (!inGroup)
            return;
          matchGroup.forEach((otherkv) => {
            if (otherkv === thiskv)
              return;
            matchGroupKV.add(otherkv);
            const otherk = otherkv.split("/", 2)[0];
            genericKV.add("".concat(otherk, "/yes"));
          });
        });
        items.forEach((item) => {
          if (!item.id)
            return;
          if (Array.isArray(item.matchTags) && item.matchTags.length) {
            item.matchTags = item.matchTags.filter((matchTag) => !matchGroupKV.has(matchTag) && !genericKV.has(matchTag));
            if (!item.matchTags.length)
              delete item.matchTags;
          }
          let kvTags = ["".concat(thiskv)].concat(item.matchTags || []);
          if (!skipGenericKV) {
            kvTags = kvTags.concat(Array.from(genericKV));
          }
          Object.keys(item.tags).forEach((osmkey) => {
            if (notName.test(osmkey))
              return;
            const osmvalue = item.tags[osmkey];
            if (!osmvalue || excludeRegexes.some((regex) => regex.test(osmvalue)))
              return;
            if (primaryName.test(osmkey)) {
              kvTags.forEach((kv) => insertName("primary", t2, kv, simplify2(osmvalue), item.id));
            } else if (alternateName.test(osmkey)) {
              kvTags.forEach((kv) => insertName("alternate", t2, kv, simplify2(osmvalue), item.id));
            }
          });
          let keepMatchNames = /* @__PURE__ */ new Set();
          (item.matchNames || []).forEach((matchName) => {
            const nsimple = simplify2(matchName);
            kvTags.forEach((kv) => {
              const branch2 = that.matchIndex.get(kv);
              const primaryLeaf = branch2 && branch2.primary.get(nsimple);
              const alternateLeaf = branch2 && branch2.alternate.get(nsimple);
              const inPrimary = primaryLeaf && primaryLeaf.has(item.id);
              const inAlternate = alternateLeaf && alternateLeaf.has(item.id);
              if (!inPrimary && !inAlternate) {
                insertName("alternate", t2, kv, nsimple, item.id);
                keepMatchNames.add(matchName);
              }
            });
          });
          if (keepMatchNames.size) {
            item.matchNames = Array.from(keepMatchNames);
          } else {
            delete item.matchNames;
          }
        });
      });
      function insertName(which, t2, kv, nsimple, itemID) {
        if (!nsimple) {
          that.warnings.push("Warning: skipping empty ".concat(which, " name for item ").concat(t2, "/").concat(kv, ": ").concat(itemID));
          return;
        }
        let branch = that.matchIndex.get(kv);
        if (!branch) {
          branch = {
            primary: /* @__PURE__ */ new Map(),
            alternate: /* @__PURE__ */ new Map(),
            excludeGeneric: /* @__PURE__ */ new Map(),
            excludeNamed: /* @__PURE__ */ new Map()
          };
          that.matchIndex.set(kv, branch);
        }
        let leaf = branch[which].get(nsimple);
        if (!leaf) {
          leaf = /* @__PURE__ */ new Set();
          branch[which].set(nsimple, leaf);
        }
        leaf.add(itemID);
        if (!/yes$/.test(kv)) {
          const kvnsimple = "".concat(kv, "/").concat(nsimple);
          const existing = seenTree.get(kvnsimple);
          if (existing && existing !== t2) {
            const items = Array.from(leaf);
            that.warnings.push('Duplicate cache key "'.concat(kvnsimple, '" in trees "').concat(t2, '" and "').concat(existing, '", check items: ').concat(items));
            return;
          }
          seenTree.set(kvnsimple, t2);
        }
      }
      function skipGenericKVMatches(t2, k2, v2) {
        return t2 === "flags" || t2 === "transit" || k2 === "landuse" || v2 === "atm" || v2 === "bicycle_parking" || v2 === "car_sharing" || v2 === "caravan_site" || v2 === "charging_station" || v2 === "dog_park" || v2 === "parking" || v2 === "phone" || v2 === "playground" || v2 === "post_box" || v2 === "public_bookcase" || v2 === "recycling" || v2 === "vending_machine";
      }
    }
    //
    // `buildLocationIndex()`
    // Call this to prepare a which-polygon location index.
    // This *resolves* all the locationSets into GeoJSON, which takes some time.
    // You can skip this step if you don't care about matching within a location.
    //
    // `data` needs to be an Object indexed on a 'tree/key/value' path.
    // (e.g. cache filled by `fileTree.read` or data found in `dist/nsi.json`)
    // {
    //    'brands/amenity/bank': { properties: {}, items: [ {}, {}, … ] },
    //    'brands/amenity/bar':  { properties: {}, items: [ {}, {}, … ] },
    //    …
    // }
    //
    buildLocationIndex(data, loco) {
      const that = this;
      if (that.locationIndex)
        return;
      that.itemLocation = /* @__PURE__ */ new Map();
      that.locationSets = /* @__PURE__ */ new Map();
      Object.keys(data).forEach((tkv) => {
        const items = data[tkv].items;
        if (!Array.isArray(items) || !items.length)
          return;
        items.forEach((item) => {
          if (that.itemLocation.has(item.id))
            return;
          let resolved;
          try {
            resolved = loco.resolveLocationSet(item.locationSet);
          } catch (err) {
            console.warn("buildLocationIndex: ".concat(err.message));
          }
          if (!resolved || !resolved.id)
            return;
          that.itemLocation.set(item.id, resolved.id);
          if (that.locationSets.has(resolved.id))
            return;
          let feature3 = _cloneDeep2(resolved.feature);
          feature3.id = resolved.id;
          feature3.properties.id = resolved.id;
          if (!feature3.geometry.coordinates.length || !feature3.properties.area) {
            console.warn("buildLocationIndex: locationSet ".concat(resolved.id, " for ").concat(item.id, " resolves to an empty feature:"));
            console.warn(JSON.stringify(feature3));
            return;
          }
          that.locationSets.set(resolved.id, feature3);
        });
      });
      that.locationIndex = (0, import_which_polygon4.default)({ type: "FeatureCollection", features: [...that.locationSets.values()] });
      function _cloneDeep2(obj) {
        return JSON.parse(JSON.stringify(obj));
      }
    }
    //
    // `match()`
    // Pass parts and return an Array of matches.
    // `k` - key
    // `v` - value
    // `n` - namelike
    // `loc` - optional - [lon,lat] location to search
    //
    // 1. If the [k,v,n] tuple matches a canonical item…
    // Return an Array of match results.
    // Each result will include the area in km² that the item is valid.
    //
    // Order of results:
    // Primary ordering will be on the "match" column:
    //   "primary" - where the query matches the `name` tag, followed by
    //   "alternate" - where the query matches an alternate name tag (e.g. short_name, brand, operator, etc)
    // Secondary ordering will be on the "area" column:
    //   "area descending" if no location was provided, (worldwide before local)
    //   "area ascending" if location was provided (local before worldwide)
    //
    // [
    //   { match: 'primary',   itemID: String,  area: Number,  kv: String,  nsimple: String },
    //   { match: 'primary',   itemID: String,  area: Number,  kv: String,  nsimple: String },
    //   { match: 'alternate', itemID: String,  area: Number,  kv: String,  nsimple: String },
    //   { match: 'alternate', itemID: String,  area: Number,  kv: String,  nsimple: String },
    //   …
    // ]
    //
    // -or-
    //
    // 2. If the [k,v,n] tuple matches an exclude pattern…
    // Return an Array with a single exclude result, either
    //
    // [ { match: 'excludeGeneric', pattern: String,  kv: String } ]  // "generic" e.g. "Food Court"
    //   or
    // [ { match: 'excludeNamed', pattern: String,  kv: String } ]    // "named", e.g. "Kebabai"
    //
    // About results
    //   "generic" - a generic word that is probably not really a name.
    //     For these, iD should warn the user "Hey don't put 'food court' in the name tag".
    //   "named" - a real name like "Kebabai" that is just common, but not a brand.
    //     For these, iD should just let it be. We don't include these in NSI, but we don't want to nag users about it either.
    //
    // -or-
    //
    // 3. If the [k,v,n] tuple matches nothing of any kind, return `null`
    //
    //
    match(k2, v2, n3, loc) {
      const that = this;
      if (!that.matchIndex) {
        throw new Error("match:  matchIndex not built.");
      }
      let matchLocations;
      if (Array.isArray(loc) && that.locationIndex) {
        matchLocations = that.locationIndex([loc[0], loc[1], loc[0], loc[1]], true);
      }
      const nsimple = simplify2(n3);
      let seen = /* @__PURE__ */ new Set();
      let results = [];
      gatherResults("primary");
      gatherResults("alternate");
      if (results.length)
        return results;
      gatherResults("exclude");
      return results.length ? results : null;
      function gatherResults(which) {
        const kv = "".concat(k2, "/").concat(v2);
        let didMatch = tryMatch(which, kv);
        if (didMatch)
          return;
        for (let mg in matchGroups) {
          const matchGroup = matchGroups[mg];
          const inGroup = matchGroup.some((otherkv) => otherkv === kv);
          if (!inGroup)
            continue;
          for (let i3 = 0; i3 < matchGroup.length; i3++) {
            const otherkv = matchGroup[i3];
            if (otherkv === kv)
              continue;
            didMatch = tryMatch(which, otherkv);
            if (didMatch)
              return;
          }
        }
        if (which === "exclude") {
          const regex = [...that.genericWords.values()].find((regex2) => regex2.test(n3));
          if (regex) {
            results.push({ match: "excludeGeneric", pattern: String(regex) });
            return;
          }
        }
      }
      function tryMatch(which, kv) {
        const branch = that.matchIndex.get(kv);
        if (!branch)
          return;
        if (which === "exclude") {
          let regex = [...branch.excludeNamed.values()].find((regex2) => regex2.test(n3));
          if (regex) {
            results.push({ match: "excludeNamed", pattern: String(regex), kv });
            return;
          }
          regex = [...branch.excludeGeneric.values()].find((regex2) => regex2.test(n3));
          if (regex) {
            results.push({ match: "excludeGeneric", pattern: String(regex), kv });
            return;
          }
          return;
        }
        const leaf = branch[which].get(nsimple);
        if (!leaf || !leaf.size)
          return;
        let hits = Array.from(leaf).map((itemID) => {
          let area = Infinity;
          if (that.itemLocation && that.locationSets) {
            const location = that.locationSets.get(that.itemLocation.get(itemID));
            area = location && location.properties.area || Infinity;
          }
          return { match: which, itemID, area, kv, nsimple };
        });
        let sortFn = byAreaDescending;
        if (matchLocations) {
          hits = hits.filter(isValidLocation);
          sortFn = byAreaAscending;
        }
        if (!hits.length)
          return;
        hits.sort(sortFn).forEach((hit) => {
          if (seen.has(hit.itemID))
            return;
          seen.add(hit.itemID);
          results.push(hit);
        });
        return true;
        function isValidLocation(hit) {
          if (!that.itemLocation)
            return true;
          return matchLocations.find((props) => props.id === that.itemLocation.get(hit.itemID));
        }
        function byAreaAscending(hitA, hitB) {
          return hitA.area - hitB.area;
        }
        function byAreaDescending(hitA, hitB) {
          return hitB.area - hitA.area;
        }
      }
    }
    //
    // `getWarnings()`
    // Return any warnings discovered when buiding the index.
    // (currently this does nothing)
    //
    getWarnings() {
      return this.warnings;
    }
  };

  // modules/services/nsi.js
  var import_vparse2 = __toESM(require_vparse());
  var _nsiStatus = "loading";
  var _nsi = {};
  var buildingPreset = {
    "building/commercial": true,
    "building/government": true,
    "building/hotel": true,
    "building/retail": true,
    "building/office": true,
    "building/supermarket": true,
    "building/yes": true
  };
  var notNames = /:(colou?r|type|forward|backward|left|right|etymology|pronunciation|wikipedia)$/i;
  var notBranches = /(coop|express|wireless|factory|outlet)/i;
  function setNsiSources() {
    const nsiVersion = package_default.dependencies["name-suggestion-index"] || package_default.devDependencies["name-suggestion-index"];
    const v2 = (0, import_vparse2.default)(nsiVersion);
    const vMinor = "".concat(v2.major, ".").concat(v2.minor);
    const cdn = nsiCdnUrl.replace("{version}", vMinor);
    const sources = {
      "nsi_data": cdn + "dist/nsi.min.json",
      "nsi_dissolved": cdn + "dist/dissolved.min.json",
      "nsi_features": cdn + "dist/featureCollection.min.json",
      "nsi_generics": cdn + "dist/genericWords.min.json",
      "nsi_presets": cdn + "dist/presets/nsi-id-presets.min.json",
      "nsi_replacements": cdn + "dist/replacements.min.json",
      "nsi_trees": cdn + "dist/trees.min.json"
    };
    let fileMap = _mainFileFetcher.fileMap();
    for (const k2 in sources) {
      if (!fileMap[k2])
        fileMap[k2] = sources[k2];
    }
  }
  function loadNsiPresets() {
    return Promise.all([
      _mainFileFetcher.get("nsi_presets"),
      _mainFileFetcher.get("nsi_features")
    ]).then((vals) => {
      Object.values(vals[0].presets).forEach((preset) => preset.suggestion = true);
      Object.values(vals[0].presets).forEach((preset) => {
        if (preset.tags["brand:wikidata"]) {
          preset.removeTags = { "brand:wikipedia": "*", ...preset.removeTags || preset.addTags || preset.tags };
        }
        if (preset.tags["operator:wikidata"]) {
          preset.removeTags = { "operator:wikipedia": "*", ...preset.removeTags || preset.addTags || preset.tags };
        }
        if (preset.tags["network:wikidata"]) {
          preset.removeTags = { "network:wikipedia": "*", ...preset.removeTags || preset.addTags || preset.tags };
        }
      });
      _mainPresetIndex.merge({
        presets: vals[0].presets,
        featureCollection: vals[1]
      });
    });
  }
  function loadNsiData() {
    return Promise.all([
      _mainFileFetcher.get("nsi_data"),
      _mainFileFetcher.get("nsi_dissolved"),
      _mainFileFetcher.get("nsi_replacements"),
      _mainFileFetcher.get("nsi_trees")
    ]).then((vals) => {
      _nsi = {
        data: vals[0].nsi,
        // the raw name-suggestion-index data
        dissolved: vals[1].dissolved,
        // list of dissolved items
        replacements: vals[2].replacements,
        // trivial old->new qid replacements
        trees: vals[3].trees,
        // metadata about trees, main tags
        kvt: /* @__PURE__ */ new Map(),
        // Map (k -> Map (v -> t) )
        qids: /* @__PURE__ */ new Map(),
        // Map (wd/wp tag values -> qids)
        ids: /* @__PURE__ */ new Map()
        // Map (id -> NSI item)
      };
      const matcher = _nsi.matcher = new Matcher();
      matcher.buildMatchIndex(_nsi.data);
      matcher.itemLocation = /* @__PURE__ */ new Map();
      matcher.locationSets = /* @__PURE__ */ new Map();
      Object.keys(_nsi.data).forEach((tkv) => {
        const items = _nsi.data[tkv].items;
        if (!Array.isArray(items) || !items.length)
          return;
        items.forEach((item) => {
          if (matcher.itemLocation.has(item.id))
            return;
          const locationSetID = _sharedLocationManager.locationSetID(item.locationSet);
          matcher.itemLocation.set(item.id, locationSetID);
          if (matcher.locationSets.has(locationSetID))
            return;
          const fakeFeature = { id: locationSetID, properties: { id: locationSetID, area: 1 } };
          matcher.locationSets.set(locationSetID, fakeFeature);
        });
      });
      matcher.locationIndex = (bbox2) => {
        const validHere = _sharedLocationManager.locationSetsAt([bbox2[0], bbox2[1]]);
        const results = [];
        for (const [locationSetID, area] of Object.entries(validHere)) {
          const fakeFeature = matcher.locationSets.get(locationSetID);
          if (fakeFeature) {
            fakeFeature.properties.area = area;
            results.push(fakeFeature);
          }
        }
        return results;
      };
      Object.keys(_nsi.data).forEach((tkv) => {
        const category = _nsi.data[tkv];
        const parts = tkv.split("/", 3);
        const t2 = parts[0];
        const k2 = parts[1];
        const v2 = parts[2];
        let vmap = _nsi.kvt.get(k2);
        if (!vmap) {
          vmap = /* @__PURE__ */ new Map();
          _nsi.kvt.set(k2, vmap);
        }
        vmap.set(v2, t2);
        const tree = _nsi.trees[t2];
        const mainTag = tree.mainTag;
        const items = category.items || [];
        items.forEach((item) => {
          item.tkv = tkv;
          item.mainTag = mainTag;
          _nsi.ids.set(item.id, item);
          const wd = item.tags[mainTag];
          const wp = item.tags[mainTag.replace("wikidata", "wikipedia")];
          if (wd)
            _nsi.qids.set(wd, wd);
          if (wp && wd)
            _nsi.qids.set(wp, wd);
        });
      });
    });
  }
  function gatherKVs(tags) {
    let primary = /* @__PURE__ */ new Set();
    let alternate = /* @__PURE__ */ new Set();
    Object.keys(tags).forEach((osmkey) => {
      const osmvalue = tags[osmkey];
      if (!osmvalue)
        return;
      if (osmkey === "route_master")
        osmkey = "route";
      const vmap = _nsi.kvt.get(osmkey);
      if (!vmap)
        return;
      if (vmap.get(osmvalue)) {
        primary.add("".concat(osmkey, "/").concat(osmvalue));
      } else if (osmvalue === "yes") {
        alternate.add("".concat(osmkey, "/").concat(osmvalue));
      }
    });
    const preset = _mainPresetIndex.matchTags(tags, "area");
    if (buildingPreset[preset.id]) {
      alternate.add("building/yes");
    }
    return { primary, alternate };
  }
  function identifyTree(tags) {
    let unknown;
    let t2;
    Object.keys(tags).forEach((osmkey) => {
      if (t2)
        return;
      const osmvalue = tags[osmkey];
      if (!osmvalue)
        return;
      if (osmkey === "route_master")
        osmkey = "route";
      const vmap = _nsi.kvt.get(osmkey);
      if (!vmap)
        return;
      if (osmvalue === "yes") {
        unknown = "unknown";
      } else {
        t2 = vmap.get(osmvalue);
      }
    });
    return t2 || unknown || null;
  }
  function gatherNames(tags) {
    const empty2 = { primary: /* @__PURE__ */ new Set(), alternate: /* @__PURE__ */ new Set() };
    let primary = /* @__PURE__ */ new Set();
    let alternate = /* @__PURE__ */ new Set();
    let foundSemi = false;
    let testNameFragments = false;
    let patterns2;
    let t2 = identifyTree(tags);
    if (!t2)
      return empty2;
    if (t2 === "transit") {
      patterns2 = {
        primary: /^network$/i,
        alternate: /^(operator|operator:\w+|network:\w+|\w+_name|\w+_name:\w+)$/i
      };
    } else if (t2 === "flags") {
      patterns2 = {
        primary: /^(flag:name|flag:name:\w+)$/i,
        alternate: /^(flag|flag:\w+|subject|subject:\w+)$/i
        // note: no `country`, we special-case it below
      };
    } else if (t2 === "brands") {
      testNameFragments = true;
      patterns2 = {
        primary: /^(name|name:\w+)$/i,
        alternate: /^(brand|brand:\w+|operator|operator:\w+|\w+_name|\w+_name:\w+)/i
      };
    } else if (t2 === "operators") {
      testNameFragments = true;
      patterns2 = {
        primary: /^(name|name:\w+|operator|operator:\w+)$/i,
        alternate: /^(brand|brand:\w+|\w+_name|\w+_name:\w+)/i
      };
    } else {
      testNameFragments = true;
      patterns2 = {
        primary: /^(name|name:\w+)$/i,
        alternate: /^(brand|brand:\w+|network|network:\w+|operator|operator:\w+|\w+_name|\w+_name:\w+)/i
      };
    }
    if (tags.name && testNameFragments) {
      const nameParts = tags.name.split(/[\s\-\/,.]/);
      for (let split = nameParts.length; split > 0; split--) {
        const name = nameParts.slice(0, split).join(" ");
        primary.add(name);
      }
    }
    Object.keys(tags).forEach((osmkey) => {
      const osmvalue = tags[osmkey];
      if (!osmvalue)
        return;
      if (isNamelike(osmkey, "primary")) {
        if (/;/.test(osmvalue)) {
          foundSemi = true;
        } else {
          primary.add(osmvalue);
          alternate.delete(osmvalue);
        }
      } else if (!primary.has(osmvalue) && isNamelike(osmkey, "alternate")) {
        if (/;/.test(osmvalue)) {
          foundSemi = true;
        } else {
          alternate.add(osmvalue);
        }
      }
    });
    if (tags.man_made === "flagpole" && !primary.size && !alternate.size && !!tags.country) {
      const osmvalue = tags.country;
      if (/;/.test(osmvalue)) {
        foundSemi = true;
      } else {
        alternate.add(osmvalue);
      }
    }
    if (foundSemi) {
      return empty2;
    } else {
      return { primary, alternate };
    }
    function isNamelike(osmkey, which) {
      if (osmkey === "old_name")
        return false;
      return patterns2[which].test(osmkey) && !notNames.test(osmkey);
    }
  }
  function gatherTuples(tryKVs, tryNames) {
    let tuples = [];
    ["primary", "alternate"].forEach((whichName) => {
      const arr = Array.from(tryNames[whichName]).sort((a2, b2) => b2.length - a2.length);
      arr.forEach((n3) => {
        ["primary", "alternate"].forEach((whichKV) => {
          tryKVs[whichKV].forEach((kv) => {
            const parts = kv.split("/", 2);
            const k2 = parts[0];
            const v2 = parts[1];
            tuples.push({ k: k2, v: v2, n: n3 });
          });
        });
      });
    });
    return tuples;
  }
  function _upgradeTags(tags, loc) {
    let newTags = Object.assign({}, tags);
    let changed = false;
    Object.keys(newTags).forEach((osmkey) => {
      const matchTag = osmkey.match(/^(\w+:)?wikidata$/);
      if (matchTag) {
        const prefix = matchTag[1] || "";
        const wd = newTags[osmkey];
        const replace = _nsi.replacements[wd];
        if (replace && replace.wikidata !== void 0) {
          changed = true;
          if (replace.wikidata) {
            newTags[osmkey] = replace.wikidata;
          } else {
            delete newTags[osmkey];
          }
        }
        if (replace && replace.wikipedia !== void 0) {
          changed = true;
          const wpkey = "".concat(prefix, "wikipedia");
          if (replace.wikipedia) {
            newTags[wpkey] = replace.wikipedia;
          } else {
            delete newTags[wpkey];
          }
        }
      }
    });
    const isRouteMaster = tags.type === "route_master";
    const tryKVs = gatherKVs(tags);
    if (!tryKVs.primary.size && !tryKVs.alternate.size) {
      return changed ? { newTags, matched: null } : null;
    }
    const tryNames = gatherNames(tags);
    const foundQID = _nsi.qids.get(tags.wikidata) || _nsi.qids.get(tags.wikipedia);
    if (foundQID)
      tryNames.primary.add(foundQID);
    if (!tryNames.primary.size && !tryNames.alternate.size) {
      return changed ? { newTags, matched: null } : null;
    }
    const tuples = gatherTuples(tryKVs, tryNames);
    for (let i3 = 0; i3 < tuples.length; i3++) {
      const tuple = tuples[i3];
      const hits = _nsi.matcher.match(tuple.k, tuple.v, tuple.n, loc);
      if (!hits || !hits.length)
        continue;
      if (hits[0].match !== "primary" && hits[0].match !== "alternate")
        break;
      let itemID, item;
      for (let j2 = 0; j2 < hits.length; j2++) {
        const hit = hits[j2];
        itemID = hit.itemID;
        if (_nsi.dissolved[itemID])
          continue;
        item = _nsi.ids.get(itemID);
        if (!item)
          continue;
        const mainTag = item.mainTag;
        const itemQID = item.tags[mainTag];
        const notQID = newTags["not:".concat(mainTag)];
        if (
          // Exceptions, skip this hit
          !itemQID || itemQID === notQID || // No `*:wikidata` or matched a `not:*:wikidata`
          newTags.office && !item.tags.office
        ) {
          item = null;
          continue;
        } else {
          break;
        }
      }
      if (!item)
        continue;
      item = JSON.parse(JSON.stringify(item));
      const tkv = item.tkv;
      const parts = tkv.split("/", 3);
      const k2 = parts[1];
      const v2 = parts[2];
      const category = _nsi.data[tkv];
      const properties = category.properties || {};
      let preserveTags = item.preserveTags || properties.preserveTags || [];
      ["building", "emergency", "internet_access", "takeaway"].forEach((osmkey) => {
        if (k2 !== osmkey)
          preserveTags.push("^".concat(osmkey, "$"));
      });
      const regexes = preserveTags.map((s2) => new RegExp(s2, "i"));
      let keepTags = {};
      Object.keys(newTags).forEach((osmkey) => {
        if (regexes.some((regex) => regex.test(osmkey))) {
          keepTags[osmkey] = newTags[osmkey];
        }
      });
      _nsi.kvt.forEach((vmap, k3) => {
        if (newTags[k3] === "yes")
          delete newTags[k3];
      });
      if (foundQID) {
        delete newTags.wikipedia;
        delete newTags.wikidata;
      }
      Object.assign(newTags, item.tags, keepTags);
      if (isRouteMaster) {
        newTags.route_master = newTags.route;
        delete newTags.route;
      }
      const origName = tags.name;
      const newName = newTags.name;
      if (newName && origName && newName !== origName && !newTags.branch) {
        const newNames = gatherNames(newTags);
        const newSet = /* @__PURE__ */ new Set([...newNames.primary, ...newNames.alternate]);
        const isMoved = newSet.has(origName);
        if (!isMoved) {
          const nameParts = origName.split(/[\s\-\/,.]/);
          for (let split = nameParts.length; split > 0; split--) {
            const name = nameParts.slice(0, split).join(" ");
            const branch = nameParts.slice(split).join(" ");
            const nameHits = _nsi.matcher.match(k2, v2, name, loc);
            if (!nameHits || !nameHits.length)
              continue;
            if (nameHits.some((hit) => hit.itemID === itemID)) {
              if (branch) {
                if (notBranches.test(branch)) {
                  newTags.name = origName;
                } else {
                  const branchHits = _nsi.matcher.match(k2, v2, branch, loc);
                  if (branchHits && branchHits.length) {
                    if (branchHits[0].match === "primary" || branchHits[0].match === "alternate") {
                      return null;
                    }
                  } else {
                    newTags.branch = branch;
                  }
                }
              }
              break;
            }
          }
        }
      }
      return { newTags, matched: item };
    }
    return changed ? { newTags, matched: null } : null;
  }
  function _isGenericName(tags) {
    const n3 = tags.name;
    if (!n3)
      return false;
    const tryNames = { primary: /* @__PURE__ */ new Set([n3]), alternate: /* @__PURE__ */ new Set() };
    const tryKVs = gatherKVs(tags);
    if (!tryKVs.primary.size && !tryKVs.alternate.size)
      return false;
    const tuples = gatherTuples(tryKVs, tryNames);
    for (let i3 = 0; i3 < tuples.length; i3++) {
      const tuple = tuples[i3];
      const hits = _nsi.matcher.match(tuple.k, tuple.v, tuple.n);
      if (hits && hits.length && hits[0].match === "excludeGeneric")
        return true;
    }
    return false;
  }
  var nsi_default = {
    // `init()`
    // On init, start preparing the name-suggestion-index
    //
    init: () => {
      setNsiSources();
      _mainPresetIndex.ensureLoaded().then(() => loadNsiPresets()).then(() => loadNsiData()).then(() => _nsiStatus = "ok").catch(() => _nsiStatus = "failed");
    },
    // `reset()`
    // Reset is called when user saves data to OSM (does nothing here)
    //
    reset: () => {
    },
    // `status()`
    // To let other code know how it's going...
    //
    // Returns
    //   `String`: 'loading', 'ok', 'failed'
    //
    status: () => _nsiStatus,
    // `isGenericName()`
    // Is the `name` tag generic?
    //
    // Arguments
    //   `tags`: `Object` containing the feature's OSM tags
    // Returns
    //   `true` if it is generic, `false` if not
    //
    isGenericName: (tags) => _isGenericName(tags),
    // `upgradeTags()`
    // Suggest tag upgrades.
    // This function will not modify the input tags, it makes a copy.
    //
    // Arguments
    //   `tags`: `Object` containing the feature's OSM tags
    //   `loc`: Location where this feature exists, as a [lon, lat]
    // Returns
    //   `Object` containing the result, or `null` if no changes needed:
    //   {
    //     'newTags': `Object` - The tags the the feature should have
    //     'matched': `Object` - The matched item
    //   }
    //
    upgradeTags: (tags, loc) => _upgradeTags(tags, loc),
    // `cache()`
    // Direct access to the NSI cache, useful for testing or breaking things
    //
    // Returns
    //   `Object`: the internal NSI cache
    //
    cache: () => _nsi
  };

  // modules/services/kartaview.js
  var import_rbush8 = __toESM(require_rbush_min());
  var apibase2 = "https://kartaview.org";
  var maxResults = 1e3;
  var tileZoom = 14;
  var tiler4 = utilTiler().zoomExtent([tileZoom, tileZoom]).skipNullIsland(true);
  var dispatch7 = dispatch_default("loadedImages");
  var imgZoom2 = zoom_default2().extent([[0, 0], [320, 240]]).translateExtent([[0, 0], [320, 240]]).scaleExtent([1, 15]);
  var _oscCache;
  var _oscSelectedImage;
  var _loadViewerPromise2;
  function abortRequest4(controller) {
    controller.abort();
  }
  function maxPageAtZoom(z2) {
    if (z2 < 15)
      return 2;
    if (z2 === 15)
      return 5;
    if (z2 === 16)
      return 10;
    if (z2 === 17)
      return 20;
    if (z2 === 18)
      return 40;
    if (z2 > 18)
      return 80;
  }
  function loadTiles2(which, url, projection2) {
    var currZoom = Math.floor(geoScaleToZoom(projection2.scale()));
    var tiles = tiler4.getTiles(projection2);
    var cache = _oscCache[which];
    Object.keys(cache.inflight).forEach(function(k2) {
      var wanted = tiles.find(function(tile) {
        return k2.indexOf(tile.id + ",") === 0;
      });
      if (!wanted) {
        abortRequest4(cache.inflight[k2]);
        delete cache.inflight[k2];
      }
    });
    tiles.forEach(function(tile) {
      loadNextTilePage(which, currZoom, url, tile);
    });
  }
  function loadNextTilePage(which, currZoom, url, tile) {
    var cache = _oscCache[which];
    var bbox2 = tile.extent.bbox();
    var maxPages = maxPageAtZoom(currZoom);
    var nextPage = cache.nextPage[tile.id] || 1;
    var params = utilQsString({
      ipp: maxResults,
      page: nextPage,
      // client_id: clientId,
      bbTopLeft: [bbox2.maxY, bbox2.minX].join(","),
      bbBottomRight: [bbox2.minY, bbox2.maxX].join(",")
    }, true);
    if (nextPage > maxPages)
      return;
    var id2 = tile.id + "," + String(nextPage);
    if (cache.loaded[id2] || cache.inflight[id2])
      return;
    var controller = new AbortController();
    cache.inflight[id2] = controller;
    var options2 = {
      method: "POST",
      signal: controller.signal,
      body: params,
      headers: { "Content-Type": "application/x-www-form-urlencoded" }
    };
    json_default(url, options2).then(function(data) {
      cache.loaded[id2] = true;
      delete cache.inflight[id2];
      if (!data || !data.currentPageItems || !data.currentPageItems.length) {
        throw new Error("No Data");
      }
      var features = data.currentPageItems.map(function(item) {
        var loc = [+item.lng, +item.lat];
        var d2;
        if (which === "images") {
          d2 = {
            loc,
            key: item.id,
            ca: +item.heading,
            captured_at: item.shot_date || item.date_added,
            captured_by: item.username,
            imagePath: item.lth_name,
            sequence_id: item.sequence_id,
            sequence_index: +item.sequence_index
          };
          var seq = _oscCache.sequences[d2.sequence_id];
          if (!seq) {
            seq = { rotation: 0, images: [] };
            _oscCache.sequences[d2.sequence_id] = seq;
          }
          seq.images[d2.sequence_index] = d2;
          _oscCache.images.forImageKey[d2.key] = d2;
        }
        return {
          minX: loc[0],
          minY: loc[1],
          maxX: loc[0],
          maxY: loc[1],
          data: d2
        };
      });
      cache.rtree.load(features);
      if (data.currentPageItems.length === maxResults) {
        cache.nextPage[tile.id] = nextPage + 1;
        loadNextTilePage(which, currZoom, url, tile);
      } else {
        cache.nextPage[tile.id] = Infinity;
      }
      if (which === "images") {
        dispatch7.call("loadedImages");
      }
    }).catch(function() {
      cache.loaded[id2] = true;
      delete cache.inflight[id2];
    });
  }
  function partitionViewport2(projection2) {
    var z2 = geoScaleToZoom(projection2.scale());
    var z22 = Math.ceil(z2 * 2) / 2 + 2.5;
    var tiler9 = utilTiler().zoomExtent([z22, z22]);
    return tiler9.getTiles(projection2).map(function(tile) {
      return tile.extent;
    });
  }
  function searchLimited2(limit, projection2, rtree) {
    limit = limit || 5;
    return partitionViewport2(projection2).reduce(function(result, extent) {
      var found = rtree.search(extent.bbox()).slice(0, limit).map(function(d2) {
        return d2.data;
      });
      return found.length ? result.concat(found) : result;
    }, []);
  }
  var kartaview_default = {
    init: function() {
      if (!_oscCache) {
        this.reset();
      }
      this.event = utilRebind(this, dispatch7, "on");
    },
    reset: function() {
      if (_oscCache) {
        Object.values(_oscCache.images.inflight).forEach(abortRequest4);
      }
      _oscCache = {
        images: { inflight: {}, loaded: {}, nextPage: {}, rtree: new import_rbush8.default(), forImageKey: {} },
        sequences: {}
      };
      _oscSelectedImage = null;
    },
    images: function(projection2) {
      var limit = 5;
      return searchLimited2(limit, projection2, _oscCache.images.rtree);
    },
    sequences: function(projection2) {
      var viewport = projection2.clipExtent();
      var min3 = [viewport[0][0], viewport[1][1]];
      var max3 = [viewport[1][0], viewport[0][1]];
      var bbox2 = geoExtent(projection2.invert(min3), projection2.invert(max3)).bbox();
      var sequenceKeys = {};
      _oscCache.images.rtree.search(bbox2).forEach(function(d2) {
        sequenceKeys[d2.data.sequence_id] = true;
      });
      var lineStrings = [];
      Object.keys(sequenceKeys).forEach(function(sequenceKey) {
        var seq = _oscCache.sequences[sequenceKey];
        var images = seq && seq.images;
        if (images) {
          lineStrings.push({
            type: "LineString",
            coordinates: images.map(function(d2) {
              return d2.loc;
            }).filter(Boolean),
            properties: {
              captured_at: images[0] ? images[0].captured_at : null,
              captured_by: images[0] ? images[0].captured_by : null,
              key: sequenceKey
            }
          });
        }
      });
      return lineStrings;
    },
    cachedImage: function(imageKey) {
      return _oscCache.images.forImageKey[imageKey];
    },
    loadImages: function(projection2) {
      var url = apibase2 + "/1.0/list/nearby-photos/";
      loadTiles2("images", url, projection2);
    },
    ensureViewerLoaded: function(context) {
      if (_loadViewerPromise2)
        return _loadViewerPromise2;
      var wrap2 = context.container().select(".photoviewer").selectAll(".kartaview-wrapper").data([0]);
      var that = this;
      var wrapEnter = wrap2.enter().append("div").attr("class", "photo-wrapper kartaview-wrapper").classed("hide", true).call(imgZoom2.on("zoom", zoomPan2)).on("dblclick.zoom", null);
      wrapEnter.append("div").attr("class", "photo-attribution fillD");
      var controlsEnter = wrapEnter.append("div").attr("class", "photo-controls-wrap").append("div").attr("class", "photo-controls");
      controlsEnter.append("button").on("click.back", step(-1)).text("\u25C4");
      controlsEnter.append("button").on("click.rotate-ccw", rotate(-90)).text("\u293F");
      controlsEnter.append("button").on("click.rotate-cw", rotate(90)).text("\u293E");
      controlsEnter.append("button").on("click.forward", step(1)).text("\u25BA");
      wrapEnter.append("div").attr("class", "kartaview-image-wrap");
      context.ui().photoviewer.on("resize.kartaview", function(dimensions) {
        imgZoom2.extent([[0, 0], dimensions]).translateExtent([[0, 0], dimensions]);
      });
      function zoomPan2(d3_event) {
        var t2 = d3_event.transform;
        context.container().select(".photoviewer .kartaview-image-wrap").call(utilSetTransform, t2.x, t2.y, t2.k);
      }
      function rotate(deg) {
        return function() {
          if (!_oscSelectedImage)
            return;
          var sequenceKey = _oscSelectedImage.sequence_id;
          var sequence = _oscCache.sequences[sequenceKey];
          if (!sequence)
            return;
          var r2 = sequence.rotation || 0;
          r2 += deg;
          if (r2 > 180)
            r2 -= 360;
          if (r2 < -180)
            r2 += 360;
          sequence.rotation = r2;
          var wrap3 = context.container().select(".photoviewer .kartaview-wrapper");
          wrap3.transition().duration(100).call(imgZoom2.transform, identity2);
          wrap3.selectAll(".kartaview-image").transition().duration(100).style("transform", "rotate(" + r2 + "deg)");
        };
      }
      function step(stepBy) {
        return function() {
          if (!_oscSelectedImage)
            return;
          var sequenceKey = _oscSelectedImage.sequence_id;
          var sequence = _oscCache.sequences[sequenceKey];
          if (!sequence)
            return;
          var nextIndex = _oscSelectedImage.sequence_index + stepBy;
          var nextImage = sequence.images[nextIndex];
          if (!nextImage)
            return;
          context.map().centerEase(nextImage.loc);
          that.selectImage(context, nextImage.key);
        };
      }
      _loadViewerPromise2 = Promise.resolve();
      return _loadViewerPromise2;
    },
    showViewer: function(context) {
      var viewer = context.container().select(".photoviewer").classed("hide", false);
      var isHidden = viewer.selectAll(".photo-wrapper.kartaview-wrapper.hide").size();
      if (isHidden) {
        viewer.selectAll(".photo-wrapper:not(.kartaview-wrapper)").classed("hide", true);
        viewer.selectAll(".photo-wrapper.kartaview-wrapper").classed("hide", false);
      }
      return this;
    },
    hideViewer: function(context) {
      _oscSelectedImage = null;
      this.updateUrlImage(null);
      var viewer = context.container().select(".photoviewer");
      if (!viewer.empty())
        viewer.datum(null);
      viewer.classed("hide", true).selectAll(".photo-wrapper").classed("hide", true);
      context.container().selectAll(".viewfield-group, .sequence, .icon-sign").classed("currentView", false);
      return this.setStyles(context, null, true);
    },
    selectImage: function(context, imageKey) {
      var d2 = this.cachedImage(imageKey);
      _oscSelectedImage = d2;
      this.updateUrlImage(imageKey);
      var viewer = context.container().select(".photoviewer");
      if (!viewer.empty())
        viewer.datum(d2);
      this.setStyles(context, null, true);
      context.container().selectAll(".icon-sign").classed("currentView", false);
      if (!d2)
        return this;
      var wrap2 = context.container().select(".photoviewer .kartaview-wrapper");
      var imageWrap = wrap2.selectAll(".kartaview-image-wrap");
      var attribution = wrap2.selectAll(".photo-attribution").text("");
      wrap2.transition().duration(100).call(imgZoom2.transform, identity2);
      imageWrap.selectAll(".kartaview-image").remove();
      if (d2) {
        var sequence = _oscCache.sequences[d2.sequence_id];
        var r2 = sequence && sequence.rotation || 0;
        imageWrap.append("img").attr("class", "kartaview-image").attr("src", apibase2 + "/" + d2.imagePath).style("transform", "rotate(" + r2 + "deg)");
        if (d2.captured_by) {
          attribution.append("a").attr("class", "captured_by").attr("target", "_blank").attr("href", "https://kartaview.org/user/" + encodeURIComponent(d2.captured_by)).text("@" + d2.captured_by);
          attribution.append("span").text("|");
        }
        if (d2.captured_at) {
          attribution.append("span").attr("class", "captured_at").text(localeDateString2(d2.captured_at));
          attribution.append("span").text("|");
        }
        attribution.append("a").attr("class", "image-link").attr("target", "_blank").attr("href", "https://kartaview.org/details/" + d2.sequence_id + "/" + d2.sequence_index).text("kartaview.org");
      }
      return this;
      function localeDateString2(s2) {
        if (!s2)
          return null;
        var options2 = { day: "numeric", month: "short", year: "numeric" };
        var d4 = new Date(s2);
        if (isNaN(d4.getTime()))
          return null;
        return d4.toLocaleDateString(_mainLocalizer.localeCode(), options2);
      }
    },
    getSelectedImage: function() {
      return _oscSelectedImage;
    },
    getSequenceKeyForImage: function(d2) {
      return d2 && d2.sequence_id;
    },
    // Updates the currently highlighted sequence and selected bubble.
    // Reset is only necessary when interacting with the viewport because
    // this implicitly changes the currently selected bubble/sequence
    setStyles: function(context, hovered, reset) {
      if (reset) {
        context.container().selectAll(".viewfield-group").classed("highlighted", false).classed("hovered", false).classed("currentView", false);
        context.container().selectAll(".sequence").classed("highlighted", false).classed("currentView", false);
      }
      var hoveredImageKey = hovered && hovered.key;
      var hoveredSequenceKey = this.getSequenceKeyForImage(hovered);
      var hoveredSequence = hoveredSequenceKey && _oscCache.sequences[hoveredSequenceKey];
      var hoveredImageKeys = hoveredSequence && hoveredSequence.images.map(function(d2) {
        return d2.key;
      }) || [];
      var viewer = context.container().select(".photoviewer");
      var selected = viewer.empty() ? void 0 : viewer.datum();
      var selectedImageKey = selected && selected.key;
      var selectedSequenceKey = this.getSequenceKeyForImage(selected);
      var selectedSequence = selectedSequenceKey && _oscCache.sequences[selectedSequenceKey];
      var selectedImageKeys = selectedSequence && selectedSequence.images.map(function(d2) {
        return d2.key;
      }) || [];
      var highlightedImageKeys = utilArrayUnion(hoveredImageKeys, selectedImageKeys);
      context.container().selectAll(".layer-kartaview .viewfield-group").classed("highlighted", function(d2) {
        return highlightedImageKeys.indexOf(d2.key) !== -1;
      }).classed("hovered", function(d2) {
        return d2.key === hoveredImageKey;
      }).classed("currentView", function(d2) {
        return d2.key === selectedImageKey;
      });
      context.container().selectAll(".layer-kartaview .sequence").classed("highlighted", function(d2) {
        return d2.properties.key === hoveredSequenceKey;
      }).classed("currentView", function(d2) {
        return d2.properties.key === selectedSequenceKey;
      });
      context.container().selectAll(".layer-kartaview .viewfield-group .viewfield").attr("d", viewfieldPath);
      function viewfieldPath() {
        var d2 = this.parentNode.__data__;
        if (d2.pano && d2.key !== selectedImageKey) {
          return "M 8,13 m -10,0 a 10,10 0 1,0 20,0 a 10,10 0 1,0 -20,0";
        } else {
          return "M 6,9 C 8,8.4 8,8.4 10,9 L 16,-2 C 12,-5 4,-5 0,-2 z";
        }
      }
      return this;
    },
    updateUrlImage: function(imageKey) {
      if (!window.mocha) {
        var hash = utilStringQs(window.location.hash);
        if (imageKey) {
          hash.photo = "kartaview/" + imageKey;
        } else {
          delete hash.photo;
        }
        window.location.replace("#" + utilQsString(hash, true));
      }
    },
    cache: function() {
      return _oscCache;
    }
  };

  // modules/services/vegbilder.js
  var import_rbush9 = __toESM(require_rbush_min());

  // modules/services/pannellum_photo.js
  var pannellumViewerCSS = "pannellum/pannellum.css";
  var pannellumViewerJS = "pannellum/pannellum.js";
  var dispatch8 = dispatch_default("viewerChanged");
  var _currScenes = [];
  var _pannellumViewer;
  var pannellum_photo_default = {
    init: async function(context, selection2) {
      selection2.append("div").attr("class", "photo-frame pannellum-frame").attr("id", "ideditor-pannellum-viewer").classed("hide", true);
      if (!window.pannellum) {
        await this.loadPannellum(context);
      }
      const options2 = {
        "default": { firstScene: "" },
        scenes: {}
      };
      _pannellumViewer = window.pannellum.viewer("ideditor-pannellum-viewer", options2);
      _pannellumViewer.on("mousedown", () => {
        select_default2(window).on("pointermove.pannellum mousemove.pannellum", () => {
          dispatch8.call("viewerChanged");
        });
      }).on("mouseup", () => {
        select_default2(window).on("pointermove.pannellum mousemove.pannellum", null);
      }).on("animatefinished", () => {
        dispatch8.call("viewerChanged");
      });
      context.ui().photoviewer.on("resize.pannellum", () => {
        _pannellumViewer.resize();
      });
      this.event = utilRebind(this, dispatch8, "on");
      return this;
    },
    loadPannellum: function(context) {
      const head = select_default2("head");
      return Promise.all([
        new Promise((resolve, reject) => {
          head.selectAll("#ideditor-pannellum-viewercss").data([0]).enter().append("link").attr("id", "ideditor-pannellum-viewercss").attr("rel", "stylesheet").attr("crossorigin", "anonymous").attr("href", context.asset(pannellumViewerCSS)).on("load.pannellum", resolve).on("error.pannellum", reject);
        }),
        new Promise((resolve, reject) => {
          head.selectAll("#ideditor-pannellum-viewerjs").data([0]).enter().append("script").attr("id", "ideditor-pannellum-viewerjs").attr("crossorigin", "anonymous").attr("src", context.asset(pannellumViewerJS)).on("load.pannellum", resolve).on("error.pannellum", reject);
        })
      ]);
    },
    showPhotoFrame: function(context) {
      const isHidden = context.selectAll(".photo-frame.pannellum-frame.hide").size();
      if (isHidden) {
        context.selectAll(".photo-frame:not(.pannellum-frame)").classed("hide", true);
        context.selectAll(".photo-frame.pannellum-frame").classed("hide", false);
      }
      return this;
    },
    hidePhotoFrame: function(viewerContext) {
      viewerContext.select("photo-frame.pannellum-frame").classed("hide", false);
      return this;
    },
    selectPhoto: function(data, keepOrientation) {
      const { key } = data;
      if (!(key in _currScenes)) {
        let newSceneOptions = {
          showFullscreenCtrl: false,
          autoLoad: false,
          compass: true,
          yaw: 0,
          type: "equirectangular",
          preview: data.preview_path,
          panorama: data.image_path,
          northOffset: data.ca
        };
        _currScenes.push(key);
        _pannellumViewer.addScene(key, newSceneOptions);
      }
      let yaw = 0;
      let pitch = 0;
      if (keepOrientation) {
        yaw = this.getYaw();
        pitch = _pannellumViewer.getPitch();
      }
      _pannellumViewer.loadScene(key, pitch, yaw);
      dispatch8.call("viewerChanged");
      if (_currScenes.length > 3) {
        const old_key = _currScenes.shift();
        _pannellumViewer.removeScene(old_key);
      }
      return this;
    },
    getYaw: function() {
      return _pannellumViewer.getYaw();
    }
  };

  // modules/services/vegbilder.js
  var owsEndpoint = "https://www.vegvesen.no/kart/ogc/vegbilder_1_0/ows?";
  var tileZoom2 = 14;
  var tiler5 = utilTiler().zoomExtent([tileZoom2, tileZoom2]).skipNullIsland(true);
  var dispatch9 = dispatch_default("loadedImages", "viewerChanged");
  var directionEnum = Object.freeze({
    forward: Symbol(0),
    backward: Symbol(1)
  });
  var _planeFrame;
  var _pannellumFrame;
  var _currentFrame;
  var _loadViewerPromise3;
  var _vegbilderCache;
  async function fetchAvailableLayers() {
    var _a2, _b, _c;
    const params = {
      service: "WFS",
      request: "GetCapabilities",
      version: "2.0.0"
    };
    const urlForRequest = owsEndpoint + utilQsString(params);
    const response = await xml_default(urlForRequest);
    const xPathSelector = "/wfs:WFS_Capabilities/wfs:FeatureTypeList/wfs:FeatureType/wfs:Name";
    const regexMatcher = /^vegbilder_1_0:Vegbilder(?<image_type>_360)?_(?<year>\d{4})$/;
    const NSResolver = response.createNSResolver(response);
    const l2 = response.evaluate(
      xPathSelector,
      response,
      NSResolver,
      XPathResult.ANY_TYPE
    );
    let node;
    const availableLayers = [];
    while ((node = l2.iterateNext()) !== null) {
      const match = (_a2 = node.textContent) == null ? void 0 : _a2.match(regexMatcher);
      if (match) {
        availableLayers.push({
          name: match[0],
          is_sphere: !!((_b = match.groups) == null ? void 0 : _b.image_type),
          year: parseInt((_c = match.groups) == null ? void 0 : _c.year, 10)
        });
      }
    }
    return availableLayers;
  }
  function filterAvailableLayers(photoContex) {
    const fromDateString = photoContex.fromDate();
    const toDateString = photoContex.toDate();
    const fromYear = fromDateString ? new Date(fromDateString).getFullYear() : 2016;
    const toYear = toDateString ? new Date(toDateString).getFullYear() : null;
    const showsFlat = photoContex.showsFlat();
    const showsPano = photoContex.showsPanoramic();
    return Array.from(_vegbilderCache.wfslayers.values()).filter(({ layerInfo }) => layerInfo.year >= fromYear && (!toYear || layerInfo.year <= toYear) && (!layerInfo.is_sphere && showsFlat || layerInfo.is_sphere && showsPano));
  }
  function loadWFSLayers(projection2, margin, wfslayers) {
    const tiles = tiler5.margin(margin).getTiles(projection2);
    for (const cache of wfslayers) {
      loadWFSLayer(projection2, cache, tiles);
    }
  }
  function loadWFSLayer(projection2, cache, tiles) {
    for (const [key, controller] of cache.inflight.entries()) {
      const wanted = tiles.some((tile) => key === tile.id);
      if (!wanted) {
        controller.abort();
        cache.inflight.delete(key);
      }
    }
    Promise.all(tiles.map(
      (tile) => loadTile2(cache, cache.layerInfo.name, tile)
    )).then(() => orderSequences(projection2, cache));
  }
  async function loadTile2(cache, typename, tile) {
    const bbox2 = tile.extent.bbox();
    const tileid = tile.id;
    if (cache.loaded.get(tileid) === true || cache.inflight.has(tileid))
      return;
    const params = {
      service: "WFS",
      request: "GetFeature",
      version: "2.0.0",
      typenames: typename,
      bbox: [bbox2.minY, bbox2.minX, bbox2.maxY, bbox2.maxX].join(","),
      outputFormat: "json"
    };
    const controller = new AbortController();
    cache.inflight.set(tileid, controller);
    const options2 = {
      method: "GET",
      signal: controller.signal
    };
    const urlForRequest = owsEndpoint + utilQsString(params);
    let featureCollection;
    try {
      featureCollection = await json_default(urlForRequest, options2);
    } catch {
      cache.loaded.set(tileid, false);
      return;
    } finally {
      cache.inflight.delete(tileid);
    }
    cache.loaded.set(tileid, true);
    if (featureCollection.features.length === 0) {
      return;
    }
    const features = featureCollection.features.map((feature3) => {
      const loc = feature3.geometry.coordinates;
      const key = feature3.id;
      const properties = feature3.properties;
      const {
        RETNING: ca,
        TIDSPUNKT: captured_at,
        URL: image_path,
        URLPREVIEW: preview_path,
        BILDETYPE: image_type,
        METER: metering,
        FELTKODE: lane_code
      } = properties;
      const lane_number = parseInt(lane_code.match(/^[0-9]+/)[0], 10);
      const direction = lane_number % 2 === 0 ? directionEnum.backward : directionEnum.forward;
      const data = {
        loc,
        key,
        ca,
        image_path,
        preview_path,
        road_reference: roadReference(properties),
        metering,
        lane_code,
        direction,
        captured_at: new Date(captured_at),
        is_sphere: image_type === "360"
      };
      cache.points.set(key, data);
      return {
        minX: loc[0],
        minY: loc[1],
        maxX: loc[0],
        maxY: loc[1],
        data
      };
    });
    _vegbilderCache.rtree.load(features);
    dispatch9.call("loadedImages");
  }
  function orderSequences(projection2, cache) {
    const { points } = cache;
    const grouped = Array.from(points.values()).reduce((grouped2, image) => {
      const key = image.road_reference;
      if (grouped2.has(key)) {
        grouped2.get(key).push(image);
      } else {
        grouped2.set(key, [image]);
      }
      return grouped2;
    }, /* @__PURE__ */ new Map());
    const imageSequences = Array.from(grouped.values()).reduce((imageSequences2, imageGroup) => {
      imageGroup.sort((a2, b2) => {
        if (a2.captured_at.valueOf() > b2.captured_at.valueOf()) {
          return 1;
        } else if (a2.captured_at.valueOf() < b2.captured_at.valueOf()) {
          return -1;
        } else {
          const { direction } = a2;
          if (direction === directionEnum.forward) {
            return a2.metering - b2.metering;
          } else {
            return b2.metering - a2.metering;
          }
        }
      });
      let imageSequence = [imageGroup[0]];
      let angle2 = null;
      for (const [lastImage, image] of pairs(imageGroup)) {
        if (lastImage.ca === null) {
          const b2 = projection2(lastImage.loc);
          const a2 = projection2(image.loc);
          if (!geoVecEqual(a2, b2)) {
            angle2 = geoVecAngle(a2, b2);
            angle2 *= 180 / Math.PI;
            angle2 -= 90;
            angle2 = angle2 >= 0 ? angle2 : angle2 + 360;
          }
          lastImage.ca = angle2;
        }
        if (image.direction === lastImage.direction && image.captured_at.valueOf() - lastImage.captured_at.valueOf() <= 2e4) {
          imageSequence.push(image);
        } else {
          imageSequences2.push(imageSequence);
          imageSequence = [image];
        }
      }
      imageSequences2.push(imageSequence);
      return imageSequences2;
    }, []);
    cache.sequences = imageSequences.map((images) => {
      const sequence = {
        images,
        key: images[0].key,
        geometry: {
          type: "LineString",
          coordinates: images.map((image) => image.loc)
        }
      };
      for (const image of images) {
        _vegbilderCache.image2sequence_map.set(image.key, sequence);
      }
      return sequence;
    });
  }
  function roadReference(properties) {
    const {
      FYLKENUMMER: county_number,
      VEGKATEGORI: road_class,
      VEGSTATUS: road_status,
      VEGNUMMER: road_number,
      STREKNING: section,
      DELSTREKNING: subsection,
      HP: parcel,
      KRYSSDEL: junction_part,
      SIDEANLEGGSDEL: services_part,
      ANKERPUNKT: anker_point,
      AAR: year
    } = properties;
    let reference;
    if (year >= 2020) {
      reference = "".concat(road_class).concat(road_status).concat(road_number, " S").concat(section, "D").concat(subsection);
      if (junction_part) {
        reference = "".concat(reference, " M").concat(anker_point, " KD").concat(junction_part);
      } else if (services_part) {
        reference = "".concat(reference, " M").concat(anker_point, " SD").concat(services_part);
      }
    } else {
      reference = "".concat(county_number).concat(road_class).concat(road_status).concat(road_number, " HP").concat(parcel);
    }
    return reference;
  }
  function localeTimestamp(date) {
    const options2 = {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    };
    return date.toLocaleString(_mainLocalizer.localeCode(), options2);
  }
  function partitionViewport3(projection2) {
    const zoom = geoScaleToZoom(projection2.scale());
    const roundZoom = Math.ceil(zoom * 2) / 2 + 2.5;
    const tiler9 = utilTiler().zoomExtent([roundZoom, roundZoom]);
    return tiler9.getTiles(projection2).map((tile) => tile.extent);
  }
  function searchLimited3(limit, projection2, rtree) {
    limit != null ? limit : limit = 5;
    return partitionViewport3(projection2).reduce((result, extent) => {
      const found = rtree.search(extent.bbox()).slice(0, limit).map((d2) => d2.data);
      return result.concat(found);
    }, []);
  }
  var vegbilder_default = {
    init: function() {
      this.event = utilRebind(this, dispatch9, "on");
    },
    reset: async function() {
      if (_vegbilderCache) {
        for (const layer of _vegbilderCache.wfslayers.values()) {
          for (const controller of layer.inflight.values()) {
            controller.abort();
          }
        }
      }
      _vegbilderCache = {
        wfslayers: /* @__PURE__ */ new Map(),
        rtree: new import_rbush9.default(),
        image2sequence_map: /* @__PURE__ */ new Map()
      };
      const availableLayers = await fetchAvailableLayers();
      const { wfslayers } = _vegbilderCache;
      for (const layerInfo of availableLayers) {
        const cache = {
          layerInfo,
          loaded: /* @__PURE__ */ new Map(),
          inflight: /* @__PURE__ */ new Map(),
          points: /* @__PURE__ */ new Map(),
          sequences: []
        };
        wfslayers.set(layerInfo.name, cache);
      }
    },
    images: function(projection2) {
      const limit = 5;
      return searchLimited3(limit, projection2, _vegbilderCache.rtree);
    },
    sequences: function(projection2) {
      const viewport = projection2.clipExtent();
      const min3 = [viewport[0][0], viewport[1][1]];
      const max3 = [viewport[1][0], viewport[0][1]];
      const bbox2 = geoExtent(projection2.invert(min3), projection2.invert(max3)).bbox();
      const seen = /* @__PURE__ */ new Set();
      const line_strings = [];
      for (const { data } of _vegbilderCache.rtree.search(bbox2)) {
        const sequence = _vegbilderCache.image2sequence_map.get(data.key);
        if (!sequence)
          continue;
        const { key, geometry, images } = sequence;
        if (seen.has(key))
          continue;
        seen.add(key);
        const line = {
          type: "LineString",
          coordinates: geometry.coordinates,
          key,
          images
        };
        line_strings.push(line);
      }
      return line_strings;
    },
    cachedImage: function(key) {
      for (const { points } of _vegbilderCache.wfslayers.values()) {
        if (points.has(key))
          return points.get(key);
      }
    },
    getSequenceForImage: function(image) {
      return _vegbilderCache == null ? void 0 : _vegbilderCache.image2sequence_map.get(image == null ? void 0 : image.key);
    },
    loadImages: async function(context, margin) {
      if (!_vegbilderCache) {
        await this.reset();
      }
      margin != null ? margin : margin = 1;
      const wfslayers = filterAvailableLayers(context.photos());
      loadWFSLayers(context.projection, margin, wfslayers);
    },
    photoFrame: function() {
      return _currentFrame;
    },
    ensureViewerLoaded: function(context) {
      if (_loadViewerPromise3)
        return _loadViewerPromise3;
      const step = (stepBy) => () => {
        const viewer = context.container().select(".photoviewer");
        const selected = viewer.empty() ? void 0 : viewer.datum();
        if (!selected)
          return;
        const sequence = this.getSequenceForImage(selected);
        const nextIndex = sequence.images.indexOf(selected) + stepBy;
        const nextImage = sequence.images[nextIndex];
        if (!nextImage)
          return;
        context.map().centerEase(nextImage.loc);
        this.selectImage(context, nextImage.key, true);
      };
      const wrap2 = context.container().select(".photoviewer").selectAll(".vegbilder-wrapper").data([0]);
      const wrapEnter = wrap2.enter().append("div").attr("class", "photo-wrapper vegbilder-wrapper").classed("hide", true);
      wrapEnter.append("div").attr("class", "photo-attribution fillD");
      const controlsEnter = wrapEnter.append("div").attr("class", "photo-controls-wrap").append("div").attr("class", "photo-controls");
      controlsEnter.append("button").on("click.back", step(-1)).text("\u25C4");
      controlsEnter.append("button").on("click.forward", step(1)).text("\u25BA");
      _loadViewerPromise3 = Promise.all([
        pannellum_photo_default.init(context, wrapEnter),
        plane_photo_default.init(context, wrapEnter)
      ]).then(([pannellumPhotoFrame, planePhotoFrame]) => {
        _pannellumFrame = pannellumPhotoFrame;
        _pannellumFrame.event.on("viewerChanged", () => dispatch9.call("viewerChanged"));
        _planeFrame = planePhotoFrame;
        _planeFrame.event.on("viewerChanged", () => dispatch9.call("viewerChanged"));
      });
      return _loadViewerPromise3;
    },
    selectImage: function(context, key, keepOrientation) {
      const d2 = this.cachedImage(key);
      this.updateUrlImage(key);
      const viewer = context.container().select(".photoviewer");
      if (!viewer.empty()) {
        viewer.datum(d2);
      }
      this.setStyles(context, null, true);
      if (!d2)
        return this;
      const wrap2 = context.container().select(".photoviewer .vegbilder-wrapper");
      const attribution = wrap2.selectAll(".photo-attribution").text("");
      if (d2.captured_at) {
        attribution.append("span").attr("class", "captured_at").text(localeTimestamp(d2.captured_at));
      }
      attribution.append("a").attr("target", "_blank").attr("href", "https://vegvesen.no").call(_t.append("vegbilder.publisher"));
      attribution.append("a").attr("target", "_blank").attr("href", "https://vegbilder.atlas.vegvesen.no/?year=".concat(d2.captured_at.getFullYear(), "&lat=").concat(d2.loc[1], "&lng=").concat(d2.loc[0], "&view=image&imageId=").concat(d2.key)).call(_t.append("vegbilder.view_on"));
      _currentFrame = d2.is_sphere ? _pannellumFrame : _planeFrame;
      _currentFrame.selectPhoto(d2, keepOrientation).showPhotoFrame(wrap2);
      return this;
    },
    showViewer: function(context) {
      const viewer = context.container().select(".photoviewer").classed("hide", false);
      const isHidden = viewer.selectAll(".photo-wrapper.vegbilder-wrapper.hide").size();
      if (isHidden) {
        viewer.selectAll(".photo-wrapper:not(.vegbilder-wrapper)").classed("hide", true);
        viewer.selectAll(".photo-wrapper.vegbilder-wrapper").classed("hide", false);
      }
      return this;
    },
    hideViewer: function(context) {
      this.updateUrlImage(null);
      const viewer = context.container().select(".photoviewer");
      if (!viewer.empty())
        viewer.datum(null);
      viewer.classed("hide", true).selectAll(".photo-wrapper").classed("hide", true);
      context.container().selectAll(".viewfield-group, .sequence").classed("currentView", false);
      return this.setStyles(context, null, true);
    },
    // Updates the currently highlighted sequence and selected bubble.
    // Reset is only necessary when interacting with the viewport because
    // this implicitly changes the currently selected bubble/sequence
    setStyles: function(context, hovered, reset) {
      var _a2, _b;
      if (reset) {
        context.container().selectAll(".viewfield-group").classed("highlighted", false).classed("hovered", false).classed("currentView", false);
        context.container().selectAll(".sequence").classed("highlighted", false).classed("currentView", false);
      }
      const hoveredImageKey = hovered == null ? void 0 : hovered.key;
      const hoveredSequence = this.getSequenceForImage(hovered);
      const hoveredSequenceKey = hoveredSequence == null ? void 0 : hoveredSequence.key;
      const hoveredImageKeys = (_a2 = hoveredSequence == null ? void 0 : hoveredSequence.images.map((d2) => d2.key)) != null ? _a2 : [];
      const viewer = context.container().select(".photoviewer");
      const selected = viewer.empty() ? void 0 : viewer.datum();
      const selectedImageKey = selected == null ? void 0 : selected.key;
      const selectedSequence = this.getSequenceForImage(selected);
      const selectedSequenceKey = selectedSequence == null ? void 0 : selectedSequence.key;
      const selectedImageKeys = (_b = selectedSequence == null ? void 0 : selectedSequence.images.map((d2) => d2.key)) != null ? _b : [];
      const highlightedImageKeys = utilArrayUnion(hoveredImageKeys, selectedImageKeys);
      context.container().selectAll(".layer-vegbilder .viewfield-group").classed("highlighted", (d2) => highlightedImageKeys.indexOf(d2.key) !== -1).classed("hovered", (d2) => d2.key === hoveredImageKey).classed("currentView", (d2) => d2.key === selectedImageKey);
      context.container().selectAll(".layer-vegbilder .sequence").classed("highlighted", (d2) => d2.key === hoveredSequenceKey).classed("currentView", (d2) => d2.key === selectedSequenceKey);
      context.container().selectAll(".layer-vegbilder .viewfield-group .viewfield").attr("d", viewfieldPath);
      function viewfieldPath() {
        const d2 = this.parentNode.__data__;
        if (d2.is_sphere && d2.key !== selectedImageKey) {
          return "M 8,13 m -10,0 a 10,10 0 1,0 20,0 a 10,10 0 1,0 -20,0";
        } else {
          return "M 6,9 C 8,8.4 8,8.4 10,9 L 16,-2 C 12,-5 4,-5 0,-2 z";
        }
      }
      return this;
    },
    updateUrlImage: function(key) {
      if (!window.mocha) {
        const hash = utilStringQs(window.location.hash);
        if (key) {
          hash.photo = "vegbilder/" + key;
        } else {
          delete hash.photo;
        }
        window.location.replace("#" + utilQsString(hash, true));
      }
    },
    validHere: function(extent) {
      const bbox2 = Object.values(extent.bbox());
      return iso1A2Codes(bbox2).includes("NO");
    },
    cache: function() {
      return _vegbilderCache;
    }
  };

  // node_modules/osm-auth/src/osm-auth.mjs
  function osmAuth(o2) {
    var oauth2 = {};
    var _store = null;
    try {
      _store = window.localStorage;
    } catch (e3) {
      var _mock = /* @__PURE__ */ new Map();
      _store = {
        isMocked: true,
        hasItem: (k2) => _mock.has(k2),
        getItem: (k2) => _mock.get(k2),
        setItem: (k2, v2) => _mock.set(k2, v2),
        removeItem: (k2) => _mock.delete(k2),
        clear: () => _mock.clear()
      };
    }
    function token(k2, v2) {
      if (arguments.length === 1)
        return _store.getItem(o2.url + k2);
      else if (arguments.length === 2)
        return _store.setItem(o2.url + k2, v2);
    }
    oauth2.authenticated = function() {
      return !!token("oauth2_access_token");
    };
    oauth2.logout = function() {
      token("oauth2_access_token", "");
      token("oauth_token", "");
      token("oauth_token_secret", "");
      token("oauth_request_token_secret", "");
      return oauth2;
    };
    oauth2.authenticate = function(callback) {
      if (oauth2.authenticated()) {
        callback(null, oauth2);
        return;
      }
      oauth2.logout();
      _preopenPopup(function(error, popup) {
        if (error) {
          callback(error);
        } else {
          _generatePkceChallenge(function(pkce) {
            _authenticate(pkce, popup, callback);
          });
        }
      });
    };
    oauth2.authenticateAsync = function() {
      if (oauth2.authenticated()) {
        return Promise.resolve(oauth2);
      }
      oauth2.logout();
      return new Promise((resolve, reject) => {
        var errback = (err, result) => {
          if (err) {
            reject(err);
          } else {
            resolve(result);
          }
        };
        _preopenPopup((error, popup) => {
          if (error) {
            errback(error);
          } else {
            _generatePkceChallenge((pkce) => _authenticate(pkce, popup, errback));
          }
        });
      });
    };
    function _preopenPopup(callback) {
      if (o2.singlepage) {
        callback(null, void 0);
        return;
      }
      var w2 = 550;
      var h2 = 610;
      var settings = [
        ["width", w2],
        ["height", h2],
        ["left", window.screen.width / 2 - w2 / 2],
        ["top", window.screen.height / 2 - h2 / 2]
      ].map(function(x2) {
        return x2.join("=");
      }).join(",");
      var popup = window.open("about:blank", "oauth_window", settings);
      if (popup) {
        callback(null, popup);
      } else {
        var error = new Error("Popup was blocked");
        error.status = "popup-blocked";
        callback(error);
      }
    }
    function _authenticate(pkce, popup, callback) {
      var state = generateState();
      var url = o2.url + "/oauth2/authorize?" + utilQsString2({
        client_id: o2.client_id,
        redirect_uri: o2.redirect_uri,
        response_type: "code",
        scope: o2.scope,
        state,
        code_challenge: pkce.code_challenge,
        code_challenge_method: pkce.code_challenge_method
      });
      if (o2.singlepage) {
        if (_store.isMocked) {
          var error = new Error("localStorage unavailable, but required in singlepage mode");
          error.status = "pkce-localstorage-unavailable";
          callback(error);
          return;
        }
        var params = utilStringQs2(window.location.search.slice(1));
        if (params.code) {
          oauth2.bootstrapToken(params.code, callback);
        } else {
          token("oauth2_state", state);
          token("oauth2_pkce_code_verifier", pkce.code_verifier);
          window.location = url;
        }
      } else {
        oauth2.popupWindow = popup;
        popup.location = url;
      }
      window.authComplete = function(url2) {
        var params2 = utilStringQs2(url2.split("?")[1]);
        if (params2.state !== state) {
          error = new Error("Invalid state");
          error.status = "invalid-state";
          callback(error);
          return;
        }
        _getAccessToken(params2.code, pkce.code_verifier, accessTokenDone);
        delete window.authComplete;
      };
      function accessTokenDone(err, xhr) {
        o2.done();
        if (err) {
          callback(err);
          return;
        }
        var access_token = JSON.parse(xhr.response);
        token("oauth2_access_token", access_token.access_token);
        callback(null, oauth2);
      }
    }
    function _getAccessToken(auth_code, code_verifier, accessTokenDone) {
      var url = o2.url + "/oauth2/token?" + utilQsString2({
        client_id: o2.client_id,
        redirect_uri: o2.redirect_uri,
        grant_type: "authorization_code",
        code: auth_code,
        code_verifier
      });
      oauth2.rawxhr("POST", url, null, null, null, accessTokenDone);
      o2.loading();
    }
    oauth2.bringPopupWindowToFront = function() {
      var broughtPopupToFront = false;
      try {
        if (oauth2.popupWindow && !oauth2.popupWindow.closed) {
          oauth2.popupWindow.focus();
          broughtPopupToFront = true;
        }
      } catch (err) {
      }
      return broughtPopupToFront;
    };
    oauth2.bootstrapToken = function(auth_code, callback) {
      var state = token("oauth2_state");
      token("oauth2_state", "");
      var params = utilStringQs2(window.location.search.slice(1));
      if (params.state !== state) {
        var error = new Error("Invalid state");
        error.status = "invalid-state";
        callback(error);
        return;
      }
      var code_verifier = token("oauth2_pkce_code_verifier");
      token("oauth2_pkce_code_verifier", "");
      _getAccessToken(auth_code, code_verifier, accessTokenDone);
      function accessTokenDone(err, xhr) {
        o2.done();
        if (err) {
          callback(err);
          return;
        }
        var access_token = JSON.parse(xhr.response);
        token("oauth2_access_token", access_token.access_token);
        callback(null, oauth2);
      }
    };
    oauth2.fetch = function(resource, options2) {
      if (oauth2.authenticated()) {
        return _doFetch();
      } else {
        if (o2.auto) {
          return oauth2.authenticateAsync().then(_doFetch);
        } else {
          return Promise.reject(new Error("not authenticated"));
        }
      }
      function _doFetch() {
        options2 = options2 || {};
        if (!options2.headers) {
          options2.headers = { "Content-Type": "application/x-www-form-urlencoded" };
        }
        options2.headers.Authorization = "Bearer " + token("oauth2_access_token");
        return fetch(resource, options2);
      }
    };
    oauth2.xhr = function(options2, callback) {
      if (oauth2.authenticated()) {
        return _doXHR();
      } else {
        if (o2.auto) {
          oauth2.authenticate(_doXHR);
          return;
        } else {
          callback("not authenticated", null);
          return;
        }
      }
      function _doXHR() {
        var url = options2.prefix !== false ? o2.apiUrl + options2.path : options2.path;
        return oauth2.rawxhr(
          options2.method,
          url,
          token("oauth2_access_token"),
          options2.content,
          options2.headers,
          done
        );
      }
      function done(err, xhr) {
        if (err) {
          callback(err);
        } else if (xhr.responseXML) {
          callback(err, xhr.responseXML);
        } else {
          callback(err, xhr.response);
        }
      }
    };
    oauth2.rawxhr = function(method, url, access_token, data, headers, callback) {
      headers = headers || { "Content-Type": "application/x-www-form-urlencoded" };
      if (access_token) {
        headers.Authorization = "Bearer " + access_token;
      }
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function() {
        if (4 === xhr.readyState && 0 !== xhr.status) {
          if (/^20\d$/.test(xhr.status)) {
            callback(null, xhr);
          } else {
            callback(xhr, null);
          }
        }
      };
      xhr.onerror = function(e3) {
        callback(e3, null);
      };
      xhr.open(method, url, true);
      for (var h2 in headers)
        xhr.setRequestHeader(h2, headers[h2]);
      xhr.send(data);
      return xhr;
    };
    oauth2.preauth = function(val) {
      if (val && val.access_token) {
        token("oauth2_access_token", val.access_token);
      }
      return oauth2;
    };
    oauth2.options = function(val) {
      if (!arguments.length)
        return o2;
      o2 = val;
      o2.apiUrl = o2.apiUrl || "https://api.openstreetmap.org";
      o2.url = o2.url || "https://www.openstreetmap.org";
      o2.auto = o2.auto || false;
      o2.singlepage = o2.singlepage || false;
      o2.loading = o2.loading || function() {
      };
      o2.done = o2.done || function() {
      };
      return oauth2.preauth(o2);
    };
    oauth2.options(o2);
    return oauth2;
  }
  function utilQsString2(obj) {
    return Object.keys(obj).filter(function(key) {
      return obj[key] !== void 0;
    }).sort().map(function(key) {
      return encodeURIComponent(key) + "=" + encodeURIComponent(obj[key]);
    }).join("&");
  }
  function utilStringQs2(str) {
    var i3 = 0;
    while (i3 < str.length && (str[i3] === "?" || str[i3] === "#"))
      i3++;
    str = str.slice(i3);
    return str.split("&").reduce(function(obj, pair3) {
      var parts = pair3.split("=");
      if (parts.length === 2) {
        obj[parts[0]] = decodeURIComponent(parts[1]);
      }
      return obj;
    }, {});
  }
  function supportsWebCryptoAPI() {
    return window && window.crypto && window.crypto.getRandomValues && window.crypto.subtle && window.crypto.subtle.digest;
  }
  function _generatePkceChallenge(callback) {
    var code_verifier;
    if (supportsWebCryptoAPI()) {
      var random = window.crypto.getRandomValues(new Uint8Array(32));
      code_verifier = base64(random.buffer);
      var verifier = Uint8Array.from(Array.from(code_verifier).map(function(char) {
        return char.charCodeAt(0);
      }));
      window.crypto.subtle.digest("SHA-256", verifier).then(function(hash) {
        var code_challenge = base64(hash);
        callback({
          code_challenge,
          code_verifier,
          code_challenge_method: "S256"
        });
      });
    } else {
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
      code_verifier = "";
      for (var i3 = 0; i3 < 64; i3++) {
        code_verifier += chars[Math.floor(Math.random() * chars.length)];
      }
      callback({
        code_verifier,
        code_challenge: code_verifier,
        code_challenge_method: "plain"
      });
    }
  }
  function generateState() {
    var state;
    if (supportsWebCryptoAPI()) {
      var random = window.crypto.getRandomValues(new Uint8Array(32));
      state = base64(random.buffer);
    } else {
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
      state = "";
      for (var i3 = 0; i3 < 64; i3++) {
        state += chars[Math.floor(Math.random() * chars.length)];
      }
    }
    return state;
  }
  function base64(buffer) {
    return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer))).replace(/\//g, "_").replace(/\+/g, "-").replace(/[=]/g, "");
  }

  // modules/services/osm.js
  var import_rbush10 = __toESM(require_rbush_min());
  var tiler6 = utilTiler();
  var dispatch10 = dispatch_default("apiStatusChange", "authLoading", "authDone", "change", "loading", "loaded", "loadedNotes");
  var urlroot = osmApiConnections[0].url;
  var apiUrlroot = osmApiConnections[0].apiUrl || urlroot;
  var redirectPath = window.location.origin + window.location.pathname;
  var oauth = osmAuth({
    url: urlroot,
    apiUrl: apiUrlroot,
    client_id: osmApiConnections[0].client_id,
    client_secret: osmApiConnections[0].client_secret,
    scope: "read_prefs write_prefs write_api read_gpx write_notes",
    redirect_uri: redirectPath + "land.html",
    loading: authLoading,
    done: authDone
  });
  var _apiConnections = osmApiConnections;
  var _imageryBlocklists = [/.*\.google(apis)?\..*\/(vt|kh)[\?\/].*([xyz]=.*){3}.*/];
  var _tileCache = { toLoad: {}, loaded: {}, inflight: {}, seen: {}, rtree: new import_rbush10.default() };
  var _noteCache = { toLoad: {}, loaded: {}, inflight: {}, inflightPost: {}, note: {}, closed: {}, rtree: new import_rbush10.default() };
  var _userCache = { toLoad: {}, user: {} };
  var _cachedApiStatus;
  var _changeset = {};
  var _deferred = /* @__PURE__ */ new Set();
  var _connectionID = 1;
  var _tileZoom4 = 16;
  var _noteZoom = 12;
  var _rateLimitError;
  var _userChangesets;
  var _userDetails;
  var _off;
  var _maxWayNodes = 2e3;
  function authLoading() {
    dispatch10.call("authLoading");
  }
  function authDone() {
    dispatch10.call("authDone");
  }
  function abortRequest5(controllerOrXHR) {
    if (controllerOrXHR) {
      controllerOrXHR.abort();
    }
  }
  function hasInflightRequests(cache) {
    return Object.keys(cache.inflight).length;
  }
  function abortUnwantedRequests4(cache, visibleTiles) {
    Object.keys(cache.inflight).forEach(function(k2) {
      if (cache.toLoad[k2])
        return;
      if (visibleTiles.find(function(tile) {
        return k2 === tile.id;
      }))
        return;
      abortRequest5(cache.inflight[k2]);
      delete cache.inflight[k2];
    });
  }
  function getLoc(attrs) {
    var lon = attrs.lon && attrs.lon.value;
    var lat = attrs.lat && attrs.lat.value;
    return [Number(lon), Number(lat)];
  }
  function getNodes(obj) {
    var elems = obj.getElementsByTagName("nd");
    var nodes = new Array(elems.length);
    for (var i3 = 0, l2 = elems.length; i3 < l2; i3++) {
      nodes[i3] = "n" + elems[i3].attributes.ref.value;
    }
    return nodes;
  }
  function getNodesJSON(obj) {
    var elems = obj.nodes;
    var nodes = new Array(elems.length);
    for (var i3 = 0, l2 = elems.length; i3 < l2; i3++) {
      nodes[i3] = "n" + elems[i3];
    }
    return nodes;
  }
  function getTags(obj) {
    var elems = obj.getElementsByTagName("tag");
    var tags = {};
    for (var i3 = 0, l2 = elems.length; i3 < l2; i3++) {
      var attrs = elems[i3].attributes;
      tags[attrs.k.value] = attrs.v.value;
    }
    return tags;
  }
  function getMembers(obj) {
    var elems = obj.getElementsByTagName("member");
    var members = new Array(elems.length);
    for (var i3 = 0, l2 = elems.length; i3 < l2; i3++) {
      var attrs = elems[i3].attributes;
      members[i3] = {
        id: attrs.type.value[0] + attrs.ref.value,
        type: attrs.type.value,
        role: attrs.role.value
      };
    }
    return members;
  }
  function getMembersJSON(obj) {
    var elems = obj.members;
    var members = new Array(elems.length);
    for (var i3 = 0, l2 = elems.length; i3 < l2; i3++) {
      var attrs = elems[i3];
      members[i3] = {
        id: attrs.type[0] + attrs.ref,
        type: attrs.type,
        role: attrs.role
      };
    }
    return members;
  }
  function getVisible(attrs) {
    return !attrs.visible || attrs.visible.value !== "false";
  }
  function parseComments(comments) {
    var parsedComments = [];
    for (var i3 = 0; i3 < comments.length; i3++) {
      var comment = comments[i3];
      if (comment.nodeName === "comment") {
        var childNodes = comment.childNodes;
        var parsedComment = {};
        for (var j2 = 0; j2 < childNodes.length; j2++) {
          var node = childNodes[j2];
          var nodeName = node.nodeName;
          if (nodeName === "#text")
            continue;
          parsedComment[nodeName] = node.textContent;
          if (nodeName === "uid") {
            var uid = node.textContent;
            if (uid && !_userCache.user[uid]) {
              _userCache.toLoad[uid] = true;
            }
          }
        }
        if (parsedComment) {
          parsedComments.push(parsedComment);
        }
      }
    }
    return parsedComments;
  }
  function encodeNoteRtree(note) {
    return {
      minX: note.loc[0],
      minY: note.loc[1],
      maxX: note.loc[0],
      maxY: note.loc[1],
      data: note
    };
  }
  var jsonparsers = {
    node: function nodeData(obj, uid) {
      return new osmNode({
        id: uid,
        visible: typeof obj.visible === "boolean" ? obj.visible : true,
        version: obj.version && obj.version.toString(),
        changeset: obj.changeset && obj.changeset.toString(),
        timestamp: obj.timestamp,
        user: obj.user,
        uid: obj.uid && obj.uid.toString(),
        loc: [Number(obj.lon), Number(obj.lat)],
        tags: obj.tags
      });
    },
    way: function wayData(obj, uid) {
      return new osmWay({
        id: uid,
        visible: typeof obj.visible === "boolean" ? obj.visible : true,
        version: obj.version && obj.version.toString(),
        changeset: obj.changeset && obj.changeset.toString(),
        timestamp: obj.timestamp,
        user: obj.user,
        uid: obj.uid && obj.uid.toString(),
        tags: obj.tags,
        nodes: getNodesJSON(obj)
      });
    },
    relation: function relationData(obj, uid) {
      return new osmRelation({
        id: uid,
        visible: typeof obj.visible === "boolean" ? obj.visible : true,
        version: obj.version && obj.version.toString(),
        changeset: obj.changeset && obj.changeset.toString(),
        timestamp: obj.timestamp,
        user: obj.user,
        uid: obj.uid && obj.uid.toString(),
        tags: obj.tags,
        members: getMembersJSON(obj)
      });
    },
    user: function parseUser(obj, uid) {
      return {
        id: uid,
        display_name: obj.display_name,
        account_created: obj.account_created,
        image_url: obj.img && obj.img.href,
        changesets_count: obj.changesets && obj.changesets.count && obj.changesets.count.toString() || "0",
        active_blocks: obj.blocks && obj.blocks.received && obj.blocks.received.active && obj.blocks.received.active.toString() || "0"
      };
    }
  };
  function parseJSON(payload, callback, options2) {
    options2 = Object.assign({ skipSeen: true }, options2);
    if (!payload) {
      return callback({ message: "No JSON", status: -1 });
    }
    var json = payload;
    if (typeof json !== "object")
      json = JSON.parse(payload);
    if (!json.elements)
      return callback({ message: "No JSON", status: -1 });
    var children2 = json.elements;
    var handle = window.requestIdleCallback(function() {
      _deferred.delete(handle);
      var results = [];
      var result;
      for (var i3 = 0; i3 < children2.length; i3++) {
        result = parseChild(children2[i3]);
        if (result)
          results.push(result);
      }
      callback(null, results);
    });
    _deferred.add(handle);
    function parseChild(child) {
      var parser3 = jsonparsers[child.type];
      if (!parser3)
        return null;
      var uid;
      uid = osmEntity.id.fromOSM(child.type, child.id);
      if (options2.skipSeen) {
        if (_tileCache.seen[uid])
          return null;
        _tileCache.seen[uid] = true;
      }
      return parser3(child, uid);
    }
  }
  function parseUserJSON(payload, callback, options2) {
    options2 = Object.assign({ skipSeen: true }, options2);
    if (!payload) {
      return callback({ message: "No JSON", status: -1 });
    }
    var json = payload;
    if (typeof json !== "object")
      json = JSON.parse(payload);
    if (!json.users && !json.user)
      return callback({ message: "No JSON", status: -1 });
    var objs = json.users || [json];
    var handle = window.requestIdleCallback(function() {
      _deferred.delete(handle);
      var results = [];
      var result;
      for (var i3 = 0; i3 < objs.length; i3++) {
        result = parseObj(objs[i3]);
        if (result)
          results.push(result);
      }
      callback(null, results);
    });
    _deferred.add(handle);
    function parseObj(obj) {
      var uid = obj.user.id && obj.user.id.toString();
      if (options2.skipSeen && _userCache.user[uid]) {
        delete _userCache.toLoad[uid];
        return null;
      }
      var user = jsonparsers.user(obj.user, uid);
      _userCache.user[uid] = user;
      delete _userCache.toLoad[uid];
      return user;
    }
  }
  var parsers = {
    node: function nodeData2(obj, uid) {
      var attrs = obj.attributes;
      return new osmNode({
        id: uid,
        visible: getVisible(attrs),
        version: attrs.version.value,
        changeset: attrs.changeset && attrs.changeset.value,
        timestamp: attrs.timestamp && attrs.timestamp.value,
        user: attrs.user && attrs.user.value,
        uid: attrs.uid && attrs.uid.value,
        loc: getLoc(attrs),
        tags: getTags(obj)
      });
    },
    way: function wayData2(obj, uid) {
      var attrs = obj.attributes;
      return new osmWay({
        id: uid,
        visible: getVisible(attrs),
        version: attrs.version.value,
        changeset: attrs.changeset && attrs.changeset.value,
        timestamp: attrs.timestamp && attrs.timestamp.value,
        user: attrs.user && attrs.user.value,
        uid: attrs.uid && attrs.uid.value,
        tags: getTags(obj),
        nodes: getNodes(obj)
      });
    },
    relation: function relationData2(obj, uid) {
      var attrs = obj.attributes;
      return new osmRelation({
        id: uid,
        visible: getVisible(attrs),
        version: attrs.version.value,
        changeset: attrs.changeset && attrs.changeset.value,
        timestamp: attrs.timestamp && attrs.timestamp.value,
        user: attrs.user && attrs.user.value,
        uid: attrs.uid && attrs.uid.value,
        tags: getTags(obj),
        members: getMembers(obj)
      });
    },
    note: function parseNote(obj, uid) {
      var attrs = obj.attributes;
      var childNodes = obj.childNodes;
      var props = {};
      props.id = uid;
      props.loc = getLoc(attrs);
      if (!_noteCache.note[uid]) {
        let coincident = false;
        const epsilon3 = 1e-5;
        do {
          if (coincident) {
            props.loc = geoVecAdd(props.loc, [epsilon3, epsilon3]);
          }
          const bbox2 = geoExtent(props.loc).bbox();
          coincident = _noteCache.rtree.search(bbox2).length;
        } while (coincident);
      } else {
        props.loc = _noteCache.note[uid].loc;
      }
      for (var i3 = 0; i3 < childNodes.length; i3++) {
        var node = childNodes[i3];
        var nodeName = node.nodeName;
        if (nodeName === "#text")
          continue;
        if (nodeName === "comments") {
          props[nodeName] = parseComments(node.childNodes);
        } else {
          props[nodeName] = node.textContent;
        }
      }
      var note = new osmNote(props);
      var item = encodeNoteRtree(note);
      _noteCache.note[note.id] = note;
      updateRtree4(item, true);
      return note;
    },
    user: function parseUser2(obj, uid) {
      var attrs = obj.attributes;
      var user = {
        id: uid,
        display_name: attrs.display_name && attrs.display_name.value,
        account_created: attrs.account_created && attrs.account_created.value,
        changesets_count: "0",
        active_blocks: "0"
      };
      var img = obj.getElementsByTagName("img");
      if (img && img[0] && img[0].getAttribute("href")) {
        user.image_url = img[0].getAttribute("href");
      }
      var changesets = obj.getElementsByTagName("changesets");
      if (changesets && changesets[0] && changesets[0].getAttribute("count")) {
        user.changesets_count = changesets[0].getAttribute("count");
      }
      var blocks = obj.getElementsByTagName("blocks");
      if (blocks && blocks[0]) {
        var received = blocks[0].getElementsByTagName("received");
        if (received && received[0] && received[0].getAttribute("active")) {
          user.active_blocks = received[0].getAttribute("active");
        }
      }
      _userCache.user[uid] = user;
      delete _userCache.toLoad[uid];
      return user;
    }
  };
  function parseXML(xml, callback, options2) {
    options2 = Object.assign({ skipSeen: true }, options2);
    if (!xml || !xml.childNodes) {
      return callback({ message: "No XML", status: -1 });
    }
    var root3 = xml.childNodes[0];
    var children2 = root3.childNodes;
    var handle = window.requestIdleCallback(function() {
      _deferred.delete(handle);
      var results = [];
      var result;
      for (var i3 = 0; i3 < children2.length; i3++) {
        result = parseChild(children2[i3]);
        if (result)
          results.push(result);
      }
      callback(null, results);
    });
    _deferred.add(handle);
    function parseChild(child) {
      var parser3 = parsers[child.nodeName];
      if (!parser3)
        return null;
      var uid;
      if (child.nodeName === "user") {
        uid = child.attributes.id.value;
        if (options2.skipSeen && _userCache.user[uid]) {
          delete _userCache.toLoad[uid];
          return null;
        }
      } else if (child.nodeName === "note") {
        uid = child.getElementsByTagName("id")[0].textContent;
      } else {
        uid = osmEntity.id.fromOSM(child.nodeName, child.attributes.id.value);
        if (options2.skipSeen) {
          if (_tileCache.seen[uid])
            return null;
          _tileCache.seen[uid] = true;
        }
      }
      return parser3(child, uid);
    }
  }
  function updateRtree4(item, replace) {
    _noteCache.rtree.remove(item, function isEql(a2, b2) {
      return a2.data.id === b2.data.id;
    });
    if (replace) {
      _noteCache.rtree.insert(item);
    }
  }
  function wrapcb(thisArg, callback, cid) {
    return function(err, result) {
      if (err) {
        if (err.status === 400 || err.status === 401 || err.status === 403) {
          thisArg.logout();
        }
        return callback.call(thisArg, err);
      } else if (thisArg.getConnectionId() !== cid) {
        return callback.call(thisArg, { message: "Connection Switched", status: -1 });
      } else {
        return callback.call(thisArg, err, result);
      }
    };
  }
  var osm_default = {
    init: function() {
      utilRebind(this, dispatch10, "on");
    },
    reset: function() {
      Array.from(_deferred).forEach(function(handle) {
        window.cancelIdleCallback(handle);
        _deferred.delete(handle);
      });
      _connectionID++;
      _userChangesets = void 0;
      _userDetails = void 0;
      _rateLimitError = void 0;
      Object.values(_tileCache.inflight).forEach(abortRequest5);
      Object.values(_noteCache.inflight).forEach(abortRequest5);
      Object.values(_noteCache.inflightPost).forEach(abortRequest5);
      if (_changeset.inflight)
        abortRequest5(_changeset.inflight);
      _tileCache = { toLoad: {}, loaded: {}, inflight: {}, seen: {}, rtree: new import_rbush10.default() };
      _noteCache = { toLoad: {}, loaded: {}, inflight: {}, inflightPost: {}, note: {}, closed: {}, rtree: new import_rbush10.default() };
      _userCache = { toLoad: {}, user: {} };
      _cachedApiStatus = void 0;
      _changeset = {};
      return this;
    },
    getConnectionId: function() {
      return _connectionID;
    },
    getUrlRoot: function() {
      return urlroot;
    },
    getApiUrlRoot: function() {
      return apiUrlroot;
    },
    changesetURL: function(changesetID) {
      return urlroot + "/changeset/" + changesetID;
    },
    changesetsURL: function(center, zoom) {
      var precision3 = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));
      return urlroot + "/history#map=" + Math.floor(zoom) + "/" + center[1].toFixed(precision3) + "/" + center[0].toFixed(precision3);
    },
    entityURL: function(entity) {
      return urlroot + "/" + entity.type + "/" + entity.osmId();
    },
    historyURL: function(entity) {
      return urlroot + "/" + entity.type + "/" + entity.osmId() + "/history";
    },
    userURL: function(username) {
      return urlroot + "/user/" + encodeURIComponent(username);
    },
    noteURL: function(note) {
      return urlroot + "/note/" + note.id;
    },
    noteReportURL: function(note) {
      return urlroot + "/reports/new?reportable_type=Note&reportable_id=" + note.id;
    },
    // Generic method to load data from the OSM API
    // Can handle either auth or unauth calls.
    loadFromAPI: function(path, callback, options2) {
      options2 = Object.assign({ skipSeen: true }, options2);
      var that = this;
      var cid = _connectionID;
      function done(err, payload) {
        if (that.getConnectionId() !== cid) {
          if (callback)
            callback({ message: "Connection Switched", status: -1 });
          return;
        }
        var isAuthenticated = that.authenticated();
        if (isAuthenticated && err && err.status && (err.status === 400 || err.status === 401 || err.status === 403)) {
          that.logout();
          that.loadFromAPI(path, callback, options2);
        } else {
          if (!isAuthenticated && !_rateLimitError && err && err.status && (err.status === 509 || err.status === 429)) {
            _rateLimitError = err;
            dispatch10.call("change");
            that.reloadApiStatus();
          } else if (err && _cachedApiStatus === "online" || !err && _cachedApiStatus !== "online") {
            that.reloadApiStatus();
          }
          if (callback) {
            if (err) {
              return callback(err);
            } else {
              if (path.indexOf(".json") !== -1) {
                return parseJSON(payload, callback, options2);
              } else {
                return parseXML(payload, callback, options2);
              }
            }
          }
        }
      }
      if (this.authenticated()) {
        return oauth.xhr({
          method: "GET",
          path
        }, done);
      } else {
        var url = apiUrlroot + path;
        var controller = new AbortController();
        var fn;
        if (path.indexOf(".json") !== -1) {
          fn = json_default;
        } else {
          fn = xml_default;
        }
        fn(url, { signal: controller.signal }).then(function(data) {
          done(null, data);
        }).catch(function(err) {
          if (err.name === "AbortError")
            return;
          var match = err.message.match(/^\d{3}/);
          if (match) {
            done({ status: +match[0], statusText: err.message });
          } else {
            done(err.message);
          }
        });
        return controller;
      }
    },
    // Load a single entity by id (ways and relations use the `/full` call to include
    // nodes and members). Parent relations are not included, see `loadEntityRelations`.
    // GET /api/0.6/node/#id
    // GET /api/0.6/[way|relation]/#id/full
    loadEntity: function(id2, callback) {
      var type2 = osmEntity.id.type(id2);
      var osmID = osmEntity.id.toOSM(id2);
      var options2 = { skipSeen: false };
      this.loadFromAPI(
        "/api/0.6/" + type2 + "/" + osmID + (type2 !== "node" ? "/full" : "") + ".json",
        function(err, entities) {
          if (callback)
            callback(err, { data: entities });
        },
        options2
      );
    },
    // Load a single note by id , XML format
    // GET /api/0.6/notes/#id
    loadEntityNote: function(id2, callback) {
      var options2 = { skipSeen: false };
      this.loadFromAPI(
        "/api/0.6/notes/" + id2,
        function(err, entities) {
          if (callback)
            callback(err, { data: entities });
        },
        options2
      );
    },
    // Load a single entity with a specific version
    // GET /api/0.6/[node|way|relation]/#id/#version
    loadEntityVersion: function(id2, version, callback) {
      var type2 = osmEntity.id.type(id2);
      var osmID = osmEntity.id.toOSM(id2);
      var options2 = { skipSeen: false };
      this.loadFromAPI(
        "/api/0.6/" + type2 + "/" + osmID + "/" + version + ".json",
        function(err, entities) {
          if (callback)
            callback(err, { data: entities });
        },
        options2
      );
    },
    // Load the relations of a single entity with the given.
    // GET /api/0.6/[node|way|relation]/#id/relations
    loadEntityRelations: function(id2, callback) {
      var type2 = osmEntity.id.type(id2);
      var osmID = osmEntity.id.toOSM(id2);
      var options2 = { skipSeen: false };
      this.loadFromAPI(
        "/api/0.6/" + type2 + "/" + osmID + "/relations.json",
        function(err, entities) {
          if (callback)
            callback(err, { data: entities });
        },
        options2
      );
    },
    // Load multiple entities in chunks
    // (note: callback may be called multiple times)
    // Unlike `loadEntity`, child nodes and members are not fetched
    // GET /api/0.6/[nodes|ways|relations]?#parameters
    loadMultiple: function(ids, callback) {
      var that = this;
      var groups = utilArrayGroupBy(utilArrayUniq(ids), osmEntity.id.type);
      Object.keys(groups).forEach(function(k2) {
        var type2 = k2 + "s";
        var osmIDs = groups[k2].map(function(id2) {
          return osmEntity.id.toOSM(id2);
        });
        var options2 = { skipSeen: false };
        utilArrayChunk(osmIDs, 150).forEach(function(arr) {
          that.loadFromAPI(
            "/api/0.6/" + type2 + ".json?" + type2 + "=" + arr.join(),
            function(err, entities) {
              if (callback)
                callback(err, { data: entities });
            },
            options2
          );
        });
      });
    },
    // Create, upload, and close a changeset
    // PUT /api/0.6/changeset/create
    // POST /api/0.6/changeset/#id/upload
    // PUT /api/0.6/changeset/#id/close
    putChangeset: function(changeset, changes, callback) {
      var cid = _connectionID;
      if (_changeset.inflight) {
        return callback({ message: "Changeset already inflight", status: -2 }, changeset);
      } else if (_changeset.open) {
        return createdChangeset.call(this, null, _changeset.open);
      } else {
        var options2 = {
          method: "PUT",
          path: "/api/0.6/changeset/create",
          headers: { "Content-Type": "text/xml" },
          content: JXON.stringify(changeset.asJXON())
        };
        _changeset.inflight = oauth.xhr(
          options2,
          wrapcb(this, createdChangeset, cid)
        );
      }
      function createdChangeset(err, changesetID) {
        _changeset.inflight = null;
        if (err) {
          return callback(err, changeset);
        }
        _changeset.open = changesetID;
        changeset = changeset.update({ id: changesetID });
        var options3 = {
          method: "POST",
          path: "/api/0.6/changeset/" + changesetID + "/upload",
          headers: { "Content-Type": "text/xml" },
          content: JXON.stringify(changeset.osmChangeJXON(changes))
        };
        _changeset.inflight = oauth.xhr(
          options3,
          wrapcb(this, uploadedChangeset, cid)
        );
      }
      function uploadedChangeset(err) {
        _changeset.inflight = null;
        if (err)
          return callback(err, changeset);
        window.setTimeout(function() {
          callback(null, changeset);
        }, 2500);
        _changeset.open = null;
        if (this.getConnectionId() === cid) {
          oauth.xhr({
            method: "PUT",
            path: "/api/0.6/changeset/" + changeset.id + "/close",
            headers: { "Content-Type": "text/xml" }
          }, function() {
            return true;
          });
        }
      }
    },
    // Load multiple users in chunks
    // (note: callback may be called multiple times)
    // GET /api/0.6/users?users=#id1,#id2,...,#idn
    loadUsers: function(uids, callback) {
      var toLoad = [];
      var cached = [];
      utilArrayUniq(uids).forEach(function(uid) {
        if (_userCache.user[uid]) {
          delete _userCache.toLoad[uid];
          cached.push(_userCache.user[uid]);
        } else {
          toLoad.push(uid);
        }
      });
      if (cached.length || !this.authenticated()) {
        callback(void 0, cached);
        if (!this.authenticated())
          return;
      }
      utilArrayChunk(toLoad, 150).forEach((function(arr) {
        oauth.xhr({
          method: "GET",
          path: "/api/0.6/users.json?users=" + arr.join()
        }, wrapcb(this, done, _connectionID));
      }).bind(this));
      function done(err, payload) {
        if (err)
          return callback(err);
        var options2 = { skipSeen: true };
        return parseUserJSON(payload, function(err2, results) {
          if (err2)
            return callback(err2);
          return callback(void 0, results);
        }, options2);
      }
    },
    // Load a given user by id
    // GET /api/0.6/user/#id
    loadUser: function(uid, callback) {
      if (_userCache.user[uid] || !this.authenticated()) {
        delete _userCache.toLoad[uid];
        return callback(void 0, _userCache.user[uid]);
      }
      oauth.xhr({
        method: "GET",
        path: "/api/0.6/user/" + uid + ".json"
      }, wrapcb(this, done, _connectionID));
      function done(err, payload) {
        if (err)
          return callback(err);
        var options2 = { skipSeen: true };
        return parseUserJSON(payload, function(err2, results) {
          if (err2)
            return callback(err2);
          return callback(void 0, results[0]);
        }, options2);
      }
    },
    // Load the details of the logged-in user
    // GET /api/0.6/user/details
    userDetails: function(callback) {
      if (_userDetails) {
        return callback(void 0, _userDetails);
      }
      oauth.xhr({
        method: "GET",
        path: "/api/0.6/user/details.json"
      }, wrapcb(this, done, _connectionID));
      function done(err, payload) {
        if (err)
          return callback(err);
        var options2 = { skipSeen: false };
        return parseUserJSON(payload, function(err2, results) {
          if (err2)
            return callback(err2);
          _userDetails = results[0];
          return callback(void 0, _userDetails);
        }, options2);
      }
    },
    // Load previous changesets for the logged in user
    // GET /api/0.6/changesets?user=#id
    userChangesets: function(callback) {
      if (_userChangesets) {
        return callback(void 0, _userChangesets);
      }
      this.userDetails(
        wrapcb(this, gotDetails, _connectionID)
      );
      function gotDetails(err, user) {
        if (err) {
          return callback(err);
        }
        oauth.xhr({
          method: "GET",
          path: "/api/0.6/changesets?user=" + user.id
        }, wrapcb(this, done, _connectionID));
      }
      function done(err, xml) {
        if (err) {
          return callback(err);
        }
        _userChangesets = Array.prototype.map.call(
          xml.getElementsByTagName("changeset"),
          function(changeset) {
            return { tags: getTags(changeset) };
          }
        ).filter(function(changeset) {
          var comment = changeset.tags.comment;
          return comment && comment !== "";
        });
        return callback(void 0, _userChangesets);
      }
    },
    // Fetch the status of the OSM API
    // GET /api/capabilities
    status: function(callback) {
      var url = apiUrlroot + "/api/capabilities";
      var errback = wrapcb(this, done, _connectionID);
      xml_default(url).then(function(data) {
        errback(null, data);
      }).catch(function(err) {
        errback(err.message);
      });
      function done(err, xml) {
        if (err) {
          return callback(err, null);
        }
        var elements = xml.getElementsByTagName("blacklist");
        var regexes = [];
        for (var i3 = 0; i3 < elements.length; i3++) {
          var regexString = elements[i3].getAttribute("regex");
          if (regexString) {
            try {
              var regex = new RegExp(regexString);
              regexes.push(regex);
            } catch {
            }
          }
        }
        if (regexes.length) {
          _imageryBlocklists = regexes;
        }
        if (_rateLimitError) {
          return callback(_rateLimitError, "rateLimited");
        } else {
          var waynodes = xml.getElementsByTagName("waynodes");
          var maxWayNodes = waynodes.length && parseInt(waynodes[0].getAttribute("maximum"), 10);
          if (maxWayNodes && isFinite(maxWayNodes))
            _maxWayNodes = maxWayNodes;
          var apiStatus = xml.getElementsByTagName("status");
          var val = apiStatus[0].getAttribute("api");
          return callback(void 0, val);
        }
      }
    },
    // Calls `status` and dispatches an `apiStatusChange` event if the returned
    // status differs from the cached status.
    reloadApiStatus: function() {
      if (!this.throttledReloadApiStatus) {
        var that = this;
        this.throttledReloadApiStatus = throttle_default(function() {
          that.status(function(err, status) {
            if (status !== _cachedApiStatus) {
              _cachedApiStatus = status;
              dispatch10.call("apiStatusChange", that, err, status);
            }
          });
        }, 500);
      }
      this.throttledReloadApiStatus();
    },
    // Returns the maximum number of nodes a single way can have
    maxWayNodes: function() {
      return _maxWayNodes;
    },
    // Load data (entities) from the API in tiles
    // GET /api/0.6/map?bbox=
    loadTiles: function(projection2, callback) {
      if (_off)
        return;
      var tiles = tiler6.zoomExtent([_tileZoom4, _tileZoom4]).getTiles(projection2);
      var hadRequests = hasInflightRequests(_tileCache);
      abortUnwantedRequests4(_tileCache, tiles);
      if (hadRequests && !hasInflightRequests(_tileCache)) {
        dispatch10.call("loaded");
      }
      tiles.forEach(function(tile) {
        this.loadTile(tile, callback);
      }, this);
    },
    // Load a single data tile
    // GET /api/0.6/map?bbox=
    loadTile: function(tile, callback) {
      if (_off)
        return;
      if (_tileCache.loaded[tile.id] || _tileCache.inflight[tile.id])
        return;
      if (!hasInflightRequests(_tileCache)) {
        dispatch10.call("loading");
      }
      var path = "/api/0.6/map.json?bbox=";
      var options2 = { skipSeen: true };
      _tileCache.inflight[tile.id] = this.loadFromAPI(
        path + tile.extent.toParam(),
        tileCallback,
        options2
      );
      function tileCallback(err, parsed) {
        delete _tileCache.inflight[tile.id];
        if (!err) {
          delete _tileCache.toLoad[tile.id];
          _tileCache.loaded[tile.id] = true;
          var bbox2 = tile.extent.bbox();
          bbox2.id = tile.id;
          _tileCache.rtree.insert(bbox2);
        }
        if (callback) {
          callback(err, Object.assign({ data: parsed }, tile));
        }
        if (!hasInflightRequests(_tileCache)) {
          dispatch10.call("loaded");
        }
      }
    },
    isDataLoaded: function(loc) {
      var bbox2 = { minX: loc[0], minY: loc[1], maxX: loc[0], maxY: loc[1] };
      return _tileCache.rtree.collides(bbox2);
    },
    // load the tile that covers the given `loc`
    loadTileAtLoc: function(loc, callback) {
      if (Object.keys(_tileCache.toLoad).length > 50)
        return;
      var k2 = geoZoomToScale(_tileZoom4 + 1);
      var offset = geoRawMercator().scale(k2)(loc);
      var projection2 = geoRawMercator().transform({ k: k2, x: -offset[0], y: -offset[1] });
      var tiles = tiler6.zoomExtent([_tileZoom4, _tileZoom4]).getTiles(projection2);
      tiles.forEach(function(tile) {
        if (_tileCache.toLoad[tile.id] || _tileCache.loaded[tile.id] || _tileCache.inflight[tile.id])
          return;
        _tileCache.toLoad[tile.id] = true;
        this.loadTile(tile, callback);
      }, this);
    },
    // Load notes from the API in tiles
    // GET /api/0.6/notes?bbox=
    loadNotes: function(projection2, noteOptions) {
      noteOptions = Object.assign({ limit: 1e4, closed: 7 }, noteOptions);
      if (_off)
        return;
      var that = this;
      var path = "/api/0.6/notes?limit=" + noteOptions.limit + "&closed=" + noteOptions.closed + "&bbox=";
      var throttleLoadUsers = throttle_default(function() {
        var uids = Object.keys(_userCache.toLoad);
        if (!uids.length)
          return;
        that.loadUsers(uids, function() {
        });
      }, 750);
      var tiles = tiler6.zoomExtent([_noteZoom, _noteZoom]).getTiles(projection2);
      abortUnwantedRequests4(_noteCache, tiles);
      tiles.forEach(function(tile) {
        if (_noteCache.loaded[tile.id] || _noteCache.inflight[tile.id])
          return;
        var options2 = { skipSeen: false };
        _noteCache.inflight[tile.id] = that.loadFromAPI(
          path + tile.extent.toParam(),
          function(err) {
            delete _noteCache.inflight[tile.id];
            if (!err) {
              _noteCache.loaded[tile.id] = true;
            }
            throttleLoadUsers();
            dispatch10.call("loadedNotes");
          },
          options2
        );
      });
    },
    // Create a note
    // POST /api/0.6/notes?params
    postNoteCreate: function(note, callback) {
      if (!this.authenticated()) {
        return callback({ message: "Not Authenticated", status: -3 }, note);
      }
      if (_noteCache.inflightPost[note.id]) {
        return callback({ message: "Note update already inflight", status: -2 }, note);
      }
      if (!note.loc[0] || !note.loc[1] || !note.newComment)
        return;
      var comment = note.newComment;
      if (note.newCategory && note.newCategory !== "None") {
        comment += " #" + note.newCategory;
      }
      var path = "/api/0.6/notes?" + utilQsString({ lon: note.loc[0], lat: note.loc[1], text: comment });
      _noteCache.inflightPost[note.id] = oauth.xhr({
        method: "POST",
        path
      }, wrapcb(this, done, _connectionID));
      function done(err, xml) {
        delete _noteCache.inflightPost[note.id];
        if (err) {
          return callback(err);
        }
        this.removeNote(note);
        var options2 = { skipSeen: false };
        return parseXML(xml, function(err2, results) {
          if (err2) {
            return callback(err2);
          } else {
            return callback(void 0, results[0]);
          }
        }, options2);
      }
    },
    // Update a note
    // POST /api/0.6/notes/#id/comment?text=comment
    // POST /api/0.6/notes/#id/close?text=comment
    // POST /api/0.6/notes/#id/reopen?text=comment
    postNoteUpdate: function(note, newStatus, callback) {
      if (!this.authenticated()) {
        return callback({ message: "Not Authenticated", status: -3 }, note);
      }
      if (_noteCache.inflightPost[note.id]) {
        return callback({ message: "Note update already inflight", status: -2 }, note);
      }
      var action;
      if (note.status !== "closed" && newStatus === "closed") {
        action = "close";
      } else if (note.status !== "open" && newStatus === "open") {
        action = "reopen";
      } else {
        action = "comment";
        if (!note.newComment)
          return;
      }
      var path = "/api/0.6/notes/" + note.id + "/" + action;
      if (note.newComment) {
        path += "?" + utilQsString({ text: note.newComment });
      }
      _noteCache.inflightPost[note.id] = oauth.xhr({
        method: "POST",
        path
      }, wrapcb(this, done, _connectionID));
      function done(err, xml) {
        delete _noteCache.inflightPost[note.id];
        if (err) {
          return callback(err);
        }
        this.removeNote(note);
        if (action === "close") {
          _noteCache.closed[note.id] = true;
        } else if (action === "reopen") {
          delete _noteCache.closed[note.id];
        }
        var options2 = { skipSeen: false };
        return parseXML(xml, function(err2, results) {
          if (err2) {
            return callback(err2);
          } else {
            return callback(void 0, results[0]);
          }
        }, options2);
      }
    },
    /* connection options for source switcher (optional) */
    apiConnections: function(val) {
      if (!arguments.length)
        return _apiConnections;
      _apiConnections = val;
      return this;
    },
    switch: function(newOptions) {
      urlroot = newOptions.url;
      apiUrlroot = newOptions.apiUrl || urlroot;
      if (newOptions.url && !newOptions.apiUrl) {
        newOptions = {
          ...newOptions,
          apiUrl: newOptions.url
        };
      }
      const oldOptions = utilObjectOmit(oauth.options(), "access_token");
      oauth.options({ ...oldOptions, ...newOptions });
      this.reset();
      this.userChangesets(function() {
      });
      dispatch10.call("change");
      return this;
    },
    toggle: function(val) {
      _off = !val;
      return this;
    },
    isChangesetInflight: function() {
      return !!_changeset.inflight;
    },
    // get/set cached data
    // This is used to save/restore the state when entering/exiting the walkthrough
    // Also used for testing purposes.
    caches: function(obj) {
      function cloneCache(source) {
        var target = {};
        Object.keys(source).forEach(function(k2) {
          if (k2 === "rtree") {
            target.rtree = new import_rbush10.default().fromJSON(source.rtree.toJSON());
          } else if (k2 === "note") {
            target.note = {};
            Object.keys(source.note).forEach(function(id2) {
              target.note[id2] = osmNote(source.note[id2]);
            });
          } else {
            target[k2] = JSON.parse(JSON.stringify(source[k2]));
          }
        });
        return target;
      }
      if (!arguments.length) {
        return {
          tile: cloneCache(_tileCache),
          note: cloneCache(_noteCache),
          user: cloneCache(_userCache)
        };
      }
      if (obj === "get") {
        return {
          tile: _tileCache,
          note: _noteCache,
          user: _userCache
        };
      }
      if (obj.tile) {
        _tileCache = obj.tile;
        _tileCache.inflight = {};
      }
      if (obj.note) {
        _noteCache = obj.note;
        _noteCache.inflight = {};
        _noteCache.inflightPost = {};
      }
      if (obj.user) {
        _userCache = obj.user;
      }
      return this;
    },
    logout: function() {
      _userChangesets = void 0;
      _userDetails = void 0;
      oauth.logout();
      dispatch10.call("change");
      return this;
    },
    authenticated: function() {
      return oauth.authenticated();
    },
    authenticate: function(callback) {
      var that = this;
      var cid = _connectionID;
      _userChangesets = void 0;
      _userDetails = void 0;
      function done(err, res) {
        if (err) {
          if (callback)
            callback(err);
          return;
        }
        if (that.getConnectionId() !== cid) {
          if (callback)
            callback({ message: "Connection Switched", status: -1 });
          return;
        }
        _rateLimitError = void 0;
        dispatch10.call("change");
        if (callback)
          callback(err, res);
        that.userChangesets(function() {
        });
      }
      oauth.authenticate(done);
    },
    imageryBlocklists: function() {
      return _imageryBlocklists;
    },
    tileZoom: function(val) {
      if (!arguments.length)
        return _tileZoom4;
      _tileZoom4 = val;
      return this;
    },
    // get all cached notes covering the viewport
    notes: function(projection2) {
      var viewport = projection2.clipExtent();
      var min3 = [viewport[0][0], viewport[1][1]];
      var max3 = [viewport[1][0], viewport[0][1]];
      var bbox2 = geoExtent(projection2.invert(min3), projection2.invert(max3)).bbox();
      return _noteCache.rtree.search(bbox2).map(function(d2) {
        return d2.data;
      });
    },
    // get a single note from the cache
    getNote: function(id2) {
      return _noteCache.note[id2];
    },
    // remove a single note from the cache
    removeNote: function(note) {
      if (!(note instanceof osmNote) || !note.id)
        return;
      delete _noteCache.note[note.id];
      updateRtree4(encodeNoteRtree(note), false);
    },
    // replace a single note in the cache
    replaceNote: function(note) {
      if (!(note instanceof osmNote) || !note.id)
        return;
      _noteCache.note[note.id] = note;
      updateRtree4(encodeNoteRtree(note), true);
      return note;
    },
    // Get an array of note IDs closed during this session.
    // Used to populate `closed:note` changeset tag
    getClosedIDs: function() {
      return Object.keys(_noteCache.closed).sort();
    }
  };

  // modules/services/osm_wikibase.js
  var apibase3 = "https://wiki.openstreetmap.org/w/api.php";
  var _inflight2 = {};
  var _wikibaseCache = {};
  var _localeIDs = { en: false };
  var debouncedRequest = debounce_default(request, 500, { leading: false });
  function request(url, callback) {
    if (_inflight2[url])
      return;
    var controller = new AbortController();
    _inflight2[url] = controller;
    json_default(url, { signal: controller.signal }).then(function(result) {
      delete _inflight2[url];
      if (callback)
        callback(null, result);
    }).catch(function(err) {
      delete _inflight2[url];
      if (err.name === "AbortError")
        return;
      if (callback)
        callback(err.message);
    });
  }
  var osm_wikibase_default = {
    init: function() {
      _inflight2 = {};
      _wikibaseCache = {};
      _localeIDs = {};
    },
    reset: function() {
      Object.values(_inflight2).forEach(function(controller) {
        controller.abort();
      });
      _inflight2 = {};
    },
    /**
     * Get the best value for the property, or undefined if not found
     * @param entity object from wikibase
     * @param property string e.g. 'P4' for image
     * @param langCode string e.g. 'fr' for French
     */
    claimToValue: function(entity, property, langCode) {
      if (!entity.claims[property])
        return void 0;
      var locale2 = _localeIDs[langCode];
      var preferredPick, localePick;
      entity.claims[property].forEach(function(stmt) {
        if (!preferredPick && stmt.rank === "preferred") {
          preferredPick = stmt;
        }
        if (locale2 && stmt.qualifiers && stmt.qualifiers.P26 && stmt.qualifiers.P26[0].datavalue.value.id === locale2) {
          localePick = stmt;
        }
      });
      var result = localePick || preferredPick;
      if (result) {
        var datavalue = result.mainsnak.datavalue;
        return datavalue.type === "wikibase-entityid" ? datavalue.value.id : datavalue.value;
      } else {
        return void 0;
      }
    },
    /**
     * Convert monolingual property into a key-value object (language -> value)
     * @param entity object from wikibase
     * @param property string e.g. 'P31' for monolingual wiki page title
     */
    monolingualClaimToValueObj: function(entity, property) {
      if (!entity || !entity.claims[property])
        return void 0;
      return entity.claims[property].reduce(function(acc, obj) {
        var value = obj.mainsnak.datavalue.value;
        acc[value.language] = value.text;
        return acc;
      }, {});
    },
    toSitelink: function(key, value) {
      var result = value ? "Tag:" + key + "=" + value : "Key:" + key;
      return result.replace(/_/g, " ").trim();
    },
    //
    // Pass params object of the form:
    // {
    //   key: 'string',
    //   value: 'string',
    //   langCode: 'string'
    // }
    //
    getEntity: function(params, callback) {
      var doRequest = params.debounce ? debouncedRequest : request;
      var that = this;
      var titles = [];
      var result = {};
      var rtypeSitelink = params.key === "type" && params.value ? ("Relation:" + params.value).replace(/_/g, " ").trim() : false;
      var keySitelink = params.key ? this.toSitelink(params.key) : false;
      var tagSitelink = params.key && params.value ? this.toSitelink(params.key, params.value) : false;
      var localeSitelink;
      if (params.langCodes) {
        params.langCodes.forEach(function(langCode) {
          if (_localeIDs[langCode] === void 0) {
            localeSitelink = ("Locale:" + langCode).replace(/_/g, " ").trim();
            titles.push(localeSitelink);
          }
        });
      }
      if (rtypeSitelink) {
        if (_wikibaseCache[rtypeSitelink]) {
          result.rtype = _wikibaseCache[rtypeSitelink];
        } else {
          titles.push(rtypeSitelink);
        }
      }
      if (keySitelink) {
        if (_wikibaseCache[keySitelink]) {
          result.key = _wikibaseCache[keySitelink];
        } else {
          titles.push(keySitelink);
        }
      }
      if (tagSitelink) {
        if (_wikibaseCache[tagSitelink]) {
          result.tag = _wikibaseCache[tagSitelink];
        } else {
          titles.push(tagSitelink);
        }
      }
      if (!titles.length) {
        return callback(null, result);
      }
      var obj = {
        action: "wbgetentities",
        sites: "wiki",
        titles: titles.join("|"),
        languages: params.langCodes.join("|"),
        languagefallback: 1,
        origin: "*",
        format: "json"
        // There is an MW Wikibase API bug https://phabricator.wikimedia.org/T212069
        // We shouldn't use v1 until it gets fixed, but should switch to it afterwards
        // formatversion: 2,
      };
      var url = apibase3 + "?" + utilQsString(obj);
      doRequest(url, function(err, d2) {
        if (err) {
          callback(err);
        } else if (!d2.success || d2.error) {
          callback(d2.error.messages.map(function(v2) {
            return v2.html["*"];
          }).join("<br>"));
        } else {
          var localeID = false;
          Object.values(d2.entities).forEach(function(res) {
            if (res.missing !== "") {
              var title = res.sitelinks.wiki.title;
              if (title === rtypeSitelink) {
                _wikibaseCache[rtypeSitelink] = res;
                result.rtype = res;
              } else if (title === keySitelink) {
                _wikibaseCache[keySitelink] = res;
                result.key = res;
              } else if (title === tagSitelink) {
                _wikibaseCache[tagSitelink] = res;
                result.tag = res;
              } else if (title === localeSitelink) {
                localeID = res.id;
              } else {
                console.log("Unexpected title " + title);
              }
            }
          });
          if (localeSitelink) {
            that.addLocale(params.langCodes[0], localeID);
          }
          callback(null, result);
        }
      });
    },
    //
    // Pass params object of the form:
    // {
    //   key: 'string',     // required
    //   value: 'string'    // optional
    // }
    //
    // Get an result object used to display tag documentation
    // {
    //   title:        'string',
    //   description:  'string',
    //   editURL:      'string',
    //   imageURL:     'string',
    //   wiki:         { title: 'string', text: 'string', url: 'string' }
    // }
    //
    getDocs: function(params, callback) {
      var that = this;
      var langCodes = _mainLocalizer.localeCodes().map(function(code) {
        return code.toLowerCase();
      });
      params.langCodes = langCodes;
      this.getEntity(params, function(err, data) {
        if (err) {
          callback(err);
          return;
        }
        var entity = data.rtype || data.tag || data.key;
        if (!entity) {
          callback("No entity");
          return;
        }
        var i3;
        var description;
        for (i3 in langCodes) {
          let code2 = langCodes[i3];
          if (entity.descriptions[code2] && entity.descriptions[code2].language === code2) {
            description = entity.descriptions[code2];
            break;
          }
        }
        if (!description && Object.values(entity.descriptions).length)
          description = Object.values(entity.descriptions)[0];
        var result = {
          title: entity.title,
          description: description ? description.value : "",
          descriptionLocaleCode: description ? description.language : "",
          editURL: "https://wiki.openstreetmap.org/wiki/" + entity.title
        };
        if (entity.claims) {
          var imageroot;
          var image = that.claimToValue(entity, "P4", langCodes[0]);
          if (image) {
            imageroot = "https://commons.wikimedia.org/w/index.php";
          } else {
            image = that.claimToValue(entity, "P28", langCodes[0]);
            if (image) {
              imageroot = "https://wiki.openstreetmap.org/w/index.php";
            }
          }
          if (imageroot && image) {
            result.imageURL = imageroot + "?" + utilQsString({
              title: "Special:Redirect/file/" + image,
              width: 400
            });
          }
        }
        var rtypeWiki = that.monolingualClaimToValueObj(data.rtype, "P31");
        var tagWiki = that.monolingualClaimToValueObj(data.tag, "P31");
        var keyWiki = that.monolingualClaimToValueObj(data.key, "P31");
        var wikis = [rtypeWiki, tagWiki, keyWiki];
        for (i3 in wikis) {
          var wiki = wikis[i3];
          for (var j2 in langCodes) {
            var code = langCodes[j2];
            var referenceId = langCodes[0].split("-")[0] !== "en" && code.split("-")[0] === "en" ? "inspector.wiki_en_reference" : "inspector.wiki_reference";
            var info = getWikiInfo(wiki, code, referenceId);
            if (info) {
              result.wiki = info;
              break;
            }
          }
          if (result.wiki)
            break;
        }
        callback(null, result);
        function getWikiInfo(wiki2, langCode, tKey) {
          if (wiki2 && wiki2[langCode]) {
            return {
              title: wiki2[langCode],
              text: tKey,
              url: "https://wiki.openstreetmap.org/wiki/" + wiki2[langCode]
            };
          }
        }
      });
    },
    addLocale: function(langCode, qid) {
      _localeIDs[langCode] = qid;
    },
    apibase: function(val) {
      if (!arguments.length)
        return apibase3;
      apibase3 = val;
      return this;
    }
  };

  // modules/services/streetside.js
  var import_rbush11 = __toESM(require_rbush_min());
  var streetsideApi = "https://dev.virtualearth.net/REST/v1/Imagery/MetaData/Streetside?mapArea={bbox}&key={key}&count={count}";
  var maxResults2 = 500;
  var bubbleAppKey = utilAesDecrypt("5c875730b09c6b422433e807e1ff060b6536c791dbfffcffc4c6b18a1bdba1f14593d151adb50e19e1be1ab19aef813bf135d0f103475e5c724dec94389e45d0");
  var pannellumViewerCSS2 = "pannellum/pannellum.css";
  var pannellumViewerJS2 = "pannellum/pannellum.js";
  var tileZoom3 = 16.5;
  var tiler7 = utilTiler().zoomExtent([tileZoom3, tileZoom3]).skipNullIsland(true);
  var dispatch11 = dispatch_default("loadedImages", "viewerChanged");
  var minHfov = 10;
  var maxHfov = 90;
  var defaultHfov = 45;
  var _hires = false;
  var _resolution = 512;
  var _currScene = 0;
  var _ssCache;
  var _pannellumViewer2;
  var _sceneOptions = {
    showFullscreenCtrl: false,
    autoLoad: true,
    compass: true,
    yaw: 0,
    minHfov,
    maxHfov,
    hfov: defaultHfov,
    type: "cubemap",
    cubeMap: []
  };
  var _loadViewerPromise4;
  function abortRequest6(i3) {
    i3.abort();
  }
  function localeTimestamp2(s2) {
    if (!s2)
      return null;
    const options2 = { day: "numeric", month: "short", year: "numeric" };
    const d2 = new Date(s2);
    if (isNaN(d2.getTime()))
      return null;
    return d2.toLocaleString(_mainLocalizer.localeCode(), options2);
  }
  function loadTiles3(which, url, projection2, margin) {
    const tiles = tiler7.margin(margin).getTiles(projection2);
    const cache = _ssCache[which];
    Object.keys(cache.inflight).forEach((k2) => {
      const wanted = tiles.find((tile) => k2.indexOf(tile.id + ",") === 0);
      if (!wanted) {
        abortRequest6(cache.inflight[k2]);
        delete cache.inflight[k2];
      }
    });
    tiles.forEach((tile) => loadNextTilePage2(which, url, tile));
  }
  function loadNextTilePage2(which, url, tile) {
    const cache = _ssCache[which];
    const nextPage = cache.nextPage[tile.id] || 0;
    const id2 = tile.id + "," + String(nextPage);
    if (cache.loaded[id2] || cache.inflight[id2])
      return;
    cache.inflight[id2] = getBubbles(url, tile, (response) => {
      cache.loaded[id2] = true;
      delete cache.inflight[id2];
      if (!response)
        return;
      if (response.resourceSets[0].resources.length === maxResults2) {
        const split = tile.extent.split();
        loadNextTilePage2(which, url, { id: tile.id + ",a", extent: split[0] });
        loadNextTilePage2(which, url, { id: tile.id + ",b", extent: split[1] });
        loadNextTilePage2(which, url, { id: tile.id + ",c", extent: split[2] });
        loadNextTilePage2(which, url, { id: tile.id + ",d", extent: split[3] });
      }
      const features = response.resourceSets[0].resources.map((bubble) => {
        const bubbleId = bubble.imageUrl;
        if (cache.points[bubbleId])
          return null;
        const loc = [bubble.lon, bubble.lat];
        const d2 = {
          loc,
          key: bubbleId,
          imageUrl: bubble.imageUrl.replace(
            "{subdomain}",
            bubble.imageUrlSubdomains[0]
          ),
          ca: bubble.he,
          captured_at: bubble.vintageEnd,
          captured_by: "microsoft",
          pano: true,
          sequenceKey: null
        };
        cache.points[bubbleId] = d2;
        return {
          minX: loc[0],
          minY: loc[1],
          maxX: loc[0],
          maxY: loc[1],
          data: d2
        };
      }).filter(Boolean);
      cache.rtree.load(features);
      if (which === "bubbles") {
        dispatch11.call("loadedImages");
      }
    });
  }
  function getBubbles(url, tile, callback) {
    let rect = tile.extent.rectangle();
    let urlForRequest = url.replace("{key}", bubbleAppKey).replace("{bbox}", [rect[1], rect[0], rect[3], rect[2]].join(",")).replace("{count}", maxResults2);
    const controller = new AbortController();
    fetch(urlForRequest, { signal: controller.signal }).then(function(response) {
      if (!response.ok) {
        throw new Error(response.status + " " + response.statusText);
      }
      return response.json();
    }).then(function(result) {
      if (!result) {
        callback(null);
      }
      return callback(result || []);
    }).catch(function(err) {
      if (err.name === "AbortError") {
      } else {
        throw new Error(err);
      }
    });
    return controller;
  }
  function partitionViewport4(projection2) {
    let z2 = geoScaleToZoom(projection2.scale());
    let z22 = Math.ceil(z2 * 2) / 2 + 2.5;
    let tiler9 = utilTiler().zoomExtent([z22, z22]);
    return tiler9.getTiles(projection2).map((tile) => tile.extent);
  }
  function searchLimited4(limit, projection2, rtree) {
    limit = limit || 5;
    return partitionViewport4(projection2).reduce((result, extent) => {
      let found = rtree.search(extent.bbox()).slice(0, limit).map((d2) => d2.data);
      return found.length ? result.concat(found) : result;
    }, []);
  }
  function loadImage2(imgInfo) {
    return new Promise((resolve) => {
      let img = new Image();
      img.onload = () => {
        let canvas = document.getElementById("ideditor-canvas" + imgInfo.face);
        let ctx = canvas.getContext("2d");
        ctx.drawImage(img, imgInfo.x, imgInfo.y);
        resolve({ imgInfo, status: "ok" });
      };
      img.onerror = () => {
        resolve({ data: imgInfo, status: "error" });
      };
      img.setAttribute("crossorigin", "");
      img.src = imgInfo.url;
    });
  }
  function loadCanvas(imageGroup) {
    return Promise.all(imageGroup.map(loadImage2)).then((data) => {
      let canvas = document.getElementById("ideditor-canvas" + data[0].imgInfo.face);
      const which = { "01": 0, "02": 1, "03": 2, "10": 3, "11": 4, "12": 5 };
      let face = data[0].imgInfo.face;
      _sceneOptions.cubeMap[which[face]] = canvas.toDataURL("image/jpeg", 1);
      return { status: "loadCanvas for face " + data[0].imgInfo.face + "ok" };
    });
  }
  function loadFaces(faceGroup) {
    return Promise.all(faceGroup.map(loadCanvas)).then(() => {
      return { status: "loadFaces done" };
    });
  }
  function setupCanvas(selection2, reset) {
    if (reset) {
      selection2.selectAll("#ideditor-stitcher-canvases").remove();
    }
    selection2.selectAll("#ideditor-stitcher-canvases").data([0]).enter().append("div").attr("id", "ideditor-stitcher-canvases").attr("display", "none").selectAll("canvas").data(["canvas01", "canvas02", "canvas03", "canvas10", "canvas11", "canvas12"]).enter().append("canvas").attr("id", (d2) => "ideditor-" + d2).attr("width", _resolution).attr("height", _resolution);
  }
  function qkToXY(qk) {
    let x2 = 0;
    let y2 = 0;
    let scale = 256;
    for (let i3 = qk.length; i3 > 0; i3--) {
      const key = qk[i3 - 1];
      x2 += +(key === "1" || key === "3") * scale;
      y2 += +(key === "2" || key === "3") * scale;
      scale *= 2;
    }
    return [x2, y2];
  }
  function getQuadKeys() {
    let dim = _resolution / 256;
    let quadKeys;
    if (dim === 16) {
      quadKeys = [
        "0000",
        "0001",
        "0010",
        "0011",
        "0100",
        "0101",
        "0110",
        "0111",
        "1000",
        "1001",
        "1010",
        "1011",
        "1100",
        "1101",
        "1110",
        "1111",
        "0002",
        "0003",
        "0012",
        "0013",
        "0102",
        "0103",
        "0112",
        "0113",
        "1002",
        "1003",
        "1012",
        "1013",
        "1102",
        "1103",
        "1112",
        "1113",
        "0020",
        "0021",
        "0030",
        "0031",
        "0120",
        "0121",
        "0130",
        "0131",
        "1020",
        "1021",
        "1030",
        "1031",
        "1120",
        "1121",
        "1130",
        "1131",
        "0022",
        "0023",
        "0032",
        "0033",
        "0122",
        "0123",
        "0132",
        "0133",
        "1022",
        "1023",
        "1032",
        "1033",
        "1122",
        "1123",
        "1132",
        "1133",
        "0200",
        "0201",
        "0210",
        "0211",
        "0300",
        "0301",
        "0310",
        "0311",
        "1200",
        "1201",
        "1210",
        "1211",
        "1300",
        "1301",
        "1310",
        "1311",
        "0202",
        "0203",
        "0212",
        "0213",
        "0302",
        "0303",
        "0312",
        "0313",
        "1202",
        "1203",
        "1212",
        "1213",
        "1302",
        "1303",
        "1312",
        "1313",
        "0220",
        "0221",
        "0230",
        "0231",
        "0320",
        "0321",
        "0330",
        "0331",
        "1220",
        "1221",
        "1230",
        "1231",
        "1320",
        "1321",
        "1330",
        "1331",
        "0222",
        "0223",
        "0232",
        "0233",
        "0322",
        "0323",
        "0332",
        "0333",
        "1222",
        "1223",
        "1232",
        "1233",
        "1322",
        "1323",
        "1332",
        "1333",
        "2000",
        "2001",
        "2010",
        "2011",
        "2100",
        "2101",
        "2110",
        "2111",
        "3000",
        "3001",
        "3010",
        "3011",
        "3100",
        "3101",
        "3110",
        "3111",
        "2002",
        "2003",
        "2012",
        "2013",
        "2102",
        "2103",
        "2112",
        "2113",
        "3002",
        "3003",
        "3012",
        "3013",
        "3102",
        "3103",
        "3112",
        "3113",
        "2020",
        "2021",
        "2030",
        "2031",
        "2120",
        "2121",
        "2130",
        "2131",
        "3020",
        "3021",
        "3030",
        "3031",
        "3120",
        "3121",
        "3130",
        "3131",
        "2022",
        "2023",
        "2032",
        "2033",
        "2122",
        "2123",
        "2132",
        "2133",
        "3022",
        "3023",
        "3032",
        "3033",
        "3122",
        "3123",
        "3132",
        "3133",
        "2200",
        "2201",
        "2210",
        "2211",
        "2300",
        "2301",
        "2310",
        "2311",
        "3200",
        "3201",
        "3210",
        "3211",
        "3300",
        "3301",
        "3310",
        "3311",
        "2202",
        "2203",
        "2212",
        "2213",
        "2302",
        "2303",
        "2312",
        "2313",
        "3202",
        "3203",
        "3212",
        "3213",
        "3302",
        "3303",
        "3312",
        "3313",
        "2220",
        "2221",
        "2230",
        "2231",
        "2320",
        "2321",
        "2330",
        "2331",
        "3220",
        "3221",
        "3230",
        "3231",
        "3320",
        "3321",
        "3330",
        "3331",
        "2222",
        "2223",
        "2232",
        "2233",
        "2322",
        "2323",
        "2332",
        "2333",
        "3222",
        "3223",
        "3232",
        "3233",
        "3322",
        "3323",
        "3332",
        "3333"
      ];
    } else if (dim === 8) {
      quadKeys = [
        "000",
        "001",
        "010",
        "011",
        "100",
        "101",
        "110",
        "111",
        "002",
        "003",
        "012",
        "013",
        "102",
        "103",
        "112",
        "113",
        "020",
        "021",
        "030",
        "031",
        "120",
        "121",
        "130",
        "131",
        "022",
        "023",
        "032",
        "033",
        "122",
        "123",
        "132",
        "133",
        "200",
        "201",
        "210",
        "211",
        "300",
        "301",
        "310",
        "311",
        "202",
        "203",
        "212",
        "213",
        "302",
        "303",
        "312",
        "313",
        "220",
        "221",
        "230",
        "231",
        "320",
        "321",
        "330",
        "331",
        "222",
        "223",
        "232",
        "233",
        "322",
        "323",
        "332",
        "333"
      ];
    } else if (dim === 4) {
      quadKeys = [
        "00",
        "01",
        "10",
        "11",
        "02",
        "03",
        "12",
        "13",
        "20",
        "21",
        "30",
        "31",
        "22",
        "23",
        "32",
        "33"
      ];
    } else {
      quadKeys = [
        "0",
        "1",
        "2",
        "3"
      ];
    }
    return quadKeys;
  }
  var streetside_default = {
    /**
     * init() initialize streetside.
     */
    init: function() {
      if (!_ssCache) {
        this.reset();
      }
      this.event = utilRebind(this, dispatch11, "on");
    },
    /**
     * reset() reset the cache.
     */
    reset: function() {
      if (_ssCache) {
        Object.values(_ssCache.bubbles.inflight).forEach(abortRequest6);
      }
      _ssCache = {
        bubbles: { inflight: {}, loaded: {}, nextPage: {}, rtree: new import_rbush11.default(), points: {} },
        sequences: {}
      };
    },
    /**
     * bubbles()
     */
    bubbles: function(projection2) {
      const limit = 5;
      return searchLimited4(limit, projection2, _ssCache.bubbles.rtree);
    },
    cachedImage: function(imageKey) {
      return _ssCache.bubbles.points[imageKey];
    },
    sequences: function(projection2) {
      const viewport = projection2.clipExtent();
      const min3 = [viewport[0][0], viewport[1][1]];
      const max3 = [viewport[1][0], viewport[0][1]];
      const bbox2 = geoExtent(projection2.invert(min3), projection2.invert(max3)).bbox();
      let seen = {};
      let results = [];
      _ssCache.bubbles.rtree.search(bbox2).forEach((d2) => {
        const key = d2.data.sequenceKey;
        if (key && !seen[key]) {
          seen[key] = true;
          results.push(_ssCache.sequences[key].geojson);
        }
      });
      return results;
    },
    /**
     * loadBubbles()
     */
    loadBubbles: function(projection2, margin) {
      if (margin === void 0)
        margin = 2;
      loadTiles3("bubbles", streetsideApi, projection2, margin);
    },
    viewer: function() {
      return _pannellumViewer2;
    },
    initViewer: function() {
      if (!window.pannellum)
        return;
      if (_pannellumViewer2)
        return;
      _currScene += 1;
      const sceneID = _currScene.toString();
      const options2 = {
        "default": { firstScene: sceneID },
        scenes: {}
      };
      options2.scenes[sceneID] = _sceneOptions;
      _pannellumViewer2 = window.pannellum.viewer("ideditor-viewer-streetside", options2);
    },
    ensureViewerLoaded: function(context) {
      if (_loadViewerPromise4)
        return _loadViewerPromise4;
      let wrap2 = context.container().select(".photoviewer").selectAll(".ms-wrapper").data([0]);
      let wrapEnter = wrap2.enter().append("div").attr("class", "photo-wrapper ms-wrapper").classed("hide", true);
      let that = this;
      let pointerPrefix = "PointerEvent" in window ? "pointer" : "mouse";
      wrapEnter.append("div").attr("id", "ideditor-viewer-streetside").on(pointerPrefix + "down.streetside", () => {
        select_default2(window).on(pointerPrefix + "move.streetside", () => {
          dispatch11.call("viewerChanged");
        }, true);
      }).on(pointerPrefix + "up.streetside pointercancel.streetside", () => {
        select_default2(window).on(pointerPrefix + "move.streetside", null);
        let t2 = timer((elapsed) => {
          dispatch11.call("viewerChanged");
          if (elapsed > 2e3) {
            t2.stop();
          }
        });
      }).append("div").attr("class", "photo-attribution fillD");
      let controlsEnter = wrapEnter.append("div").attr("class", "photo-controls-wrap").append("div").attr("class", "photo-controls");
      controlsEnter.append("button").on("click.back", step(-1)).text("\u25C4");
      controlsEnter.append("button").on("click.forward", step(1)).text("\u25BA");
      wrap2 = wrap2.merge(wrapEnter).call(setupCanvas, true);
      context.ui().photoviewer.on("resize.streetside", () => {
        if (_pannellumViewer2) {
          _pannellumViewer2.resize();
        }
      });
      _loadViewerPromise4 = new Promise((resolve, reject) => {
        let loadedCount = 0;
        function loaded() {
          loadedCount += 1;
          if (loadedCount === 2)
            resolve();
        }
        const head = select_default2("head");
        head.selectAll("#ideditor-streetside-viewercss").data([0]).enter().append("link").attr("id", "ideditor-streetside-viewercss").attr("rel", "stylesheet").attr("crossorigin", "anonymous").attr("href", context.asset(pannellumViewerCSS2)).on("load.serviceStreetside", loaded).on("error.serviceStreetside", function() {
          reject();
        });
        head.selectAll("#ideditor-streetside-viewerjs").data([0]).enter().append("script").attr("id", "ideditor-streetside-viewerjs").attr("crossorigin", "anonymous").attr("src", context.asset(pannellumViewerJS2)).on("load.serviceStreetside", loaded).on("error.serviceStreetside", function() {
          reject();
        });
      }).catch(function() {
        _loadViewerPromise4 = null;
      });
      return _loadViewerPromise4;
      function step(stepBy) {
        return () => {
          let viewer = context.container().select(".photoviewer");
          let selected = viewer.empty() ? void 0 : viewer.datum();
          if (!selected)
            return;
          let nextID = stepBy === 1 ? selected.ne : selected.pr;
          let yaw = _pannellumViewer2.getYaw();
          let ca = selected.ca + yaw;
          let origin = selected.loc;
          const meters = 35;
          let p1 = [
            origin[0] + geoMetersToLon(meters / 5, origin[1]),
            origin[1]
          ];
          let p2 = [
            origin[0] + geoMetersToLon(meters / 2, origin[1]),
            origin[1] + geoMetersToLat(meters)
          ];
          let p3 = [
            origin[0] - geoMetersToLon(meters / 2, origin[1]),
            origin[1] + geoMetersToLat(meters)
          ];
          let p4 = [
            origin[0] - geoMetersToLon(meters / 5, origin[1]),
            origin[1]
          ];
          let poly = [p1, p2, p3, p4, p1];
          let angle2 = (stepBy === 1 ? ca : ca + 180) * (Math.PI / 180);
          poly = geoRotate(poly, -angle2, origin);
          let extent = poly.reduce((extent2, point2) => {
            return extent2.extend(geoExtent(point2));
          }, geoExtent());
          let minDist = Infinity;
          _ssCache.bubbles.rtree.search(extent.bbox()).forEach((d2) => {
            if (d2.data.key === selected.key)
              return;
            if (!geoPointInPolygon(d2.data.loc, poly))
              return;
            let dist = geoVecLength(d2.data.loc, selected.loc);
            let theta = selected.ca - d2.data.ca;
            let minTheta = Math.min(Math.abs(theta), 360 - Math.abs(theta));
            if (minTheta > 20) {
              dist += 5;
            }
            if (dist < minDist) {
              nextID = d2.data.key;
              minDist = dist;
            }
          });
          let nextBubble = nextID && that.cachedImage(nextID);
          if (!nextBubble)
            return;
          context.map().centerEase(nextBubble.loc);
          that.selectImage(context, nextBubble.key).yaw(yaw).showViewer(context);
        };
      }
    },
    yaw: function(yaw) {
      if (typeof yaw !== "number")
        return yaw;
      _sceneOptions.yaw = yaw;
      return this;
    },
    /**
     * showViewer()
     */
    showViewer: function(context) {
      let wrap2 = context.container().select(".photoviewer").classed("hide", false);
      let isHidden = wrap2.selectAll(".photo-wrapper.ms-wrapper.hide").size();
      if (isHidden) {
        wrap2.selectAll(".photo-wrapper:not(.ms-wrapper)").classed("hide", true);
        wrap2.selectAll(".photo-wrapper.ms-wrapper").classed("hide", false);
      }
      return this;
    },
    /**
     * hideViewer()
     */
    hideViewer: function(context) {
      let viewer = context.container().select(".photoviewer");
      if (!viewer.empty())
        viewer.datum(null);
      viewer.classed("hide", true).selectAll(".photo-wrapper").classed("hide", true);
      context.container().selectAll(".viewfield-group, .sequence, .icon-sign").classed("currentView", false);
      this.updateUrlImage(null);
      return this.setStyles(context, null, true);
    },
    /**
     * selectImage().
     */
    selectImage: function(context, key) {
      let that = this;
      let d2 = this.cachedImage(key);
      let viewer = context.container().select(".photoviewer");
      if (!viewer.empty())
        viewer.datum(d2);
      this.setStyles(context, null, true);
      let wrap2 = context.container().select(".photoviewer .ms-wrapper");
      let attribution = wrap2.selectAll(".photo-attribution").html("");
      wrap2.selectAll(".pnlm-load-box").style("display", "block");
      if (!d2)
        return this;
      this.updateUrlImage(key);
      _sceneOptions.northOffset = d2.ca;
      let line1 = attribution.append("div").attr("class", "attribution-row");
      const hiresDomId = utilUniqueDomId("streetside-hires");
      let label = line1.append("label").attr("for", hiresDomId).attr("class", "streetside-hires");
      label.append("input").attr("type", "checkbox").attr("id", hiresDomId).property("checked", _hires).on("click", (d3_event) => {
        d3_event.stopPropagation();
        _hires = !_hires;
        _resolution = _hires ? 1024 : 512;
        wrap2.call(setupCanvas, true);
        let viewstate = {
          yaw: _pannellumViewer2.getYaw(),
          pitch: _pannellumViewer2.getPitch(),
          hfov: _pannellumViewer2.getHfov()
        };
        _sceneOptions = Object.assign(_sceneOptions, viewstate);
        that.selectImage(context, d2.key).showViewer(context);
      });
      label.append("span").call(_t.append("streetside.hires"));
      let captureInfo = line1.append("div").attr("class", "attribution-capture-info");
      if (d2.captured_by) {
        const yyyy = (/* @__PURE__ */ new Date()).getFullYear();
        captureInfo.append("a").attr("class", "captured_by").attr("target", "_blank").attr("href", "https://www.microsoft.com/en-us/maps/streetside").text("\xA9" + yyyy + " Microsoft");
        captureInfo.append("span").text("|");
      }
      if (d2.captured_at) {
        captureInfo.append("span").attr("class", "captured_at").text(localeTimestamp2(d2.captured_at));
      }
      let line2 = attribution.append("div").attr("class", "attribution-row");
      line2.append("a").attr("class", "image-view-link").attr("target", "_blank").attr("href", "https://www.bing.com/maps?cp=" + d2.loc[1] + "~" + d2.loc[0] + "&lvl=17&dir=" + d2.ca + "&style=x&v=2&sV=1").call(_t.append("streetside.view_on_bing"));
      line2.append("a").attr("class", "image-report-link").attr("target", "_blank").attr("href", "https://www.bing.com/maps/privacyreport/streetsideprivacyreport?bubbleid=" + encodeURIComponent(d2.key) + "&focus=photo&lat=" + d2.loc[1] + "&lng=" + d2.loc[0] + "&z=17").call(_t.append("streetside.report"));
      const faceKeys = ["01", "02", "03", "10", "11", "12"];
      let quadKeys = getQuadKeys();
      let faces = faceKeys.map((faceKey) => {
        return quadKeys.map((quadKey) => {
          const xy = qkToXY(quadKey);
          return {
            face: faceKey,
            url: d2.imageUrl.replace("{faceId}", faceKey).replace("{tileId}", quadKey),
            x: xy[0],
            y: xy[1]
          };
        });
      });
      loadFaces(faces).then(function() {
        if (!_pannellumViewer2) {
          that.initViewer();
        } else {
          _currScene += 1;
          let sceneID = _currScene.toString();
          _pannellumViewer2.addScene(sceneID, _sceneOptions).loadScene(sceneID);
          if (_currScene > 2) {
            sceneID = (_currScene - 1).toString();
            _pannellumViewer2.removeScene(sceneID);
          }
        }
      });
      return this;
    },
    getSequenceKeyForBubble: function(d2) {
      return d2 && d2.sequenceKey;
    },
    // Updates the currently highlighted sequence and selected bubble.
    // Reset is only necessary when interacting with the viewport because
    // this implicitly changes the currently selected bubble/sequence
    setStyles: function(context, hovered, reset) {
      if (reset) {
        context.container().selectAll(".viewfield-group").classed("highlighted", false).classed("hovered", false).classed("currentView", false);
        context.container().selectAll(".sequence").classed("highlighted", false).classed("currentView", false);
      }
      let hoveredBubbleKey = hovered && hovered.key;
      let hoveredSequenceKey = this.getSequenceKeyForBubble(hovered);
      let hoveredSequence = hoveredSequenceKey && _ssCache.sequences[hoveredSequenceKey];
      let hoveredBubbleKeys = hoveredSequence && hoveredSequence.bubbles.map((d2) => d2.key) || [];
      let viewer = context.container().select(".photoviewer");
      let selected = viewer.empty() ? void 0 : viewer.datum();
      let selectedBubbleKey = selected && selected.key;
      let selectedSequenceKey = this.getSequenceKeyForBubble(selected);
      let selectedSequence = selectedSequenceKey && _ssCache.sequences[selectedSequenceKey];
      let selectedBubbleKeys = selectedSequence && selectedSequence.bubbles.map((d2) => d2.key) || [];
      let highlightedBubbleKeys = utilArrayUnion(hoveredBubbleKeys, selectedBubbleKeys);
      context.container().selectAll(".layer-streetside-images .viewfield-group").classed("highlighted", (d2) => highlightedBubbleKeys.indexOf(d2.key) !== -1).classed("hovered", (d2) => d2.key === hoveredBubbleKey).classed("currentView", (d2) => d2.key === selectedBubbleKey);
      context.container().selectAll(".layer-streetside-images .sequence").classed("highlighted", (d2) => d2.properties.key === hoveredSequenceKey).classed("currentView", (d2) => d2.properties.key === selectedSequenceKey);
      context.container().selectAll(".layer-streetside-images .viewfield-group .viewfield").attr("d", viewfieldPath);
      function viewfieldPath() {
        let d2 = this.parentNode.__data__;
        if (d2.pano && d2.key !== selectedBubbleKey) {
          return "M 8,13 m -10,0 a 10,10 0 1,0 20,0 a 10,10 0 1,0 -20,0";
        } else {
          return "M 6,9 C 8,8.4 8,8.4 10,9 L 16,-2 C 12,-5 4,-5 0,-2 z";
        }
      }
      return this;
    },
    updateUrlImage: function(imageKey) {
      if (!window.mocha) {
        var hash = utilStringQs(window.location.hash);
        if (imageKey) {
          hash.photo = "streetside/" + imageKey;
        } else {
          delete hash.photo;
        }
        window.location.replace("#" + utilQsString(hash, true));
      }
    },
    /**
     * cache().
     */
    cache: function() {
      return _ssCache;
    }
  };

  // modules/services/taginfo.js
  var apibase4 = taginfoApiUrl;
  var _inflight3 = {};
  var _popularKeys = {};
  var _taginfoCache = {};
  var tag_sorts = {
    point: "count_nodes",
    vertex: "count_nodes",
    area: "count_ways",
    line: "count_ways"
  };
  var tag_sort_members = {
    point: "count_node_members",
    vertex: "count_node_members",
    area: "count_way_members",
    line: "count_way_members",
    relation: "count_relation_members"
  };
  var tag_filters = {
    point: "nodes",
    vertex: "nodes",
    area: "ways",
    line: "ways"
  };
  var tag_members_fractions = {
    point: "count_node_members_fraction",
    vertex: "count_node_members_fraction",
    area: "count_way_members_fraction",
    line: "count_way_members_fraction",
    relation: "count_relation_members_fraction"
  };
  function sets(params, n3, o2) {
    if (params.geometry && o2[params.geometry]) {
      params[n3] = o2[params.geometry];
    }
    return params;
  }
  function setFilter(params) {
    return sets(params, "filter", tag_filters);
  }
  function setSort(params) {
    return sets(params, "sortname", tag_sorts);
  }
  function setSortMembers(params) {
    return sets(params, "sortname", tag_sort_members);
  }
  function clean(params) {
    return utilObjectOmit(params, ["geometry", "debounce"]);
  }
  function filterKeys(type2) {
    var count_type = type2 ? "count_" + type2 : "count_all";
    return function(d2) {
      return Number(d2[count_type]) > 2500 || d2.in_wiki;
    };
  }
  function filterMultikeys(prefix) {
    return function(d2) {
      var re3 = new RegExp("^" + prefix + "(.*)$", "i");
      var matches = d2.key.match(re3) || [];
      return matches.length === 2 && matches[1].indexOf(":") === -1;
    };
  }
  function filterValues(allowUpperCase) {
    return function(d2) {
      if (d2.value.match(/[;,]/) !== null)
        return false;
      if (!allowUpperCase && d2.value.match(/[A-Z*]/) !== null)
        return false;
      return d2.count > 100 || d2.in_wiki;
    };
  }
  function filterRoles(geometry) {
    return function(d2) {
      if (d2.role === "")
        return false;
      if (d2.role.match(/[A-Z*;,]/) !== null)
        return false;
      return Number(d2[tag_members_fractions[geometry]]) > 0;
    };
  }
  function valKey(d2) {
    return {
      value: d2.key,
      title: d2.key
    };
  }
  function valKeyDescription(d2) {
    var obj = {
      value: d2.value,
      title: d2.description || d2.value
    };
    return obj;
  }
  function roleKey(d2) {
    return {
      value: d2.role,
      title: d2.role
    };
  }
  function sortKeys(a2, b2) {
    return a2.key.indexOf(":") === -1 && b2.key.indexOf(":") !== -1 ? -1 : a2.key.indexOf(":") !== -1 && b2.key.indexOf(":") === -1 ? 1 : 0;
  }
  var debouncedRequest2 = debounce_default(request2, 300, { leading: false });
  function request2(url, params, exactMatch, callback, loaded) {
    if (_inflight3[url])
      return;
    if (checkCache(url, params, exactMatch, callback))
      return;
    var controller = new AbortController();
    _inflight3[url] = controller;
    json_default(url, { signal: controller.signal }).then(function(result) {
      delete _inflight3[url];
      if (loaded)
        loaded(null, result);
    }).catch(function(err) {
      delete _inflight3[url];
      if (err.name === "AbortError")
        return;
      if (loaded)
        loaded(err.message);
    });
  }
  function checkCache(url, params, exactMatch, callback) {
    var rp = params.rp || 25;
    var testQuery = params.query || "";
    var testUrl = url;
    do {
      var hit = _taginfoCache[testUrl];
      if (hit && (url === testUrl || hit.length < rp)) {
        callback(null, hit);
        return true;
      }
      if (exactMatch || !testQuery.length)
        return false;
      testQuery = testQuery.slice(0, -1);
      testUrl = url.replace(/&query=(.*?)&/, "&query=" + testQuery + "&");
    } while (testQuery.length >= 0);
    return false;
  }
  var taginfo_default = {
    init: function() {
      _inflight3 = {};
      _taginfoCache = {};
      _popularKeys = {
        // manually exclude some keys – #5377, #7485
        postal_code: true,
        full_name: true,
        loc_name: true,
        reg_name: true,
        short_name: true,
        sorting_name: true,
        artist_name: true,
        nat_name: true,
        long_name: true,
        via: true,
        "bridge:name": true
      };
      var params = {
        rp: 100,
        sortname: "values_all",
        sortorder: "desc",
        page: 1,
        debounce: false,
        lang: _mainLocalizer.languageCode()
      };
      this.keys(params, function(err, data) {
        if (err)
          return;
        data.forEach(function(d2) {
          if (d2.value === "opening_hours")
            return;
          _popularKeys[d2.value] = true;
        });
      });
    },
    reset: function() {
      Object.values(_inflight3).forEach(function(controller) {
        controller.abort();
      });
      _inflight3 = {};
    },
    keys: function(params, callback) {
      var doRequest = params.debounce ? debouncedRequest2 : request2;
      params = clean(setSort(params));
      params = Object.assign({
        rp: 10,
        sortname: "count_all",
        sortorder: "desc",
        page: 1,
        lang: _mainLocalizer.languageCode()
      }, params);
      var url = apibase4 + "keys/all?" + utilQsString(params);
      doRequest(url, params, false, callback, function(err, d2) {
        if (err) {
          callback(err);
        } else {
          var f2 = filterKeys(params.filter);
          var result = d2.data.filter(f2).sort(sortKeys).map(valKey);
          _taginfoCache[url] = result;
          callback(null, result);
        }
      });
    },
    multikeys: function(params, callback) {
      var doRequest = params.debounce ? debouncedRequest2 : request2;
      params = clean(setSort(params));
      params = Object.assign({
        rp: 25,
        sortname: "count_all",
        sortorder: "desc",
        page: 1,
        lang: _mainLocalizer.languageCode()
      }, params);
      var prefix = params.query;
      var url = apibase4 + "keys/all?" + utilQsString(params);
      doRequest(url, params, true, callback, function(err, d2) {
        if (err) {
          callback(err);
        } else {
          var f2 = filterMultikeys(prefix);
          var result = d2.data.filter(f2).map(valKey);
          _taginfoCache[url] = result;
          callback(null, result);
        }
      });
    },
    values: function(params, callback) {
      var key = params.key;
      if (key && _popularKeys[key]) {
        callback(null, []);
        return;
      }
      var doRequest = params.debounce ? debouncedRequest2 : request2;
      params = clean(setSort(setFilter(params)));
      params = Object.assign({
        rp: 25,
        sortname: "count_all",
        sortorder: "desc",
        page: 1,
        lang: _mainLocalizer.languageCode()
      }, params);
      var url = apibase4 + "key/values?" + utilQsString(params);
      doRequest(url, params, false, callback, function(err, d2) {
        if (err) {
          callback(err);
        } else {
          var allowUpperCase = allowUpperCaseTagValues.test(params.key);
          var f2 = filterValues(allowUpperCase);
          var result = d2.data.filter(f2).map(valKeyDescription);
          _taginfoCache[url] = result;
          callback(null, result);
        }
      });
    },
    roles: function(params, callback) {
      var doRequest = params.debounce ? debouncedRequest2 : request2;
      var geometry = params.geometry;
      params = clean(setSortMembers(params));
      params = Object.assign({
        rp: 25,
        sortname: "count_all_members",
        sortorder: "desc",
        page: 1,
        lang: _mainLocalizer.languageCode()
      }, params);
      var url = apibase4 + "relation/roles?" + utilQsString(params);
      doRequest(url, params, true, callback, function(err, d2) {
        if (err) {
          callback(err);
        } else {
          var f2 = filterRoles(geometry);
          var result = d2.data.filter(f2).map(roleKey);
          _taginfoCache[url] = result;
          callback(null, result);
        }
      });
    },
    docs: function(params, callback) {
      var doRequest = params.debounce ? debouncedRequest2 : request2;
      params = clean(setSort(params));
      var path = "key/wiki_pages?";
      if (params.value) {
        path = "tag/wiki_pages?";
      } else if (params.rtype) {
        path = "relation/wiki_pages?";
      }
      var url = apibase4 + path + utilQsString(params);
      doRequest(url, params, true, callback, function(err, d2) {
        if (err) {
          callback(err);
        } else {
          _taginfoCache[url] = d2.data;
          callback(null, d2.data);
        }
      });
    },
    apibase: function(_2) {
      if (!arguments.length)
        return apibase4;
      apibase4 = _2;
      return this;
    }
  };

  // modules/services/vector_tile.js
  var import_fast_deep_equal11 = __toESM(require_fast_deep_equal());
  var import_fast_json_stable_stringify2 = __toESM(require_fast_json_stable_stringify());
  var import_polygon_clipping = __toESM(require_polygon_clipping_umd());
  var import_pbf2 = __toESM(require_pbf());
  var import_vector_tile2 = __toESM(require_vector_tile());
  var tiler8 = utilTiler().tileSize(512).margin(1);
  var dispatch12 = dispatch_default("loadedData");
  var _vtCache;
  function abortRequest7(controller) {
    controller.abort();
  }
  function vtToGeoJSON(data, tile, mergeCache) {
    var vectorTile = new import_vector_tile2.default.VectorTile(new import_pbf2.default(data));
    var layers = Object.keys(vectorTile.layers);
    if (!Array.isArray(layers)) {
      layers = [layers];
    }
    var features = [];
    layers.forEach(function(layerID) {
      var layer = vectorTile.layers[layerID];
      if (layer) {
        for (var i3 = 0; i3 < layer.length; i3++) {
          var feature3 = layer.feature(i3).toGeoJSON(tile.xyz[0], tile.xyz[1], tile.xyz[2]);
          var geometry = feature3.geometry;
          if (geometry.type === "Polygon") {
            geometry.type = "MultiPolygon";
            geometry.coordinates = [geometry.coordinates];
          }
          var isClipped = false;
          if (geometry.type === "MultiPolygon") {
            var featureClip = bboxClip(feature3, tile.extent.rectangle());
            if (!(0, import_fast_deep_equal11.default)(feature3.geometry, featureClip.geometry)) {
              isClipped = true;
            }
            if (!feature3.geometry.coordinates.length)
              continue;
            if (!feature3.geometry.coordinates[0].length)
              continue;
          }
          var featurehash = utilHashcode((0, import_fast_json_stable_stringify2.default)(feature3));
          var propertyhash = utilHashcode((0, import_fast_json_stable_stringify2.default)(feature3.properties || {}));
          feature3.__layerID__ = layerID.replace(/[^_a-zA-Z0-9\-]/g, "_");
          feature3.__featurehash__ = featurehash;
          feature3.__propertyhash__ = propertyhash;
          features.push(feature3);
          if (isClipped && geometry.type === "MultiPolygon") {
            var merged = mergeCache[propertyhash];
            if (merged && merged.length) {
              var other = merged[0];
              var coords = import_polygon_clipping.default.union(
                feature3.geometry.coordinates,
                other.geometry.coordinates
              );
              if (!coords || !coords.length) {
                continue;
              }
              merged.push(feature3);
              for (var j2 = 0; j2 < merged.length; j2++) {
                merged[j2].geometry.coordinates = coords;
                merged[j2].__featurehash__ = featurehash;
              }
            } else {
              mergeCache[propertyhash] = [feature3];
            }
          }
        }
      }
    });
    return features;
  }
  function loadTile3(source, tile) {
    if (source.loaded[tile.id] || source.inflight[tile.id])
      return;
    var url = source.template.replace("{x}", tile.xyz[0]).replace("{y}", tile.xyz[1]).replace(/\{[t-]y\}/, Math.pow(2, tile.xyz[2]) - tile.xyz[1] - 1).replace(/\{z(oom)?\}/, tile.xyz[2]).replace(/\{switch:([^}]+)\}/, function(s2, r2) {
      var subdomains = r2.split(",");
      return subdomains[(tile.xyz[0] + tile.xyz[1]) % subdomains.length];
    });
    var controller = new AbortController();
    source.inflight[tile.id] = controller;
    fetch(url, { signal: controller.signal }).then(function(response) {
      if (!response.ok) {
        throw new Error(response.status + " " + response.statusText);
      }
      source.loaded[tile.id] = [];
      delete source.inflight[tile.id];
      return response.arrayBuffer();
    }).then(function(data) {
      if (!data) {
        throw new Error("No Data");
      }
      var z2 = tile.xyz[2];
      if (!source.canMerge[z2]) {
        source.canMerge[z2] = {};
      }
      source.loaded[tile.id] = vtToGeoJSON(data, tile, source.canMerge[z2]);
      dispatch12.call("loadedData");
    }).catch(function() {
      source.loaded[tile.id] = [];
      delete source.inflight[tile.id];
    });
  }
  var vector_tile_default = {
    init: function() {
      if (!_vtCache) {
        this.reset();
      }
      this.event = utilRebind(this, dispatch12, "on");
    },
    reset: function() {
      for (var sourceID in _vtCache) {
        var source = _vtCache[sourceID];
        if (source && source.inflight) {
          Object.values(source.inflight).forEach(abortRequest7);
        }
      }
      _vtCache = {};
    },
    addSource: function(sourceID, template) {
      _vtCache[sourceID] = { template, inflight: {}, loaded: {}, canMerge: {} };
      return _vtCache[sourceID];
    },
    data: function(sourceID, projection2) {
      var source = _vtCache[sourceID];
      if (!source)
        return [];
      var tiles = tiler8.getTiles(projection2);
      var seen = {};
      var results = [];
      for (var i3 = 0; i3 < tiles.length; i3++) {
        var features = source.loaded[tiles[i3].id];
        if (!features || !features.length)
          continue;
        for (var j2 = 0; j2 < features.length; j2++) {
          var feature3 = features[j2];
          var hash = feature3.__featurehash__;
          if (seen[hash])
            continue;
          seen[hash] = true;
          results.push(Object.assign({}, feature3));
        }
      }
      return results;
    },
    loadTiles: function(sourceID, template, projection2) {
      var source = _vtCache[sourceID];
      if (!source) {
        source = this.addSource(sourceID, template);
      }
      var tiles = tiler8.getTiles(projection2);
      Object.keys(source.inflight).forEach(function(k2) {
        var wanted = tiles.find(function(tile) {
          return k2 === tile.id;
        });
        if (!wanted) {
          abortRequest7(source.inflight[k2]);
          delete source.inflight[k2];
        }
      });
      tiles.forEach(function(tile) {
        loadTile3(source, tile);
      });
    },
    cache: function() {
      return _vtCache;
    }
  };

  // modules/services/wikidata.js
  var apibase5 = "https://www.wikidata.org/w/api.php?";
  var _wikidataCache = {};
  var wikidata_default = {
    init: function() {
    },
    reset: function() {
      _wikidataCache = {};
    },
    // Search for Wikidata items matching the query
    itemsForSearchQuery: function(query, callback, language) {
      if (!query) {
        if (callback)
          callback("No query", {});
        return;
      }
      var lang = this.languagesToQuery()[0];
      var url = apibase5 + utilQsString({
        action: "wbsearchentities",
        format: "json",
        formatversion: 2,
        search: query,
        type: "item",
        // the language to search
        language: language || lang,
        // the language for the label and description in the result
        uselang: lang,
        limit: 10,
        origin: "*"
      });
      json_default(url).then((result) => {
        if (result && result.error) {
          if (result.error.code === "badvalue" && result.error.info.includes(lang) && !language && lang.includes("-")) {
            this.itemsForSearchQuery(query, callback, lang.split("-")[0]);
            return;
          } else {
            throw new Error(result.error);
          }
        }
        if (callback)
          callback(null, result.search || {});
      }).catch(function(err) {
        if (callback)
          callback(err.message, {});
      });
    },
    // Given a Wikipedia language and article title,
    // return an array of corresponding Wikidata entities.
    itemsByTitle: function(lang, title, callback) {
      if (!title) {
        if (callback)
          callback("No title", {});
        return;
      }
      lang = lang || "en";
      var url = apibase5 + utilQsString({
        action: "wbgetentities",
        format: "json",
        formatversion: 2,
        sites: lang.replace(/-/g, "_") + "wiki",
        titles: title,
        languages: "en",
        // shrink response by filtering to one language
        origin: "*"
      });
      json_default(url).then(function(result) {
        if (result && result.error) {
          throw new Error(result.error);
        }
        if (callback)
          callback(null, result.entities || {});
      }).catch(function(err) {
        if (callback)
          callback(err.message, {});
      });
    },
    languagesToQuery: function() {
      return _mainLocalizer.localeCodes().map(function(code) {
        return code.toLowerCase();
      }).filter(function(code) {
        return code !== "en-us";
      });
    },
    entityByQID: function(qid, callback) {
      if (!qid) {
        callback("No qid", {});
        return;
      }
      if (_wikidataCache[qid]) {
        if (callback)
          callback(null, _wikidataCache[qid]);
        return;
      }
      var langs = this.languagesToQuery();
      var url = apibase5 + utilQsString({
        action: "wbgetentities",
        format: "json",
        formatversion: 2,
        ids: qid,
        props: "labels|descriptions|claims|sitelinks",
        sitefilter: langs.map(function(d2) {
          return d2 + "wiki";
        }).join("|"),
        languages: langs.join("|"),
        languagefallback: 1,
        origin: "*"
      });
      json_default(url).then(function(result) {
        if (result && result.error) {
          throw new Error(result.error);
        }
        if (callback)
          callback(null, result.entities[qid] || {});
      }).catch(function(err) {
        if (callback)
          callback(err.message, {});
      });
    },
    // Pass `params` object of the form:
    // {
    //   qid: 'string'      // brand wikidata  (e.g. 'Q37158')
    // }
    //
    // Get an result object used to display tag documentation
    // {
    //   title:        'string',
    //   description:  'string',
    //   editURL:      'string',
    //   imageURL:     'string',
    //   wiki:         { title: 'string', text: 'string', url: 'string' }
    // }
    //
    getDocs: function(params, callback) {
      var langs = this.languagesToQuery();
      this.entityByQID(params.qid, function(err, entity) {
        if (err || !entity) {
          callback(err || "No entity");
          return;
        }
        var i3;
        var description;
        for (i3 in langs) {
          let code = langs[i3];
          if (entity.descriptions[code] && entity.descriptions[code].language === code) {
            description = entity.descriptions[code];
            break;
          }
        }
        if (!description && Object.values(entity.descriptions).length)
          description = Object.values(entity.descriptions)[0];
        var result = {
          title: entity.id,
          description: description ? description.value : "",
          descriptionLocaleCode: description ? description.language : "",
          editURL: "https://www.wikidata.org/wiki/" + entity.id
        };
        if (entity.claims) {
          var imageroot = "https://commons.wikimedia.org/w/index.php";
          var props = ["P154", "P18"];
          var prop, image;
          for (i3 = 0; i3 < props.length; i3++) {
            prop = entity.claims[props[i3]];
            if (prop && Object.keys(prop).length > 0) {
              image = prop[Object.keys(prop)[0]].mainsnak.datavalue.value;
              if (image) {
                result.imageURL = imageroot + "?" + utilQsString({
                  title: "Special:Redirect/file/" + image,
                  width: 400
                });
                break;
              }
            }
          }
        }
        if (entity.sitelinks) {
          var englishLocale = _mainLocalizer.languageCode().toLowerCase() === "en";
          for (i3 = 0; i3 < langs.length; i3++) {
            var w2 = langs[i3] + "wiki";
            if (entity.sitelinks[w2]) {
              var title = entity.sitelinks[w2].title;
              var tKey = "inspector.wiki_reference";
              if (!englishLocale && langs[i3] === "en") {
                tKey = "inspector.wiki_en_reference";
              }
              result.wiki = {
                title,
                text: tKey,
                url: "https://" + langs[i3] + ".wikipedia.org/wiki/" + title.replace(/ /g, "_")
              };
              break;
            }
          }
        }
        callback(null, result);
      });
    }
  };

  // modules/services/wikipedia.js
  var endpoint = "https://en.wikipedia.org/w/api.php?";
  var wikipedia_default = {
    init: function() {
    },
    reset: function() {
    },
    search: function(lang, query, callback) {
      if (!query) {
        if (callback)
          callback("No Query", []);
        return;
      }
      lang = lang || "en";
      var url = endpoint.replace("en", lang) + utilQsString({
        action: "query",
        list: "search",
        srlimit: "10",
        srinfo: "suggestion",
        format: "json",
        origin: "*",
        srsearch: query
      });
      json_default(url).then(function(result) {
        if (result && result.error) {
          throw new Error(result.error);
        } else if (!result || !result.query || !result.query.search) {
          throw new Error("No Results");
        }
        if (callback) {
          var titles = result.query.search.map(function(d2) {
            return d2.title;
          });
          callback(null, titles);
        }
      }).catch(function(err) {
        if (callback)
          callback(err, []);
      });
    },
    suggestions: function(lang, query, callback) {
      if (!query) {
        if (callback)
          callback("", []);
        return;
      }
      lang = lang || "en";
      var url = endpoint.replace("en", lang) + utilQsString({
        action: "opensearch",
        namespace: 0,
        suggest: "",
        format: "json",
        origin: "*",
        search: query
      });
      json_default(url).then(function(result) {
        if (result && result.error) {
          throw new Error(result.error);
        } else if (!result || result.length < 2) {
          throw new Error("No Results");
        }
        if (callback)
          callback(null, result[1] || []);
      }).catch(function(err) {
        if (callback)
          callback(err.message, []);
      });
    },
    translations: function(lang, title, callback) {
      if (!title) {
        if (callback)
          callback("No Title");
        return;
      }
      var url = endpoint.replace("en", lang) + utilQsString({
        action: "query",
        prop: "langlinks",
        format: "json",
        origin: "*",
        lllimit: 500,
        titles: title
      });
      json_default(url).then(function(result) {
        if (result && result.error) {
          throw new Error(result.error);
        } else if (!result || !result.query || !result.query.pages) {
          throw new Error("No Results");
        }
        if (callback) {
          var list2 = result.query.pages[Object.keys(result.query.pages)[0]];
          var translations = {};
          if (list2 && list2.langlinks) {
            list2.langlinks.forEach(function(d2) {
              translations[d2.lang] = d2["*"];
            });
          }
          callback(null, translations);
        }
      }).catch(function(err) {
        if (callback)
          callback(err.message);
      });
    }
  };

  // modules/services/mapilio.js
  var import_pbf3 = __toESM(require_pbf());
  var import_rbush12 = __toESM(require_rbush_min());
  var import_vector_tile3 = __toESM(require_vector_tile());
  var apiUrl2 = "https://end.mapilio.com";
  var imageBaseUrl = "https://cdn.mapilio.com/im";
  var baseTileUrl2 = "https://geo.mapilio.com/geoserver/gwc/service/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&LAYER=mapilio:";
  var pointLayer = "map_points";
  var lineLayer = "map_roads_line";
  var tileStyle = "&STYLE=&TILEMATRIX=EPSG:900913:{z}&TILEMATRIXSET=EPSG:900913&FORMAT=application/vnd.mapbox-vector-tile&TILECOL={x}&TILEROW={y}";
  var minZoom3 = 14;
  var dispatch13 = dispatch_default("loadedImages", "loadedLines");
  var imgZoom3 = zoom_default2().extent([[0, 0], [320, 240]]).translateExtent([[0, 0], [320, 240]]).scaleExtent([1, 15]);
  var pannellumViewerCSS3 = "pannellum/pannellum.css";
  var pannellumViewerJS3 = "pannellum/pannellum.js";
  var resolution = 1080;
  var _activeImage;
  var _cache4;
  var _loadViewerPromise5;
  var _pannellumViewer3;
  var _sceneOptions2 = {
    showFullscreenCtrl: false,
    autoLoad: true,
    yaw: 0,
    minHfov: 10,
    maxHfov: 90,
    hfov: 60
  };
  var _currScene2 = 0;
  function partitionViewport5(projection2) {
    const z2 = geoScaleToZoom(projection2.scale());
    const z22 = Math.ceil(z2 * 2) / 2 + 2.5;
    const tiler9 = utilTiler().zoomExtent([z22, z22]);
    return tiler9.getTiles(projection2).map(function(tile) {
      return tile.extent;
    });
  }
  function searchLimited5(limit, projection2, rtree) {
    limit = limit || 5;
    return partitionViewport5(projection2).reduce(function(result, extent) {
      const found = rtree.search(extent.bbox()).slice(0, limit).map(function(d2) {
        return d2.data;
      });
      return found.length ? result.concat(found) : result;
    }, []);
  }
  function loadTiles4(which, url, maxZoom2, projection2) {
    const tiler9 = utilTiler().zoomExtent([minZoom3, maxZoom2]).skipNullIsland(true);
    const tiles = tiler9.getTiles(projection2);
    tiles.forEach(function(tile) {
      loadTile4(which, url, tile);
    });
  }
  function loadTile4(which, url, tile) {
    const cache = _cache4.requests;
    const tileId = "".concat(tile.id, "-").concat(which);
    if (cache.loaded[tileId] || cache.inflight[tileId])
      return;
    const controller = new AbortController();
    cache.inflight[tileId] = controller;
    const requestUrl = url.replace("{x}", tile.xyz[0]).replace("{y}", tile.xyz[1]).replace("{z}", tile.xyz[2]);
    fetch(requestUrl, { signal: controller.signal }).then(function(response) {
      if (!response.ok) {
        throw new Error(response.status + " " + response.statusText);
      }
      cache.loaded[tileId] = true;
      delete cache.inflight[tileId];
      return response.arrayBuffer();
    }).then(function(data) {
      if (data.byteLength === 0) {
        throw new Error("No Data");
      }
      loadTileDataToCache2(data, tile, which);
      if (which === "images") {
        dispatch13.call("loadedImages");
      } else {
        dispatch13.call("loadedLines");
      }
    }).catch(function(e3) {
      if (e3.message === "No Data") {
        cache.loaded[tileId] = true;
      } else {
        console.error(e3);
      }
    });
  }
  function loadTileDataToCache2(data, tile) {
    const vectorTile = new import_vector_tile3.VectorTile(new import_pbf3.default(data));
    let features, cache, layer, i3, feature3, loc, d2;
    if (vectorTile.layers.hasOwnProperty(pointLayer)) {
      features = [];
      cache = _cache4.images;
      layer = vectorTile.layers[pointLayer];
      for (i3 = 0; i3 < layer.length; i3++) {
        feature3 = layer.feature(i3).toGeoJSON(tile.xyz[0], tile.xyz[1], tile.xyz[2]);
        loc = feature3.geometry.coordinates;
        let resolutionArr = feature3.properties.resolution.split("x");
        let sourceWidth = Math.max(resolutionArr[0], resolutionArr[1]);
        let sourceHeight = Math.min(resolutionArr[0], resolutionArr[1]);
        let isPano = sourceWidth % sourceHeight === 0;
        d2 = {
          loc,
          capture_time: feature3.properties.capture_time,
          id: feature3.properties.id,
          sequence_id: feature3.properties.sequence_uuid,
          heading: feature3.properties.heading,
          resolution: feature3.properties.resolution,
          isPano
        };
        cache.forImageId[d2.id] = d2;
        features.push({
          minX: loc[0],
          minY: loc[1],
          maxX: loc[0],
          maxY: loc[1],
          data: d2
        });
      }
      if (cache.rtree) {
        cache.rtree.load(features);
      }
    }
    if (vectorTile.layers.hasOwnProperty(lineLayer)) {
      cache = _cache4.sequences;
      layer = vectorTile.layers[lineLayer];
      for (i3 = 0; i3 < layer.length; i3++) {
        feature3 = layer.feature(i3).toGeoJSON(tile.xyz[0], tile.xyz[1], tile.xyz[2]);
        if (cache.lineString[feature3.properties.sequence_uuid]) {
          cache.lineString[feature3.properties.sequence_uuid].push(feature3);
        } else {
          cache.lineString[feature3.properties.sequence_uuid] = [feature3];
        }
      }
    }
  }
  function getImageData(imageId, sequenceId) {
    return fetch(apiUrl2 + "/api/sequence-detail?sequence_uuid=".concat(sequenceId), { method: "GET" }).then(function(response) {
      if (!response.ok) {
        throw new Error(response.status + " " + response.statusText);
      }
      return response.json();
    }).then(function(data) {
      let index = data.data.findIndex((feature3) => feature3.id === imageId);
      const { filename, uploaded_hash } = data.data[index];
      _sceneOptions2.panorama = imageBaseUrl + "/" + uploaded_hash + "/" + filename + "/" + resolution;
    });
  }
  var mapilio_default = {
    // Initialize Mapilio
    init: function() {
      if (!_cache4) {
        this.reset();
      }
      this.event = utilRebind(this, dispatch13, "on");
    },
    // Reset cache and state
    reset: function() {
      if (_cache4) {
        Object.values(_cache4.requests.inflight).forEach(function(request3) {
          request3.abort();
        });
      }
      _cache4 = {
        images: { rtree: new import_rbush12.default(), forImageId: {} },
        sequences: { rtree: new import_rbush12.default(), lineString: {} },
        requests: { loaded: {}, inflight: {} }
      };
      _activeImage = null;
    },
    // Get visible images
    images: function(projection2) {
      const limit = 5;
      return searchLimited5(limit, projection2, _cache4.images.rtree);
    },
    cachedImage: function(imageKey) {
      return _cache4.images.forImageId[imageKey];
    },
    // Load images in the visible area
    loadImages: function(projection2) {
      let url = baseTileUrl2 + pointLayer + tileStyle;
      loadTiles4("images", url, 14, projection2);
    },
    // Load line in the visible area
    loadLines: function(projection2) {
      let url = baseTileUrl2 + lineLayer + tileStyle;
      loadTiles4("line", url, 14, projection2);
    },
    // Get visible sequences
    sequences: function(projection2) {
      const viewport = projection2.clipExtent();
      const min3 = [viewport[0][0], viewport[1][1]];
      const max3 = [viewport[1][0], viewport[0][1]];
      const bbox2 = geoExtent(projection2.invert(min3), projection2.invert(max3)).bbox();
      const sequenceIds = {};
      let lineStrings = [];
      _cache4.images.rtree.search(bbox2).forEach(function(d2) {
        if (d2.data.sequence_id) {
          sequenceIds[d2.data.sequence_id] = true;
        }
      });
      Object.keys(sequenceIds).forEach(function(sequenceId) {
        if (_cache4.sequences.lineString[sequenceId]) {
          lineStrings = lineStrings.concat(_cache4.sequences.lineString[sequenceId]);
        }
      });
      return lineStrings;
    },
    // Set the currently visible image
    setActiveImage: function(image) {
      if (image) {
        _activeImage = {
          id: image.id,
          sequence_id: image.sequence_id
        };
      } else {
        _activeImage = null;
      }
    },
    // Update the currently highlighted sequence and selected bubble.
    setStyles: function(context, hovered) {
      const hoveredImageId = hovered && hovered.id;
      const hoveredSequenceId = hovered && hovered.sequence_id;
      const selectedSequenceId = _activeImage && _activeImage.sequence_id;
      const selectedImageId = _activeImage && _activeImage.id;
      const markers = context.container().selectAll(".layer-mapilio .viewfield-group");
      const sequences = context.container().selectAll(".layer-mapilio .sequence");
      markers.classed("highlighted", function(d2) {
        return d2.id === hoveredImageId;
      }).classed("hovered", function(d2) {
        return d2.id === hoveredImageId;
      }).classed("currentView", function(d2) {
        return d2.id === selectedImageId;
      });
      sequences.classed("highlighted", function(d2) {
        return d2.properties.sequence_uuid === hoveredSequenceId;
      }).classed("currentView", function(d2) {
        return d2.properties.sequence_uuid === selectedSequenceId;
      });
      return this;
    },
    updateUrlImage: function(imageKey) {
      if (!window.mocha) {
        var hash = utilStringQs(window.location.hash);
        if (imageKey) {
          hash.photo = "mapilio/" + imageKey;
        } else {
          delete hash.photo;
        }
        window.location.replace("#" + utilQsString(hash, true));
      }
    },
    initViewer: function() {
      if (!window.pannellum)
        return;
      if (_pannellumViewer3)
        return;
      _currScene2 += 1;
      const sceneID = _currScene2.toString();
      const options2 = {
        "default": { firstScene: sceneID },
        scenes: {}
      };
      options2.scenes[sceneID] = _sceneOptions2;
      _pannellumViewer3 = window.pannellum.viewer("ideditor-viewer-mapilio-pnlm", options2);
    },
    selectImage: function(context, id2) {
      let that = this;
      let d2 = this.cachedImage(id2);
      this.setActiveImage(d2);
      this.updateUrlImage(d2.id);
      let viewer = context.container().select(".photoviewer");
      if (!viewer.empty())
        viewer.datum(d2);
      this.setStyles(context, null);
      if (!d2)
        return this;
      let wrap2 = context.container().select(".photoviewer .mapilio-wrapper");
      let attribution = wrap2.selectAll(".photo-attribution").text("");
      if (d2.capture_time) {
        attribution.append("span").attr("class", "captured_at").text(localeDateString2(d2.capture_time));
        attribution.append("span").text("|");
      }
      attribution.append("a").attr("class", "image-link").attr("target", "_blank").attr("href", "https://mapilio.com/app?lat=".concat(d2.loc[1], "&lng=").concat(d2.loc[0], "&zoom=17&pId=").concat(d2.id)).text("mapilio.com");
      wrap2.transition().duration(100).call(imgZoom3.transform, identity2);
      wrap2.selectAll("img").remove();
      wrap2.selectAll("button.back").classed("hide", !_cache4.images.forImageId.hasOwnProperty(+id2 - 1));
      wrap2.selectAll("button.forward").classed("hide", !_cache4.images.forImageId.hasOwnProperty(+id2 + 1));
      getImageData(d2.id, d2.sequence_id).then(function() {
        if (d2.isPano) {
          if (!_pannellumViewer3) {
            that.initViewer();
          } else {
            _currScene2 += 1;
            let sceneID = _currScene2.toString();
            _pannellumViewer3.addScene(sceneID, _sceneOptions2).loadScene(sceneID);
            if (_currScene2 > 2) {
              sceneID = (_currScene2 - 1).toString();
              _pannellumViewer3.removeScene(sceneID);
            }
          }
        } else {
          that.initOnlyPhoto(context);
        }
      });
      function localeDateString2(s2) {
        if (!s2)
          return null;
        var options2 = { day: "numeric", month: "short", year: "numeric" };
        var d4 = new Date(s2);
        if (isNaN(d4.getTime()))
          return null;
        return d4.toLocaleDateString(_mainLocalizer.localeCode(), options2);
      }
      return this;
    },
    initOnlyPhoto: function(context) {
      if (_pannellumViewer3) {
        _pannellumViewer3.destroy();
        _pannellumViewer3 = null;
      }
      let wrap2 = context.container().select("#ideditor-viewer-mapilio-simple");
      let imgWrap = wrap2.select("img");
      if (!imgWrap.empty()) {
        imgWrap.attr("src", _sceneOptions2.panorama);
      } else {
        wrap2.append("img").attr("src", _sceneOptions2.panorama);
      }
    },
    ensureViewerLoaded: function(context) {
      let that = this;
      let imgWrap = context.container().select("#ideditor-viewer-mapilio-simple > img");
      if (!imgWrap.empty()) {
        imgWrap.remove();
      }
      if (_loadViewerPromise5)
        return _loadViewerPromise5;
      let wrap2 = context.container().select(".photoviewer").selectAll(".mapilio-wrapper").data([0]);
      let wrapEnter = wrap2.enter().append("div").attr("class", "photo-wrapper mapilio-wrapper").classed("hide", true).on("dblclick.zoom", null);
      wrapEnter.append("div").attr("class", "photo-attribution fillD");
      const controlsEnter = wrapEnter.append("div").attr("class", "photo-controls-wrap").append("div").attr("class", "photo-controls-mapilio");
      controlsEnter.append("button").classed("back", true).on("click.back", step(-1)).text("\u25C4");
      controlsEnter.append("button").classed("forward", true).on("click.forward", step(1)).text("\u25BA");
      wrapEnter.append("div").attr("id", "ideditor-viewer-mapilio-pnlm");
      wrapEnter.append("div").attr("id", "ideditor-viewer-mapilio-simple-wrap").call(imgZoom3.on("zoom", zoomPan2)).append("div").attr("id", "ideditor-viewer-mapilio-simple");
      context.ui().photoviewer.on("resize.mapilio", () => {
        if (_pannellumViewer3) {
          _pannellumViewer3.resize();
        }
      });
      _loadViewerPromise5 = new Promise((resolve, reject) => {
        let loadedCount = 0;
        function loaded() {
          loadedCount += 1;
          if (loadedCount === 2)
            resolve();
        }
        const head = select_default2("head");
        head.selectAll("#ideditor-mapilio-viewercss").data([0]).enter().append("link").attr("id", "ideditor-mapilio-viewercss").attr("rel", "stylesheet").attr("crossorigin", "anonymous").attr("href", context.asset(pannellumViewerCSS3)).on("load.serviceMapilio", loaded).on("error.serviceMapilio", function() {
          reject();
        });
        head.selectAll("#ideditor-mapilio-viewerjs").data([0]).enter().append("script").attr("id", "ideditor-mapilio-viewerjs").attr("crossorigin", "anonymous").attr("src", context.asset(pannellumViewerJS3)).on("load.serviceMapilio", loaded).on("error.serviceMapilio", function() {
          reject();
        });
      }).catch(function() {
        _loadViewerPromise5 = null;
      });
      function step(stepBy) {
        return function() {
          if (!_activeImage)
            return;
          const imageId = _activeImage.id;
          const nextIndex = imageId + stepBy;
          if (!nextIndex)
            return;
          const nextImage = _cache4.images.forImageId[nextIndex];
          context.map().centerEase(nextImage.loc);
          that.selectImage(context, nextImage.id);
        };
      }
      function zoomPan2(d3_event) {
        var t2 = d3_event.transform;
        context.container().select(".photoviewer #ideditor-viewer-mapilio-simple").call(utilSetTransform, t2.x, t2.y, t2.k);
      }
      return _loadViewerPromise5;
    },
    showViewer: function(context) {
      let wrap2 = context.container().select(".photoviewer").classed("hide", false);
      let isHidden = wrap2.selectAll(".photo-wrapper.mapilio-wrapper.hide").size();
      if (isHidden) {
        wrap2.selectAll(".photo-wrapper:not(.mapilio-wrapper)").classed("hide", true);
        wrap2.selectAll(".photo-wrapper.mapilio-wrapper").classed("hide", false);
      }
      return this;
    },
    /**
     * hideViewer()
     */
    hideViewer: function(context) {
      let viewer = context.container().select(".photoviewer");
      if (!viewer.empty())
        viewer.datum(null);
      this.updateUrlImage(null);
      viewer.classed("hide", true).selectAll(".photo-wrapper").classed("hide", true);
      context.container().selectAll(".viewfield-group, .sequence, .icon-sign").classed("currentView", false);
      this.setActiveImage();
      return this.setStyles(context, null);
    },
    // Return the current cache
    cache: function() {
      return _cache4;
    }
  };

  // modules/services/index.js
  var services = {
    geocoder: nominatim_default,
    keepRight: keepRight_default,
    improveOSM: improveOSM_default,
    osmose: osmose_default,
    mapillary: mapillary_default,
    nsi: nsi_default,
    kartaview: kartaview_default,
    vegbilder: vegbilder_default,
    osm: osm_default,
    osmWikibase: osm_wikibase_default,
    maprules: maprules_default,
    streetside: streetside_default,
    taginfo: taginfo_default,
    vectorTile: vector_tile_default,
    wikidata: wikidata_default,
    wikipedia: wikipedia_default,
    mapilio: mapilio_default
  };

  // modules/modes/drag_note.js
  function modeDragNote(context) {
    var mode = {
      id: "drag-note",
      button: "browse"
    };
    var edit2 = behaviorEdit(context);
    var _nudgeInterval;
    var _lastLoc;
    var _note;
    function startNudge(d3_event, nudge) {
      if (_nudgeInterval)
        window.clearInterval(_nudgeInterval);
      _nudgeInterval = window.setInterval(function() {
        context.map().pan(nudge);
        doMove(d3_event, nudge);
      }, 50);
    }
    function stopNudge() {
      if (_nudgeInterval) {
        window.clearInterval(_nudgeInterval);
        _nudgeInterval = null;
      }
    }
    function origin(note) {
      return context.projection(note.loc);
    }
    function start2(d3_event, note) {
      _note = note;
      var osm = services.osm;
      if (osm) {
        _note = osm.getNote(_note.id);
      }
      context.surface().selectAll(".note-" + _note.id).classed("active", true);
      context.perform(actionNoop());
      context.enter(mode);
      context.selectedNoteID(_note.id);
    }
    function move(d3_event, entity, point2) {
      d3_event.stopPropagation();
      _lastLoc = context.projection.invert(point2);
      doMove(d3_event);
      var nudge = geoViewportEdge(point2, context.map().dimensions());
      if (nudge) {
        startNudge(d3_event, nudge);
      } else {
        stopNudge();
      }
    }
    function doMove(d3_event, nudge) {
      nudge = nudge || [0, 0];
      var currPoint = d3_event && d3_event.point || context.projection(_lastLoc);
      var currMouse = geoVecSubtract(currPoint, nudge);
      var loc = context.projection.invert(currMouse);
      _note = _note.move(loc);
      var osm = services.osm;
      if (osm) {
        osm.replaceNote(_note);
      }
      context.replace(actionNoop());
    }
    function end() {
      context.replace(actionNoop());
      context.selectedNoteID(_note.id).enter(modeSelectNote(context, _note.id));
    }
    var drag = behaviorDrag().selector(".layer-touch.markers .target.note.new").surface(context.container().select(".main-map").node()).origin(origin).on("start", start2).on("move", move).on("end", end);
    mode.enter = function() {
      context.install(edit2);
    };
    mode.exit = function() {
      context.ui().sidebar.hover.cancel();
      context.uninstall(edit2);
      context.surface().selectAll(".active").classed("active", false);
      stopNudge();
    };
    mode.behavior = drag;
    return mode;
  }

  // modules/modes/select_data.js
  function modeSelectData(context, selectedDatum) {
    var mode = {
      id: "select-data",
      button: "browse"
    };
    var keybinding = utilKeybinding("select-data");
    var dataEditor = uiDataEditor(context);
    var behaviors = [
      behaviorBreathe(context),
      behaviorHover(context),
      behaviorSelect(context),
      behaviorLasso(context),
      modeDragNode(context).behavior,
      modeDragNote(context).behavior
    ];
    function selectData(d3_event, drawn) {
      var selection2 = context.surface().selectAll(".layer-mapdata .data" + selectedDatum.__featurehash__);
      if (selection2.empty()) {
        var source = d3_event && d3_event.type === "zoom" && d3_event.sourceEvent;
        if (drawn && source && (source.type === "pointermove" || source.type === "mousemove" || source.type === "touchmove")) {
          context.enter(modeBrowse(context));
        }
      } else {
        selection2.classed("selected", true);
      }
    }
    function esc() {
      if (context.container().select(".combobox").size())
        return;
      context.enter(modeBrowse(context));
    }
    mode.zoomToSelected = function() {
      var extent = geoExtent(bounds_default(selectedDatum));
      context.map().centerZoomEase(extent.center(), context.map().trimmedExtentZoom(extent));
    };
    mode.enter = function() {
      behaviors.forEach(context.install);
      keybinding.on(_t("inspector.zoom_to.key"), mode.zoomToSelected).on("\u238B", esc, true);
      select_default2(document).call(keybinding);
      selectData();
      var sidebar = context.ui().sidebar;
      sidebar.show(dataEditor.datum(selectedDatum));
      var extent = geoExtent(bounds_default(selectedDatum));
      sidebar.expand(sidebar.intersects(extent));
      context.map().on("drawn.select-data", selectData);
    };
    mode.exit = function() {
      behaviors.forEach(context.uninstall);
      select_default2(document).call(keybinding.unbind);
      context.surface().selectAll(".layer-mapdata .selected").classed("selected hover", false);
      context.map().on("drawn.select-data", null);
      context.ui().sidebar.hide();
    };
    return mode;
  }

  // modules/behavior/select.js
  function behaviorSelect(context) {
    var _tolerancePx = 4;
    var _lastMouseEvent = null;
    var _showMenu = false;
    var _downPointers = {};
    var _longPressTimeout = null;
    var _lastInteractionType = null;
    var _multiselectionPointerId = null;
    var _pointerPrefix = "PointerEvent" in window ? "pointer" : "mouse";
    function keydown(d3_event) {
      if (d3_event.keyCode === 32) {
        var activeNode = document.activeElement;
        if (activeNode && (/* @__PURE__ */ new Set(["INPUT", "TEXTAREA"])).has(activeNode.nodeName))
          return;
      }
      if (d3_event.keyCode === 93 || // context menu key
      d3_event.keyCode === 32) {
        d3_event.preventDefault();
      }
      if (d3_event.repeat)
        return;
      cancelLongPress();
      if (d3_event.shiftKey) {
        context.surface().classed("behavior-multiselect", true);
      }
      if (d3_event.keyCode === 32) {
        if (!_downPointers.spacebar && _lastMouseEvent) {
          cancelLongPress();
          _longPressTimeout = window.setTimeout(didLongPress, 500, "spacebar", "spacebar");
          _downPointers.spacebar = {
            firstEvent: _lastMouseEvent,
            lastEvent: _lastMouseEvent
          };
        }
      }
    }
    function keyup(d3_event) {
      cancelLongPress();
      if (!d3_event.shiftKey) {
        context.surface().classed("behavior-multiselect", false);
      }
      if (d3_event.keyCode === 93) {
        d3_event.preventDefault();
        _lastInteractionType = "menukey";
        contextmenu(d3_event);
      } else if (d3_event.keyCode === 32) {
        var pointer = _downPointers.spacebar;
        if (pointer) {
          delete _downPointers.spacebar;
          if (pointer.done)
            return;
          d3_event.preventDefault();
          _lastInteractionType = "spacebar";
          click(pointer.firstEvent, pointer.lastEvent, "spacebar");
        }
      }
    }
    function pointerdown(d3_event) {
      var id2 = (d3_event.pointerId || "mouse").toString();
      cancelLongPress();
      if (d3_event.buttons && d3_event.buttons !== 1)
        return;
      context.ui().closeEditMenu();
      if (d3_event.pointerType !== "mouse") {
        _longPressTimeout = window.setTimeout(didLongPress, 500, id2, "longdown-" + (d3_event.pointerType || "mouse"));
      }
      _downPointers[id2] = {
        firstEvent: d3_event,
        lastEvent: d3_event
      };
    }
    function didLongPress(id2, interactionType) {
      var pointer = _downPointers[id2];
      if (!pointer)
        return;
      for (var i3 in _downPointers) {
        _downPointers[i3].done = true;
      }
      _longPressTimeout = null;
      _lastInteractionType = interactionType;
      _showMenu = true;
      click(pointer.firstEvent, pointer.lastEvent, id2);
    }
    function pointermove(d3_event) {
      var id2 = (d3_event.pointerId || "mouse").toString();
      if (_downPointers[id2]) {
        _downPointers[id2].lastEvent = d3_event;
      }
      if (!d3_event.pointerType || d3_event.pointerType === "mouse") {
        _lastMouseEvent = d3_event;
        if (_downPointers.spacebar) {
          _downPointers.spacebar.lastEvent = d3_event;
        }
      }
    }
    function pointerup(d3_event) {
      var id2 = (d3_event.pointerId || "mouse").toString();
      var pointer = _downPointers[id2];
      if (!pointer)
        return;
      delete _downPointers[id2];
      if (_multiselectionPointerId === id2) {
        _multiselectionPointerId = null;
      }
      if (pointer.done)
        return;
      click(pointer.firstEvent, d3_event, id2);
    }
    function pointercancel(d3_event) {
      var id2 = (d3_event.pointerId || "mouse").toString();
      if (!_downPointers[id2])
        return;
      delete _downPointers[id2];
      if (_multiselectionPointerId === id2) {
        _multiselectionPointerId = null;
      }
    }
    function contextmenu(d3_event) {
      d3_event.preventDefault();
      if (!+d3_event.clientX && !+d3_event.clientY) {
        if (_lastMouseEvent) {
          d3_event = _lastMouseEvent;
        } else {
          return;
        }
      } else {
        _lastMouseEvent = d3_event;
        if (d3_event.pointerType === "touch" || d3_event.pointerType === "pen" || d3_event.mozInputSource && // firefox doesn't give a pointerType on contextmenu events
        (d3_event.mozInputSource === MouseEvent.MOZ_SOURCE_TOUCH || d3_event.mozInputSource === MouseEvent.MOZ_SOURCE_PEN)) {
          _lastInteractionType = "touch";
        } else {
          _lastInteractionType = "rightclick";
        }
      }
      _showMenu = true;
      click(d3_event, d3_event);
    }
    function click(firstEvent, lastEvent, pointerId) {
      cancelLongPress();
      var mapNode = context.container().select(".main-map").node();
      var pointGetter = utilFastMouse(mapNode);
      var p1 = pointGetter(firstEvent);
      var p2 = pointGetter(lastEvent);
      var dist = geoVecLength(p1, p2);
      if (dist > _tolerancePx || !mapContains(lastEvent)) {
        resetProperties();
        return;
      }
      var targetDatum = lastEvent.target.__data__;
      var multiselectEntityId;
      if (!_multiselectionPointerId) {
        var selectPointerInfo = pointerDownOnSelection(pointerId);
        if (selectPointerInfo) {
          _multiselectionPointerId = selectPointerInfo.pointerId;
          multiselectEntityId = !selectPointerInfo.selected && selectPointerInfo.entityId;
          _downPointers[selectPointerInfo.pointerId].done = true;
        }
      }
      var isMultiselect = context.mode().id === "select" && // and shift key is down
      (lastEvent && lastEvent.shiftKey || // or we're lasso-selecting
      context.surface().select(".lasso").node() || // or a pointer is down over a selected feature
      _multiselectionPointerId && !multiselectEntityId);
      processClick(targetDatum, isMultiselect, p2, multiselectEntityId);
      function mapContains(event) {
        var rect = mapNode.getBoundingClientRect();
        return event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom;
      }
      function pointerDownOnSelection(skipPointerId) {
        var mode = context.mode();
        var selectedIDs = mode.id === "select" ? mode.selectedIDs() : [];
        for (var pointerId2 in _downPointers) {
          if (pointerId2 === "spacebar" || pointerId2 === skipPointerId)
            continue;
          var pointerInfo = _downPointers[pointerId2];
          var p12 = pointGetter(pointerInfo.firstEvent);
          var p22 = pointGetter(pointerInfo.lastEvent);
          if (geoVecLength(p12, p22) > _tolerancePx)
            continue;
          var datum2 = pointerInfo.firstEvent.target.__data__;
          var entity = datum2 && datum2.properties && datum2.properties.entity || datum2;
          if (context.graph().hasEntity(entity.id)) {
            return {
              pointerId: pointerId2,
              entityId: entity.id,
              selected: selectedIDs.indexOf(entity.id) !== -1
            };
          }
        }
        return null;
      }
    }
    function processClick(datum2, isMultiselect, point2, alsoSelectId) {
      var mode = context.mode();
      var showMenu = _showMenu;
      var interactionType = _lastInteractionType;
      var entity = datum2 && datum2.properties && datum2.properties.entity;
      if (entity)
        datum2 = entity;
      if (datum2 && datum2.type === "midpoint") {
        datum2 = datum2.parents[0];
      }
      var newMode;
      if (datum2 instanceof osmEntity) {
        var selectedIDs = context.selectedIDs();
        context.selectedNoteID(null);
        context.selectedErrorID(null);
        if (!isMultiselect) {
          if (!showMenu || selectedIDs.length <= 1 || selectedIDs.indexOf(datum2.id) === -1) {
            if (alsoSelectId === datum2.id)
              alsoSelectId = null;
            selectedIDs = (alsoSelectId ? [alsoSelectId] : []).concat([datum2.id]);
            newMode = mode.id === "select" ? mode.selectedIDs(selectedIDs) : modeSelect(context, selectedIDs).selectBehavior(behavior);
            context.enter(newMode);
          }
        } else {
          if (selectedIDs.indexOf(datum2.id) !== -1) {
            if (!showMenu) {
              selectedIDs = selectedIDs.filter(function(id2) {
                return id2 !== datum2.id;
              });
              newMode = selectedIDs.length ? mode.selectedIDs(selectedIDs) : modeBrowse(context).selectBehavior(behavior);
              context.enter(newMode);
            }
          } else {
            selectedIDs = selectedIDs.concat([datum2.id]);
            newMode = mode.selectedIDs(selectedIDs);
            context.enter(newMode);
          }
        }
      } else if (datum2 && datum2.__featurehash__ && !isMultiselect) {
        context.selectedNoteID(null).enter(modeSelectData(context, datum2));
      } else if (datum2 instanceof osmNote && !isMultiselect) {
        context.selectedNoteID(datum2.id).enter(modeSelectNote(context, datum2.id));
      } else if (datum2 instanceof QAItem && !isMultiselect) {
        context.selectedErrorID(datum2.id).enter(modeSelectError(context, datum2.id, datum2.service));
      } else {
        context.selectedNoteID(null);
        context.selectedErrorID(null);
        if (!isMultiselect && mode.id !== "browse") {
          context.enter(modeBrowse(context));
        }
      }
      context.ui().closeEditMenu();
      if (showMenu)
        context.ui().showEditMenu(point2, interactionType);
      resetProperties();
    }
    function cancelLongPress() {
      if (_longPressTimeout)
        window.clearTimeout(_longPressTimeout);
      _longPressTimeout = null;
    }
    function resetProperties() {
      cancelLongPress();
      _showMenu = false;
      _lastInteractionType = null;
    }
    function behavior(selection2) {
      resetProperties();
      _lastMouseEvent = context.map().lastPointerEvent();
      select_default2(window).on("keydown.select", keydown).on("keyup.select", keyup).on(_pointerPrefix + "move.select", pointermove, true).on(_pointerPrefix + "up.select", pointerup, true).on("pointercancel.select", pointercancel, true).on("contextmenu.select-window", function(d3_event) {
        var e3 = d3_event;
        if (+e3.clientX === 0 && +e3.clientY === 0) {
          d3_event.preventDefault();
        }
      });
      selection2.on(_pointerPrefix + "down.select", pointerdown).on("contextmenu.select", contextmenu);
    }
    behavior.off = function(selection2) {
      cancelLongPress();
      select_default2(window).on("keydown.select", null).on("keyup.select", null).on("contextmenu.select-window", null).on(_pointerPrefix + "move.select", null, true).on(_pointerPrefix + "up.select", null, true).on("pointercancel.select", null, true);
      selection2.on(_pointerPrefix + "down.select", null).on("contextmenu.select", null);
      context.surface().classed("behavior-multiselect", false);
    };
    return behavior;
  }

  // modules/operations/index.js
  var operations_exports = {};
  __export(operations_exports, {
    operationCircularize: () => operationCircularize,
    operationContinue: () => operationContinue,
    operationCopy: () => operationCopy,
    operationDelete: () => operationDelete,
    operationDisconnect: () => operationDisconnect,
    operationDowngrade: () => operationDowngrade,
    operationExtract: () => operationExtract,
    operationMerge: () => operationMerge,
    operationMove: () => operationMove,
    operationOrthogonalize: () => operationOrthogonalize,
    operationPaste: () => operationPaste,
    operationReflectLong: () => operationReflectLong,
    operationReflectShort: () => operationReflectShort,
    operationReverse: () => operationReverse,
    operationRotate: () => operationRotate,
    operationSplit: () => operationSplit,
    operationStraighten: () => operationStraighten
  });

  // modules/operations/continue.js
  function operationContinue(context, selectedIDs) {
    var _entities = selectedIDs.map(function(id2) {
      return context.graph().entity(id2);
    });
    var _geometries = Object.assign(
      { line: [], vertex: [] },
      utilArrayGroupBy(_entities, function(entity) {
        return entity.geometry(context.graph());
      })
    );
    var _vertex = _geometries.vertex.length && _geometries.vertex[0];
    function candidateWays() {
      return _vertex ? context.graph().parentWays(_vertex).filter(function(parent) {
        return parent.geometry(context.graph()) === "line" && !parent.isClosed() && parent.affix(_vertex.id) && (_geometries.line.length === 0 || _geometries.line[0] === parent);
      }) : [];
    }
    var _candidates = candidateWays();
    var operation2 = function() {
      var candidate = _candidates[0];
      context.enter(
        modeDrawLine(context, candidate.id, context.graph(), "line", candidate.affix(_vertex.id), true)
      );
    };
    operation2.relatedEntityIds = function() {
      return _candidates.length ? [_candidates[0].id] : [];
    };
    operation2.available = function() {
      return _geometries.vertex.length === 1 && _geometries.line.length <= 1 && !context.features().hasHiddenConnections(_vertex, context.graph());
    };
    operation2.disabled = function() {
      if (_candidates.length === 0) {
        return "not_eligible";
      } else if (_candidates.length > 1) {
        return "multiple";
      }
      return false;
    };
    operation2.tooltip = function() {
      var disable = operation2.disabled();
      return disable ? _t.append("operations.continue." + disable) : _t.append("operations.continue.description");
    };
    operation2.annotation = function() {
      return _t("operations.continue.annotation.line");
    };
    operation2.id = "continue";
    operation2.keys = [_t("operations.continue.key")];
    operation2.title = _t.append("operations.continue.title");
    operation2.behavior = behaviorOperation(context).which(operation2);
    return operation2;
  }

  // modules/operations/copy.js
  function operationCopy(context, selectedIDs) {
    function getFilteredIdsToCopy() {
      return selectedIDs.filter(function(selectedID) {
        var entity = context.graph().hasEntity(selectedID);
        return entity.hasInterestingTags() || entity.geometry(context.graph()) !== "vertex";
      });
    }
    var operation2 = function() {
      var graph = context.graph();
      var selected = groupEntities(getFilteredIdsToCopy(), graph);
      var canCopy = [];
      var skip = {};
      var entity;
      var i3;
      for (i3 = 0; i3 < selected.relation.length; i3++) {
        entity = selected.relation[i3];
        if (!skip[entity.id] && entity.isComplete(graph)) {
          canCopy.push(entity.id);
          skip = getDescendants(entity.id, graph, skip);
        }
      }
      for (i3 = 0; i3 < selected.way.length; i3++) {
        entity = selected.way[i3];
        if (!skip[entity.id]) {
          canCopy.push(entity.id);
          skip = getDescendants(entity.id, graph, skip);
        }
      }
      for (i3 = 0; i3 < selected.node.length; i3++) {
        entity = selected.node[i3];
        if (!skip[entity.id]) {
          canCopy.push(entity.id);
        }
      }
      context.copyIDs(canCopy);
      if (_point && (canCopy.length !== 1 || graph.entity(canCopy[0]).type !== "node")) {
        context.copyLonLat(context.projection.invert(_point));
      } else {
        context.copyLonLat(null);
      }
    };
    function groupEntities(ids, graph) {
      var entities = ids.map(function(id2) {
        return graph.entity(id2);
      });
      return Object.assign(
        { relation: [], way: [], node: [] },
        utilArrayGroupBy(entities, "type")
      );
    }
    function getDescendants(id2, graph, descendants) {
      var entity = graph.entity(id2);
      var children2;
      descendants = descendants || {};
      if (entity.type === "relation") {
        children2 = entity.members.map(function(m2) {
          return m2.id;
        });
      } else if (entity.type === "way") {
        children2 = entity.nodes;
      } else {
        children2 = [];
      }
      for (var i3 = 0; i3 < children2.length; i3++) {
        if (!descendants[children2[i3]]) {
          descendants[children2[i3]] = true;
          descendants = getDescendants(children2[i3], graph, descendants);
        }
      }
      return descendants;
    }
    operation2.available = function() {
      return getFilteredIdsToCopy().length > 0;
    };
    operation2.disabled = function() {
      var extent = utilTotalExtent(getFilteredIdsToCopy(), context.graph());
      if (extent.percentContainedIn(context.map().extent()) < 0.8) {
        return "too_large";
      }
      return false;
    };
    operation2.availableForKeypress = function() {
      var selection2 = window.getSelection && window.getSelection();
      return !selection2 || !selection2.toString();
    };
    operation2.tooltip = function() {
      var disable = operation2.disabled();
      return disable ? _t.append("operations.copy." + disable, { n: selectedIDs.length }) : _t.append("operations.copy.description", { n: selectedIDs.length });
    };
    operation2.annotation = function() {
      return _t("operations.copy.annotation", { n: selectedIDs.length });
    };
    var _point;
    operation2.point = function(val) {
      _point = val;
      return operation2;
    };
    operation2.id = "copy";
    operation2.keys = [uiCmd("\u2318C")];
    operation2.title = _t.append("operations.copy.title");
    operation2.behavior = behaviorOperation(context).which(operation2);
    return operation2;
  }

  // modules/operations/disconnect.js
  function operationDisconnect(context, selectedIDs) {
    var _vertexIDs = [];
    var _wayIDs = [];
    var _otherIDs = [];
    var _actions = [];
    selectedIDs.forEach(function(id2) {
      var entity = context.entity(id2);
      if (entity.type === "way") {
        _wayIDs.push(id2);
      } else if (entity.geometry(context.graph()) === "vertex") {
        _vertexIDs.push(id2);
      } else {
        _otherIDs.push(id2);
      }
    });
    var _coords, _descriptionID = "", _annotationID = "features";
    var _disconnectingVertexIds = [];
    var _disconnectingWayIds = [];
    if (_vertexIDs.length > 0) {
      _disconnectingVertexIds = _vertexIDs;
      _vertexIDs.forEach(function(vertexID) {
        var action = actionDisconnect(vertexID);
        if (_wayIDs.length > 0) {
          var waysIDsForVertex = _wayIDs.filter(function(wayID) {
            var way = context.entity(wayID);
            return way.nodes.indexOf(vertexID) !== -1;
          });
          action.limitWays(waysIDsForVertex);
        }
        _actions.push(action);
        _disconnectingWayIds = _disconnectingWayIds.concat(context.graph().parentWays(context.graph().entity(vertexID)).map((d2) => d2.id));
      });
      _disconnectingWayIds = utilArrayUniq(_disconnectingWayIds).filter(function(id2) {
        return _wayIDs.indexOf(id2) === -1;
      });
      _descriptionID += _actions.length === 1 ? "single_point." : "multiple_points.";
      if (_wayIDs.length === 1) {
        _descriptionID += "single_way." + context.graph().geometry(_wayIDs[0]);
      } else {
        _descriptionID += _wayIDs.length === 0 ? "no_ways" : "multiple_ways";
      }
    } else if (_wayIDs.length > 0) {
      var ways = _wayIDs.map(function(id2) {
        return context.entity(id2);
      });
      var nodes = utilGetAllNodes(_wayIDs, context.graph());
      _coords = nodes.map(function(n3) {
        return n3.loc;
      });
      var sharedActions = [];
      var sharedNodes = [];
      var unsharedActions = [];
      var unsharedNodes = [];
      nodes.forEach(function(node) {
        var action = actionDisconnect(node.id).limitWays(_wayIDs);
        if (action.disabled(context.graph()) !== "not_connected") {
          var count = 0;
          for (var i3 in ways) {
            var way = ways[i3];
            if (way.nodes.indexOf(node.id) !== -1) {
              count += 1;
            }
            if (count > 1)
              break;
          }
          if (count > 1) {
            sharedActions.push(action);
            sharedNodes.push(node);
          } else {
            unsharedActions.push(action);
            unsharedNodes.push(node);
          }
        }
      });
      _descriptionID += "no_points.";
      _descriptionID += _wayIDs.length === 1 ? "single_way." : "multiple_ways.";
      if (sharedActions.length) {
        _actions = sharedActions;
        _disconnectingVertexIds = sharedNodes.map((node) => node.id);
        _descriptionID += "conjoined";
        _annotationID = "from_each_other";
      } else {
        _actions = unsharedActions;
        _disconnectingVertexIds = unsharedNodes.map((node) => node.id);
        if (_wayIDs.length === 1) {
          _descriptionID += context.graph().geometry(_wayIDs[0]);
        } else {
          _descriptionID += "separate";
        }
      }
    }
    var _extent = utilTotalExtent(_disconnectingVertexIds, context.graph());
    var operation2 = function() {
      context.perform(function(graph) {
        return _actions.reduce(function(graph2, action) {
          return action(graph2);
        }, graph);
      }, operation2.annotation());
      context.validator().validate();
    };
    operation2.relatedEntityIds = function() {
      if (_vertexIDs.length) {
        return _disconnectingWayIds;
      }
      return _disconnectingVertexIds;
    };
    operation2.available = function() {
      if (_actions.length === 0)
        return false;
      if (_otherIDs.length !== 0)
        return false;
      if (_vertexIDs.length !== 0 && _wayIDs.length !== 0 && !_wayIDs.every(function(wayID) {
        return _vertexIDs.some(function(vertexID) {
          var way = context.entity(wayID);
          return way.nodes.indexOf(vertexID) !== -1;
        });
      }))
        return false;
      return true;
    };
    operation2.disabled = function() {
      var reason;
      for (var actionIndex in _actions) {
        reason = _actions[actionIndex].disabled(context.graph());
        if (reason)
          return reason;
      }
      if (_extent && _extent.percentContainedIn(context.map().extent()) < 0.8) {
        return "too_large." + ((_vertexIDs.length ? _vertexIDs : _wayIDs).length === 1 ? "single" : "multiple");
      } else if (_coords && someMissing()) {
        return "not_downloaded";
      } else if (selectedIDs.some(context.hasHiddenConnections)) {
        return "connected_to_hidden";
      }
      return false;
      function someMissing() {
        if (context.inIntro())
          return false;
        var osm = context.connection();
        if (osm) {
          var missing = _coords.filter(function(loc) {
            return !osm.isDataLoaded(loc);
          });
          if (missing.length) {
            missing.forEach(function(loc) {
              context.loadTileAtLoc(loc);
            });
            return true;
          }
        }
        return false;
      }
    };
    operation2.tooltip = function() {
      var disable = operation2.disabled();
      return disable ? _t.append("operations.disconnect." + disable) : _t.append("operations.disconnect.description." + _descriptionID);
    };
    operation2.annotation = function() {
      return _t("operations.disconnect.annotation." + _annotationID);
    };
    operation2.id = "disconnect";
    operation2.keys = [_t("operations.disconnect.key")];
    operation2.title = _t.append("operations.disconnect.title");
    operation2.behavior = behaviorOperation(context).which(operation2);
    return operation2;
  }

  // modules/operations/downgrade.js
  function operationDowngrade(context, selectedIDs) {
    var _affectedFeatureCount = 0;
    var _downgradeType = downgradeTypeForEntityIDs(selectedIDs);
    var _multi = _affectedFeatureCount === 1 ? "single" : "multiple";
    function downgradeTypeForEntityIDs(entityIds) {
      var downgradeType;
      _affectedFeatureCount = 0;
      for (var i3 in entityIds) {
        var entityID = entityIds[i3];
        var type2 = downgradeTypeForEntityID(entityID);
        if (type2) {
          _affectedFeatureCount += 1;
          if (downgradeType && type2 !== downgradeType) {
            if (downgradeType !== "generic" && type2 !== "generic") {
              downgradeType = "building_address";
            } else {
              downgradeType = "generic";
            }
          } else {
            downgradeType = type2;
          }
        }
      }
      return downgradeType;
    }
    function downgradeTypeForEntityID(entityID) {
      var graph = context.graph();
      var entity = graph.entity(entityID);
      var preset = _mainPresetIndex.match(entity, graph);
      if (!preset || preset.isFallback())
        return null;
      if (entity.type === "node" && preset.id !== "address" && Object.keys(entity.tags).some(function(key) {
        return key.match(/^addr:.{1,}/);
      })) {
        return "address";
      }
      var geometry = entity.geometry(graph);
      if (geometry === "area" && entity.tags.building && !preset.tags.building) {
        return "building";
      }
      if (geometry === "vertex" && Object.keys(entity.tags).length) {
        return "generic";
      }
      return null;
    }
    var buildingKeysToKeep = ["architect", "building", "height", "layer", "nycdoitt:bin", "source", "type", "wheelchair"];
    var addressKeysToKeep = ["source"];
    var operation2 = function() {
      context.perform(function(graph) {
        for (var i3 in selectedIDs) {
          var entityID = selectedIDs[i3];
          var type2 = downgradeTypeForEntityID(entityID);
          if (!type2)
            continue;
          var tags = Object.assign({}, graph.entity(entityID).tags);
          for (var key in tags) {
            if (type2 === "address" && addressKeysToKeep.indexOf(key) !== -1)
              continue;
            if (type2 === "building") {
              if (buildingKeysToKeep.indexOf(key) !== -1 || key.match(/^building:.{1,}/) || key.match(/^roof:.{1,}/))
                continue;
            }
            if (type2 !== "generic") {
              if (key.match(/^addr:.{1,}/) || key.match(/^source:.{1,}/))
                continue;
            }
            delete tags[key];
          }
          graph = actionChangeTags(entityID, tags)(graph);
        }
        return graph;
      }, operation2.annotation());
      context.validator().validate();
      context.enter(modeSelect(context, selectedIDs));
    };
    operation2.available = function() {
      return _downgradeType;
    };
    operation2.disabled = function() {
      if (selectedIDs.some(hasWikidataTag)) {
        return "has_wikidata_tag";
      }
      return false;
      function hasWikidataTag(id2) {
        var entity = context.entity(id2);
        return entity.tags.wikidata && entity.tags.wikidata.trim().length > 0;
      }
    };
    operation2.tooltip = function() {
      var disable = operation2.disabled();
      return disable ? _t.append("operations.downgrade." + disable + "." + _multi) : _t.append("operations.downgrade.description." + _downgradeType);
    };
    operation2.annotation = function() {
      var suffix;
      if (_downgradeType === "building_address") {
        suffix = "generic";
      } else {
        suffix = _downgradeType;
      }
      return _t("operations.downgrade.annotation." + suffix, { n: _affectedFeatureCount });
    };
    operation2.id = "downgrade";
    operation2.keys = [uiCmd("\u232B")];
    operation2.title = _t.append("operations.downgrade.title");
    operation2.behavior = behaviorOperation(context).which(operation2);
    return operation2;
  }

  // modules/operations/extract.js
  function operationExtract(context, selectedIDs) {
    var _amount = selectedIDs.length === 1 ? "single" : "multiple";
    var _geometries = utilArrayUniq(selectedIDs.map(function(entityID) {
      return context.graph().hasEntity(entityID) && context.graph().geometry(entityID);
    }).filter(Boolean));
    var _geometryID = _geometries.length === 1 ? _geometries[0] : "feature";
    var _extent;
    var _actions = selectedIDs.map(function(entityID) {
      var graph = context.graph();
      var entity = graph.hasEntity(entityID);
      if (!entity || !entity.hasInterestingTags())
        return null;
      if (entity.type === "node" && graph.parentWays(entity).length === 0)
        return null;
      if (entity.type !== "node") {
        var preset = _mainPresetIndex.match(entity, graph);
        if (preset.geometry.indexOf("point") === -1)
          return null;
      }
      _extent = _extent ? _extent.extend(entity.extent(graph)) : entity.extent(graph);
      return actionExtract(entityID, context.projection);
    }).filter(Boolean);
    var operation2 = function() {
      var combinedAction = function(graph) {
        _actions.forEach(function(action) {
          graph = action(graph);
        });
        return graph;
      };
      context.perform(combinedAction, operation2.annotation());
      var extractedNodeIDs = _actions.map(function(action) {
        return action.getExtractedNodeID();
      });
      context.enter(modeSelect(context, extractedNodeIDs));
    };
    operation2.available = function() {
      return _actions.length && selectedIDs.length === _actions.length;
    };
    operation2.disabled = function() {
      if (_extent && _extent.percentContainedIn(context.map().extent()) < 0.8) {
        return "too_large";
      } else if (selectedIDs.some(function(entityID) {
        return context.graph().geometry(entityID) === "vertex" && context.hasHiddenConnections(entityID);
      })) {
        return "connected_to_hidden";
      }
      return false;
    };
    operation2.tooltip = function() {
      var disableReason = operation2.disabled();
      if (disableReason) {
        return _t.append("operations.extract." + disableReason + "." + _amount);
      } else {
        return _t.append("operations.extract.description." + _geometryID + "." + _amount);
      }
    };
    operation2.annotation = function() {
      return _t("operations.extract.annotation", { n: selectedIDs.length });
    };
    operation2.id = "extract";
    operation2.keys = [_t("operations.extract.key")];
    operation2.title = _t.append("operations.extract.title");
    operation2.behavior = behaviorOperation(context).which(operation2);
    return operation2;
  }

  // modules/operations/merge.js
  function operationMerge(context, selectedIDs) {
    var _action = getAction();
    function getAction() {
      var join = actionJoin(selectedIDs);
      if (!join.disabled(context.graph()))
        return join;
      var merge2 = actionMerge(selectedIDs);
      if (!merge2.disabled(context.graph()))
        return merge2;
      var mergePolygon = actionMergePolygon(selectedIDs);
      if (!mergePolygon.disabled(context.graph()))
        return mergePolygon;
      var mergeNodes = actionMergeNodes(selectedIDs);
      if (!mergeNodes.disabled(context.graph()))
        return mergeNodes;
      if (join.disabled(context.graph()) !== "not_eligible")
        return join;
      if (merge2.disabled(context.graph()) !== "not_eligible")
        return merge2;
      if (mergePolygon.disabled(context.graph()) !== "not_eligible")
        return mergePolygon;
      return mergeNodes;
    }
    var operation2 = function() {
      if (operation2.disabled())
        return;
      context.perform(_action, operation2.annotation());
      context.validator().validate();
      var resultIDs = selectedIDs.filter(context.hasEntity);
      if (resultIDs.length > 1) {
        var interestingIDs = resultIDs.filter(function(id2) {
          return context.entity(id2).hasInterestingTags();
        });
        if (interestingIDs.length)
          resultIDs = interestingIDs;
      }
      context.enter(modeSelect(context, resultIDs));
    };
    operation2.available = function() {
      return selectedIDs.length >= 2;
    };
    operation2.disabled = function() {
      var actionDisabled = _action.disabled(context.graph());
      if (actionDisabled)
        return actionDisabled;
      var osm = context.connection();
      if (osm && _action.resultingWayNodesLength && _action.resultingWayNodesLength(context.graph()) > osm.maxWayNodes()) {
        return "too_many_vertices";
      }
      return false;
    };
    operation2.tooltip = function() {
      var disabled = operation2.disabled();
      if (disabled) {
        if (disabled === "conflicting_relations") {
          return _t.append("operations.merge.conflicting_relations");
        }
        if (disabled === "restriction" || disabled === "connectivity") {
          return _t.append(
            "operations.merge.damage_relation",
            { relation: _mainPresetIndex.item("type/" + disabled).name() }
          );
        }
        return _t.append("operations.merge." + disabled);
      }
      return _t.append("operations.merge.description");
    };
    operation2.annotation = function() {
      return _t("operations.merge.annotation", { n: selectedIDs.length });
    };
    operation2.id = "merge";
    operation2.keys = [_t("operations.merge.key")];
    operation2.title = _t.append("operations.merge.title");
    operation2.behavior = behaviorOperation(context).which(operation2);
    return operation2;
  }

  // modules/operations/paste.js
  function operationPaste(context) {
    var _pastePoint;
    var operation2 = function() {
      if (!_pastePoint)
        return;
      var oldIDs = context.copyIDs();
      if (!oldIDs.length)
        return;
      var projection2 = context.projection;
      var extent = geoExtent();
      var oldGraph = context.copyGraph();
      var newIDs = [];
      var action = actionCopyEntities(oldIDs, oldGraph);
      context.perform(action);
      var copies = action.copies();
      var originals = /* @__PURE__ */ new Set();
      Object.values(copies).forEach(function(entity) {
        originals.add(entity.id);
      });
      for (var id2 in copies) {
        var oldEntity = oldGraph.entity(id2);
        var newEntity = copies[id2];
        extent._extend(oldEntity.extent(oldGraph));
        var parents = context.graph().parentWays(newEntity);
        var parentCopied = parents.some(function(parent) {
          return originals.has(parent.id);
        });
        if (!parentCopied) {
          newIDs.push(newEntity.id);
        }
      }
      var copyPoint = context.copyLonLat() && projection2(context.copyLonLat()) || projection2(extent.center());
      var delta = geoVecSubtract(_pastePoint, copyPoint);
      context.replace(actionMove(newIDs, delta, projection2), operation2.annotation());
      context.enter(modeSelect(context, newIDs));
    };
    operation2.point = function(val) {
      _pastePoint = val;
      return operation2;
    };
    operation2.available = function() {
      return context.mode().id === "browse";
    };
    operation2.disabled = function() {
      return !context.copyIDs().length;
    };
    operation2.tooltip = function() {
      var oldGraph = context.copyGraph();
      var ids = context.copyIDs();
      if (!ids.length) {
        return _t.append("operations.paste.nothing_copied");
      }
      return _t.append("operations.paste.description", { feature: utilDisplayLabel(oldGraph.entity(ids[0]), oldGraph), n: ids.length });
    };
    operation2.annotation = function() {
      var ids = context.copyIDs();
      return _t("operations.paste.annotation", { n: ids.length });
    };
    operation2.id = "paste";
    operation2.keys = [uiCmd("\u2318V")];
    operation2.title = _t.append("operations.paste.title");
    return operation2;
  }

  // modules/operations/reverse.js
  function operationReverse(context, selectedIDs) {
    var operation2 = function() {
      context.perform(function combinedReverseAction(graph) {
        actions().forEach(function(action) {
          graph = action(graph);
        });
        return graph;
      }, operation2.annotation());
      context.validator().validate();
    };
    function actions(situation) {
      return selectedIDs.map(function(entityID) {
        var entity = context.hasEntity(entityID);
        if (!entity)
          return null;
        if (situation === "toolbar") {
          if (entity.type === "way" && (!entity.isOneWay() && !entity.isSided()))
            return null;
        }
        var geometry = entity.geometry(context.graph());
        if (entity.type !== "node" && geometry !== "line")
          return null;
        var action = actionReverse(entityID);
        if (action.disabled(context.graph()))
          return null;
        return action;
      }).filter(Boolean);
    }
    function reverseTypeID() {
      var acts = actions();
      var nodeActionCount = acts.filter(function(act) {
        var entity = context.hasEntity(act.entityID());
        return entity && entity.type === "node";
      }).length;
      if (nodeActionCount === 0)
        return "line";
      if (nodeActionCount === acts.length)
        return "point";
      return "feature";
    }
    operation2.available = function(situation) {
      return actions(situation).length > 0;
    };
    operation2.disabled = function() {
      return false;
    };
    operation2.tooltip = function() {
      return _t.append("operations.reverse.description." + reverseTypeID());
    };
    operation2.annotation = function() {
      var acts = actions();
      return _t("operations.reverse.annotation." + reverseTypeID(), { n: acts.length });
    };
    operation2.id = "reverse";
    operation2.keys = [_t("operations.reverse.key")];
    operation2.title = _t.append("operations.reverse.title");
    operation2.behavior = behaviorOperation(context).which(operation2);
    return operation2;
  }

  // modules/operations/split.js
  function operationSplit(context, selectedIDs) {
    var _vertexIds = selectedIDs.filter(function(id2) {
      return context.graph().geometry(id2) === "vertex";
    });
    var _selectedWayIds = selectedIDs.filter(function(id2) {
      var entity = context.graph().hasEntity(id2);
      return entity && entity.type === "way";
    });
    var _isAvailable = _vertexIds.length > 0 && _vertexIds.length + _selectedWayIds.length === selectedIDs.length;
    var _action = actionSplit(_vertexIds);
    var _ways = [];
    var _geometry = "feature";
    var _waysAmount = "single";
    var _nodesAmount = _vertexIds.length === 1 ? "single" : "multiple";
    if (_isAvailable) {
      if (_selectedWayIds.length)
        _action.limitWays(_selectedWayIds);
      _ways = _action.ways(context.graph());
      var geometries = {};
      _ways.forEach(function(way) {
        geometries[way.geometry(context.graph())] = true;
      });
      if (Object.keys(geometries).length === 1) {
        _geometry = Object.keys(geometries)[0];
      }
      _waysAmount = _ways.length === 1 ? "single" : "multiple";
    }
    var operation2 = function() {
      var difference2 = context.perform(_action, operation2.annotation());
      var idsToSelect = _vertexIds.concat(difference2.extantIDs().filter(function(id2) {
        return context.entity(id2).type === "way";
      }));
      context.enter(modeSelect(context, idsToSelect));
    };
    operation2.relatedEntityIds = function() {
      return _selectedWayIds.length ? [] : _ways.map((way) => way.id);
    };
    operation2.available = function() {
      return _isAvailable;
    };
    operation2.disabled = function() {
      var reason = _action.disabled(context.graph());
      if (reason) {
        return reason;
      } else if (selectedIDs.some(context.hasHiddenConnections)) {
        return "connected_to_hidden";
      }
      return false;
    };
    operation2.tooltip = function() {
      var disable = operation2.disabled();
      return disable ? _t.append("operations.split." + disable) : _t.append("operations.split.description." + _geometry + "." + _waysAmount + "." + _nodesAmount + "_node");
    };
    operation2.annotation = function() {
      return _t("operations.split.annotation." + _geometry, { n: _ways.length });
    };
    operation2.icon = function() {
      if (_waysAmount === "multiple") {
        return "#iD-operation-split-multiple";
      } else {
        return "#iD-operation-split";
      }
    };
    operation2.id = "split";
    operation2.keys = [_t("operations.split.key")];
    operation2.title = _t.append("operations.split.title");
    operation2.behavior = behaviorOperation(context).which(operation2);
    return operation2;
  }

  // modules/operations/straighten.js
  function operationStraighten(context, selectedIDs) {
    var _wayIDs = selectedIDs.filter(function(id2) {
      return id2.charAt(0) === "w";
    });
    var _nodeIDs = selectedIDs.filter(function(id2) {
      return id2.charAt(0) === "n";
    });
    var _amount = (_wayIDs.length ? _wayIDs : _nodeIDs).length === 1 ? "single" : "multiple";
    var _nodes = utilGetAllNodes(selectedIDs, context.graph());
    var _coords = _nodes.map(function(n3) {
      return n3.loc;
    });
    var _extent = utilTotalExtent(selectedIDs, context.graph());
    var _action = chooseAction();
    var _geometry;
    function chooseAction() {
      if (_wayIDs.length === 0 && _nodeIDs.length > 2) {
        _geometry = "point";
        return actionStraightenNodes(_nodeIDs, context.projection);
      } else if (_wayIDs.length > 0 && (_nodeIDs.length === 0 || _nodeIDs.length === 2)) {
        var startNodeIDs = [];
        var endNodeIDs = [];
        for (var i3 = 0; i3 < selectedIDs.length; i3++) {
          var entity = context.entity(selectedIDs[i3]);
          if (entity.type === "node") {
            continue;
          } else if (entity.type !== "way" || entity.isClosed()) {
            return null;
          }
          startNodeIDs.push(entity.first());
          endNodeIDs.push(entity.last());
        }
        startNodeIDs = startNodeIDs.filter(function(n3) {
          return startNodeIDs.indexOf(n3) === startNodeIDs.lastIndexOf(n3);
        });
        endNodeIDs = endNodeIDs.filter(function(n3) {
          return endNodeIDs.indexOf(n3) === endNodeIDs.lastIndexOf(n3);
        });
        if (utilArrayDifference(startNodeIDs, endNodeIDs).length + utilArrayDifference(endNodeIDs, startNodeIDs).length !== 2)
          return null;
        var wayNodeIDs = utilGetAllNodes(_wayIDs, context.graph()).map(function(node) {
          return node.id;
        });
        if (wayNodeIDs.length <= 2)
          return null;
        if (_nodeIDs.length === 2 && (wayNodeIDs.indexOf(_nodeIDs[0]) === -1 || wayNodeIDs.indexOf(_nodeIDs[1]) === -1))
          return null;
        if (_nodeIDs.length) {
          _extent = utilTotalExtent(_nodeIDs, context.graph());
        }
        _geometry = "line";
        return actionStraightenWay(selectedIDs, context.projection);
      }
      return null;
    }
    function operation2() {
      if (!_action)
        return;
      context.perform(_action, operation2.annotation());
      window.setTimeout(function() {
        context.validator().validate();
      }, 300);
    }
    operation2.available = function() {
      return Boolean(_action);
    };
    operation2.disabled = function() {
      var reason = _action.disabled(context.graph());
      if (reason) {
        return reason;
      } else if (_extent.percentContainedIn(context.map().extent()) < 0.8) {
        return "too_large";
      } else if (someMissing()) {
        return "not_downloaded";
      } else if (selectedIDs.some(context.hasHiddenConnections)) {
        return "connected_to_hidden";
      }
      return false;
      function someMissing() {
        if (context.inIntro())
          return false;
        var osm = context.connection();
        if (osm) {
          var missing = _coords.filter(function(loc) {
            return !osm.isDataLoaded(loc);
          });
          if (missing.length) {
            missing.forEach(function(loc) {
              context.loadTileAtLoc(loc);
            });
            return true;
          }
        }
        return false;
      }
    };
    operation2.tooltip = function() {
      var disable = operation2.disabled();
      return disable ? _t.append("operations.straighten." + disable + "." + _amount) : _t.append("operations.straighten.description." + _geometry + (_wayIDs.length === 1 ? "" : "s"));
    };
    operation2.annotation = function() {
      return _t("operations.straighten.annotation." + _geometry, { n: _wayIDs.length ? _wayIDs.length : _nodeIDs.length });
    };
    operation2.id = "straighten";
    operation2.keys = [_t("operations.straighten.key")];
    operation2.title = _t.append("operations.straighten.title");
    operation2.behavior = behaviorOperation(context).which(operation2);
    return operation2;
  }

  // modules/modes/select.js
  function modeSelect(context, selectedIDs) {
    var mode = {
      id: "select",
      button: "browse"
    };
    var keybinding = utilKeybinding("select");
    var _breatheBehavior = behaviorBreathe(context);
    var _modeDragNode = modeDragNode(context);
    var _selectBehavior;
    var _behaviors = [];
    var _operations = [];
    var _newFeature = false;
    var _follow = false;
    var _focusedParentWayId;
    var _focusedVertexIds;
    function singular() {
      if (selectedIDs && selectedIDs.length === 1) {
        return context.hasEntity(selectedIDs[0]);
      }
    }
    function selectedEntities() {
      return selectedIDs.map(function(id2) {
        return context.hasEntity(id2);
      }).filter(Boolean);
    }
    function checkSelectedIDs() {
      var ids = [];
      if (Array.isArray(selectedIDs)) {
        ids = selectedIDs.filter(function(id2) {
          return context.hasEntity(id2);
        });
      }
      if (!ids.length) {
        context.enter(modeBrowse(context));
        return false;
      } else if (selectedIDs.length > 1 && ids.length === 1 || selectedIDs.length === 1 && ids.length > 1) {
        context.enter(modeSelect(context, ids));
        return false;
      }
      selectedIDs = ids;
      return true;
    }
    function parentWaysIdsOfSelection(onlyCommonParents) {
      var graph = context.graph();
      var parents = [];
      for (var i3 = 0; i3 < selectedIDs.length; i3++) {
        var entity = context.hasEntity(selectedIDs[i3]);
        if (!entity || entity.geometry(graph) !== "vertex") {
          return [];
        }
        var currParents = graph.parentWays(entity).map(function(w2) {
          return w2.id;
        });
        if (!parents.length) {
          parents = currParents;
          continue;
        }
        parents = (onlyCommonParents ? utilArrayIntersection : utilArrayUnion)(parents, currParents);
        if (!parents.length) {
          return [];
        }
      }
      return parents;
    }
    function childNodeIdsOfSelection(onlyCommon) {
      var graph = context.graph();
      var childs = [];
      for (var i3 = 0; i3 < selectedIDs.length; i3++) {
        var entity = context.hasEntity(selectedIDs[i3]);
        if (!entity || !["area", "line"].includes(entity.geometry(graph))) {
          return [];
        }
        var currChilds = graph.childNodes(entity).map(function(node) {
          return node.id;
        });
        if (!childs.length) {
          childs = currChilds;
          continue;
        }
        childs = (onlyCommon ? utilArrayIntersection : utilArrayUnion)(childs, currChilds);
        if (!childs.length) {
          return [];
        }
      }
      return childs;
    }
    function checkFocusedParent() {
      if (_focusedParentWayId) {
        var parents = parentWaysIdsOfSelection(true);
        if (parents.indexOf(_focusedParentWayId) === -1)
          _focusedParentWayId = null;
      }
    }
    function parentWayIdForVertexNavigation() {
      var parentIds = parentWaysIdsOfSelection(true);
      if (_focusedParentWayId && parentIds.indexOf(_focusedParentWayId) !== -1) {
        return _focusedParentWayId;
      }
      return parentIds.length ? parentIds[0] : null;
    }
    mode.selectedIDs = function(val) {
      if (!arguments.length)
        return selectedIDs;
      selectedIDs = val;
      return mode;
    };
    mode.zoomToSelected = function() {
      context.map().zoomToEase(selectedEntities());
    };
    mode.newFeature = function(val) {
      if (!arguments.length)
        return _newFeature;
      _newFeature = val;
      return mode;
    };
    mode.selectBehavior = function(val) {
      if (!arguments.length)
        return _selectBehavior;
      _selectBehavior = val;
      return mode;
    };
    mode.follow = function(val) {
      if (!arguments.length)
        return _follow;
      _follow = val;
      return mode;
    };
    function loadOperations() {
      _operations.forEach(function(operation2) {
        if (operation2.behavior) {
          context.uninstall(operation2.behavior);
        }
      });
      _operations = Object.values(operations_exports).map(function(o2) {
        return o2(context, selectedIDs);
      }).filter(function(o2) {
        return o2.id !== "delete" && o2.id !== "downgrade" && o2.id !== "copy";
      }).concat([
        // group copy/downgrade/delete operation together at the end of the list
        operationCopy(context, selectedIDs),
        operationDowngrade(context, selectedIDs),
        operationDelete(context, selectedIDs)
      ]).filter(function(operation2) {
        return operation2.available();
      });
      _operations.forEach(function(operation2) {
        if (operation2.behavior) {
          context.install(operation2.behavior);
        }
      });
      context.ui().closeEditMenu();
    }
    mode.operations = function() {
      return _operations;
    };
    mode.enter = function() {
      if (!checkSelectedIDs())
        return;
      context.features().forceVisible(selectedIDs);
      _modeDragNode.restoreSelectedIDs(selectedIDs);
      loadOperations();
      if (!_behaviors.length) {
        if (!_selectBehavior)
          _selectBehavior = behaviorSelect(context);
        _behaviors = [
          behaviorPaste(context),
          _breatheBehavior,
          behaviorHover(context).on("hover", context.ui().sidebar.hoverModeSelect),
          _selectBehavior,
          behaviorLasso(context),
          _modeDragNode.behavior,
          modeDragNote(context).behavior
        ];
      }
      _behaviors.forEach(context.install);
      keybinding.on(_t("inspector.zoom_to.key"), mode.zoomToSelected).on(["[", "pgup"], previousVertex).on(["]", "pgdown"], nextVertex).on(["{", uiCmd("\u2318["), "home"], firstVertex).on(["}", uiCmd("\u2318]"), "end"], lastVertex).on(uiCmd("\u21E7\u2190"), nudgeSelection([-10, 0])).on(uiCmd("\u21E7\u2191"), nudgeSelection([0, -10])).on(uiCmd("\u21E7\u2192"), nudgeSelection([10, 0])).on(uiCmd("\u21E7\u2193"), nudgeSelection([0, 10])).on(uiCmd("\u21E7\u2325\u2190"), nudgeSelection([-100, 0])).on(uiCmd("\u21E7\u2325\u2191"), nudgeSelection([0, -100])).on(uiCmd("\u21E7\u2325\u2192"), nudgeSelection([100, 0])).on(uiCmd("\u21E7\u2325\u2193"), nudgeSelection([0, 100])).on(utilKeybinding.plusKeys.map((key) => uiCmd("\u21E7" + key)), scaleSelection(1.05)).on(utilKeybinding.plusKeys.map((key) => uiCmd("\u21E7\u2325" + key)), scaleSelection(Math.pow(1.05, 5))).on(utilKeybinding.minusKeys.map((key) => uiCmd("\u21E7" + key)), scaleSelection(1 / 1.05)).on(utilKeybinding.minusKeys.map((key) => uiCmd("\u21E7\u2325" + key)), scaleSelection(1 / Math.pow(1.05, 5))).on(["\\", "pause"], focusNextParent).on(uiCmd("\u2318\u2191"), selectParent).on(uiCmd("\u2318\u2193"), selectChild).on("\u238B", esc, true);
      select_default2(document).call(keybinding);
      context.ui().sidebar.select(selectedIDs, _newFeature);
      context.history().on("change.select", function() {
        loadOperations();
        selectElements();
      }).on("undone.select", checkSelectedIDs).on("redone.select", checkSelectedIDs);
      context.map().on("drawn.select", selectElements).on("crossEditableZoom.select", function() {
        selectElements();
        _breatheBehavior.restartIfNeeded(context.surface());
      });
      context.map().doubleUpHandler().on("doubleUp.modeSelect", didDoubleUp);
      selectElements();
      if (_follow) {
        var extent = geoExtent();
        var graph = context.graph();
        selectedIDs.forEach(function(id2) {
          var entity = context.entity(id2);
          extent._extend(entity.extent(graph));
        });
        var loc = extent.center();
        context.map().centerEase(loc);
        _follow = false;
      }
      function nudgeSelection(delta) {
        return function() {
          if (!context.map().withinEditableZoom())
            return;
          var moveOp = operationMove(context, selectedIDs);
          if (moveOp.disabled()) {
            context.ui().flash.duration(4e3).iconName("#iD-operation-" + moveOp.id).iconClass("operation disabled").label(moveOp.tooltip())();
          } else {
            context.perform(actionMove(selectedIDs, delta, context.projection), moveOp.annotation());
            context.validator().validate();
          }
        };
      }
      function scaleSelection(factor) {
        return function() {
          if (!context.map().withinEditableZoom())
            return;
          let nodes = utilGetAllNodes(selectedIDs, context.graph());
          let isUp = factor > 1;
          if (nodes.length <= 1)
            return;
          let extent2 = utilTotalExtent(selectedIDs, context.graph());
          function scalingDisabled() {
            if (tooSmall()) {
              return "too_small";
            } else if (extent2.percentContainedIn(context.map().extent()) < 0.8) {
              return "too_large";
            } else if (someMissing() || selectedIDs.some(incompleteRelation)) {
              return "not_downloaded";
            } else if (selectedIDs.some(context.hasHiddenConnections)) {
              return "connected_to_hidden";
            }
            return false;
            function tooSmall() {
              if (isUp)
                return false;
              let dLon = Math.abs(extent2[1][0] - extent2[0][0]);
              let dLat = Math.abs(extent2[1][1] - extent2[0][1]);
              return dLon < geoMetersToLon(1, extent2[1][1]) && dLat < geoMetersToLat(1);
            }
            function someMissing() {
              if (context.inIntro())
                return false;
              let osm = context.connection();
              if (osm) {
                let missing = nodes.filter(function(n3) {
                  return !osm.isDataLoaded(n3.loc);
                });
                if (missing.length) {
                  missing.forEach(function(loc2) {
                    context.loadTileAtLoc(loc2);
                  });
                  return true;
                }
              }
              return false;
            }
            function incompleteRelation(id2) {
              let entity = context.entity(id2);
              return entity.type === "relation" && !entity.isComplete(context.graph());
            }
          }
          const disabled = scalingDisabled();
          if (disabled) {
            let multi = selectedIDs.length === 1 ? "single" : "multiple";
            context.ui().flash.duration(4e3).iconName("#iD-icon-no").iconClass("operation disabled").label(_t.append("operations.scale." + disabled + "." + multi))();
          } else {
            const pivot = context.projection(extent2.center());
            const annotation = _t("operations.scale.annotation." + (isUp ? "up" : "down") + ".feature", { n: selectedIDs.length });
            context.perform(actionScale(selectedIDs, pivot, factor, context.projection), annotation);
            context.validator().validate();
          }
        };
      }
      function didDoubleUp(d3_event, loc2) {
        if (!context.map().withinEditableZoom())
          return;
        var target = select_default2(d3_event.target);
        var datum2 = target.datum();
        var entity = datum2 && datum2.properties && datum2.properties.entity;
        if (!entity)
          return;
        if (entity instanceof osmWay && target.classed("target")) {
          var choice = geoChooseEdge(context.graph().childNodes(entity), loc2, context.projection);
          var prev = entity.nodes[choice.index - 1];
          var next = entity.nodes[choice.index];
          context.perform(
            actionAddMidpoint({ loc: choice.loc, edge: [prev, next] }, osmNode()),
            _t("operations.add.annotation.vertex")
          );
          context.validator().validate();
        } else if (entity.type === "midpoint") {
          context.perform(
            actionAddMidpoint({ loc: entity.loc, edge: entity.edge }, osmNode()),
            _t("operations.add.annotation.vertex")
          );
          context.validator().validate();
        }
      }
      function selectElements() {
        if (!checkSelectedIDs())
          return;
        var surface = context.surface();
        surface.selectAll(".selected-member").classed("selected-member", false);
        surface.selectAll(".selected").classed("selected", false);
        surface.selectAll(".related").classed("related", false);
        checkFocusedParent();
        if (_focusedParentWayId) {
          surface.selectAll(utilEntitySelector([_focusedParentWayId])).classed("related", true);
        }
        if (context.map().withinEditableZoom()) {
          surface.selectAll(utilDeepMemberSelector(
            selectedIDs,
            context.graph(),
            true
            /* skipMultipolgonMembers */
          )).classed("selected-member", true);
          surface.selectAll(utilEntityOrDeepMemberSelector(selectedIDs, context.graph())).classed("selected", true);
        }
      }
      function esc() {
        if (context.container().select(".combobox").size())
          return;
        context.enter(modeBrowse(context));
      }
      function firstVertex(d3_event) {
        d3_event.preventDefault();
        var entity = singular();
        var parentId = parentWayIdForVertexNavigation();
        var way;
        if (entity && entity.type === "way") {
          way = entity;
        } else if (parentId) {
          way = context.entity(parentId);
        }
        _focusedParentWayId = way && way.id;
        if (way) {
          context.enter(
            mode.selectedIDs([way.first()]).follow(true)
          );
        }
      }
      function lastVertex(d3_event) {
        d3_event.preventDefault();
        var entity = singular();
        var parentId = parentWayIdForVertexNavigation();
        var way;
        if (entity && entity.type === "way") {
          way = entity;
        } else if (parentId) {
          way = context.entity(parentId);
        }
        _focusedParentWayId = way && way.id;
        if (way) {
          context.enter(
            mode.selectedIDs([way.last()]).follow(true)
          );
        }
      }
      function previousVertex(d3_event) {
        d3_event.preventDefault();
        var parentId = parentWayIdForVertexNavigation();
        _focusedParentWayId = parentId;
        if (!parentId)
          return;
        var way = context.entity(parentId);
        var length2 = way.nodes.length;
        var curr = way.nodes.indexOf(selectedIDs[0]);
        var index = -1;
        if (curr > 0) {
          index = curr - 1;
        } else if (way.isClosed()) {
          index = length2 - 2;
        }
        if (index !== -1) {
          context.enter(
            mode.selectedIDs([way.nodes[index]]).follow(true)
          );
        }
      }
      function nextVertex(d3_event) {
        d3_event.preventDefault();
        var parentId = parentWayIdForVertexNavigation();
        _focusedParentWayId = parentId;
        if (!parentId)
          return;
        var way = context.entity(parentId);
        var length2 = way.nodes.length;
        var curr = way.nodes.indexOf(selectedIDs[0]);
        var index = -1;
        if (curr < length2 - 1) {
          index = curr + 1;
        } else if (way.isClosed()) {
          index = 0;
        }
        if (index !== -1) {
          context.enter(
            mode.selectedIDs([way.nodes[index]]).follow(true)
          );
        }
      }
      function focusNextParent(d3_event) {
        d3_event.preventDefault();
        var parents = parentWaysIdsOfSelection(true);
        if (!parents || parents.length < 2)
          return;
        var index = parents.indexOf(_focusedParentWayId);
        if (index < 0 || index > parents.length - 2) {
          _focusedParentWayId = parents[0];
        } else {
          _focusedParentWayId = parents[index + 1];
        }
        var surface = context.surface();
        surface.selectAll(".related").classed("related", false);
        if (_focusedParentWayId) {
          surface.selectAll(utilEntitySelector([_focusedParentWayId])).classed("related", true);
        }
      }
      function selectParent(d3_event) {
        d3_event.preventDefault();
        var currentSelectedIds = mode.selectedIDs();
        var parentIds = _focusedParentWayId ? [_focusedParentWayId] : parentWaysIdsOfSelection(false);
        if (!parentIds.length)
          return;
        context.enter(
          mode.selectedIDs(parentIds)
        );
        _focusedVertexIds = currentSelectedIds;
      }
      function selectChild(d3_event) {
        d3_event.preventDefault();
        var currentSelectedIds = mode.selectedIDs();
        var childIds = _focusedVertexIds ? _focusedVertexIds.filter((id2) => context.hasEntity(id2)) : childNodeIdsOfSelection(true);
        if (!childIds || !childIds.length)
          return;
        if (currentSelectedIds.length === 1)
          _focusedParentWayId = currentSelectedIds[0];
        context.enter(
          mode.selectedIDs(childIds)
        );
      }
    };
    mode.exit = function() {
      _newFeature = false;
      _focusedVertexIds = null;
      _operations.forEach(function(operation2) {
        if (operation2.behavior) {
          context.uninstall(operation2.behavior);
        }
      });
      _operations = [];
      _behaviors.forEach(context.uninstall);
      select_default2(document).call(keybinding.unbind);
      context.ui().closeEditMenu();
      context.history().on("change.select", null).on("undone.select", null).on("redone.select", null);
      var surface = context.surface();
      surface.selectAll(".selected-member").classed("selected-member", false);
      surface.selectAll(".selected").classed("selected", false);
      surface.selectAll(".highlighted").classed("highlighted", false);
      surface.selectAll(".related").classed("related", false);
      context.map().on("drawn.select", null);
      context.ui().sidebar.hide();
      context.features().forceVisible([]);
      var entity = singular();
      if (_newFeature && entity && entity.type === "relation" && // no tags
      Object.keys(entity.tags).length === 0 && // no parent relations
      context.graph().parentRelations(entity).length === 0 && // no members or one member with no role
      (entity.members.length === 0 || entity.members.length === 1 && !entity.members[0].role)) {
        var deleteAction = actionDeleteRelation(
          entity.id,
          true
          /* don't delete untagged members */
        );
        context.perform(deleteAction, _t("operations.delete.annotation.relation"));
        context.validator().validate();
      }
    };
    return mode;
  }

  // modules/behavior/lasso.js
  function behaviorLasso(context) {
    var _pointerPrefix = "PointerEvent" in window ? "pointer" : "mouse";
    var behavior = function(selection2) {
      var lasso;
      function pointerdown(d3_event) {
        var button = 0;
        if (d3_event.button === button && d3_event.shiftKey === true) {
          lasso = null;
          select_default2(window).on(_pointerPrefix + "move.lasso", pointermove).on(_pointerPrefix + "up.lasso", pointerup);
          d3_event.stopPropagation();
        }
      }
      function pointermove() {
        if (!lasso) {
          lasso = uiLasso(context);
          context.surface().call(lasso);
        }
        lasso.p(context.map().mouse());
      }
      function normalize2(a2, b2) {
        return [
          [Math.min(a2[0], b2[0]), Math.min(a2[1], b2[1])],
          [Math.max(a2[0], b2[0]), Math.max(a2[1], b2[1])]
        ];
      }
      function lassoed() {
        if (!lasso)
          return [];
        var graph = context.graph();
        var limitToNodes;
        if (context.map().editableDataEnabled(
          true
          /* skipZoomCheck */
        ) && context.map().isInWideSelection()) {
          limitToNodes = new Set(utilGetAllNodes(context.selectedIDs(), graph));
        } else if (!context.map().editableDataEnabled()) {
          return [];
        }
        var bounds = lasso.extent().map(context.projection.invert);
        var extent = geoExtent(normalize2(bounds[0], bounds[1]));
        var intersects = context.history().intersects(extent).filter(function(entity) {
          return entity.type === "node" && (!limitToNodes || limitToNodes.has(entity)) && geoPointInPolygon(context.projection(entity.loc), lasso.coordinates) && !context.features().isHidden(entity, graph, entity.geometry(graph));
        });
        intersects.sort(function(node1, node2) {
          var parents1 = graph.parentWays(node1);
          var parents2 = graph.parentWays(node2);
          if (parents1.length && parents2.length) {
            var sharedParents = utilArrayIntersection(parents1, parents2);
            if (sharedParents.length) {
              var sharedParentNodes = sharedParents[0].nodes;
              return sharedParentNodes.indexOf(node1.id) - sharedParentNodes.indexOf(node2.id);
            } else {
              return Number(parents1[0].id.slice(1)) - Number(parents2[0].id.slice(1));
            }
          } else if (parents1.length || parents2.length) {
            return parents1.length - parents2.length;
          }
          return node1.loc[0] - node2.loc[0];
        });
        return intersects.map(function(entity) {
          return entity.id;
        });
      }
      function pointerup() {
        select_default2(window).on(_pointerPrefix + "move.lasso", null).on(_pointerPrefix + "up.lasso", null);
        if (!lasso)
          return;
        var ids = lassoed();
        lasso.close();
        if (ids.length) {
          context.enter(modeSelect(context, ids));
        }
      }
      selection2.on(_pointerPrefix + "down.lasso", pointerdown);
    };
    behavior.off = function(selection2) {
      selection2.on(_pointerPrefix + "down.lasso", null);
    };
    return behavior;
  }

  // modules/modes/browse.js
  function modeBrowse(context) {
    var mode = {
      button: "browse",
      id: "browse",
      title: _t.append("modes.browse.title"),
      description: _t.append("modes.browse.description")
    };
    var sidebar;
    var _selectBehavior;
    var _behaviors = [];
    mode.selectBehavior = function(val) {
      if (!arguments.length)
        return _selectBehavior;
      _selectBehavior = val;
      return mode;
    };
    mode.enter = function() {
      if (!_behaviors.length) {
        if (!_selectBehavior)
          _selectBehavior = behaviorSelect(context);
        _behaviors = [
          behaviorPaste(context),
          behaviorHover(context).on("hover", context.ui().sidebar.hover),
          _selectBehavior,
          behaviorLasso(context),
          modeDragNode(context).behavior,
          modeDragNote(context).behavior
        ];
      }
      _behaviors.forEach(context.install);
      if (document.activeElement && document.activeElement.blur) {
        document.activeElement.blur();
      }
      if (sidebar) {
        context.ui().sidebar.show(sidebar);
      } else {
        context.ui().sidebar.select(null);
      }
    };
    mode.exit = function() {
      context.ui().sidebar.hover.cancel();
      _behaviors.forEach(context.uninstall);
      if (sidebar) {
        context.ui().sidebar.hide();
      }
    };
    mode.sidebar = function(_2) {
      if (!arguments.length)
        return sidebar;
      sidebar = _2;
      return mode;
    };
    mode.operations = function() {
      return [operationPaste(context)];
    };
    return mode;
  }

  // modules/behavior/add_way.js
  function behaviorAddWay(context) {
    var dispatch14 = dispatch_default("start", "startFromWay", "startFromNode");
    var draw = behaviorDraw(context);
    function behavior(surface) {
      draw.on("click", function() {
        dispatch14.apply("start", this, arguments);
      }).on("clickWay", function() {
        dispatch14.apply("startFromWay", this, arguments);
      }).on("clickNode", function() {
        dispatch14.apply("startFromNode", this, arguments);
      }).on("cancel", behavior.cancel).on("finish", behavior.cancel);
      context.map().dblclickZoomEnable(false);
      surface.call(draw);
    }
    behavior.off = function(surface) {
      surface.call(draw.off);
    };
    behavior.cancel = function() {
      window.setTimeout(function() {
        context.map().dblclickZoomEnable(true);
      }, 1e3);
      context.enter(modeBrowse(context));
    };
    return utilRebind(behavior, dispatch14, "on");
  }

  // modules/behavior/hash.js
  function behaviorHash(context) {
    var _cachedHash = null;
    var _latitudeLimit = 90 - 1e-8;
    function computedHashParameters() {
      var map2 = context.map();
      var center = map2.center();
      var zoom = map2.zoom();
      var precision3 = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));
      var oldParams = utilObjectOmit(
        utilStringQs(window.location.hash),
        ["comment", "source", "hashtags", "walkthrough"]
      );
      var newParams = {};
      delete oldParams.id;
      var selected = context.selectedIDs().filter(function(id2) {
        return context.hasEntity(id2);
      });
      if (selected.length) {
        newParams.id = selected.join(",");
      }
      newParams.map = zoom.toFixed(2) + "/" + center[1].toFixed(precision3) + "/" + center[0].toFixed(precision3);
      return Object.assign(oldParams, newParams);
    }
    function computedHash() {
      return "#" + utilQsString(computedHashParameters(), true);
    }
    function computedTitle(includeChangeCount) {
      var baseTitle = context.documentTitleBase() || "iD";
      var contextual;
      var changeCount;
      var titleID;
      var selected = context.selectedIDs().filter(function(id2) {
        return context.hasEntity(id2);
      });
      if (selected.length) {
        var firstLabel = utilDisplayLabel(context.entity(selected[0]), context.graph());
        if (selected.length > 1) {
          contextual = _t("title.labeled_and_more", {
            labeled: firstLabel,
            count: selected.length - 1
          });
        } else {
          contextual = firstLabel;
        }
        titleID = "context";
      }
      if (includeChangeCount) {
        changeCount = context.history().difference().summary().length;
        if (changeCount > 0) {
          titleID = contextual ? "changes_context" : "changes";
        }
      }
      if (titleID) {
        return _t("title.format." + titleID, {
          changes: changeCount,
          base: baseTitle,
          context: contextual
        });
      }
      return baseTitle;
    }
    function updateTitle(includeChangeCount) {
      if (!context.setsDocumentTitle())
        return;
      var newTitle = computedTitle(includeChangeCount);
      if (document.title !== newTitle) {
        document.title = newTitle;
      }
    }
    function updateHashIfNeeded() {
      if (context.inIntro())
        return;
      var latestHash = computedHash();
      if (_cachedHash !== latestHash) {
        _cachedHash = latestHash;
        window.history.replaceState(null, computedTitle(
          false
          /* includeChangeCount */
        ), latestHash);
        updateTitle(
          true
          /* includeChangeCount */
        );
        const q2 = utilStringQs(latestHash);
        if (q2.map) {
          corePreferences("map-location", q2.map);
        }
      }
    }
    var _throttledUpdate = throttle_default(updateHashIfNeeded, 500);
    var _throttledUpdateTitle = throttle_default(function() {
      updateTitle(
        true
        /* includeChangeCount */
      );
    }, 500);
    function hashchange() {
      if (window.location.hash === _cachedHash)
        return;
      _cachedHash = window.location.hash;
      var q2 = utilStringQs(_cachedHash);
      var mapArgs = (q2.map || "").split("/").map(Number);
      if (mapArgs.length < 3 || mapArgs.some(isNaN)) {
        updateHashIfNeeded();
      } else {
        if (_cachedHash === computedHash())
          return;
        var mode = context.mode();
        context.map().centerZoom([mapArgs[2], Math.min(_latitudeLimit, Math.max(-_latitudeLimit, mapArgs[1]))], mapArgs[0]);
        if (q2.id && mode) {
          var ids = q2.id.split(",").filter(function(id2) {
            return context.hasEntity(id2);
          });
          if (ids.length && (mode.id === "browse" || mode.id === "select" && !utilArrayIdentical(mode.selectedIDs(), ids))) {
            context.enter(modeSelect(context, ids));
            return;
          }
        }
        var center = context.map().center();
        var dist = geoSphericalDistance(center, [mapArgs[2], mapArgs[1]]);
        var maxdist = 500;
        if (mode && mode.id.match(/^draw/) !== null && dist > maxdist) {
          context.enter(modeBrowse(context));
          return;
        }
      }
    }
    function behavior() {
      context.map().on("move.behaviorHash", _throttledUpdate);
      context.history().on("change.behaviorHash", _throttledUpdateTitle);
      context.on("enter.behaviorHash", _throttledUpdate);
      select_default2(window).on("hashchange.behaviorHash", hashchange);
      var q2 = utilStringQs(window.location.hash);
      if (q2.id) {
        context.zoomToEntity(q2.id.split(",")[0], !q2.map);
      }
      if (q2.walkthrough === "true") {
        behavior.startWalkthrough = true;
      }
      if (q2.map) {
        behavior.hadLocation = true;
      } else if (!q2.id && corePreferences("map-location")) {
        const mapArgs = corePreferences("map-location").split("/").map(Number);
        context.map().centerZoom([mapArgs[2], Math.min(_latitudeLimit, Math.max(-_latitudeLimit, mapArgs[1]))], mapArgs[0]);
        updateHashIfNeeded();
        behavior.hadLocation = true;
      }
      hashchange();
      updateTitle(false);
    }
    behavior.off = function() {
      _throttledUpdate.cancel();
      _throttledUpdateTitle.cancel();
      context.map().on("move.behaviorHash", null);
      context.on("enter.behaviorHash", null);
      select_default2(window).on("hashchange.behaviorHash", null);
      window.location.hash = "";
    };
    return behavior;
  }

  // node_modules/d3-brush/src/brush.js
  var { abs: abs2, max: max2, min: min2 } = Math;
  function number1(e3) {
    return [+e3[0], +e3[1]];
  }
  function number22(e3) {
    return [number1(e3[0]), number1(e3[1])];
  }
  var X3 = {
    name: "x",
    handles: ["w", "e"].map(type),
    input: function(x2, e3) {
      return x2 == null ? null : [[+x2[0], e3[0][1]], [+x2[1], e3[1][1]]];
    },
    output: function(xy) {
      return xy && [xy[0][0], xy[1][0]];
    }
  };
  var Y3 = {
    name: "y",
    handles: ["n", "s"].map(type),
    input: function(y2, e3) {
      return y2 == null ? null : [[e3[0][0], +y2[0]], [e3[1][0], +y2[1]]];
    },
    output: function(xy) {
      return xy && [xy[0][1], xy[1][1]];
    }
  };
  var XY = {
    name: "xy",
    handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
    input: function(xy) {
      return xy == null ? null : number22(xy);
    },
    output: function(xy) {
      return xy;
    }
  };
  function type(t2) {
    return { type: t2 };
  }

  // modules/index.js
  var debug = false;
  var d3 = {
    dispatch: dispatch_default,
    geoMercator: mercator_default,
    geoProjection: projection,
    polygonArea: area_default3,
    polygonCentroid: centroid_default2,
    select: select_default2,
    selectAll: selectAll_default2,
    timerFlush
  };

  // modules/id.js
  window.requestIdleCallback = window.requestIdleCallback || function(cb) {
    var start2 = Date.now();
    return window.requestAnimationFrame(function() {
      cb({
        didTimeout: false,
        timeRemaining: function() {
          return Math.max(0, 50 - (Date.now() - start2));
        }
      });
    });
  };
  window.cancelIdleCallback = window.cancelIdleCallback || function(id2) {
    window.cancelAnimationFrame(id2);
  };
  window.iD = modules_exports;
})();
//# sourceMappingURL=iD.js.map
