(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Mapillary = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var Queue = require('tinyqueue');

module.exports = polylabel;
module.exports.default = polylabel;

function polylabel(polygon, precision, debug) {
    precision = precision || 1.0;

    // find the bounding box of the outer ring
    var minX, minY, maxX, maxY;
    for (var i = 0; i < polygon[0].length; i++) {
        var p = polygon[0][i];
        if (!i || p[0] < minX) minX = p[0];
        if (!i || p[1] < minY) minY = p[1];
        if (!i || p[0] > maxX) maxX = p[0];
        if (!i || p[1] > maxY) maxY = p[1];
    }

    var width = maxX - minX;
    var height = maxY - minY;
    var cellSize = Math.min(width, height);
    var h = cellSize / 2;

    // a priority queue of cells in order of their "potential" (max distance to polygon)
    var cellQueue = new Queue(null, compareMax);

    if (cellSize === 0) return [minX, minY];

    // cover polygon with initial cells
    for (var x = minX; x < maxX; x += cellSize) {
        for (var y = minY; y < maxY; y += cellSize) {
            cellQueue.push(new Cell(x + h, y + h, h, polygon));
        }
    }

    // take centroid as the first best guess
    var bestCell = getCentroidCell(polygon);

    // special case for rectangular polygons
    var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);
    if (bboxCell.d > bestCell.d) bestCell = bboxCell;

    var numProbes = cellQueue.length;

    while (cellQueue.length) {
        // pick the most promising cell from the queue
        var cell = cellQueue.pop();

        // update the best cell if we found a better one
        if (cell.d > bestCell.d) {
            bestCell = cell;
            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);
        }

        // do not drill down further if there's no chance of a better solution
        if (cell.max - bestCell.d <= precision) continue;

        // split the cell into four cells
        h = cell.h / 2;
        cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));
        cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));
        cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));
        cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));
        numProbes += 4;
    }

    if (debug) {
        console.log('num probes: ' + numProbes);
        console.log('best distance: ' + bestCell.d);
    }

    return [bestCell.x, bestCell.y];
}

function compareMax(a, b) {
    return b.max - a.max;
}

function Cell(x, y, h, polygon) {
    this.x = x; // cell center x
    this.y = y; // cell center y
    this.h = h; // half the cell size
    this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon
    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell
}

// signed distance from point to polygon outline (negative if point is outside)
function pointToPolygonDist(x, y, polygon) {
    var inside = false;
    var minDistSq = Infinity;

    for (var k = 0; k < polygon.length; k++) {
        var ring = polygon[k];

        for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
            var a = ring[i];
            var b = ring[j];

            if ((a[1] > y !== b[1] > y) &&
                (x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0])) inside = !inside;

            minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));
        }
    }

    return (inside ? 1 : -1) * Math.sqrt(minDistSq);
}

// get polygon centroid
function getCentroidCell(polygon) {
    var area = 0;
    var x = 0;
    var y = 0;
    var points = polygon[0];

    for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {
        var a = points[i];
        var b = points[j];
        var f = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * f;
        y += (a[1] + b[1]) * f;
        area += f * 3;
    }
    if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);
    return new Cell(x / area, y / area, 0, polygon);
}

// get squared distance from a point to a segment
function getSegDistSq(px, py, a, b) {

    var x = a[0];
    var y = a[1];
    var dx = b[0] - x;
    var dy = b[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = b[0];
            y = b[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = px - x;
    dy = py - y;

    return dx * dx + dy * dy;
}

},{"tinyqueue":242}],2:[function(require,module,exports){
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

module.exports = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function(t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function(t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function(x, epsilon) {
    if (typeof epsilon === 'undefined') epsilon = 1e-6;

    var t0, t1, t2, x2, i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) return t2;

        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 1e-6) break;

        t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) return t0;
    if (t2 > t1) return t1;

    while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) return t2;

        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
};

UnitBezier.prototype.solve = function(x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

},{}],3:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],4:[function(require,module,exports){

},{}],5:[function(require,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],6:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],7:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":3,"ieee754":17}],8:[function(require,module,exports){
'use strict';

module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

},{}],9:[function(require,module,exports){
'use strict';

var OneVersionConstraint = require('individual/one-version');

var MY_VERSION = '7';
OneVersionConstraint('ev-store', MY_VERSION);

var hashKey = '__EV_STORE_KEY@' + MY_VERSION;

module.exports = EvStore;

function EvStore(elem) {
    var hash = elem[hashKey];

    if (!hash) {
        hash = elem[hashKey] = {};
    }

    return hash;
}

},{"individual/one-version":19}],10:[function(require,module,exports){
'use strict';
var request = require('./request');
var buildQueryObject = require('./buildQueryObject');
var isArray = Array.isArray;

function simpleExtend(obj, obj2) {
  var prop;
  for (prop in obj2) {
    obj[prop] = obj2[prop];
  }
  return obj;
}

function XMLHttpSource(jsongUrl, config) {
  this._jsongUrl = jsongUrl;
  if (typeof config === 'number') {
    var newConfig = {
      timeout: config
    };
    config = newConfig;
  }
  this._config = simpleExtend({
    timeout: 15000,
    headers: {}
  }, config || {});
}

XMLHttpSource.prototype = {
  // because javascript
  constructor: XMLHttpSource,
  /**
   * buildQueryObject helper
   */
  buildQueryObject: buildQueryObject,

  /**
   * @inheritDoc DataSource#get
   */
  get: function httpSourceGet(pathSet) {
    var method = 'GET';
    var queryObject = this.buildQueryObject(this._jsongUrl, method, {
      paths: pathSet,
      method: 'get'
    });
    var config = simpleExtend(queryObject, this._config);
    // pass context for onBeforeRequest callback
    var context = this;
    return request(method, config, context);
  },

  /**
   * @inheritDoc DataSource#set
   */
  set: function httpSourceSet(jsongEnv) {
    var method = 'POST';
    var queryObject = this.buildQueryObject(this._jsongUrl, method, {
      jsonGraph: jsongEnv,
      method: 'set'
    });
    var config = simpleExtend(queryObject, this._config);
    config.headers["Content-Type"] = "application/x-www-form-urlencoded";
    
    // pass context for onBeforeRequest callback
    var context = this;
    return request(method, config, context);

  },

  /**
   * @inheritDoc DataSource#call
   */
  call: function httpSourceCall(callPath, args, pathSuffix, paths) {
    // arguments defaults
    args = args || [];
    pathSuffix = pathSuffix || [];
    paths = paths || [];

    var method = 'POST';
    var queryData = [];
    queryData.push('method=call');
    queryData.push('callPath=' + encodeURIComponent(JSON.stringify(callPath)));
    queryData.push('arguments=' + encodeURIComponent(JSON.stringify(args)));
    queryData.push('pathSuffixes=' + encodeURIComponent(JSON.stringify(pathSuffix)));
    queryData.push('paths=' + encodeURIComponent(JSON.stringify(paths)));

    var queryObject = this.buildQueryObject(this._jsongUrl, method, queryData.join('&'));
    var config = simpleExtend(queryObject, this._config);
    config.headers["Content-Type"] = "application/x-www-form-urlencoded";
    
    // pass context for onBeforeRequest callback
    var context = this;
    return request(method, config, context);
  }
};
// ES6 modules
XMLHttpSource.XMLHttpSource = XMLHttpSource;
XMLHttpSource['default'] = XMLHttpSource;
// commonjs
module.exports = XMLHttpSource;

},{"./buildQueryObject":11,"./request":14}],11:[function(require,module,exports){
'use strict';
module.exports = function buildQueryObject(url, method, queryData) {
  var qData = [];
  var keys;
  var data = {url: url};
  var isQueryParamUrl = url.indexOf('?') !== -1;
  var startUrl = (isQueryParamUrl) ? '&' : '?';

  if (typeof queryData === 'string') {
    qData.push(queryData);
  } else {

    keys = Object.keys(queryData);
    keys.forEach(function (k) {
      var value = (typeof queryData[k] === 'object') ? JSON.stringify(queryData[k]) : queryData[k];
      qData.push(k + '=' + encodeURIComponent(value));
    });
  }

  if (method === 'GET') {
    data.url += startUrl + qData.join('&');
  } else {
    data.data = qData.join('&');
  }

  return data;
};

},{}],12:[function(require,module,exports){
(function (global){
'use strict';
// Get CORS support even for older IE
module.exports = function getCORSRequest() {
    var xhr = new global.XMLHttpRequest();
    if ('withCredentials' in xhr) {
        return xhr;
    } else if (!!global.XDomainRequest) {
        return new XDomainRequest();
    } else {
        throw new Error('CORS is not supported by your browser');
    }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],13:[function(require,module,exports){
(function (global){
'use strict';
module.exports = function getXMLHttpRequest() {
  var progId,
    progIds,
    i;
  if (global.XMLHttpRequest) {
    return new global.XMLHttpRequest();
  } else {
    try {
    progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
    for (i = 0; i < 3; i++) {
      try {
        progId = progIds[i];
        if (new global.ActiveXObject(progId)) {
          break;
        }
      } catch(e) { }
    }
    return new global.ActiveXObject(progId);
    } catch (e) {
    throw new Error('XMLHttpRequest is not supported by your browser');
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
'use strict';
var getXMLHttpRequest = require('./getXMLHttpRequest');
var getCORSRequest = require('./getCORSRequest');
var hasOwnProp = Object.prototype.hasOwnProperty;

var noop = function() {};

function Observable() {}

Observable.create = function(subscribe) {
  var o = new Observable();

  o.subscribe = function(onNext, onError, onCompleted) {

    var observer;
    var disposable;

    if (typeof onNext === 'function') {
        observer = {
            onNext: onNext,
            onError: (onError || noop),
            onCompleted: (onCompleted || noop)
        };
    } else {
        observer = onNext;
    }

    disposable = subscribe(observer);

    if (typeof disposable === 'function') {
      return {
        dispose: disposable
      };
    } else {
      return disposable;
    }
  };

  return o;
};

function request(method, options, context) {
  return Observable.create(function requestObserver(observer) {

    var config = {
      method: method || 'GET',
      crossDomain: false,
      async: true,
      headers: {},
      responseType: 'json'
    };

    var xhr,
      isDone,
      headers,
      header,
      prop;

    for (prop in options) {
      if (hasOwnProp.call(options, prop)) {
        config[prop] = options[prop];
      }
    }

    // Add request with Headers
    if (!config.crossDomain && !config.headers['X-Requested-With']) {
      config.headers['X-Requested-With'] = 'XMLHttpRequest';
    }

    // allow the user to mutate the config open
    if (context.onBeforeRequest != null) {
      context.onBeforeRequest(config);
    }

    // create xhr
    try {
      xhr = config.crossDomain ? getCORSRequest() : getXMLHttpRequest();
    } catch (err) {
      observer.onError(err);
    }
    try {
      // Takes the url and opens the connection
      if (config.user) {
        xhr.open(config.method, config.url, config.async, config.user, config.password);
      } else {
        xhr.open(config.method, config.url, config.async);
      }

      // Sets timeout information
      xhr.timeout = config.timeout;

      // Anything but explicit false results in true.
      xhr.withCredentials = config.withCredentials !== false;

      // Fills the request headers
      headers = config.headers;
      for (header in headers) {
        if (hasOwnProp.call(headers, header)) {
          xhr.setRequestHeader(header, headers[header]);
        }
      }

      if (config.responseType) {
        try {
          xhr.responseType = config.responseType;
        } catch (e) {
          // WebKit added support for the json responseType value on 09/03/2013
          // https://bugs.webkit.org/show_bug.cgi?id=73648. Versions of Safari prior to 7 are
          // known to throw when setting the value "json" as the response type. Other older
          // browsers implementing the responseType
          //
          // The json response type can be ignored if not supported, because JSON payloads are
          // parsed on the client-side regardless.
          if (config.responseType !== 'json') {
            throw e;
          }
        }
      }

      xhr.onreadystatechange = function onreadystatechange(e) {
        // Complete
        if (xhr.readyState === 4) {
          if (!isDone) {
            isDone = true;
            onXhrLoad(observer, xhr, e);
          }
        }
      };

      // Timeout
      xhr.ontimeout = function ontimeout(e) {
        if (!isDone) {
          isDone = true;
          onXhrError(observer, xhr, 'timeout error', e);
        }
      };

      // Send Request
      xhr.send(config.data);

    } catch (e) {
      observer.onError(e);
    }
    // Dispose
    return function dispose() {
      // Doesn't work in IE9
      if (!isDone && xhr.readyState !== 4) {
        isDone = true;
        xhr.abort();
      }
    };//Dispose
  });
}

/*
 * General handling of ultimate failure (after appropriate retries)
 */
function _handleXhrError(observer, textStatus, errorThrown) {
  // IE9: cross-domain request may be considered errors
  if (!errorThrown) {
    errorThrown = new Error(textStatus);
  }

  observer.onError(errorThrown);
}

function onXhrLoad(observer, xhr, e) {
  var responseData,
    responseObject,
    responseType;

  // If there's no observer, the request has been (or is being) cancelled.
  if (xhr && observer) {
    responseType = xhr.responseType;
    // responseText is the old-school way of retrieving response (supported by IE8 & 9)
    // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)
    responseData = ('response' in xhr) ? xhr.response : xhr.responseText;

    // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
    var status = (xhr.status === 1223) ? 204 : xhr.status;

    if (status >= 200 && status <= 399) {
      try {
        if (responseType !== 'json') {
          responseData = JSON.parse(responseData || '');
        }
        if (typeof responseData === 'string') {
          responseData = JSON.parse(responseData || '');
        }
      } catch (e) {
        _handleXhrError(observer, 'invalid json', e);
      }
      observer.onNext(responseData);
      observer.onCompleted();
      return;

    } else if (status === 401 || status === 403 || status === 407) {

      return _handleXhrError(observer, responseData);

    } else if (status === 410) {
      // TODO: Retry ?
      return _handleXhrError(observer, responseData);

    } else if (status === 408 || status === 504) {
      // TODO: Retry ?
      return _handleXhrError(observer, responseData);

    } else {

      return _handleXhrError(observer, responseData || ('Response code ' + status));

    }//if
  }//if
}//onXhrLoad

function onXhrError(observer, xhr, status, e) {
  _handleXhrError(observer, status || xhr.statusText || 'request error', e);
}

module.exports = request;

},{"./getCORSRequest":12,"./getXMLHttpRequest":13}],15:[function(require,module,exports){
(function (global){
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,e.falcor=t()}}(function(){var t;return function e(t,n,r){function o(s,u){if(!n[s]){if(!t[s]){var a="function"==typeof require&&require;if(!u&&a)return a(s,!0);if(i)return i(s,!0);var c=new Error("Cannot find module '"+s+"'");throw c.code="MODULE_NOT_FOUND",c}var p=n[s]={exports:{}};t[s][0].call(p.exports,function(e){var n=t[s][1][e];return o(n?n:e)},p,p.exports,e,t,n,r)}return n[s].exports}for(var i="function"==typeof require&&require,s=0;s<r.length;s++)o(r[s]);return o}({1:[function(t,e,n){var r=t(32),o=t(130);r.atom=o.atom,r.ref=o.ref,r.error=o.error,r.pathValue=o.pathValue,r.HttpDataSource=t(125),e.exports=r},{125:125,130:130,32:32}],2:[function(t,e,n){function r(t){var e=t||{};this._root=e._root||new o(e),this._path=e.path||e._path||[],this._scheduler=e.scheduler||e._scheduler||new l,this._source=e.source||e._source,this._request=e.request||e._request||new s(this,this._scheduler),this._ID=N++,"number"==typeof e.maxSize?this._maxSize=e.maxSize:this._maxSize=e._maxSize||r.prototype._maxSize,"number"==typeof e.collectRatio?this._collectRatio=e.collectRatio:this._collectRatio=e._collectRatio||r.prototype._collectRatio,(e.boxed||e.hasOwnProperty("_boxed"))&&(this._boxed=e.boxed||e._boxed),(e.materialized||e.hasOwnProperty("_materialized"))&&(this._materialized=e.materialized||e._materialized),"boolean"==typeof e.treatErrorsAsValues?this._treatErrorsAsValues=e.treatErrorsAsValues:e.hasOwnProperty("_treatErrorsAsValues")&&(this._treatErrorsAsValues=e._treatErrorsAsValues),e.cache&&this.setCache(e.cache)}var o=t(4),i=t(3),s=t(55),u=t(64),a=t(65),c=t(61),p=t(63),h=t(73),f=t(75),l=t(74),d=t(81),v=t(84),y=t(49),b=t(134),m=t(88),g=t(100),w=t(96),x=t(102),_=t(98),S=t(99),E=t(77),C=t(76),A=t(130),N=0,k=t(116),O=function(){},P=t(14),j=t(19),D={pathValue:!0,pathSyntax:!0,json:!0,jsonGraph:!0},q=t(72);e.exports=r,r.ref=A.ref,r.atom=A.atom,r.error=A.error,r.pathValue=A.pathValue,r.prototype.constructor=r,r.prototype._materialized=!1,r.prototype._boxed=!1,r.prototype._progressive=!1,r.prototype._treatErrorsAsValues=!1,r.prototype._maxSize=Math.pow(2,53)-1,r.prototype._collectRatio=.75,r.prototype.get=t(71),r.prototype._getWithPaths=t(70),r.prototype.set=function(){var t=k(arguments,D,"set");return t!==!0?new u(function(e){e.onError(t)}):this._set.apply(this,arguments)},r.prototype.preload=function(){var t=k(arguments,q,"preload");if(t!==!0)return new u(function(e){e.onError(t)});var e=Array.prototype.slice.call(arguments),n=this;return new u(function(t){return n.get.apply(n,e).subscribe(function(){},function(e){t.onError(e)},function(){t.onCompleted()})})},r.prototype._set=function(){var t,e=-1,n=arguments.length,r=arguments[n-1];for(w(r)?n-=1:r=void 0,t=new Array(n);++e<n;)t[e]=arguments[e];return a.create(this,t,r)},r.prototype.call=function(){var t,e=-1,n=arguments.length;for(t=new Array(n);++e<n;){var r=arguments[e];t[e]=r;var o=typeof r;if(e>1&&!Array.isArray(r)||0===e&&!Array.isArray(r)&&"string"!==o||1===e&&!Array.isArray(r)&&!x(r))return new u(function(t){t.onError(new Error("Invalid argument"))})}return c.create(this,t)},r.prototype.invalidate=function(){var t,e=-1,n=arguments.length,r=arguments[n-1];for(t=new Array(n);++e<n;)if(t[e]=b.fromPath(arguments[e]),"object"!=typeof t[e])throw new Error("Invalid argument");p.create(this,t,r).subscribe(O,function(t){throw t})},r.prototype.deref=t(5),r.prototype.getValue=t(16),r.prototype.setValue=t(79),r.prototype._getValueSync=t(24),r.prototype._setValueSync=t(80),r.prototype._derefSync=t(6),r.prototype.setCache=function(t){var e=this._root.cache;if(t!==e){var n=this._root,r=this._path;this._path=[],this._root.cache={},"undefined"!=typeof e&&y(n,n.expired,m(e),0),S(t)?C(this,[t]):_(t)?E(this,[t]):g(t)&&E(this,[{json:t}]),this._path=r}else"undefined"==typeof e&&(this._root.cache={});return this},r.prototype.getCache=function(){var t=v(arguments);if(0===t.length)return P(this._root.cache);var e=[{}],n=this._path;return j.getWithPathsAsJSONGraph(this,t,e),this._path=n,e[0].jsonGraph},r.prototype.getVersion=function(t){var e=t&&b.fromPath(t)||[];if(Array.isArray(e)===!1)throw new Error("Model#getVersion must be called with an Array path.");return this._path.length&&(e=this._path.concat(e)),this._getVersion(this,e)},r.prototype._syncCheck=function(t){if(Boolean(this._source)&&this._root.syncRefCount<=0&&this._root.unsafeMode===!1)throw new Error("Model#"+t+" may only be called within the context of a request selector.");return!0},r.prototype._clone=function(t){var e=new r(this);for(var n in t){var o=t[n];"delete"===o?delete e[n]:e[n]=o}return e.setCache=void 0,e},r.prototype.batch=function(t){var e=t;"number"==typeof e?e=new f(Math.round(Math.abs(e))):e&&e.schedule||(e=new h);var n=this._clone();return n._request=new s(n,e),n},r.prototype.unbatch=function(){var t=this._clone();return t._request=new s(t,new l),t},r.prototype.treatErrorsAsValues=function(){return this._clone({_treatErrorsAsValues:!0})},r.prototype.asDataSource=function(){return new i(this)},r.prototype._materialize=function(){return this._clone({_materialized:!0})},r.prototype._dematerialize=function(){return this._clone({_materialized:"delete"})},r.prototype.boxValues=function(){return this._clone({_boxed:!0})},r.prototype.unboxValues=function(){return this._clone({_boxed:"delete"})},r.prototype.withoutDataSource=function(){return this._clone({_source:"delete"})},r.prototype.toJSON=function(){return{$type:"ref",value:this._path}},r.prototype.getPath=function(){return d(this._path)},r.prototype._getBoundValue=t(13),r.prototype._getVersion=t(18),r.prototype._getValueSync=t(17),r.prototype._getPathValuesAsPathMap=j.getWithPathsAsPathMap,r.prototype._getPathValuesAsJSONG=j.getWithPathsAsJSONGraph,r.prototype._setPathValuesAsJSON=t(78),r.prototype._setPathValuesAsJSONG=t(78),r.prototype._setPathValuesAsPathMap=t(78),r.prototype._setPathValuesAsValues=t(78),r.prototype._setPathMapsAsJSON=t(77),r.prototype._setPathMapsAsJSONG=t(77),r.prototype._setPathMapsAsPathMap=t(77),r.prototype._setPathMapsAsValues=t(77),r.prototype._setJSONGsAsJSON=t(76),r.prototype._setJSONGsAsJSONG=t(76),r.prototype._setJSONGsAsPathMap=t(76),r.prototype._setJSONGsAsValues=t(76),r.prototype._setCache=t(77),r.prototype._invalidatePathValuesAsJSON=t(48),r.prototype._invalidatePathMapsAsJSON=t(47)},{100:100,102:102,116:116,13:13,130:130,134:134,14:14,16:16,17:17,18:18,19:19,24:24,3:3,4:4,47:47,48:48,49:49,5:5,55:55,6:6,61:61,63:63,64:64,65:65,70:70,71:71,72:72,73:73,74:74,75:75,76:76,77:77,78:78,79:79,80:80,81:81,84:84,88:88,96:96,98:98,99:99}],3:[function(t,e,n){function r(t){this._model=t._materialize().treatErrorsAsValues()}r.prototype.get=function(t){return this._model.get.apply(this._model,t)._toJSONG()},r.prototype.set=function(t){return this._model.set(t)._toJSONG()},r.prototype.call=function(t,e,n,r){var o=[t,e,n].concat(r);return this._model.call.apply(this._model,o)._toJSONG()},e.exports=r},{}],4:[function(t,e,n){function r(t){var e=t||{};this.syncRefCount=0,this.expired=e.expired||[],this.unsafeMode=e.unsafeMode||!1,this.collectionScheduler=e.collectionScheduler||new s,this.cache={},o(e.comparator)&&(this.comparator=e.comparator),o(e.errorSelector)&&(this.errorSelector=e.errorSelector),o(e.onChange)&&(this.onChange=e.onChange)}var o=t(96),i=t(91),s=t(74);r.prototype.errorSelector=function(t,e){return e},r.prototype.comparator=function(t,e){return i(t,"value")&&i(e,"value")?t.value===e.value&&t.$type===e.$type&&t.$expires===e.$expires:t===e},e.exports=r},{74:74,91:91,96:96}],5:[function(t,e,n){function r(t,e){var n,r=!1;try{++t._root.syncRefCount,n=t._derefSync(e)}catch(i){n=i,r=!0}finally{--t._root.syncRefCount}return r?o.Observable["throw"](n):o.Observable["return"](n)}var o=t(159),i=t(134);e.exports=function(t){for(var e=this,n=-1,s=arguments.length-1,u=new Array(s),a=i.fromPath(t);++n<s;)u[n]=i.fromPath(arguments[n+1]);if(0===s)throw new Error("Model#deref requires at least one value path.");return o.Observable.defer(function(){return r(e,a)}).flatMap(function(t){if(Boolean(t)){if(s>0){var n=o.Observable.of(t);return t.get.apply(t,u)["catch"](o.Observable.empty()).concat(n).last().flatMap(function(){return r(e,a)}).filter(function(t){return t})}return o.Observable["return"](t)}if(s>0){var i=u.map(function(t){return a.concat(t)});return e.get.apply(e,i).concat(o.Observable.defer(function(){return r(e,a)})).last().filter(function(t){return t})}return o.Observable.empty()})}},{134:134,159:159}],6:[function(t,e,n){var r=t(134),o=t(13),i=t(8),s=t(118);e.exports=function(t){var e=r.fromPath(t);if(!Array.isArray(e))throw new Error("Model#derefSync must be called with an Array path.");var n=o(this,this._path.concat(e),!1),u=n.path,a=n.value,c=n.found;if(c&&void 0!==a&&(a.$type!==s||void 0!==a.value)){if(a.$type)throw new i;return this._clone({_path:u})}}},{118:118,13:13,134:134,8:8}],7:[function(t,e,n){function r(){this.message=r.message,this.stack=(new Error).stack}r.prototype=new Error,r.prototype.name="BoundJSONGraphModelError",r.message="It is not legal to use the JSON Graph format from a bound Model. JSON Graph format can only be used from a root model.",e.exports=r},{}],8:[function(t,e,n){function r(t,e){this.message=i,this.stack=(new Error).stack,this.boundPath=t,this.shortedPath=e}var o="InvalidModelError",i="The boundPath of the model is not valid since a value or error was found before the path end.";r.prototype=new Error,r.prototype.name=o,r.message=i,e.exports=r},{}],9:[function(t,e,n){function r(t){this.message="An exception was thrown when making a request.",this.stack=(new Error).stack,this.innerError=t}var o="InvalidSourceError";r.prototype=new Error,r.prototype.name=o,r.is=function(t){return t&&t.name===o},e.exports=r},{}],10:[function(t,e,n){function r(){this.message="The allowed number of retries have been exceeded.",this.stack=(new Error).stack}var o="MaxRetryExceededError";r.prototype=new Error,r.prototype.name=o,r.is=function(t){return t&&t.name===o},e.exports=r},{}],11:[function(t,e,n){function r(t,e,n,r,o,h,f){for(var l,d,v=n,y=o,b=r,m=0;;){if(0===m&&b[c]?(m=y.length,d=b[c]):(l=y[m++],d=v[l]),d){var g=d.$type,w=g&&d.value||d;if(m<y.length){if(g){v=d;break}v=d;continue}if(v=d,g&&u(d))break;if(b[c]||i(b,d),g===a){f?s(t,d,h,null,null,null,y,y.length,f):p(t,d),m=0,y=w,b=d,v=e;continue}break}v=void 0;break}if(m<y.length&&void 0!==v){for(var x=[],_=0;m>_;_++)x[_]=y[_];y=x}return[v,y]}var o=t(26),i=o.create,s=t(22),u=t(27),a=t(120),c=t(33),p=t(29).promote;e.exports=r},{120:120,22:22,26:26,27:27,29:29,33:33}],12:[function(t,e,n){var r=t(15),o=t(8),i=t(7);e.exports=function(t,e){return function(n,s,u){var a,c,p,h=u[0],f={values:u,optimizedPaths:[]},l=n._root.cache,d=n._path,v=l,y=d.length,b=[];if(y){if(e)return{criticalError:new i};if(v=r(n,d),v.$type)return{criticalError:new o(d,d)};for(a=[],c=0;y>c;++c)a[c]=d[c]}else a=[],y=0;for(c=0,p=s.length;p>c;c++)t(n,l,v,s[c],0,h,f,b,a,y,e);return f}}},{15:15,7:7,8:8}],13:[function(t,e,n){var r=t(17),o=t(8);e.exports=function(t,e,n){var i,s,u,a,c,p=e,h=e;for(i=t._boxed,n=t._materialized,s=t._treatErrorsAsValues,t._boxed=!0,t._materialized=void 0===n||n,t._treatErrorsAsValues=!0,u=r(t,p.concat(null),!0),t._boxed=i,t._materialized=n,t._treatErrorsAsValues=s,p=u.optimizedPath,a=u.shorted,c=u.found,u=u.value;p.length&&null===p[p.length-1];)p.pop();if(c&&a)throw new o(h,p);return{path:p,value:u,shorted:a,found:c}}},{17:17,8:8}],14:[function(t,e,n){function r(t){var e,n,r,o={},i=Object.keys(t);for(n=0,r=i.length;r>n;n++)e=i[n],s(e)||(o[e]=t[e]);return o}function o(t,e,n){Object.keys(t).filter(function(e){return!s(e)&&t[e]}).forEach(function(n){var s=t[n],u=e[n];if(u||(u=e[n]={}),s.$type){var a,c=s.value&&"object"==typeof s.value,p=!t[i];return a=c||p?r(s):s.value,void(e[n]=a)}o(s,u,n)})}var i=t(37),s=t(97);e.exports=function(t){var e={};return o(t,e),e}},{37:37,97:97}],15:[function(t,e,n){e.exports=function(t,e){for(var n=t._root.cache,r=-1,o=e.length;++r<o&&n&&!n.$type;)n=n[e[r]];return n}},{}],16:[function(t,e,n){var r=t(64),o=t(134);e.exports=function(t){for(var e=o.fromPath(t),n=0,i=e.length;++n<i;)if("object"==typeof e[n])return new r(function(t){t.onError(new Error("Paths must be simple paths"))});var s=this;return new r(function(t){return s.get(e).subscribe(function(n){for(var r=n.json,o=-1,i=e.length;r&&++o<i;)r=r[e[o]];t.onNext(r)},function(e){t.onError(e)},function(){t.onCompleted()})})}},{134:134,64:64}],17:[function(t,e,n){var r=t(11),o=t(25),i=t(27),s=t(29).promote,u=t(120),a=t(118),c=t(119);e.exports=function(t,e,n){for(var p,h,f,l,d,v=t._root.cache,y=e.length,b=[],m=!1,g=!1,w=0,x=v,_=v,S=v,E=!0,C=!1;x&&y>w;){if(p=e[w++],null!==p&&(x=_[p],b[b.length]=p),!x){S=void 0,m=!0,E=!1;break}if(f=x.$type,f===a&&void 0===x.value){S=void 0,E=!1,m=y>w;break}if(y>w){if(f===u){if(i(x)){C=!0,S=void 0,E=!1;break}if(l=r(t,v,v,x,x.value),d=l[0],!d){S=void 0,x=void 0,E=!1;break}f=d.$type,x=d,b=l[1].slice(0)}if(f)break}else S=x;_=x}if(y>w&&!C){for(h=w;y>h;++h)if(null!==e[w]){g=!0;break}for(g?(m=!0,S=void 0):S=x,h=w;y>h;++h)null!==e[h]&&(b[b.length]=e[h])}if(S&&f&&(i(S)?S=void 0:s(t,S)),S&&f===c&&!t._treatErrorsAsValues)throw{path:w===y?e:e.slice(0,w),value:S.value};return S&&t._boxed?S=Boolean(f)&&!n?o(S):S:!S&&t._materialized?S={$type:a}:S&&(S=S.value),{value:S,shorted:m,optimizedPath:b,found:E}}},{11:11,118:118,119:119,120:120,25:25,27:27,29:29}],18:[function(t,e,n){var r=t(46);e.exports=function(t,e){var n=t._getValueSync({_boxed:!0,_root:t._root,_treatErrorsAsValues:t._treatErrorsAsValues},e,!0).value,o=n&&n[r];return null==o?-1:o}},{46:46}],19:[function(t,e,n){var r=t(12),o=t(31),i=r(o,!1),s=r(o,!0);e.exports={getValueSync:t(17),getBoundValue:t(13),getWithPathsAsPathMap:i,getWithPathsAsJSONGraph:s}},{12:12,13:13,17:17,31:31}],20:[function(t,e,n){var r=t(29),o=t(25),i=r.promote;e.exports=function(t,e,n,r,s){var u=e.value;s.errors||(s.errors=[]),t._boxed&&(u=o(e)),s.errors.push({path:r.slice(0,n+1),value:u}),i(t,e)}},{25:25,29:29}],21:[function(t,e,n){function r(t,e,n,r,o,i,s){s.requestedMissingPaths.push(r.slice(0,n).concat(e)),s.optimizedMissingPaths.push(o.slice(0,i).concat(e))}var o=t(30),i=o.fastCopy;e.exports=function(t,e,n,o,s,u,a){var c;o.requestedMissingPaths||(o.requestedMissingPaths=[],o.optimizedMissingPaths=[]),c=n<e.length?i(e,n):[],r(t,c,n,s,u,a,o)}},{30:30}],22:[function(t,e,n){var r=t(29),o=t(25),i=r.promote,s=t(120),u=t(118),a=t(119),c=t(37);e.exports=function(t,e,n,r,p,h,f,l,d,v){if(n){var y,b,m,g,w,x,_,S,E=!1;if(e&&i(t,e),e&&void 0!==e.value||(E=t._materialized),E)S={$type:u};else if(t._boxed)S=o(e);else if(e.$type===s||e.$type===a)S=d?o(e):e.value;else if(d){var C=e.value&&"object"==typeof e.value,A=!e[c];S=C||A?o(e):e.value}else S=e.value;if(p&&(p.hasValue=!0),d){for(w=n.jsonGraph,w||(w=n.jsonGraph={},n.paths=[]),y=0,b=l-1;b>y;y++)g=f[y],w[g]||(w[g]={}),w=w[g];g=f[y],w[g]=E?{$type:u}:S,h&&n.paths.push(h.slice(0,r))}else if(0===r)n.json=S;else{for(w=n.json,w||(w=n.json={}),y=0;r-1>y;y++)m=h[y],w[m]||(w[m]={}),x=w,_=m,w=w[m];m=h[y],null!==m?w[m]=S:x[_]=S}}}},{118:118,119:119,120:120,25:25,29:29,37:37}],23:[function(t,e,n){var r=t(27),o=t(26),i=t(29),s=o.remove,u=i.splice,a=t(119),c=t(20),p=t(22),h=t(21),f=t(28),l=t(35);e.exports=function(t,e,n,o,i,d,v,y,b,m,g){var w=e&&e.$type,x=e&&void 0===e.value;return e&&w?void(r(e)?(e[l]||(u(t,e),s(e)),h(t,n,o,d,v,y,b)):w===a?(g&&(v[o]=null),m||t._treatErrorsAsValues?p(t,e,i,o,d,v,y,b,m,g):c(t,e,o,v,d)):(g&&(v[o]=null),(!x||x&&t._materialized)&&p(t,e,i,o,d,v,y,b,m,g))):void(f(t)?p(t,e,i,o,d,v,y,b,m,g):h(t,n,o,d,v,y,b))}},{119:119,20:20,21:21,22:22,26:26,27:27,28:28,29:29,35:35}],24:[function(t,e,n){var r=t(134);e.exports=function(t){var e=r.fromPath(t);if(Array.isArray(e)===!1)throw new Error("Model#getValueSync must be called with an Array path.");return this._path.length&&(e=this._path.concat(e)),this._syncCheck("getValueSync")&&this._getValueSync(this,e).value}},{134:134}],25:[function(t,e,n){var r=t(40);e.exports=function(t){var e,n,o,i=Object.keys(t);for(e={},n=0,o=i.length;o>n;n++){var s=i[n];s[0]!==r&&(e[s]=t[s])}return e}},{40:40}],26:[function(t,e,n){function r(t,e){var n=e[a]||0;e[i+n]=t,e[a]=n+1,t[u]=n,t[s]=e}function o(t){var e=t[s];if(e){for(var n=t[u],r=e[a];r>n;)e[i+n]=e[i+n+1],++n;e[a]=r-1,t[s]=void 0,t[u]=void 0}}var i=t(43),s=t(33),u=t(42),a=t(44);e.exports={create:r,remove:o}},{33:33,42:42,43:43,44:44}],27:[function(t,e,n){var r=t(106);e.exports=function(t){var e=void 0===t.$expires&&-1||t.$expires;return-1!==e&&1!==e&&(0===e||e<r())}},{106:106}],28:[function(t,e,n){e.exports=function(t){return t._materialized&&!t._source}},{}],29:[function(t,e,n){function r(t,e){var n=t._root,r=n[i];if(r!==e){var o=e[a],s=e[u];s&&(s[a]=o),o&&(o[u]=s),e[a]=void 0,n[i]=e,e[u]=r,r[a]=e}}function o(t,e){var n=t._root,r=e[a],o=e[u];o&&(o[a]=r),r&&(r[u]=o),e[a]=void 0,e===n[i]&&(n[i]=void 0),e===n[s]&&(n[s]=void 0),e[c]=!0,n.expired.push(e)}var i=t(34),s=t(45),u=t(38),a=t(41),c=t(35);e.exports={promote:r,splice:o}},{34:34,35:35,38:38,41:41,45:45}],30:[function(t,e,n){function r(t,e){var n,r,o,i=[];for(r=0,o=e||0,n=t.length;n>o;r++,o++)i[r]=t[o];return i}function o(t,e){var n,r,o,i=[];for(n=0,r=t.length;r>n;n++)i[n]=t[n];for(o=0,r=e.length;r>o;o++)null!==e[o]&&(i[n++]=e[o]);return i}function i(t,e){var n,r,o,i=[];for(n=0,r=t.length;r>n;n++)i[n]=t[n];for(o=0,r=e.length;r>o;o++)i[n++]=e[o];return i}e.exports={fastCat:i,fastCatSkipNulls:o,fastCopy:r}},{}],31:[function(t,e,n){var r=t(11),o=t(23),i=t(27),s=t(143).iterateKeySet,u=t(120),a=t(29).promote;e.exports=function c(t,e,n,p,h,f,l,d,v,y,b,m){var g=m,w=v;if(!n||n&&n.$type||h===p.length)return void o(t,n,p,h,f,l,d,w,y,b,g);var x,_;x=p[h];var S="object"==typeof x,E=h+1,C=!1,A=x;if(S&&(C={},A=s(x,C)),void 0!==A||!C.done){var N=y+1;do{g=!1;var k;null===A?k=n:(k=n[A],w[y]=A,d[h]=A);var O=w,P=N;if(k){var j=k.$type,D=j&&k.value||k;if(E<p.length&&j&&j===u&&!i(k)){b&&o(t,k,p,E,f,l,null,w,P,b,g),a(t,k);var q=r(t,e,e,k,D,f,b);g=!0,k=q[0];var R=q[1];for(O=[],P=R.length,_=0;P>_;++_)O[_]=R[_]}}c(t,e,k,p,E,f,l,d,O,P,b,g),C&&!C.done&&(A=s(x,C))}while(C&&!C.done)}}},{11:11,120:120,143:143,23:23,27:27,29:29}],32:[function(t,e,n){"use strict";function r(t){return new r.Model(t)}"function"==typeof Promise?r.Promise=Promise:r.Promise=t(151),e.exports=r,r.Model=t(2)},{151:151,2:2}],33:[function(t,e,n){e.exports=t(40)+"context"},{40:40}],34:[function(t,e,n){e.exports=t(40)+"head"},{40:40}],35:[function(t,e,n){e.exports=t(40)+"invalidated"},{40:40}],36:[function(t,e,n){e.exports=t(40)+"key"},{40:40}],37:[function(t,e,n){e.exports="$modelCreated"},{}],38:[function(t,e,n){e.exports=t(40)+"next"},{40:40}],39:[function(t,e,n){e.exports=t(40)+"parent"},{40:40}],40:[function(t,e,n){e.exports=String.fromCharCode(30)},{}],41:[function(t,e,n){e.exports=t(40)+"prev"},{40:40}],42:[function(t,e,n){e.exports=t(40)+"ref-index"},{40:40}],43:[function(t,e,n){e.exports=t(40)+"ref"},{40:40}],44:[function(t,e,n){e.exports=t(40)+"refs-length"},{40:40}],45:[function(t,e,n){e.exports=t(40)+"tail"},{40:40}],46:[function(t,e,n){e.exports=t(40)+"version"},{40:40}],47:[function(t,e,n){function r(t,e,n,o,s,u,c,p,h,f){if(!_(t)&&!t.$type)for(var l in t)if(l[0]!==a&&"$"!==l[0]&&m(t,l)){var d=t[l],v=g(d)&&!d.$type,y=i(n,o,s,l,d,v,!1,u,c,p,h,f),w=y[0],x=y[1];w&&(v?r(d,e+1,n,x,w,u,c,p,h,f):A(w,x,l,p)&&C(x,b(w),p,u))}}function o(t,e,n,r,o,s,a,h){if(w(n))return S(n,o,s),[void 0,e];y(s,n);var d=n,v=n.value,b=e;if(n=n[p],null!=n)b=n[c]||e;else{var m=0,g=v.length-1;b=n=e;do{var x=v[m],E=g>m,C=i(e,b,n,x,t,E,!0,r,o,s,a,h);if(n=C[0],_(n))return C;b=C[1]}while(m++<g);if(d[p]!==n){var A=n[l]||0;n[l]=A+1,n[u+A]=d,d[p]=n,d[f]=A}}return[n,b]}function i(t,e,n,r,i,u,a,c,p,h,f,l){for(var v=n.$type;v===d;){var y=o(i,t,n,c,p,h,f,l);if(n=y[0],_(n))return y;e=y[1],v=n&&n.$type}if(void 0!==v)return[n,e];if(null==r){if(u)throw new Error("`null` is not allowed in branch key positions.");n&&(r=n[s])}else e=n,n=e[r];return[n,e]}var s=t(36),u=t(43),a=t(40),c=t(39),p=t(33),h=t(46),f=t(42),l=t(44),d=t(120),v=t(13),y=t(50),b=t(88),m=t(91),g=t(100),w=t(95),x=t(96),_=t(102),S=t(86),E=t(92),C=t(115),A=t(109);e.exports=function(t,e){for(var n=t._root,o=n,i=n.expired,s=E(),u=n._comparator,a=n._errorSelector,p=t._path,f=n.cache,l=p.length?v(t,p).value:f,d=l[c]||f,y=f[h],b=-1,m=e.length;++b<m;){var g=e[b];r(g.json,0,f,d,l,s,i,o,u,a)}var w=f[h],_=n.onChange;x(_)&&y!==w&&_()}},{100:100,102:102,109:109,115:115,120:120,13:13,33:33,36:36,39:39,40:40,42:42,43:43,44:44,46:46,50:50,86:86,88:88,91:91,92:92,95:95,96:96}],48:[function(t,e,n){function r(t,e,n,o,s,u,a,c){var p={},h=e<t.length-1,f=t[e],l=x(f,p);do{var d=i(n,o,s,l,h,!1,u,a,c),v=d[0],b=d[1];v&&(h?r(t,e+1,n,b,v,u,a,c):E(v,b,l,c)&&S(b,y(v),c,u)),l=x(f,p)}while(!p.done)}function o(t,e,n,r,o){if(b(e))return w(e,r,o),[void 0,t];v(o,e);var s=e,p=e.value,l=t;if(e=e[c],null!=e)l=e[a]||t;else{var d=0,y=p.length-1;l=e=t;do{var m=p[d],x=y>d,_=i(t,l,e,m,x,!0,n,r,o);if(e=_[0],g(e))return _;l=_[1]}while(d++<y);if(s[c]!==e){var S=e[f]||0;e[f]=S+1,e[u+S]=s,s[c]=e,s[h]=S}}return[e,l]}function i(t,e,n,r,i,u,a,c,p){for(var h=n.$type;h===l;){var f=o(t,n,a,c,p);if(n=f[0],g(n))return f;e=f[1],h=n.$type}if(void 0!==h)return[n,e];if(null==r){if(i)throw new Error("`null` is not allowed in branch key positions.");n&&(r=n[s])}else e=n,n=e[r];return[n,e]}var s=t(36),u=t(43),a=t(39),c=t(33),p=t(46),h=t(42),f=t(44),l=t(120),d=t(13),v=t(50),y=t(88),b=t(95),m=t(96),g=t(102),w=t(86),x=t(143).iterateKeySet,_=t(92),S=t(115),E=t(109);e.exports=function(t,e){for(var n=t._root,o=n,i=n.expired,s=_(),u=t._path,c=n.cache,h=u.length?d(t,u).value:c,f=h[a]||c,l=c[p],v=-1,y=e.length;++v<y;){var b=e[v];r(b,0,c,f,h,s,i,o)}var g=c[p],w=n.onChange;m(w)&&l!==g&&w()}},{102:102,109:109,115:115,120:120,13:13,143:143,33:33,36:36,39:39,42:42,43:43,44:44,46:46,50:50,86:86,88:88,92:92,95:95,96:96}],49:[function(t,e,n){var r=t(36),o=t(39),i=t(34),s=t(45),u=t(38),a=t(41),c=t(108),p=t(115);e.exports=function(t,e,n,h,f,l){var d=n,v=f;"number"!=typeof v&&(v=.75);var y,b,m,g="number"==typeof l,w=h*v;for(b=e.pop();b;)m=b.$size||0,d-=m,g===!0?p(b,m,t,l):(y=b[o])&&c(b,y,b[r],t),b=e.pop();if(d>=h){var x=t[s];for(b=x;d>=w&&b;)x=x[a],m=b.$size||0,d-=m,g===!0&&p(b,m,t,l),b=x;t[s]=t[a]=b,null==b?t[i]=t[u]=void 0:b[u]=void 0}}},{108:108,115:115,34:34,36:36,38:38,39:39,41:41,45:45}],50:[function(t,e,n){var r=t(121),o=t(34),i=t(45),s=t(38),u=t(41),a=t(100);e.exports=function(t,e){if(a(e)&&e.$expires!==r){var n=t[o],c=t[i],p=e[s],h=e[u];e!==n&&(null!=p&&"object"==typeof p&&(p[u]=h),null!=h&&"object"==typeof h&&(h[s]=p),p=n,null!=n&&"object"==typeof n&&(n[u]=e),t[o]=t[s]=n=e,n[s]=p,n[u]=void 0),null!=c&&e!==c||(t[i]=t[u]=c=h||e)}return e}},{100:100,121:121,34:34,38:38,41:41,45:45}],51:[function(t,e,n){var r=t(34),o=t(45),i=t(38),s=t(41);e.exports=function(t,e){var n=t[r],u=t[o],a=e[i],c=e[s];null!=a&&"object"==typeof a&&(a[s]=c),null!=c&&"object"==typeof c&&(c[i]=a),e===n&&(t[r]=t[i]=a),e===u&&(t[o]=t[s]=c),e[i]=e[s]=void 0,n=u=a=c=void 0}},{34:34,38:38,41:41,45:45}],52:[function(t,e,n){function r(t,e){var n=!1;return function(){if(!n&&!t._disposed){n=!0,t._callbacks[e]=null,t._optimizedPaths[e]=[],t._requestedPaths[e]=[];var r=--t._count;0!==r||t.sent||(t._disposable.dispose(),t.requestQueue.removeRequest(t))}}}function o(t){for(var e=[],n=-1,r=0,o=t.length;o>r;++r)for(var i=t[r],s=0,u=i.length;u>s;++s)e[++n]=i[s];return e}var i=t(59),s=t(60),u=0,a=t(57).GetRequest,c=t(76),p=t(78),h=t(119),f=[],l=function(t,e){this.sent=!1,this.scheduled=!1,this.requestQueue=e,this.id=++u,this.type=a,this._scheduler=t,this._pathMap={},this._optimizedPaths=[],this._requestedPaths=[],this._callbacks=[],this._count=0,this._disposable=null,this._collapsed=null,this._disposed=!1};l.prototype={batch:function(t,e,n){var o=this,i=o._optimizedPaths,u=o._requestedPaths,a=o._callbacks,c=i.length;return i[c]=e,u[c]=t,a[c]=n,++o._count,o.scheduled||(o.scheduled=!0,o._disposable=o._scheduler.schedule(function(){s(o,i,function(t,e){if(o.requestQueue.removeRequest(o),o._disposed=!0,o._count){o._merge(u,t,e);for(var n=0,r=a.length;r>n;++n){var i=a[n];i&&i(t,e)}}})})),r(o,c)},add:function(t,e,n){var o,s,u=this,a=i(t,e,u._pathMap);a?(s=a[2],o=a[1]):(s=t,o=e);var c=!1,p=!1;if(o.length<e.length){c=!0;var h=u._callbacks.length;u._callbacks[h]=n,u._requestedPaths[h]=a[0],u._optimizedPaths[h]=[],++u._count,p=r(u,h)}return[c,s,o,p]},_merge:function(t,e,n){var r=this,i=r.requestQueue.model,s=i._root,u=s.errorSelector,a=s.comparator,l=i._path;i._path=f;var d=o(t);if(e){var v=e;v instanceof Error&&(v={message:v.message}),v.$type||(v={$type:h,value:v});var y=d.map(function(t){return{path:t,value:v}});p(i,y,null,u,a)}else c(i,[{paths:d,jsonGraph:n.jsonGraph}],null,u,a);i._path=l}},e.exports=l},{119:119,57:57,59:59,60:60,76:76,78:78}],53:[function(t,e,n){function r(){this.length=0,this.pending=!1,this.pathmaps=[],s.call(this,this._subscribe)}var o=t(159),i=o.Observer,s=o.Observable,u=o.Disposable,a=o.SerialDisposable,c=o.CompositeDisposable,p=t(9),h=t(143),f=h.iterateKeySet;r.create=function(t,e,n){var r=new this;return r.queue=t,r.model=e,r.index=n,r},r.prototype=Object.create(s.prototype),r.prototype.constructor=r,r.prototype.insertPath=function(t,e,n,r,o){var i=r||0,s=o||t.length-1,u=n||this.pathmaps[s+1]||(this.pathmaps[s+1]=Object.create(null));if(void 0===u||null===u)return!1;var a,c,p=t[i],h={};a=f(p,h);do{if(c=u[a],s>i){if(null==c){if(e)return!1;c=u[a]=Object.create(null)}if(this.insertPath(t,e,c,i+1,s)===!1)return!1}else u[a]=(c||0)+1,this.length+=1;h.done||(a=f(p,h))}while(!h.done);return!0},r.prototype.removePath=function(t,e,n,r){var o=n||0,i=r||t.length-1,s=e||this.pathmaps[i+1];if(void 0===s||null===s)return!0;var u,a,c=0,p=t[o],h={};u=f(p,h);do if(a=s[u],void 0!==a&&null!==a){if(i>o){c+=this.removePath(t,a,o+1,i);var l=void 0;for(l in a)break;void 0===l&&delete s[u]}else a=s[u]=(a||1)-1,0===a&&delete s[u],c+=1,this.length-=1;h.done||(u=f(p,h))}while(!h.done);return c},r.prototype.getSourceObserver=function(t){var e=this;return i.create(function(n){n.jsonGraph=n.jsonGraph||n.jsong||n.values||n.value,n.index=e.index,t.onNext(n)},function(e){t.onError(e)},function(){t.onCompleted()})},r.prototype._subscribe=function(t){var e=this,n=this.queue;e.pending=!0;var r=!1,o=new a,i=u.create(function(){r||(r=!0,n&&n._remove(e))}),s=new c(o,i);try{o.setDisposable(this.model._source[this.method](this.getSourceArgs()).subscribe(this.getSourceObserver(t)))}catch(h){throw new p(h)}return s},e.exports=r},{143:143,159:159,9:9}],54:[function(t,e,n){function r(t,e){this.total=0,this.model=t,this.requests=[],this.scheduler=e}var o=t(58),i=t(40),s=t(90),u=t(100),a=t(143);r.prototype.set=function(t){return t.paths=a.collapse(t.paths),o.create(this.model,t)},r.prototype._remove=function(t){var e=this.requests,n=e.indexOf(t);-1!==n&&e.splice(n,1)},r.prototype.distributePaths=function(t,e,n){var r,o,i=this.model,s=-1,u=t.length,a=-1,c=e.length,p=[];t:for(;++s<u;){var h=t[s];for(a=-1;++a<c;)if(o=e[a],o.insertPath(h,o.pending)){p[a]=o;continue t}r||(r=n.create(this,i,this.total++),e[a]=r,p[c++]=r),r.insertPath(h,!1)}var f=[],l=-1;for(a=-1;++a<c;)o=p[a],null!=o&&(f[++l]=o);return f},r.prototype.mergeJSONGraphs=function(t,e){var n=0,r=[],o=[],a=[],c=t.index,p=e.index;t.index=Math.max(c,p),r[-1]=t.jsonGraph||{},o[-1]=e.jsonGraph||{};t:for(;n>-1;){for(var h=r[n-1],f=o[n-1],l=a[n-1]||(a[n-1]=Object.keys(f));l.length>0;){var d=l.pop();if(d[0]!==i)if(h.hasOwnProperty(d)){var v=h[d],y=s(v),b=f[d],m=s(b);if(u(v)&&u(b)&&!y&&!m){r[n]=v,o[n]=b,n+=1;continue t}p>c&&(h[d]=b)}else h[d]=f[d]}n-=1}return t},e.exports=r},{100:100,143:143,40:40,58:58,90:90}],55:[function(t,e,n){function r(t,e){this.model=t,this.scheduler=e,this.requests=this._requests=[]}var o=t(54),i=t(56);r.prototype.get=i.prototype.get,r.prototype.removeRequest=i.prototype.removeRequest,r.prototype.set=o.prototype.set,r.prototype.call=o.prototype.call,e.exports=r},{54:54,56:56}],56:[function(t,e,n){function r(t,e){this.model=t,this.scheduler=e,this.requests=this._requests=[]}var o=t(57),i=t(52);r.prototype={setScheduler:function(t){this.scheduler=t},get:function(t,e,n){function r(){v||(--h,0===h&&n())}var s,u,a,c=this,p=[],h=0,f=c._requests,l=e,d=t,v=!1;for(s=0,u=f.length;u>s;++s)if(a=f[s],a.type===o.GetRequest){if(a.sent){var y=a.add(d,l,r);y[0]&&(d=y[1],l=y[2],p[p.length]=y[3],++h)}else a.batch(d,l,r),l=[],d=[],++h;if(!l.length)break}if(l.length){a=new i(c.scheduler,c),f[f.length]=a,++h;var b=a.batch(d,l,r);p[p.length]=b}return function(){if(!v&&0!==h){v=!0;for(var t=p.length,e=0;t>e;++e)p[e]()}}},removeRequest:function(t){for(var e=this._requests,n=e.length;--n>=0;)if(e[n].id===t.id){e.splice(n,1);break}}},e.exports=r},{52:52,57:57}],57:[function(t,e,n){e.exports={GetRequest:"GET"}},{}],58:[function(t,e,n){function r(){s.call(this)}var o=t(159),i=o.Observer,s=t(53),u=t(83),a=t(76),c=t(78),p=new Array(0);r.create=function(t,e){var n=new r;return n.model=t,n.jsonGraphEnvelope=e,n},r.prototype=Object.create(s.prototype),r.prototype.constructor=r,r.prototype.method="set",r.prototype.insertPath=function(){return!1},r.prototype.removePath=function(){return 0},r.prototype.getSourceArgs=function(){return this.jsonGraphEnvelope},r.prototype.getSourceObserver=function(t){var e=this.model,n=e._path,r=this.jsonGraphEnvelope.paths,o=e._root,h=o.errorSelector,f=o.comparator;return s.prototype.getSourceObserver.call(this,i.create(function(o){e._path=p;var i=a(e,[{paths:r,jsonGraph:o.jsonGraph}],null,h,f);o.paths=i[1],e._path=n,t.onNext(o)},function(o){e._path=p,c(e,u(r,function(t){return{path:t,value:o}}),null,h,f),e._path=n,t.onError(o)},function(){t.onCompleted()}))},e.exports=r},{159:159,53:53,76:76,78:78,83:83}],59:[function(t,e,n){var r=t(143).hasIntersection,o=t(84);e.exports=function(t,e,n){for(var i=[],s=[],u=[],a=-1,c=-1,p=!1,h=0,f=e.length;f>h;++h){var l=e[h],d=n[l.length];d&&r(d,l,0)?(!p&&h>0&&(s=o(t,0,h),i=o(e,0,h)),u[++a]=t[h],p=!0):p&&(i[++c]=l,s[c]=t[h])}return p?[u,i,s]:null}},{143:143,84:84}],60:[function(t,e,n){var r=t(143),o=r.toTree,i=r.toPaths;e.exports=function(t,e,n){if(0===t._count)return void t.requestQueue.removeRequest(t);t.sent=!0,t.scheduled=!1;for(var r=t._pathMap,s=Object.keys(e),u=0,a=s.length;a>u;++u)for(var c=e[u],p=0,h=c.length;h>p;++p){var f=c[p],l=f.length;if(r[l]){var d=r[l];d[d.length]=f}else r[l]=[f]}for(var v=Object.keys(r),y=0,b=v.length;b>y;++y){var m=v[y];r[m]=o(r[m])}var g,w=t._collasped=i(r);t.requestQueue.model._source.get(w).subscribe(function(t){g=t},function(t){n(t,g)},function(){n(null,g)})}},{143:143}],61:[function(t,e,n){function r(t){u.call(this,t||i)}function o(t){return s.Observable.defer(function(){return t})}function i(t){function e(t){function e(t,e){if(Boolean(e.invalidated))t.invalidations.push(t.localThisPath.concat(e.path));else{var n=e.path,r=e.value;Boolean(r)&&"object"==typeof r&&r.$type===f?t.references.push({path:i(n),value:e.value}):t.values.push({path:i(n),value:e.value})}return t}function n(t){var e=t.values.concat(t.references);return e.length>0?o(g.set.apply(g,e)._toJSONG()).map(function(e){return{results:t,envelope:e}}):u["return"]({results:t,envelope:{jsonGraph:{},paths:[]}})}function r(t){var e,n=t.envelope,r=t.results,c=r.values,p=r.references,h=r.invalidations,f=c.map(a).map(i),l=p.reduce(s,[]),d=b.map(i),v=l.concat(d);return e=v.length>0?o(m.get.apply(m,f.concat(v))._toJSONG()):u["return"](n),e.doAction(function(t){t.invalidated=h})}function s(t,e){var n=e.path;return t.push.apply(t,y.map(function(t){return n.concat(t)})),t}function a(t){return t.path}var c=t&&t.localFn;if("function"==typeof c){var p=t.model,h=p._path,l=c.apply(p,v).reduce(e,{values:[],references:[],invalidations:[],localThisPath:h}).flatMap(n).flatMap(r);return u["return"](l)}return u.empty()}function n(t){function e(t){var e=t.invalidated;return e&&e.length&&m.invalidate.apply(m,e),t}return t&&"object"==typeof t?s.Observable.defer(function(){
var e;try{e=t.call(x,v,y,b)}catch(n){e=u["throw"](new p(n))}return e}).map(e):u.empty()}function r(t){return o(g.set(t)).reduce(function(t){return t},null).map(function(){return{invalidated:t.invalidated,paths:t.paths.map(function(t){return t.slice(w.length)})}})}function i(t){return _.concat(t)}var c=this.args,l=this.model,d=h.fromPath(c[0]),v=c[1]||[],y=(c[2]||[]).map(h.fromPath),b=(c[3]||[]).map(h.fromPath),m=l._clone({_path:[]}),g=m.withoutDataSource(),w=l._path,x=w.concat(d),_=x.slice(0,-1),S=o(l.withoutDataSource().get(d)).map(function(t){for(var e=t.json,n=-1,r=d.length;e&&++n<r;)e=e[d[n]];var o=m._derefSync(_).boxValues();return{model:o,localFn:e}}).flatMap(e).defaultIfEmpty(n(l._source)).mergeAll().flatMap(r),E=new a;return E.add(S.subscribe(function(e){var n=e.paths,r=e.invalidated,i=l.get.apply(l,n);"AsJSONG"===t.outputFormat&&(i=o(i._toJSONG()).doAction(function(t){t.invalidated=r})),E.add(i.subscribe(t))},function(e){t.onError(e)})),E}var s=t(159)&&t(158),u=s.Observable,a=s.CompositeDisposable,c=t(64),p=t(9),h=t(134),f=t(120);r.create=c.create,r.prototype=Object.create(u.prototype),r.prototype.constructor=r,r.prototype.invokeSourceRequest=function(t){return this},r.prototype.ensureCollect=function(t){return this},r.prototype.initialize=function(){return this},e.exports=r},{120:120,134:134,158:158,159:159,64:64,9:9}],62:[function(t,e,n){function r(t){i.call(this,t)}var o=t(159),i=o.Observable,s=t(64),u=t(134),a=t(88),c=t(49),p=t(81),h=t(46),f=Array.isArray,l=t(101),d=t(98),v=t(99);r.create=s.create,r.prototype=Object.create(i.prototype),r.prototype.constructor=r,r.prototype.subscribeCount=0,r.prototype.subscribeLimit=10,r.prototype.initialize=function(){for(var t,e,n=this.model,r=this.outputFormat||"AsPathMap",o=this.isProgressive,i=[{}],s=[],a=this.args,c=-1,h=a.length;++c<h;){var y,b=a[c];f(b)||"string"==typeof b?(b=u.fromPath(b),y="PathValues"):l(b)?(b.path=u.fromPath(b.path),y="PathValues"):v(b)?y="JSONGs":d(b)&&(y="PathMaps"),e!==y&&(e=y,t={inputType:y,arguments:[]},s.push(t),t.values=i),t.arguments.push(b)}return this.boundPath=p(n._path),this.groups=s,this.outputFormat=r,this.isProgressive=o,this.isCompleted=!1,this.isMaster=null==n._source,this.values=i,this},r.prototype.invokeSourceRequest=function(t){return this},r.prototype.ensureCollect=function(t){var e=this["finally"](function(){var e=t._root,n=e.cache;e.collectionScheduler.schedule(function(){c(e,e.expired,a(n),t._maxSize,t._collectRatio,n[h])})});return new this.constructor(function(t){return e.subscribe(t)})},e.exports=r},{101:101,134:134,159:159,46:46,49:49,64:64,81:81,88:88,98:98,99:99}],63:[function(t,e,n){function r(t){u.call(this,t||o)}function o(t){for(var e=this.model,n=this.method,r=this.groups,o=-1,i=r.length;++o<i;){var u=r[o],a=u.inputType,c=u.arguments;if(c.length>0){var p="_"+n+a+"AsJSON",h=e[p];h(e,c)}}return t.onCompleted(),s.empty}var i=t(159),s=i.Disposable,u=t(62);r.create=u.create,r.prototype=Object.create(u.prototype),r.prototype.method="invalidate",r.prototype.constructor=r,e.exports=r},{159:159,62:62}],64:[function(t,e,n){function r(t){this._subscribe=t}function o(t){var e=this.model,n=new this.type;return n.model=e,n.args=this.args,n.outputFormat=t.outputFormat||"AsPathMap",n.isProgressive=t.isProgressive||!1,n.subscribeCount=0,n.subscribeLimit=t.retryLimit||10,n.initialize().invokeSourceRequest(e).ensureCollect(e).subscribe(t)}var i=t(32),s=t(159)&&t(158),u=s.Observable,a=t(84),c=t(105),p={outputFormat:{value:"AsJSONG"}},h={isProgressive:{value:!0}};r.create=function(t,e){var n=new r(o);return n.args=e,n.type=this,n.model=t,n},r.prototype=Object.create(u.prototype),r.prototype.constructor=r,r.prototype._mixin=function(){var t=this,e=a(arguments);return new t.constructor(function(n){return t.subscribe(e.reduce(function(t,e){return Object.create(t,e)},n))})},r.prototype._toJSONG=function(){return this._mixin(p)},r.prototype.progressively=function(){return this._mixin(h)},r.prototype.subscribe=function(t,e,n){var r=t;r&&"object"==typeof r||(r={onNext:t||c,onError:e||c,onCompleted:n||c});var o=this._subscribe(r);switch(typeof o){case"function":return{dispose:o};case"object":return o||{dispose:c};default:return{dispose:c}}},r.prototype.then=function(t,e){var n=this;return new i.Promise(function(t,e){var r,o=!1;n.toArray().subscribe(function(t){r=t.length<=1?t[0]:t},function(t){o=!0,e(t)},function(){o===!1&&t(r)})}).then(t,e)},e.exports=r},{105:105,158:158,159:159,32:32,84:84}],65:[function(t,e,n){function r(t){l.call(this,t||o)}function o(t){return this.isCompleted?s.call(this,t):i.call(this,t)}function i(t){if(this.subscribeCount++>this.subscribeLimit)return t.onError("Loop kill switch thrown."),h.empty;for(var e=[],n=[],r=this.model,o=this.isMaster,i=r._root,c=this.outputFormat,p=i.errorSelector,f=this.method,l=this.groups,d=-1,y=l.length;++d<y;){var b=l[d],m=b.inputType,g=b.arguments;if(g.length>0){var w="_"+f+m+c,x=r[w],_=x(r,g,null,p);n.push.apply(n,_[1]),"PathValues"===m?e.push.apply(e,g.map(u)):"JSONGs"===m?e.push.apply(e,v(g,a)):e.push.apply(e,_[0])}}return this.requestedPaths=e,o?(this.isCompleted=!0,s.call(this,t)):void t.onError({method:f,optimizedPaths:n,invokeSourceRequest:!0})}function s(t){var e=new f(this.model,this.requestedPaths);return"AsJSONG"===this.outputFormat&&(e=e._toJSONG()),this.isProgressive&&(e=e.progressively()),e.subscribe(t)}function u(t){return t.path}function a(t){return t.paths}var c=t(159),p=c.Observable,h=c.Disposable,f=t(67),l=t(62),d=t(9),v=t(82),y=new Array(0);r.create=l.create,r.prototype=Object.create(l.prototype),r.prototype.method="set",r.prototype.constructor=r,r.prototype.invokeSourceRequest=function(t){var e=this,n=this["catch"](function(r){var o;if(r&&r.invokeSourceRequest===!0){var i={},s=t._path,u=r.optimizedPaths;t._path=y,t._getPathValuesAsJSONG(t._materialize().withoutDataSource(),u,[i]),t._path=s,o=t._request.set(i)["do"](function(t){e.isCompleted=u.length===t.paths.length},function(){e.isCompleted=!0}).materialize().flatMap(function(t){if("C"===t.kind)return p.empty();if("E"===t.kind){var e=t.exception;if(d.is(e))return p["throw"](t.exception)}return n})}else o=p["throw"](r);return o});return new this.constructor(function(t){return n.subscribe(t)})},e.exports=r},{159:159,62:62,67:67,82:82,9:9}],66:[function(t,e,n){var r=function(t){this.disposed=!1,this.currentDisposable=t};r.prototype={dispose:function(){if(!this.disposed&&this.currentDisposable){this.disposed=!0;var t=this.currentDisposable;t.dispose?t.dispose():t()}}},e.exports=r},{}],67:[function(t,e,n){var r=t(64),o=t(68),i=t(69),s={dispose:function(){}},u=t(159).Observable,a=e.exports=function(t,e,n,r){this.model=t,this.currentRemainingPaths=e,this.isJSONGraph=n||!1,this.isProgressive=r||!1};a.prototype=Object.create(u.prototype),a.prototype.subscribe=r.prototype.subscribe,a.prototype.then=r.prototype.then,a.prototype._toJSONG=function(){return new a(this.model,this.currentRemainingPaths,!0,this.isProgressive)},a.prototype.progressively=function(){return new a(this.model,this.currentRemainingPaths,this.isJSONGraph,!0)},a.prototype._subscribe=function(t){var e=[{}],n=[],r=t.isJSONG=this.isJSONGraph,u=this.isProgressive,a=o(this.model,this.currentRemainingPaths,t,u,r,e,n);return a?i(this,this.model,a,t,e,n,1):s}},{159:159,64:64,68:68,69:69}],68:[function(t,e,n){var r=t(19),o=r.getWithPathsAsJSONGraph,i=r.getWithPathsAsPathMap;e.exports=function(t,e,n,r,s,u,a){var c;if(c=s?o(t,e,u):i(t,e,u),c.criticalError)return n.onError(c.criticalError),null;var p=c.hasValue,h=!c.requestedMissingPaths||!t._source,f=u[0].json||u[0].jsonGraph;if(c.errors)for(var l=c.errors,d=a.length,v=0,y=l.length;y>v;++v,++d)a[d]=l[v];if(p&&r||f&&h)try{++t._root.syncRefCount,n.onNext(u[0])}catch(b){throw b}finally{--t._root.syncRefCount}return h?(a.length?n.onError(a):n.onCompleted(),null):c}},{19:19}],69:[function(t,e,n){var r=t(68),o=t(10),i=t(30).fastCat,s=t(49),u=t(88),a=t(66),c=t(46);e.exports=function p(t,e,n,h,f,l,d){if(10===d)throw new o;var v=e._request,y=n.requestedMissingPaths,b=n.optimizedMissingPaths,m=new a,g=[],w=e._path;if(w.length)for(var x=0,_=y.length;_>x;++x)g[x]=i(w,y[x]);else g=y;var S=v.get(g,b,function(){var n=r(e,y,h,t.isProgressive,t.isJSONGraph,f,l);if(n)m.currentDisposable=p(t,e,n,h,f,l,d+1);else{var o=e._root,i=o.cache,a=i[c];s(o,o.expired,u(i),e._maxSize,e._collectRatio,a)}});return m.currentDisposable=S,m}},{10:10,30:30,46:46,49:49,66:66,68:68,88:88}],70:[function(t,e,n){var r=t(67);e.exports=function(t){return new r(this,t)}},{67:67}],71:[function(t,e,n){var r=t(134),o=t(64),i=t(72),s=t(116),u=t(67);e.exports=function(){var t=s(arguments,i,"get");if(t!==!0)return new o(function(e){e.onError(t)});var e=r.fromPathsOrPathValues(arguments);return new u(this,e)}},{116:116,134:134,64:64,67:67,72:72}],72:[function(t,e,n){e.exports={path:!0,pathSyntax:!0}},{}],73:[function(t,e,n){function r(){}var o=t(123),i=t(159),s=i.Disposable;r.prototype.schedule=function(t){return o(t),s.empty},r.prototype.scheduleWithState=function(t,e){var n=this;return o(function(){e(n,t)}),s.empty},e.exports=r},{123:123,159:159}],74:[function(t,e,n){function r(){}var o=t(159),i=o.Disposable;r.prototype.schedule=function(t){return t(),i.empty},r.prototype.scheduleWithState=function(t,e){return e(this,t),i.empty},e.exports=r},{159:159}],75:[function(t,e,n){function r(t){this.delay=t}var o=t(159),i=o.Disposable;r.prototype.schedule=function(t){var e=setTimeout(t,this.delay);return i.create(function(){void 0!==e&&(clearTimeout(e),e=void 0)})},r.prototype.scheduleWithState=function(t,e){var n=this,r=setTimeout(function(){e(n,t)},this.delay);return i.create(function(){void 0!==r&&(clearTimeout(r),r=void 0)})},e.exports=r},{159:159}],76:[function(t,e,n){function r(t,e,n,o,s,u,a,c,p,h,f,d,v,y,b,g,w){for(var x={},_=e<t.length-1,S=t[e],E=m(S,x),C=d.index;;){f.depth=e;var A=i(n,o,s,u,a,c,E,_,!1,f,d,v,y,b,g,w);f[e]=E,f.index=e,d[d.index++]=E;var N=A[0],k=A[1];if(N&&(_?r(t,e+1,n,k,N,u,A[3],A[2],p,h,f,d,v,y,b,g,w):(l(b,N),p.push(f.slice(0,f.index+1)),h.push(d.slice(0,d.index)))),E=m(S,x),x.done)break;d.index=C}}function o(t,e,n,r,o,s,c,f,v,m,g){var w=e.value;if(s.splice(0,s.length),s.push.apply(s,w),d(e))return s.index=w.length,b(e,f,v),[void 0,t,r,n];l(v,e);var x=0,_=e,S=w.length-1,E=e=t,C=r=n;do{var A=w[x],N=S>x,k=i(t,E,e,n,C,r,A,N,!0,o,s,c,f,v,m,g);if(e=k[0],y(e))return s.index=x,k;E=k[1],r=k[2],C=k[3]}while(x++<S);if(s.index=x,_[a]!==e){var O=e[h]||0;e[h]=O+1,e[u+O]=_,_[a]=e,_[p]=O}return[e,E,r,C]}function i(t,e,n,r,i,u,a,c,p,h,l,d,v,b,m,g){for(var x=n.$type;x===f;){var _=o(t,n,r,u,h,l,d,v,b,m,g);if(n=_[0],y(n))return _;e=_[1],u=_[2],i=_[3],x=n.$type}if(void 0!==x)return[n,e,u,i];if(null==a){if(c)throw new Error("`null` is not allowed in branch key positions.");n&&(a=n[s])}else e=n,i=u,n=e[a],u=i&&i[a];return n=w(e,n,u,a,h,l,d,v,b,m,g),[n,e,u,i]}var s=t(36),u=t(43),a=t(33),c=t(46),p=t(42),h=t(44),f=t(120),l=t(50),d=t(94),v=t(96),y=t(102),b=t(86),m=t(143).iterateKeySet,g=t(92),w=t(103);e.exports=function(t,e,n,o,i){for(var s=t._root,u=s,a=s.expired,p=g(),h=s.cache,f=h[c],l=[],d=[],y=[],b=[],m=-1,w=e.length;++m<w;)for(var x=e[m],_=x.paths,S=x.jsonGraph,E=-1,C=_.length;++E<C;){var A=_[E];d.index=0,r(A,0,h,h,h,S,S,S,y,b,l,d,p,a,u,i,o)}var N=h[c],k=s.onChange;return v(k)&&f!==N&&k(),[y,b]}},{102:102,103:103,120:120,143:143,33:33,36:36,42:42,43:43,44:44,46:46,50:50,86:86,92:92,94:94,96:96}],77:[function(t,e,n){function r(t,e,n,o,u,a,c,p,h,f,l,d,v,y){var b=s(t);if(b&&b.length)for(var g=0,x=b.length,_=h.index;;){var S=b[g],E=t[S],C=w(E)&&!E.$type;p.depth=e;var A=i(n,o,u,S,E,C,!1,p,h,f,l,d,v,y);p[e]=S,p.index=e,h[h.index++]=S;var N=A[0],k=A[1];if(N&&(C?r(E,e+1,n,k,N,a,c,p,h,f,l,d,v,y):(m(d,N),a.push(p.slice(0,p.index+1)),c.push(h.slice(0,h.index)))),++g>=x)break;h.index=_}}function o(t,e,n,r,o,s,u,c,f,v){var y=n.value;if(o.splice(0,o.length),o.push.apply(o,y),x(n))return o.index=y.length,E(n,u,c),[void 0,e];m(c,n);var b=n,g=e;if(n=n[h],null!=n)g=n[p]||e,o.index=y.length;else{var w=0,_=y.length-1;g=n=e;do{var C=y[w],A=_>w,N=i(e,g,n,C,t,A,!0,r,o,s,u,c,f,v);if(n=N[0],S(n))return o.index=w,N;g=N[1]}while(w++<_);if(o.index=w,b[h]!==n){var k=n[d]||0;n[d]=k+1,n[a+k]=b,b[h]=n,b[l]=k}}return[n,g]}function i(t,e,n,r,i,s,a,c,p,h,f,l,d,y){for(var b=n.$type;b===v;){var m=o(i,t,n,c,p,h,f,l,d,y);if(n=m[0],S(n))return m;e=m[1],b=n&&n.$type}if(void 0!==b)return[n,e];if(null==r){if(s)throw new Error("`null` is not allowed in branch key positions.");n&&(r=n[u])}else e=n,n=e[r];return n=A(e,n,r,i,s,a,c,p,h,f,l,d,y),[n,e]}function s(t){if(w(t)&&!t.$type){var e=[],n=0;b(t)&&(e[n++]="length");for(var r in t)r[0]!==c&&"$"!==r[0]&&g(t,r)&&(e[n++]=r);return e}}var u=t(36),a=t(43),c=t(40),p=t(39),h=t(33),f=t(46),l=t(42),d=t(44),v=t(120),y=t(13),b=Array.isArray,m=t(50),g=t(91),w=t(100),x=t(95),_=t(96),S=t(102),E=t(86),C=t(92),A=t(104);e.exports=function(t,e,n,o,i){for(var s=t._root,u=s,a=s.expired,c=C(),h=t._path,l=s.cache,d=h.length?y(t,h).value:l,v=d[p]||l,b=l[f],m=[],g=[],w=[],x=h.length,S=-1,E=e.length;++S<E;){var A=e[S],N=h.slice(0);N.index=x,r(A.json,0,l,v,d,g,w,m,N,c,a,u,i,o)}var k=l[f],O=s.onChange;return _(O)&&b!==k&&O(),[g,w]}},{100:100,102:102,104:104,120:120,13:13,33:33,36:36,39:39,40:40,42:42,43:43,44:44,46:46,50:50,86:86,91:91,92:92,95:95,96:96}],78:[function(t,e,n){function r(t,e,n,o,s,u,a,c,p,h,f,l,d,y,b){for(var m={},g=n<e.length-1,x=e[n],_=w(x,m),S=h.index;;){p.depth=n;var E=i(o,s,u,_,t,g,!1,p,h,f,l,d,y,b);p[n]=_,p.index=n,h[h.index++]=_;var C=E[0],A=E[1];if(C&&(g?r(t,e,n+1,o,A,C,a,c,p,h,f,l,d,y,b):(v(d,C),a.push(p.slice(0,p.index+1)),c.push(h.slice(0,h.index)))),_=w(x,m),m.done)break;h.index=S}}function o(t,e,n,r,o,s,p,l,d,b){var w=n.value;if(o.splice(0,o.length),o.push.apply(o,w),y(n))return o.index=w.length,g(n,p,l),[void 0,e];v(l,n);var x=n,_=e;if(n=n[c],null!=n)_=n[a]||e,o.index=w.length;else{var S=0,E=w.length-1;_=n=e;do{var C=w[S],A=E>S,N=i(e,_,n,C,t,A,!0,r,o,s,p,l,d,b);if(n=N[0],m(n))return o.index=S,N;_=N[1]}while(S++<E);if(o.index=S,x[c]!==n){var k=n[f]||0;n[f]=k+1,n[u+k]=x,x[c]=n,x[h]=k}}return[n,_]}function i(t,e,n,r,i,u,a,c,p,h,f,d,v,y){for(var b=n.$type;b===l;){var g=o(i,t,n,c,p,h,f,d,v,y);if(n=g[0],m(n))return g;e=g[1],b=n.$type}if(void 0!==b)return[n,e];if(null==r){if(u)throw new Error("`null` is not allowed in branch key positions.");n&&(r=n[s])}else e=n,n=e[r];return n=_(e,n,r,i,u,a,c,p,h,f,d,v,y),[n,e]}var s=t(36),u=t(43),a=t(39),c=t(33),p=t(46),h=t(42),f=t(44),l=t(120),d=t(13),v=t(50),y=t(95),b=t(96),m=t(102),g=t(86),w=t(143).iterateKeySet,x=t(92),_=t(104);e.exports=function(t,e,n,o,i){for(var s=t._root,u=s,c=s.expired,h=x(),f=t._path,l=s.cache,v=f.length?d(t,f).value:l,y=v[a]||l,m=l[p],g=[],w=[],_=[],S=f.length,E=-1,C=e.length;++E<C;){var A=e[E],N=A.path,k=A.value,O=f.slice(0);O.index=S,r(k,N,0,l,y,v,w,_,g,O,h,c,u,i,o)}var P=l[p],j=s.onChange;return b(j)&&m!==P&&j(),[w,_]}},{102:102,104:104,120:120,13:13,143:143,33:33,36:36,39:39,42:42,43:43,44:44,46:46,50:50,86:86,92:92,95:95,96:96}],79:[function(t,e,n){var r=t(130),o=t(64),i=t(101);e.exports=function(t,e){for(var n=i(t)?t:r.pathValue(t,e),s=0,u=n.path,a=u.length;++s<a;)if("object"==typeof u[s])return new o(function(t){t.onError(new Error("Paths must be simple paths"))});var c=this;return new o(function(t){return c._set(n).subscribe(function(e){for(var n=e.json,r=-1,o=u.length;n&&++r<o;)n=n[u[r]];t.onNext(n)},function(e){t.onError(e)},function(){t.onCompleted()})})}},{101:101,130:130,64:64}],80:[function(t,e,n){var r=t(134),o=t(101),i=t(78);e.exports=function(t,e,n,s){var u=r.fromPath(t),a=e,c=n,p=s;if(o(u)?(p=c,c=a,a=u):a={path:u,value:a},o(a)===!1)throw new Error("Model#setValueSync must be called with an Array path.");return"function"!=typeof c&&(c=this._root._errorSelector),"function"!=typeof p&&(p=this._root._comparator),this._syncCheck("setValueSync")?(i(this,[a]),this._getValueSync(this,a.path).value):void 0}},{101:101,134:134,78:78}],81:[function(t,e,n){e.exports=function(t){if(!t)return t;for(var e=-1,n=t.length,r=[];++e<n;)r[e]=t[e];return r}},{}],82:[function(t,e,n){e.exports=function(t,e){for(var n=-1,r=-1,o=t.length,i=[];++r<o;)for(var s=e(t[r],r,t),u=-1,a=s.length;++u<a;)i[++n]=s[u];return i}},{}],83:[function(t,e,n){e.exports=function(t,e){for(var n=-1,r=t.length,o=new Array(r);++n<r;)o[n]=e(t[n],n,t);return o}},{}],84:[function(t,e,n){e.exports=function(t,e,n){var r=e||0,o=-1,i=t.length-r;0>i&&(i=0),n>0&&i>n&&(i=n);for(var s=new Array(i);++o<i;)s[o]=t[o+r];return s}},{}],85:[function(t,e,n){var r=t(40),o=t(91),i=Array.isArray,s=t(100);e.exports=function(t){var e=t;if(s(e)){e=i(t)?[]:{};var n=t;for(var u in n)u[0]!==r&&o(n,u)&&(e[u]=n[u])}return e}},{100:100,40:40,91:91}],86:[function(t,e,n){var r=t(51),o=t(35);e.exports=function(t,e,n){return t[o]||(t[o]=!0,e.push(t),r(n,t)),t}},{35:35,51:51}],87:[function(t,e,n){var r=t(100);e.exports=function(t){return r(t)&&t.$expires||void 0}},{100:100}],88:[function(t,e,n){var r=t(100);e.exports=function(t){return r(t)&&t.$size||0}},{100:100}],89:[function(t,e,n){var r=t(100);e.exports=function(t){return r(t)&&t.$timestamp||void 0}},{100:100}],90:[function(t,e,n){var r=t(100);e.exports=function(t,e){var n=r(t)&&t.$type||void 0;return e&&n?"branch":n}},{100:100}],91:[function(t,e,n){var r=t(100),o=Object.prototype.hasOwnProperty;e.exports=function(t,e){return r(t)&&o.call(t,e)}},{100:100}],92:[function(t,e,n){var r=1;e.exports=function(){return r++}},{}],93:[function(t,e,n){var r=t(36),o=t(39),i=t(46);e.exports=function(t,e,n,s){return t[r]=n,t[o]=e,t[i]=s,e[n]=t,t}},{36:36,39:39,46:46}],94:[function(t,e,n){var r=t(106),o=t(122),i=t(121);e.exports=function(t){var e=t.$expires;return null!=e&&e!==i&&e!==o&&e<r()}},{106:106,121:121,122:122}],95:[function(t,e,n){var r=t(106),o=t(122),i=t(121);e.exports=function(t){var e=t.$expires;return null!=e&&e!==i&&(e===o||e<r())}},{106:106,121:121,122:122}],96:[function(t,e,n){var r="function";e.exports=function(t){return Boolean(t)&&typeof t===r}},{}],97:[function(t,e,n){var r=t(40);e.exports=function(t){return"$size"===t||t&&t.charAt(0)===r}},{40:40}],98:[function(t,e,n){var r=t(100);e.exports=function(t){return r(t)&&"json"in t}},{100:100}],99:[function(t,e,n){var r=Array.isArray,o=t(100);e.exports=function(t){return o(t)&&r(t.paths)&&(o(t.jsonGraph)||o(t.jsong)||o(t.json)||o(t.values)||o(t.value))}},{100:100}],100:[function(t,e,n){var r="object";e.exports=function(t){return null!==t&&typeof t===r}},{}],101:[function(t,e,n){var r=Array.isArray,o=t(100);e.exports=function(t){return o(t)&&(r(t.path)||"string"==typeof t.path)}},{100:100}],102:[function(t,e,n){var r="object";e.exports=function(t){return null==t||typeof t!==r}},{}],103:[function(t,e,n){var r=t(36),o=t(39),i=t(120),s=t(119),u=t(88),a=t(89),c=t(100),p=t(95),h=t(96),f=t(50),l=t(117),d=t(93),v=t(86),y=t(110),b=t(115),m=t(107);e.exports=function(t,e,n,g,w,x,_,S,E,C,A){var N,k,O,P,j,D,q;if(e===n){if(null===n)return e=l(n,void 0,n),t=b(t,-e.$size,E,_),e=d(e,t,g),f(E,e),e;if(void 0===n)return n;if(P=c(e),P&&(k=e.$type,null==k))return null==e[o]&&(e[r]=g,e[o]=t),e}else P=c(e),P&&(k=e.$type);if(k!==i){if(j=c(n),j&&(O=n.$type),P&&!k&&(null==n||j&&!O))return e}else{if(null==n)return p(e)?void v(e,S,E):e;if(j=c(n),j&&(O=n.$type,O===i))if(e===n){if(null!=e[o])return e}else if(D=e.$timestamp,q=n.$timestamp,!p(e)&&!p(n)&&D>q)return}if(k&&j&&!O)return d(y(e,n,t,g,E),t,g);if(O||!j){if(O===s&&h(A)&&(n=A(m(w,g),n)),O&&e===n)null==e[o]&&(e=l(e,k,e.value),t=b(t,-e.$size,E,_),e=d(e,t,g,_));else{var R=!0;!k&&P||(R=a(n)<a(e)==!1,(k||O)&&h(C)&&(R=!C(e,n,x.slice(0,x.index)))),R&&(n=l(n,O,O?n.value:n),N=u(e)-u(n),e=y(e,n,t,g,E),t=b(t,N,E,_),e=d(e,t,g,_))}p(e)?v(e,S,E):f(E,e)}else null==e&&(e=d(n,t,g));return e}},{100:100,107:107,110:110,115:115,117:117,119:119,120:120,36:36,39:39,50:50,86:86,88:88,89:89,93:93,95:95,96:96}],104:[function(t,e,n){var r=t(120),o=t(119),i=t(90),s=t(88),u=t(89),a=t(95),c=t(102),p=t(96),h=t(117),f=t(86),l=t(93),d=t(110),v=t(115),y=t(114),b=t(107);e.exports=function(t,e,n,m,g,w,x,_,S,E,C,A,N){var k=i(e,w);if(g||w)k&&a(e)&&(k="expired",f(e,E,C)),(k&&k!==r||c(e))&&(e=d(e,{},t,n,C),e=l(e,t,n,S),e=y(e,S));else{var O=m,P=i(O),j=u(O)<u(e)==!1;if((k||P)&&p(A)&&(j=!A(e,O,_.slice(0,_.index))),j){P===o&&p(N)&&(O=N(b(x,n),O)),O=h(O,P,P?O.value:O);var D=s(e)-s(O);e=d(e,O,t,n,C),t=v(t,D,C,S),e=l(e,t,n,S)}}return e}},{102:102,107:107,110:110,114:114,115:115,117:117,119:119,120:120,86:86,88:88,89:89,90:90,93:93,95:95,96:96}],105:[function(t,e,n){e.exports=function(){}},{}],106:[function(t,e,n){e.exports=Date.now},{}],107:[function(t,e,n){e.exports=function(t,e){var n=t.slice(0,t.depth);return n[n.length]=e,n}},{}],108:[function(t,e,n){var r=t(120),o=t(39),i=t(51),s=t(100),u=t(112),a=t(113);e.exports=function(t,e,n,c){if(s(t)){var p=t.$type;return Boolean(p)&&(p===r&&a(t),i(c,t)),u(t),e[n]=t[o]=void 0,!0}return!1}},{100:100,112:112,113:113,120:120,39:39,51:51}],109:[function(t,e,n){var r=t(91),o=t(40),i=t(108);e.exports=function s(t,e,n,u){if(i(t,e,n,u)){if(null==t.$type)for(var a in t)a[0]!==o&&"$"!==a[0]&&r(t,a)&&s(t[a],t,a,u);return!0}return!1}},{108:108,40:40,91:91}],110:[function(t,e,n){var r=t(100),o=t(111),i=t(109);e.exports=function(t,e,n,s,u){return t===e?t:(r(t)&&(o(t,e),i(t,n,s,u)),n[s]=e,e)}},{100:100,109:109,111:111}],111:[function(t,e,n){var r=t(43),o=t(33),i=t(44);e.exports=function(t,e){for(var n=t[i]||0,s=e[i]||0,u=-1;++u<n;){var a=t[r+u];void 0!==a&&(a[o]=e,e[r+(s+u)]=a,t[r+u]=void 0)}return e[i]=n+s,t[i]=void 0,e}},{33:33,43:43,44:44}],112:[function(t,e,n){var r=t(43),o=t(33),i=t(42),s=t(44);e.exports=function(t){for(var e=-1,n=t[s]||0;++e<n;){var u=t[r+e];null!=u&&(u[o]=u[i]=t[r+e]=void 0)}return t[s]=void 0,t}},{33:33,42:42,43:43,44:44}],113:[function(t,e,n){var r=t(43),o=t(33),i=t(42),s=t(44);e.exports=function(t){var e=t[o];if(e){for(var n=(t[i]||0)-1,u=(e[s]||0)-1;++n<=u;)e[r+n]=e[r+(n+1)];e[s]=u,t[i]=t[o]=e=void 0}return t}},{33:33,42:42,43:43,44:44}],114:[function(t,e,n){var r=t(43),o=t(39),i=t(46),s=t(44);e.exports=function(t,e){var n=[t],u=0;do{var a=n[u--];if(a&&a[i]!==e){a[i]=e,n[u++]=a[o];for(var c=-1,p=a[s]||0;++c<p;)n[u++]=a[r+c]}}while(u>-1);return t}},{39:39,43:43,44:44,46:46}],115:[function(t,e,n){var r=t(36),o=t(46),i=t(39),s=t(108),u=t(114);e.exports=function(t,e,n,a){var c=t;do{var p=c[i],h=c.$size=(c.$size||0)-e;0>=h&&null!=p?s(c,p,c[r],n):c[o]!==a&&u(c,a),c=p}while(c);return t}},{108:108,114:114,36:36,39:39,46:46}],116:[function(t,e,n){var r=Array.isArray,o=t(101),i=t(99),s=t(98),u=t(134);e.exports=function(t,e,n){for(var a=0,c=t.length;c>a;++a){var p=t[a],h=!1;if(r(p)&&e.path?h=!0:"string"==typeof p&&e.pathSyntax?h=!0:o(p)&&e.pathValue?(p.path=u.fromPath(p.path),h=!0):i(p)&&e.jsonGraph?h=!0:s(p)&&e.json?h=!0:"function"==typeof p&&a+1===c&&e.selector&&(h=!0),!h)return new Error("Unrecognized argument "+typeof p+" ["+String(p)+"] to Model#"+n)}return!0}},{101:101,134:134,98:98,99:99}],117:[function(t,e,n){var r=t(130),o=r.atom,i=t(106),s=t(122),u=t(37),a=50,c=t(85),p=Array.isArray,h=t(88),f=t(87);e.exports=function(t,e,n){var r=0,l=t,d=e;if(d?(l=c(l),r=h(l),l.$type=d):(l=o(n),d=l.$type,l[u]=!0),null==n)r=a+1;else if(null==r||0>=r)switch(typeof n){case"object":r=p(n)?a+n.length:a+1;break;case"string":r=a+n.length;break;default:r=a+1}var v=f(l);return"number"==typeof v&&s>v&&(l.$expires=i()+-1*v),l.$size=r,l}},{106:106,122:122,130:130,37:37,85:85,87:87,88:88}],118:[function(t,e,n){e.exports="atom"},{}],119:[function(t,e,n){e.exports="error"},{}],120:[function(t,e,n){e.exports="ref"},{}],121:[function(t,e,n){e.exports=1},{}],122:[function(t,e,n){e.exports=0},{}],123:[function(t,e,n){"use strict";function r(){if(a.length)throw a.shift()}function o(t){var e;e=u.length?u.pop():new i,e.task=t,s(e)}function i(){this.task=null}var s=t(124),u=[],a=[],c=s.makeRequestCallFromTimer(r);e.exports=o,i.prototype.call=function(){try{this.task.call()}catch(t){o.onerror?o.onerror(t):(a.push(t),c())}finally{this.task=null,u[u.length]=this}}},{124:124}],124:[function(t,e,n){(function(t){"use strict";function n(t){u.length||(s(),a=!0),u[u.length]=t}function r(){for(;c<u.length;){var t=c;if(c+=1,u[t].call(),c>p){for(var e=0,n=u.length-c;n>e;e++)u[e]=u[e+c];u.length-=c,c=0}}u.length=0,c=0,a=!1}function o(t){var e=1,n=new h(t),r=document.createTextNode("");return n.observe(r,{characterData:!0}),function(){e=-e,r.data=e}}function i(t){return function(){function e(){clearTimeout(n),clearInterval(r),t()}var n=setTimeout(e,0),r=setInterval(e,50)}}e.exports=n;var s,u=[],a=!1,c=0,p=1024,h=t.MutationObserver||t.WebKitMutationObserver;s="function"==typeof h?o(r):i(r),n.requestFlush=s,n.makeRequestCallFromTimer=i}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],125:[function(t,e,n){"use strict";function r(t,e){var n;for(n in e)t[n]=e[n];return t}function o(t,e){if(this._jsongUrl=t,"number"==typeof e){var n={timeout:e};e=n}this._config=r({timeout:15e3,headers:{}},e||{})}var i=t(129),s=t(126);Array.isArray;o.prototype={constructor:o,buildQueryObject:s,get:function(t){var e="GET",n=this.buildQueryObject(this._jsongUrl,e,{paths:t,method:"get"}),o=r(n,this._config),s=this;return i(e,o,s)},set:function(t){var e="POST",n=this.buildQueryObject(this._jsongUrl,e,{jsonGraph:t,method:"set"}),o=r(n,this._config);o.headers["Content-Type"]="application/x-www-form-urlencoded";var s=this;return i(e,o,s)},call:function(t,e,n,o){e=e||[],n=n||[],o=o||[];var s="POST",u=[];u.push("method=call"),u.push("callPath="+encodeURIComponent(JSON.stringify(t))),u.push("arguments="+encodeURIComponent(JSON.stringify(e))),u.push("pathSuffixes="+encodeURIComponent(JSON.stringify(n))),u.push("paths="+encodeURIComponent(JSON.stringify(o)));var a=this.buildQueryObject(this._jsongUrl,s,u.join("&")),c=r(a,this._config);c.headers["Content-Type"]="application/x-www-form-urlencoded";var p=this;return i(s,c,p)}},o.XMLHttpSource=o,o["default"]=o,e.exports=o},{126:126,129:129}],126:[function(t,e,n){"use strict";e.exports=function(t,e,n){var r,o=[],i={url:t},s=-1!==t.indexOf("?"),u=s?"&":"?";return"string"==typeof n?o.push(n):(r=Object.keys(n),r.forEach(function(t){var e="object"==typeof n[t]?JSON.stringify(n[t]):n[t];o.push(t+"="+encodeURIComponent(e))})),"GET"===e?i.url+=u+o.join("&"):i.data=o.join("&"),i}},{}],127:[function(t,e,n){(function(t){"use strict";e.exports=function(){var e=new t.XMLHttpRequest;if("withCredentials"in e)return e;if(t.XDomainRequest)return new XDomainRequest;throw new Error("CORS is not supported by your browser")}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],128:[function(t,e,n){(function(t){"use strict";e.exports=function(){var e,n,r;if(t.XMLHttpRequest)return new t.XMLHttpRequest;try{for(n=["Msxml2.XMLHTTP","Microsoft.XMLHTTP","Msxml2.XMLHTTP.4.0"],r=0;3>r;r++)try{if(e=n[r],new t.ActiveXObject(e))break}catch(o){}return new t.ActiveXObject(e)}catch(o){throw new Error("XMLHttpRequest is not supported by your browser")}}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],129:[function(t,e,n){"use strict";function r(){}function o(t,e,n){return r.create(function(r){var o,i,h,f,l,d={method:t||"GET",crossDomain:!1,async:!0,headers:{},responseType:"json"};for(l in e)p.call(e,l)&&(d[l]=e[l]);d.crossDomain||d.headers["X-Requested-With"]||(d.headers["X-Requested-With"]="XMLHttpRequest"),null!=n.onBeforeRequest&&n.onBeforeRequest(d);try{o=d.crossDomain?c():a()}catch(v){r.onError(v)}try{d.user?o.open(d.method,d.url,d.async,d.user,d.password):o.open(d.method,d.url,d.async),o.timeout=d.timeout,o.withCredentials=d.withCredentials!==!1,h=d.headers;for(f in h)p.call(h,f)&&o.setRequestHeader(f,h[f]);if(d.responseType)try{o.responseType=d.responseType}catch(y){if("json"!==d.responseType)throw y}o.onreadystatechange=function(t){4===o.readyState&&(i||(i=!0,s(r,o,t)))},o.ontimeout=function(t){i||(i=!0,u(r,o,"timeout error",t))},o.send(d.data)}catch(y){r.onError(y)}return function(){i||4===o.readyState||(i=!0,o.abort())}})}function i(t,e,n){n||(n=new Error(e)),t.onError(n)}function s(t,e,n){var r,o;if(e&&t){o=e.responseType,r="response"in e?e.response:e.responseText;var s=1223===e.status?204:e.status;if(s>=200&&399>=s){try{"json"!==o&&(r=JSON.parse(r||"")),"string"==typeof r&&(r=JSON.parse(r||""))}catch(n){i(t,"invalid json",n)}return t.onNext(r),void t.onCompleted()}return 401===s||403===s||407===s?i(t,r):410===s?i(t,r):408===s||504===s?i(t,r):i(t,r||"Response code "+s)}}function u(t,e,n,r){i(t,n||e.statusText||"request error",r)}var a=t(128),c=t(127),p=Object.prototype.hasOwnProperty,h=function(){};r.create=function(t){var e=new r;return e.subscribe=function(e,n,r){var o,i;return o="function"==typeof e?{onNext:e,onError:n||h,onCompleted:r||h}:e,i=t(o),"function"==typeof i?{dispose:i}:i},e},e.exports=o},{127:127,128:128}],130:[function(t,e,n){function r(t,e,n){var r=Object.create(null);if(null!=n){for(var o in n)r[o]=n[o];return r.$type=t,r.value=e,r}return{$type:t,value:e}}var o=t(134);e.exports={ref:function(t,e){return r("ref",o.fromPath(t),e)},atom:function(t,e){return r("atom",t,e)},undefined:function(){return r("atom")},error:function(t,e){return r("error",t,e)},pathValue:function(t,e){return{path:o.fromPath(t),value:e}},pathInvalidation:function(t){return{path:o.fromPath(t),invalidated:!0}}}},{134:134}],131:[function(t,e,n){e.exports={integers:"integers",ranges:"ranges",keys:"keys"}},{}],132:[function(t,e,n){var r={token:"token",dotSeparator:".",commaSeparator:",",openingBracket:"[",closingBracket:"]",openingBrace:"{",closingBrace:"}",escape:"\\",space:" ",colon:":",quote:"quote",unknown:"unknown"};e.exports=r},{}],133:[function(t,e,n){e.exports={indexer:{nested:"Indexers cannot be nested.",needQuotes:"unquoted indexers must be numeric.",empty:"cannot have empty indexers.",leadingDot:"Indexers cannot have leading dots.",leadingComma:"Indexers cannot have leading comma.",requiresComma:"Indexers require commas between indexer args.",routedTokens:"Only one token can be used per indexer when specifying routed tokens."},range:{precedingNaN:"ranges must be preceded by numbers.",suceedingNaN:"ranges must be suceeded by numbers."},routed:{invalid:"Invalid routed token.  only integers|ranges|keys are supported."},quote:{empty:"cannot have empty quoted keys.",illegalEscape:"Invalid escape character.  Only quotes are escapable."},unexpectedToken:"Unexpected token.",invalidIdentifier:"Invalid Identifier.",invalidPath:"Please provide a valid path.",throwError:function(t,e,n){if(n)throw t+" -- "+e.parseString+" with next token: "+n;throw t+" -- "+e.parseString}}},{}],134:[function(t,e,n){var r=t(140),o=t(135),i=t(131),s=function(t,e){return o(new r(t,e))};e.exports=s,s.fromPathsOrPathValues=function(t,e){if(!t)return[];for(var n=[],r=0,o=t.length;o>r;r++)"string"==typeof t[r]?n[r]=s(t[r],e):"string"==typeof t[r].path?n[r]={path:s(t[r].path,e),value:t[r].value}:n[r]=t[r];return n},s.fromPath=function(t,e){return t?"string"==typeof t?s(t,e):t:[]},s.RoutedTokens=i},{131:131,135:135,140:140}],135:[function(t,e,n){var r=t(132),o=t(133),i=t(136);e.exports=function(t){for(var e=t.next(),n={},s=[];!e.done;){switch(e.type){case r.token:var u=+e.token[0];isNaN(u)||o.throwError(o.invalidIdentifier,t),s[s.length]=e.token;break;case r.dotSeparator:0===s.length&&o.throwError(o.unexpectedToken,t);break;case r.space:break;case r.openingBracket:i(t,e,n,s);break;default:o.throwError(o.unexpectedToken,t)}e=t.next()}return 0===s.length&&o.throwError(o.invalidPath,t),s}},{132:132,133:133,136:136}],136:[function(t,e,n){var r=t(132),o=t(133),i=o.indexer,s=t(138),u=t(137),a=t(139);e.exports=function(t,e,n,c){var p=t.next(),h=!1,f=1,l=!1;for(n.indexer=[];!p.done;){switch(p.type){case r.token:case r.quote:n.indexer.length===f&&o.throwError(i.requiresComma,t)}switch(p.type){case r.openingBrace:l=!0,a(t,p,n,c);break;case r.token:var d=+p.token;isNaN(d)&&o.throwError(i.needQuotes,t),n.indexer[n.indexer.length]=d;break;case r.dotSeparator:n.indexer.length||o.throwError(i.leadingDot,t),s(t,p,n,c);
break;case r.space:break;case r.closingBracket:h=!0;break;case r.quote:u(t,p,n,c);break;case r.openingBracket:o.throwError(i.nested,t);break;case r.commaSeparator:++f;break;default:o.throwError(o.unexpectedToken,t)}if(h)break;p=t.next()}0===n.indexer.length&&o.throwError(i.empty,t),n.indexer.length>1&&l&&o.throwError(i.routedTokens,t),1===n.indexer.length&&(n.indexer=n.indexer[0]),c[c.length]=n.indexer,n.indexer=void 0}},{132:132,133:133,137:137,138:138,139:139}],137:[function(t,e,n){var r=t(132),o=t(133),i=o.quote;e.exports=function(t,e,n,s){for(var u=t.next(),a="",c=e.token,p=!1,h=!1;!u.done;){switch(u.type){case r.token:case r.space:case r.dotSeparator:case r.commaSeparator:case r.openingBracket:case r.closingBracket:case r.openingBrace:case r.closingBrace:p&&o.throwError(i.illegalEscape,t),a+=u.token;break;case r.quote:p?(a+=u.token,p=!1):u.token!==c?a+=u.token:h=!0;break;case r.escape:p=!0;break;default:o.throwError(o.unexpectedToken,t)}if(h)break;u=t.next()}0===a.length&&o.throwError(i.empty,t),n.indexer[n.indexer.length]=a}},{132:132,133:133}],138:[function(t,e,n){var r=t(140),o=t(132),i=t(133);e.exports=function(t,e,n,s){var u,a=t.peek(),c=1,p=!1,h=!0,f=n.indexer.length-1,l=r.toNumber(n.indexer[f]);for(isNaN(l)&&i.throwError(i.range.precedingNaN,t);!p&&!a.done;){switch(a.type){case o.dotSeparator:3===c&&i.throwError(i.unexpectedToken,t),++c,3===c&&(h=!1);break;case o.token:u=r.toNumber(t.next().token),isNaN(u)&&i.throwError(i.range.suceedingNaN,t),p=!0;break;default:p=!0}if(p)break;t.next(),a=t.peek()}n.indexer[f]={from:l,to:h?u:u-1}}},{132:132,133:133,140:140}],139:[function(t,e,n){var r=t(132),o=t(131),i=t(133),s=i.routed;e.exports=function(t,e,n,u){var a=t.next(),c=!1,p="";switch(a.token){case o.integers:case o.ranges:case o.keys:break;default:i.throwError(s.invalid,t)}var h=t.next();if(h.type===r.colon&&(c=!0,h=t.next(),h.type!==r.token&&i.throwError(s.invalid,t),p=h.token,h=t.next()),h.type===r.closingBrace){var f={type:a.token,named:c,name:p};n.indexer[n.indexer.length]=f}else i.throwError(s.invalid,t)}},{131:131,132:132,133:133}],140:[function(t,e,n){function r(t,e,n){return{token:t,done:n,type:e}}function o(t,e,n){var o,g=!1,w="",x=n?m:b;do{if(o=e+1>=t.length)break;var _=t[e+1];if(void 0===_||-1!==x.indexOf(_)){if(w.length)break;++e;var S;switch(_){case s:S=i.dotSeparator;break;case u:S=i.commaSeparator;break;case a:S=i.openingBracket;break;case c:S=i.closingBracket;break;case p:S=i.openingBrace;break;case h:S=i.closingBrace;break;case y:S=i.space;break;case d:case v:S=i.quote;break;case l:S=i.escape;break;case f:S=i.colon;break;default:S=i.unknown}g=r(_,S,!1);break}w+=_,++e}while(!o);return!g&&w.length&&(g=r(w,i.token,!1)),g||(g={done:!0}),{token:g,idx:e}}var i=t(132),s=".",u=",",a="[",c="]",p="{",h="}",f=":",l="\\",d='"',v="'",y=" ",b="\\'\"[]., ",m="\\{}'\"[]., :",g=e.exports=function(t,e){this._string=t,this._idx=-1,this._extended=e,this.parseString=""};g.prototype={next:function(){var t=this._nextToken?this._nextToken:o(this._string,this._idx,this._extended);return this._idx=t.idx,this._nextToken=!1,this.parseString+=t.token.token,t.token},peek:function(){var t=this._nextToken?this._nextToken:o(this._string,this._idx,this._extended);return this._nextToken=t,t.token}},g.toNumber=function(t){return isNaN(+t)?NaN:+t}},{132:132}],141:[function(t,e,n){var r=t(147),o=t(148);e.exports=function(t){var e=t.reduce(function(t,e){var n=e.length;return t[n]||(t[n]=[]),t[n].push(e),t},{});return Object.keys(e).forEach(function(t){e[t]=o(e[t])}),r(e)}},{147:147,148:148}],142:[function(t,e,n){var r=t(144);e.exports=function o(t,e,n){for(var i=t,s=!0;s&&n<e.length;++n){var u=e[n],a=typeof u;if(u&&"object"===a){var c={},p=r(u,c),h=n+1;do{var f=i[p];s=void 0!==f,s&&(s=o(f,e,h)),p=r(u,c)}while(s&&!c.done);break}i=i[u],s=void 0!==i}return s}},{144:144}],143:[function(t,e,n){e.exports={iterateKeySet:t(144),toTree:t(148),toTreeWithUnion:t(149),pathsComplementFromTree:t(146),pathsComplementFromLengthTree:t(145),hasIntersection:t(142),toPaths:t(147),collapse:t(141)}},{141:141,142:142,144:144,145:145,146:146,147:147,148:148,149:149}],144:[function(t,e,n){function r(t,e){var n=e.from=t.from||0,r=e.to=t.to||"number"==typeof t.length&&e.from+t.length-1||0;e.rangeOffset=e.from,e.loaded=!0,n>r&&(e.empty=!0)}function o(t,e){e.done=!1;var n=e.isObject=!(!t||"object"!=typeof t);e.isArray=n&&i(t),e.arrayOffset=0}var i=Array.isArray;e.exports=function(t,e){if(void 0===e.isArray&&o(t,e),e.isArray){var n;do{e.loaded&&e.rangeOffset>e.to&&(++e.arrayOffset,e.loaded=!1);var i=e.arrayOffset,s=t.length;if(i>=s){e.done=!0;break}var u=t[e.arrayOffset],a=typeof u;if("object"===a){if(e.loaded||r(u,e),e.empty)continue;n=e.rangeOffset++}else++e.arrayOffset,n=u}while(void 0===n);return n}return e.isObject?(e.loaded||r(t,e),e.rangeOffset>e.to?void(e.done=!0):e.rangeOffset++):(e.done=!0,t)}},{}],145:[function(t,e,n){var r=t(142);e.exports=function(t,e){for(var n=[],o=-1,i=0,s=t.length;s>i;++i){var u=t[i];r(e[u.length],u,0)||(n[++o]=u)}return n}},{142:142}],146:[function(t,e,n){var r=t(142);e.exports=function(t,e){for(var n=[],o=-1,i=0,s=t.length;s>i;++i)r(e,t[i],0)||(n[++o]=t[i]);return n}},{142:142}],147:[function(t,e,n){function r(t){return null!==t&&typeof t===f}function o(t,e,n){var r,i,s,u,h,f,l,d,v,y,b,m,g,w,x=c(String(e)),_=Object.create(null),S=[],E=-1,C=0,A=[],N=0;if(u=[],h=-1,n-1>e){for(f=a(t,u);++h<f;)r=u[h],i=o(t[r],e+1,n),s=i.code,_[s]?i=_[s]:(S[C++]=s,i=_[s]={keys:[],sets:i.sets}),x=c(x+r+s),p(r)&&i.keys.push(parseInt(r,10))||i.keys.push(r);for(;++E<C;)if(r=S[E],i=_[r],u=i.keys,f=u.length,f>0)for(l=i.sets,d=-1,v=l.length,g=u[0];++d<v;){for(y=l[d],b=-1,m=y.length,w=new Array(m+1),w[0]=f>1&&u||g;++b<m;)w[b+1]=y[b];A[N++]=w}}else for(f=a(t,u),f>1?A[N++]=[u]:A[N++]=u;++h<f;)x=c(x+u[h]);return{code:x,sets:A}}function i(t){for(var e=-1,n=t.length;++e<n;){var r=t[e];h(r)&&(t[e]=s(r))}return t}function s(t){for(var e=-1,n=t.length-1,r=n>0;++e<=n;){var o=t[e];if(!p(o)){r=!1;break}t[e]=parseInt(o,10)}if(r===!0){t.sort(u);var i=t[0],s=t[n];if(n>=s-i)return{from:i,to:s}}return t}function u(t,e){return t-e}function a(t,e,n){var r=0;for(var o in t)e[r++]=o;return r>1&&e.sort(n),r}function c(t){for(var e=5381,n=-1,r=t.length;++n<r;)e=(e<<5)+e+t.charCodeAt(n);return String(e)}function p(t){return!h(t)&&t-parseFloat(t)+1>=0}var h=Array.isArray,f="object";e.exports=function(t){var e,n=[],s=0;for(var u in t)if(p(u)&&r(e=t[u]))for(var a=o(e,0,parseInt(u,10)).sets,c=-1,h=a.length;++c<h;)n[s++]=i(a[c]);return n}},{}],148:[function(t,e,n){function r(t,e,n){var i,s=e[n],u={},a=n+1;i=o(s,u);do{var c=t[i];c||(a===e.length?t[i]=null:c=t[i]={}),a<e.length&&r(c,e,a),u.done||(i=o(s,u))}while(!u.done)}var o=t(144);Array.isArray;e.exports=function(t){return t.reduce(function(t,e){return r(t,e,0),t},{})}},{144:144}],149:[function(t,e,n){},{}],150:[function(t,e,n){function r(){p=!1,u.length?c=u.concat(c):h=-1,c.length&&o()}function o(){if(!p){var t=setTimeout(r);p=!0;for(var e=c.length;e;){for(u=c,c=[];++h<e;)u&&u[h].run();h=-1,e=c.length}u=null,p=!1,clearTimeout(t)}}function i(t,e){this.fun=t,this.array=e}function s(){}var u,a=e.exports={},c=[],p=!1,h=-1;a.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];c.push(new i(t,e)),1!==c.length||p||setTimeout(o,0)},i.prototype.run=function(){this.fun.apply(null,this.array)},a.title="browser",a.browser=!0,a.env={},a.argv=[],a.version="",a.versions={},a.on=s,a.addListener=s,a.once=s,a.off=s,a.removeListener=s,a.removeAllListeners=s,a.emit=s,a.binding=function(t){throw new Error("process.binding is not supported")},a.cwd=function(){return"/"},a.chdir=function(t){throw new Error("process.chdir is not supported")},a.umask=function(){return 0}},{}],151:[function(t,e,n){"use strict";e.exports=t(156)},{156:156}],152:[function(t,e,n){"use strict";function r(){}function o(t){try{return t.then}catch(e){return y=e,b}}function i(t,e){try{return t(e)}catch(n){return y=n,b}}function s(t,e,n){try{t(e,n)}catch(r){return y=r,b}}function u(t){if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");if("function"!=typeof t)throw new TypeError("not a function");this._37=0,this._12=null,this._59=[],t!==r&&d(t,this)}function a(t,e,n){return new t.constructor(function(o,i){var s=new u(r);s.then(o,i),c(t,new l(e,n,s))})}function c(t,e){for(;3===t._37;)t=t._12;return 0===t._37?void t._59.push(e):void v(function(){var n=1===t._37?e.onFulfilled:e.onRejected;if(null===n)return void(1===t._37?p(e.promise,t._12):h(e.promise,t._12));var r=i(n,t._12);r===b?h(e.promise,y):p(e.promise,r)})}function p(t,e){if(e===t)return h(t,new TypeError("A promise cannot be resolved with itself."));if(e&&("object"==typeof e||"function"==typeof e)){var n=o(e);if(n===b)return h(t,y);if(n===t.then&&e instanceof u)return t._37=3,t._12=e,void f(t);if("function"==typeof n)return void d(n.bind(e),t)}t._37=1,t._12=e,f(t)}function h(t,e){t._37=2,t._12=e,f(t)}function f(t){for(var e=0;e<t._59.length;e++)c(t,t._59[e]);t._59=null}function l(t,e,n){this.onFulfilled="function"==typeof t?t:null,this.onRejected="function"==typeof e?e:null,this.promise=n}function d(t,e){var n=!1,r=s(t,function(t){n||(n=!0,p(e,t))},function(t){n||(n=!0,h(e,t))});n||r!==b||(n=!0,h(e,y))}var v=t(124),y=null,b={};e.exports=u,u._99=r,u.prototype.then=function(t,e){if(this.constructor!==u)return a(this,t,e);var n=new u(r);return c(this,new l(t,e,n)),n}},{124:124}],153:[function(t,e,n){"use strict";var r=t(152);e.exports=r,r.prototype.done=function(t,e){var n=arguments.length?this.then.apply(this,arguments):this;n.then(null,function(t){setTimeout(function(){throw t},0)})}},{152:152}],154:[function(t,e,n){"use strict";function r(t){var e=new o(o._99);return e._37=1,e._12=t,e}var o=t(152);e.exports=o;var i=r(!0),s=r(!1),u=r(null),a=r(void 0),c=r(0),p=r("");o.resolve=function(t){if(t instanceof o)return t;if(null===t)return u;if(void 0===t)return a;if(t===!0)return i;if(t===!1)return s;if(0===t)return c;if(""===t)return p;if("object"==typeof t||"function"==typeof t)try{var e=t.then;if("function"==typeof e)return new o(e.bind(t))}catch(n){return new o(function(t,e){e(n)})}return r(t)},o.all=function(t){var e=Array.prototype.slice.call(t);return new o(function(t,n){function r(s,u){if(u&&("object"==typeof u||"function"==typeof u)){if(u instanceof o&&u.then===o.prototype.then){for(;3===u._37;)u=u._12;return 1===u._37?r(s,u._12):(2===u._37&&n(u._12),void u.then(function(t){r(s,t)},n))}var a=u.then;if("function"==typeof a){var c=new o(a.bind(u));return void c.then(function(t){r(s,t)},n)}}e[s]=u,0===--i&&t(e)}if(0===e.length)return t([]);for(var i=e.length,s=0;s<e.length;s++)r(s,e[s])})},o.reject=function(t){return new o(function(e,n){n(t)})},o.race=function(t){return new o(function(e,n){t.forEach(function(t){o.resolve(t).then(e,n)})})},o.prototype["catch"]=function(t){return this.then(null,t)}},{152:152}],155:[function(t,e,n){"use strict";var r=t(152);e.exports=r,r.prototype["finally"]=function(t){return this.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})})}},{152:152}],156:[function(t,e,n){"use strict";e.exports=t(152),t(153),t(155),t(154),t(157)},{152:152,153:153,154:154,155:155,157:157}],157:[function(t,e,n){"use strict";var r=t(152),o=t(123);e.exports=r,r.denodeify=function(t,e){return e=e||1/0,function(){var n=this,o=Array.prototype.slice.call(arguments,0,e>0?e:0);return new r(function(e,r){o.push(function(t,n){t?r(t):e(n)});var i=t.apply(n,o);!i||"object"!=typeof i&&"function"!=typeof i||"function"!=typeof i.then||e(i)})}},r.nodeify=function(t){return function(){var e=Array.prototype.slice.call(arguments),n="function"==typeof e[e.length-1]?e.pop():null,i=this;try{return t.apply(this,arguments).nodeify(n,i)}catch(s){if(null===n||"undefined"==typeof n)return new r(function(t,e){e(s)});o(function(){n.call(i,s)})}}},r.prototype.nodeify=function(t,e){return"function"!=typeof t?this:void this.then(function(n){o(function(){t.call(e,null,n)})},function(n){o(function(){t.call(e,n)})})}},{123:123,152:152}],158:[function(e,n,r){(function(o){(function(i){var s={"boolean":!1,"function":!0,object:!0,number:!1,string:!1,undefined:!1},u=s[typeof window]&&window||this,a=s[typeof r]&&r&&!r.nodeType&&r,c=s[typeof n]&&n&&!n.nodeType&&n,p=(c&&c.exports===a&&a,s[typeof o]&&o);!p||p.global!==p&&p.window!==p||(u=p),"function"==typeof t&&t.amd?t(["rx"],function(t,e){return i(u,e,t)}):"object"==typeof n&&n&&n.exports===a?n.exports=i(u,n.exports,e(159)):u.Rx=i(u,{},u.Rx)}).call(this,function(t,e,n,r){function o(){try{return l.apply(this,arguments)}catch(t){return M.e=t,M}}function i(t){if(!E(t))throw new TypeError("fn must be a function");return l=t,o}function s(t,e,n){return new b(function(r){var o=!1,i=null,s=[];return t.subscribe(function(t){var u,a;try{a=e(t)}catch(c){return void r.onError(c)}if(u=0,o)try{u=n(a,i)}catch(p){return void r.onError(p)}else o=!0,i=a;u>0&&(i=a,s=[]),u>=0&&s.push(t)},function(t){r.onError(t)},function(){r.onNext(s),r.onCompleted()})},t)}function u(t){if(0===t.length)throw new D;return t[0]}function a(t,e,n,r){if(0>e)throw new R;return new b(function(o){var i=e;return t.subscribe(function(t){0===i--&&(o.onNext(t),o.onCompleted())},function(t){o.onError(t)},function(){n?(o.onNext(r),o.onCompleted()):o.onError(new R)})},t)}function c(t,e,n){return new b(function(r){var o=n,i=!1;return t.subscribe(function(t){i?r.onError(new Error("Sequence contains more than one element")):(o=t,i=!0)},function(t){r.onError(t)},function(){i||e?(r.onNext(o),r.onCompleted()):r.onError(new D)})},t)}function p(t,e,n){return new b(function(r){return t.subscribe(function(t){r.onNext(t),r.onCompleted()},function(t){r.onError(t)},function(){e?(r.onNext(n),r.onCompleted()):r.onError(new D)})},t)}function h(t,e,n){return new b(function(r){var o=n,i=!1;return t.subscribe(function(t){o=t,i=!0},function(t){r.onError(t)},function(){i||e?(r.onNext(o),r.onCompleted()):r.onError(new D)})},t)}function f(t,e,n,o){var i=j(e,n,3);return new b(function(e){var n=0;return t.subscribe(function(r){var s;try{s=i(r,n,t)}catch(u){return void e.onError(u)}s?(e.onNext(o?n:r),e.onCompleted()):n++},function(t){e.onError(t)},function(){e.onNext(o?-1:r),e.onCompleted()})},t)}var l,d=n.Observable,v=d.prototype,y=n.CompositeDisposable,b=n.AnonymousObservable,m=n.Disposable.empty,g=(n.internals.isEqual,n.helpers),w=g.not,x=g.defaultComparer,_=g.identity,S=g.defaultSubComparer,E=g.isFunction,C=g.isPromise,A=g.isArrayLike,N=g.isIterable,k=n.internals.inherits,O=d.fromPromise,P=d.from,j=n.internals.bindCallback,D=n.EmptyError,q=n.ObservableBase,R=n.ArgumentOutOfRangeError,M={e:{}};v.aggregate=function(){var t,e,n=!1,r=this;return 2===arguments.length?(n=!0,e=arguments[0],t=arguments[1]):t=arguments[0],new b(function(o){var i,s,u;return r.subscribe(function(r){!u&&(u=!0);try{i?s=t(s,r):(s=n?t(e,r):r,i=!0)}catch(a){return o.onError(a)}},function(t){o.onError(t)},function(){u&&o.onNext(s),!u&&n&&o.onNext(e),!u&&!n&&o.onError(new D),o.onCompleted()})},r)};var T=function(t){function e(e,n,r,o){this.source=e,this.acc=n,this.hasSeed=r,this.seed=o,t.call(this)}function n(t,e){this.o=t,this.acc=e.acc,this.hasSeed=e.hasSeed,this.seed=e.seed,this.hasAccumulation=!1,this.result=null,this.hasValue=!1,this.isStopped=!1}return k(e,t),e.prototype.subscribeCore=function(t){return this.source.subscribe(new n(t,this))},n.prototype.onNext=function(t){this.isStopped||(!this.hasValue&&(this.hasValue=!0),this.hasAccumulation?this.result=i(this.acc)(this.result,t):(this.result=this.hasSeed?i(this.acc)(this.seed,t):t,this.hasAccumulation=!0),this.result===M&&this.o.onError(this.result.e))},n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.hasValue&&this.o.onNext(this.result),!this.hasValue&&this.hasSeed&&this.o.onNext(this.seed),!this.hasValue&&!this.hasSeed&&this.o.onError(new D),this.o.onCompleted())},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(q);return v.reduce=function(t){var e=!1;if(2===arguments.length){e=!0;var n=arguments[1]}return new T(this,t,e,n)},v.some=function(t,e){var n=this;return t?n.filter(t,e).some():new b(function(t){return n.subscribe(function(){t.onNext(!0),t.onCompleted()},function(e){t.onError(e)},function(){t.onNext(!1),t.onCompleted()})},n)},v.any=function(){return this.some.apply(this,arguments)},v.isEmpty=function(){return this.any().map(w)},v.every=function(t,e){return this.filter(function(e){return!t(e)},e).some().map(w)},v.all=function(){return this.every.apply(this,arguments)},v.includes=function(t,e){function n(t,e){return 0===t&&0===e||t===e||isNaN(t)&&isNaN(e)}var r=this;return new b(function(o){var i=0,s=+e||0;return Math.abs(s)===1/0&&(s=0),0>s?(o.onNext(!1),o.onCompleted(),m):r.subscribe(function(e){i++>=s&&n(e,t)&&(o.onNext(!0),o.onCompleted())},function(t){o.onError(t)},function(){o.onNext(!1),o.onCompleted()})},this)},v.contains=function(t,e){v.includes(t,e)},v.count=function(t,e){return t?this.filter(t,e).count():this.reduce(function(t){return t+1},0)},v.indexOf=function(t,e){var n=this;return new b(function(r){var o=0,i=+e||0;return Math.abs(i)===1/0&&(i=0),0>i?(r.onNext(-1),r.onCompleted(),m):n.subscribe(function(e){o>=i&&e===t&&(r.onNext(o),r.onCompleted()),o++},function(t){r.onError(t)},function(){r.onNext(-1),r.onCompleted()})},n)},v.sum=function(t,e){return t&&E(t)?this.map(t,e).sum():this.reduce(function(t,e){return t+e},0)},v.minBy=function(t,e){return e||(e=S),s(this,t,function(t,n){return-1*e(t,n)})},v.min=function(t){return this.minBy(_,t).map(function(t){return u(t)})},v.maxBy=function(t,e){return e||(e=S),s(this,t,e)},v.max=function(t){return this.maxBy(_,t).map(function(t){return u(t)})},v.average=function(t,e){return t&&E(t)?this.map(t,e).average():this.reduce(function(t,e){return{sum:t.sum+e,count:t.count+1}},{sum:0,count:0}).map(function(t){if(0===t.count)throw new D;return t.sum/t.count})},v.sequenceEqual=function(t,e){var n=this;return e||(e=x),new b(function(r){var o=!1,i=!1,s=[],u=[],a=n.subscribe(function(t){var n,o;if(u.length>0){o=u.shift();try{n=e(o,t)}catch(a){return void r.onError(a)}n||(r.onNext(!1),r.onCompleted())}else i?(r.onNext(!1),r.onCompleted()):s.push(t)},function(t){r.onError(t)},function(){o=!0,0===s.length&&(u.length>0?(r.onNext(!1),r.onCompleted()):i&&(r.onNext(!0),r.onCompleted()))});(A(t)||N(t))&&(t=P(t)),C(t)&&(t=O(t));var c=t.subscribe(function(t){var n;if(s.length>0){var i=s.shift();try{n=e(i,t)}catch(a){return void r.onError(a)}n||(r.onNext(!1),r.onCompleted())}else o?(r.onNext(!1),r.onCompleted()):u.push(t)},function(t){r.onError(t)},function(){i=!0,0===u.length&&(s.length>0?(r.onNext(!1),r.onCompleted()):o&&(r.onNext(!0),r.onCompleted()))});return new y(a,c)},n)},v.elementAt=function(t){return a(this,t,!1)},v.elementAtOrDefault=function(t,e){return a(this,t,!0,e)},v.single=function(t,e){return t&&E(t)?this.where(t,e).single():c(this,!1)},v.singleOrDefault=function(t,e,n){return t&&E(t)?this.filter(t,n).singleOrDefault(null,e):c(this,!0,e)},v.first=function(t,e){return t?this.where(t,e).first():p(this,!1)},v.firstOrDefault=function(t,e,n){return t?this.where(t).firstOrDefault(null,e):p(this,!0,e)},v.last=function(t,e){return t?this.where(t,e).last():h(this,!1)},v.lastOrDefault=function(t,e,n){return t?this.where(t,n).lastOrDefault(null,e):h(this,!0,e)},v.find=function(t,e){return f(this,t,e,!1)},v.findIndex=function(t,e){return f(this,t,e,!0)},v.toSet=function(){if("undefined"==typeof t.Set)throw new TypeError;var e=this;return new b(function(n){var r=new t.Set;return e.subscribe(function(t){r.add(t)},function(t){n.onError(t)},function(){n.onNext(r),n.onCompleted()})},e)},v.toMap=function(e,n){if("undefined"==typeof t.Map)throw new TypeError;var r=this;return new b(function(o){var i=new t.Map;return r.subscribe(function(t){var r;try{r=e(t)}catch(s){return void o.onError(s)}var u=t;if(n)try{u=n(t)}catch(s){return void o.onError(s)}i.set(r,u)},function(t){o.onError(t)},function(){o.onNext(i),o.onCompleted()})},r)},n})}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{159:159}],159:[function(e,n,r){(function(e,o){(function(i){function u(t){for(var e=[],n=0,r=t.length;r>n;n++)e.push(t[n]);return e}function a(t,e){if(ct&&e.stack&&"object"==typeof t&&null!==t&&t.stack&&-1===t.stack.indexOf(lt)){for(var n=[],r=e;r;r=r.source)r.stack&&n.unshift(r.stack);n.unshift(t.stack);var o=n.join("\n"+lt+"\n");t.stack=c(o)}}function c(t){for(var e=t.split("\n"),n=[],r=0,o=e.length;o>r;r++){var i=e[r];p(i)||h(i)||!i||n.push(i)}return n.join("\n")}function p(t){var e=l(t);if(!e)return!1;var n=e[0],r=e[1];return n===ht&&r>=ft&&$n>=r}function h(t){return-1!==t.indexOf("(module.js:")||-1!==t.indexOf("(node.js:")}function f(){if(ct)try{throw new Error}catch(t){var e=t.stack.split("\n"),n=e[0].indexOf("@")>0?e[1]:e[2],r=l(n);if(!r)return;return ht=r[0],r[1]}}function l(t){var e=/at .+ \((.+):(\d+):(?:\d+)\)$/.exec(t);if(e)return[e[1],Number(e[2])];var n=/at ([^ ]+):(\d+):(?:\d+)$/.exec(t);if(n)return[n[1],Number(n[2])];var r=/.*@(.+):(\d+)$/.exec(t);return r?[r[1],Number(r[2])]:void 0}function d(t){var e=[];if(!Ht(t))return e;Ut.nonEnumArgs&&t.length&&Xt(t)&&(t=Yt.call(t));var n=Ut.enumPrototypes&&"function"==typeof t,r=Ut.enumErrorProps&&(t===Jt||t instanceof Error);for(var o in t)n&&"prototype"==o||r&&("message"==o||"name"==o)||e.push(o);if(Ut.nonEnumShadows&&t!==It){var i=t.constructor,s=-1,u=kt;if(t===(i&&i.prototype))var a=t===Lt?$t:t===Jt?qt:Wt.call(t),c=Ft[a];for(;++s<u;)o=Nt[s],c&&c[o]||!zt.call(t,o)||e.push(o)}return e}function v(t,e,n){for(var r=-1,o=n(t),i=o.length;++r<i;){var s=o[r];if(e(t[s],s,t)===!1)break}return t}function y(t,e){return v(t,e,d)}function b(t){return"function"!=typeof t.toString&&"string"==typeof(t+"")}function m(t,e,n,r){if(t===e)return 0!==t||1/t==1/e;var o=typeof t,i=typeof e;if(t===t&&(null==t||null==e||"function"!=o&&"object"!=o&&"function"!=i&&"object"!=i))return!1;var s=Wt.call(t),u=Wt.call(e);if(s==Ot&&(s=Tt),u==Ot&&(u=Tt),s!=u)return!1;switch(s){case jt:case Dt:return+t==+e;case Mt:return t!=+t?e!=+e:0==t?1/t==1/e:t==+e;case Vt:case $t:return t==String(e)}var a=s==Pt;if(!a){if(s!=Tt||!Ut.nodeClass&&(b(t)||b(e)))return!1;var c=!Ut.argsObject&&Xt(t)?Object:t.constructor,p=!Ut.argsObject&&Xt(e)?Object:e.constructor;if(!(c==p||zt.call(t,"constructor")&&zt.call(e,"constructor")||at(c)&&c instanceof c&&at(p)&&p instanceof p||!("constructor"in t&&"constructor"in e)))return!1}n||(n=[]),r||(r=[]);for(var h=n.length;h--;)if(n[h]==t)return r[h]==e;var f=0,l=!0;if(n.push(t),r.push(e),a){if(h=t.length,f=e.length,l=f==h)for(;f--;){var d=e[f];if(!(l=m(t[f],d,n,r)))break}}else y(e,function(e,o,i){return zt.call(i,o)?(f++,l=zt.call(t,o)&&m(t[o],e,n,r)):void 0}),l&&y(t,function(t,e,n){return zt.call(n,e)?l=--f>-1:void 0});return n.pop(),r.pop(),l}function g(t,e){for(var n=new Array(t),r=0;t>r;r++)n[r]=e();return n}function w(){try{return Qt.apply(this,arguments)}catch(t){return ne.e=t,ne}}function x(t){if(!at(t))throw new TypeError("fn must be a function");return Qt=t,w}function _(t){throw t}function S(t,e){this.id=t,this.value=e}function E(t,e){this.scheduler=t,this.disposable=e,this.isDisposed=!1}function C(t,e){e.isDisposed||(e.isDisposed=!0,e.disposable.dispose())}function A(t){this._s=s}function N(t){this._s=s,this._l=s.length,this._i=0}function k(t){this._a=t}function O(t){this._a=t,this._l=q(t),this._i=0}function P(t){return"number"==typeof t&&X.isFinite(t)}function j(t){var e,n=t[xt];if(!n&&"string"==typeof t)return e=new A(t),e[xt]();if(!n&&t.length!==i)return e=new k(t),e[xt]();if(!n)throw new TypeError("Object is not iterable");return t[xt]()}function D(t){var e=+t;return 0===e?e:isNaN(e)?e:0>e?-1:1}function q(t){var e=+t.length;return isNaN(e)?0:0!==e&&P(e)?(e=D(e)*Math.floor(Math.abs(e)),0>=e?0:e>en?en:e):e}function R(t,e){this.observer=t,this.parent=e}function M(t,e){return me(t)||(t=_e),new rn(e,t)}function T(t,e){this.observer=t,this.parent=e}function V(t,e){this.observer=t,this.parent=e}function $(t,e){return new qn(function(n){var r=new fe,o=new le;return o.setDisposable(r),r.setDisposable(t.subscribe(function(t){n.onNext(t)},function(t){try{var r=e(t)}catch(i){return n.onError(i)}ut(r)&&(r=Xe(r));var s=new fe;o.setDisposable(s),s.setDisposable(r.subscribe(n))},function(t){n.onCompleted(t)})),o},t)}function W(){return!1}function z(t,e){var n=this;return new qn(function(r){var o=0,i=t.length;return n.subscribe(function(n){if(i>o){var s=t[o++],u=x(e)(n,s);if(u===ne)return r.onError(u.e);r.onNext(u)}else r.onCompleted()},function(t){r.onError(t)},function(){r.onCompleted()})},n)}function W(){return!1}function G(){return[]}function W(){return!1}function J(){return[]}function I(t,e){this.observer=t,this.accumulator=e.accumulator,this.hasSeed=e.hasSeed,this.seed=e.seed,this.hasAccumulation=!1,this.accumulation=null,this.hasValue=!1,this.isStopped=!1}function L(t,e,n){var r=At(e,n,3);return t.map(function(e,n){var o=r(e,n,t);return ut(o)&&(o=Xe(o)),(Et(o)||St(o))&&(o=nn(o)),o}).concatAll()}function B(t,e,n){for(var r=0,o=t.length;o>r;r++)if(n(t[r],e))return r;return-1}function F(t){this.comparer=t,this.set=[]}function U(t,e,n){var r=At(e,n,3);return t.map(function(e,n){var o=r(e,n,t);return ut(o)&&(o=Xe(o)),(Et(o)||St(o))&&(o=nn(o)),o}).mergeAll()}var H={"boolean":!1,"function":!0,object:!0,number:!1,string:!1,undefined:!1},X=H[typeof window]&&window||this,Q=H[typeof r]&&r&&!r.nodeType&&r,K=H[typeof n]&&n&&!n.nodeType&&n,Y=K&&K.exports===Q&&Q,Z=H[typeof o]&&o;!Z||Z.global!==Z&&Z.window!==Z||(X=Z);var tt={internals:{},config:{Promise:X.Promise},helpers:{}},et=tt.helpers.noop=function(){},nt=(tt.helpers.notDefined=function(t){return"undefined"==typeof t},tt.helpers.identity=function(t){return t}),rt=(tt.helpers.pluck=function(t){return function(e){return e[t]}},tt.helpers.just=function(t){return function(){return t}},tt.helpers.defaultNow=Date.now),ot=tt.helpers.defaultComparer=function(t,e){return Kt(t,e)},it=tt.helpers.defaultSubComparer=function(t,e){return t>e?1:e>t?-1:0},st=(tt.helpers.defaultKeySerializer=function(t){return t.toString()},tt.helpers.defaultError=function(t){throw t}),ut=tt.helpers.isPromise=function(t){return!!t&&"function"!=typeof t.subscribe&&"function"==typeof t.then},at=(tt.helpers.asArray=function(){return Array.prototype.slice.call(arguments)},tt.helpers.not=function(t){return!t},tt.helpers.isFunction=function(){var t=function(t){return"function"==typeof t||!1};return t(/x/)&&(t=function(t){return"function"==typeof t&&"[object Function]"==Wt.call(t)}),t}());tt.config.longStackSupport=!1;var ct=!1;try{throw new Error}catch(pt){ct=!!pt.stack}var ht,ft=f(),lt="From previous event:",dt=tt.EmptyError=function(){this.message="Sequence contains no elements.",Error.call(this)};dt.prototype=Error.prototype;var vt=tt.ObjectDisposedError=function(){this.message="Object has been disposed",Error.call(this)};vt.prototype=Error.prototype;var yt=tt.ArgumentOutOfRangeError=function(){this.message="Argument out of range",Error.call(this)};yt.prototype=Error.prototype;var bt=tt.NotSupportedError=function(t){this.message=t||"This operation is not supported",Error.call(this)};bt.prototype=Error.prototype;var mt=tt.NotImplementedError=function(t){this.message=t||"This operation is not implemented",Error.call(this)};mt.prototype=Error.prototype;var gt=tt.helpers.notImplemented=function(){throw new mt},wt=tt.helpers.notSupported=function(){throw new bt},xt="function"==typeof Symbol&&Symbol.iterator||"_es6shim_iterator_";X.Set&&"function"==typeof(new X.Set)["@@iterator"]&&(xt="@@iterator");var _t=tt.doneEnumerator={done:!0,value:i},St=tt.helpers.isIterable=function(t){return t[xt]!==i},Et=tt.helpers.isArrayLike=function(t){return t&&t.length!==i};tt.helpers.iterator=xt;var Ct,At=tt.internals.bindCallback=function(t,e,n){if("undefined"==typeof e)return t;switch(n){case 0:return function(){return t.call(e)};case 1:return function(n){return t.call(e,n)};case 2:return function(n,r){return t.call(e,n,r)};case 3:return function(n,r,o){return t.call(e,n,r,o)}}return function(){return t.apply(e,arguments)}},Nt=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],kt=Nt.length,Ot="[object Arguments]",Pt="[object Array]",jt="[object Boolean]",Dt="[object Date]",qt="[object Error]",Rt="[object Function]",Mt="[object Number]",Tt="[object Object]",Vt="[object RegExp]",$t="[object String]",Wt=Object.prototype.toString,zt=Object.prototype.hasOwnProperty,Gt=Wt.call(arguments)==Ot,Jt=Error.prototype,It=Object.prototype,Lt=String.prototype,Bt=It.propertyIsEnumerable;try{Ct=!(Wt.call(document)==Tt&&!({toString:0}+""))}catch(pt){Ct=!0}var Ft={};Ft[Pt]=Ft[Dt]=Ft[Mt]={constructor:!0,toLocaleString:!0,toString:!0,valueOf:!0},Ft[jt]=Ft[$t]={constructor:!0,toString:!0,valueOf:!0},Ft[qt]=Ft[Rt]=Ft[Vt]={constructor:!0,toString:!0},Ft[Tt]={constructor:!0};var Ut={};!function(){var t=function(){this.x=1},e=[];t.prototype={valueOf:1,y:1};for(var n in new t)e.push(n);for(n in arguments);Ut.enumErrorProps=Bt.call(Jt,"message")||Bt.call(Jt,"name"),Ut.enumPrototypes=Bt.call(t,"prototype"),Ut.nonEnumArgs=0!=n,Ut.nonEnumShadows=!/valueOf/.test(e)}(1);var Ht=tt.internals.isObject=function(t){var e=typeof t;return t&&("function"==e||"object"==e)||!1},Xt=function(t){return t&&"object"==typeof t?Wt.call(t)==Ot:!1};Gt||(Xt=function(t){return t&&"object"==typeof t?zt.call(t,"callee"):!1});var Qt,Kt=tt.internals.isEqual=function(t,e){return m(t,e,[],[])},Yt=({}.hasOwnProperty,Array.prototype.slice),Zt=this.inherits=tt.internals.inherits=function(t,e){function n(){this.constructor=t}n.prototype=e.prototype,t.prototype=new n},te=tt.internals.addProperties=function(t){for(var e=[],n=1,r=arguments.length;r>n;n++)e.push(arguments[n]);for(var o=0,i=e.length;i>o;o++){var s=e[o];for(var u in s)t[u]=s[u]}},ee=tt.internals.addRef=function(t,e){return new qn(function(n){return new ie(e.getDisposable(),t.subscribe(n))})},ne={e:{}};S.prototype.compareTo=function(t){var e=this.value.compareTo(t.value);return 0===e&&(e=this.id-t.id),e};var re=tt.internals.PriorityQueue=function(t){this.items=new Array(t),this.length=0},oe=re.prototype;oe.isHigherPriority=function(t,e){return this.items[t].compareTo(this.items[e])<0},oe.percolate=function(t){if(!(t>=this.length||0>t)){var e=t-1>>1;if(!(0>e||e===t)&&this.isHigherPriority(t,e)){var n=this.items[t];this.items[t]=this.items[e],this.items[e]=n,this.percolate(e)}}},oe.heapify=function(t){if(+t||(t=0),!(t>=this.length||0>t)){var e=2*t+1,n=2*t+2,r=t;if(e<this.length&&this.isHigherPriority(e,r)&&(r=e),n<this.length&&this.isHigherPriority(n,r)&&(r=n),r!==t){var o=this.items[t];this.items[t]=this.items[r],this.items[r]=o,this.heapify(r)}}},oe.peek=function(){return this.items[0].value},oe.removeAt=function(t){this.items[t]=this.items[--this.length],this.items[this.length]=i,this.heapify()},oe.dequeue=function(){var t=this.peek();return this.removeAt(0),t},oe.enqueue=function(t){var e=this.length++;this.items[e]=new S(re.count++,t),this.percolate(e)},oe.remove=function(t){for(var e=0;e<this.length;e++)if(this.items[e].value===t)return this.removeAt(e),!0;return!1},re.count=0;var ie=tt.CompositeDisposable=function(){var t,e,n=[];if(Array.isArray(arguments[0]))n=arguments[0],e=n.length;else for(e=arguments.length,n=new Array(e),t=0;e>t;t++)n[t]=arguments[t];for(t=0;e>t;t++)if(!pe(n[t]))throw new TypeError("Not a disposable");this.disposables=n,this.isDisposed=!1,this.length=n.length},se=ie.prototype;se.add=function(t){this.isDisposed?t.dispose():(this.disposables.push(t),this.length++)},se.remove=function(t){var e=!1;if(!this.isDisposed){var n=this.disposables.indexOf(t);-1!==n&&(e=!0,this.disposables.splice(n,1),this.length--,t.dispose())}return e},se.dispose=function(){
if(!this.isDisposed){this.isDisposed=!0;for(var t=this.disposables.length,e=new Array(t),n=0;t>n;n++)e[n]=this.disposables[n];for(this.disposables=[],this.length=0,n=0;t>n;n++)e[n].dispose()}};var ue=tt.Disposable=function(t){this.isDisposed=!1,this.action=t||et};ue.prototype.dispose=function(){this.isDisposed||(this.action(),this.isDisposed=!0)};var ae=ue.create=function(t){return new ue(t)},ce=ue.empty={dispose:et},pe=ue.isDisposable=function(t){return t&&at(t.dispose)},he=ue.checkDisposed=function(t){if(t.isDisposed)throw new vt},fe=tt.SingleAssignmentDisposable=function(){this.isDisposed=!1,this.current=null};fe.prototype.getDisposable=function(){return this.current},fe.prototype.setDisposable=function(t){if(this.current)throw new Error("Disposable has already been assigned");var e=this.isDisposed;!e&&(this.current=t),e&&t&&t.dispose()},fe.prototype.dispose=function(){if(!this.isDisposed){this.isDisposed=!0;var t=this.current;this.current=null}t&&t.dispose()};var le=tt.SerialDisposable=function(){this.isDisposed=!1,this.current=null};le.prototype.getDisposable=function(){return this.current},le.prototype.setDisposable=function(t){var e=this.isDisposed;if(!e){var n=this.current;this.current=t}n&&n.dispose(),e&&t&&t.dispose()},le.prototype.dispose=function(){if(!this.isDisposed){this.isDisposed=!0;var t=this.current;this.current=null}t&&t.dispose()};var de=tt.RefCountDisposable=function(){function t(t){this.disposable=t,this.disposable.count++,this.isInnerDisposed=!1}function e(t){this.underlyingDisposable=t,this.isDisposed=!1,this.isPrimaryDisposed=!1,this.count=0}return t.prototype.dispose=function(){this.disposable.isDisposed||this.isInnerDisposed||(this.isInnerDisposed=!0,this.disposable.count--,0===this.disposable.count&&this.disposable.isPrimaryDisposed&&(this.disposable.isDisposed=!0,this.disposable.underlyingDisposable.dispose()))},e.prototype.dispose=function(){this.isDisposed||this.isPrimaryDisposed||(this.isPrimaryDisposed=!0,0===this.count&&(this.isDisposed=!0,this.underlyingDisposable.dispose()))},e.prototype.getDisposable=function(){return this.isDisposed?ce:new t(this)},e}();E.prototype.dispose=function(){this.scheduler.scheduleWithState(this,C)};var ve=tt.internals.ScheduledItem=function(t,e,n,r,o){this.scheduler=t,this.state=e,this.action=n,this.dueTime=r,this.comparer=o||it,this.disposable=new fe};ve.prototype.invoke=function(){this.disposable.setDisposable(this.invokeCore())},ve.prototype.compareTo=function(t){return this.comparer(this.dueTime,t.dueTime)},ve.prototype.isCancelled=function(){return this.disposable.isDisposed},ve.prototype.invokeCore=function(){return this.action(this.scheduler,this.state)};var ye=tt.Scheduler=function(){function t(t,e,n,r){this.now=t,this._schedule=e,this._scheduleRelative=n,this._scheduleAbsolute=r}function e(t,e){return e(),ce}t.isScheduler=function(e){return e instanceof t};var n=t.prototype;return n.schedule=function(t){return this._schedule(t,e)},n.scheduleWithState=function(t,e){return this._schedule(t,e)},n.scheduleWithRelative=function(t,n){return this._scheduleRelative(n,t,e)},n.scheduleWithRelativeAndState=function(t,e,n){return this._scheduleRelative(t,e,n)},n.scheduleWithAbsolute=function(t,n){return this._scheduleAbsolute(n,t,e)},n.scheduleWithAbsoluteAndState=function(t,e,n){return this._scheduleAbsolute(t,e,n)},t.now=rt,t.normalize=function(t){return 0>t&&(t=0),t},t}(),be=ye.normalize,me=ye.isScheduler;!function(t){function e(t,e){function n(e){o(e,function(e){var r=!1,o=!1,s=t.scheduleWithState(e,function(t,e){return r?i.remove(s):o=!0,n(e),ce});o||(i.add(s),r=!0)})}var r=e[0],o=e[1],i=new ie;return n(r),i}function n(t,e,n){function r(e){i(e,function(e,o){var i=!1,u=!1,a=t[n](e,o,function(t,e){return i?s.remove(a):u=!0,r(e),ce});u||(s.add(a),i=!0)})}var o=e[0],i=e[1],s=new ie;return r(o),s}function r(t,e){t(function(n){e(t,n)})}t.scheduleRecursive=function(t){return this.scheduleRecursiveWithState(t,r)},t.scheduleRecursiveWithState=function(t,n){return this.scheduleWithState([t,n],e)},t.scheduleRecursiveWithRelative=function(t,e){return this.scheduleRecursiveWithRelativeAndState(e,t,r)},t.scheduleRecursiveWithRelativeAndState=function(t,e,r){return this._scheduleRelative([t,r],e,function(t,e){return n(t,e,"scheduleWithRelativeAndState")})},t.scheduleRecursiveWithAbsolute=function(t,e){return this.scheduleRecursiveWithAbsoluteAndState(e,t,r)},t.scheduleRecursiveWithAbsoluteAndState=function(t,e,r){return this._scheduleAbsolute([t,r],e,function(t,e){return n(t,e,"scheduleWithAbsoluteAndState")})}}(ye.prototype),function(t){ye.prototype.schedulePeriodic=function(t,e){return this.schedulePeriodicWithState(null,t,e)},ye.prototype.schedulePeriodicWithState=function(t,e,n){if("undefined"==typeof X.setInterval)throw new bt;e=be(e);var r=t,o=X.setInterval(function(){r=n(r)},e);return ae(function(){X.clearInterval(o)})}}(ye.prototype),function(t){t.catchError=t["catch"]=function(t){return new Ae(this,t)}}(ye.prototype);var ge,we,xe=(tt.internals.SchedulePeriodicRecursive=function(){function t(t,e){e(0,this._period);try{this._state=this._action(this._state)}catch(n){throw this._cancel.dispose(),n}}function e(t,e,n,r){this._scheduler=t,this._state=e,this._period=n,this._action=r}return e.prototype.start=function(){var e=new fe;return this._cancel=e,e.setDisposable(this._scheduler.scheduleRecursiveWithRelativeAndState(0,this._period,t.bind(this))),e},e}(),ye.immediate=function(){function t(t,e){return e(this,t)}return new ye(rt,t,wt,wt)}()),_e=ye.currentThread=function(){function t(){for(;n.length>0;){var t=n.dequeue();!t.isCancelled()&&t.invoke()}}function e(e,r){var o=new ve(this,e,r,this.now());if(n)n.enqueue(o);else{n=new re(4),n.enqueue(o);var i=x(t)();if(n=null,i===ne)return _(i.e)}return o.disposable}var n,r=new ye(rt,e,wt,wt);return r.scheduleRequired=function(){return!n},r}(),Se=function(){var t,e=et;if(X.setTimeout)t=X.setTimeout,e=X.clearTimeout;else{if(!X.WScript)throw new bt;t=function(t,e){X.WScript.Sleep(e),t()}}return{setTimeout:t,clearTimeout:e}}(),Ee=Se.setTimeout,Ce=Se.clearTimeout;!function(){function t(e){if(s)Ee(function(){t(e)},0);else{var n=i[e];if(n){s=!0;var r=x(n)();if(we(e),s=!1,r===ne)return _(r.e)}}}function n(){if(!X.postMessage||X.importScripts)return!1;var t=!1,e=X.onmessage;return X.onmessage=function(){t=!0},X.postMessage("","*"),X.onmessage=e,t}function r(e){"string"==typeof e.data&&e.data.substring(0,c.length)===c&&t(e.data.substring(c.length))}var o=1,i={},s=!1;we=function(t){delete i[t]};var u=RegExp("^"+String(Wt).replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/toString| for [^\]]+/g,".*?")+"$"),a="function"==typeof(a=Z&&Y&&Z.setImmediate)&&!u.test(a)&&a;if(at(a))ge=function(e){var n=o++;return i[n]=e,a(function(){t(n)}),n};else if("undefined"!=typeof e&&"[object process]"==={}.toString.call(e))ge=function(n){var r=o++;return i[r]=n,e.nextTick(function(){t(r)}),r};else if(n()){var c="ms.rx.schedule"+Math.random();X.addEventListener?X.addEventListener("message",r,!1):X.attachEvent?X.attachEvent("onmessage",r):X.onmessage=r,ge=function(t){var e=o++;return i[e]=t,X.postMessage(c+currentId,"*"),e}}else if(X.MessageChannel){var p=new X.MessageChannel;p.port1.onmessage=function(e){t(e.data)},ge=function(t){var e=o++;return i[e]=t,p.port2.postMessage(e),e}}else ge="document"in X&&"onreadystatechange"in X.document.createElement("script")?function(e){var n=X.document.createElement("script"),r=o++;return i[r]=e,n.onreadystatechange=function(){t(r),n.onreadystatechange=null,n.parentNode.removeChild(n),n=null},X.document.documentElement.appendChild(n),r}:function(e){var n=o++;return i[n]=e,Ee(function(){t(n)},0),n}}();var Ae=(ye.timeout=ye["default"]=function(){function t(t,e){var n=this,r=new fe,o=ge(function(){!r.isDisposed&&r.setDisposable(e(n,t))});return new ie(r,ae(function(){we(o)}))}function e(t,e,n){var r=this,o=ye.normalize(e),i=new fe;if(0===o)return r.scheduleWithState(t,n);var s=Ee(function(){!i.isDisposed&&i.setDisposable(n(r,t))},o);return new ie(i,ae(function(){Ce(s)}))}function n(t,e,n){return this.scheduleWithRelativeAndState(t,e-this.now(),n)}return new ye(rt,t,e,n)}(),function(t){function e(t,e){return this._scheduler.scheduleWithState(t,this._wrap(e))}function n(t,e,n){return this._scheduler.scheduleWithRelativeAndState(t,e,this._wrap(n))}function r(t,e,n){return this._scheduler.scheduleWithAbsoluteAndState(t,e,this._wrap(n))}function o(o,i){this._scheduler=o,this._handler=i,this._recursiveOriginal=null,this._recursiveWrapper=null,t.call(this,this._scheduler.now.bind(this._scheduler),e,n,r)}return Zt(o,t),o.prototype._clone=function(t){return new o(t,this._handler)},o.prototype._wrap=function(t){var e=this;return function(n,r){try{return t(e._getRecursiveWrapper(n),r)}catch(o){if(!e._handler(o))throw o;return ce}}},o.prototype._getRecursiveWrapper=function(t){if(this._recursiveOriginal!==t){this._recursiveOriginal=t;var e=this._clone(t);e._recursiveOriginal=t,e._recursiveWrapper=e,this._recursiveWrapper=e}return this._recursiveWrapper},o.prototype.schedulePeriodicWithState=function(t,e,n){var r=this,o=!1,i=new fe;return i.setDisposable(this._scheduler.schedulePeriodicWithState(t,e,function(t){if(o)return null;try{return n(t)}catch(e){if(o=!0,!r._handler(e))throw e;return i.dispose(),null}})),i},o}(ye)),Ne=tt.Notification=function(){function t(t,e,n,r,o,i){this.kind=t,this.value=e,this.exception=n,this._accept=r,this._acceptObservable=o,this.toString=i}return t.prototype.accept=function(t,e,n){return t&&"object"==typeof t?this._acceptObservable(t):this._accept(t,e,n)},t.prototype.toObservable=function(t){var e=this;return me(t)||(t=xe),new qn(function(n){return t.scheduleWithState(e,function(t,e){e._acceptObservable(n),"N"===e.kind&&n.onCompleted()})})},t}(),ke=Ne.createOnNext=function(){function t(t){return t(this.value)}function e(t){return t.onNext(this.value)}function n(){return"OnNext("+this.value+")"}return function(r){return new Ne("N",r,null,t,e,n)}}(),Oe=Ne.createOnError=function(){function t(t,e){return e(this.exception)}function e(t){return t.onError(this.exception)}function n(){return"OnError("+this.exception+")"}return function(r){return new Ne("E",null,r,t,e,n)}}(),Pe=Ne.createOnCompleted=function(){function t(t,e,n){return n()}function e(t){return t.onCompleted()}function n(){return"OnCompleted()"}return function(){return new Ne("C",null,null,t,e,n)}}(),je=tt.Observer=function(){};je.prototype.toNotifier=function(){var t=this;return function(e){return e.accept(t)}},je.prototype.asObserver=function(){return new Me(this.onNext.bind(this),this.onError.bind(this),this.onCompleted.bind(this))},je.prototype.checked=function(){return new Te(this)};var De=je.create=function(t,e,n){return t||(t=et),e||(e=st),n||(n=et),new Me(t,e,n)};je.fromNotifier=function(t,e){return new Me(function(n){return t.call(e,ke(n))},function(n){return t.call(e,Oe(n))},function(){return t.call(e,Pe())})},je.prototype.notifyOn=function(t){return new $e(t,this)},je.prototype.makeSafe=function(t){return new AnonymousSafeObserver(this._onNext,this._onError,this._onCompleted,t)};var qe,Re=tt.internals.AbstractObserver=function(t){function e(){this.isStopped=!1,t.call(this)}return Zt(e,t),e.prototype.next=gt,e.prototype.error=gt,e.prototype.completed=gt,e.prototype.onNext=function(t){this.isStopped||this.next(t)},e.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.error(t))},e.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.completed())},e.prototype.dispose=function(){this.isStopped=!0},e.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.error(t),!0)},e}(je),Me=tt.AnonymousObserver=function(t){function e(e,n,r){t.call(this),this._onNext=e,this._onError=n,this._onCompleted=r}return Zt(e,t),e.prototype.next=function(t){this._onNext(t)},e.prototype.error=function(t){this._onError(t)},e.prototype.completed=function(){this._onCompleted()},e}(Re),Te=function(t){function e(e){t.call(this),this._observer=e,this._state=0}Zt(e,t);var n=e.prototype;return n.onNext=function(t){this.checkAccess();var e=x(this._observer.onNext).call(this._observer,t);this._state=0,e===ne&&_(e.e)},n.onError=function(t){this.checkAccess();var e=x(this._observer.onError).call(this._observer,t);this._state=2,e===ne&&_(e.e)},n.onCompleted=function(){this.checkAccess();var t=x(this._observer.onCompleted).call(this._observer);this._state=2,t===ne&&_(t.e)},n.checkAccess=function(){if(1===this._state)throw new Error("Re-entrancy detected");if(2===this._state)throw new Error("Observer completed");0===this._state&&(this._state=1)},e}(je),Ve=tt.internals.ScheduledObserver=function(t){function e(e,n){t.call(this),this.scheduler=e,this.observer=n,this.isAcquired=!1,this.hasFaulted=!1,this.queue=[],this.disposable=new le}return Zt(e,t),e.prototype.next=function(t){var e=this;this.queue.push(function(){e.observer.onNext(t)})},e.prototype.error=function(t){var e=this;this.queue.push(function(){e.observer.onError(t)})},e.prototype.completed=function(){var t=this;this.queue.push(function(){t.observer.onCompleted()})},e.prototype.ensureActive=function(){var t=!1,e=this;!this.hasFaulted&&this.queue.length>0&&(t=!this.isAcquired,this.isAcquired=!0),t&&this.disposable.setDisposable(this.scheduler.scheduleRecursive(function(t){var n;if(!(e.queue.length>0))return void(e.isAcquired=!1);n=e.queue.shift();try{n()}catch(r){throw e.queue=[],e.hasFaulted=!0,r}t()}))},e.prototype.dispose=function(){t.prototype.dispose.call(this),this.disposable.dispose()},e}(Re),$e=function(t){function e(e,n,r){t.call(this,e,n),this._cancel=r}return Zt(e,t),e.prototype.next=function(e){t.prototype.next.call(this,e),this.ensureActive()},e.prototype.error=function(e){t.prototype.error.call(this,e),this.ensureActive()},e.prototype.completed=function(){t.prototype.completed.call(this),this.ensureActive()},e.prototype.dispose=function(){t.prototype.dispose.call(this),this._cancel&&this._cancel.dispose(),this._cancel=null},e}(Ve),We=tt.Observable=function(){function t(t){if(tt.config.longStackSupport&&ct){try{throw new Error}catch(e){this.stack=e.stack.substring(e.stack.indexOf("\n")+1)}var n=this;this._subscribe=function(e){var r=e.onError.bind(e);return e.onError=function(t){a(t,n),r(t)},t.call(n,e)}}else this._subscribe=t}return qe=t.prototype,qe.subscribe=qe.forEach=function(t,e,n){return this._subscribe("object"==typeof t?t:De(t,e,n))},qe.subscribeOnNext=function(t,e){return this._subscribe(De("undefined"!=typeof e?function(n){t.call(e,n)}:t))},qe.subscribeOnError=function(t,e){return this._subscribe(De(null,"undefined"!=typeof e?function(n){t.call(e,n)}:t))},qe.subscribeOnCompleted=function(t,e){return this._subscribe(De(null,null,"undefined"!=typeof e?function(){t.call(e)}:t))},t}(),ze=tt.ObservableBase=function(t){function e(t){return t&&at(t.dispose)?t:at(t)?ae(t):ce}function n(t,n){var r=n[0],o=n[1],i=x(o.subscribeCore).call(o,r);return i!==ne||r.fail(ne.e)?void r.setDisposable(e(i)):_(ne.e)}function r(t){var e=new Rn(t),r=[e,this];return _e.scheduleRequired()?_e.scheduleWithState(r,n):n(null,r),e}function o(){t.call(this,r)}return Zt(o,t),o.prototype.subscribeCore=gt,o}(We),Ge=tt.internals.Enumerable=function(){},Je=function(t){function e(e){this.sources=e,t.call(this)}function n(t,e,n){this.o=t,this.s=e,this.e=n,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){var e,r=new le,o=xe.scheduleRecursiveWithState(this.sources[xt](),function(o,i){if(!e){var s=x(o.next).call(o);if(s===ne)return t.onError(s.e);if(s.done)return t.onCompleted();var u=s.value;ut(u)&&(u=Xe(u));var a=new fe;r.setDisposable(a),a.setDisposable(u.subscribe(new n(t,i,o)))}});return new ie(r,o,ae(function(){e=!0}))},n.prototype.onNext=function(t){this.isStopped||this.o.onNext(t)},n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.s(this.e))},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(ze);Ge.prototype.concat=function(){return new Je(this)};var Ie=function(t){function e(e){this.sources=e,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e,n=this.sources[xt](),r=new le,o=xe.scheduleRecursiveWithState(null,function(o,i){if(!e){var s=x(n.next).call(n);if(s===ne)return t.onError(s.e);if(s.done)return null!==o?t.onError(o):t.onCompleted();var u=s.value;ut(u)&&(u=Xe(u));var a=new fe;r.setDisposable(a),a.setDisposable(u.subscribe(function(e){t.onNext(e)},i,function(){t.onCompleted()}))}});return new ie(r,o,ae(function(){e=!0}))},e}(ze);Ge.prototype.catchError=function(){return new Ie(this)},Ge.prototype.catchErrorWhen=function(t){var e=this;return new qn(function(n){var r,o,i=new Tn,s=new Tn,u=t(i),a=u.subscribe(s),c=e[xt](),p=new le,h=xe.scheduleRecursive(function(t){if(!r){var e=x(c.next).call(c);if(e===ne)return n.onError(e.e);if(e.done)return void(o?n.onError(o):n.onCompleted());var u=e.value;ut(u)&&(u=Xe(u));var a=new fe,h=new fe;p.setDisposable(new ie(h,a)),a.setDisposable(u.subscribe(function(t){n.onNext(t)},function(e){h.setDisposable(s.subscribe(t,function(t){n.onError(t)},function(){n.onCompleted()})),i.onNext(e)},function(){n.onCompleted()}))}});return new ie(a,p,h,ae(function(){r=!0}))})};var Le=function(t){function e(t,e){this.v=t,this.c=null==e?-1:e}function n(t){this.v=t.v,this.l=t.c}return Zt(e,t),e.prototype[xt]=function(){return new n(this)},n.prototype.next=function(){return 0===this.l?_t:(this.l>0&&this.l--,{done:!1,value:this.v})},e}(Ge),Be=Ge.repeat=function(t,e){return new Le(t,e)},Fe=function(t){function e(t,e,n){this.s=t,this.fn=e?At(e,n,3):null}function n(t){this.i=-1,this.s=t.s,this.l=this.s.length,this.fn=t.fn}return Zt(e,t),e.prototype[xt]=function(){return new n(this)},n.prototype.next=function(){return++this.i<this.l?{done:!1,value:this.fn?this.fn(this.s[this.i],this.i,this.s):this.s[this.i]}:_t},e}(Ge),Ue=Ge.of=function(t,e,n){return new Fe(t,e,n)};qe.observeOn=function(t){var e=this;return new qn(function(n){return e.subscribe(new $e(t,n))},e)},qe.subscribeOn=function(t){var e=this;return new qn(function(n){var r=new fe,o=new le;return o.setDisposable(r),r.setDisposable(t.schedule(function(){o.setDisposable(new E(t,e.subscribe(n)))})),o},e)};var He=function(t){function e(e){this.p=e,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){return this.p.then(function(e){t.onNext(e),t.onCompleted()},function(e){t.onError(e)}),ce},e}(ze),Xe=We.fromPromise=function(t){return new He(t)};qe.toPromise=function(t){if(t||(t=tt.config.Promise),!t)throw new bt("Promise type not provided nor in Rx.config.Promise");var e=this;return new t(function(t,n){var r,o=!1;e.subscribe(function(t){r=t,o=!0},n,function(){o&&t(r)})})};var Qe=function(t){function e(e){this.source=e,t.call(this)}function n(t){this.o=t,this.a=[],this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){return this.source.subscribe(new n(t))},n.prototype.onNext=function(t){this.isStopped||this.a.push(t)},n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.o.onNext(this.a),this.o.onCompleted())},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(ze);qe.toArray=function(){return new Qe(this)},We.create=We.createWithDisposable=function(t,e){return new qn(t,e)};var Ke=(We.defer=function(t){return new qn(function(e){var n;try{n=t()}catch(r){return dn(r).subscribe(e)}return ut(n)&&(n=Xe(n)),n.subscribe(e)})},function(t){function e(e){this.scheduler=e,t.call(this)}function n(t,e){this.observer=t,this.parent=e}function r(t,e){e.onCompleted()}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new n(t,this);return e.run()},n.prototype.run=function(){return this.parent.scheduler.scheduleWithState(this.observer,r)},e}(ze)),Ye=We.empty=function(t){return me(t)||(t=xe),new Ke(t)},Ze=function(t){function e(e,n,r){this.iterable=e,this.mapper=n,this.scheduler=r,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new tn(t,this);return e.run()},e}(ze),tn=function(){function t(t,e){this.observer=t,this.parent=e}return t.prototype.run=function(){function t(t,e){try{var i=n.next()}catch(s){return r.onError(s)}if(i.done)return r.onCompleted();var u=i.value;if(o)try{u=o(u,t)}catch(s){return r.onError(s)}r.onNext(u),e(t+1)}var e=Object(this.parent.iterable),n=j(e),r=this.observer,o=this.parent.mapper;return this.parent.scheduler.scheduleRecursiveWithState(0,t)},t}(),en=Math.pow(2,53)-1;A.prototype[xt]=function(){return new N(this._s)},N.prototype[xt]=function(){return this},N.prototype.next=function(){return this._i<this._l?{done:!1,value:this._s.charAt(this._i++)}:_t},k.prototype[xt]=function(){return new O(this._a)},O.prototype[xt]=function(){return this},O.prototype.next=function(){return this._i<this._l?{done:!1,value:this._a[this._i++]}:_t};var nn=We.from=function(t,e,n,r){if(null==t)throw new Error("iterable cannot be null.");if(e&&!at(e))throw new Error("mapFn when provided must be a function");if(e)var o=At(e,n,2);return me(r)||(r=_e),new Ze(t,o,r)},rn=function(t){function e(e,n){this.args=e,this.scheduler=n,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new R(t,this);return e.run()},e}(ze);R.prototype.run=function(){function t(t,o){r>t?(e.onNext(n[t]),o(t+1)):e.onCompleted()}var e=this.observer,n=this.parent.args,r=n.length;return this.parent.scheduler.scheduleRecursiveWithState(0,t)};var on=We.fromArray=function(t,e){return me(e)||(e=_e),new rn(t,e)};We.generate=function(t,e,n,r,o){return me(o)||(o=_e),new qn(function(i){var s=!0;return o.scheduleRecursiveWithState(t,function(t,o){var u,a;try{s?s=!1:t=n(t),u=e(t),u&&(a=r(t))}catch(c){return i.onError(c)}u?(i.onNext(a),o(t)):i.onCompleted()})})};var sn=function(t){function e(){t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){return ce},e}(ze),un=We.never=function(){return new sn};We.of=function(){for(var t=arguments.length,e=new Array(t),n=0;t>n;n++)e[n]=arguments[n];return new rn(e,_e)},We.ofWithScheduler=function(t){for(var e=arguments.length,n=new Array(e-1),r=1;e>r;r++)n[r-1]=arguments[r];return new rn(n,t)};var an=function(t){function e(e,n){this.obj=e,this.keys=Object.keys(e),this.scheduler=n,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new T(t,this);return e.run()},e}(ze);T.prototype.run=function(){function t(t,i){if(o>t){var s=r[t];e.onNext([s,n[s]]),i(t+1)}else e.onCompleted()}var e=this.observer,n=this.parent.obj,r=this.parent.keys,o=r.length;return this.parent.scheduler.scheduleRecursiveWithState(0,t)},We.pairs=function(t,e){return e||(e=_e),new an(t,e)};var cn=function(t){function e(e,n,r){this.start=e,this.rangeCount=n,this.scheduler=r,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new pn(t,this);return e.run()},e}(ze),pn=function(){function t(t,e){this.observer=t,this.parent=e}return t.prototype.run=function(){function t(t,o){n>t?(r.onNext(e+t),o(t+1)):r.onCompleted()}var e=this.parent.start,n=this.parent.rangeCount,r=this.observer;return this.parent.scheduler.scheduleRecursiveWithState(0,t)},t}();We.range=function(t,e,n){return me(n)||(n=_e),new cn(t,e,n)};var hn=function(t){function e(e,n,r){this.value=e,this.repeatCount=null==n?-1:n,this.scheduler=r,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new V(t,this);return e.run()},e}(ze);V.prototype.run=function(){function t(t,r){return(-1===t||t>0)&&(e.onNext(n),t>0&&t--),0===t?e.onCompleted():void r(t)}var e=this.observer,n=this.parent.value;return this.parent.scheduler.scheduleRecursiveWithState(this.parent.repeatCount,t)},We.repeat=function(t,e,n){return me(n)||(n=_e),new hn(t,e,n)};var fn=function(t){function e(e,n){this.value=e,this.scheduler=n,t.call(this)}function n(t,e){this.observer=t,this.parent=e}function r(t,e){var n=e[0],r=e[1];r.onNext(n),r.onCompleted()}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new n(t,this);return e.run()},n.prototype.run=function(){return this.parent.scheduler.scheduleWithState([this.parent.value,this.observer],r)},e}(ze),ln=(We["return"]=We.just=We.returnValue=function(t,e){return me(e)||(e=xe),new fn(t,e)},function(t){function e(e,n){this.error=e,this.scheduler=n,t.call(this)}function n(t,e){this.o=t,this.p=e}function r(t,e){var n=e[0],r=e[1];r.onError(n)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new n(t,this);return e.run()},n.prototype.run=function(){return this.p.scheduler.scheduleWithState([this.p.error,this.o],r)},e}(ze)),dn=We["throw"]=We.throwError=We.throwException=function(t,e){return me(e)||(e=xe),new ln(t,e)};We.using=function(t,e){return new qn(function(n){var r,o,i=ce;try{r=t(),r&&(i=r),o=e(r)}catch(s){return new ie(dn(s).subscribe(n),i)}return new ie(o.subscribe(n),i)})},qe.amb=function(t){var e=this;return new qn(function(n){function r(){i||(i=s,c.dispose())}function o(){i||(i=u,a.dispose())}var i,s="L",u="R",a=new fe,c=new fe;return ut(t)&&(t=Xe(t)),a.setDisposable(e.subscribe(function(t){r(),i===s&&n.onNext(t)},function(t){r(),i===s&&n.onError(t)},function(){r(),i===s&&n.onCompleted()})),c.setDisposable(t.subscribe(function(t){o(),i===u&&n.onNext(t)},function(t){o(),i===u&&n.onError(t)},function(){o(),i===u&&n.onCompleted()})),new ie(a,c)})},We.amb=function(){function t(t,e){return t.amb(e)}var e=un(),n=[];if(Array.isArray(arguments[0]))n=arguments[0];else for(var r=0,o=arguments.length;o>r;r++)n.push(arguments[r]);for(var r=0,o=n.length;o>r;r++)e=t(e,n[r]);return e},qe["catch"]=qe.catchError=qe.catchException=function(t){return"function"==typeof t?$(this,t):vn([this,t])};var vn=We.catchError=We["catch"]=We.catchException=function(){var t=[];if(Array.isArray(arguments[0]))t=arguments[0];else for(var e=0,n=arguments.length;n>e;e++)t.push(arguments[e]);return Ue(t).catchError()};qe.combineLatest=function(){for(var t=arguments.length,e=new Array(t),n=0;t>n;n++)e[n]=arguments[n];return Array.isArray(e[0])?e[0].unshift(this):e.unshift(this),yn.apply(this,e)};var yn=We.combineLatest=function(){for(var t=arguments.length,e=new Array(t),n=0;t>n;n++)e[n]=arguments[n];var r=e.pop();return Array.isArray(e[0])&&(e=e[0]),new qn(function(t){function n(e){if(u[e]=!0,a||(a=u.every(nt))){try{var n=r.apply(null,p)}catch(o){return t.onError(o)}t.onNext(n)}else c.filter(function(t,n){return n!==e}).every(nt)&&t.onCompleted()}function o(e){c[e]=!0,c.every(nt)&&t.onCompleted()}for(var i=e.length,s=function(){return!1},u=g(i,s),a=!1,c=g(i,s),p=new Array(i),h=new Array(i),f=0;i>f;f++)!function(r){var i=e[r],s=new fe;ut(i)&&(i=Xe(i)),s.setDisposable(i.subscribe(function(t){p[r]=t,n(r)},function(e){t.onError(e)},function(){o(r)})),h[r]=s}(f);return new ie(h)},this)};qe.concat=function(){for(var t=[],e=0,n=arguments.length;n>e;e++)t.push(arguments[e]);return t.unshift(this),mn.apply(null,t)};var bn=function(t){function e(e){this.sources=e,t.call(this)}function n(t,e){this.sources=t,this.o=e}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new n(this.sources,t);return e.run()},n.prototype.run=function(){var t,e=new le,n=this.sources,r=n.length,o=this.o,i=xe.scheduleRecursiveWithState(0,function(i,s){if(!t){if(i===r)return o.onCompleted();var u=n[i];ut(u)&&(u=Xe(u));var a=new fe;e.setDisposable(a),a.setDisposable(u.subscribe(function(t){o.onNext(t)},function(t){o.onError(t)},function(){s(i+1)}))}});return new ie(e,i,ae(function(){t=!0}))},e}(ze),mn=We.concat=function(){var t;if(Array.isArray(arguments[0]))t=arguments[0];else{t=new Array(arguments.length);for(var e=0,n=arguments.length;n>e;e++)t[e]=arguments[e]}return new bn(t)};qe.concatAll=qe.concatObservable=function(){return this.merge(1)};var gn=function(t){function e(e,n){this.source=e,this.maxConcurrent=n,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new ie;return e.add(this.source.subscribe(new wn(t,this.maxConcurrent,e))),e},e}(ze),wn=function(){function t(t,e,n){this.o=t,this.max=e,this.g=n,this.done=!1,this.q=[],this.activeCount=0,this.isStopped=!1}function e(t,e){this.parent=t,this.sad=e,this.isStopped=!1}return t.prototype.handleSubscribe=function(t){var n=new fe;this.g.add(n),ut(t)&&(t=Xe(t)),n.setDisposable(t.subscribe(new e(this,n)))},t.prototype.onNext=function(t){this.isStopped||(this.activeCount<this.max?(this.activeCount++,this.handleSubscribe(t)):this.q.push(t))},t.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},t.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.done=!0,0===this.activeCount&&this.o.onCompleted())},t.prototype.dispose=function(){this.isStopped=!0},t.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e.prototype.onNext=function(t){this.isStopped||this.parent.o.onNext(t)},e.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.parent.o.onError(t))},e.prototype.onCompleted=function(){if(!this.isStopped){this.isStopped=!0;var t=this.parent;t.g.remove(this.sad),t.q.length>0?t.handleSubscribe(t.q.shift()):(t.activeCount--,t.done&&0===t.activeCount&&t.o.onCompleted())}},e.prototype.dispose=function(){this.isStopped=!0},e.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.parent.o.onError(t),!0)},t}();qe.merge=function(t){return"number"!=typeof t?xn(this,t):new gn(this,t)};var xn=We.merge=function(){var t,e,n=[],r=arguments.length;if(arguments[0])if(me(arguments[0]))for(t=arguments[0],e=1;r>e;e++)n.push(arguments[e]);else for(t=xe,e=0;r>e;e++)n.push(arguments[e]);else for(t=xe,e=1;r>e;e++)n.push(arguments[e]);return Array.isArray(n[0])&&(n=n[0]),M(t,n).mergeAll()},_n=tt.CompositeError=function(t){this.name="NotImplementedError",this.innerErrors=t,this.message="This contains multiple errors. Check the innerErrors",Error.call(this)};_n.prototype=Error.prototype,We.mergeDelayError=function(){var t;if(Array.isArray(arguments[0]))t=arguments[0];else{var e=arguments.length;t=new Array(e);for(var n=0;e>n;n++)t[n]=arguments[n]}var r=M(null,t);return new qn(function(t){function e(){0===s.length?t.onCompleted():1===s.length?t.onError(s[0]):t.onError(new _n(s))}var n=new ie,o=new fe,i=!1,s=[];return n.add(o),o.setDisposable(r.subscribe(function(r){var o=new fe;n.add(o),ut(r)&&(r=Xe(r)),o.setDisposable(r.subscribe(function(e){t.onNext(e)},function(t){s.push(t),n.remove(o),i&&1===n.length&&e()},function(){n.remove(o),i&&1===n.length&&e()}))},function(t){s.push(t),i=!0,1===n.length&&e()},function(){i=!0,1===n.length&&e()})),n})};var Sn=function(t){function e(e){this.source=e,t.call(this)}function n(t,e){this.o=t,this.g=e,this.isStopped=!1,this.done=!1}function r(t,e,n){this.parent=t,this.g=e,this.sad=n,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new ie,r=new fe;return e.add(r),r.setDisposable(this.source.subscribe(new n(t,e))),e},n.prototype.onNext=function(t){if(!this.isStopped){var e=new fe;this.g.add(e),ut(t)&&(t=Xe(t)),e.setDisposable(t.subscribe(new r(this,this.g,e)))}},n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.done=!0,1===this.g.length&&this.o.onCompleted())},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},r.prototype.onNext=function(t){this.isStopped||this.parent.o.onNext(t)},r.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.parent.o.onError(t))},r.prototype.onCompleted=function(){if(!this.isStopped){var t=this.parent;this.isStopped=!0,t.g.remove(this.sad),t.done&&1===t.g.length&&t.o.onCompleted()}},r.prototype.dispose=function(){this.isStopped=!0},r.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.parent.o.onError(t),!0)},e}(ze);qe.mergeAll=qe.mergeObservable=function(){
return new Sn(this)},qe.onErrorResumeNext=function(t){if(!t)throw new Error("Second observable is required");return En([this,t])};var En=We.onErrorResumeNext=function(){var t=[];if(Array.isArray(arguments[0]))t=arguments[0];else for(var e=0,n=arguments.length;n>e;e++)t.push(arguments[e]);return new qn(function(e){var n=0,r=new le,o=xe.scheduleRecursive(function(o){var i,s;n<t.length?(i=t[n++],ut(i)&&(i=Xe(i)),s=new fe,r.setDisposable(s),s.setDisposable(i.subscribe(e.onNext.bind(e),o,o))):e.onCompleted()});return new ie(r,o)})};qe.skipUntil=function(t){var e=this;return new qn(function(n){var r=!1,o=new ie(e.subscribe(function(t){r&&n.onNext(t)},function(t){n.onError(t)},function(){r&&n.onCompleted()}));ut(t)&&(t=Xe(t));var i=new fe;return o.add(i),i.setDisposable(t.subscribe(function(){r=!0,i.dispose()},function(t){n.onError(t)},function(){i.dispose()})),o},e)};var Cn=function(t){function e(e){this.source=e,t.call(this)}function n(t,e){this.o=t,this.inner=e,this.stopped=!1,this.latest=0,this.hasLatest=!1,this.isStopped=!1}function r(t,e){this.parent=t,this.id=e,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new le,r=this.source.subscribe(new n(t,e));return new ie(r,e)},n.prototype.onNext=function(t){if(!this.isStopped){var e=new fe,n=++this.latest;this.hasLatest=!0,this.inner.setDisposable(e),ut(t)&&(t=Xe(t)),e.setDisposable(t.subscribe(new r(this,n)))}},n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.stopped=!0,!this.hasLatest&&this.o.onCompleted())},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},r.prototype.onNext=function(t){this.isStopped||this.parent.latest===this.id&&this.parent.o.onNext(t)},r.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.parent.latest===this.id&&this.parent.o.onError(t))},r.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.parent.latest===this.id&&(this.parent.hasLatest=!1,this.parent.isStopped&&this.parent.o.onCompleted()))},r.prototype.dispose=function(){this.isStopped=!0},r.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.parent.o.onError(t),!0)},e}(ze);qe["switch"]=qe.switchLatest=function(){return new Cn(this)};var An=function(t){function e(e,n){this.source=e,this.other=ut(n)?Xe(n):n,t.call(this)}function n(t){this.o=t,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){return new ie(this.source.subscribe(t),this.other.subscribe(new n(t)))},n.prototype.onNext=function(t){this.isStopped||this.o.onCompleted()},n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){!this.isStopped&&(this.isStopped=!0)},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(ze);qe.takeUntil=function(t){return new An(this,t)},qe.withLatestFrom=function(){for(var t=arguments.length,e=new Array(t),n=0;t>n;n++)e[n]=arguments[n];var r=e.pop(),o=this;return Array.isArray(e[0])&&(e=e[0]),new qn(function(t){for(var n=e.length,i=g(n,W),s=!1,u=new Array(n),a=new Array(n+1),c=0;n>c;c++)!function(n){var r=e[n],o=new fe;ut(r)&&(r=Xe(r)),o.setDisposable(r.subscribe(function(t){u[n]=t,i[n]=!0,s=i.every(nt)},function(e){t.onError(e)},et)),a[n]=o}(c);var p=new fe;return p.setDisposable(o.subscribe(function(e){var n=[e].concat(u);if(s){var o=x(r).apply(null,n);return o===ne?t.onError(o.e):void t.onNext(o)}},function(e){t.onError(e)},function(){t.onCompleted()})),a[n]=p,new ie(a)},this)},qe.zip=function(){if(Array.isArray(arguments[0]))return z.apply(this,arguments);for(var t=arguments.length,e=new Array(t),n=0;t>n;n++)e[n]=arguments[n];var r=this,o=e.pop();return e.unshift(r),new qn(function(t){for(var n=e.length,i=g(n,G),s=g(n,W),u=new Array(n),a=0;n>a;a++)!function(n){var a=e[n],c=new fe;ut(a)&&(a=Xe(a)),c.setDisposable(a.subscribe(function(e){if(i[n].push(e),i.every(function(t){return t.length>0})){var u=i.map(function(t){return t.shift()}),a=x(o).apply(r,u);if(a===ne)return t.onError(a.e);t.onNext(a)}else s.filter(function(t,e){return e!==n}).every(nt)&&t.onCompleted()},function(e){t.onError(e)},function(){s[n]=!0,s.every(nt)&&t.onCompleted()})),u[n]=c}(a);return new ie(u)},r)},We.zip=function(){for(var t=arguments.length,e=new Array(t),n=0;t>n;n++)e[n]=arguments[n];var r=e.shift();return r.zip.apply(r,e)},We.zipArray=function(){var t;if(Array.isArray(arguments[0]))t=arguments[0];else{var e=arguments.length;t=new Array(e);for(var n=0;e>n;n++)t[n]=arguments[n]}return new qn(function(e){for(var n=t.length,r=g(n,J),o=g(n,W),i=new Array(n),s=0;n>s;s++)!function(n){i[n]=new fe,i[n].setDisposable(t[n].subscribe(function(t){if(r[n].push(t),r.every(function(t){return t.length>0})){var i=r.map(function(t){return t.shift()});e.onNext(i)}else if(o.filter(function(t,e){return e!==n}).every(nt))return e.onCompleted()},function(t){e.onError(t)},function(){o[n]=!0,o.every(nt)&&e.onCompleted()}))}(s);return new ie(i)})},qe.asObservable=function(){var t=this;return new qn(function(e){return t.subscribe(e)},t)},qe.bufferWithCount=function(t,e){return"number"!=typeof e&&(e=t),this.windowWithCount(t,e).selectMany(function(t){return t.toArray()}).where(function(t){return t.length>0})},qe.dematerialize=function(){var t=this;return new qn(function(e){return t.subscribe(function(t){return t.accept(e)},function(t){e.onError(t)},function(){e.onCompleted()})},this)},qe.distinctUntilChanged=function(t,e){var n=this;return e||(e=ot),new qn(function(r){var o,i=!1;return n.subscribe(function(n){var s=n;if(t&&(s=x(t)(n),s===ne))return r.onError(s.e);if(i){var u=x(e)(o,s);if(u===ne)return r.onError(u.e)}i&&u||(i=!0,o=s,r.onNext(n))},function(t){r.onError(t)},function(){r.onCompleted()})},this)};var Nn=function(t){function e(e,n,r,o){this.source=e,this.t=!n||at(n)?De(n||et,r||et,o||et):n,t.call(this)}function n(t,e){this.o=t,this.t=e,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){return this.source.subscribe(new n(t,this.t))},n.prototype.onNext=function(t){if(!this.isStopped){var e=x(this.t.onNext).call(this.t,t);e===ne&&this.o.onError(e.e),this.o.onNext(t)}},n.prototype.onError=function(t){if(!this.isStopped){this.isStopped=!0;var e=x(this.t.onError).call(this.t,t);if(e===ne)return this.o.onError(e.e);this.o.onError(t)}},n.prototype.onCompleted=function(){if(!this.isStopped){this.isStopped=!0;var t=x(this.t.onCompleted).call(this.t);if(t===ne)return this.o.onError(t.e);this.o.onCompleted()}},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(ze);qe["do"]=qe.tap=qe.doAction=function(t,e,n){return new Nn(this,t,e,n)},qe.doOnNext=qe.tapOnNext=function(t,e){return this.tap("undefined"!=typeof e?function(n){t.call(e,n)}:t)},qe.doOnError=qe.tapOnError=function(t,e){return this.tap(et,"undefined"!=typeof e?function(n){t.call(e,n)}:t)},qe.doOnCompleted=qe.tapOnCompleted=function(t,e){return this.tap(et,null,"undefined"!=typeof e?function(){t.call(e)}:t)},qe["finally"]=qe.ensure=function(t){var e=this;return new qn(function(n){var r;try{r=e.subscribe(n)}catch(o){throw t(),o}return ae(function(){try{r.dispose()}catch(e){throw e}finally{t()}})},this)},qe.finallyAction=function(t){return this.ensure(t)};var kn=function(t){function e(e){this.source=e,t.call(this)}function n(t){this.o=t,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){return this.source.subscribe(new n(t))},n.prototype.onNext=et,n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.o.onCompleted())},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.observer.onError(t),!0)},e}(ze);qe.ignoreElements=function(){return new kn(this)},qe.materialize=function(){var t=this;return new qn(function(e){return t.subscribe(function(t){e.onNext(ke(t))},function(t){e.onNext(Oe(t)),e.onCompleted()},function(){e.onNext(Pe()),e.onCompleted()})},t)},qe.repeat=function(t){return Be(this,t).concat()},qe.retry=function(t){return Be(this,t).catchError()},qe.retryWhen=function(t){return Be(this).catchErrorWhen(t)};var On=function(t){function e(e,n,r,o){this.source=e,this.accumulator=n,this.hasSeed=r,this.seed=o,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){return this.source.subscribe(new I(t,this))},e}(ze);I.prototype.onNext=function(t){if(!this.isStopped){!this.hasValue&&(this.hasValue=!0);try{this.hasAccumulation?this.accumulation=this.accumulator(this.accumulation,t):(this.accumulation=this.hasSeed?this.accumulator(this.seed,t):t,this.hasAccumulation=!0)}catch(e){return this.observer.onError(e)}this.observer.onNext(this.accumulation)}},I.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.observer.onError(t))},I.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,!this.hasValue&&this.hasSeed&&this.observer.onNext(this.seed),this.observer.onCompleted())},I.prototype.dispose=function(){this.isStopped=!0},I.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.observer.onError(t),!0)},qe.scan=function(){var t,e,n=!1;return 2===arguments.length?(n=!0,t=arguments[0],e=arguments[1]):e=arguments[0],new On(this,e,n,t)},qe.skipLast=function(t){if(0>t)throw new yt;var e=this;return new qn(function(n){var r=[];return e.subscribe(function(e){r.push(e),r.length>t&&n.onNext(r.shift())},function(t){n.onError(t)},function(){n.onCompleted()})},e)},qe.startWith=function(){var t,e=0;arguments.length&&me(arguments[0])?(t=arguments[0],e=1):t=xe;for(var n=[],r=e,o=arguments.length;o>r;r++)n.push(arguments[r]);return Ue([on(n,t),this]).concat()},qe.takeLast=function(t){if(0>t)throw new yt;var e=this;return new qn(function(n){var r=[];return e.subscribe(function(e){r.push(e),r.length>t&&r.shift()},function(t){n.onError(t)},function(){for(;r.length>0;)n.onNext(r.shift());n.onCompleted()})},e)},qe.takeLastBuffer=function(t){var e=this;return new qn(function(n){var r=[];return e.subscribe(function(e){r.push(e),r.length>t&&r.shift()},function(t){n.onError(t)},function(){n.onNext(r),n.onCompleted()})},e)},qe.windowWithCount=function(t,e){var n=this;if(+t||(t=0),Math.abs(t)===1/0&&(t=0),0>=t)throw new yt;if(null==e&&(e=t),+e||(e=0),Math.abs(e)===1/0&&(e=0),0>=e)throw new yt;return new qn(function(r){function o(){var t=new Tn;a.push(t),r.onNext(ee(t,s))}var i=new fe,s=new de(i),u=0,a=[];return o(),i.setDisposable(n.subscribe(function(n){for(var r=0,i=a.length;i>r;r++)a[r].onNext(n);var s=u-t+1;s>=0&&s%e===0&&a.shift().onCompleted(),++u%e===0&&o()},function(t){for(;a.length>0;)a.shift().onError(t);r.onError(t)},function(){for(;a.length>0;)a.shift().onCompleted();r.onCompleted()})),s},n)},qe.selectConcat=qe.concatMap=function(t,e,n){return at(t)&&at(e)?this.concatMap(function(n,r){var o=t(n,r);return ut(o)&&(o=Xe(o)),(Et(o)||St(o))&&(o=nn(o)),o.map(function(t,o){return e(n,t,r,o)})}):at(t)?L(this,t,n):L(this,function(){return t})},qe.concatMapObserver=qe.selectConcatObserver=function(t,e,n,r){var o=this,i=At(t,r,2),s=At(e,r,1),u=At(n,r,0);return new qn(function(t){var e=0;return o.subscribe(function(n){var r;try{r=i(n,e++)}catch(o){return void t.onError(o)}ut(r)&&(r=Xe(r)),t.onNext(r)},function(e){var n;try{n=s(e)}catch(r){return void t.onError(r)}ut(n)&&(n=Xe(n)),t.onNext(n),t.onCompleted()},function(){var e;try{e=u()}catch(n){return void t.onError(n)}ut(e)&&(e=Xe(e)),t.onNext(e),t.onCompleted()})},this).concatAll()},qe.defaultIfEmpty=function(t){var e=this;return t===i&&(t=null),new qn(function(n){var r=!1;return e.subscribe(function(t){r=!0,n.onNext(t)},function(t){n.onError(t)},function(){!r&&n.onNext(t),n.onCompleted()})},e)},F.prototype.push=function(t){var e=-1===B(this.set,t,this.comparer);return e&&this.set.push(t),e},qe.distinct=function(t,e){var n=this;return e||(e=ot),new qn(function(r){var o=new F(e);return n.subscribe(function(e){var n=e;if(t)try{n=t(e)}catch(i){return void r.onError(i)}o.push(n)&&r.onNext(e)},function(t){r.onError(t)},function(){r.onCompleted()})},this)};var Pn=function(t){function e(e,n,r){this.source=e,this.selector=At(n,r,3),t.call(this)}function n(t,e){return function(n,r,o){return t.call(this,e.selector(n,r,o),r,o)}}function r(t,e,n){this.o=t,this.selector=e,this.source=n,this.i=0,this.isStopped=!1}return Zt(e,t),e.prototype.internalMap=function(t,r){return new e(this.source,n(t,this),r)},e.prototype.subscribeCore=function(t){return this.source.subscribe(new r(t,this.selector,this))},r.prototype.onNext=function(t){if(!this.isStopped){var e=x(this.selector)(t,this.i++,this.source);return e===ne?this.o.onError(e.e):void this.o.onNext(e)}},r.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},r.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.o.onCompleted())},r.prototype.dispose=function(){this.isStopped=!0},r.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(ze);qe.map=qe.select=function(t,e){var n="function"==typeof t?t:function(){return t};return this instanceof Pn?this.internalMap(n,e):new Pn(this,n,e)},qe.pluck=function(){var t=arguments,e=arguments.length;if(0===e)throw new Error("List of properties cannot be empty.");return this.map(function(n){for(var r=n,o=0;e>o;o++){var s=r[t[o]];if("undefined"==typeof s)return i;r=s}return r})},qe.flatMapObserver=qe.selectManyObserver=function(t,e,n,r){var o=this;return new qn(function(i){var s=0;return o.subscribe(function(e){var n;try{n=t.call(r,e,s++)}catch(o){return void i.onError(o)}ut(n)&&(n=Xe(n)),i.onNext(n)},function(t){var n;try{n=e.call(r,t)}catch(o){return void i.onError(o)}ut(n)&&(n=Xe(n)),i.onNext(n),i.onCompleted()},function(){var t;try{t=n.call(r)}catch(e){return void i.onError(e)}ut(t)&&(t=Xe(t)),i.onNext(t),i.onCompleted()})},o).mergeAll()},qe.selectMany=qe.flatMap=function(t,e,n){return at(t)&&at(e)?this.flatMap(function(n,r){var o=t(n,r);return ut(o)&&(o=Xe(o)),(Et(o)||St(o))&&(o=nn(o)),o.map(function(t,o){return e(n,t,r,o)})},n):at(t)?U(this,t,n):U(this,function(){return t})},qe.selectSwitch=qe.flatMapLatest=qe.switchMap=function(t,e){return this.select(t,e).switchLatest()};var jn=function(t){function e(e,n){this.source=e,this.skipCount=n,t.call(this)}function n(t,e){this.c=e,this.r=e,this.o=t,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){return this.source.subscribe(new n(t,this.skipCount))},n.prototype.onNext=function(t){this.isStopped||(this.r<=0?this.o.onNext(t):this.r--)},n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.o.onCompleted())},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(ze);qe.skip=function(t){if(0>t)throw new yt;return new jn(this,t)},qe.skipWhile=function(t,e){var n=this,r=At(t,e,3);return new qn(function(t){var e=0,o=!1;return n.subscribe(function(i){if(!o)try{o=!r(i,e++,n)}catch(s){return void t.onError(s)}o&&t.onNext(i)},function(e){t.onError(e)},function(){t.onCompleted()})},n)},qe.take=function(t,e){if(0>t)throw new yt;if(0===t)return Ye(e);var n=this;return new qn(function(e){var r=t;return n.subscribe(function(t){r-- >0&&(e.onNext(t),0>=r&&e.onCompleted())},function(t){e.onError(t)},function(){e.onCompleted()})},n)},qe.takeWhile=function(t,e){var n=this,r=At(t,e,3);return new qn(function(t){var e=0,o=!0;return n.subscribe(function(i){if(o){try{o=r(i,e++,n)}catch(s){return void t.onError(s)}o?t.onNext(i):t.onCompleted()}},function(e){t.onError(e)},function(){t.onCompleted()})},n)};var Dn=function(t){function e(e,n,r){this.source=e,this.predicate=At(n,r,3),t.call(this)}function n(t,e){return function(n,r,o){return e.predicate(n,r,o)&&t.call(this,n,r,o)}}function r(t,e,n){this.o=t,this.predicate=e,this.source=n,this.i=0,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){return this.source.subscribe(new r(t,this.predicate,this))},e.prototype.internalFilter=function(t,r){return new e(this.source,n(t,this),r)},r.prototype.onNext=function(t){if(!this.isStopped){var e=x(this.predicate)(t,this.i++,this.source);return e===ne?this.o.onError(e.e):void(e&&this.o.onNext(t))}},r.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},r.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.o.onCompleted())},r.prototype.dispose=function(){this.isStopped=!0},r.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(ze);qe.filter=qe.where=function(t,e){return this instanceof Dn?this.internalFilter(t,e):new Dn(this,t,e)},qe.transduce=function(t){function e(t){return{"@@transducer/init":function(){return t},"@@transducer/step":function(t,e){return t.onNext(e)},"@@transducer/result":function(t){return t.onCompleted()}}}var n=this;return new qn(function(r){var o=t(e(r));return n.subscribe(function(t){try{o["@@transducer/step"](r,t)}catch(e){r.onError(e)}},function(t){r.onError(t)},function(){o["@@transducer/result"](r)})},n)};var qn=tt.AnonymousObservable=function(t){function e(t){return t&&at(t.dispose)?t:at(t)?ae(t):ce}function n(t,n){var r=n[0],o=n[1],i=x(o)(r);return i!==ne||r.fail(ne.e)?void r.setDisposable(e(i)):_(ne.e)}function r(e,r){function o(t){var r=new Rn(t),o=[r,e];return _e.scheduleRequired()?_e.scheduleWithState(o,n):n(null,o),r}this.source=r,t.call(this,o)}return Zt(r,t),r}(We),Rn=function(t){function e(e){t.call(this),this.observer=e,this.m=new fe}Zt(e,t);var n=e.prototype;return n.next=function(t){var e=x(this.observer.onNext).call(this.observer,t);e===ne&&(this.dispose(),_(e.e))},n.error=function(t){var e=x(this.observer.onError).call(this.observer,t);this.dispose(),e===ne&&_(e.e)},n.completed=function(){var t=x(this.observer.onCompleted).call(this.observer);this.dispose(),t===ne&&_(t.e)},n.setDisposable=function(t){this.m.setDisposable(t)},n.getDisposable=function(){return this.m.getDisposable()},n.dispose=function(){t.prototype.dispose.call(this),this.m.dispose()},e}(Re),Mn=function(t,e){this.subject=t,this.observer=e};Mn.prototype.dispose=function(){if(!this.subject.isDisposed&&null!==this.observer){var t=this.subject.observers.indexOf(this.observer);this.subject.observers.splice(t,1),this.observer=null}};var Tn=tt.Subject=function(t){function e(t){return he(this),this.isStopped?this.hasError?(t.onError(this.error),ce):(t.onCompleted(),ce):(this.observers.push(t),new Mn(this,t))}function n(){t.call(this,e),this.isDisposed=!1,this.isStopped=!1,this.observers=[],this.hasError=!1}return Zt(n,t),te(n.prototype,je.prototype,{hasObservers:function(){return this.observers.length>0},onCompleted:function(){if(he(this),!this.isStopped){this.isStopped=!0;for(var t=0,e=u(this.observers),n=e.length;n>t;t++)e[t].onCompleted();this.observers.length=0}},onError:function(t){if(he(this),!this.isStopped){this.isStopped=!0,this.error=t,this.hasError=!0;for(var e=0,n=u(this.observers),r=n.length;r>e;e++)n[e].onError(t);this.observers.length=0}},onNext:function(t){if(he(this),!this.isStopped)for(var e=0,n=u(this.observers),r=n.length;r>e;e++)n[e].onNext(t)},dispose:function(){this.isDisposed=!0,this.observers=null}}),n.create=function(t,e){return new Vn(t,e)},n}(We),Vn=(tt.AsyncSubject=function(t){function e(t){return he(this),this.isStopped?(this.hasError?t.onError(this.error):this.hasValue?(t.onNext(this.value),t.onCompleted()):t.onCompleted(),ce):(this.observers.push(t),new Mn(this,t))}function n(){t.call(this,e),this.isDisposed=!1,this.isStopped=!1,this.hasValue=!1,this.observers=[],this.hasError=!1}return Zt(n,t),te(n.prototype,je,{hasObservers:function(){return he(this),this.observers.length>0},onCompleted:function(){var t,e;if(he(this),!this.isStopped){this.isStopped=!0;var n=u(this.observers),e=n.length;if(this.hasValue)for(t=0;e>t;t++){var r=n[t];r.onNext(this.value),r.onCompleted()}else for(t=0;e>t;t++)n[t].onCompleted();this.observers.length=0}},onError:function(t){if(he(this),!this.isStopped){this.isStopped=!0,this.hasError=!0,this.error=t;for(var e=0,n=u(this.observers),r=n.length;r>e;e++)n[e].onError(t);this.observers.length=0}},onNext:function(t){he(this),this.isStopped||(this.value=t,this.hasValue=!0)},dispose:function(){this.isDisposed=!0,this.observers=null,this.exception=null,this.value=null}}),n}(We),tt.AnonymousSubject=function(t){function e(t){return this.observable.subscribe(t)}function n(n,r){this.observer=n,this.observable=r,t.call(this,e)}return Zt(n,t),te(n.prototype,je.prototype,{onCompleted:function(){this.observer.onCompleted()},onError:function(t){this.observer.onError(t)},onNext:function(t){this.observer.onNext(t)}}),n}(We));"function"==typeof t&&"object"==typeof t.amd&&t.amd?(X.Rx=tt,t(function(){return tt})):Q&&K?Y?(K.exports=tt).Rx=tt:Q.Rx=tt:X.Rx=tt;var $n=f()}).call(this)}).call(this,e(150),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{150:150}]},{},[1])(1)});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],16:[function(require,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

var doccy;

if (typeof document !== 'undefined') {
    doccy = document;
} else {
    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }
}

module.exports = doccy;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"min-document":4}],17:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],18:[function(require,module,exports){
(function (global){
'use strict';

/*global window, global*/

var root = typeof window !== 'undefined' ?
    window : typeof global !== 'undefined' ?
    global : {};

module.exports = Individual;

function Individual(key, value) {
    if (key in root) {
        return root[key];
    }

    root[key] = value;

    return value;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
'use strict';

var Individual = require('./index.js');

module.exports = OneVersion;

function OneVersion(moduleName, version, defaultValue) {
    var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;
    var enforceKey = key + '_ENFORCE_SINGLETON';

    var versionValue = Individual(enforceKey, version);

    if (versionValue !== version) {
        throw new Error('Can only have one copy of ' +
            moduleName + '.\n' +
            'You already have version ' + versionValue +
            ' installed.\n' +
            'This means you cannot install version ' + version);
    }

    return Individual(key, defaultValue);
}

},{"./index.js":18}],20:[function(require,module,exports){
"use strict";

module.exports = function isObject(x) {
	return typeof x === "object" && x !== null;
};

},{}],21:[function(require,module,exports){
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/* Geohash encoding/decoding and associated functions   (c) Chris Veness 2014-2016 / MIT Licence  */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

'use strict';


/**
 * Geohash encode, decode, bounds, neighbours.
 *
 * @namespace
 */
var Geohash = {};

/* (Geohash-specific) Base32 map */
Geohash.base32 = '0123456789bcdefghjkmnpqrstuvwxyz';

/**
 * Encodes latitude/longitude to geohash, either to specified precision or to automatically
 * evaluated precision.
 *
 * @param   {number} lat - Latitude in degrees.
 * @param   {number} lon - Longitude in degrees.
 * @param   {number} [precision] - Number of characters in resulting geohash.
 * @returns {string} Geohash of supplied latitude/longitude.
 * @throws  Invalid geohash.
 *
 * @example
 *     var geohash = Geohash.encode(52.205, 0.119, 7); // geohash: 'u120fxw'
 */
Geohash.encode = function(lat, lon, precision) {
    // infer precision?
    if (typeof precision == 'undefined') {
        // refine geohash until it matches precision of supplied lat/lon
        for (var p=1; p<=12; p++) {
            var hash = Geohash.encode(lat, lon, p);
            var posn = Geohash.decode(hash);
            if (posn.lat==lat && posn.lon==lon) return hash;
        }
        precision = 12; // set to maximum
    }

    lat = Number(lat);
    lon = Number(lon);
    precision = Number(precision);

    if (isNaN(lat) || isNaN(lon) || isNaN(precision)) throw new Error('Invalid geohash');

    var idx = 0; // index into base32 map
    var bit = 0; // each char holds 5 bits
    var evenBit = true;
    var geohash = '';

    var latMin =  -90, latMax =  90;
    var lonMin = -180, lonMax = 180;

    while (geohash.length < precision) {
        if (evenBit) {
            // bisect E-W longitude
            var lonMid = (lonMin + lonMax) / 2;
            if (lon >= lonMid) {
                idx = idx*2 + 1;
                lonMin = lonMid;
            } else {
                idx = idx*2;
                lonMax = lonMid;
            }
        } else {
            // bisect N-S latitude
            var latMid = (latMin + latMax) / 2;
            if (lat >= latMid) {
                idx = idx*2 + 1;
                latMin = latMid;
            } else {
                idx = idx*2;
                latMax = latMid;
            }
        }
        evenBit = !evenBit;

        if (++bit == 5) {
            // 5 bits gives us a character: append it and start over
            geohash += Geohash.base32.charAt(idx);
            bit = 0;
            idx = 0;
        }
    }

    return geohash;
};


/**
 * Decode geohash to latitude/longitude (location is approximate centre of geohash cell,
 *     to reasonable precision).
 *
 * @param   {string} geohash - Geohash string to be converted to latitude/longitude.
 * @returns {{lat:number, lon:number}} (Center of) geohashed location.
 * @throws  Invalid geohash.
 *
 * @example
 *     var latlon = Geohash.decode('u120fxw'); // latlon: { lat: 52.205, lon: 0.1188 }
 */
Geohash.decode = function(geohash) {

    var bounds = Geohash.bounds(geohash); // <-- the hard work
    // now just determine the centre of the cell...

    var latMin = bounds.sw.lat, lonMin = bounds.sw.lon;
    var latMax = bounds.ne.lat, lonMax = bounds.ne.lon;

    // cell centre
    var lat = (latMin + latMax)/2;
    var lon = (lonMin + lonMax)/2;

    // round to close to centre without excessive precision: 2-log10() decimal places
    lat = lat.toFixed(Math.floor(2-Math.log(latMax-latMin)/Math.LN10));
    lon = lon.toFixed(Math.floor(2-Math.log(lonMax-lonMin)/Math.LN10));

    return { lat: Number(lat), lon: Number(lon) };
};


/**
 * Returns SW/NE latitude/longitude bounds of specified geohash.
 *
 * @param   {string} geohash - Cell that bounds are required of.
 * @returns {{sw: {lat: number, lon: number}, ne: {lat: number, lon: number}}}
 * @throws  Invalid geohash.
 */
Geohash.bounds = function(geohash) {
    if (geohash.length === 0) throw new Error('Invalid geohash');

    geohash = geohash.toLowerCase();

    var evenBit = true;
    var latMin =  -90, latMax =  90;
    var lonMin = -180, lonMax = 180;

    for (var i=0; i<geohash.length; i++) {
        var chr = geohash.charAt(i);
        var idx = Geohash.base32.indexOf(chr);
        if (idx == -1) throw new Error('Invalid geohash');

        for (var n=4; n>=0; n--) {
            var bitN = idx >> n & 1;
            if (evenBit) {
                // longitude
                var lonMid = (lonMin+lonMax) / 2;
                if (bitN == 1) {
                    lonMin = lonMid;
                } else {
                    lonMax = lonMid;
                }
            } else {
                // latitude
                var latMid = (latMin+latMax) / 2;
                if (bitN == 1) {
                    latMin = latMid;
                } else {
                    latMax = latMid;
                }
            }
            evenBit = !evenBit;
        }
    }

    var bounds = {
        sw: { lat: latMin, lon: lonMin },
        ne: { lat: latMax, lon: lonMax },
    };

    return bounds;
};


/**
 * Determines adjacent cell in given direction.
 *
 * @param   geohash - Cell to which adjacent cell is required.
 * @param   direction - Direction from geohash (N/S/E/W).
 * @returns {string} Geocode of adjacent cell.
 * @throws  Invalid geohash.
 */
Geohash.adjacent = function(geohash, direction) {
    // based on github.com/davetroy/geohash-js

    geohash = geohash.toLowerCase();
    direction = direction.toLowerCase();

    if (geohash.length === 0) throw new Error('Invalid geohash');
    if ('nsew'.indexOf(direction) == -1) throw new Error('Invalid direction');

    var neighbour = {
        n: [ 'p0r21436x8zb9dcf5h7kjnmqesgutwvy', 'bc01fg45238967deuvhjyznpkmstqrwx' ],
        s: [ '14365h7k9dcfesgujnmqp0r2twvyx8zb', '238967debc01fg45kmstqrwxuvhjyznp' ],
        e: [ 'bc01fg45238967deuvhjyznpkmstqrwx', 'p0r21436x8zb9dcf5h7kjnmqesgutwvy' ],
        w: [ '238967debc01fg45kmstqrwxuvhjyznp', '14365h7k9dcfesgujnmqp0r2twvyx8zb' ],
    };
    var border = {
        n: [ 'prxz',     'bcfguvyz' ],
        s: [ '028b',     '0145hjnp' ],
        e: [ 'bcfguvyz', 'prxz'     ],
        w: [ '0145hjnp', '028b'     ],
    };

    var lastCh = geohash.slice(-1);    // last character of hash
    var parent = geohash.slice(0, -1); // hash without last character

    var type = geohash.length % 2;

    // check for edge-cases which don't share common prefix
    if (border[direction][type].indexOf(lastCh) != -1 && parent !== '') {
        parent = Geohash.adjacent(parent, direction);
    }

    // append letter for direction to parent
    return parent + Geohash.base32.charAt(neighbour[direction][type].indexOf(lastCh));
};


/**
 * Returns all 8 adjacent cells to specified geohash.
 *
 * @param   {string} geohash - Geohash neighbours are required of.
 * @returns {{n,ne,e,se,s,sw,w,nw: string}}
 * @throws  Invalid geohash.
 */
Geohash.neighbours = function(geohash) {
    return {
        'n':  Geohash.adjacent(geohash, 'n'),
        'ne': Geohash.adjacent(Geohash.adjacent(geohash, 'n'), 'e'),
        'e':  Geohash.adjacent(geohash, 'e'),
        'se': Geohash.adjacent(Geohash.adjacent(geohash, 's'), 'e'),
        's':  Geohash.adjacent(geohash, 's'),
        'sw': Geohash.adjacent(Geohash.adjacent(geohash, 's'), 'w'),
        'w':  Geohash.adjacent(geohash, 'w'),
        'nw': Geohash.adjacent(Geohash.adjacent(geohash, 'n'), 'w'),
    };
};


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
if (typeof module != 'undefined' && module.exports) module.exports = Geohash; // CommonJS, node.js

},{}],22:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":6}],23:[function(require,module,exports){
'use strict';

module.exports = Pbf;

var ieee754 = require('ieee754');

function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            this.type = val & 0x7;
            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },

    readVarint: function(isSigned) {
        var buf = this.buf,
            val, b;

        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;
        b = buf[this.pos];   val |= (b & 0x0f) << 28;

        return readVarintRemainder(val, isSigned, this);
    },

    readVarint64: function() { // for compatibility with v2.0.1
        return this.readVarint(true);
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = readUtf8(this.buf, this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function(arr, isSigned) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readVarint(isSigned));
        return arr;
    },
    readPackedSVarint: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val || 0;

        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);

        this.pos++; // reserve 1 byte for short string length

        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(l, s, p) {
    var buf = p.buf,
        h, b;

    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);

    throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ?
        pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }

    return ((high >>> 0) * 0x100000000) + (low >>> 0);
}

function writeBigVarint(val, pbf) {
    var low, high;

    if (val >= 0) {
        low  = (val % 0x100000000) | 0;
        high = (val / 0x100000000) | 0;
    } else {
        low  = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);

        if (low ^ 0xffffffff) {
            low = (low + 1) | 0;
        } else {
            low = 0;
            high = (high + 1) | 0;
        }
    }

    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }

    pbf.realloc(10);

    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}

function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos]   = low & 0x7f;
}

function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 0x07) << 4;

    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f;
}

function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen =
        len <= 0x3fff ? 1 :
        len <= 0x1fffff ? 2 :
        len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
}

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

// Buffer code below from https://github.com/feross/buffer, MIT-licensed

function readUInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] * 0x1000000);
}

function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = (val >>> 8);
    buf[pos + 2] = (val >>> 16);
    buf[pos + 3] = (val >>> 24);
}

function readInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] << 24);
}

function readUtf8(buf, pos, end) {
    var str = '';
    var i = pos;

    while (i < end) {
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence =
            b0 > 0xEF ? 4 :
            b0 > 0xDF ? 3 :
            b0 > 0xBF ? 2 : 1;

        if (i + bytesPerSequence > end) break;

        var b1, b2, b3;

        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }

        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;

        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }

        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }

    return str;
}

function writeUtf8(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || (i + 1 === str.length)) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c;
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }

        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}

},{"ieee754":17}],24:[function(require,module,exports){
'use strict';

module.exports = partialSort;

// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]

function partialSort(arr, k, left, right, compare) {
    left = left || 0;
    right = right || (arr.length - 1);
    compare = compare || defaultCompare;

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            partialSort(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

},{}],25:[function(require,module,exports){
'use strict';

module.exports = rbush;

var quickselect = require('quickselect');

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from stratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}

},{"quickselect":24}],26:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('./Subject');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
/**
 * @class BehaviorSubject<T>
 */
var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        _super.call(this);
        this._value = _value;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));
exports.BehaviorSubject = BehaviorSubject;

},{"./Subject":34,"./util/ObjectUnsubscribedError":221}],27:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;

},{"./Subscriber":36}],28:[function(require,module,exports){
"use strict";
var Observable_1 = require('./Observable');
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;

},{"./Observable":29}],29:[function(require,module,exports){
"use strict";
var root_1 = require('./util/root');
var toSubscriber_1 = require('./util/toSubscriber');
var observable_1 = require('./symbol/observable');
var pipe_1 = require('./util/pipe');
/**
 * A representation of any set of values over any amount of time. This is the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    /**
     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
     *
     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
     *
     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
     * thought.
     *
     * Apart from starting the execution of an Observable, this method allows you to listen for values
     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
     * following ways.
     *
     * The first way is creating an object that implements {@link Observer} interface. It should have methods
     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
     * be left uncaught.
     *
     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
     *
     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
     *
     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
     * It is an Observable itself that decides when these functions will be called. For example {@link of}
     * by default emits all its values synchronously. Always check documentation for how given Observable
     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
     *
     * @example <caption>Subscribe with an Observer</caption>
     * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remove this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
     *
     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
     * .subscribe(sumObserver);
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Subscribe with functions</caption>
     * let sum = 0;
     *
     * Rx.Observable.of(1, 2, 3)
     * .subscribe(
     *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
     *   undefined,
     *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
     * );
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Cancel a subscription</caption>
     * const subscription = Rx.Observable.interval(1000).subscribe(
     *   num => console.log(num),
     *   undefined,
     *   () => console.log('completed!') // Will not be called, even
     * );                                // when cancelling subscription
     *
     *
     * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // "unsubscribed!" after 2.5s
     *
     *
     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
     *  Observable.
     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled.
     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     * @method subscribe
     */
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    /* tslint:enable:max-line-length */
    /**
     * Used to stitch together functional operators into a chain.
     * @method pipe
     * @return {Observable} the Observable result of all of the operators having
     * been called in the order they were passed in.
     *
     * @example
     *
     * import { map, filter, scan } from 'rxjs/operators';
     *
     * Rx.Observable.interval(1000)
     *   .pipe(
     *     filter(x => x % 2 === 0),
     *     map(x => x + x),
     *     scan((acc, x) => acc + x)
     *   )
     *   .subscribe(x => console.log(x))
     */
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i - 0] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    /* tslint:enable:max-line-length */
    Observable.prototype.toPromise = function (PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;

},{"./symbol/observable":216,"./util/pipe":236,"./util/root":237,"./util/toSubscriber":239}],30:[function(require,module,exports){
"use strict";
exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};

},{}],31:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;

},{"./Subscriber":36}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('./Subject');
var queue_1 = require('./scheduler/queue');
var Subscription_1 = require('./Subscription');
var observeOn_1 = require('./operators/observeOn');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
/**
 * @class ReplaySubject<T>
 */
var ReplaySubject = (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        _super.call(this);
        this.scheduler = scheduler;
        this._events = [];
        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        this._windowTime = windowTime < 1 ? 1 : windowTime;
    }
    ReplaySubject.prototype.next = function (value) {
        var now = this._getNow();
        this._events.push(new ReplayEvent(now, value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _events = this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        var len = _events.length;
        for (var i = 0; i < len && !subscriber.closed; i++) {
            subscriber.next(_events[i].value);
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue_1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

},{"./Subject":34,"./SubjectSubscription":35,"./Subscription":37,"./operators/observeOn":182,"./scheduler/queue":214,"./util/ObjectUnsubscribedError":221}],33:[function(require,module,exports){
"use strict";
/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;

},{}],34:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('./Observable');
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;

},{"./Observable":29,"./SubjectSubscription":35,"./Subscriber":36,"./Subscription":37,"./symbol/rxSubscriber":217,"./util/ObjectUnsubscribedError":221}],35:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('./Subscription');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;

},{"./Subscription":37}],36:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = require('./util/isFunction');
var Subscription_1 = require('./Subscription');
var Observer_1 = require('./Observer');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

},{"./Observer":30,"./Subscription":37,"./symbol/rxSubscriber":217,"./util/isFunction":230}],37:[function(require,module,exports){
"use strict";
var isArray_1 = require('./util/isArray');
var isObject_1 = require('./util/isObject');
var isFunction_1 = require('./util/isFunction');
var tryCatch_1 = require('./util/tryCatch');
var errorObject_1 = require('./util/errorObject');
var UnsubscriptionError_1 = require('./util/UnsubscriptionError');
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        }
        else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}

},{"./util/UnsubscriptionError":224,"./util/errorObject":225,"./util/isArray":227,"./util/isFunction":230,"./util/isObject":232,"./util/tryCatch":240}],38:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var combineLatest_1 = require('../../observable/combineLatest');
Observable_1.Observable.combineLatest = combineLatest_1.combineLatest;

},{"../../Observable":29,"../../observable/combineLatest":104}],39:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var concat_1 = require('../../observable/concat');
Observable_1.Observable.concat = concat_1.concat;

},{"../../Observable":29,"../../observable/concat":105}],40:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var defer_1 = require('../../observable/defer');
Observable_1.Observable.defer = defer_1.defer;

},{"../../Observable":29,"../../observable/defer":106}],41:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var empty_1 = require('../../observable/empty');
Observable_1.Observable.empty = empty_1.empty;

},{"../../Observable":29,"../../observable/empty":107}],42:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var from_1 = require('../../observable/from');
Observable_1.Observable.from = from_1.from;

},{"../../Observable":29,"../../observable/from":108}],43:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var fromEvent_1 = require('../../observable/fromEvent');
Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;

},{"../../Observable":29,"../../observable/fromEvent":109}],44:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var fromPromise_1 = require('../../observable/fromPromise');
Observable_1.Observable.fromPromise = fromPromise_1.fromPromise;

},{"../../Observable":29,"../../observable/fromPromise":110}],45:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var merge_1 = require('../../observable/merge');
Observable_1.Observable.merge = merge_1.merge;

},{"../../Observable":29,"../../observable/merge":111}],46:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var of_1 = require('../../observable/of');
Observable_1.Observable.of = of_1.of;

},{"../../Observable":29,"../../observable/of":112}],47:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var throw_1 = require('../../observable/throw');
Observable_1.Observable.throw = throw_1._throw;

},{"../../Observable":29,"../../observable/throw":113}],48:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var timer_1 = require('../../observable/timer');
Observable_1.Observable.timer = timer_1.timer;

},{"../../Observable":29,"../../observable/timer":114}],49:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var zip_1 = require('../../observable/zip');
Observable_1.Observable.zip = zip_1.zip;

},{"../../Observable":29,"../../observable/zip":115}],50:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var auditTime_1 = require('../../operator/auditTime');
Observable_1.Observable.prototype.auditTime = auditTime_1.auditTime;

},{"../../Observable":29,"../../operator/auditTime":116}],51:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var buffer_1 = require('../../operator/buffer');
Observable_1.Observable.prototype.buffer = buffer_1.buffer;

},{"../../Observable":29,"../../operator/buffer":117}],52:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var bufferCount_1 = require('../../operator/bufferCount');
Observable_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount;

},{"../../Observable":29,"../../operator/bufferCount":118}],53:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var bufferWhen_1 = require('../../operator/bufferWhen');
Observable_1.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen;

},{"../../Observable":29,"../../operator/bufferWhen":119}],54:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var catch_1 = require('../../operator/catch');
Observable_1.Observable.prototype.catch = catch_1._catch;
Observable_1.Observable.prototype._catch = catch_1._catch;

},{"../../Observable":29,"../../operator/catch":120}],55:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var combineLatest_1 = require('../../operator/combineLatest');
Observable_1.Observable.prototype.combineLatest = combineLatest_1.combineLatest;

},{"../../Observable":29,"../../operator/combineLatest":121}],56:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var concat_1 = require('../../operator/concat');
Observable_1.Observable.prototype.concat = concat_1.concat;

},{"../../Observable":29,"../../operator/concat":122}],57:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var debounceTime_1 = require('../../operator/debounceTime');
Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;

},{"../../Observable":29,"../../operator/debounceTime":123}],58:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var delay_1 = require('../../operator/delay');
Observable_1.Observable.prototype.delay = delay_1.delay;

},{"../../Observable":29,"../../operator/delay":124}],59:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var distinct_1 = require('../../operator/distinct');
Observable_1.Observable.prototype.distinct = distinct_1.distinct;

},{"../../Observable":29,"../../operator/distinct":125}],60:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var distinctUntilChanged_1 = require('../../operator/distinctUntilChanged');
Observable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;

},{"../../Observable":29,"../../operator/distinctUntilChanged":126}],61:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var do_1 = require('../../operator/do');
Observable_1.Observable.prototype.do = do_1._do;
Observable_1.Observable.prototype._do = do_1._do;

},{"../../Observable":29,"../../operator/do":127}],62:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var expand_1 = require('../../operator/expand');
Observable_1.Observable.prototype.expand = expand_1.expand;

},{"../../Observable":29,"../../operator/expand":128}],63:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var filter_1 = require('../../operator/filter');
Observable_1.Observable.prototype.filter = filter_1.filter;

},{"../../Observable":29,"../../operator/filter":129}],64:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var finally_1 = require('../../operator/finally');
Observable_1.Observable.prototype.finally = finally_1._finally;
Observable_1.Observable.prototype._finally = finally_1._finally;

},{"../../Observable":29,"../../operator/finally":130}],65:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var first_1 = require('../../operator/first');
Observable_1.Observable.prototype.first = first_1.first;

},{"../../Observable":29,"../../operator/first":131}],66:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var last_1 = require('../../operator/last');
Observable_1.Observable.prototype.last = last_1.last;

},{"../../Observable":29,"../../operator/last":132}],67:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var map_1 = require('../../operator/map');
Observable_1.Observable.prototype.map = map_1.map;

},{"../../Observable":29,"../../operator/map":133}],68:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var merge_1 = require('../../operator/merge');
Observable_1.Observable.prototype.merge = merge_1.merge;

},{"../../Observable":29,"../../operator/merge":134}],69:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var mergeAll_1 = require('../../operator/mergeAll');
Observable_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;

},{"../../Observable":29,"../../operator/mergeAll":135}],70:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var mergeMap_1 = require('../../operator/mergeMap');
Observable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;
Observable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;

},{"../../Observable":29,"../../operator/mergeMap":136}],71:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var pairwise_1 = require('../../operator/pairwise');
Observable_1.Observable.prototype.pairwise = pairwise_1.pairwise;

},{"../../Observable":29,"../../operator/pairwise":137}],72:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var pluck_1 = require('../../operator/pluck');
Observable_1.Observable.prototype.pluck = pluck_1.pluck;

},{"../../Observable":29,"../../operator/pluck":138}],73:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var publish_1 = require('../../operator/publish');
Observable_1.Observable.prototype.publish = publish_1.publish;

},{"../../Observable":29,"../../operator/publish":139}],74:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var publishReplay_1 = require('../../operator/publishReplay');
Observable_1.Observable.prototype.publishReplay = publishReplay_1.publishReplay;

},{"../../Observable":29,"../../operator/publishReplay":140}],75:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var reduce_1 = require('../../operator/reduce');
Observable_1.Observable.prototype.reduce = reduce_1.reduce;

},{"../../Observable":29,"../../operator/reduce":141}],76:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var retry_1 = require('../../operator/retry');
Observable_1.Observable.prototype.retry = retry_1.retry;

},{"../../Observable":29,"../../operator/retry":142}],77:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var sample_1 = require('../../operator/sample');
Observable_1.Observable.prototype.sample = sample_1.sample;

},{"../../Observable":29,"../../operator/sample":143}],78:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var scan_1 = require('../../operator/scan');
Observable_1.Observable.prototype.scan = scan_1.scan;

},{"../../Observable":29,"../../operator/scan":144}],79:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var share_1 = require('../../operator/share');
Observable_1.Observable.prototype.share = share_1.share;

},{"../../Observable":29,"../../operator/share":145}],80:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var skip_1 = require('../../operator/skip');
Observable_1.Observable.prototype.skip = skip_1.skip;

},{"../../Observable":29,"../../operator/skip":146}],81:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var skipUntil_1 = require('../../operator/skipUntil');
Observable_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;

},{"../../Observable":29,"../../operator/skipUntil":147}],82:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var skipWhile_1 = require('../../operator/skipWhile');
Observable_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile;

},{"../../Observable":29,"../../operator/skipWhile":148}],83:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var startWith_1 = require('../../operator/startWith');
Observable_1.Observable.prototype.startWith = startWith_1.startWith;

},{"../../Observable":29,"../../operator/startWith":149}],84:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var switchMap_1 = require('../../operator/switchMap');
Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;

},{"../../Observable":29,"../../operator/switchMap":150}],85:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var take_1 = require('../../operator/take');
Observable_1.Observable.prototype.take = take_1.take;

},{"../../Observable":29,"../../operator/take":151}],86:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var takeUntil_1 = require('../../operator/takeUntil');
Observable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;

},{"../../Observable":29,"../../operator/takeUntil":152}],87:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var takeWhile_1 = require('../../operator/takeWhile');
Observable_1.Observable.prototype.takeWhile = takeWhile_1.takeWhile;

},{"../../Observable":29,"../../operator/takeWhile":153}],88:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var throttleTime_1 = require('../../operator/throttleTime');
Observable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;

},{"../../Observable":29,"../../operator/throttleTime":154}],89:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var timeout_1 = require('../../operator/timeout');
Observable_1.Observable.prototype.timeout = timeout_1.timeout;

},{"../../Observable":29,"../../operator/timeout":155}],90:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var withLatestFrom_1 = require('../../operator/withLatestFrom');
Observable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;

},{"../../Observable":29,"../../operator/withLatestFrom":156}],91:[function(require,module,exports){
"use strict";
var Observable_1 = require('../../Observable');
var zip_1 = require('../../operator/zip');
Observable_1.Observable.prototype.zip = zip_1.zipProto;

},{"../../Observable":29,"../../operator/zip":157}],92:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var ScalarObservable_1 = require('./ScalarObservable');
var EmptyObservable_1 = require('./EmptyObservable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayLikeObservable = (function (_super) {
    __extends(ArrayLikeObservable, _super);
    function ArrayLikeObservable(arrayLike, scheduler) {
        _super.call(this);
        this.arrayLike = arrayLike;
        this.scheduler = scheduler;
        if (!scheduler && arrayLike.length === 1) {
            this._isScalar = true;
            this.value = arrayLike[0];
        }
    }
    ArrayLikeObservable.create = function (arrayLike, scheduler) {
        var length = arrayLike.length;
        if (length === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else if (length === 1) {
            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
        }
        else {
            return new ArrayLikeObservable(arrayLike, scheduler);
        }
    };
    ArrayLikeObservable.dispatch = function (state) {
        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;
        if (subscriber.closed) {
            return;
        }
        if (index >= length) {
            subscriber.complete();
            return;
        }
        subscriber.next(arrayLike[index]);
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;
        var length = arrayLike.length;
        if (scheduler) {
            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < length && !subscriber.closed; i++) {
                subscriber.next(arrayLike[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayLikeObservable;
}(Observable_1.Observable));
exports.ArrayLikeObservable = ArrayLikeObservable;

},{"../Observable":29,"./EmptyObservable":96,"./ScalarObservable":102}],93:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var ScalarObservable_1 = require('./ScalarObservable');
var EmptyObservable_1 = require('./EmptyObservable');
var isScheduler_1 = require('../util/isScheduler');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = (function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        }
        else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        }
        else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable));
exports.ArrayObservable = ArrayObservable;

},{"../Observable":29,"../util/isScheduler":234,"./EmptyObservable":96,"./ScalarObservable":102}],94:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('../Subject');
var Observable_1 = require('../Observable');
var Subscriber_1 = require('../Subscriber');
var Subscription_1 = require('../Subscription');
var refCount_1 = require('../operators/refCount');
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
        this._isComplete = false;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            }
            else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount_1.refCount()(this);
    };
    return ConnectableObservable;
}(Observable_1.Observable));
exports.ConnectableObservable = ConnectableObservable;
var connectableProto = ConnectableObservable.prototype;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
};
var ConnectableSubscriber = (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber));
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Observable":29,"../Subject":34,"../Subscriber":36,"../Subscription":37,"../operators/refCount":188}],95:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var subscribeToResult_1 = require('../util/subscribeToResult');
var OuterSubscriber_1 = require('../OuterSubscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var DeferObservable = (function (_super) {
    __extends(DeferObservable, _super);
    function DeferObservable(observableFactory) {
        _super.call(this);
        this.observableFactory = observableFactory;
    }
    /**
     * Creates an Observable that, on subscribe, calls an Observable factory to
     * make an Observable for each new Observer.
     *
     * <span class="informal">Creates the Observable lazily, that is, only when it
     * is subscribed.
     * </span>
     *
     * <img src="./img/defer.png" width="100%">
     *
     * `defer` allows you to create the Observable only when the Observer
     * subscribes, and create a fresh Observable for each Observer. It waits until
     * an Observer subscribes to it, and then it generates an Observable,
     * typically with an Observable factory function. It does this afresh for each
     * subscriber, so although each subscriber may think it is subscribing to the
     * same Observable, in fact each subscriber gets its own individual
     * Observable.
     *
     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
     * var clicksOrInterval = Rx.Observable.defer(function () {
     *   if (Math.random() > 0.5) {
     *     return Rx.Observable.fromEvent(document, 'click');
     *   } else {
     *     return Rx.Observable.interval(1000);
     *   }
     * });
     * clicksOrInterval.subscribe(x => console.log(x));
     *
     * // Results in the following behavior:
     * // If the result of Math.random() is greater than 0.5 it will listen
     * // for clicks anywhere on the "document"; when document is clicked it
     * // will log a MouseEvent object to the console. If the result is less
     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
     *
     * @see {@link create}
     *
     * @param {function(): SubscribableOrPromise} observableFactory The Observable
     * factory function to invoke for each Observer that subscribes to the output
     * Observable. May also return a Promise, which will be converted on the fly
     * to an Observable.
     * @return {Observable} An Observable whose Observers' subscriptions trigger
     * an invocation of the given Observable factory function.
     * @static true
     * @name defer
     * @owner Observable
     */
    DeferObservable.create = function (observableFactory) {
        return new DeferObservable(observableFactory);
    };
    DeferObservable.prototype._subscribe = function (subscriber) {
        return new DeferSubscriber(subscriber, this.observableFactory);
    };
    return DeferObservable;
}(Observable_1.Observable));
exports.DeferObservable = DeferObservable;
var DeferSubscriber = (function (_super) {
    __extends(DeferSubscriber, _super);
    function DeferSubscriber(destination, factory) {
        _super.call(this, destination);
        this.factory = factory;
        this.tryDefer();
    }
    DeferSubscriber.prototype.tryDefer = function () {
        try {
            this._callFactory();
        }
        catch (err) {
            this._error(err);
        }
    };
    DeferSubscriber.prototype._callFactory = function () {
        var result = this.factory();
        if (result) {
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return DeferSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../Observable":29,"../OuterSubscriber":31,"../util/subscribeToResult":238}],96:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = (function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        }
        else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable));
exports.EmptyObservable = EmptyObservable;

},{"../Observable":29}],97:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ErrorObservable = (function (_super) {
    __extends(ErrorObservable, _super);
    function ErrorObservable(error, scheduler) {
        _super.call(this);
        this.error = error;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits an error notification.
     *
     * <span class="informal">Just emits 'error', and nothing else.
     * </span>
     *
     * <img src="./img/throw.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the error notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then emit an error.</caption>
     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x === 13 ?
     *     Rx.Observable.throw('Thirteens are bad') :
     *     Rx.Observable.of('a', 'b', 'c')
     * );
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link of}
     *
     * @param {any} error The particular Error to pass to the error notification.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the error notification.
     * @return {Observable} An error Observable: emits only the error notification
     * using the given error argument.
     * @static true
     * @name throw
     * @owner Observable
     */
    ErrorObservable.create = function (error, scheduler) {
        return new ErrorObservable(error, scheduler);
    };
    ErrorObservable.dispatch = function (arg) {
        var error = arg.error, subscriber = arg.subscriber;
        subscriber.error(error);
    };
    ErrorObservable.prototype._subscribe = function (subscriber) {
        var error = this.error;
        var scheduler = this.scheduler;
        subscriber.syncErrorThrowable = true;
        if (scheduler) {
            return scheduler.schedule(ErrorObservable.dispatch, 0, {
                error: error, subscriber: subscriber
            });
        }
        else {
            subscriber.error(error);
        }
    };
    return ErrorObservable;
}(Observable_1.Observable));
exports.ErrorObservable = ErrorObservable;

},{"../Observable":29}],98:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var tryCatch_1 = require('../util/tryCatch');
var isFunction_1 = require('../util/isFunction');
var errorObject_1 = require('../util/errorObject');
var Subscription_1 = require('../Subscription');
var toString = Object.prototype.toString;
function isNodeStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isNodeList(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
}
function isHTMLCollection(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
}
function isEventTarget(sourceObj) {
    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventObservable = (function (_super) {
    __extends(FromEventObservable, _super);
    function FromEventObservable(sourceObj, eventName, selector, options) {
        _super.call(this);
        this.sourceObj = sourceObj;
        this.eventName = eventName;
        this.selector = selector;
        this.options = options;
    }
    /* tslint:enable:max-line-length */
    /**
     * Creates an Observable that emits events of a specific type coming from the
     * given event target.
     *
     * <span class="informal">Creates an Observable from DOM events, or Node.js
     * EventEmitter events or others.</span>
     *
     * <img src="./img/fromEvent.png" width="100%">
     *
     * `fromEvent` accepts as a first argument event target, which is an object with methods
     * for registering event handler functions. As a second argument it takes string that indicates
     * type of event we want to listen for. `fromEvent` supports selected types of event targets,
     * which are described in detail below. If your event target does not match any of the ones listed,
     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.
     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event
     * handler functions have different names, but they all accept a string describing event type
     * and function itself, which will be called whenever said event happens.
     *
     * Every time resulting Observable is subscribed, event handler function will be registered
     * to event target on given event type. When that event fires, value
     * passed as a first argument to registered function will be emitted by output Observable.
     * When Observable is unsubscribed, function will be unregistered from event target.
     *
     * Note that if event target calls registered function with more than one argument, second
     * and following arguments will not appear in resulting stream. In order to get access to them,
     * you can pass to `fromEvent` optional project function, which will be called with all arguments
     * passed to event handler. Output Observable will then emit value returned by project function,
     * instead of the usual value.
     *
     * Remember that event targets listed below are checked via duck typing. It means that
     * no matter what kind of object you have and no matter what environment you work in,
     * you can safely use `fromEvent` on that object if it exposes described methods (provided
     * of course they behave as was described above). So for example if Node.js library exposes
     * event target which has the same method names as DOM EventTarget, `fromEvent` is still
     * a good choice.
     *
     * If the API you use is more callback then event handler oriented (subscribed
     * callback function fires only once and thus there is no need to manually
     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}
     * instead.
     *
     * `fromEvent` supports following types of event targets:
     *
     * **DOM EventTarget**
     *
     * This is an object with `addEventListener` and `removeEventListener` methods.
     *
     * In the browser, `addEventListener` accepts - apart from event type string and event
     * handler function arguments - optional third parameter, which is either an object or boolean,
     * both used for additional configuration how and when passed function will be called. When
     * `fromEvent` is used with event target of that type, you can provide this values
     * as third parameter as well.
     *
     * **Node.js EventEmitter**
     *
     * An object with `addListener` and `removeListener` methods.
     *
     * **JQuery-style event target**
     *
     * An object with `on` and `off` methods
     *
     * **DOM NodeList**
     *
     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.
     *
     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes
     * it contains and install event handler function in every of them. When returned Observable
     * is unsubscribed, function will be removed from all Nodes.
     *
     * **DOM HtmlCollection**
     *
     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is
     * installed and removed in each of elements.
     *
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * clicks.subscribe(x => console.log(x));
     *
     * // Results in:
     * // MouseEvent object logged to console every time a click
     * // occurs on the document.
     *
     *
     * @example <caption>Use addEventListener with capture option</caption>
     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter
     *                                                                          // which will be passed to addEventListener
     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');
     *
     * clicksInDocument.subscribe(() => console.log('document'));
     * clicksInDiv.subscribe(() => console.log('div'));
     *
     * // By default events bubble UP in DOM tree, so normally
     * // when we would click on div in document
     * // "div" would be logged first and then "document".
     * // Since we specified optional `capture` option, document
     * // will catch event when it goes DOWN DOM tree, so console
     * // will log "document" and then "div".
     *
     * @see {@link bindCallback}
     * @see {@link bindNodeCallback}
     * @see {@link fromEventPattern}
     *
     * @param {EventTargetLike} target The DOM EventTarget, Node.js
     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.
     * @param {string} eventName The event name of interest, being emitted by the
     * `target`.
     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
     * @param {SelectorMethodSignature<T>} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEvent
     * @owner Observable
     */
    FromEventObservable.create = function (target, eventName, options, selector) {
        if (isFunction_1.isFunction(options)) {
            selector = options;
            options = undefined;
        }
        return new FromEventObservable(target, eventName, selector, options);
    };
    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        }
        else if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };
        }
        else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function () { return source_2.off(eventName, handler); };
        }
        else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function () { return source_3.removeListener(eventName, handler); };
        }
        else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(new Subscription_1.Subscription(unsubscribe));
    };
    FromEventObservable.prototype._subscribe = function (subscriber) {
        var sourceObj = this.sourceObj;
        var eventName = this.eventName;
        var options = this.options;
        var selector = this.selector;
        var handler = selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
            if (result === errorObject_1.errorObject) {
                subscriber.error(errorObject_1.errorObject.e);
            }
            else {
                subscriber.next(result);
            }
        } : function (e) { return subscriber.next(e); };
        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
    };
    return FromEventObservable;
}(Observable_1.Observable));
exports.FromEventObservable = FromEventObservable;

},{"../Observable":29,"../Subscription":37,"../util/errorObject":225,"../util/isFunction":230,"../util/tryCatch":240}],99:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = require('../util/isArray');
var isArrayLike_1 = require('../util/isArrayLike');
var isPromise_1 = require('../util/isPromise');
var PromiseObservable_1 = require('./PromiseObservable');
var IteratorObservable_1 = require('./IteratorObservable');
var ArrayObservable_1 = require('./ArrayObservable');
var ArrayLikeObservable_1 = require('./ArrayLikeObservable');
var iterator_1 = require('../symbol/iterator');
var Observable_1 = require('../Observable');
var observeOn_1 = require('../operators/observeOn');
var observable_1 = require('../symbol/observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromObservable = (function (_super) {
    __extends(FromObservable, _super);
    function FromObservable(ish, scheduler) {
        _super.call(this, null);
        this.ish = ish;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable from an Array, an array-like object, a Promise, an
     * iterable object, or an Observable-like object.
     *
     * <span class="informal">Converts almost anything to an Observable.</span>
     *
     * <img src="./img/from.png" width="100%">
     *
     * Convert various other objects and data types into Observables. `from`
     * converts a Promise or an array-like or an
     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
     * object into an Observable that emits the items in that promise or array or
     * iterable. A String, in this context, is treated as an array of characters.
     * Observable-like objects (contains a function named with the ES2015 Symbol
     * for Observable) can also be converted through this operator.
     *
     * @example <caption>Converts an array to an Observable</caption>
     * var array = [10, 20, 30];
     * var result = Rx.Observable.from(array);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 10 20 30
     *
     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
     * function* generateDoubles(seed) {
     *   var i = seed;
     *   while (true) {
     *     yield i;
     *     i = 2 * i; // double it
     *   }
     * }
     *
     * var iterator = generateDoubles(3);
     * var result = Rx.Observable.from(iterator).take(10);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 3 6 12 24 48 96 192 384 768 1536
     *
     * @see {@link create}
     * @see {@link fromEvent}
     * @see {@link fromEventPattern}
     * @see {@link fromPromise}
     *
     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
     * Observable-like, an Array, an iterable or an array-like object to be
     * converted.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * emissions of values.
     * @return {Observable<T>} The Observable whose values are originally from the
     * input object that was converted.
     * @static true
     * @name from
     * @owner Observable
     */
    FromObservable.create = function (ish, scheduler) {
        if (ish != null) {
            if (typeof ish[observable_1.observable] === 'function') {
                if (ish instanceof Observable_1.Observable && !scheduler) {
                    return ish;
                }
                return new FromObservable(ish, scheduler);
            }
            else if (isArray_1.isArray(ish)) {
                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
            }
            else if (isPromise_1.isPromise(ish)) {
                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
            }
            else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {
                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
            }
            else if (isArrayLike_1.isArrayLike(ish)) {
                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
            }
        }
        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
    };
    FromObservable.prototype._subscribe = function (subscriber) {
        var ish = this.ish;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            return ish[observable_1.observable]().subscribe(subscriber);
        }
        else {
            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
        }
    };
    return FromObservable;
}(Observable_1.Observable));
exports.FromObservable = FromObservable;

},{"../Observable":29,"../operators/observeOn":182,"../symbol/iterator":215,"../symbol/observable":216,"../util/isArray":227,"../util/isArrayLike":228,"../util/isPromise":233,"./ArrayLikeObservable":92,"./ArrayObservable":93,"./IteratorObservable":100,"./PromiseObservable":101}],100:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Observable_1 = require('../Observable');
var iterator_1 = require('../symbol/iterator');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IteratorObservable = (function (_super) {
    __extends(IteratorObservable, _super);
    function IteratorObservable(iterator, scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
        if (iterator == null) {
            throw new Error('iterator cannot be null.');
        }
        this.iterator = getIterator(iterator);
    }
    IteratorObservable.create = function (iterator, scheduler) {
        return new IteratorObservable(iterator, scheduler);
    };
    IteratorObservable.dispatch = function (state) {
        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;
        if (hasError) {
            subscriber.error(state.error);
            return;
        }
        var result = iterator.next();
        if (result.done) {
            subscriber.complete();
            return;
        }
        subscriber.next(result.value);
        state.index = index + 1;
        if (subscriber.closed) {
            if (typeof iterator.return === 'function') {
                iterator.return();
            }
            return;
        }
        this.schedule(state);
    };
    IteratorObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;
        if (scheduler) {
            return scheduler.schedule(IteratorObservable.dispatch, 0, {
                index: index, iterator: iterator, subscriber: subscriber
            });
        }
        else {
            do {
                var result = iterator.next();
                if (result.done) {
                    subscriber.complete();
                    break;
                }
                else {
                    subscriber.next(result.value);
                }
                if (subscriber.closed) {
                    if (typeof iterator.return === 'function') {
                        iterator.return();
                    }
                    break;
                }
            } while (true);
        }
    };
    return IteratorObservable;
}(Observable_1.Observable));
exports.IteratorObservable = IteratorObservable;
var StringIterator = (function () {
    function StringIterator(str, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = str.length; }
        this.str = str;
        this.idx = idx;
        this.len = len;
    }
    StringIterator.prototype[iterator_1.iterator] = function () { return (this); };
    StringIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.str.charAt(this.idx++)
        } : {
            done: true,
            value: undefined
        };
    };
    return StringIterator;
}());
var ArrayIterator = (function () {
    function ArrayIterator(arr, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = toLength(arr); }
        this.arr = arr;
        this.idx = idx;
        this.len = len;
    }
    ArrayIterator.prototype[iterator_1.iterator] = function () { return this; };
    ArrayIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.arr[this.idx++]
        } : {
            done: true,
            value: undefined
        };
    };
    return ArrayIterator;
}());
function getIterator(obj) {
    var i = obj[iterator_1.iterator];
    if (!i && typeof obj === 'string') {
        return new StringIterator(obj);
    }
    if (!i && obj.length !== undefined) {
        return new ArrayIterator(obj);
    }
    if (!i) {
        throw new TypeError('object is not iterable');
    }
    return obj[iterator_1.iterator]();
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
        return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
        return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
        return 0;
    }
    if (len > maxSafeInteger) {
        return maxSafeInteger;
    }
    return len;
}
function numberIsFinite(value) {
    return typeof value === 'number' && root_1.root.isFinite(value);
}
function sign(value) {
    var valueAsNumber = +value;
    if (valueAsNumber === 0) {
        return valueAsNumber;
    }
    if (isNaN(valueAsNumber)) {
        return valueAsNumber;
    }
    return valueAsNumber < 0 ? -1 : 1;
}

},{"../Observable":29,"../symbol/iterator":215,"../util/root":237}],101:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PromiseObservable = (function (_super) {
    __extends(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
        _super.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
    }
    /**
     * Converts a Promise to an Observable.
     *
     * <span class="informal">Returns an Observable that just emits the Promise's
     * resolved value, then completes.</span>
     *
     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
     * Observable. If the Promise resolves with a value, the output Observable
     * emits that resolved value as a `next`, and then completes. If the Promise
     * is rejected, then the output Observable emits the corresponding Error.
     *
     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     *
     * @param {PromiseLike<T>} promise The promise to be converted.
     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
     * the delivery of the resolved value (or the rejection).
     * @return {Observable<T>} An Observable which wraps the Promise.
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    PromiseObservable.create = function (promise, scheduler) {
        return new PromiseObservable(promise, scheduler);
    };
    PromiseObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var promise = this.promise;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    subscriber.next(this.value);
                    subscriber.complete();
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.next(value);
                        subscriber.complete();
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.error(err);
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () { throw err; });
                });
            }
        }
        else {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () { throw err; });
                });
            }
        }
    };
    return PromiseObservable;
}(Observable_1.Observable));
exports.PromiseObservable = PromiseObservable;
function dispatchNext(arg) {
    var value = arg.value, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
    }
}
function dispatchError(arg) {
    var err = arg.err, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.error(err);
    }
}

},{"../Observable":29,"../util/root":237}],102:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = (function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done, value = state.value, subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        }
        else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable));
exports.ScalarObservable = ScalarObservable;

},{"../Observable":29}],103:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = require('../util/isNumeric');
var Observable_1 = require('../Observable');
var async_1 = require('../scheduler/async');
var isScheduler_1 = require('../util/isScheduler');
var isDate_1 = require('../util/isDate');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = (function (_super) {
    __extends(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) { dueTime = 0; }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        }
        else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async_1.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ?
            (+dueTime - this.scheduler.now()) :
            dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) { initialDelay = 0; }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index, period = state.period, subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable));
exports.TimerObservable = TimerObservable;

},{"../Observable":29,"../scheduler/async":213,"../util/isDate":229,"../util/isNumeric":231,"../util/isScheduler":234}],104:[function(require,module,exports){
"use strict";
var isScheduler_1 = require('../util/isScheduler');
var isArray_1 = require('../util/isArray');
var ArrayObservable_1 = require('./ArrayObservable');
var combineLatest_1 = require('../operators/combineLatest');
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from all the Observables passed as
 * arguments. This is done by subscribing to each Observable in order and,
 * whenever any Observable emits, collecting an array of the most recent
 * values from each Observable. So if you pass `n` Observables to operator,
 * returned Observable will always emit an array of `n` values, in order
 * corresponding to order of passed Observables (value from the first Observable
 * on the first place and so on).
 *
 * Static version of `combineLatest` accepts either an array of Observables
 * or each Observable can be put directly as an argument. Note that array of
 * Observables is good choice, if you don't know beforehand how many Observables
 * you will combine. Passing empty array will result in Observable that
 * completes immediately.
 *
 * To ensure output array has always the same length, `combineLatest` will
 * actually wait for all input Observables to emit at least once,
 * before it starts emitting results. This means if some Observable emits
 * values before other Observables started emitting, all that values but last
 * will be lost. On the other hand, is some Observable does not emit value but
 * completes, resulting Observable will complete at the same moment without
 * emitting anything, since it will be now impossible to include value from
 * completed Observable in resulting array. Also, if some input Observable does
 * not emit any value and never completes, `combineLatest` will also never emit
 * and never complete, since, again, it will wait for all streams to emit some
 * value.
 *
 * If at least one Observable was passed to `combineLatest` and all passed Observables
 * emitted something, resulting Observable will complete when all combined
 * streams complete. So even if some Observable completes, result of
 * `combineLatest` will still emit values when other Observables do. In case
 * of completed Observable, its value from now on will always be the last
 * emitted value. On the other hand, if any Observable errors, `combineLatest`
 * will error immediately as well, and all other Observables will be unsubscribed.
 *
 * `combineLatest` accepts as optional parameter `project` function, which takes
 * as arguments all values that would normally be emitted by resulting Observable.
 * `project` can return any kind of value, which will be then emitted by Observable
 * instead of default array. Note that `project` does not take as argument that array
 * of values, but values themselves. That means default `project` can be imagined
 * as function that takes all its arguments and puts them into an array.
 *
 *
 * @example <caption>Combine two timer Observables</caption>
 * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
 * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
 * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);
 * combinedTimers.subscribe(value => console.log(value));
 * // Logs
 * // [0, 0] after 0.5s
 * // [1, 0] after 1s
 * // [1, 1] after 1.5s
 * // [2, 1] after 2s
 *
 *
 * @example <caption>Combine an array of Observables</caption>
 * const observables = [1, 5, 10].map(
 *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds
 * );
 * const combined = Rx.Observable.combineLatest(observables);
 * combined.subscribe(value => console.log(value));
 * // Logs
 * // [0, 0, 0] immediately
 * // [1, 0, 0] after 1s
 * // [1, 5, 0] after 5s
 * // [1, 5, 10] after 10s
 *
 *
 * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} observable1 An input Observable to combine with other Observables.
 * @param {ObservableInput} observable2 An input Observable to combine with other Observables.
 * More than one input Observables may be given as arguments
 * or an array of Observables may be given as the first argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
 * each input Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @static true
 * @name combineLatest
 * @owner Observable
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    var scheduler = null;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));
}
exports.combineLatest = combineLatest;

},{"../operators/combineLatest":164,"../util/isArray":227,"../util/isScheduler":234,"./ArrayObservable":93}],105:[function(require,module,exports){
"use strict";
var isScheduler_1 = require('../util/isScheduler');
var of_1 = require('./of');
var from_1 = require('./from');
var concatAll_1 = require('../operators/concatAll');
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from given
 * Observable and then moves on to the next.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * `concat` joins multiple Observables together, by subscribing to them one at a time and
 * merging their results into the output Observable. You can pass either an array of
 * Observables, or put them directly as arguments. Passing an empty array will result
 * in Observable that completes immediately.
 *
 * `concat` will subscribe to first input Observable and emit all its values, without
 * changing or affecting them in any way. When that Observable completes, it will
 * subscribe to then next Observable passed and, again, emit its values. This will be
 * repeated, until the operator runs out of Observables. When last input Observable completes,
 * `concat` will complete as well. At any given moment only one Observable passed to operator
 * emits values. If you would like to emit values from passed Observables concurrently, check out
 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
 *
 * Note that if some input Observable never completes, `concat` will also never complete
 * and Observables following the one that did not complete will never be subscribed. On the other
 * hand, if some Observable simply completes immediately after it is subscribed, it will be
 * invisible for `concat`, which will just move on to the next Observable.
 *
 * If any Observable in chain errors, instead of passing control to the next Observable,
 * `concat` will error immediately as well. Observables that would be subscribed after
 * the one that emitted error, never will.
 *
 * If you pass to `concat` the same Observable many times, its stream of values
 * will be "replayed" on every subscription, which means you can repeat given Observable
 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
 * you can always use {@link repeat}.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = Rx.Observable.concat(timer, sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 *
 * @example <caption>Concatenate an array of 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 *
 * @example <caption>Concatenate the same Observable to repeat it</caption>
 * const timer = Rx.Observable.interval(1000).take(2);
 *
 * Rx.Observable.concat(timer, timer) // concating the same Observable!
 * .subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('...and it is done!')
 * );
 *
 * // Logs:
 * // 0 after 1s
 * // 1 after 2s
 * // 0 after 3s
 * // 1 after 4s
 * // "...and it is done!" also after 4s
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} input1 An input Observable to concatenate with others.
 * @param {ObservableInput} input2 An input Observable to concatenate with others.
 * More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @static true
 * @name concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {
        return from_1.from(observables[0]);
    }
    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
}
exports.concat = concat;

},{"../operators/concatAll":166,"../util/isScheduler":234,"./from":108,"./of":112}],106:[function(require,module,exports){
"use strict";
var DeferObservable_1 = require('./DeferObservable');
exports.defer = DeferObservable_1.DeferObservable.create;

},{"./DeferObservable":95}],107:[function(require,module,exports){
"use strict";
var EmptyObservable_1 = require('./EmptyObservable');
exports.empty = EmptyObservable_1.EmptyObservable.create;

},{"./EmptyObservable":96}],108:[function(require,module,exports){
"use strict";
var FromObservable_1 = require('./FromObservable');
exports.from = FromObservable_1.FromObservable.create;

},{"./FromObservable":99}],109:[function(require,module,exports){
"use strict";
var FromEventObservable_1 = require('./FromEventObservable');
exports.fromEvent = FromEventObservable_1.FromEventObservable.create;

},{"./FromEventObservable":98}],110:[function(require,module,exports){
"use strict";
var PromiseObservable_1 = require('./PromiseObservable');
exports.fromPromise = PromiseObservable_1.PromiseObservable.create;

},{"./PromiseObservable":101}],111:[function(require,module,exports){
"use strict";
var merge_1 = require('../operator/merge');
exports.merge = merge_1.mergeStatic;

},{"../operator/merge":134}],112:[function(require,module,exports){
"use strict";
var ArrayObservable_1 = require('./ArrayObservable');
exports.of = ArrayObservable_1.ArrayObservable.of;

},{"./ArrayObservable":93}],113:[function(require,module,exports){
"use strict";
var ErrorObservable_1 = require('./ErrorObservable');
exports._throw = ErrorObservable_1.ErrorObservable.create;

},{"./ErrorObservable":97}],114:[function(require,module,exports){
"use strict";
var TimerObservable_1 = require('./TimerObservable');
exports.timer = TimerObservable_1.TimerObservable.create;

},{"./TimerObservable":103}],115:[function(require,module,exports){
"use strict";
var zip_1 = require('../operators/zip');
exports.zip = zip_1.zipStatic;

},{"../operators/zip":207}],116:[function(require,module,exports){
"use strict";
var async_1 = require('../scheduler/async');
var auditTime_1 = require('../operators/auditTime');
/**
 * Ignores source values for `duration` milliseconds, then emits the most recent
 * value from the source Observable, then repeats this process.
 *
 * <span class="informal">When it sees a source values, it ignores that plus
 * the next ones for `duration` milliseconds, and then it emits the most recent
 * value from the source.</span>
 *
 * <img src="./img/auditTime.png" width="100%">
 *
 * `auditTime` is similar to `throttleTime`, but emits the last value from the
 * silenced time window, instead of the first value. `auditTime` emits the most
 * recent value from the source Observable on the output Observable as soon as
 * its internal timer becomes disabled, and ignores source values while the
 * timer is enabled. Initially, the timer is disabled. As soon as the first
 * source value arrives, the timer is enabled. After `duration` milliseconds (or
 * the time unit determined internally by the optional `scheduler`) has passed,
 * the timer is disabled, then the most recent source value is emitted on the
 * output Observable, and this process repeats for the next source value.
 * Optionally takes a {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.auditTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} duration Time to wait before emitting the most recent source
 * value, measured in milliseconds or the time unit determined internally
 * by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the rate-limiting behavior.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method auditTime
 * @owner Observable
 */
function auditTime(duration, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return auditTime_1.auditTime(duration, scheduler)(this);
}
exports.auditTime = auditTime;

},{"../operators/auditTime":159,"../scheduler/async":213}],117:[function(require,module,exports){
"use strict";
var buffer_1 = require('../operators/buffer');
/**
 * Buffers the source Observable values until `closingNotifier` emits.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when another Observable emits.</span>
 *
 * <img src="./img/buffer.png" width="100%">
 *
 * Buffers the incoming Observable values until the given `closingNotifier`
 * Observable emits a value, at which point it emits the buffer on the output
 * Observable and starts a new buffer internally, awaiting the next time
 * `closingNotifier` emits.
 *
 * @example <caption>On every click, emit array of most recent interval events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var buffered = interval.buffer(clicks);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link window}
 *
 * @param {Observable<any>} closingNotifier An Observable that signals the
 * buffer to be emitted on the output Observable.
 * @return {Observable<T[]>} An Observable of buffers, which are arrays of
 * values.
 * @method buffer
 * @owner Observable
 */
function buffer(closingNotifier) {
    return buffer_1.buffer(closingNotifier)(this);
}
exports.buffer = buffer;

},{"../operators/buffer":160}],118:[function(require,module,exports){
"use strict";
var bufferCount_1 = require('../operators/bufferCount');
/**
 * Buffers the source Observable values until the size hits the maximum
 * `bufferSize` given.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when its size reaches `bufferSize`.</span>
 *
 * <img src="./img/bufferCount.png" width="100%">
 *
 * Buffers a number of values from the source Observable by `bufferSize` then
 * emits the buffer and clears it, and starts a new buffer each
 * `startBufferEvery` values. If `startBufferEvery` is not provided or is
 * `null`, then new buffers are started immediately at the start of the source
 * and when each buffer closes and is emitted.
 *
 * @example <caption>Emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>On every click, emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2, 1);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link pairwise}
 * @see {@link windowCount}
 *
 * @param {number} bufferSize The maximum size of the buffer emitted.
 * @param {number} [startBufferEvery] Interval at which to start a new buffer.
 * For example if `startBufferEvery` is `2`, then a new buffer will be started
 * on every other value from the source. A new buffer is started at the
 * beginning of the source by default.
 * @return {Observable<T[]>} An Observable of arrays of buffered values.
 * @method bufferCount
 * @owner Observable
 */
function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) { startBufferEvery = null; }
    return bufferCount_1.bufferCount(bufferSize, startBufferEvery)(this);
}
exports.bufferCount = bufferCount;

},{"../operators/bufferCount":161}],119:[function(require,module,exports){
"use strict";
var bufferWhen_1 = require('../operators/bufferWhen');
/**
 * Buffers the source Observable values, using a factory function of closing
 * Observables to determine when to close, emit, and reset the buffer.
 *
 * <span class="informal">Collects values from the past as an array. When it
 * starts collecting values, it calls a function that returns an Observable that
 * tells when to close the buffer and restart collecting.</span>
 *
 * <img src="./img/bufferWhen.png" width="100%">
 *
 * Opens a buffer immediately, then closes the buffer when the observable
 * returned by calling `closingSelector` function emits a value. When it closes
 * the buffer, it immediately opens a new buffer and repeats the process.
 *
 * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferWhen(() =>
 *   Rx.Observable.interval(1000 + Math.random() * 4000)
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link windowWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals buffer closure.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferWhen
 * @owner Observable
 */
function bufferWhen(closingSelector) {
    return bufferWhen_1.bufferWhen(closingSelector)(this);
}
exports.bufferWhen = bufferWhen;

},{"../operators/bufferWhen":162}],120:[function(require,module,exports){
"use strict";
var catchError_1 = require('../operators/catchError');
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @name catch
 * @owner Observable
 */
function _catch(selector) {
    return catchError_1.catchError(selector)(this);
}
exports._catch = _catch;

},{"../operators/catchError":163}],121:[function(require,module,exports){
"use strict";
var combineLatest_1 = require('../operators/combineLatest');
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from this Observable with values from
 * Observables passed as arguments. This is done by subscribing to each
 * Observable, in order, and collecting an array of each of the most recent
 * values any time any of the input Observables emits, then either taking that
 * array and passing it as arguments to an optional `project` function and
 * emitting the return value of that, or just emitting the array of recent
 * values directly if there is no `project` function.
 *
 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method combineLatest
 * @owner Observable
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return combineLatest_1.combineLatest.apply(void 0, observables)(this);
}
exports.combineLatest = combineLatest;

},{"../operators/combineLatest":164}],122:[function(require,module,exports){
"use strict";
var concat_1 = require('../operators/concat');
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return concat_1.concat.apply(void 0, observables)(this);
}
exports.concat = concat;

},{"../operators/concat":165}],123:[function(require,module,exports){
"use strict";
var async_1 = require('../scheduler/async');
var debounceTime_1 = require('../operators/debounceTime');
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return debounceTime_1.debounceTime(dueTime, scheduler)(this);
}
exports.debounceTime = debounceTime;

},{"../operators/debounceTime":167,"../scheduler/async":213}],124:[function(require,module,exports){
"use strict";
var async_1 = require('../scheduler/async');
var delay_1 = require('../operators/delay');
/**
 * Delays the emission of items from the source Observable by a given timeout or
 * until a given Date.
 *
 * <span class="informal">Time shifts each item by some specified amount of
 * milliseconds.</span>
 *
 * <img src="./img/delay.png" width="100%">
 *
 * If the delay argument is a Number, this operator time shifts the source
 * Observable by that amount of time expressed in milliseconds. The relative
 * time intervals between the values are preserved.
 *
 * If the delay argument is a Date, this operator time shifts the start of the
 * Observable execution until the given date occurs.
 *
 * @example <caption>Delay each click by one second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @example <caption>Delay all clicks until a future date happens</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var date = new Date('March 15, 2050 12:00:00'); // in the future
 * var delayedClicks = clicks.delay(date); // click emitted only after that date
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 *
 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
 * a `Date` until which the emission of the source items is delayed.
 * @param {Scheduler} [scheduler=async] The IScheduler to use for
 * managing the timers that handle the time-shift for each item.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified timeout or Date.
 * @method delay
 * @owner Observable
 */
function delay(delay, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return delay_1.delay(delay, scheduler)(this);
}
exports.delay = delay;

},{"../operators/delay":169,"../scheduler/async":213}],125:[function(require,module,exports){
"use strict";
var distinct_1 = require('../operators/distinct');
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
 *
 * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
 * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
 * source observable directly with an equality check against previous values.
 *
 * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
 *
 * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
 * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
 * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
 * that the internal `Set` can be "flushed", basically clearing it of values.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
 *   .distinct()
 *   .subscribe(x => console.log(x)); // 1, 2, 3, 4
 *
 * @example <caption>An example using a keySelector function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     .distinct((p: Person) => p.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 *
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [keySelector] Optional function to select which value you want to check as distinct.
 * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinct
 * @owner Observable
 */
function distinct(keySelector, flushes) {
    return distinct_1.distinct(keySelector, flushes)(this);
}
exports.distinct = distinct;

},{"../operators/distinct":170}],126:[function(require,module,exports){
"use strict";
var distinctUntilChanged_1 = require('../operators/distinctUntilChanged');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return distinctUntilChanged_1.distinctUntilChanged(compare, keySelector)(this);
}
exports.distinctUntilChanged = distinctUntilChanged;

},{"../operators/distinctUntilChanged":171}],127:[function(require,module,exports){
"use strict";
var tap_1 = require('../operators/tap');
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source as long as errors don't occur.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
function _do(nextOrObserver, error, complete) {
    return tap_1.tap(nextOrObserver, error, complete)(this);
}
exports._do = _do;

},{"../operators/tap":202}],128:[function(require,module,exports){
"use strict";
var expand_1 = require('../operators/expand');
/* tslint:enable:max-line-length */
/**
 * Recursively projects each source value to an Observable which is merged in
 * the output Observable.
 *
 * <span class="informal">It's similar to {@link mergeMap}, but applies the
 * projection function to every source value as well as every output value.
 * It's recursive.</span>
 *
 * <img src="./img/expand.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger. *Expand* will re-emit on the output
 * Observable every source value. Then, each output value is given to the
 * `project` function which returns an inner Observable to be merged on the
 * output Observable. Those output values resulting from the projection are also
 * given to the `project` function to produce new output values. This is how
 * *expand* behaves recursively.
 *
 * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var powersOfTwo = clicks
 *   .mapTo(1)
 *   .expand(x => Rx.Observable.of(2 * x).delay(1000))
 *   .take(10);
 * powersOfTwo.subscribe(x => console.log(x));
 *
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 *
 * @param {function(value: T, index: number) => Observable} project A function
 * that, when applied to an item emitted by the source or the output Observable,
 * returns an Observable.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
 * each projected inner Observable.
 * @return {Observable} An Observable that emits the source values and also
 * result of applying the projection function to each value emitted on the
 * output Observable and and merging the results of the Observables obtained
 * from this transformation.
 * @method expand
 * @owner Observable
 */
function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (scheduler === void 0) { scheduler = undefined; }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return expand_1.expand(project, concurrent, scheduler)(this);
}
exports.expand = expand;

},{"../operators/expand":172}],129:[function(require,module,exports){
"use strict";
var filter_1 = require('../operators/filter');
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return filter_1.filter(predicate, thisArg)(this);
}
exports.filter = filter;

},{"../operators/filter":173}],130:[function(require,module,exports){
"use strict";
var finalize_1 = require('../operators/finalize');
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback Function to be called when source terminates.
 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
function _finally(callback) {
    return finalize_1.finalize(callback)(this);
}
exports._finally = _finally;

},{"../operators/finalize":174}],131:[function(require,module,exports){
"use strict";
var first_1 = require('../operators/first');
/**
 * Emits only the first value (or the first value that meets some condition)
 * emitted by the source Observable.
 *
 * <span class="informal">Emits only the first value. Or emits only the first
 * value that passes some test.</span>
 *
 * <img src="./img/first.png" width="100%">
 *
 * If called with no arguments, `first` emits the first value of the source
 * Observable, then completes. If called with a `predicate` function, `first`
 * emits the first value of the source that matches the specified condition. It
 * may also take a `resultSelector` function to produce the output value from
 * the input value, and a `defaultValue` to emit in case the source completes
 * before it is able to emit a valid value. Throws an error if `defaultValue`
 * was not provided and a matching element is not found.
 *
 * @example <caption>Emit only the first click that happens on the DOM</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Emits the first click that happens on a DIV</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link take}
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
 * An optional function called with each item to test for condition matching.
 * @param {function(value: T, index: number): R} [resultSelector] A function to
 * produce the value on the output Observable based on the values
 * and the indices of the source Observable. The arguments passed to this
 * function are:
 * - `value`: the value that was emitted on the source.
 * - `index`: the "index" of the value from the source.
 * @param {R} [defaultValue] The default value emitted in case no valid value
 * was found on the source.
 * @return {Observable<T|R>} An Observable of the first item that matches the
 * condition.
 * @method first
 * @owner Observable
 */
function first(predicate, resultSelector, defaultValue) {
    return first_1.first(predicate, resultSelector, defaultValue)(this);
}
exports.first = first;

},{"../operators/first":175}],132:[function(require,module,exports){
"use strict";
var last_1 = require('../operators/last');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits only the last item emitted by the source Observable.
 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
 * the last item from the source Observable, the resulting Observable will emit the last item
 * from the source Observable that satisfies the predicate.
 *
 * <img src="./img/last.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {function} predicate - The condition any source emitted item has to satisfy.
 * @return {Observable} An Observable that emits only the last item satisfying the given condition
 * from the source, or an NoSuchElementException if no such items are emitted.
 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
 * @method last
 * @owner Observable
 */
function last(predicate, resultSelector, defaultValue) {
    return last_1.last(predicate, resultSelector, defaultValue)(this);
}
exports.last = last;

},{"../operators/last":176}],133:[function(require,module,exports){
"use strict";
var map_1 = require('../operators/map');
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    return map_1.map(project, thisArg)(this);
}
exports.map = map;

},{"../operators/map":177}],134:[function(require,module,exports){
"use strict";
var merge_1 = require('../operators/merge');
var merge_2 = require('../operators/merge');
exports.mergeStatic = merge_2.mergeStatic;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {ObservableInput} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} An Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return merge_1.merge.apply(void 0, observables)(this);
}
exports.merge = merge;

},{"../operators/merge":178}],135:[function(require,module,exports){
"use strict";
var mergeAll_1 = require('../operators/mergeAll');
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeAll_1.mergeAll(concurrent)(this);
}
exports.mergeAll = mergeAll;

},{"../operators/mergeAll":179}],136:[function(require,module,exports){
"use strict";
var mergeMap_1 = require('../operators/mergeMap');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(project, resultSelector, concurrent)(this);
}
exports.mergeMap = mergeMap;

},{"../operators/mergeMap":180}],137:[function(require,module,exports){
"use strict";
var pairwise_1 = require('../operators/pairwise');
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
function pairwise() {
    return pairwise_1.pairwise()(this);
}
exports.pairwise = pairwise;

},{"../operators/pairwise":183}],138:[function(require,module,exports){
"use strict";
var pluck_1 = require('../operators/pluck');
/**
 * Maps each source value (an object) to its specified nested property.
 *
 * <span class="informal">Like {@link map}, but meant only for picking one of
 * the nested properties of every emitted object.</span>
 *
 * <img src="./img/pluck.png" width="100%">
 *
 * Given a list of strings describing a path to an object property, retrieves
 * the value of a specified nested property from all values in the source
 * Observable. If a property can't be resolved, it will return `undefined` for
 * that value.
 *
 * @example <caption>Map every click to the tagName of the clicked target element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var tagNames = clicks.pluck('target', 'tagName');
 * tagNames.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {...string} properties The nested properties to pluck from each source
 * value (an object).
 * @return {Observable} A new Observable of property values from the source values.
 * @method pluck
 * @owner Observable
 */
function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i - 0] = arguments[_i];
    }
    return pluck_1.pluck.apply(void 0, properties)(this);
}
exports.pluck = pluck;

},{"../operators/pluck":184}],139:[function(require,module,exports){
"use strict";
var publish_1 = require('../operators/publish');
/* tslint:enable:max-line-length */
/**
 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
 * before it begins emitting items to those Observers that have subscribed to it.
 *
 * <img src="./img/publish.png" width="100%">
 *
 * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
 * as needed, without causing multiple subscriptions to the source sequence.
 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
 * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
 * @method publish
 * @owner Observable
 */
function publish(selector) {
    return publish_1.publish(selector)(this);
}
exports.publish = publish;

},{"../operators/publish":185}],140:[function(require,module,exports){
"use strict";
var publishReplay_1 = require('../operators/publishReplay');
/* tslint:enable:max-line-length */
/**
 * @param bufferSize
 * @param windowTime
 * @param selectorOrScheduler
 * @param scheduler
 * @return {Observable<T> | ConnectableObservable<T>}
 * @method publishReplay
 * @owner Observable
 */
function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
    return publishReplay_1.publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler)(this);
}
exports.publishReplay = publishReplay;

},{"../operators/publishReplay":186}],141:[function(require,module,exports){
"use strict";
var reduce_1 = require('../operators/reduce');
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns the
 * accumulated result when the source completes, given an optional seed value.
 *
 * <span class="informal">Combines together all values emitted on the source,
 * using an accumulator function that knows how to join a new source value into
 * the accumulation from the past.</span>
 *
 * <img src="./img/reduce.png" width="100%">
 *
 * Like
 * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
 * `reduce` applies an `accumulator` function against an accumulation and each
 * value of the source Observable (from the past) to reduce it to a single
 * value, emitted on the output Observable. Note that `reduce` will only emit
 * one value, only when the source Observable completes. It is equivalent to
 * applying operator {@link scan} followed by operator {@link last}.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events that happened in 5 seconds</caption>
 * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')
 *   .takeUntil(Rx.Observable.interval(5000));
 * var ones = clicksInFiveSeconds.mapTo(1);
 * var seed = 0;
 * var count = ones.reduce((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link count}
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link scan}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function
 * called on each source value.
 * @param {R} [seed] The initial accumulation value.
 * @return {Observable<R>} An Observable that emits a single value that is the
 * result of accumulating the values emitted by the source Observable.
 * @method reduce
 * @owner Observable
 */
function reduce(accumulator, seed) {
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length >= 2) {
        return reduce_1.reduce(accumulator, seed)(this);
    }
    return reduce_1.reduce(accumulator)(this);
}
exports.reduce = reduce;

},{"../operators/reduce":187}],142:[function(require,module,exports){
"use strict";
var retry_1 = require('../operators/retry');
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given
 * as a number parameter) rather than propagating the `error` call.
 *
 * <img src="./img/retry.png" width="100%">
 *
 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
 * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
 * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
 * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
 * @param {number} count - Number of retry attempts before failing.
 * @return {Observable} The source Observable modified with the retry logic.
 * @method retry
 * @owner Observable
 */
function retry(count) {
    if (count === void 0) { count = -1; }
    return retry_1.retry(count)(this);
}
exports.retry = retry;

},{"../operators/retry":189}],143:[function(require,module,exports){
"use strict";
var sample_1 = require('../operators/sample');
/**
 * Emits the most recently emitted value from the source Observable whenever
 * another Observable, the `notifier`, emits.
 *
 * <span class="informal">It's like {@link sampleTime}, but samples whenever
 * the `notifier` Observable emits something.</span>
 *
 * <img src="./img/sample.png" width="100%">
 *
 * Whenever the `notifier` Observable emits a value or completes, `sample`
 * looks at the source Observable and emits whichever value it has most recently
 * emitted since the previous sampling, unless the source has not emitted
 * anything since the previous sampling. The `notifier` is subscribed to as soon
 * as the output Observable is subscribed.
 *
 * @example <caption>On every click, sample the most recent "seconds" timer</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = seconds.sample(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {Observable<any>} notifier The Observable to use for sampling the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the results of sampling the
 * values emitted by the source Observable whenever the notifier Observable
 * emits value or completes.
 * @method sample
 * @owner Observable
 */
function sample(notifier) {
    return sample_1.sample(notifier)(this);
}
exports.sample = sample;

},{"../operators/sample":190}],144:[function(require,module,exports){
"use strict";
var scan_1 = require('../operators/scan');
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns each
 * intermediate result, with an optional seed value.
 *
 * <span class="informal">It's like {@link reduce}, but emits the current
 * accumulation whenever the source emits a value.</span>
 *
 * <img src="./img/scan.png" width="100%">
 *
 * Combines together all values emitted on the source, using an accumulator
 * function that knows how to join a new source value into the accumulation from
 * the past. Is similar to {@link reduce}, but emits the intermediate
 * accumulations.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var ones = clicks.mapTo(1);
 * var seed = 0;
 * var count = ones.scan((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link reduce}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator
 * The accumulator function called on each source value.
 * @param {T|R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method scan
 * @owner Observable
 */
function scan(accumulator, seed) {
    if (arguments.length >= 2) {
        return scan_1.scan(accumulator, seed)(this);
    }
    return scan_1.scan(accumulator)(this);
}
exports.scan = scan;

},{"../operators/scan":191}],145:[function(require,module,exports){
"use strict";
var share_1 = require('../operators/share');
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 *
 * This behaves similarly to .publish().refCount(), with a behavior difference when the source observable emits complete.
 * .publish().refCount() will not resubscribe to the original source, however .share() will resubscribe to the original source.
 * Observable.of("test").publish().refCount() will not re-emit "test" on new subscriptions, Observable.of("test").share() will
 * re-emit "test" to new subscriptions.
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
 * @method share
 * @owner Observable
 */
function share() {
    return share_1.share()(this);
}
exports.share = share;
;

},{"../operators/share":192}],146:[function(require,module,exports){
"use strict";
var skip_1 = require('../operators/skip');
/**
 * Returns an Observable that skips the first `count` items emitted by the source Observable.
 *
 * <img src="./img/skip.png" width="100%">
 *
 * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
 * @return {Observable} An Observable that skips values emitted by the source Observable.
 *
 * @method skip
 * @owner Observable
 */
function skip(count) {
    return skip_1.skip(count)(this);
}
exports.skip = skip;

},{"../operators/skip":193}],147:[function(require,module,exports){
"use strict";
var skipUntil_1 = require('../operators/skipUntil');
/**
 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
 *
 * <img src="./img/skipUntil.png" width="100%">
 *
 * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
 * be mirrored by the resulting Observable.
 * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
 * an item, then emits the remaining items.
 * @method skipUntil
 * @owner Observable
 */
function skipUntil(notifier) {
    return skipUntil_1.skipUntil(notifier)(this);
}
exports.skipUntil = skipUntil;

},{"../operators/skipUntil":194}],148:[function(require,module,exports){
"use strict";
var skipWhile_1 = require('../operators/skipWhile');
/**
 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
 * true, but emits all further source items as soon as the condition becomes false.
 *
 * <img src="./img/skipWhile.png" width="100%">
 *
 * @param {Function} predicate - A function to test each item emitted from the source Observable.
 * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the
 * specified predicate becomes false.
 * @method skipWhile
 * @owner Observable
 */
function skipWhile(predicate) {
    return skipWhile_1.skipWhile(predicate)(this);
}
exports.skipWhile = skipWhile;

},{"../operators/skipWhile":195}],149:[function(require,module,exports){
"use strict";
var startWith_1 = require('../operators/startWith');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    return startWith_1.startWith.apply(void 0, array)(this);
}
exports.startWith = startWith;

},{"../operators/startWith":196}],150:[function(require,module,exports){
"use strict";
var switchMap_1 = require('../operators/switchMap');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return switchMap_1.switchMap(project, resultSelector)(this);
}
exports.switchMap = switchMap;

},{"../operators/switchMap":197}],151:[function(require,module,exports){
"use strict";
var take_1 = require('../operators/take');
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take(count) {
    return take_1.take(count)(this);
}
exports.take = take;

},{"../operators/take":198}],152:[function(require,module,exports){
"use strict";
var takeUntil_1 = require('../operators/takeUntil');
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value, the output Observable stops mirroring the source Observable
 * and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return takeUntil_1.takeUntil(notifier)(this);
}
exports.takeUntil = takeUntil;

},{"../operators/takeUntil":200}],153:[function(require,module,exports){
"use strict";
var takeWhile_1 = require('../operators/takeWhile');
/**
 * Emits values emitted by the source Observable so long as each value satisfies
 * the given `predicate`, and then completes as soon as this `predicate` is not
 * satisfied.
 *
 * <span class="informal">Takes values from the source only while they pass the
 * condition given. When the first value does not satisfy, it completes.</span>
 *
 * <img src="./img/takeWhile.png" width="100%">
 *
 * `takeWhile` subscribes and begins mirroring the source Observable. Each value
 * emitted on the source is given to the `predicate` function which returns a
 * boolean, representing a condition to be satisfied by the source values. The
 * output Observable emits the source values until such time as the `predicate`
 * returns false, at which point `takeWhile` stops mirroring the source
 * Observable and completes the output Observable.
 *
 * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.takeWhile(ev => ev.clientX > 200);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates a value emitted by the source Observable and returns a boolean.
 * Also takes the (zero-based) index as the second argument.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable so long as each value satisfies the condition defined by the
 * `predicate`, then completes.
 * @method takeWhile
 * @owner Observable
 */
function takeWhile(predicate) {
    return takeWhile_1.takeWhile(predicate)(this);
}
exports.takeWhile = takeWhile;

},{"../operators/takeWhile":201}],154:[function(require,module,exports){
"use strict";
var async_1 = require('../scheduler/async');
var throttle_1 = require('../operators/throttle');
var throttleTime_1 = require('../operators/throttleTime');
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for `duration` milliseconds, then repeats this process.
 *
 * <span class="informal">Lets a value pass, then ignores source values for the
 * next `duration` milliseconds.</span>
 *
 * <img src="./img/throttleTime.png" width="100%">
 *
 * `throttleTime` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled. After `duration` milliseconds (or the time unit determined
 * internally by the optional `scheduler`) has passed, the timer is disabled,
 * and this process repeats for the next source value. Optionally takes a
 * {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {number} duration Time to wait before emitting another value after
 * emitting the last value, measured in milliseconds or the time unit determined
 * internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the throttling.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttleTime
 * @owner Observable
 */
function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }
    return throttleTime_1.throttleTime(duration, scheduler, config)(this);
}
exports.throttleTime = throttleTime;

},{"../operators/throttle":203,"../operators/throttleTime":204,"../scheduler/async":213}],155:[function(require,module,exports){
"use strict";
var async_1 = require('../scheduler/async');
var timeout_1 = require('../operators/timeout');
/**
 *
 * Errors if Observable does not emit a value in given time span.
 *
 * <span class="informal">Timeouts on Observable that doesn't emit values fast enough.</span>
 *
 * <img src="./img/timeout.png" width="100%">
 *
 * `timeout` operator accepts as an argument either a number or a Date.
 *
 * If number was provided, it returns an Observable that behaves like a source
 * Observable, unless there is a period of time where there is no value emitted.
 * So if you provide `100` as argument and first value comes after 50ms from
 * the moment of subscription, this value will be simply re-emitted by the resulting
 * Observable. If however after that 100ms passes without a second value being emitted,
 * stream will end with an error and source Observable will be unsubscribed.
 * These checks are performed throughout whole lifecycle of Observable - from the moment
 * it was subscribed to, until it completes or errors itself. Thus every value must be
 * emitted within specified period since previous value.
 *
 * If provided argument was Date, returned Observable behaves differently. It throws
 * if Observable did not complete before provided Date. This means that periods between
 * emission of particular values do not matter in this case. If Observable did not complete
 * before provided Date, source Observable will be unsubscribed. Other than that, resulting
 * stream behaves just as source Observable.
 *
 * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)
 * when returned Observable will check if source stream emitted value or completed.
 *
 * @example <caption>Check if ticks are emitted within certain timespan</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(1100) // Let's use bigger timespan to be safe,
 *                       // since `interval` might fire a bit later then scheduled.
 * .subscribe(
 *     value => console.log(value), // Will emit numbers just as regular `interval` would.
 *     err => console.log(err) // Will never be called.
 * );
 *
 * seconds.timeout(900).subscribe(
 *     value => console.log(value), // Will never be called.
 *     err => console.log(err) // Will emit error before even first value is emitted,
 *                             // since it did not arrive within 900ms period.
 * );
 *
 * @example <caption>Use Date to check if Observable completed</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(new Date("December 17, 2020 03:24:00"))
 * .subscribe(
 *     value => console.log(value), // Will emit values as regular `interval` would
 *                                  // until December 17, 2020 at 03:24:00.
 *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,
 *                             // since Observable did not complete by then.
 * );
 *
 * @see {@link timeoutWith}
 *
 * @param {number|Date} due Number specifying period within which Observable must emit values
 *                          or Date specifying before when Observable should complete
 * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
 * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.
 * @method timeout
 * @owner Observable
 */
function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return timeout_1.timeout(due, scheduler)(this);
}
exports.timeout = timeout;

},{"../operators/timeout":205,"../scheduler/async":213}],156:[function(require,module,exports){
"use strict";
var withLatestFrom_1 = require('../operators/withLatestFrom');
/* tslint:enable:max-line-length */
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    return withLatestFrom_1.withLatestFrom.apply(void 0, args)(this);
}
exports.withLatestFrom = withLatestFrom;

},{"../operators/withLatestFrom":206}],157:[function(require,module,exports){
"use strict";
var zip_1 = require('../operators/zip');
/* tslint:enable:max-line-length */
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
function zipProto() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return zip_1.zip.apply(void 0, observables)(this);
}
exports.zipProto = zipProto;

},{"../operators/zip":207}],158:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tryCatch_1 = require('../util/tryCatch');
var errorObject_1 = require('../util/errorObject');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Ignores source values for a duration determined by another Observable, then
 * emits the most recent value from the source Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link auditTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/audit.png" width="100%">
 *
 * `audit` is similar to `throttle`, but emits the last value from the silenced
 * time window, instead of the first value. `audit` emits the most recent value
 * from the source Observable on the output Observable as soon as its internal
 * timer becomes disabled, and ignores source values while the timer is enabled.
 * Initially, the timer is disabled. As soon as the first source value arrives,
 * the timer is enabled by calling the `durationSelector` function with the
 * source value, which returns the "duration" Observable. When the duration
 * Observable emits a value or completes, the timer is disabled, then the most
 * recent source value is emitted on the output Observable, and this process
 * repeats for the next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.audit(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttle}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration, returned as an Observable or a Promise.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method audit
 * @owner Observable
 */
function audit(durationSelector) {
    return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
    };
}
exports.audit = audit;
var AuditOperator = (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AuditSubscriber = (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);
            if (duration === errorObject_1.errorObject) {
                this.destination.error(errorObject_1.errorObject.e);
            }
            else {
                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);
                if (innerSubscription.closed) {
                    this.clearThrottle();
                }
                else {
                    this.add(this.throttled = innerSubscription);
                }
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":31,"../util/errorObject":225,"../util/subscribeToResult":238,"../util/tryCatch":240}],159:[function(require,module,exports){
"use strict";
var async_1 = require('../scheduler/async');
var audit_1 = require('./audit');
var timer_1 = require('../observable/timer');
/**
 * Ignores source values for `duration` milliseconds, then emits the most recent
 * value from the source Observable, then repeats this process.
 *
 * <span class="informal">When it sees a source values, it ignores that plus
 * the next ones for `duration` milliseconds, and then it emits the most recent
 * value from the source.</span>
 *
 * <img src="./img/auditTime.png" width="100%">
 *
 * `auditTime` is similar to `throttleTime`, but emits the last value from the
 * silenced time window, instead of the first value. `auditTime` emits the most
 * recent value from the source Observable on the output Observable as soon as
 * its internal timer becomes disabled, and ignores source values while the
 * timer is enabled. Initially, the timer is disabled. As soon as the first
 * source value arrives, the timer is enabled. After `duration` milliseconds (or
 * the time unit determined internally by the optional `scheduler`) has passed,
 * the timer is disabled, then the most recent source value is emitted on the
 * output Observable, and this process repeats for the next source value.
 * Optionally takes a {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.auditTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} duration Time to wait before emitting the most recent source
 * value, measured in milliseconds or the time unit determined internally
 * by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the rate-limiting behavior.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method auditTime
 * @owner Observable
 */
function auditTime(duration, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });
}
exports.auditTime = auditTime;

},{"../observable/timer":114,"../scheduler/async":213,"./audit":158}],160:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Buffers the source Observable values until `closingNotifier` emits.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when another Observable emits.</span>
 *
 * <img src="./img/buffer.png" width="100%">
 *
 * Buffers the incoming Observable values until the given `closingNotifier`
 * Observable emits a value, at which point it emits the buffer on the output
 * Observable and starts a new buffer internally, awaiting the next time
 * `closingNotifier` emits.
 *
 * @example <caption>On every click, emit array of most recent interval events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var buffered = interval.buffer(clicks);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link window}
 *
 * @param {Observable<any>} closingNotifier An Observable that signals the
 * buffer to be emitted on the output Observable.
 * @return {Observable<T[]>} An Observable of buffers, which are arrays of
 * values.
 * @method buffer
 * @owner Observable
 */
function buffer(closingNotifier) {
    return function bufferOperatorFunction(source) {
        return source.lift(new BufferOperator(closingNotifier));
    };
}
exports.buffer = buffer;
var BufferOperator = (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferSubscriber = (function (_super) {
    __extends(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        _super.call(this, destination);
        this.buffer = [];
        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":31,"../util/subscribeToResult":238}],161:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Buffers the source Observable values until the size hits the maximum
 * `bufferSize` given.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when its size reaches `bufferSize`.</span>
 *
 * <img src="./img/bufferCount.png" width="100%">
 *
 * Buffers a number of values from the source Observable by `bufferSize` then
 * emits the buffer and clears it, and starts a new buffer each
 * `startBufferEvery` values. If `startBufferEvery` is not provided or is
 * `null`, then new buffers are started immediately at the start of the source
 * and when each buffer closes and is emitted.
 *
 * @example <caption>Emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>On every click, emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2, 1);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link pairwise}
 * @see {@link windowCount}
 *
 * @param {number} bufferSize The maximum size of the buffer emitted.
 * @param {number} [startBufferEvery] Interval at which to start a new buffer.
 * For example if `startBufferEvery` is `2`, then a new buffer will be started
 * on every other value from the source. A new buffer is started at the
 * beginning of the source by default.
 * @return {Observable<T[]>} An Observable of arrays of buffered values.
 * @method bufferCount
 * @owner Observable
 */
function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) { startBufferEvery = null; }
    return function bufferCountOperatorFunction(source) {
        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
    };
}
exports.bufferCount = bufferCount;
var BufferCountOperator = (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferCountSubscriber = (function (_super) {
    __extends(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        _super.call(this, destination);
        this.bufferSize = bufferSize;
        this.buffer = [];
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber_1.Subscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferSkipCountSubscriber = (function (_super) {
    __extends(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        _super.call(this, destination);
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        this.buffers = [];
        this.count = 0;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36}],162:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('../Subscription');
var tryCatch_1 = require('../util/tryCatch');
var errorObject_1 = require('../util/errorObject');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Buffers the source Observable values, using a factory function of closing
 * Observables to determine when to close, emit, and reset the buffer.
 *
 * <span class="informal">Collects values from the past as an array. When it
 * starts collecting values, it calls a function that returns an Observable that
 * tells when to close the buffer and restart collecting.</span>
 *
 * <img src="./img/bufferWhen.png" width="100%">
 *
 * Opens a buffer immediately, then closes the buffer when the observable
 * returned by calling `closingSelector` function emits a value. When it closes
 * the buffer, it immediately opens a new buffer and repeats the process.
 *
 * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferWhen(() =>
 *   Rx.Observable.interval(1000 + Math.random() * 4000)
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link windowWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals buffer closure.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferWhen
 * @owner Observable
 */
function bufferWhen(closingSelector) {
    return function (source) {
        return source.lift(new BufferWhenOperator(closingSelector));
    };
}
exports.bufferWhen = bufferWhen;
var BufferWhenOperator = (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferWhenSubscriber = (function (_super) {
    __extends(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        _super.call(this, destination);
        this.closingSelector = closingSelector;
        this.subscribing = false;
        this.openBuffer();
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject_1.errorObject) {
            this.error(errorObject_1.errorObject.e);
        }
        else {
            closingSubscription = new Subscription_1.Subscription();
            this.closingSubscription = closingSubscription;
            this.add(closingSubscription);
            this.subscribing = true;
            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
            this.subscribing = false;
        }
    };
    return BufferWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":31,"../Subscription":37,"../util/errorObject":225,"../util/subscribeToResult":238,"../util/tryCatch":240}],163:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @name catchError
 */
function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
exports.catchError = catchError;
var CatchOperator = (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":31,"../util/subscribeToResult":238}],164:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = require('../observable/ArrayObservable');
var isArray_1 = require('../util/isArray');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
var none = {};
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from this Observable with values from
 * Observables passed as arguments. This is done by subscribing to each
 * Observable, in order, and collecting an array of each of the most recent
 * values any time any of the input Observables emits, then either taking that
 * array and passing it as arguments to an optional `project` function and
 * emitting the return value of that, or just emitting the array of recent
 * values directly if there is no `project` function.
 *
 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method combineLatest
 * @owner Observable
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project)); };
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = (function () {
    function CombineLatestOperator(project) {
        this.project = project;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CombineLatestSubscriber = (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, project) {
        _super.call(this, destination);
        this.project = project;
        this.active = 0;
        this.values = [];
        this.observables = [];
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(none);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === none ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.project) {
                this._tryProject(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryProject = function (values) {
        var result;
        try {
            result = this.project.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;

},{"../OuterSubscriber":31,"../observable/ArrayObservable":93,"../util/isArray":227,"../util/subscribeToResult":238}],165:[function(require,module,exports){
"use strict";
var concat_1 = require('../observable/concat');
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };
}
exports.concat = concat;

},{"../observable/concat":105}],166:[function(require,module,exports){
"use strict";
var mergeAll_1 = require('./mergeAll');
/**
 * Converts a higher-order Observable into a first-order Observable by
 * concatenating the inner Observables in order.
 *
 * <span class="informal">Flattens an Observable-of-Observables by putting one
 * inner Observable after the other.</span>
 *
 * <img src="./img/concatAll.png" width="100%">
 *
 * Joins every Observable emitted by the source (a higher-order Observable), in
 * a serial fashion. It subscribes to each inner Observable only after the
 * previous inner Observable has completed, and merges all of their values into
 * the returned observable.
 *
 * __Warning:__ If the source Observable emits Observables quickly and
 * endlessly, and the inner Observables it emits generally complete slower than
 * the source emits, you can run into memory issues as the incoming Observables
 * collect in an unbounded buffer.
 *
 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
 * var firstOrder = higherOrder.concatAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link combineAll}
 * @see {@link concat}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable emitting values from all the inner
 * Observables concatenated.
 * @method concatAll
 * @owner Observable
 */
function concatAll() {
    return mergeAll_1.mergeAll(1);
}
exports.concatAll = concatAll;

},{"./mergeAll":179}],167:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var async_1 = require('../scheduler/async');
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}

},{"../Subscriber":36,"../scheduler/async":213}],168:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Emits a given value if the source Observable completes without emitting any
 * `next` value, otherwise mirrors the source Observable.
 *
 * <span class="informal">If the source Observable turns out to be empty, then
 * this operator will emit a default value.</span>
 *
 * <img src="./img/defaultIfEmpty.png" width="100%">
 *
 * `defaultIfEmpty` emits the values emitted by the source Observable or a
 * specified default value if the source Observable is empty (completes without
 * having emitted any `next` value).
 *
 * @example <caption>If no clicks happen in 5 seconds, then emit "no clicks"</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
 * var result = clicksBeforeFive.defaultIfEmpty('no clicks');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link empty}
 * @see {@link last}
 *
 * @param {any} [defaultValue=null] The default value used if the source
 * Observable is empty.
 * @return {Observable} An Observable that emits either the specified
 * `defaultValue` if the source Observable emits no items, or the values emitted
 * by the source Observable.
 * @method defaultIfEmpty
 * @owner Observable
 */
function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) { defaultValue = null; }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
exports.defaultIfEmpty = defaultIfEmpty;
var DefaultIfEmptyOperator = (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DefaultIfEmptySubscriber = (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        _super.call(this, destination);
        this.defaultValue = defaultValue;
        this.isEmpty = true;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36}],169:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = require('../scheduler/async');
var isDate_1 = require('../util/isDate');
var Subscriber_1 = require('../Subscriber');
var Notification_1 = require('../Notification');
/**
 * Delays the emission of items from the source Observable by a given timeout or
 * until a given Date.
 *
 * <span class="informal">Time shifts each item by some specified amount of
 * milliseconds.</span>
 *
 * <img src="./img/delay.png" width="100%">
 *
 * If the delay argument is a Number, this operator time shifts the source
 * Observable by that amount of time expressed in milliseconds. The relative
 * time intervals between the values are preserved.
 *
 * If the delay argument is a Date, this operator time shifts the start of the
 * Observable execution until the given date occurs.
 *
 * @example <caption>Delay each click by one second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @example <caption>Delay all clicks until a future date happens</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var date = new Date('March 15, 2050 12:00:00'); // in the future
 * var delayedClicks = clicks.delay(date); // click emitted only after that date
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 *
 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
 * a `Date` until which the emission of the source items is delayed.
 * @param {Scheduler} [scheduler=async] The IScheduler to use for
 * managing the timers that handle the time-shift for each item.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified timeout or Date.
 * @method delay
 * @owner Observable
 */
function delay(delay, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
exports.delay = delay;
var DelayOperator = (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelaySubscriber = (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        _super.call(this, destination);
        this.delay = delay;
        this.scheduler = scheduler;
        this.queue = [];
        this.active = false;
        this.errored = false;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber));
var DelayMessage = (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());

},{"../Notification":28,"../Subscriber":36,"../scheduler/async":213,"../util/isDate":229}],170:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
var Set_1 = require('../util/Set');
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
 *
 * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
 * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
 * source observable directly with an equality check against previous values.
 *
 * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
 *
 * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
 * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
 * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
 * that the internal `Set` can be "flushed", basically clearing it of values.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
 *   .distinct()
 *   .subscribe(x => console.log(x)); // 1, 2, 3, 4
 *
 * @example <caption>An example using a keySelector function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     .distinct((p: Person) => p.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 *
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [keySelector] Optional function to select which value you want to check as distinct.
 * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinct
 * @owner Observable
 */
function distinct(keySelector, flushes) {
    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };
}
exports.distinct = distinct;
var DistinctOperator = (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctSubscriber = (function (_super) {
    __extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.values = new Set_1.Set();
        if (flushes) {
            this.add(subscribeToResult_1.subscribeToResult(this, flushes));
        }
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.DistinctSubscriber = DistinctSubscriber;

},{"../OuterSubscriber":31,"../util/Set":222,"../util/subscribeToResult":238}],171:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var tryCatch_1 = require('../util/tryCatch');
var errorObject_1 = require('../util/errorObject');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1.tryCatch(this.keySelector)(value);
            if (key === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
            if (result === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36,"../util/errorObject":225,"../util/tryCatch":240}],172:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tryCatch_1 = require('../util/tryCatch');
var errorObject_1 = require('../util/errorObject');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Recursively projects each source value to an Observable which is merged in
 * the output Observable.
 *
 * <span class="informal">It's similar to {@link mergeMap}, but applies the
 * projection function to every source value as well as every output value.
 * It's recursive.</span>
 *
 * <img src="./img/expand.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger. *Expand* will re-emit on the output
 * Observable every source value. Then, each output value is given to the
 * `project` function which returns an inner Observable to be merged on the
 * output Observable. Those output values resulting from the projection are also
 * given to the `project` function to produce new output values. This is how
 * *expand* behaves recursively.
 *
 * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var powersOfTwo = clicks
 *   .mapTo(1)
 *   .expand(x => Rx.Observable.of(2 * x).delay(1000))
 *   .take(10);
 * powersOfTwo.subscribe(x => console.log(x));
 *
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 *
 * @param {function(value: T, index: number) => Observable} project A function
 * that, when applied to an item emitted by the source or the output Observable,
 * returns an Observable.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
 * each projected inner Observable.
 * @return {Observable} An Observable that emits the source values and also
 * result of applying the projection function to each value emitted on the
 * output Observable and and merging the results of the Observables obtained
 * from this transformation.
 * @method expand
 * @owner Observable
 */
function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (scheduler === void 0) { scheduler = undefined; }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };
}
exports.expand = expand;
var ExpandOperator = (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());
exports.ExpandOperator = ExpandOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ExpandSubscriber = (function (_super) {
    __extends(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        _super.call(this, destination);
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
        this.index = 0;
        this.active = 0;
        this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            this.buffer = [];
        }
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            var result = tryCatch_1.tryCatch(this.project)(value, index);
            if (result === errorObject_1.errorObject) {
                destination.error(errorObject_1.errorObject.e);
            }
            else if (!this.scheduler) {
                this.subscribeToProjection(result, value, index);
            }
            else {
                var state = { subscriber: this, result: result, value: value, index: index };
                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.ExpandSubscriber = ExpandSubscriber;

},{"../OuterSubscriber":31,"../util/errorObject":225,"../util/subscribeToResult":238,"../util/tryCatch":240}],173:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
exports.filter = filter;
var FilterOperator = (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36}],174:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var Subscription_1 = require('../Subscription');
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback Function to be called when source terminates.
 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
exports.finalize = finalize;
var FinallyOperator = (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FinallySubscriber = (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        _super.call(this, destination);
        this.add(new Subscription_1.Subscription(callback));
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36,"../Subscription":37}],175:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var EmptyError_1 = require('../util/EmptyError');
/**
 * Emits only the first value (or the first value that meets some condition)
 * emitted by the source Observable.
 *
 * <span class="informal">Emits only the first value. Or emits only the first
 * value that passes some test.</span>
 *
 * <img src="./img/first.png" width="100%">
 *
 * If called with no arguments, `first` emits the first value of the source
 * Observable, then completes. If called with a `predicate` function, `first`
 * emits the first value of the source that matches the specified condition. It
 * may also take a `resultSelector` function to produce the output value from
 * the input value, and a `defaultValue` to emit in case the source completes
 * before it is able to emit a valid value. Throws an error if `defaultValue`
 * was not provided and a matching element is not found.
 *
 * @example <caption>Emit only the first click that happens on the DOM</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Emits the first click that happens on a DIV</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link take}
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
 * An optional function called with each item to test for condition matching.
 * @param {function(value: T, index: number): R} [resultSelector] A function to
 * produce the value on the output Observable based on the values
 * and the indices of the source Observable. The arguments passed to this
 * function are:
 * - `value`: the value that was emitted on the source.
 * - `index`: the "index" of the value from the source.
 * @param {R} [defaultValue] The default value emitted in case no valid value
 * was found on the source.
 * @return {Observable<T|R>} An Observable of the first item that matches the
 * condition.
 * @method first
 * @owner Observable
 */
function first(predicate, resultSelector, defaultValue) {
    return function (source) { return source.lift(new FirstOperator(predicate, resultSelector, defaultValue, source)); };
}
exports.first = first;
var FirstOperator = (function () {
    function FirstOperator(predicate, resultSelector, defaultValue, source) {
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
    }
    FirstOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
    };
    return FirstOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FirstSubscriber = (function (_super) {
    __extends(FirstSubscriber, _super);
    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
        this.index = 0;
        this.hasCompleted = false;
        this._emitted = false;
    }
    FirstSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this._tryPredicate(value, index);
        }
        else {
            this._emit(value, index);
        }
    };
    FirstSubscriber.prototype._tryPredicate = function (value, index) {
        var result;
        try {
            result = this.predicate(value, index, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this._emit(value, index);
        }
    };
    FirstSubscriber.prototype._emit = function (value, index) {
        if (this.resultSelector) {
            this._tryResultSelector(value, index);
            return;
        }
        this._emitFinal(value);
    };
    FirstSubscriber.prototype._tryResultSelector = function (value, index) {
        var result;
        try {
            result = this.resultSelector(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this._emitFinal(result);
    };
    FirstSubscriber.prototype._emitFinal = function (value) {
        var destination = this.destination;
        if (!this._emitted) {
            this._emitted = true;
            destination.next(value);
            destination.complete();
            this.hasCompleted = true;
        }
    };
    FirstSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
            destination.next(this.defaultValue);
            destination.complete();
        }
        else if (!this.hasCompleted) {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return FirstSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36,"../util/EmptyError":220}],176:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var EmptyError_1 = require('../util/EmptyError');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits only the last item emitted by the source Observable.
 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
 * the last item from the source Observable, the resulting Observable will emit the last item
 * from the source Observable that satisfies the predicate.
 *
 * <img src="./img/last.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {function} predicate - The condition any source emitted item has to satisfy.
 * @return {Observable} An Observable that emits only the last item satisfying the given condition
 * from the source, or an NoSuchElementException if no such items are emitted.
 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
 * @method last
 * @owner Observable
 */
function last(predicate, resultSelector, defaultValue) {
    return function (source) { return source.lift(new LastOperator(predicate, resultSelector, defaultValue, source)); };
}
exports.last = last;
var LastOperator = (function () {
    function LastOperator(predicate, resultSelector, defaultValue, source) {
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
    }
    LastOperator.prototype.call = function (observer, source) {
        return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
    };
    return LastOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var LastSubscriber = (function (_super) {
    __extends(LastSubscriber, _super);
    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
        this.hasValue = false;
        this.index = 0;
        if (typeof defaultValue !== 'undefined') {
            this.lastValue = defaultValue;
            this.hasValue = true;
        }
    }
    LastSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this._tryPredicate(value, index);
        }
        else {
            if (this.resultSelector) {
                this._tryResultSelector(value, index);
                return;
            }
            this.lastValue = value;
            this.hasValue = true;
        }
    };
    LastSubscriber.prototype._tryPredicate = function (value, index) {
        var result;
        try {
            result = this.predicate(value, index, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            if (this.resultSelector) {
                this._tryResultSelector(value, index);
                return;
            }
            this.lastValue = value;
            this.hasValue = true;
        }
    };
    LastSubscriber.prototype._tryResultSelector = function (value, index) {
        var result;
        try {
            result = this.resultSelector(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.lastValue = result;
        this.hasValue = true;
    };
    LastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.hasValue) {
            destination.next(this.lastValue);
            destination.complete();
        }
        else {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return LastSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36,"../util/EmptyError":220}],177:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36}],178:[function(require,module,exports){
"use strict";
var Observable_1 = require('../Observable');
var ArrayObservable_1 = require('../observable/ArrayObservable');
var mergeAll_1 = require('./mergeAll');
var isScheduler_1 = require('../util/isScheduler');
/* tslint:enable:max-line-length */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function (source) { return source.lift.call(mergeStatic.apply(void 0, [source].concat(observables))); };
}
exports.merge = merge;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (as arguments), and simply
 * forwards (without doing any transformation) all the values from all the input
 * Observables to the output Observable. The output Observable only completes
 * once all input Observables have completed. Any error delivered by an input
 * Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // timer will emit ascending values, one every second(1000ms) to console
 * // clicks logs MouseEvents to console everytime the "document" is clicked
 * // Since the two streams are merged you see these happening
 * // as they occur.
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - First timer1 and timer2 will run concurrently
 * // - timer1 will emit a value every 1000ms for 10 iterations
 * // - timer2 will emit a value every 2000ms for 6 iterations
 * // - after timer1 hits it's max iteration, timer2 will
 * //   continue, and timer3 will start to run concurrently with timer2
 * // - when timer2 hits it's max iteration it terminates, and
 * //   timer3 will continue to emit a value every 500ms until it is complete
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {...ObservableInput} observables Input Observables to merge together.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @static true
 * @name merge
 * @owner Observable
 */
function mergeStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return mergeAll_1.mergeAll(concurrent)(new ArrayObservable_1.ArrayObservable(observables, scheduler));
}
exports.mergeStatic = mergeStatic;

},{"../Observable":29,"../observable/ArrayObservable":93,"../util/isScheduler":234,"./mergeAll":179}],179:[function(require,module,exports){
"use strict";
var mergeMap_1 = require('./mergeMap');
var identity_1 = require('../util/identity');
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(identity_1.identity, null, concurrent);
}
exports.mergeAll = mergeAll;

},{"../util/identity":226,"./mergeMap":180}],180:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var subscribeToResult_1 = require('../util/subscribeToResult');
var OuterSubscriber_1 = require('../OuterSubscriber');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return function mergeMapOperatorFunction(source) {
        if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
            resultSelector = null;
        }
        return source.lift(new MergeMapOperator(project, resultSelector, concurrent));
    };
}
exports.mergeMap = mergeMap;
var MergeMapOperator = (function () {
    function MergeMapOperator(project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
    };
    return MergeMapOperator;
}());
exports.MergeMapOperator = MergeMapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeMapSubscriber = MergeMapSubscriber;

},{"../OuterSubscriber":31,"../util/subscribeToResult":238}],181:[function(require,module,exports){
"use strict";
var ConnectableObservable_1 = require('../observable/ConnectableObservable');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
 * which the source sequence's elements will be multicast to the selector function
 * or Subject to push source elements into.
 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable} An Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */
function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
exports.multicast = multicast;
var MulticastOperator = (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());
exports.MulticastOperator = MulticastOperator;

},{"../observable/ConnectableObservable":94}],182:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var Notification_1 = require('../Notification');
/**
 *
 * Re-emits all notifications from source Observable with specified scheduler.
 *
 * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
 *
 * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
 * notifications emitted by the source Observable. It might be useful, if you do not have control over
 * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
 *
 * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
 * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
 * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
 * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
 * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
 * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
 * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
 * little bit more, to ensure that they are emitted at expected moments.
 *
 * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
 * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
 * will delay all notifications - including error notifications - while `delay` will pass through error
 * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
 * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
 * for notification emissions in general.
 *
 * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
 * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
 *                                               // with async scheduler by default...
 *
 * intervals
 * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
 * .subscribe(val => {                           // scheduler to ensure smooth animation.
 *   someDiv.style.height = val + 'px';
 * });
 *
 * @see {@link delay}
 *
 * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.
 * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
 * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
 * but with provided scheduler.
 *
 * @method observeOn
 * @owner Observable
 */
function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;

},{"../Notification":28,"../Subscriber":36}],183:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
exports.pairwise = pairwise;
var PairwiseOperator = (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var PairwiseSubscriber = (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        _super.call(this, destination);
        this.hasPrev = false;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36}],184:[function(require,module,exports){
"use strict";
var map_1 = require('./map');
/**
 * Maps each source value (an object) to its specified nested property.
 *
 * <span class="informal">Like {@link map}, but meant only for picking one of
 * the nested properties of every emitted object.</span>
 *
 * <img src="./img/pluck.png" width="100%">
 *
 * Given a list of strings describing a path to an object property, retrieves
 * the value of a specified nested property from all values in the source
 * Observable. If a property can't be resolved, it will return `undefined` for
 * that value.
 *
 * @example <caption>Map every click to the tagName of the clicked target element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var tagNames = clicks.pluck('target', 'tagName');
 * tagNames.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {...string} properties The nested properties to pluck from each source
 * value (an object).
 * @return {Observable} A new Observable of property values from the source values.
 * @method pluck
 * @owner Observable
 */
function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i - 0] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return function (source) { return map_1.map(plucker(properties, length))(source); };
}
exports.pluck = pluck;
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp[props[i]];
            if (typeof p !== 'undefined') {
                currentProp = p;
            }
            else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}

},{"./map":177}],185:[function(require,module,exports){
"use strict";
var Subject_1 = require('../Subject');
var multicast_1 = require('./multicast');
/* tslint:enable:max-line-length */
/**
 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
 * before it begins emitting items to those Observers that have subscribed to it.
 *
 * <img src="./img/publish.png" width="100%">
 *
 * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
 * as needed, without causing multiple subscriptions to the source sequence.
 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
 * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
 * @method publish
 * @owner Observable
 */
function publish(selector) {
    return selector ?
        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :
        multicast_1.multicast(new Subject_1.Subject());
}
exports.publish = publish;

},{"../Subject":34,"./multicast":181}],186:[function(require,module,exports){
"use strict";
var ReplaySubject_1 = require('../ReplaySubject');
var multicast_1 = require('./multicast');
/* tslint:enable:max-line-length */
function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
        scheduler = selectorOrScheduler;
    }
    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
    var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
    return function (source) { return multicast_1.multicast(function () { return subject; }, selector)(source); };
}
exports.publishReplay = publishReplay;

},{"../ReplaySubject":32,"./multicast":181}],187:[function(require,module,exports){
"use strict";
var scan_1 = require('./scan');
var takeLast_1 = require('./takeLast');
var defaultIfEmpty_1 = require('./defaultIfEmpty');
var pipe_1 = require('../util/pipe');
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns the
 * accumulated result when the source completes, given an optional seed value.
 *
 * <span class="informal">Combines together all values emitted on the source,
 * using an accumulator function that knows how to join a new source value into
 * the accumulation from the past.</span>
 *
 * <img src="./img/reduce.png" width="100%">
 *
 * Like
 * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
 * `reduce` applies an `accumulator` function against an accumulation and each
 * value of the source Observable (from the past) to reduce it to a single
 * value, emitted on the output Observable. Note that `reduce` will only emit
 * one value, only when the source Observable completes. It is equivalent to
 * applying operator {@link scan} followed by operator {@link last}.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events that happened in 5 seconds</caption>
 * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')
 *   .takeUntil(Rx.Observable.interval(5000));
 * var ones = clicksInFiveSeconds.mapTo(1);
 * var seed = 0;
 * var count = ones.reduce((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link count}
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link scan}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function
 * called on each source value.
 * @param {R} [seed] The initial accumulation value.
 * @return {Observable<R>} An Observable that emits a single value that is the
 * result of accumulating the values emitted by the source Observable.
 * @method reduce
 * @owner Observable
 */
function reduce(accumulator, seed) {
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return pipe_1.pipe(scan_1.scan(function (acc, value, index) {
            return accumulator(acc, value, index + 1);
        }), takeLast_1.takeLast(1))(source);
    };
}
exports.reduce = reduce;

},{"../util/pipe":236,"./defaultIfEmpty":168,"./scan":191,"./takeLast":199}],188:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
exports.refCount = refCount;
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36}],189:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given
 * as a number parameter) rather than propagating the `error` call.
 *
 * <img src="./img/retry.png" width="100%">
 *
 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
 * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
 * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
 * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
 * @param {number} count - Number of retry attempts before failing.
 * @return {Observable} The source Observable modified with the retry logic.
 * @method retry
 * @owner Observable
 */
function retry(count) {
    if (count === void 0) { count = -1; }
    return function (source) { return source.lift(new RetryOperator(count, source)); };
}
exports.retry = retry;
var RetryOperator = (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetrySubscriber = (function (_super) {
    __extends(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        _super.call(this, destination);
        this.count = count;
        this.source = source;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36}],190:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Emits the most recently emitted value from the source Observable whenever
 * another Observable, the `notifier`, emits.
 *
 * <span class="informal">It's like {@link sampleTime}, but samples whenever
 * the `notifier` Observable emits something.</span>
 *
 * <img src="./img/sample.png" width="100%">
 *
 * Whenever the `notifier` Observable emits a value or completes, `sample`
 * looks at the source Observable and emits whichever value it has most recently
 * emitted since the previous sampling, unless the source has not emitted
 * anything since the previous sampling. The `notifier` is subscribed to as soon
 * as the output Observable is subscribed.
 *
 * @example <caption>On every click, sample the most recent "seconds" timer</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = seconds.sample(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {Observable<any>} notifier The Observable to use for sampling the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the results of sampling the
 * values emitted by the source Observable whenever the notifier Observable
 * emits value or completes.
 * @method sample
 * @owner Observable
 */
function sample(notifier) {
    return function (source) { return source.lift(new SampleOperator(notifier)); };
}
exports.sample = sample;
var SampleOperator = (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));
        return subscription;
    };
    return SampleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleSubscriber = (function (_super) {
    __extends(SampleSubscriber, _super);
    function SampleSubscriber() {
        _super.apply(this, arguments);
        this.hasValue = false;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":31,"../util/subscribeToResult":238}],191:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns each
 * intermediate result, with an optional seed value.
 *
 * <span class="informal">It's like {@link reduce}, but emits the current
 * accumulation whenever the source emits a value.</span>
 *
 * <img src="./img/scan.png" width="100%">
 *
 * Combines together all values emitted on the source, using an accumulator
 * function that knows how to join a new source value into the accumulation from
 * the past. Is similar to {@link reduce}, but emits the intermediate
 * accumulations.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var ones = clicks.mapTo(1);
 * var seed = 0;
 * var count = ones.scan((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link reduce}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator
 * The accumulator function called on each source value.
 * @param {T|R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method scan
 * @owner Observable
 */
function scan(accumulator, seed) {
    var hasSeed = false;
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
exports.scan = scan;
var ScanOperator = (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) { hasSeed = false; }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ScanSubscriber = (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this._seed = _seed;
        this.hasSeed = hasSeed;
        this.index = 0;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36}],192:[function(require,module,exports){
"use strict";
var multicast_1 = require('./multicast');
var refCount_1 = require('./refCount');
var Subject_1 = require('../Subject');
function shareSubjectFactory() {
    return new Subject_1.Subject();
}
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for .multicast(() => new Subject()).refCount().
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
 * @method share
 * @owner Observable
 */
function share() {
    return function (source) { return refCount_1.refCount()(multicast_1.multicast(shareSubjectFactory)(source)); };
}
exports.share = share;
;

},{"../Subject":34,"./multicast":181,"./refCount":188}],193:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Returns an Observable that skips the first `count` items emitted by the source Observable.
 *
 * <img src="./img/skip.png" width="100%">
 *
 * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
 * @return {Observable} An Observable that skips values emitted by the source Observable.
 *
 * @method skip
 * @owner Observable
 */
function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
exports.skip = skip;
var SkipOperator = (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipSubscriber = (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36}],194:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
 *
 * <img src="./img/skipUntil.png" width="100%">
 *
 * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
 * be mirrored by the resulting Observable.
 * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
 * an item, then emits the remaining items.
 * @method skipUntil
 * @owner Observable
 */
function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
exports.skipUntil = skipUntil;
var SkipUntilOperator = (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));
    };
    return SkipUntilOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipUntilSubscriber = (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.hasValue = false;
        this.isInnerStopped = false;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype._complete = function () {
        if (this.isInnerStopped) {
            _super.prototype._complete.call(this);
        }
        else {
            this.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
        this.isInnerStopped = true;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    return SkipUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":31,"../util/subscribeToResult":238}],195:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
 * true, but emits all further source items as soon as the condition becomes false.
 *
 * <img src="./img/skipWhile.png" width="100%">
 *
 * @param {Function} predicate - A function to test each item emitted from the source Observable.
 * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the
 * specified predicate becomes false.
 * @method skipWhile
 * @owner Observable
 */
function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
exports.skipWhile = skipWhile;
var SkipWhileOperator = (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipWhileSubscriber = (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.skipping = true;
        this.index = 0;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36}],196:[function(require,module,exports){
"use strict";
var ArrayObservable_1 = require('../observable/ArrayObservable');
var ScalarObservable_1 = require('../observable/ScalarObservable');
var EmptyObservable_1 = require('../observable/EmptyObservable');
var concat_1 = require('../observable/concat');
var isScheduler_1 = require('../util/isScheduler');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    return function (source) {
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len === 1) {
            return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);
        }
        else if (len > 1) {
            return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);
        }
        else {
            return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);
        }
    };
}
exports.startWith = startWith;

},{"../observable/ArrayObservable":93,"../observable/EmptyObservable":96,"../observable/ScalarObservable":102,"../observable/concat":105,"../util/isScheduler":234}],197:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return function switchMapOperatorFunction(source) {
        return source.lift(new SwitchMapOperator(project, resultSelector));
    };
}
exports.switchMap = switchMap;
var SwitchMapOperator = (function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":31,"../util/subscribeToResult":238}],198:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');
var EmptyObservable_1 = require('../observable/EmptyObservable');
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take(count) {
    return function (source) {
        if (count === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
exports.take = take;
var TakeOperator = (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36,"../observable/EmptyObservable":96,"../util/ArgumentOutOfRangeError":219}],199:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');
var EmptyObservable_1 = require('../observable/EmptyObservable');
/**
 * Emits only the last `count` values emitted by the source Observable.
 *
 * <span class="informal">Remembers the latest `count` values, then emits those
 * only when the source completes.</span>
 *
 * <img src="./img/takeLast.png" width="100%">
 *
 * `takeLast` returns an Observable that emits at most the last `count` values
 * emitted by the source Observable. If the source emits fewer than `count`
 * values then all of its values are emitted. This operator must wait until the
 * `complete` notification emission from the source in order to emit the `next`
 * values on the output Observable, because otherwise it is impossible to know
 * whether or not more values will be emitted on the source. For this reason,
 * all values are emitted synchronously, followed by the complete notification.
 *
 * @example <caption>Take the last 3 values of an Observable with many values</caption>
 * var many = Rx.Observable.range(1, 100);
 * var lastThree = many.takeLast(3);
 * lastThree.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of values to emit from the end of
 * the sequence of values emitted by the source Observable.
 * @return {Observable<T>} An Observable that emits at most the last count
 * values emitted by the source Observable.
 * @method takeLast
 * @owner Observable
 */
function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
exports.takeLast = takeLast;
var TakeLastOperator = (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeLastSubscriber = (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.ring = new Array();
        this.count = 0;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36,"../observable/EmptyObservable":96,"../util/ArgumentOutOfRangeError":219}],200:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
    };
    return TakeUntilOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":31,"../util/subscribeToResult":238}],201:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Emits values emitted by the source Observable so long as each value satisfies
 * the given `predicate`, and then completes as soon as this `predicate` is not
 * satisfied.
 *
 * <span class="informal">Takes values from the source only while they pass the
 * condition given. When the first value does not satisfy, it completes.</span>
 *
 * <img src="./img/takeWhile.png" width="100%">
 *
 * `takeWhile` subscribes and begins mirroring the source Observable. Each value
 * emitted on the source is given to the `predicate` function which returns a
 * boolean, representing a condition to be satisfied by the source values. The
 * output Observable emits the source values until such time as the `predicate`
 * returns false, at which point `takeWhile` stops mirroring the source
 * Observable and completes the output Observable.
 *
 * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.takeWhile(ev => ev.clientX > 200);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates a value emitted by the source Observable and returns a boolean.
 * Also takes the (zero-based) index as the second argument.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable so long as each value satisfies the condition defined by the
 * `predicate`, then completes.
 * @method takeWhile
 * @owner Observable
 */
function takeWhile(predicate) {
    return function (source) { return source.lift(new TakeWhileOperator(predicate)); };
}
exports.takeWhile = takeWhile;
var TakeWhileOperator = (function () {
    function TakeWhileOperator(predicate) {
        this.predicate = predicate;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));
    };
    return TakeWhileOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeWhileSubscriber = (function (_super) {
    __extends(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.index = 0;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36}],202:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source as long as errors don't occur.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @name tap
 */
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
exports.tap = tap;
var DoOperator = (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = (function (_super) {
    __extends(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36}],203:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
exports.defaultThrottleConfig = {
    leading: true,
    trailing: false
};
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for a duration determined by another Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link throttleTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/throttle.png" width="100%">
 *
 * `throttle` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled by calling the `durationSelector` function with the source value,
 * which returns the "duration" Observable. When the duration Observable emits a
 * value or completes, the timer is disabled, and this process repeats for the
 * next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration for each source value, returned as an Observable or a Promise.
 * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults
 * to `{ leading: true, trailing: false }`.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttle
 * @owner Observable
 */
function throttle(durationSelector, config) {
    if (config === void 0) { config = exports.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };
}
exports.throttle = throttle;
var ThrottleOperator = (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc
 * @ignore
 * @extends {Ignored}
 */
var ThrottleSubscriber = (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        _super.call(this, destination);
        this.destination = destination;
        this.durationSelector = durationSelector;
        this._leading = _leading;
        this._trailing = _trailing;
        this._hasTrailingValue = false;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this._trailing) {
                this._hasTrailingValue = true;
                this._trailingValue = value;
            }
        }
        else {
            var duration = this.tryDurationSelector(value);
            if (duration) {
                this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
            }
            if (this._leading) {
                this.destination.next(value);
                if (this._trailing) {
                    this._hasTrailingValue = true;
                    this._trailingValue = value;
                }
            }
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype._unsubscribe = function () {
        var _a = this, throttled = _a.throttled, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue, _trailing = _a._trailing;
        this._trailingValue = null;
        this._hasTrailingValue = false;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
    };
    ThrottleSubscriber.prototype._sendTrailing = function () {
        var _a = this, destination = _a.destination, throttled = _a.throttled, _trailing = _a._trailing, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue;
        if (throttled && _trailing && _hasTrailingValue) {
            destination.next(_trailingValue);
            this._trailingValue = null;
            this._hasTrailingValue = false;
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._sendTrailing();
        this._unsubscribe();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this._sendTrailing();
        this._unsubscribe();
    };
    return ThrottleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":31,"../util/subscribeToResult":238}],204:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var async_1 = require('../scheduler/async');
var throttle_1 = require('./throttle');
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for `duration` milliseconds, then repeats this process.
 *
 * <span class="informal">Lets a value pass, then ignores source values for the
 * next `duration` milliseconds.</span>
 *
 * <img src="./img/throttleTime.png" width="100%">
 *
 * `throttleTime` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled. After `duration` milliseconds (or the time unit determined
 * internally by the optional `scheduler`) has passed, the timer is disabled,
 * and this process repeats for the next source value. Optionally takes a
 * {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {number} duration Time to wait before emitting another value after
 * emitting the last value, measured in milliseconds or the time unit determined
 * internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the throttling.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttleTime
 * @owner Observable
 */
function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
exports.throttleTime = throttleTime;
var ThrottleTimeOperator = (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ThrottleTimeSubscriber = (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        _super.call(this, destination);
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
        this._hasTrailingValue = false;
        this._trailingValue = null;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}

},{"../Subscriber":36,"../scheduler/async":213,"./throttle":203}],205:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = require('../scheduler/async');
var isDate_1 = require('../util/isDate');
var Subscriber_1 = require('../Subscriber');
var TimeoutError_1 = require('../util/TimeoutError');
/**
 *
 * Errors if Observable does not emit a value in given time span.
 *
 * <span class="informal">Timeouts on Observable that doesn't emit values fast enough.</span>
 *
 * <img src="./img/timeout.png" width="100%">
 *
 * `timeout` operator accepts as an argument either a number or a Date.
 *
 * If number was provided, it returns an Observable that behaves like a source
 * Observable, unless there is a period of time where there is no value emitted.
 * So if you provide `100` as argument and first value comes after 50ms from
 * the moment of subscription, this value will be simply re-emitted by the resulting
 * Observable. If however after that 100ms passes without a second value being emitted,
 * stream will end with an error and source Observable will be unsubscribed.
 * These checks are performed throughout whole lifecycle of Observable - from the moment
 * it was subscribed to, until it completes or errors itself. Thus every value must be
 * emitted within specified period since previous value.
 *
 * If provided argument was Date, returned Observable behaves differently. It throws
 * if Observable did not complete before provided Date. This means that periods between
 * emission of particular values do not matter in this case. If Observable did not complete
 * before provided Date, source Observable will be unsubscribed. Other than that, resulting
 * stream behaves just as source Observable.
 *
 * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)
 * when returned Observable will check if source stream emitted value or completed.
 *
 * @example <caption>Check if ticks are emitted within certain timespan</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(1100) // Let's use bigger timespan to be safe,
 *                       // since `interval` might fire a bit later then scheduled.
 * .subscribe(
 *     value => console.log(value), // Will emit numbers just as regular `interval` would.
 *     err => console.log(err) // Will never be called.
 * );
 *
 * seconds.timeout(900).subscribe(
 *     value => console.log(value), // Will never be called.
 *     err => console.log(err) // Will emit error before even first value is emitted,
 *                             // since it did not arrive within 900ms period.
 * );
 *
 * @example <caption>Use Date to check if Observable completed</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(new Date("December 17, 2020 03:24:00"))
 * .subscribe(
 *     value => console.log(value), // Will emit values as regular `interval` would
 *                                  // until December 17, 2020 at 03:24:00.
 *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,
 *                             // since Observable did not complete by then.
 * );
 *
 * @see {@link timeoutWith}
 *
 * @param {number|Date} due Number specifying period within which Observable must emit values
 *                          or Date specifying before when Observable should complete
 * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
 * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.
 * @method timeout
 * @owner Observable
 */
function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteTimeout = isDate_1.isDate(due);
    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
    return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };
}
exports.timeout = timeout;
var TimeoutOperator = (function () {
    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
    }
    TimeoutOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));
    };
    return TimeoutOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutSubscriber = (function (_super) {
    __extends(TimeoutSubscriber, _super);
    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
        _super.call(this, destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
        this.action = null;
        this.scheduleTimeout();
    }
    TimeoutSubscriber.dispatchTimeout = function (subscriber) {
        subscriber.error(subscriber.errorInstance);
    };
    TimeoutSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            // Recycle the action if we've already scheduled one. All the production
            // Scheduler Actions mutate their state/delay time and return themeselves.
            // VirtualActions are immutable, so they create and return a clone. In this
            // case, we need to set the action reference to the most recent VirtualAction,
            // to ensure that's the one we clone from next time.
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.errorInstance = null;
    };
    return TimeoutSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":36,"../scheduler/async":213,"../util/TimeoutError":223,"../util/isDate":229}],206:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
exports.withLatestFrom = withLatestFrom;
var WithLatestFromOperator = (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WithLatestFromSubscriber = (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        _super.call(this, destination);
        this.observables = observables;
        this.project = project;
        this.toRespond = [];
        var len = observables.length;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
        }
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":31,"../util/subscribeToResult":238}],207:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = require('../observable/ArrayObservable');
var isArray_1 = require('../util/isArray');
var Subscriber_1 = require('../Subscriber');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
var iterator_1 = require('../symbol/iterator');
/* tslint:enable:max-line-length */
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function zipOperatorFunction(source) {
        return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));
    };
}
exports.zip = zip;
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
 * of its input Observables.
 *
 * If the latest parameter is a function, this function is used to compute the created value from the input values.
 * Otherwise, an array of the input values is returned.
 *
 * @example <caption>Combine age and name from different sources</caption>
 *
 * let age$ = Observable.of<number>(27, 25, 29);
 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
 * let isDev$ = Observable.of<boolean>(true, true, false);
 *
 * Observable
 *     .zip(age$,
 *          name$,
 *          isDev$,
 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
 *     .subscribe(x => console.log(x));
 *
 * // outputs
 * // { age: 27, name: 'Foo', isDev: true }
 * // { age: 25, name: 'Bar', isDev: true }
 * // { age: 29, name: 'Beer', isDev: false }
 *
 * @param observables
 * @return {Observable<R>}
 * @static true
 * @name zip
 * @owner Observable
 */
function zipStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
}
exports.zipStatic = zipStatic;
var ZipOperator = (function () {
    function ZipOperator(project) {
        this.project = project;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.project));
    };
    return ZipOperator;
}());
exports.ZipOperator = ZipOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, project, values) {
        if (values === void 0) { values = Object.create(null); }
        _super.call(this, destination);
        this.iterators = [];
        this.active = 0;
        this.project = (typeof project === 'function') ? project : null;
        this.values = values;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator_1.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                this.add(iterator.subscribe(iterator, i));
            }
            else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.project) {
            this._tryProject(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber));
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        _super.call(this, destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
    }
    ZipBufferIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":31,"../Subscriber":36,"../observable/ArrayObservable":93,"../symbol/iterator":215,"../util/isArray":227,"../util/subscribeToResult":238}],208:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('../Subscription');
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;

},{"../Subscription":37}],209:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Action_1 = require('./Action');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;

},{"../util/root":237,"./Action":208}],210:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = require('../Scheduler');
var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;

},{"../Scheduler":33}],211:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncAction_1 = require('./AsyncAction');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var QueueAction = (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;

},{"./AsyncAction":209}],212:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1 = require('./AsyncScheduler');
var QueueScheduler = (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        _super.apply(this, arguments);
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;

},{"./AsyncScheduler":210}],213:[function(require,module,exports){
"use strict";
var AsyncAction_1 = require('./AsyncAction');
var AsyncScheduler_1 = require('./AsyncScheduler');
/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);

},{"./AsyncAction":209,"./AsyncScheduler":210}],214:[function(require,module,exports){
"use strict";
var QueueAction_1 = require('./QueueAction');
var QueueScheduler_1 = require('./QueueScheduler');
/**
 *
 * Queue Scheduler
 *
 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
 *
 * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
 *
 * When used without delay, it schedules given task synchronously - executes it right when
 * it is scheduled. However when called recursively, that is when inside the scheduled task,
 * another task is scheduled with queue scheduler, instead of executing immediately as well,
 * that task will be put on a queue and wait for current one to finish.
 *
 * This means that when you execute task with `queue` scheduler, you are sure it will end
 * before any other task scheduled with that scheduler will start.
 *
 * @examples <caption>Schedule recursively first, then do something</caption>
 *
 * Rx.Scheduler.queue.schedule(() => {
 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
 *
 * // Logs:
 * // "first"
 * // "second"
 *
 *
 * @example <caption>Reschedule itself recursively</caption>
 *
 * Rx.Scheduler.queue.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
 *
 * // In scheduler that runs recursively, you would expect:
 * // "before", 3
 * // "before", 2
 * // "before", 1
 * // "after", 1
 * // "after", 2
 * // "after", 3
 *
 * // But with queue it logs:
 * // "before", 3
 * // "after", 3
 * // "before", 2
 * // "after", 2
 * // "before", 1
 * // "after", 1
 *
 *
 * @static true
 * @name queue
 * @owner Scheduler
 */
exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);

},{"./QueueAction":211,"./QueueScheduler":212}],215:[function(require,module,exports){
"use strict";
var root_1 = require('../util/root');
function symbolIteratorPonyfill(root) {
    var Symbol = root.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    }
    else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.iterator = symbolIteratorPonyfill(root_1.root);
/**
 * @deprecated use iterator instead
 */
exports.$$iterator = exports.iterator;

},{"../util/root":237}],216:[function(require,module,exports){
"use strict";
var root_1 = require('../util/root');
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        }
        else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    }
    else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.observable = getSymbolObservable(root_1.root);
/**
 * @deprecated use observable instead
 */
exports.$$observable = exports.observable;

},{"../util/root":237}],217:[function(require,module,exports){
"use strict";
var root_1 = require('../util/root');
var Symbol = root_1.root.Symbol;
exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;

},{"../util/root":237}],218:[function(require,module,exports){
"use strict";
var root_1 = require('./root');
var RequestAnimationFrameDefinition = (function () {
    function RequestAnimationFrameDefinition(root) {
        if (root.requestAnimationFrame) {
            this.cancelAnimationFrame = root.cancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.requestAnimationFrame.bind(root);
        }
        else if (root.mozRequestAnimationFrame) {
            this.cancelAnimationFrame = root.mozCancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.mozRequestAnimationFrame.bind(root);
        }
        else if (root.webkitRequestAnimationFrame) {
            this.cancelAnimationFrame = root.webkitCancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.webkitRequestAnimationFrame.bind(root);
        }
        else if (root.msRequestAnimationFrame) {
            this.cancelAnimationFrame = root.msCancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.msRequestAnimationFrame.bind(root);
        }
        else if (root.oRequestAnimationFrame) {
            this.cancelAnimationFrame = root.oCancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.oRequestAnimationFrame.bind(root);
        }
        else {
            this.cancelAnimationFrame = root.clearTimeout.bind(root);
            this.requestAnimationFrame = function (cb) { return root.setTimeout(cb, 1000 / 60); };
        }
    }
    return RequestAnimationFrameDefinition;
}());
exports.RequestAnimationFrameDefinition = RequestAnimationFrameDefinition;
exports.AnimationFrame = new RequestAnimationFrameDefinition(root_1.root);

},{"./root":237}],219:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError = (function (_super) {
    __extends(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var err = _super.call(this, 'argument out of range');
        this.name = err.name = 'ArgumentOutOfRangeError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ArgumentOutOfRangeError;
}(Error));
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;

},{}],220:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an Observable or a sequence was queried but has no
 * elements.
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link single}
 *
 * @class EmptyError
 */
var EmptyError = (function (_super) {
    __extends(EmptyError, _super);
    function EmptyError() {
        var err = _super.call(this, 'no elements in sequence');
        this.name = err.name = 'EmptyError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return EmptyError;
}(Error));
exports.EmptyError = EmptyError;

},{}],221:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = (function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error));
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;

},{}],222:[function(require,module,exports){
"use strict";
var root_1 = require('./root');
function minimalSetImpl() {
    // THIS IS NOT a full impl of Set, this is just the minimum
    // bits of functionality we need for this library.
    return (function () {
        function MinimalSet() {
            this._values = [];
        }
        MinimalSet.prototype.add = function (value) {
            if (!this.has(value)) {
                this._values.push(value);
            }
        };
        MinimalSet.prototype.has = function (value) {
            return this._values.indexOf(value) !== -1;
        };
        Object.defineProperty(MinimalSet.prototype, "size", {
            get: function () {
                return this._values.length;
            },
            enumerable: true,
            configurable: true
        });
        MinimalSet.prototype.clear = function () {
            this._values.length = 0;
        };
        return MinimalSet;
    }());
}
exports.minimalSetImpl = minimalSetImpl;
exports.Set = root_1.root.Set || minimalSetImpl();

},{"./root":237}],223:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when duetime elapses.
 *
 * @see {@link timeout}
 *
 * @class TimeoutError
 */
var TimeoutError = (function (_super) {
    __extends(TimeoutError, _super);
    function TimeoutError() {
        var err = _super.call(this, 'Timeout has occurred');
        this.name = err.name = 'TimeoutError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return TimeoutError;
}(Error));
exports.TimeoutError = TimeoutError;

},{}],224:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error));
exports.UnsubscriptionError = UnsubscriptionError;

},{}],225:[function(require,module,exports){
"use strict";
// typeof any so that it we don't have to cast when comparing a result to the error object
exports.errorObject = { e: {} };

},{}],226:[function(require,module,exports){
"use strict";
function identity(x) {
    return x;
}
exports.identity = identity;

},{}],227:[function(require,module,exports){
"use strict";
exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

},{}],228:[function(require,module,exports){
"use strict";
exports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });

},{}],229:[function(require,module,exports){
"use strict";
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;

},{}],230:[function(require,module,exports){
"use strict";
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;

},{}],231:[function(require,module,exports){
"use strict";
var isArray_1 = require('../util/isArray');
function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
exports.isNumeric = isNumeric;
;

},{"../util/isArray":227}],232:[function(require,module,exports){
"use strict";
function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;

},{}],233:[function(require,module,exports){
"use strict";
function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;

},{}],234:[function(require,module,exports){
"use strict";
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;

},{}],235:[function(require,module,exports){
"use strict";
/* tslint:disable:no-empty */
function noop() { }
exports.noop = noop;

},{}],236:[function(require,module,exports){
"use strict";
var noop_1 = require('./noop');
/* tslint:enable:max-line-length */
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i - 0] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
/* @internal */
function pipeFromArray(fns) {
    if (!fns) {
        return noop_1.noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;

},{"./noop":235}],237:[function(require,module,exports){
(function (global){
"use strict";
// CommonJS / Node have global context exposed as "global" variable.
// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
// the global "global" var for now.
var __window = typeof window !== 'undefined' && window;
var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
    self instanceof WorkerGlobalScope && self;
var __global = typeof global !== 'undefined' && global;
var _root = __window || __global || __self;
exports.root = _root;
// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
// This is needed when used with angular/tsickle which inserts a goog.module statement.
// Wrap in IIFE
(function () {
    if (!_root) {
        throw new Error('RxJS could not find any global context (window, self, global)');
    }
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],238:[function(require,module,exports){
"use strict";
var root_1 = require('./root');
var isArrayLike_1 = require('./isArrayLike');
var isPromise_1 = require('./isPromise');
var isObject_1 = require('./isObject');
var Observable_1 = require('../Observable');
var iterator_1 = require('../symbol/iterator');
var InnerSubscriber_1 = require('../InnerSubscriber');
var observable_1 = require('../symbol/observable');
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        }
        else {
            destination.syncErrorThrowable = true;
            return result.subscribe(destination);
        }
    }
    else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    }
    else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) { return destination.error(err); })
            .then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () { throw err; });
        });
        return destination;
    }
    else if (result && typeof result[iterator_1.iterator] === 'function') {
        var iterator = result[iterator_1.iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    }
    else if (result && typeof result[observable_1.observable] === 'function') {
        var obs = result[observable_1.observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        }
        else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = ("You provided " + value + " where a stream was expected.")
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
exports.subscribeToResult = subscribeToResult;

},{"../InnerSubscriber":27,"../Observable":29,"../symbol/iterator":215,"../symbol/observable":216,"./isArrayLike":228,"./isObject":232,"./isPromise":233,"./root":237}],239:[function(require,module,exports){
"use strict";
var Subscriber_1 = require('../Subscriber');
var rxSubscriber_1 = require('../symbol/rxSubscriber');
var Observer_1 = require('../Observer');
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;

},{"../Observer":30,"../Subscriber":36,"../symbol/rxSubscriber":217}],240:[function(require,module,exports){
"use strict";
var errorObject_1 = require('./errorObject');
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;

},{"./errorObject":225}],241:[function(require,module,exports){
// threejs.org/license
(function(m,ja){"object"===typeof exports&&"undefined"!==typeof module?ja(exports):"function"===typeof define&&define.amd?define(["exports"],ja):ja(m.THREE=m.THREE||{})})(this,function(m){function ja(){}function C(a,b){this.x=a||0;this.y=b||0}function K(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];0<arguments.length&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}function Z(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._w=void 0!==d?d:1}
function p(a,b,c){this.x=a||0;this.y=b||0;this.z=c||0}function ra(){this.elements=[1,0,0,0,1,0,0,0,1];0<arguments.length&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}function ea(a,b,c,d,e,f,g,h,k,l){Object.defineProperty(this,"id",{value:kf++});this.uuid=R.generateUUID();this.name="";this.image=void 0!==a?a:ea.DEFAULT_IMAGE;this.mipmaps=[];this.mapping=void 0!==b?b:ea.DEFAULT_MAPPING;this.wrapS=void 0!==c?c:1001;this.wrapT=void 0!==d?d:1001;this.magFilter=
void 0!==e?e:1006;this.minFilter=void 0!==f?f:1008;this.anisotropy=void 0!==k?k:1;this.format=void 0!==g?g:1023;this.type=void 0!==h?h:1009;this.offset=new C(0,0);this.repeat=new C(1,1);this.center=new C(0,0);this.rotation=0;this.matrixAutoUpdate=!0;this.matrix=new ra;this.generateMipmaps=!0;this.premultiplyAlpha=!1;this.flipY=!0;this.unpackAlignment=4;this.encoding=void 0!==l?l:3E3;this.version=0;this.onUpdate=null}function da(a,b,c,d){this.x=a||0;this.y=b||0;this.z=c||0;this.w=void 0!==d?d:1}function Hb(a,
b,c){this.uuid=R.generateUUID();this.width=a;this.height=b;this.scissor=new da(0,0,a,b);this.scissorTest=!1;this.viewport=new da(0,0,a,b);c=c||{};void 0===c.minFilter&&(c.minFilter=1006);this.texture=new ea(void 0,void 0,c.wrapS,c.wrapT,c.magFilter,c.minFilter,c.format,c.type,c.anisotropy,c.encoding);this.depthBuffer=void 0!==c.depthBuffer?c.depthBuffer:!0;this.stencilBuffer=void 0!==c.stencilBuffer?c.stencilBuffer:!0;this.depthTexture=void 0!==c.depthTexture?c.depthTexture:null}function Ib(a,b,c){Hb.call(this,
a,b,c);this.activeMipMapLevel=this.activeCubeFace=0}function fb(a,b,c,d,e,f,g,h,k,l,q,n){ea.call(this,null,f,g,h,k,l,d,e,q,n);this.image={data:a,width:b,height:c};this.magFilter=void 0!==k?k:1003;this.minFilter=void 0!==l?l:1003;this.flipY=this.generateMipmaps=!1;this.unpackAlignment=1}function Ua(a,b,c,d,e,f,g,h,k,l){a=void 0!==a?a:[];ea.call(this,a,void 0!==b?b:301,c,d,e,f,g,h,k,l);this.flipY=!1}function Jb(a,b,c){var d=a[0];if(0>=d||0<d)return a;var e=b*c,f=we[e];void 0===f&&(f=new Float32Array(e),
we[e]=f);if(0!==b)for(d.toArray(f,0),d=1,e=0;d!==b;++d)e+=c,a[d].toArray(f,e);return f}function xe(a,b){var c=ye[b];void 0===c&&(c=new Int32Array(b),ye[b]=c);for(var d=0;d!==b;++d)c[d]=a.allocTextureUnit();return c}function lf(a,b){a.uniform1f(this.addr,b)}function mf(a,b){a.uniform1i(this.addr,b)}function nf(a,b){void 0===b.x?a.uniform2fv(this.addr,b):a.uniform2f(this.addr,b.x,b.y)}function of(a,b){void 0!==b.x?a.uniform3f(this.addr,b.x,b.y,b.z):void 0!==b.r?a.uniform3f(this.addr,b.r,b.g,b.b):a.uniform3fv(this.addr,
b)}function pf(a,b){void 0===b.x?a.uniform4fv(this.addr,b):a.uniform4f(this.addr,b.x,b.y,b.z,b.w)}function qf(a,b){a.uniformMatrix2fv(this.addr,!1,b.elements||b)}function rf(a,b){void 0===b.elements?a.uniformMatrix3fv(this.addr,!1,b):(ze.set(b.elements),a.uniformMatrix3fv(this.addr,!1,ze))}function sf(a,b){void 0===b.elements?a.uniformMatrix4fv(this.addr,!1,b):(Ae.set(b.elements),a.uniformMatrix4fv(this.addr,!1,Ae))}function tf(a,b,c){var d=c.allocTextureUnit();a.uniform1i(this.addr,d);c.setTexture2D(b||
Be,d)}function uf(a,b,c){var d=c.allocTextureUnit();a.uniform1i(this.addr,d);c.setTextureCube(b||Ce,d)}function De(a,b){a.uniform2iv(this.addr,b)}function Ee(a,b){a.uniform3iv(this.addr,b)}function Fe(a,b){a.uniform4iv(this.addr,b)}function vf(a){switch(a){case 5126:return lf;case 35664:return nf;case 35665:return of;case 35666:return pf;case 35674:return qf;case 35675:return rf;case 35676:return sf;case 35678:case 36198:return tf;case 35680:return uf;case 5124:case 35670:return mf;case 35667:case 35671:return De;
case 35668:case 35672:return Ee;case 35669:case 35673:return Fe}}function wf(a,b){a.uniform1fv(this.addr,b)}function xf(a,b){a.uniform1iv(this.addr,b)}function yf(a,b){a.uniform2fv(this.addr,Jb(b,this.size,2))}function zf(a,b){a.uniform3fv(this.addr,Jb(b,this.size,3))}function Af(a,b){a.uniform4fv(this.addr,Jb(b,this.size,4))}function Bf(a,b){a.uniformMatrix2fv(this.addr,!1,Jb(b,this.size,4))}function Cf(a,b){a.uniformMatrix3fv(this.addr,!1,Jb(b,this.size,9))}function Df(a,b){a.uniformMatrix4fv(this.addr,
!1,Jb(b,this.size,16))}function Ef(a,b,c){var d=b.length,e=xe(c,d);a.uniform1iv(this.addr,e);for(a=0;a!==d;++a)c.setTexture2D(b[a]||Be,e[a])}function Ff(a,b,c){var d=b.length,e=xe(c,d);a.uniform1iv(this.addr,e);for(a=0;a!==d;++a)c.setTextureCube(b[a]||Ce,e[a])}function Gf(a){switch(a){case 5126:return wf;case 35664:return yf;case 35665:return zf;case 35666:return Af;case 35674:return Bf;case 35675:return Cf;case 35676:return Df;case 35678:return Ef;case 35680:return Ff;case 5124:case 35670:return xf;
case 35667:case 35671:return De;case 35668:case 35672:return Ee;case 35669:case 35673:return Fe}}function Hf(a,b,c){this.id=a;this.addr=c;this.setValue=vf(b.type)}function If(a,b,c){this.id=a;this.addr=c;this.size=b.size;this.setValue=Gf(b.type)}function Ge(a){this.id=a;this.seq=[];this.map={}}function gb(a,b,c){this.seq=[];this.map={};this.renderer=c;c=a.getProgramParameter(b,a.ACTIVE_UNIFORMS);for(var d=0;d<c;++d){var e=a.getActiveUniform(b,d),f=a.getUniformLocation(b,e.name),g=this,h=e.name,k=
h.length;for(Od.lastIndex=0;;){var l=Od.exec(h),q=Od.lastIndex,n=l[1],t=l[3];"]"===l[2]&&(n|=0);if(void 0===t||"["===t&&q+2===k){h=g;e=void 0===t?new Hf(n,e,f):new If(n,e,f);h.seq.push(e);h.map[e.id]=e;break}else t=g.map[n],void 0===t&&(t=new Ge(n),n=g,g=t,n.seq.push(g),n.map[g.id]=g),g=t}}}function H(a,b,c){return void 0===b&&void 0===c?this.set(a):this.setRGB(a,b,c)}function kd(a,b){this.min=void 0!==a?a:new C(Infinity,Infinity);this.max=void 0!==b?b:new C(-Infinity,-Infinity)}function Jf(a,b,c,
d,e){var f,g,h,k,l,q,n,t,r,m,v,w,x,z,I,B;this.render=function(a,u,za,la){if(0!==a.length){u=new p;var J=la.w/la.z,ta=.5*la.z,Va=.5*la.w,L=16/la.w,Y=new C(L*J,L),ua=new p(1,1,0),M=new C(1,1),V=new kd;V.min.set(la.x,la.y);V.max.set(la.x+(la.z-16),la.y+(la.w-16));if(void 0===z){var L=new Float32Array([-1,-1,0,0,1,-1,1,0,1,1,1,1,-1,1,0,1]),y=new Uint16Array([0,1,2,0,2,3]);v=b.createBuffer();w=b.createBuffer();b.bindBuffer(b.ARRAY_BUFFER,v);b.bufferData(b.ARRAY_BUFFER,L,b.STATIC_DRAW);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,
w);b.bufferData(b.ELEMENT_ARRAY_BUFFER,y,b.STATIC_DRAW);I=b.createTexture();B=b.createTexture();c.bindTexture(b.TEXTURE_2D,I);b.texImage2D(b.TEXTURE_2D,0,b.RGB,16,16,0,b.RGB,b.UNSIGNED_BYTE,null);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST);c.bindTexture(b.TEXTURE_2D,B);b.texImage2D(b.TEXTURE_2D,0,
b.RGBA,16,16,0,b.RGBA,b.UNSIGNED_BYTE,null);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST);var L=x={vertexShader:"uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\n\tvUV = uv;\n\tvec2 pos = position;\n\tif ( renderType == 2 ) {\n\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\t\tvVisibility =        visibility.r / 9.0;\n\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\tvVisibility *=       visibility.b / 9.0;\n\t\tvVisibility *= 1.0 - visibility.a / 9.0;\n\t\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\n\t\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n\t}\n\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
fragmentShader:"uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\n\tif ( renderType == 0 ) {\n\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n\t} else if ( renderType == 1 ) {\n\t\tgl_FragColor = texture2D( map, vUV );\n\t} else {\n\t\tvec4 texture = texture2D( map, vUV );\n\t\ttexture.a *= opacity * vVisibility;\n\t\tgl_FragColor = texture;\n\t\tgl_FragColor.rgb *= color;\n\t}\n}"},y=b.createProgram(),
A=b.createShader(b.FRAGMENT_SHADER),aa=b.createShader(b.VERTEX_SHADER),D="precision "+e.precision+" float;\n";b.shaderSource(A,D+L.fragmentShader);b.shaderSource(aa,D+L.vertexShader);b.compileShader(A);b.compileShader(aa);b.attachShader(y,A);b.attachShader(y,aa);b.linkProgram(y);z=y;r=b.getAttribLocation(z,"position");m=b.getAttribLocation(z,"uv");f=b.getUniformLocation(z,"renderType");g=b.getUniformLocation(z,"map");h=b.getUniformLocation(z,"occlusionMap");k=b.getUniformLocation(z,"opacity");l=b.getUniformLocation(z,
"color");q=b.getUniformLocation(z,"scale");n=b.getUniformLocation(z,"rotation");t=b.getUniformLocation(z,"screenPosition")}c.useProgram(z);c.initAttributes();c.enableAttribute(r);c.enableAttribute(m);c.disableUnusedAttributes();b.uniform1i(h,0);b.uniform1i(g,1);b.bindBuffer(b.ARRAY_BUFFER,v);b.vertexAttribPointer(r,2,b.FLOAT,!1,16,0);b.vertexAttribPointer(m,2,b.FLOAT,!1,16,8);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,w);c.disable(b.CULL_FACE);c.buffers.depth.setMask(!1);y=0;for(A=a.length;y<A;y++)if(L=
16/la.w,Y.set(L*J,L),aa=a[y],u.set(aa.matrixWorld.elements[12],aa.matrixWorld.elements[13],aa.matrixWorld.elements[14]),u.applyMatrix4(za.matrixWorldInverse),u.applyMatrix4(za.projectionMatrix),ua.copy(u),M.x=la.x+ua.x*ta+ta-8,M.y=la.y+ua.y*Va+Va-8,!0===V.containsPoint(M)){c.activeTexture(b.TEXTURE0);c.bindTexture(b.TEXTURE_2D,null);c.activeTexture(b.TEXTURE1);c.bindTexture(b.TEXTURE_2D,I);b.copyTexImage2D(b.TEXTURE_2D,0,b.RGB,M.x,M.y,16,16,0);b.uniform1i(f,0);b.uniform2f(q,Y.x,Y.y);b.uniform3f(t,
ua.x,ua.y,ua.z);c.disable(b.BLEND);c.enable(b.DEPTH_TEST);b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0);c.activeTexture(b.TEXTURE0);c.bindTexture(b.TEXTURE_2D,B);b.copyTexImage2D(b.TEXTURE_2D,0,b.RGBA,M.x,M.y,16,16,0);b.uniform1i(f,1);c.disable(b.DEPTH_TEST);c.activeTexture(b.TEXTURE1);c.bindTexture(b.TEXTURE_2D,I);b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0);aa.positionScreen.copy(ua);aa.customUpdateCallback?aa.customUpdateCallback(aa):aa.updateLensFlares();b.uniform1i(f,2);c.enable(b.BLEND);
for(var D=0,H=aa.lensFlares.length;D<H;D++){var E=aa.lensFlares[D];.001<E.opacity&&.001<E.scale&&(ua.x=E.x,ua.y=E.y,ua.z=E.z,L=E.size*E.scale/la.w,Y.x=L*J,Y.y=L,b.uniform3f(t,ua.x,ua.y,ua.z),b.uniform2f(q,Y.x,Y.y),b.uniform1f(n,E.rotation),b.uniform1f(k,E.opacity),b.uniform3f(l,E.color.r,E.color.g,E.color.b),c.setBlending(E.blending,E.blendEquation,E.blendSrc,E.blendDst),d.setTexture2D(E.texture,1),b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0))}}c.enable(b.CULL_FACE);c.enable(b.DEPTH_TEST);c.buffers.depth.setMask(!0);
c.reset()}}}function tc(a,b,c,d,e,f,g,h,k){ea.call(this,a,b,c,d,e,f,g,h,k);this.needsUpdate=!0}function Kf(a,b,c,d,e){var f,g,h,k,l,q,n,t,r,m,v,w,x,z,I,B,J;function ta(a,b){return a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.z!==b.z?b.z-a.z:b.id-a.id}var za,la,ha,He,Va=new p,L=new Z,C=new p;this.render=function(u,p,V){if(0!==u.length){if(void 0===ha){var M=new Float32Array([-.5,-.5,0,0,.5,-.5,1,0,.5,.5,1,1,-.5,.5,0,1]),y=new Uint16Array([0,1,2,0,2,3]);za=b.createBuffer();la=b.createBuffer();
b.bindBuffer(b.ARRAY_BUFFER,za);b.bufferData(b.ARRAY_BUFFER,M,b.STATIC_DRAW);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,la);b.bufferData(b.ELEMENT_ARRAY_BUFFER,y,b.STATIC_DRAW);M=b.createProgram();y=b.createShader(b.VERTEX_SHADER);var Y=b.createShader(b.FRAGMENT_SHADER);b.shaderSource(y,["precision "+e.precision+" float;","#define SHADER_NAME SpriteMaterial\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float fogDepth;\nvoid main() {\n\tvUV = uvOffset + uv * uvScale;\n\tvec2 alignedPosition = position * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tvec4 mvPosition;\n\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\tfogDepth = - mvPosition.z;\n}"].join("\n"));
b.shaderSource(Y,["precision "+e.precision+" float;","#define SHADER_NAME SpriteMaterial\nuniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvarying float fogDepth;\nvoid main() {\n\tvec4 texture = texture2D( map, vUV );\n\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\n\tif ( gl_FragColor.a < alphaTest ) discard;\n\tif ( fogType > 0 ) {\n\t\tfloat fogFactor = 0.0;\n\t\tif ( fogType == 1 ) {\n\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t\t} else {\n\t\t\tconst float LOG2 = 1.442695;\n\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );\n\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\t\t}\n\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\t}\n}"].join("\n"));
b.compileShader(y);b.compileShader(Y);b.attachShader(M,y);b.attachShader(M,Y);b.linkProgram(M);ha=M;B=b.getAttribLocation(ha,"position");J=b.getAttribLocation(ha,"uv");f=b.getUniformLocation(ha,"uvOffset");g=b.getUniformLocation(ha,"uvScale");h=b.getUniformLocation(ha,"rotation");k=b.getUniformLocation(ha,"scale");l=b.getUniformLocation(ha,"color");q=b.getUniformLocation(ha,"map");n=b.getUniformLocation(ha,"opacity");t=b.getUniformLocation(ha,"modelViewMatrix");r=b.getUniformLocation(ha,"projectionMatrix");
m=b.getUniformLocation(ha,"fogType");v=b.getUniformLocation(ha,"fogDensity");w=b.getUniformLocation(ha,"fogNear");x=b.getUniformLocation(ha,"fogFar");z=b.getUniformLocation(ha,"fogColor");b.getUniformLocation(ha,"fogDepth");I=b.getUniformLocation(ha,"alphaTest");M=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");M.width=8;M.height=8;y=M.getContext("2d");y.fillStyle="white";y.fillRect(0,0,8,8);He=new tc(M)}c.useProgram(ha);c.initAttributes();c.enableAttribute(B);c.enableAttribute(J);
c.disableUnusedAttributes();c.disable(b.CULL_FACE);c.enable(b.BLEND);b.bindBuffer(b.ARRAY_BUFFER,za);b.vertexAttribPointer(B,2,b.FLOAT,!1,16,0);b.vertexAttribPointer(J,2,b.FLOAT,!1,16,8);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,la);b.uniformMatrix4fv(r,!1,V.projectionMatrix.elements);c.activeTexture(b.TEXTURE0);b.uniform1i(q,0);y=M=0;(Y=p.fog)?(b.uniform3f(z,Y.color.r,Y.color.g,Y.color.b),Y.isFog?(b.uniform1f(w,Y.near),b.uniform1f(x,Y.far),b.uniform1i(m,1),y=M=1):Y.isFogExp2&&(b.uniform1f(v,Y.density),
b.uniform1i(m,2),y=M=2)):(b.uniform1i(m,0),y=M=0);for(var A=0,ua=u.length;A<ua;A++)Y=u[A],Y.modelViewMatrix.multiplyMatrices(V.matrixWorldInverse,Y.matrixWorld),Y.z=-Y.modelViewMatrix.elements[14];u.sort(ta);for(var E=[],A=0,ua=u.length;A<ua;A++){Y=u[A];var G=Y.material;if(!1!==G.visible){Y.onBeforeRender(a,p,V,void 0,G,void 0);b.uniform1f(I,G.alphaTest);b.uniformMatrix4fv(t,!1,Y.modelViewMatrix.elements);Y.matrixWorld.decompose(Va,L,C);E[0]=C.x;E[1]=C.y;var D=0;p.fog&&G.fog&&(D=y);M!==D&&(b.uniform1i(m,
D),M=D);null!==G.map?(b.uniform2f(f,G.map.offset.x,G.map.offset.y),b.uniform2f(g,G.map.repeat.x,G.map.repeat.y)):(b.uniform2f(f,0,0),b.uniform2f(g,1,1));b.uniform1f(n,G.opacity);b.uniform3f(l,G.color.r,G.color.g,G.color.b);b.uniform1f(h,G.rotation);b.uniform2fv(k,E);c.setBlending(G.blending,G.blendEquation,G.blendSrc,G.blendDst,G.blendEquationAlpha,G.blendSrcAlpha,G.blendDstAlpha,G.premultipliedAlpha);c.buffers.depth.setTest(G.depthTest);c.buffers.depth.setMask(G.depthWrite);c.buffers.color.setMask(G.colorWrite);
d.setTexture2D(G.map||He,0);b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0);Y.onAfterRender(a,p,V,void 0,G,void 0)}}c.enable(b.CULL_FACE);c.reset()}}}function Q(){Object.defineProperty(this,"id",{value:Lf++});this.uuid=R.generateUUID();this.name="";this.type="Material";this.lights=this.fog=!0;this.blending=1;this.side=0;this.flatShading=!1;this.vertexColors=0;this.opacity=1;this.transparent=!1;this.blendSrc=204;this.blendDst=205;this.blendEquation=100;this.blendEquationAlpha=this.blendDstAlpha=this.blendSrcAlpha=
null;this.depthFunc=3;this.depthWrite=this.depthTest=!0;this.clippingPlanes=null;this.clipShadows=this.clipIntersection=!1;this.colorWrite=!0;this.precision=null;this.polygonOffset=!1;this.polygonOffsetUnits=this.polygonOffsetFactor=0;this.dithering=!1;this.alphaTest=0;this.premultipliedAlpha=!1;this.overdraw=0;this.visible=!0;this.userData={};this.needsUpdate=!0}function Wa(a){Q.call(this);this.type="MeshDepthMaterial";this.depthPacking=3200;this.morphTargets=this.skinning=!1;this.displacementMap=
this.alphaMap=this.map=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=!1;this.wireframeLinewidth=1;this.lights=this.fog=!1;this.setValues(a)}function Xa(a){Q.call(this);this.type="MeshDistanceMaterial";this.referencePosition=new p;this.nearDistance=1;this.farDistance=1E3;this.morphTargets=this.skinning=!1;this.displacementMap=this.alphaMap=this.map=null;this.displacementScale=1;this.displacementBias=0;this.lights=this.fog=!1;this.setValues(a)}function Oa(a,b){this.min=void 0!==
a?a:new p(Infinity,Infinity,Infinity);this.max=void 0!==b?b:new p(-Infinity,-Infinity,-Infinity)}function Da(a,b){this.center=void 0!==a?a:new p;this.radius=void 0!==b?b:0}function Aa(a,b){this.normal=void 0!==a?a:new p(1,0,0);this.constant=void 0!==b?b:0}function ld(a,b,c,d,e,f){this.planes=[void 0!==a?a:new Aa,void 0!==b?b:new Aa,void 0!==c?c:new Aa,void 0!==d?d:new Aa,void 0!==e?e:new Aa,void 0!==f?f:new Aa]}function Ie(a,b,c){function d(b,c,d,e,f,g){var h=b.geometry;var k=n;var l=b.customDepthMaterial;
d&&(k=t,l=b.customDistanceMaterial);l?k=l:(l=!1,c.morphTargets&&(h&&h.isBufferGeometry?l=h.morphAttributes&&h.morphAttributes.position&&0<h.morphAttributes.position.length:h&&h.isGeometry&&(l=h.morphTargets&&0<h.morphTargets.length)),b.isSkinnedMesh&&!1===c.skinning&&console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",b),b=b.isSkinnedMesh&&c.skinning,h=0,l&&(h|=1),b&&(h|=2),k=k[h]);a.localClippingEnabled&&!0===c.clipShadows&&0!==c.clippingPlanes.length&&(h=
k.uuid,l=c.uuid,b=r[h],void 0===b&&(b={},r[h]=b),h=b[l],void 0===h&&(h=k.clone(),b[l]=h),k=h);k.visible=c.visible;k.wireframe=c.wireframe;l=c.side;B.renderSingleSided&&2==l&&(l=0);B.renderReverseSided&&(0===l?l=1:1===l&&(l=0));k.side=l;k.clipShadows=c.clipShadows;k.clippingPlanes=c.clippingPlanes;k.clipIntersection=c.clipIntersection;k.wireframeLinewidth=c.wireframeLinewidth;k.linewidth=c.linewidth;d&&k.isMeshDistanceMaterial&&(k.referencePosition.copy(e),k.nearDistance=f,k.farDistance=g);return k}
function e(c,g,h,k){var l;if(!1!==c.visible){if(c.layers.test(g.layers)&&(c.isMesh||c.isLine||c.isPoints)&&c.castShadow&&(!c.frustumCulled||f.intersectsObject(c))){c.modelViewMatrix.multiplyMatrices(h.matrixWorldInverse,c.matrixWorld);var n=b.update(c),t=c.material;if(Array.isArray(t))for(var r=n.groups,m=0,z=r.length;m<z;m++){var u=r[m];(l=t[u.materialIndex])&&l.visible&&(l=d(c,l,k,q,h.near,h.far),a.renderBufferDirect(h,null,n,l,c,u))}else t.visible&&(l=d(c,t,k,q,h.near,h.far),a.renderBufferDirect(h,
null,n,l,c,null))}c=c.children;n=0;for(t=c.length;n<t;n++)e(c[n],g,h,k)}}var f=new ld,g=new K,h=new C,k=new C(c,c),l=new p,q=new p,n=Array(4),t=Array(4),r={},m=[new p(1,0,0),new p(-1,0,0),new p(0,0,1),new p(0,0,-1),new p(0,1,0),new p(0,-1,0)],v=[new p(0,1,0),new p(0,1,0),new p(0,1,0),new p(0,1,0),new p(0,0,1),new p(0,0,-1)],w=[new da,new da,new da,new da,new da,new da];for(c=0;4!==c;++c){var x=0!==(c&1),z=0!==(c&2),I=new Wa({depthPacking:3201,morphTargets:x,skinning:z});n[c]=I;x=new Xa({morphTargets:x,
skinning:z});t[c]=x}var B=this;this.enabled=!1;this.autoUpdate=!0;this.needsUpdate=!1;this.type=1;this.renderSingleSided=this.renderReverseSided=!0;this.render=function(b,c,d){if(!1!==B.enabled&&(!1!==B.autoUpdate||!1!==B.needsUpdate)&&0!==b.length){var n=a.state;n.disable(a.context.BLEND);n.buffers.color.setClear(1,1,1,1);n.buffers.depth.setTest(!0);n.setScissorTest(!1);for(var t,r=0,z=b.length;r<z;r++){var u=b[r];t=u.shadow;var I=u&&u.isPointLight;if(void 0===t)console.warn("THREE.WebGLShadowMap:",
u,"has no shadow.");else{var p=t.camera;h.copy(t.mapSize);h.min(k);if(I){var x=h.x,J=h.y;w[0].set(2*x,J,x,J);w[1].set(0,J,x,J);w[2].set(3*x,J,x,J);w[3].set(x,J,x,J);w[4].set(3*x,0,x,J);w[5].set(x,0,x,J);h.x*=4;h.y*=2}null===t.map&&(t.map=new Hb(h.x,h.y,{minFilter:1003,magFilter:1003,format:1023}),t.map.texture.name=u.name+".shadowMap",p.updateProjectionMatrix());t.isSpotLightShadow&&t.update(u);x=t.map;J=t.matrix;q.setFromMatrixPosition(u.matrixWorld);p.position.copy(q);I?(t=6,J.makeTranslation(-q.x,
-q.y,-q.z)):(t=1,l.setFromMatrixPosition(u.target.matrixWorld),p.lookAt(l),p.updateMatrixWorld(),J.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),J.multiply(p.projectionMatrix),J.multiply(p.matrixWorldInverse));a.setRenderTarget(x);a.clear();for(u=0;u<t;u++)I&&(l.copy(p.position),l.add(m[u]),p.up.copy(v[u]),p.lookAt(l),p.updateMatrixWorld(),n.viewport(w[u])),g.multiplyMatrices(p.projectionMatrix,p.matrixWorldInverse),f.setFromMatrix(g),e(c,d,p,I)}}B.needsUpdate=!1}}}function Mf(a){var b={};return{get:function(a){a.isInterleavedBufferAttribute&&
(a=a.data);return b[a.uuid]},remove:function(c){c.isInterleavedBufferAttribute&&(c=c.data);var d=b[c.uuid];d&&(a.deleteBuffer(d.buffer),delete b[c.uuid])},update:function(c,d){c.isInterleavedBufferAttribute&&(c=c.data);var e=b[c.uuid];if(void 0===e){var e=c.uuid,f=c.array,g=c.dynamic?a.DYNAMIC_DRAW:a.STATIC_DRAW,h=a.createBuffer();a.bindBuffer(d,h);a.bufferData(d,f,g);c.onUploadCallback();d=a.FLOAT;f instanceof Float32Array?d=a.FLOAT:f instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):
f instanceof Uint16Array?d=a.UNSIGNED_SHORT:f instanceof Int16Array?d=a.SHORT:f instanceof Uint32Array?d=a.UNSIGNED_INT:f instanceof Int32Array?d=a.INT:f instanceof Int8Array?d=a.BYTE:f instanceof Uint8Array&&(d=a.UNSIGNED_BYTE);b[e]={buffer:h,type:d,bytesPerElement:f.BYTES_PER_ELEMENT,version:c.version}}else e.version<c.version&&(f=c,h=f.array,g=f.updateRange,a.bindBuffer(d,e.buffer),!1===f.dynamic?a.bufferData(d,h,a.STATIC_DRAW):-1===g.count?a.bufferSubData(d,0,h):0===g.count?console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."):
(a.bufferSubData(d,g.offset*h.BYTES_PER_ELEMENT,h.subarray(g.offset,g.offset+g.count)),g.count=-1),e.version=c.version)}}}function Ya(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._order=d||Ya.DefaultOrder}function Pd(){this.mask=1}function A(){Object.defineProperty(this,"id",{value:Nf++});this.uuid=R.generateUUID();this.name="";this.type="Object3D";this.parent=null;this.children=[];this.up=A.DefaultUp.clone();var a=new p,b=new Ya,c=new Z,d=new p(1,1,1);b.onChange(function(){c.setFromEuler(b,
!1)});c.onChange(function(){b.setFromQuaternion(c,void 0,!1)});Object.defineProperties(this,{position:{enumerable:!0,value:a},rotation:{enumerable:!0,value:b},quaternion:{enumerable:!0,value:c},scale:{enumerable:!0,value:d},modelViewMatrix:{value:new K},normalMatrix:{value:new ra}});this.matrix=new K;this.matrixWorld=new K;this.matrixAutoUpdate=A.DefaultMatrixAutoUpdate;this.matrixWorldNeedsUpdate=!1;this.layers=new Pd;this.visible=!0;this.receiveShadow=this.castShadow=!1;this.frustumCulled=!0;this.renderOrder=
0;this.userData={}}function La(){A.call(this);this.type="Camera";this.matrixWorldInverse=new K;this.projectionMatrix=new K}function Kb(a,b,c,d,e,f){La.call(this);this.type="OrthographicCamera";this.zoom=1;this.view=null;this.left=a;this.right=b;this.top=c;this.bottom=d;this.near=void 0!==e?e:.1;this.far=void 0!==f?f:2E3;this.updateProjectionMatrix()}function Pa(a,b,c,d,e,f){this.a=a;this.b=b;this.c=c;this.normal=d&&d.isVector3?d:new p;this.vertexNormals=Array.isArray(d)?d:[];this.color=e&&e.isColor?
e:new H;this.vertexColors=Array.isArray(e)?e:[];this.materialIndex=void 0!==f?f:0}function N(){Object.defineProperty(this,"id",{value:Of+=2});this.uuid=R.generateUUID();this.name="";this.type="Geometry";this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingSphere=this.boundingBox=null;this.groupsNeedUpdate=this.lineDistancesNeedUpdate=this.colorsNeedUpdate=this.normalsNeedUpdate=
this.uvsNeedUpdate=this.verticesNeedUpdate=this.elementsNeedUpdate=!1}function P(a,b,c){if(Array.isArray(a))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.uuid=R.generateUUID();this.name="";this.array=a;this.itemSize=b;this.count=void 0!==a?a.length/b:0;this.normalized=!0===c;this.dynamic=!1;this.updateRange={offset:0,count:-1};this.onUploadCallback=function(){};this.version=0}function uc(a,b,c){P.call(this,new Int8Array(a),b,c)}function vc(a,b,c){P.call(this,new Uint8Array(a),
b,c)}function wc(a,b,c){P.call(this,new Uint8ClampedArray(a),b,c)}function xc(a,b,c){P.call(this,new Int16Array(a),b,c)}function hb(a,b,c){P.call(this,new Uint16Array(a),b,c)}function yc(a,b,c){P.call(this,new Int32Array(a),b,c)}function ib(a,b,c){P.call(this,new Uint32Array(a),b,c)}function y(a,b,c){P.call(this,new Float32Array(a),b,c)}function zc(a,b,c){P.call(this,new Float64Array(a),b,c)}function Je(){this.indices=[];this.vertices=[];this.normals=[];this.colors=[];this.uvs=[];this.uvs2=[];this.groups=
[];this.morphTargets={};this.skinWeights=[];this.skinIndices=[];this.boundingSphere=this.boundingBox=null;this.groupsNeedUpdate=this.uvsNeedUpdate=this.colorsNeedUpdate=this.normalsNeedUpdate=this.verticesNeedUpdate=!1}function Qd(a){if(0===a.length)return-Infinity;for(var b=a[0],c=1,d=a.length;c<d;++c)a[c]>b&&(b=a[c]);return b}function D(){Object.defineProperty(this,"id",{value:Pf+=2});this.uuid=R.generateUUID();this.name="";this.type="BufferGeometry";this.index=null;this.attributes={};this.morphAttributes=
{};this.groups=[];this.boundingSphere=this.boundingBox=null;this.drawRange={start:0,count:Infinity}}function Lb(a,b,c,d,e,f){N.call(this);this.type="BoxGeometry";this.parameters={width:a,height:b,depth:c,widthSegments:d,heightSegments:e,depthSegments:f};this.fromBufferGeometry(new jb(a,b,c,d,e,f));this.mergeVertices()}function jb(a,b,c,d,e,f){function g(a,b,c,d,e,f,g,m,ta,za,la){var z=f/ta,u=g/za,v=f/2,w=g/2,I=m/2;g=ta+1;var B=za+1,x=f=0,J,y,C=new p;for(y=0;y<B;y++){var A=y*u-w;for(J=0;J<g;J++)C[a]=
(J*z-v)*d,C[b]=A*e,C[c]=I,l.push(C.x,C.y,C.z),C[a]=0,C[b]=0,C[c]=0<m?1:-1,q.push(C.x,C.y,C.z),n.push(J/ta),n.push(1-y/za),f+=1}for(y=0;y<za;y++)for(J=0;J<ta;J++)a=t+J+g*(y+1),b=t+(J+1)+g*(y+1),c=t+(J+1)+g*y,k.push(t+J+g*y,a,c),k.push(a,b,c),x+=6;h.addGroup(r,x,la);r+=x;t+=f}D.call(this);this.type="BoxBufferGeometry";this.parameters={width:a,height:b,depth:c,widthSegments:d,heightSegments:e,depthSegments:f};var h=this;a=a||1;b=b||1;c=c||1;d=Math.floor(d)||1;e=Math.floor(e)||1;f=Math.floor(f)||1;var k=
[],l=[],q=[],n=[],t=0,r=0;g("z","y","x",-1,-1,c,b,a,f,e,0);g("z","y","x",1,-1,c,b,-a,f,e,1);g("x","z","y",1,1,a,c,b,d,f,2);g("x","z","y",1,-1,a,c,-b,d,f,3);g("x","y","z",1,-1,a,b,c,d,e,4);g("x","y","z",-1,-1,a,b,-c,d,e,5);this.setIndex(k);this.addAttribute("position",new y(l,3));this.addAttribute("normal",new y(q,3));this.addAttribute("uv",new y(n,2))}function Ac(a,b,c,d){N.call(this);this.type="PlaneGeometry";this.parameters={width:a,height:b,widthSegments:c,heightSegments:d};this.fromBufferGeometry(new kb(a,
b,c,d));this.mergeVertices()}function kb(a,b,c,d){D.call(this);this.type="PlaneBufferGeometry";this.parameters={width:a,height:b,widthSegments:c,heightSegments:d};a=a||1;b=b||1;var e=a/2,f=b/2;c=Math.floor(c)||1;d=Math.floor(d)||1;var g=c+1,h=d+1,k=a/c,l=b/d,q=[],n=[],t=[],r=[];for(a=0;a<h;a++){var m=a*l-f;for(b=0;b<g;b++)n.push(b*k-e,-m,0),t.push(0,0,1),r.push(b/c),r.push(1-a/d)}for(a=0;a<d;a++)for(b=0;b<c;b++)e=b+g*(a+1),f=b+1+g*(a+1),h=b+1+g*a,q.push(b+g*a,e,h),q.push(e,f,h);this.setIndex(q);this.addAttribute("position",
new y(n,3));this.addAttribute("normal",new y(t,3));this.addAttribute("uv",new y(r,2))}function va(a){Q.call(this);this.type="MeshBasicMaterial";this.color=new H(16777215);this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.envMap=this.alphaMap=this.specularMap=null;this.combine=0;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.lights=this.morphTargets=this.skinning=
!1;this.setValues(a)}function oa(a){Q.call(this);this.type="ShaderMaterial";this.defines={};this.uniforms={};this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";this.linewidth=1;this.wireframe=!1;this.wireframeLinewidth=1;this.morphNormals=this.morphTargets=this.skinning=this.clipping=this.lights=this.fog=!1;this.extensions={derivatives:!1,fragDepth:!1,
drawBuffers:!1,shaderTextureLOD:!1};this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]};this.index0AttributeName=void 0;void 0!==a&&(void 0!==a.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(a))}function lb(a,b){this.origin=void 0!==a?a:new p;this.direction=void 0!==b?b:new p}function Mb(a,b){this.start=void 0!==a?a:new p;this.end=void 0!==b?b:new p}function Qa(a,b,c){this.a=void 0!==a?a:new p;this.b=void 0!==
b?b:new p;this.c=void 0!==c?c:new p}function pa(a,b){A.call(this);this.type="Mesh";this.geometry=void 0!==a?a:new D;this.material=void 0!==b?b:new va({color:16777215*Math.random()});this.drawMode=0;this.updateMorphTargets()}function Qf(a,b,c,d){function e(a,c){b.buffers.color.setClear(a.r,a.g,a.b,c,d)}var f=new H(0),g=0,h,k,l;return{getClearColor:function(){return f},setClearColor:function(a,b){f.set(a);g=void 0!==b?b:1;e(f,g)},getClearAlpha:function(){return g},setClearAlpha:function(a){g=a;e(f,
g)},render:function(b,d,t,r){d=d.background;null===d?e(f,g):d&&d.isColor&&(e(d,1),r=!0);(a.autoClear||r)&&a.clear(a.autoClearColor,a.autoClearDepth,a.autoClearStencil);d&&d.isCubeTexture?(void 0===l&&(l=new pa(new jb(1,1,1),new oa({uniforms:mb.cube.uniforms,vertexShader:mb.cube.vertexShader,fragmentShader:mb.cube.fragmentShader,side:1,depthTest:!0,depthWrite:!1,fog:!1})),l.geometry.removeAttribute("normal"),l.geometry.removeAttribute("uv"),l.onBeforeRender=function(a,b,c){this.matrixWorld.copyPosition(c.matrixWorld)},
c.update(l.geometry)),l.material.uniforms.tCube.value=d,b.push(l,l.geometry,l.material,0,null)):d&&d.isTexture&&(void 0===h&&(h=new Kb(-1,1,1,-1,0,1),k=new pa(new kb(2,2),new va({depthTest:!1,depthWrite:!1,fog:!1})),c.update(k.geometry)),k.material.map=d,a.renderBufferDirect(h,null,k.geometry,k.material,k,null))}}}function Rf(a,b){return a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.program&&b.program&&a.program!==b.program?a.program.id-b.program.id:a.material.id!==b.material.id?a.material.id-
b.material.id:a.z!==b.z?a.z-b.z:a.id-b.id}function Sf(a,b){return a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.z!==b.z?b.z-a.z:a.id-b.id}function Tf(){var a=[],b=0,c=[],d=[];return{opaque:c,transparent:d,init:function(){b=0;c.length=0;d.length=0},push:function(e,f,g,h,k){var l=a[b];void 0===l?(l={id:e.id,object:e,geometry:f,material:g,program:g.program,renderOrder:e.renderOrder,z:h,group:k},a[b]=l):(l.id=e.id,l.object=e,l.geometry=f,l.material=g,l.program=g.program,l.renderOrder=e.renderOrder,
l.z=h,l.group=k);(!0===g.transparent?d:c).push(l);b++},sort:function(){1<c.length&&c.sort(Rf);1<d.length&&d.sort(Sf)}}}function Uf(){var a={};return{get:function(b,c){b=b.id+","+c.id;c=a[b];void 0===c&&(c=new Tf,a[b]=c);return c},dispose:function(){a={}}}}function Vf(a,b){return Math.abs(b[1])-Math.abs(a[1])}function Wf(a){var b={},c=new Float32Array(8);return{update:function(d,e,f,g){var h=d.morphTargetInfluences,k=h.length;d=b[e.id];if(void 0===d){d=[];for(var l=0;l<k;l++)d[l]=[l,0];b[e.id]=d}var q=
f.morphTargets&&e.morphAttributes.position;f=f.morphNormals&&e.morphAttributes.normal;for(l=0;l<k;l++){var n=d[l];0!==n[1]&&(q&&e.removeAttribute("morphTarget"+l),f&&e.removeAttribute("morphNormal"+l))}for(l=0;l<k;l++)n=d[l],n[0]=l,n[1]=h[l];d.sort(Vf);for(l=0;8>l;l++){if(n=d[l])if(h=n[0],n=n[1]){q&&e.addAttribute("morphTarget"+l,q[h]);f&&e.addAttribute("morphNormal"+l,f[h]);c[l]=n;continue}c[l]=0}g.getUniforms().setValue(a,"morphTargetInfluences",c)}}}function Xf(a,b,c){var d,e,f;this.setMode=function(a){d=
a};this.setIndex=function(a){e=a.type;f=a.bytesPerElement};this.render=function(b,h){a.drawElements(d,h,e,b*f);c.calls++;c.vertices+=h;d===a.TRIANGLES?c.faces+=h/3:d===a.POINTS&&(c.points+=h)};this.renderInstances=function(g,h,k){var l=b.get("ANGLE_instanced_arrays");null===l?console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."):(l.drawElementsInstancedANGLE(d,k,e,h*f,g.maxInstancedCount),c.calls++,c.vertices+=
k*g.maxInstancedCount,d===a.TRIANGLES?c.faces+=g.maxInstancedCount*k/3:d===a.POINTS&&(c.points+=g.maxInstancedCount*k))}}function Yf(a,b,c){var d;this.setMode=function(a){d=a};this.render=function(b,f){a.drawArrays(d,b,f);c.calls++;c.vertices+=f;d===a.TRIANGLES?c.faces+=f/3:d===a.POINTS&&(c.points+=f)};this.renderInstances=function(e,f,g){var h=b.get("ANGLE_instanced_arrays");if(null===h)console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
else{var k=e.attributes.position;k.isInterleavedBufferAttribute?(g=k.data.count,h.drawArraysInstancedANGLE(d,0,g,e.maxInstancedCount)):h.drawArraysInstancedANGLE(d,f,g,e.maxInstancedCount);c.calls++;c.vertices+=g*e.maxInstancedCount;d===a.TRIANGLES?c.faces+=e.maxInstancedCount*g/3:d===a.POINTS&&(c.points+=e.maxInstancedCount*g)}}}function Zf(a,b,c){function d(a){a=a.target;var g=e[a.id];null!==g.index&&b.remove(g.index);for(var k in g.attributes)b.remove(g.attributes[k]);a.removeEventListener("dispose",
d);delete e[a.id];if(k=f[a.id])b.remove(k),delete f[a.id];if(k=f[g.id])b.remove(k),delete f[g.id];c.geometries--}var e={},f={};return{get:function(a,b){var f=e[b.id];if(f)return f;b.addEventListener("dispose",d);b.isBufferGeometry?f=b:b.isGeometry&&(void 0===b._bufferGeometry&&(b._bufferGeometry=(new D).setFromObject(a)),f=b._bufferGeometry);e[b.id]=f;c.geometries++;return f},update:function(c){var d=c.index,e=c.attributes;null!==d&&b.update(d,a.ELEMENT_ARRAY_BUFFER);for(var f in e)b.update(e[f],
a.ARRAY_BUFFER);c=c.morphAttributes;for(f in c)for(var d=c[f],e=0,g=d.length;e<g;e++)b.update(d[e],a.ARRAY_BUFFER)},getWireframeAttribute:function(c){var d=f[c.id];if(d)return d;d=[];var e=c.index;var g=c.attributes;if(null!==e){var q=e.array;for(var n=0,t=q.length;n<t;n+=3){var r=q[n+0];g=q[n+1];e=q[n+2];d.push(r,g,g,e,e,r)}}else for(q=g.position.array,n=0,t=q.length/3-1;n<t;n+=3)r=n+0,g=n+1,e=n+2,d.push(r,g,g,e,e,r);d=new (65535<Qd(d)?ib:hb)(d,1);b.update(d,a.ELEMENT_ARRAY_BUFFER);return f[c.id]=
d}}}function $f(){var a={};return{get:function(b){if(void 0!==a[b.id])return a[b.id];switch(b.type){case "DirectionalLight":var c={direction:new p,color:new H,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new C};break;case "SpotLight":c={position:new p,direction:new p,color:new H,distance:0,coneCos:0,penumbraCos:0,decay:0,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new C};break;case "PointLight":c={position:new p,color:new H,distance:0,decay:0,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new C,
shadowCameraNear:1,shadowCameraFar:1E3};break;case "HemisphereLight":c={direction:new p,skyColor:new H,groundColor:new H};break;case "RectAreaLight":c={color:new H,position:new p,halfWidth:new p,halfHeight:new p}}return a[b.id]=c}}}function ag(){var a=new $f,b={hash:"",ambient:[0,0,0],directional:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],point:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]},c=new p,d=new K,e=new K;return{setup:function(f,
g,h){for(var k,l=0,q=0,n=0,t=0,r=0,m=0,v=0,w=0,p=h.matrixWorldInverse,z=0,I=f.length;z<I;z++){var B=f[z];k=B.color;var J=B.intensity,ta=B.distance,za=B.shadow&&B.shadow.map?B.shadow.map.texture:null;if(B.isAmbientLight)l+=k.r*J,q+=k.g*J,n+=k.b*J;else if(B.isDirectionalLight){h=a.get(B);h.color.copy(B.color).multiplyScalar(B.intensity);h.direction.setFromMatrixPosition(B.matrixWorld);c.setFromMatrixPosition(B.target.matrixWorld);h.direction.sub(c);h.direction.transformDirection(p);if(h.shadow=B.castShadow)k=
B.shadow,h.shadowBias=k.bias,h.shadowRadius=k.radius,h.shadowMapSize=k.mapSize;b.directionalShadowMap[t]=za;b.directionalShadowMatrix[t]=B.shadow.matrix;b.directional[t]=h;t++}else if(B.isSpotLight){h=a.get(B);h.position.setFromMatrixPosition(B.matrixWorld);h.position.applyMatrix4(p);h.color.copy(k).multiplyScalar(J);h.distance=ta;h.direction.setFromMatrixPosition(B.matrixWorld);c.setFromMatrixPosition(B.target.matrixWorld);h.direction.sub(c);h.direction.transformDirection(p);h.coneCos=Math.cos(B.angle);
h.penumbraCos=Math.cos(B.angle*(1-B.penumbra));h.decay=0===B.distance?0:B.decay;if(h.shadow=B.castShadow)k=B.shadow,h.shadowBias=k.bias,h.shadowRadius=k.radius,h.shadowMapSize=k.mapSize;b.spotShadowMap[m]=za;b.spotShadowMatrix[m]=B.shadow.matrix;b.spot[m]=h;m++}else if(B.isRectAreaLight)h=a.get(B),h.color.copy(k).multiplyScalar(J/(B.width*B.height)),h.position.setFromMatrixPosition(B.matrixWorld),h.position.applyMatrix4(p),e.identity(),d.copy(B.matrixWorld),d.premultiply(p),e.extractRotation(d),h.halfWidth.set(.5*
B.width,0,0),h.halfHeight.set(0,.5*B.height,0),h.halfWidth.applyMatrix4(e),h.halfHeight.applyMatrix4(e),b.rectArea[v]=h,v++;else if(B.isPointLight){h=a.get(B);h.position.setFromMatrixPosition(B.matrixWorld);h.position.applyMatrix4(p);h.color.copy(B.color).multiplyScalar(B.intensity);h.distance=B.distance;h.decay=0===B.distance?0:B.decay;if(h.shadow=B.castShadow)k=B.shadow,h.shadowBias=k.bias,h.shadowRadius=k.radius,h.shadowMapSize=k.mapSize,h.shadowCameraNear=k.camera.near,h.shadowCameraFar=k.camera.far;
b.pointShadowMap[r]=za;b.pointShadowMatrix[r]=B.shadow.matrix;b.point[r]=h;r++}else B.isHemisphereLight&&(h=a.get(B),h.direction.setFromMatrixPosition(B.matrixWorld),h.direction.transformDirection(p),h.direction.normalize(),h.skyColor.copy(B.color).multiplyScalar(J),h.groundColor.copy(B.groundColor).multiplyScalar(J),b.hemi[w]=h,w++)}b.ambient[0]=l;b.ambient[1]=q;b.ambient[2]=n;b.directional.length=t;b.spot.length=m;b.rectArea.length=v;b.point.length=r;b.hemi.length=w;b.hash=t+","+r+","+m+","+v+","+
w+","+g.length},state:b}}function bg(a,b){var c={};return{update:function(d){var e=b.frame,f=d.geometry,g=a.get(d,f);c[g.id]!==e&&(f.isGeometry&&g.updateFromObject(d),a.update(g),c[g.id]=e);return g},clear:function(){c={}}}}function cg(a){a=a.split("\n");for(var b=0;b<a.length;b++)a[b]=b+1+": "+a[b];return a.join("\n")}function Ke(a,b,c){var d=a.createShader(b);a.shaderSource(d,c);a.compileShader(d);!1===a.getShaderParameter(d,a.COMPILE_STATUS)&&console.error("THREE.WebGLShader: Shader couldn't compile.");
""!==a.getShaderInfoLog(d)&&console.warn("THREE.WebGLShader: gl.getShaderInfoLog()",b===a.VERTEX_SHADER?"vertex":"fragment",a.getShaderInfoLog(d),cg(c));return d}function Le(a){switch(a){case 3E3:return["Linear","( value )"];case 3001:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];default:throw Error("unsupported encoding: "+
a);}}function Rd(a,b){b=Le(b);return"vec4 "+a+"( vec4 value ) { return "+b[0]+"ToLinear"+b[1]+"; }"}function dg(a,b){b=Le(b);return"vec4 "+a+"( vec4 value ) { return LinearTo"+b[0]+b[1]+"; }"}function eg(a,b){switch(b){case 1:b="Linear";break;case 2:b="Reinhard";break;case 3:b="Uncharted2";break;case 4:b="OptimizedCineon";break;default:throw Error("unsupported toneMapping: "+b);}return"vec3 "+a+"( vec3 color ) { return "+b+"ToneMapping( color ); }"}function fg(a,b,c){a=a||{};return[a.derivatives||
b.envMapCubeUV||b.bumpMap||b.normalMap||b.flatShading?"#extension GL_OES_standard_derivatives : enable":"",(a.fragDepth||b.logarithmicDepthBuffer)&&c.get("EXT_frag_depth")?"#extension GL_EXT_frag_depth : enable":"",a.drawBuffers&&c.get("WEBGL_draw_buffers")?"#extension GL_EXT_draw_buffers : require":"",(a.shaderTextureLOD||b.envMap)&&c.get("EXT_shader_texture_lod")?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Bc).join("\n")}function gg(a){var b=[],c;for(c in a){var d=a[c];!1!==d&&b.push("#define "+
c+" "+d)}return b.join("\n")}function Bc(a){return""!==a}function Me(a,b){return a.replace(/NUM_DIR_LIGHTS/g,b.numDirLights).replace(/NUM_SPOT_LIGHTS/g,b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,b.numPointLights).replace(/NUM_HEMI_LIGHTS/g,b.numHemiLights)}function Sd(a){return a.replace(/^[ \t]*#include +<([\w\d.]+)>/gm,function(a,c){a=W[c];if(void 0===a)throw Error("Can not resolve #include <"+c+">");return Sd(a)})}function Ne(a){return a.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
function(a,c,d,e){a="";for(c=parseInt(c);c<parseInt(d);c++)a+=e.replace(/\[ i \]/g,"[ "+c+" ]");return a})}function hg(a,b,c,d,e,f){var g=a.context,h=d.defines,k=e.vertexShader,l=e.fragmentShader,q="SHADOWMAP_TYPE_BASIC";1===f.shadowMapType?q="SHADOWMAP_TYPE_PCF":2===f.shadowMapType&&(q="SHADOWMAP_TYPE_PCF_SOFT");var n="ENVMAP_TYPE_CUBE",t="ENVMAP_MODE_REFLECTION",r="ENVMAP_BLENDING_MULTIPLY";if(f.envMap){switch(d.envMap.mapping){case 301:case 302:n="ENVMAP_TYPE_CUBE";break;case 306:case 307:n="ENVMAP_TYPE_CUBE_UV";
break;case 303:case 304:n="ENVMAP_TYPE_EQUIREC";break;case 305:n="ENVMAP_TYPE_SPHERE"}switch(d.envMap.mapping){case 302:case 304:t="ENVMAP_MODE_REFRACTION"}switch(d.combine){case 0:r="ENVMAP_BLENDING_MULTIPLY";break;case 1:r="ENVMAP_BLENDING_MIX";break;case 2:r="ENVMAP_BLENDING_ADD"}}var m=0<a.gammaFactor?a.gammaFactor:1,v=fg(d.extensions,f,b),w=gg(h),p=g.createProgram();d.isRawShaderMaterial?(h=[w].filter(Bc).join("\n"),0<h.length&&(h+="\n"),b=[v,w].filter(Bc).join("\n"),0<b.length&&(b+="\n")):(h=
["precision "+f.precision+" float;","precision "+f.precision+" int;","#define SHADER_NAME "+e.name,w,f.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+m,"#define MAX_BONES "+f.maxBones,f.useFog&&f.fog?"#define USE_FOG":"",f.useFog&&f.fogExp?"#define FOG_EXP2":"",f.map?"#define USE_MAP":"",f.envMap?"#define USE_ENVMAP":"",f.envMap?"#define "+t:"",f.lightMap?"#define USE_LIGHTMAP":"",f.aoMap?"#define USE_AOMAP":"",f.emissiveMap?"#define USE_EMISSIVEMAP":"",f.bumpMap?"#define USE_BUMPMAP":
"",f.normalMap?"#define USE_NORMALMAP":"",f.displacementMap&&f.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",f.specularMap?"#define USE_SPECULARMAP":"",f.roughnessMap?"#define USE_ROUGHNESSMAP":"",f.metalnessMap?"#define USE_METALNESSMAP":"",f.alphaMap?"#define USE_ALPHAMAP":"",f.vertexColors?"#define USE_COLOR":"",f.flatShading?"#define FLAT_SHADED":"",f.skinning?"#define USE_SKINNING":"",f.useVertexTexture?"#define BONE_TEXTURE":"",f.morphTargets?"#define USE_MORPHTARGETS":"",f.morphNormals&&
!1===f.flatShading?"#define USE_MORPHNORMALS":"",f.doubleSided?"#define DOUBLE_SIDED":"",f.flipSided?"#define FLIP_SIDED":"","#define NUM_CLIPPING_PLANES "+f.numClippingPlanes,f.shadowMapEnabled?"#define USE_SHADOWMAP":"",f.shadowMapEnabled?"#define "+q:"",f.sizeAttenuation?"#define USE_SIZEATTENUATION":"",f.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",f.logarithmicDepthBuffer&&b.get("EXT_frag_depth")?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;",
"uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_COLOR","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;",
"\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Bc).join("\n"),b=[v,"precision "+f.precision+" float;","precision "+f.precision+" int;","#define SHADER_NAME "+e.name,w,f.alphaTest?"#define ALPHATEST "+f.alphaTest:
"","#define GAMMA_FACTOR "+m,f.useFog&&f.fog?"#define USE_FOG":"",f.useFog&&f.fogExp?"#define FOG_EXP2":"",f.map?"#define USE_MAP":"",f.envMap?"#define USE_ENVMAP":"",f.envMap?"#define "+n:"",f.envMap?"#define "+t:"",f.envMap?"#define "+r:"",f.lightMap?"#define USE_LIGHTMAP":"",f.aoMap?"#define USE_AOMAP":"",f.emissiveMap?"#define USE_EMISSIVEMAP":"",f.bumpMap?"#define USE_BUMPMAP":"",f.normalMap?"#define USE_NORMALMAP":"",f.specularMap?"#define USE_SPECULARMAP":"",f.roughnessMap?"#define USE_ROUGHNESSMAP":
"",f.metalnessMap?"#define USE_METALNESSMAP":"",f.alphaMap?"#define USE_ALPHAMAP":"",f.vertexColors?"#define USE_COLOR":"",f.gradientMap?"#define USE_GRADIENTMAP":"",f.flatShading?"#define FLAT_SHADED":"",f.doubleSided?"#define DOUBLE_SIDED":"",f.flipSided?"#define FLIP_SIDED":"","#define NUM_CLIPPING_PLANES "+f.numClippingPlanes,"#define UNION_CLIPPING_PLANES "+(f.numClippingPlanes-f.numClipIntersection),f.shadowMapEnabled?"#define USE_SHADOWMAP":"",f.shadowMapEnabled?"#define "+q:"",f.premultipliedAlpha?
"#define PREMULTIPLIED_ALPHA":"",f.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",f.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",f.logarithmicDepthBuffer&&b.get("EXT_frag_depth")?"#define USE_LOGDEPTHBUF_EXT":"",f.envMap&&b.get("EXT_shader_texture_lod")?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;",0!==f.toneMapping?"#define TONE_MAPPING":"",0!==f.toneMapping?W.tonemapping_pars_fragment:"",0!==f.toneMapping?eg("toneMapping",f.toneMapping):
"",f.dithering?"#define DITHERING":"",f.outputEncoding||f.mapEncoding||f.envMapEncoding||f.emissiveMapEncoding?W.encodings_pars_fragment:"",f.mapEncoding?Rd("mapTexelToLinear",f.mapEncoding):"",f.envMapEncoding?Rd("envMapTexelToLinear",f.envMapEncoding):"",f.emissiveMapEncoding?Rd("emissiveMapTexelToLinear",f.emissiveMapEncoding):"",f.outputEncoding?dg("linearToOutputTexel",f.outputEncoding):"",f.depthPacking?"#define DEPTH_PACKING "+d.depthPacking:"","\n"].filter(Bc).join("\n"));k=Sd(k);k=Me(k,f);
l=Sd(l);l=Me(l,f);d.isShaderMaterial||(k=Ne(k),l=Ne(l));l=b+l;k=Ke(g,g.VERTEX_SHADER,h+k);l=Ke(g,g.FRAGMENT_SHADER,l);g.attachShader(p,k);g.attachShader(p,l);void 0!==d.index0AttributeName?g.bindAttribLocation(p,0,d.index0AttributeName):!0===f.morphTargets&&g.bindAttribLocation(p,0,"position");g.linkProgram(p);f=g.getProgramInfoLog(p);e=g.getShaderInfoLog(k);q=g.getShaderInfoLog(l);t=n=!0;if(!1===g.getProgramParameter(p,g.LINK_STATUS))n=!1,console.error("THREE.WebGLProgram: shader error: ",g.getError(),
"gl.VALIDATE_STATUS",g.getProgramParameter(p,g.VALIDATE_STATUS),"gl.getProgramInfoLog",f,e,q);else if(""!==f)console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",f);else if(""===e||""===q)t=!1;t&&(this.diagnostics={runnable:n,material:d,programLog:f,vertexShader:{log:e,prefix:h},fragmentShader:{log:q,prefix:b}});g.deleteShader(k);g.deleteShader(l);var z;this.getUniforms=function(){void 0===z&&(z=new gb(g,p,a));return z};var I;this.getAttributes=function(){if(void 0===I){for(var a={},b=g.getProgramParameter(p,
g.ACTIVE_ATTRIBUTES),c=0;c<b;c++){var d=g.getActiveAttrib(p,c).name;a[d]=g.getAttribLocation(p,d)}I=a}return I};this.destroy=function(){g.deleteProgram(p);this.program=void 0};Object.defineProperties(this,{uniforms:{get:function(){console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");return this.getUniforms()}},attributes:{get:function(){console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");return this.getAttributes()}}});this.id=ig++;this.code=c;this.usedTimes=1;
this.program=p;this.vertexShader=k;this.fragmentShader=l;return this}function jg(a,b,c){function d(a,b){if(a)a.isTexture?c=a.encoding:a.isWebGLRenderTarget&&(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),c=a.texture.encoding);else var c=3E3;3E3===c&&b&&(c=3007);return c}var e=[],f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",
MeshPhongMaterial:"phong",MeshToonMaterial:"phong",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow"},g="precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
this.getParameters=function(b,e,g,q,n,t,r){var h=f[b.type];if(r.isSkinnedMesh){var l=r.skeleton.bones;if(c.floatVertexTextures)l=1024;else{var k=Math.min(Math.floor((c.maxVertexUniforms-20)/4),l.length);k<l.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+l.length+" bones. This GPU supports "+k+"."),l=0):l=k}}else l=0;k=c.precision;null!==b.precision&&(k=c.getMaxPrecision(b.precision),k!==b.precision&&console.warn("THREE.WebGLProgram.getParameters:",b.precision,"not supported, using",k,"instead."));
var m=a.getRenderTarget();return{shaderID:h,precision:k,supportsVertexTextures:c.vertexTextures,outputEncoding:d(m?m.texture:null,a.gammaOutput),map:!!b.map,mapEncoding:d(b.map,a.gammaInput),envMap:!!b.envMap,envMapMode:b.envMap&&b.envMap.mapping,envMapEncoding:d(b.envMap,a.gammaInput),envMapCubeUV:!!b.envMap&&(306===b.envMap.mapping||307===b.envMap.mapping),lightMap:!!b.lightMap,aoMap:!!b.aoMap,emissiveMap:!!b.emissiveMap,emissiveMapEncoding:d(b.emissiveMap,a.gammaInput),bumpMap:!!b.bumpMap,normalMap:!!b.normalMap,
displacementMap:!!b.displacementMap,roughnessMap:!!b.roughnessMap,metalnessMap:!!b.metalnessMap,specularMap:!!b.specularMap,alphaMap:!!b.alphaMap,gradientMap:!!b.gradientMap,combine:b.combine,vertexColors:b.vertexColors,fog:!!q,useFog:b.fog,fogExp:q&&q.isFogExp2,flatShading:b.flatShading,sizeAttenuation:b.sizeAttenuation,logarithmicDepthBuffer:c.logarithmicDepthBuffer,skinning:b.skinning&&0<l,maxBones:l,useVertexTexture:c.floatVertexTextures,morphTargets:b.morphTargets,morphNormals:b.morphNormals,
maxMorphTargets:a.maxMorphTargets,maxMorphNormals:a.maxMorphNormals,numDirLights:e.directional.length,numPointLights:e.point.length,numSpotLights:e.spot.length,numRectAreaLights:e.rectArea.length,numHemiLights:e.hemi.length,numClippingPlanes:n,numClipIntersection:t,dithering:b.dithering,shadowMapEnabled:a.shadowMap.enabled&&r.receiveShadow&&0<g.length,shadowMapType:a.shadowMap.type,toneMapping:a.toneMapping,physicallyCorrectLights:a.physicallyCorrectLights,premultipliedAlpha:b.premultipliedAlpha,
alphaTest:b.alphaTest,doubleSided:2===b.side,flipSided:1===b.side,depthPacking:void 0!==b.depthPacking?b.depthPacking:!1}};this.getProgramCode=function(b,c){var d=[];c.shaderID?d.push(c.shaderID):(d.push(b.fragmentShader),d.push(b.vertexShader));if(void 0!==b.defines)for(var e in b.defines)d.push(e),d.push(b.defines[e]);for(e=0;e<g.length;e++)d.push(c[g[e]]);d.push(b.onBeforeCompile.toString());d.push(a.gammaOutput);return d.join()};this.acquireProgram=function(c,d,f,g){for(var h,l=0,k=e.length;l<
k;l++){var q=e[l];if(q.code===g){h=q;++h.usedTimes;break}}void 0===h&&(h=new hg(a,b,g,c,d,f),e.push(h));return h};this.releaseProgram=function(a){if(0===--a.usedTimes){var b=e.indexOf(a);e[b]=e[e.length-1];e.pop();a.destroy()}};this.programs=e}function kg(a,b,c,d,e,f,g){function h(a,b){if(a.width>b||a.height>b){b/=Math.max(a.width,a.height);var c=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");c.width=Math.floor(a.width*b);c.height=Math.floor(a.height*b);c.getContext("2d").drawImage(a,
0,0,a.width,a.height,0,0,c.width,c.height);console.warn("THREE.WebGLRenderer: image is too big ("+a.width+"x"+a.height+"). Resized to "+c.width+"x"+c.height,a);return c}return a}function k(a){return R.isPowerOfTwo(a.width)&&R.isPowerOfTwo(a.height)}function l(a,b){return a.generateMipmaps&&b&&1003!==a.minFilter&&1006!==a.minFilter}function q(b){return 1003===b||1004===b||1005===b?a.NEAREST:a.LINEAR}function n(b){b=b.target;b.removeEventListener("dispose",n);a:{var c=d.get(b);if(b.image&&c.__image__webglTextureCube)a.deleteTexture(c.__image__webglTextureCube);
else{if(void 0===c.__webglInit)break a;a.deleteTexture(c.__webglTexture)}d.remove(b)}g.textures--}function t(b){b=b.target;b.removeEventListener("dispose",t);var c=d.get(b),e=d.get(b.texture);if(b){void 0!==e.__webglTexture&&a.deleteTexture(e.__webglTexture);b.depthTexture&&b.depthTexture.dispose();if(b.isWebGLRenderTargetCube)for(e=0;6>e;e++)a.deleteFramebuffer(c.__webglFramebuffer[e]),c.__webglDepthbuffer&&a.deleteRenderbuffer(c.__webglDepthbuffer[e]);else a.deleteFramebuffer(c.__webglFramebuffer),
c.__webglDepthbuffer&&a.deleteRenderbuffer(c.__webglDepthbuffer);d.remove(b.texture);d.remove(b)}g.textures--}function r(b,q){var t=d.get(b);if(0<b.version&&t.__version!==b.version){var r=b.image;if(void 0===r)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined",b);else if(!1===r.complete)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete",b);else{void 0===t.__webglInit&&(t.__webglInit=!0,b.addEventListener("dispose",n),t.__webglTexture=
a.createTexture(),g.textures++);c.activeTexture(a.TEXTURE0+q);c.bindTexture(a.TEXTURE_2D,t.__webglTexture);a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,b.flipY);a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,b.premultiplyAlpha);a.pixelStorei(a.UNPACK_ALIGNMENT,b.unpackAlignment);var u=h(b.image,e.maxTextureSize);(1001!==b.wrapS||1001!==b.wrapT||1003!==b.minFilter&&1006!==b.minFilter)&&!1===k(u)&&(q=u,q instanceof HTMLImageElement||q instanceof HTMLCanvasElement||q instanceof ImageBitmap?(r=document.createElementNS("http://www.w3.org/1999/xhtml",
"canvas"),r.width=R.floorPowerOfTwo(q.width),r.height=R.floorPowerOfTwo(q.height),r.getContext("2d").drawImage(q,0,0,r.width,r.height),console.warn("THREE.WebGLRenderer: image is not power of two ("+q.width+"x"+q.height+"). Resized to "+r.width+"x"+r.height,q),u=r):u=q);q=k(u);var r=f.convert(b.format),z=f.convert(b.type);m(a.TEXTURE_2D,b,q);var p=b.mipmaps;if(b.isDepthTexture){p=a.DEPTH_COMPONENT;if(1015===b.type){if(!x)throw Error("Float Depth Texture only supported in WebGL2.0");p=a.DEPTH_COMPONENT32F}else x&&
(p=a.DEPTH_COMPONENT16);1026===b.format&&p===a.DEPTH_COMPONENT&&1012!==b.type&&1014!==b.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),b.type=1012,z=f.convert(b.type));1027===b.format&&(p=a.DEPTH_STENCIL,1020!==b.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),b.type=1020,z=f.convert(b.type)));c.texImage2D(a.TEXTURE_2D,0,p,u.width,u.height,0,r,z,null)}else if(b.isDataTexture)if(0<
p.length&&q){for(var v=0,w=p.length;v<w;v++)u=p[v],c.texImage2D(a.TEXTURE_2D,v,r,u.width,u.height,0,r,z,u.data);b.generateMipmaps=!1}else c.texImage2D(a.TEXTURE_2D,0,r,u.width,u.height,0,r,z,u.data);else if(b.isCompressedTexture)for(v=0,w=p.length;v<w;v++)u=p[v],1023!==b.format&&1022!==b.format?-1<c.getCompressedTextureFormats().indexOf(r)?c.compressedTexImage2D(a.TEXTURE_2D,v,r,u.width,u.height,0,u.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):
c.texImage2D(a.TEXTURE_2D,v,r,u.width,u.height,0,r,z,u.data);else if(0<p.length&&q){v=0;for(w=p.length;v<w;v++)u=p[v],c.texImage2D(a.TEXTURE_2D,v,r,r,z,u);b.generateMipmaps=!1}else c.texImage2D(a.TEXTURE_2D,0,r,r,z,u);l(b,q)&&a.generateMipmap(a.TEXTURE_2D);t.__version=b.version;if(b.onUpdate)b.onUpdate(b);return}}c.activeTexture(a.TEXTURE0+q);c.bindTexture(a.TEXTURE_2D,t.__webglTexture)}function m(c,g,h){h?(a.texParameteri(c,a.TEXTURE_WRAP_S,f.convert(g.wrapS)),a.texParameteri(c,a.TEXTURE_WRAP_T,
f.convert(g.wrapT)),a.texParameteri(c,a.TEXTURE_MAG_FILTER,f.convert(g.magFilter)),a.texParameteri(c,a.TEXTURE_MIN_FILTER,f.convert(g.minFilter))):(a.texParameteri(c,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(c,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),1001===g.wrapS&&1001===g.wrapT||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",g),a.texParameteri(c,a.TEXTURE_MAG_FILTER,q(g.magFilter)),a.texParameteri(c,
a.TEXTURE_MIN_FILTER,q(g.minFilter)),1003!==g.minFilter&&1006!==g.minFilter&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.",g));!(h=b.get("EXT_texture_filter_anisotropic"))||1015===g.type&&null===b.get("OES_texture_float_linear")||1016===g.type&&null===b.get("OES_texture_half_float_linear")||!(1<g.anisotropy||d.get(g).__currentAnisotropy)||(a.texParameterf(c,h.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(g.anisotropy,
e.getMaxAnisotropy())),d.get(g).__currentAnisotropy=g.anisotropy)}function p(b,e,g,h){var l=f.convert(e.texture.format),k=f.convert(e.texture.type);c.texImage2D(h,0,l,e.width,e.height,0,l,k,null);a.bindFramebuffer(a.FRAMEBUFFER,b);a.framebufferTexture2D(a.FRAMEBUFFER,g,h,d.get(e.texture).__webglTexture,0);a.bindFramebuffer(a.FRAMEBUFFER,null)}function w(b,c){a.bindRenderbuffer(a.RENDERBUFFER,b);c.depthBuffer&&!c.stencilBuffer?(a.renderbufferStorage(a.RENDERBUFFER,a.DEPTH_COMPONENT16,c.width,c.height),
a.framebufferRenderbuffer(a.FRAMEBUFFER,a.DEPTH_ATTACHMENT,a.RENDERBUFFER,b)):c.depthBuffer&&c.stencilBuffer?(a.renderbufferStorage(a.RENDERBUFFER,a.DEPTH_STENCIL,c.width,c.height),a.framebufferRenderbuffer(a.FRAMEBUFFER,a.DEPTH_STENCIL_ATTACHMENT,a.RENDERBUFFER,b)):a.renderbufferStorage(a.RENDERBUFFER,a.RGBA4,c.width,c.height);a.bindRenderbuffer(a.RENDERBUFFER,null)}var x="undefined"!==typeof WebGL2RenderingContext&&a instanceof window.WebGL2RenderingContext;this.setTexture2D=r;this.setTextureCube=
function(b,q){var t=d.get(b);if(6===b.image.length)if(0<b.version&&t.__version!==b.version){t.__image__webglTextureCube||(b.addEventListener("dispose",n),t.__image__webglTextureCube=a.createTexture(),g.textures++);c.activeTexture(a.TEXTURE0+q);c.bindTexture(a.TEXTURE_CUBE_MAP,t.__image__webglTextureCube);a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,b.flipY);q=b&&b.isCompressedTexture;for(var r=b.image[0]&&b.image[0].isDataTexture,u=[],p=0;6>p;p++)u[p]=q||r?r?b.image[p].image:b.image[p]:h(b.image[p],e.maxCubemapSize);
var v=k(u[0]),w=f.convert(b.format),z=f.convert(b.type);m(a.TEXTURE_CUBE_MAP,b,v);for(p=0;6>p;p++)if(q)for(var x,I=u[p].mipmaps,y=0,C=I.length;y<C;y++)x=I[y],1023!==b.format&&1022!==b.format?-1<c.getCompressedTextureFormats().indexOf(w)?c.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+p,y,w,x.width,x.height,0,x.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+p,y,w,x.width,x.height,
0,w,z,x.data);else r?c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+p,0,w,u[p].width,u[p].height,0,w,z,u[p].data):c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+p,0,w,w,z,u[p]);l(b,v)&&a.generateMipmap(a.TEXTURE_CUBE_MAP);t.__version=b.version;if(b.onUpdate)b.onUpdate(b)}else c.activeTexture(a.TEXTURE0+q),c.bindTexture(a.TEXTURE_CUBE_MAP,t.__image__webglTextureCube)};this.setTextureCubeDynamic=function(b,e){c.activeTexture(a.TEXTURE0+e);c.bindTexture(a.TEXTURE_CUBE_MAP,d.get(b).__webglTexture)};this.setupRenderTarget=
function(b){var e=d.get(b),f=d.get(b.texture);b.addEventListener("dispose",t);f.__webglTexture=a.createTexture();g.textures++;var h=!0===b.isWebGLRenderTargetCube,n=k(b);if(h){e.__webglFramebuffer=[];for(var q=0;6>q;q++)e.__webglFramebuffer[q]=a.createFramebuffer()}else e.__webglFramebuffer=a.createFramebuffer();if(h){c.bindTexture(a.TEXTURE_CUBE_MAP,f.__webglTexture);m(a.TEXTURE_CUBE_MAP,b.texture,n);for(q=0;6>q;q++)p(e.__webglFramebuffer[q],b,a.COLOR_ATTACHMENT0,a.TEXTURE_CUBE_MAP_POSITIVE_X+q);
l(b.texture,n)&&a.generateMipmap(a.TEXTURE_CUBE_MAP);c.bindTexture(a.TEXTURE_CUBE_MAP,null)}else c.bindTexture(a.TEXTURE_2D,f.__webglTexture),m(a.TEXTURE_2D,b.texture,n),p(e.__webglFramebuffer,b,a.COLOR_ATTACHMENT0,a.TEXTURE_2D),l(b.texture,n)&&a.generateMipmap(a.TEXTURE_2D),c.bindTexture(a.TEXTURE_2D,null);if(b.depthBuffer){e=d.get(b);f=!0===b.isWebGLRenderTargetCube;if(b.depthTexture){if(f)throw Error("target.depthTexture not supported in Cube render targets");if(b&&b.isWebGLRenderTargetCube)throw Error("Depth Texture with cube render targets is not supported");
a.bindFramebuffer(a.FRAMEBUFFER,e.__webglFramebuffer);if(!b.depthTexture||!b.depthTexture.isDepthTexture)throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");d.get(b.depthTexture).__webglTexture&&b.depthTexture.image.width===b.width&&b.depthTexture.image.height===b.height||(b.depthTexture.image.width=b.width,b.depthTexture.image.height=b.height,b.depthTexture.needsUpdate=!0);r(b.depthTexture,0);e=d.get(b.depthTexture).__webglTexture;if(1026===b.depthTexture.format)a.framebufferTexture2D(a.FRAMEBUFFER,
a.DEPTH_ATTACHMENT,a.TEXTURE_2D,e,0);else if(1027===b.depthTexture.format)a.framebufferTexture2D(a.FRAMEBUFFER,a.DEPTH_STENCIL_ATTACHMENT,a.TEXTURE_2D,e,0);else throw Error("Unknown depthTexture format");}else if(f)for(e.__webglDepthbuffer=[],f=0;6>f;f++)a.bindFramebuffer(a.FRAMEBUFFER,e.__webglFramebuffer[f]),e.__webglDepthbuffer[f]=a.createRenderbuffer(),w(e.__webglDepthbuffer[f],b);else a.bindFramebuffer(a.FRAMEBUFFER,e.__webglFramebuffer),e.__webglDepthbuffer=a.createRenderbuffer(),w(e.__webglDepthbuffer,
b);a.bindFramebuffer(a.FRAMEBUFFER,null)}};this.updateRenderTargetMipmap=function(b){var e=b.texture,f=k(b);l(e,f)&&(b=b.isWebGLRenderTargetCube?a.TEXTURE_CUBE_MAP:a.TEXTURE_2D,e=d.get(e).__webglTexture,c.bindTexture(b,e),a.generateMipmap(b),c.bindTexture(b,null))}}function lg(){var a={};return{get:function(b){b=b.uuid;var c=a[b];void 0===c&&(c={},a[b]=c);return c},remove:function(b){delete a[b.uuid]},clear:function(){a={}}}}function mg(a,b,c){function d(b,c,d){var e=new Uint8Array(4),f=a.createTexture();
a.bindTexture(b,f);a.texParameteri(b,a.TEXTURE_MIN_FILTER,a.NEAREST);a.texParameteri(b,a.TEXTURE_MAG_FILTER,a.NEAREST);for(b=0;b<d;b++)a.texImage2D(c+b,0,a.RGBA,1,1,0,a.RGBA,a.UNSIGNED_BYTE,e);return f}function e(b){!0!==z[b]&&(a.enable(b),z[b]=!0)}function f(b){!1!==z[b]&&(a.disable(b),z[b]=!1)}function g(b,d,g,h,l,k,n,q){0!==b?e(a.BLEND):f(a.BLEND);if(5!==b){if(b!==J||q!==L)switch(b){case 2:q?(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.ONE,a.ONE,a.ONE,a.ONE)):(a.blendEquation(a.FUNC_ADD),
a.blendFunc(a.SRC_ALPHA,a.ONE));break;case 3:q?(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.ZERO,a.ZERO,a.ONE_MINUS_SRC_COLOR,a.ONE_MINUS_SRC_ALPHA)):(a.blendEquation(a.FUNC_ADD),a.blendFunc(a.ZERO,a.ONE_MINUS_SRC_COLOR));break;case 4:q?(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.ZERO,a.SRC_COLOR,a.ZERO,a.SRC_ALPHA)):(a.blendEquation(a.FUNC_ADD),a.blendFunc(a.ZERO,a.SRC_COLOR));break;default:q?(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.ONE,
a.ONE_MINUS_SRC_ALPHA,a.ONE,a.ONE_MINUS_SRC_ALPHA)):(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.SRC_ALPHA,a.ONE_MINUS_SRC_ALPHA,a.ONE,a.ONE_MINUS_SRC_ALPHA))}E=A=ha=C=y=ta=null}else{l=l||d;k=k||g;n=n||h;if(d!==ta||l!==ha)a.blendEquationSeparate(c.convert(d),c.convert(l)),ta=d,ha=l;if(g!==y||h!==C||k!==A||n!==E)a.blendFuncSeparate(c.convert(g),c.convert(h),c.convert(k),c.convert(n)),y=g,C=h,A=k,E=n}J=b;L=q}function h(b){D!==b&&(b?a.frontFace(a.CW):a.frontFace(a.CCW),D=b)}
function k(b){0!==b?(e(a.CULL_FACE),b!==H&&(1===b?a.cullFace(a.BACK):2===b?a.cullFace(a.FRONT):a.cullFace(a.FRONT_AND_BACK))):f(a.CULL_FACE);H=b}function l(b,c,d){if(b){if(e(a.POLYGON_OFFSET_FILL),V!==c||K!==d)a.polygonOffset(c,d),V=c,K=d}else f(a.POLYGON_OFFSET_FILL)}function q(b){void 0===b&&(b=a.TEXTURE0+N-1);R!==b&&(a.activeTexture(b),R=b)}var n=new function(){var b=!1,c=new da,d=null,e=new da(0,0,0,0);return{setMask:function(c){d===c||b||(a.colorMask(c,c,c,c),d=c)},setLocked:function(a){b=a},
setClear:function(b,d,f,g,h){!0===h&&(b*=g,d*=g,f*=g);c.set(b,d,f,g);!1===e.equals(c)&&(a.clearColor(b,d,f,g),e.copy(c))},reset:function(){b=!1;d=null;e.set(-1,0,0,0)}}},t=new function(){var b=!1,c=null,d=null,g=null;return{setTest:function(b){b?e(a.DEPTH_TEST):f(a.DEPTH_TEST)},setMask:function(d){c===d||b||(a.depthMask(d),c=d)},setFunc:function(b){if(d!==b){if(b)switch(b){case 0:a.depthFunc(a.NEVER);break;case 1:a.depthFunc(a.ALWAYS);break;case 2:a.depthFunc(a.LESS);break;case 3:a.depthFunc(a.LEQUAL);
break;case 4:a.depthFunc(a.EQUAL);break;case 5:a.depthFunc(a.GEQUAL);break;case 6:a.depthFunc(a.GREATER);break;case 7:a.depthFunc(a.NOTEQUAL);break;default:a.depthFunc(a.LEQUAL)}else a.depthFunc(a.LEQUAL);d=b}},setLocked:function(a){b=a},setClear:function(b){g!==b&&(a.clearDepth(b),g=b)},reset:function(){b=!1;g=d=c=null}}},r=new function(){var b=!1,c=null,d=null,g=null,h=null,l=null,k=null,n=null,q=null;return{setTest:function(b){b?e(a.STENCIL_TEST):f(a.STENCIL_TEST)},setMask:function(d){c===d||b||
(a.stencilMask(d),c=d)},setFunc:function(b,c,e){if(d!==b||g!==c||h!==e)a.stencilFunc(b,c,e),d=b,g=c,h=e},setOp:function(b,c,d){if(l!==b||k!==c||n!==d)a.stencilOp(b,c,d),l=b,k=c,n=d},setLocked:function(a){b=a},setClear:function(b){q!==b&&(a.clearStencil(b),q=b)},reset:function(){b=!1;q=n=k=l=h=g=d=c=null}}},m=a.getParameter(a.MAX_VERTEX_ATTRIBS),p=new Uint8Array(m),w=new Uint8Array(m),x=new Uint8Array(m),z={},I=null,B=null,J=null,ta=null,y=null,C=null,ha=null,A=null,E=null,L=!1,D=null,H=null,M=null,
V=null,K=null,N=a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS),m=parseFloat(/^WebGL\ ([0-9])/.exec(a.getParameter(a.VERSION))[1]),aa=1<=parseFloat(m),R=null,P={},Q=new da,G=new da,X={};X[a.TEXTURE_2D]=d(a.TEXTURE_2D,a.TEXTURE_2D,1);X[a.TEXTURE_CUBE_MAP]=d(a.TEXTURE_CUBE_MAP,a.TEXTURE_CUBE_MAP_POSITIVE_X,6);n.setClear(0,0,0,1);t.setClear(1);r.setClear(0);e(a.DEPTH_TEST);t.setFunc(3);h(!1);k(1);e(a.CULL_FACE);e(a.BLEND);g(1);return{buffers:{color:n,depth:t,stencil:r},initAttributes:function(){for(var a=
0,b=p.length;a<b;a++)p[a]=0},enableAttribute:function(c){p[c]=1;0===w[c]&&(a.enableVertexAttribArray(c),w[c]=1);0!==x[c]&&(b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c,0),x[c]=0)},enableAttributeAndDivisor:function(c,d){p[c]=1;0===w[c]&&(a.enableVertexAttribArray(c),w[c]=1);x[c]!==d&&(b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c,d),x[c]=d)},disableUnusedAttributes:function(){for(var b=0,c=w.length;b!==c;++b)w[b]!==p[b]&&(a.disableVertexAttribArray(b),w[b]=0)},enable:e,
disable:f,getCompressedTextureFormats:function(){if(null===I&&(I=[],b.get("WEBGL_compressed_texture_pvrtc")||b.get("WEBGL_compressed_texture_s3tc")||b.get("WEBGL_compressed_texture_etc1")))for(var c=a.getParameter(a.COMPRESSED_TEXTURE_FORMATS),d=0;d<c.length;d++)I.push(c[d]);return I},useProgram:function(b){return B!==b?(a.useProgram(b),B=b,!0):!1},setBlending:g,setMaterial:function(b){2===b.side?f(a.CULL_FACE):e(a.CULL_FACE);h(1===b.side);!0===b.transparent?g(b.blending,b.blendEquation,b.blendSrc,
b.blendDst,b.blendEquationAlpha,b.blendSrcAlpha,b.blendDstAlpha,b.premultipliedAlpha):g(0);t.setFunc(b.depthFunc);t.setTest(b.depthTest);t.setMask(b.depthWrite);n.setMask(b.colorWrite);l(b.polygonOffset,b.polygonOffsetFactor,b.polygonOffsetUnits)},setFlipSided:h,setCullFace:k,setLineWidth:function(b){b!==M&&(aa&&a.lineWidth(b),M=b)},setPolygonOffset:l,setScissorTest:function(b){b?e(a.SCISSOR_TEST):f(a.SCISSOR_TEST)},activeTexture:q,bindTexture:function(b,c){null===R&&q();var d=P[R];void 0===d&&(d=
{type:void 0,texture:void 0},P[R]=d);if(d.type!==b||d.texture!==c)a.bindTexture(b,c||X[b]),d.type=b,d.texture=c},compressedTexImage2D:function(){try{a.compressedTexImage2D.apply(a,arguments)}catch(fa){console.error("THREE.WebGLState:",fa)}},texImage2D:function(){try{a.texImage2D.apply(a,arguments)}catch(fa){console.error("THREE.WebGLState:",fa)}},scissor:function(b){!1===Q.equals(b)&&(a.scissor(b.x,b.y,b.z,b.w),Q.copy(b))},viewport:function(b){!1===G.equals(b)&&(a.viewport(b.x,b.y,b.z,b.w),G.copy(b))},
reset:function(){for(var b=0;b<w.length;b++)1===w[b]&&(a.disableVertexAttribArray(b),w[b]=0);z={};R=I=null;P={};H=D=J=B=null;n.reset();t.reset();r.reset()}}}function ng(a,b,c){function d(b){if("highp"===b){if(0<a.getShaderPrecisionFormat(a.VERTEX_SHADER,a.HIGH_FLOAT).precision&&0<a.getShaderPrecisionFormat(a.FRAGMENT_SHADER,a.HIGH_FLOAT).precision)return"highp";b="mediump"}return"mediump"===b&&0<a.getShaderPrecisionFormat(a.VERTEX_SHADER,a.MEDIUM_FLOAT).precision&&0<a.getShaderPrecisionFormat(a.FRAGMENT_SHADER,
a.MEDIUM_FLOAT).precision?"mediump":"lowp"}var e,f=void 0!==c.precision?c.precision:"highp",g=d(f);g!==f&&(console.warn("THREE.WebGLRenderer:",f,"not supported, using",g,"instead."),f=g);c=!0===c.logarithmicDepthBuffer;var g=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),h=a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS),k=a.getParameter(a.MAX_TEXTURE_SIZE),l=a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE),q=a.getParameter(a.MAX_VERTEX_ATTRIBS),n=a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS),t=a.getParameter(a.MAX_VARYING_VECTORS),
r=a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS),m=0<h,p=!!b.get("OES_texture_float");return{getMaxAnisotropy:function(){if(void 0!==e)return e;var c=b.get("EXT_texture_filter_anisotropic");return e=null!==c?a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0},getMaxPrecision:d,precision:f,logarithmicDepthBuffer:c,maxTextures:g,maxVertexTextures:h,maxTextureSize:k,maxCubemapSize:l,maxAttributes:q,maxVertexUniforms:n,maxVaryings:t,maxFragmentUniforms:r,vertexTextures:m,floatFragmentTextures:p,floatVertexTextures:m&&
p}}function U(a,b,c,d){La.call(this);this.type="PerspectiveCamera";this.fov=void 0!==a?a:50;this.zoom=1;this.near=void 0!==c?c:.1;this.far=void 0!==d?d:2E3;this.focus=10;this.aspect=void 0!==b?b:1;this.view=null;this.filmGauge=35;this.filmOffset=0;this.updateProjectionMatrix()}function nd(a){U.call(this);this.cameras=a||[]}function og(a){function b(){if(null!==d&&d.isPresenting){var b=d.getEyeParameters("left"),e=b.renderWidth,b=b.renderHeight;t=a.getPixelRatio();n=a.getSize();a.setDrawingBufferSize(2*
e,b,1)}else c.enabled&&a.setDrawingBufferSize(n.width,n.height,t)}var c=this,d=null,e=null;"undefined"!==typeof window&&"VRFrameData"in window&&(e=new window.VRFrameData);var f=new K,g=new K,h=new K,k=new U;k.bounds=new da(0,0,.5,1);k.layers.enable(1);var l=new U;l.bounds=new da(.5,0,.5,1);l.layers.enable(2);var q=new nd([k,l]);q.layers.enable(1);q.layers.enable(2);var n,t;"undefined"!==typeof window&&window.addEventListener("vrdisplaypresentchange",b,!1);this.standing=this.enabled=!1;this.getDevice=
function(){return d};this.setDevice=function(a){void 0!==a&&(d=a)};this.getCamera=function(a){if(null===d)return a;d.depthNear=a.near;d.depthFar=a.far;d.getFrameData(e);var b=e.pose;null!==b.position?a.position.fromArray(b.position):a.position.set(0,0,0);null!==b.orientation&&a.quaternion.fromArray(b.orientation);a.updateMatrixWorld();b=d.stageParameters;this.standing&&b&&(g.fromArray(b.sittingToStandingTransform),h.getInverse(g),a.matrixWorld.multiply(g),a.matrixWorldInverse.multiply(h));if(!1===
d.isPresenting)return a;k.near=a.near;l.near=a.near;k.far=a.far;l.far=a.far;q.matrixWorld.copy(a.matrixWorld);q.matrixWorldInverse.copy(a.matrixWorldInverse);k.matrixWorldInverse.fromArray(e.leftViewMatrix);l.matrixWorldInverse.fromArray(e.rightViewMatrix);this.standing&&b&&(k.matrixWorldInverse.multiply(h),l.matrixWorldInverse.multiply(h));a=a.parent;null!==a&&(f.getInverse(a.matrixWorld),k.matrixWorldInverse.multiply(f),l.matrixWorldInverse.multiply(f));k.matrixWorld.getInverse(k.matrixWorldInverse);
l.matrixWorld.getInverse(l.matrixWorldInverse);k.projectionMatrix.fromArray(e.leftProjectionMatrix);l.projectionMatrix.fromArray(e.rightProjectionMatrix);q.projectionMatrix.copy(k.projectionMatrix);a=d.getLayers();a.length&&(a=a[0],null!==a.leftBounds&&4===a.leftBounds.length&&k.bounds.fromArray(a.leftBounds),null!==a.rightBounds&&4===a.rightBounds.length&&l.bounds.fromArray(a.rightBounds));return q};this.getStandingMatrix=function(){return g};this.submitFrame=function(){d&&d.isPresenting&&d.submitFrame()};
this.dispose=function(){"undefined"!==typeof window&&window.removeEventListener("vrdisplaypresentchange",b)}}function pg(a){var b={};return{get:function(c){if(void 0!==b[c])return b[c];switch(c){case "WEBGL_depth_texture":var d=a.getExtension("WEBGL_depth_texture")||a.getExtension("MOZ_WEBGL_depth_texture")||a.getExtension("WEBKIT_WEBGL_depth_texture");break;case "EXT_texture_filter_anisotropic":d=a.getExtension("EXT_texture_filter_anisotropic")||a.getExtension("MOZ_EXT_texture_filter_anisotropic")||
a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case "WEBGL_compressed_texture_s3tc":d=a.getExtension("WEBGL_compressed_texture_s3tc")||a.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case "WEBGL_compressed_texture_pvrtc":d=a.getExtension("WEBGL_compressed_texture_pvrtc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;case "WEBGL_compressed_texture_etc1":d=a.getExtension("WEBGL_compressed_texture_etc1");
break;default:d=a.getExtension(c)}null===d&&console.warn("THREE.WebGLRenderer: "+c+" extension not supported.");return b[c]=d}}}function qg(){function a(){l.value!==d&&(l.value=d,l.needsUpdate=0<e);c.numPlanes=e;c.numIntersection=0}function b(a,b,d,e){var f=null!==a?a.length:0,g=null;if(0!==f){g=l.value;if(!0!==e||null===g){e=d+4*f;b=b.matrixWorldInverse;k.getNormalMatrix(b);if(null===g||g.length<e)g=new Float32Array(e);for(e=0;e!==f;++e,d+=4)h.copy(a[e]).applyMatrix4(b,k),h.normal.toArray(g,d),g[d+
3]=h.constant}l.value=g;l.needsUpdate=!0}c.numPlanes=f;return g}var c=this,d=null,e=0,f=!1,g=!1,h=new Aa,k=new ra,l={value:null,needsUpdate:!1};this.uniform=l;this.numIntersection=this.numPlanes=0;this.init=function(a,c,g){var h=0!==a.length||c||0!==e||f;f=c;d=b(a,g,0);e=a.length;return h};this.beginShadows=function(){g=!0;b(null)};this.endShadows=function(){g=!1;a()};this.setState=function(c,h,k,r,m,p){if(!f||null===c||0===c.length||g&&!k)g?b(null):a();else{k=g?0:e;var n=4*k,q=m.clippingState||null;
l.value=q;q=b(c,r,n,p);for(c=0;c!==n;++c)q[c]=d[c];m.clippingState=q;this.numIntersection=h?this.numPlanes:0;this.numPlanes+=k}}}function Pe(a,b){return{convert:function(c){if(1E3===c)return a.REPEAT;if(1001===c)return a.CLAMP_TO_EDGE;if(1002===c)return a.MIRRORED_REPEAT;if(1003===c)return a.NEAREST;if(1004===c)return a.NEAREST_MIPMAP_NEAREST;if(1005===c)return a.NEAREST_MIPMAP_LINEAR;if(1006===c)return a.LINEAR;if(1007===c)return a.LINEAR_MIPMAP_NEAREST;if(1008===c)return a.LINEAR_MIPMAP_LINEAR;
if(1009===c)return a.UNSIGNED_BYTE;if(1017===c)return a.UNSIGNED_SHORT_4_4_4_4;if(1018===c)return a.UNSIGNED_SHORT_5_5_5_1;if(1019===c)return a.UNSIGNED_SHORT_5_6_5;if(1010===c)return a.BYTE;if(1011===c)return a.SHORT;if(1012===c)return a.UNSIGNED_SHORT;if(1013===c)return a.INT;if(1014===c)return a.UNSIGNED_INT;if(1015===c)return a.FLOAT;if(1016===c){var d=b.get("OES_texture_half_float");if(null!==d)return d.HALF_FLOAT_OES}if(1021===c)return a.ALPHA;if(1022===c)return a.RGB;if(1023===c)return a.RGBA;
if(1024===c)return a.LUMINANCE;if(1025===c)return a.LUMINANCE_ALPHA;if(1026===c)return a.DEPTH_COMPONENT;if(1027===c)return a.DEPTH_STENCIL;if(100===c)return a.FUNC_ADD;if(101===c)return a.FUNC_SUBTRACT;if(102===c)return a.FUNC_REVERSE_SUBTRACT;if(200===c)return a.ZERO;if(201===c)return a.ONE;if(202===c)return a.SRC_COLOR;if(203===c)return a.ONE_MINUS_SRC_COLOR;if(204===c)return a.SRC_ALPHA;if(205===c)return a.ONE_MINUS_SRC_ALPHA;if(206===c)return a.DST_ALPHA;if(207===c)return a.ONE_MINUS_DST_ALPHA;
if(208===c)return a.DST_COLOR;if(209===c)return a.ONE_MINUS_DST_COLOR;if(210===c)return a.SRC_ALPHA_SATURATE;if(2001===c||2002===c||2003===c||2004===c)if(d=b.get("WEBGL_compressed_texture_s3tc"),null!==d){if(2001===c)return d.COMPRESSED_RGB_S3TC_DXT1_EXT;if(2002===c)return d.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(2003===c)return d.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(2004===c)return d.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(2100===c||2101===c||2102===c||2103===c)if(d=b.get("WEBGL_compressed_texture_pvrtc"),null!==
d){if(2100===c)return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(2101===c)return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(2102===c)return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(2103===c)return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(2151===c&&(d=b.get("WEBGL_compressed_texture_etc1"),null!==d))return d.COMPRESSED_RGB_ETC1_WEBGL;if(103===c||104===c)if(d=b.get("EXT_blend_minmax"),null!==d){if(103===c)return d.MIN_EXT;if(104===c)return d.MAX_EXT}return 1020===c&&(d=b.get("WEBGL_depth_texture"),null!==d)?d.UNSIGNED_INT_24_8_WEBGL:
0}}}function Wd(a){function b(){ia=new pg(F);ia.get("WEBGL_depth_texture");ia.get("OES_texture_float");ia.get("OES_texture_float_linear");ia.get("OES_texture_half_float");ia.get("OES_texture_half_float_linear");ia.get("OES_standard_derivatives");ia.get("OES_element_index_uint");ia.get("ANGLE_instanced_arrays");oa=new Pe(F,ia);Z=new ng(F,ia,a);ba=new mg(F,ia,oa);ba.scissor(S.copy(ea).multiplyScalar(O));ba.viewport(Q.copy(ca).multiplyScalar(O));U=new lg;T=new kg(F,ia,ba,U,Z,oa,Vd);na=new Mf(F);pa=new Zf(F,
na,Vd);ra=new bg(pa,Ra);va=new Wf(F);ma=new jg(L,ia,Z);sa=new ag;qa=new Uf;ja=new Qf(L,ba,pa,J);wa=new Yf(F,ia,Ra);xa=new Xf(F,ia,Ra);ya=new Jf(L,F,ba,T,Z);Aa=new Kf(L,F,ba,T,Z);L.info.programs=ma.programs;L.context=F;L.capabilities=Z;L.extensions=ia;L.properties=U;L.renderLists=qa;L.state=ba}function c(a){a.preventDefault();console.log("THREE.WebGLRenderer: Context Lost.");Y=!0}function d(){console.log("THREE.WebGLRenderer: Context Restored.");Y=!1;b()}function e(a){a=a.target;a.removeEventListener("dispose",
e);f(a);U.remove(a)}function f(a){var b=U.get(a).program;a.program=void 0;void 0!==b&&ma.releaseProgram(b)}function g(a,b,c){a.render(function(a){L.renderBufferImmediate(a,b,c)})}function h(a){null!==Ba&&Ba(a);(a=ka.getDevice())&&a.isPresenting?a.requestAnimationFrame(h):window.requestAnimationFrame(h)}function k(a,b,c){if(!1!==a.visible){if(a.layers.test(b.layers))if(a.isLight)y.push(a),a.castShadow&&C.push(a);else if(a.isSprite)a.frustumCulled&&!Td.intersectsSprite(a)||D.push(a);else if(a.isLensFlare)Va.push(a);
else if(a.isImmediateRenderObject)c&&Nb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(md),A.push(a,null,a.material,Nb.z,null);else if(a.isMesh||a.isLine||a.isPoints)if(a.isSkinnedMesh&&a.skeleton.update(),!a.frustumCulled||Td.intersectsObject(a)){c&&Nb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(md);var d=ra.update(a),e=a.material;if(Array.isArray(e))for(var f=d.groups,g=0,h=f.length;g<h;g++){var l=f[g],n=e[l.materialIndex];n&&n.visible&&A.push(a,d,n,Nb.z,l)}else e.visible&&A.push(a,d,e,
Nb.z,null)}a=a.children;g=0;for(h=a.length;g<h;g++)k(a[g],b,c)}}function l(a,b,c,d){for(var e=0,f=a.length;e<f;e++){var g=a[e],h=g.object,l=g.geometry,k=void 0===d?g.material:d,g=g.group;if(c.isArrayCamera){aa=c;for(var n=c.cameras,t=0,r=n.length;t<r;t++){var m=n[t];if(h.layers.test(m.layers)){var u=m.bounds;ba.viewport(Q.set(u.x*X,u.y*fa,u.z*X,u.w*fa).multiplyScalar(O));q(h,b,m,l,k,g)}}}else aa=null,q(h,b,c,l,k,g)}}function q(a,b,c,d,e,f){a.onBeforeRender(L,b,c,d,e,f);a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse,
a.matrixWorld);a.normalMatrix.getNormalMatrix(a.modelViewMatrix);if(a.isImmediateRenderObject){ba.setMaterial(e);var h=t(c,b.fog,e,a);N="";g(a,h,e)}else L.renderBufferDirect(c,b.fog,d,e,a,f);a.onAfterRender(L,b,c,d,e,f)}function n(a,b,c){var d=U.get(a);c=ma.getParameters(a,sa.state,C,b,Fa.numPlanes,Fa.numIntersection,c);var g=ma.getProgramCode(a,c),h=d.program,l=!0;if(void 0===h)a.addEventListener("dispose",e);else if(h.code!==g)f(a);else{if(void 0!==c.shaderID)return;l=!1}l&&(c.shaderID?(h=mb[c.shaderID],
d.shader={name:a.type,uniforms:Ea.clone(h.uniforms),vertexShader:h.vertexShader,fragmentShader:h.fragmentShader}):d.shader={name:a.type,uniforms:a.uniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader},a.onBeforeCompile(d.shader),h=ma.acquireProgram(a,d.shader,c,g),d.program=h,a.program=h);c=h.getAttributes();if(a.morphTargets)for(g=a.numSupportedMorphTargets=0;g<L.maxMorphTargets;g++)0<=c["morphTarget"+g]&&a.numSupportedMorphTargets++;if(a.morphNormals)for(g=a.numSupportedMorphNormals=
0;g<L.maxMorphNormals;g++)0<=c["morphNormal"+g]&&a.numSupportedMorphNormals++;c=d.shader.uniforms;if(!a.isShaderMaterial&&!a.isRawShaderMaterial||!0===a.clipping)d.numClippingPlanes=Fa.numPlanes,d.numIntersection=Fa.numIntersection,c.clippingPlanes=Fa.uniform;d.fog=b;d.lightsHash=sa.state.hash;a.lights&&(c.ambientLightColor.value=sa.state.ambient,c.directionalLights.value=sa.state.directional,c.spotLights.value=sa.state.spot,c.rectAreaLights.value=sa.state.rectArea,c.pointLights.value=sa.state.point,
c.hemisphereLights.value=sa.state.hemi,c.directionalShadowMap.value=sa.state.directionalShadowMap,c.directionalShadowMatrix.value=sa.state.directionalShadowMatrix,c.spotShadowMap.value=sa.state.spotShadowMap,c.spotShadowMatrix.value=sa.state.spotShadowMatrix,c.pointShadowMap.value=sa.state.pointShadowMap,c.pointShadowMatrix.value=sa.state.pointShadowMatrix);a=d.program.getUniforms();a=gb.seqWithValue(a.seq,c);d.uniformsList=a}function t(a,b,c,d){G=0;var e=U.get(c);ga&&(Ud||a!==P)&&Fa.setState(c.clippingPlanes,
c.clipIntersection,c.clipShadows,a,e,a===P&&c.id===V);!1===c.needsUpdate&&(void 0===e.program?c.needsUpdate=!0:c.fog&&e.fog!==b?c.needsUpdate=!0:c.lights&&e.lightsHash!==sa.state.hash?c.needsUpdate=!0:void 0===e.numClippingPlanes||e.numClippingPlanes===Fa.numPlanes&&e.numIntersection===Fa.numIntersection||(c.needsUpdate=!0));c.needsUpdate&&(n(c,b,d),c.needsUpdate=!1);var f=!1,g=!1,h=!1,l=e.program,k=l.getUniforms(),q=e.shader.uniforms;ba.useProgram(l.program)&&(h=g=f=!0);c.id!==V&&(V=c.id,g=!0);if(f||
a!==P){k.setValue(F,"projectionMatrix",a.projectionMatrix);Z.logarithmicDepthBuffer&&k.setValue(F,"logDepthBufFC",2/(Math.log(a.far+1)/Math.LN2));P!==(aa||a)&&(P=aa||a,h=g=!0);if(c.isShaderMaterial||c.isMeshPhongMaterial||c.isMeshStandardMaterial||c.envMap)f=k.map.cameraPosition,void 0!==f&&f.setValue(F,Nb.setFromMatrixPosition(a.matrixWorld));(c.isMeshPhongMaterial||c.isMeshLambertMaterial||c.isMeshBasicMaterial||c.isMeshStandardMaterial||c.isShaderMaterial||c.skinning)&&k.setValue(F,"viewMatrix",
a.matrixWorldInverse)}if(c.skinning&&(k.setOptional(F,d,"bindMatrix"),k.setOptional(F,d,"bindMatrixInverse"),a=d.skeleton))if(f=a.bones,Z.floatVertexTextures){if(void 0===a.boneTexture){var f=Math.sqrt(4*f.length),f=R.ceilPowerOfTwo(f),f=Math.max(f,4),t=new Float32Array(f*f*4);t.set(a.boneMatrices);var u=new fb(t,f,f,1023,1015);a.boneMatrices=t;a.boneTexture=u;a.boneTextureSize=f}k.setValue(F,"boneTexture",a.boneTexture);k.setValue(F,"boneTextureSize",a.boneTextureSize)}else k.setOptional(F,a,"boneMatrices");
g&&(k.setValue(F,"toneMappingExposure",L.toneMappingExposure),k.setValue(F,"toneMappingWhitePoint",L.toneMappingWhitePoint),c.lights&&(g=h,q.ambientLightColor.needsUpdate=g,q.directionalLights.needsUpdate=g,q.pointLights.needsUpdate=g,q.spotLights.needsUpdate=g,q.rectAreaLights.needsUpdate=g,q.hemisphereLights.needsUpdate=g),b&&c.fog&&(q.fogColor.value=b.color,b.isFog?(q.fogNear.value=b.near,q.fogFar.value=b.far):b.isFogExp2&&(q.fogDensity.value=b.density)),c.isMeshBasicMaterial?r(q,c):c.isMeshLambertMaterial?
(r(q,c),c.emissiveMap&&(q.emissiveMap.value=c.emissiveMap)):c.isMeshPhongMaterial?(r(q,c),c.isMeshToonMaterial?(m(q,c),c.gradientMap&&(q.gradientMap.value=c.gradientMap)):m(q,c)):c.isMeshStandardMaterial?(r(q,c),c.isMeshPhysicalMaterial&&(q.clearCoat.value=c.clearCoat,q.clearCoatRoughness.value=c.clearCoatRoughness),q.roughness.value=c.roughness,q.metalness.value=c.metalness,c.roughnessMap&&(q.roughnessMap.value=c.roughnessMap),c.metalnessMap&&(q.metalnessMap.value=c.metalnessMap),c.emissiveMap&&
(q.emissiveMap.value=c.emissiveMap),c.bumpMap&&(q.bumpMap.value=c.bumpMap,q.bumpScale.value=c.bumpScale),c.normalMap&&(q.normalMap.value=c.normalMap,q.normalScale.value.copy(c.normalScale)),c.displacementMap&&(q.displacementMap.value=c.displacementMap,q.displacementScale.value=c.displacementScale,q.displacementBias.value=c.displacementBias),c.envMap&&(q.envMapIntensity.value=c.envMapIntensity)):c.isMeshDepthMaterial?(r(q,c),c.displacementMap&&(q.displacementMap.value=c.displacementMap,q.displacementScale.value=
c.displacementScale,q.displacementBias.value=c.displacementBias)):c.isMeshDistanceMaterial?(r(q,c),c.displacementMap&&(q.displacementMap.value=c.displacementMap,q.displacementScale.value=c.displacementScale,q.displacementBias.value=c.displacementBias),q.referencePosition.value.copy(c.referencePosition),q.nearDistance.value=c.nearDistance,q.farDistance.value=c.farDistance):c.isMeshNormalMaterial?(r(q,c),c.bumpMap&&(q.bumpMap.value=c.bumpMap,q.bumpScale.value=c.bumpScale),c.normalMap&&(q.normalMap.value=
c.normalMap,q.normalScale.value.copy(c.normalScale)),c.displacementMap&&(q.displacementMap.value=c.displacementMap,q.displacementScale.value=c.displacementScale,q.displacementBias.value=c.displacementBias)):c.isLineBasicMaterial?(q.diffuse.value=c.color,q.opacity.value=c.opacity,c.isLineDashedMaterial&&(q.dashSize.value=c.dashSize,q.totalSize.value=c.dashSize+c.gapSize,q.scale.value=c.scale)):c.isPointsMaterial?(q.diffuse.value=c.color,q.opacity.value=c.opacity,q.size.value=c.size*O,q.scale.value=
.5*fa,q.map.value=c.map,null!==c.map&&(!0===c.map.matrixAutoUpdate&&(b=c.map.offset,g=c.map.repeat,h=c.map.center,c.map.matrix.setUvTransform(b.x,b.y,g.x,g.y,c.map.rotation,h.x,h.y)),q.uvTransform.value.copy(c.map.matrix))):c.isShadowMaterial&&(q.color.value=c.color,q.opacity.value=c.opacity),void 0!==q.ltcMat&&(q.ltcMat.value=E.LTC_MAT_TEXTURE),void 0!==q.ltcMag&&(q.ltcMag.value=E.LTC_MAG_TEXTURE),gb.upload(F,e.uniformsList,q,L));k.setValue(F,"modelViewMatrix",d.modelViewMatrix);k.setValue(F,"normalMatrix",
d.normalMatrix);k.setValue(F,"modelMatrix",d.matrixWorld);return l}function r(a,b){a.opacity.value=b.opacity;b.color&&(a.diffuse.value=b.color);b.emissive&&a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity);b.map&&(a.map.value=b.map);b.alphaMap&&(a.alphaMap.value=b.alphaMap);b.specularMap&&(a.specularMap.value=b.specularMap);b.envMap&&(a.envMap.value=b.envMap,a.flipEnvMap.value=b.envMap&&b.envMap.isCubeTexture?-1:1,a.reflectivity.value=b.reflectivity,a.refractionRatio.value=b.refractionRatio);
b.lightMap&&(a.lightMap.value=b.lightMap,a.lightMapIntensity.value=b.lightMapIntensity);b.aoMap&&(a.aoMap.value=b.aoMap,a.aoMapIntensity.value=b.aoMapIntensity);if(b.map)var c=b.map;else b.specularMap?c=b.specularMap:b.displacementMap?c=b.displacementMap:b.normalMap?c=b.normalMap:b.bumpMap?c=b.bumpMap:b.roughnessMap?c=b.roughnessMap:b.metalnessMap?c=b.metalnessMap:b.alphaMap?c=b.alphaMap:b.emissiveMap&&(c=b.emissiveMap);if(void 0!==c){c.isWebGLRenderTarget&&(c=c.texture);if(!0===c.matrixAutoUpdate){b=
c.offset;var d=c.repeat,e=c.center;c.matrix.setUvTransform(b.x,b.y,d.x,d.y,c.rotation,e.x,e.y)}a.uvTransform.value.copy(c.matrix)}}function m(a,b){a.specular.value=b.specular;a.shininess.value=Math.max(b.shininess,1E-4);b.emissiveMap&&(a.emissiveMap.value=b.emissiveMap);b.bumpMap&&(a.bumpMap.value=b.bumpMap,a.bumpScale.value=b.bumpScale);b.normalMap&&(a.normalMap.value=b.normalMap,a.normalScale.value.copy(b.normalScale));b.displacementMap&&(a.displacementMap.value=b.displacementMap,a.displacementScale.value=
b.displacementScale,a.displacementBias.value=b.displacementBias)}console.log("THREE.WebGLRenderer","88");a=a||{};var v=void 0!==a.canvas?a.canvas:document.createElementNS("http://www.w3.org/1999/xhtml","canvas"),w=void 0!==a.context?a.context:null,x=void 0!==a.alpha?a.alpha:!1,z=void 0!==a.depth?a.depth:!0,I=void 0!==a.stencil?a.stencil:!0,B=void 0!==a.antialias?a.antialias:!1,J=void 0!==a.premultipliedAlpha?a.premultipliedAlpha:!0,ta=void 0!==a.preserveDrawingBuffer?a.preserveDrawingBuffer:!1,y=
[],C=[],A=null,D=[],Va=[];this.domElement=v;this.context=null;this.sortObjects=this.autoClearStencil=this.autoClearDepth=this.autoClearColor=this.autoClear=!0;this.clippingPlanes=[];this.localClippingEnabled=!1;this.gammaFactor=2;this.physicallyCorrectLights=this.gammaOutput=this.gammaInput=!1;this.toneMappingWhitePoint=this.toneMappingExposure=this.toneMapping=1;this.maxMorphTargets=8;this.maxMorphNormals=4;var L=this,Y=!1,H=null,M=null,V=-1,N="",P=null,aa=null,Q=new da,S=new da,W=null,G=0,X=v.width,
fa=v.height,O=1,ca=new da(0,0,X,fa),ea=new da(0,0,X,fa),Oe=!1,Td=new ld,Fa=new qg,ga=!1,Ud=!1,md=new K,Nb=new p,Vd={geometries:0,textures:0},Ra={frame:0,calls:0,vertices:0,faces:0,points:0};this.info={render:Ra,memory:Vd,programs:null};try{x={alpha:x,depth:z,stencil:I,antialias:B,premultipliedAlpha:J,preserveDrawingBuffer:ta};var F=w||v.getContext("webgl",x)||v.getContext("experimental-webgl",x);if(null===F){if(null!==v.getContext("webgl"))throw"Error creating WebGL context with your selected attributes.";
throw"Error creating WebGL context.";}void 0===F.getShaderPrecisionFormat&&(F.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}});v.addEventListener("webglcontextlost",c,!1);v.addEventListener("webglcontextrestored",d,!1)}catch(rg){console.error("THREE.WebGLRenderer: "+rg)}var ia,Z,ba,U,T,na,pa,ra,sa,ma,qa,ja,va,wa,xa,ya,Aa,oa;b();var ka=new og(L);this.vr=ka;var Ca=new Ie(L,ra,Z.maxTextureSize);this.shadowMap=Ca;this.getContext=function(){return F};this.getContextAttributes=
function(){return F.getContextAttributes()};this.forceContextLoss=function(){var a=ia.get("WEBGL_lose_context");a&&a.loseContext()};this.forceContextRestore=function(){var a=ia.get("WEBGL_lose_context");a&&a.restoreContext()};this.getPixelRatio=function(){return O};this.setPixelRatio=function(a){void 0!==a&&(O=a,this.setSize(X,fa,!1))};this.getSize=function(){return{width:X,height:fa}};this.setSize=function(a,b,c){var d=ka.getDevice();d&&d.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):
(X=a,fa=b,v.width=a*O,v.height=b*O,!1!==c&&(v.style.width=a+"px",v.style.height=b+"px"),this.setViewport(0,0,a,b))};this.getDrawingBufferSize=function(){return{width:X*O,height:fa*O}};this.setDrawingBufferSize=function(a,b,c){X=a;fa=b;O=c;v.width=a*c;v.height=b*c;this.setViewport(0,0,a,b)};this.setViewport=function(a,b,c,d){ca.set(a,fa-b-d,c,d);ba.viewport(Q.copy(ca).multiplyScalar(O))};this.setScissor=function(a,b,c,d){ea.set(a,fa-b-d,c,d);ba.scissor(S.copy(ea).multiplyScalar(O))};this.setScissorTest=
function(a){ba.setScissorTest(Oe=a)};this.getClearColor=function(){return ja.getClearColor()};this.setClearColor=function(){ja.setClearColor.apply(ja,arguments)};this.getClearAlpha=function(){return ja.getClearAlpha()};this.setClearAlpha=function(){ja.setClearAlpha.apply(ja,arguments)};this.clear=function(a,b,c){var d=0;if(void 0===a||a)d|=F.COLOR_BUFFER_BIT;if(void 0===b||b)d|=F.DEPTH_BUFFER_BIT;if(void 0===c||c)d|=F.STENCIL_BUFFER_BIT;F.clear(d)};this.clearColor=function(){this.clear(!0,!1,!1)};
this.clearDepth=function(){this.clear(!1,!0,!1)};this.clearStencil=function(){this.clear(!1,!1,!0)};this.clearTarget=function(a,b,c,d){this.setRenderTarget(a);this.clear(b,c,d)};this.dispose=function(){v.removeEventListener("webglcontextlost",c,!1);v.removeEventListener("webglcontextrestored",d,!1);qa.dispose();ka.dispose()};this.renderBufferImmediate=function(a,b,c){ba.initAttributes();var d=U.get(a);a.hasPositions&&!d.position&&(d.position=F.createBuffer());a.hasNormals&&!d.normal&&(d.normal=F.createBuffer());
a.hasUvs&&!d.uv&&(d.uv=F.createBuffer());a.hasColors&&!d.color&&(d.color=F.createBuffer());b=b.getAttributes();a.hasPositions&&(F.bindBuffer(F.ARRAY_BUFFER,d.position),F.bufferData(F.ARRAY_BUFFER,a.positionArray,F.DYNAMIC_DRAW),ba.enableAttribute(b.position),F.vertexAttribPointer(b.position,3,F.FLOAT,!1,0,0));if(a.hasNormals){F.bindBuffer(F.ARRAY_BUFFER,d.normal);if(!c.isMeshPhongMaterial&&!c.isMeshStandardMaterial&&!c.isMeshNormalMaterial&&!0===c.flatShading)for(var e=0,f=3*a.count;e<f;e+=9){var g=
a.normalArray,h=(g[e+0]+g[e+3]+g[e+6])/3,l=(g[e+1]+g[e+4]+g[e+7])/3,k=(g[e+2]+g[e+5]+g[e+8])/3;g[e+0]=h;g[e+1]=l;g[e+2]=k;g[e+3]=h;g[e+4]=l;g[e+5]=k;g[e+6]=h;g[e+7]=l;g[e+8]=k}F.bufferData(F.ARRAY_BUFFER,a.normalArray,F.DYNAMIC_DRAW);ba.enableAttribute(b.normal);F.vertexAttribPointer(b.normal,3,F.FLOAT,!1,0,0)}a.hasUvs&&c.map&&(F.bindBuffer(F.ARRAY_BUFFER,d.uv),F.bufferData(F.ARRAY_BUFFER,a.uvArray,F.DYNAMIC_DRAW),ba.enableAttribute(b.uv),F.vertexAttribPointer(b.uv,2,F.FLOAT,!1,0,0));a.hasColors&&
0!==c.vertexColors&&(F.bindBuffer(F.ARRAY_BUFFER,d.color),F.bufferData(F.ARRAY_BUFFER,a.colorArray,F.DYNAMIC_DRAW),ba.enableAttribute(b.color),F.vertexAttribPointer(b.color,3,F.FLOAT,!1,0,0));ba.disableUnusedAttributes();F.drawArrays(F.TRIANGLES,0,a.count);a.count=0};this.renderBufferDirect=function(a,b,c,d,e,f){ba.setMaterial(d);var g=t(a,b,d,e);a=c.id+"_"+g.id+"_"+(!0===d.wireframe);var h=!1;a!==N&&(N=a,h=!0);e.morphTargetInfluences&&(va.update(e,c,d,g),h=!0);var l=c.index,k=c.attributes.position;
b=1;!0===d.wireframe&&(l=pa.getWireframeAttribute(c),b=2);a=wa;if(null!==l){var n=na.get(l);a=xa;a.setIndex(n)}if(h){h=void 0;if(c&&c.isInstancedBufferGeometry&&null===ia.get("ANGLE_instanced_arrays"))console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");else{void 0===h&&(h=0);ba.initAttributes();var q=c.attributes,g=g.getAttributes(),r=d.defaultAttributeValues;for(J in g){var m=g[J];if(0<=m){var u=
q[J];if(void 0!==u){var p=u.normalized,v=u.itemSize,w=na.get(u);if(void 0!==w){var z=w.buffer,x=w.type,w=w.bytesPerElement;if(u.isInterleavedBufferAttribute){var B=u.data,I=B.stride,u=u.offset;B&&B.isInstancedInterleavedBuffer?(ba.enableAttributeAndDivisor(m,B.meshPerAttribute),void 0===c.maxInstancedCount&&(c.maxInstancedCount=B.meshPerAttribute*B.count)):ba.enableAttribute(m);F.bindBuffer(F.ARRAY_BUFFER,z);F.vertexAttribPointer(m,v,x,p,I*w,(h*I+u)*w)}else u.isInstancedBufferAttribute?(ba.enableAttributeAndDivisor(m,
u.meshPerAttribute),void 0===c.maxInstancedCount&&(c.maxInstancedCount=u.meshPerAttribute*u.count)):ba.enableAttribute(m),F.bindBuffer(F.ARRAY_BUFFER,z),F.vertexAttribPointer(m,v,x,p,0,h*v*w)}}else if(void 0!==r&&(p=r[J],void 0!==p))switch(p.length){case 2:F.vertexAttrib2fv(m,p);break;case 3:F.vertexAttrib3fv(m,p);break;case 4:F.vertexAttrib4fv(m,p);break;default:F.vertexAttrib1fv(m,p)}}}ba.disableUnusedAttributes()}null!==l&&F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,n.buffer)}n=0;null!==l?n=l.count:void 0!==
k&&(n=k.count);l=c.drawRange.start*b;k=null!==f?f.start*b:0;var J=Math.max(l,k);f=Math.max(0,Math.min(n,l+c.drawRange.count*b,k+(null!==f?f.count*b:Infinity))-1-J+1);if(0!==f){if(e.isMesh)if(!0===d.wireframe)ba.setLineWidth(d.wireframeLinewidth*(null===H?O:1)),a.setMode(F.LINES);else switch(e.drawMode){case 0:a.setMode(F.TRIANGLES);break;case 1:a.setMode(F.TRIANGLE_STRIP);break;case 2:a.setMode(F.TRIANGLE_FAN)}else e.isLine?(d=d.linewidth,void 0===d&&(d=1),ba.setLineWidth(d*(null===H?O:1)),e.isLineSegments?
a.setMode(F.LINES):e.isLineLoop?a.setMode(F.LINE_LOOP):a.setMode(F.LINE_STRIP)):e.isPoints&&a.setMode(F.POINTS);c&&c.isInstancedBufferGeometry?0<c.maxInstancedCount&&a.renderInstances(c,J,f):a.render(J,f)}};this.compile=function(a,b){y.length=0;C.length=0;a.traverse(function(a){a.isLight&&(y.push(a),a.castShadow&&C.push(a))});sa.setup(y,C,b);a.traverse(function(b){if(b.material)if(Array.isArray(b.material))for(var c=0;c<b.material.length;c++)n(b.material[c],a.fog,b);else n(b.material,a.fog,b)})};
var Da=!1,Ba=null;this.animate=function(a){Ba=a;Da||((a=ka.getDevice())&&a.isPresenting?a.requestAnimationFrame(h):window.requestAnimationFrame(h),Da=!0)};this.render=function(a,b,c,d){if(!b||!b.isCamera)console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");else if(!Y){N="";V=-1;P=null;!0===a.autoUpdate&&a.updateMatrixWorld();null===b.parent&&b.updateMatrixWorld();ka.enabled&&(b=ka.getCamera(b));md.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse);Td.setFromMatrix(md);
y.length=0;C.length=0;D.length=0;Va.length=0;Ud=this.localClippingEnabled;ga=Fa.init(this.clippingPlanes,Ud,b);A=qa.get(a,b);A.init();k(a,b,L.sortObjects);!0===L.sortObjects&&A.sort();ga&&Fa.beginShadows();Ca.render(C,a,b);sa.setup(y,C,b);ga&&Fa.endShadows();Ra.frame++;Ra.calls=0;Ra.vertices=0;Ra.faces=0;Ra.points=0;void 0===c&&(c=null);this.setRenderTarget(c);ja.render(A,a,b,d);d=A.opaque;var e=A.transparent;if(a.overrideMaterial){var f=a.overrideMaterial;d.length&&l(d,a,b,f);e.length&&l(e,a,b,f)}else d.length&&
l(d,a,b),e.length&&l(e,a,b);Aa.render(D,a,b);ya.render(Va,a,b,Q);c&&T.updateRenderTargetMipmap(c);ba.buffers.depth.setTest(!0);ba.buffers.depth.setMask(!0);ba.buffers.color.setMask(!0);ba.setPolygonOffset(!1);ka.enabled&&ka.submitFrame()}};this.setFaceCulling=function(a,b){ba.setCullFace(a);ba.setFlipSided(0===b)};this.allocTextureUnit=function(){var a=G;a>=Z.maxTextures&&console.warn("THREE.WebGLRenderer: Trying to use "+a+" texture units while this GPU supports only "+Z.maxTextures);G+=1;return a};
this.setTexture2D=function(){var a=!1;return function(b,c){b&&b.isWebGLRenderTarget&&(a||(console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),a=!0),b=b.texture);T.setTexture2D(b,c)}}();this.setTexture=function(){var a=!1;return function(b,c){a||(console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),a=!0);T.setTexture2D(b,c)}}();this.setTextureCube=function(){var a=!1;return function(b,c){b&&
b.isWebGLRenderTargetCube&&(a||(console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."),a=!0),b=b.texture);b&&b.isCubeTexture||Array.isArray(b.image)&&6===b.image.length?T.setTextureCube(b,c):T.setTextureCubeDynamic(b,c)}}();this.getRenderTarget=function(){return H};this.setRenderTarget=function(a){(H=a)&&void 0===U.get(a).__webglFramebuffer&&T.setupRenderTarget(a);var b=null,c=!1;a?(b=U.get(a).__webglFramebuffer,a.isWebGLRenderTargetCube&&
(b=b[a.activeCubeFace],c=!0),Q.copy(a.viewport),S.copy(a.scissor),W=a.scissorTest):(Q.copy(ca).multiplyScalar(O),S.copy(ea).multiplyScalar(O),W=Oe);M!==b&&(F.bindFramebuffer(F.FRAMEBUFFER,b),M=b);ba.viewport(Q);ba.scissor(S);ba.setScissorTest(W);c&&(c=U.get(a.texture),F.framebufferTexture2D(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_CUBE_MAP_POSITIVE_X+a.activeCubeFace,c.__webglTexture,a.activeMipMapLevel))};this.readRenderTargetPixels=function(a,b,c,d,e,f){if(a&&a.isWebGLRenderTarget){var g=U.get(a).__webglFramebuffer;
if(g){var h=!1;g!==M&&(F.bindFramebuffer(F.FRAMEBUFFER,g),h=!0);try{var l=a.texture,k=l.format,n=l.type;1023!==k&&oa.convert(k)!==F.getParameter(F.IMPLEMENTATION_COLOR_READ_FORMAT)?console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."):1009===n||oa.convert(n)===F.getParameter(F.IMPLEMENTATION_COLOR_READ_TYPE)||1015===n&&(ia.get("OES_texture_float")||ia.get("WEBGL_color_buffer_float"))||1016===n&&ia.get("EXT_color_buffer_half_float")?
F.checkFramebufferStatus(F.FRAMEBUFFER)===F.FRAMEBUFFER_COMPLETE?0<=b&&b<=a.width-d&&0<=c&&c<=a.height-e&&F.readPixels(b,c,d,e,oa.convert(k),oa.convert(n),f):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."):console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")}finally{h&&F.bindFramebuffer(F.FRAMEBUFFER,M)}}}else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")}}
function Ob(a,b){this.name="";this.color=new H(a);this.density=void 0!==b?b:2.5E-4}function Pb(a,b,c){this.name="";this.color=new H(a);this.near=void 0!==b?b:1;this.far=void 0!==c?c:1E3}function od(){A.call(this);this.type="Scene";this.overrideMaterial=this.fog=this.background=null;this.autoUpdate=!0}function Xd(a,b,c,d,e){A.call(this);this.lensFlares=[];this.positionScreen=new p;this.customUpdateCallback=void 0;void 0!==a&&this.add(a,b,c,d,e)}function Za(a){Q.call(this);this.type="SpriteMaterial";
this.color=new H(16777215);this.map=null;this.rotation=0;this.lights=this.fog=!1;this.setValues(a)}function Cc(a){A.call(this);this.type="Sprite";this.material=void 0!==a?a:new Za}function Dc(){A.call(this);this.type="LOD";Object.defineProperties(this,{levels:{enumerable:!0,value:[]}})}function Ec(a,b){a=a||[];this.bones=a.slice(0);this.boneMatrices=new Float32Array(16*this.bones.length);if(void 0===b)this.calculateInverses();else if(this.bones.length===b.length)this.boneInverses=b.slice(0);else for(console.warn("THREE.Skeleton boneInverses is the wrong length."),
this.boneInverses=[],a=0,b=this.bones.length;a<b;a++)this.boneInverses.push(new K)}function pd(){A.call(this);this.type="Bone"}function qd(a,b){pa.call(this,a,b);this.type="SkinnedMesh";this.bindMode="attached";this.bindMatrix=new K;this.bindMatrixInverse=new K;a=this.initBones();a=new Ec(a);this.bind(a,this.matrixWorld);this.normalizeSkinWeights()}function O(a){Q.call(this);this.type="LineBasicMaterial";this.color=new H(16777215);this.linewidth=1;this.linejoin=this.linecap="round";this.lights=!1;
this.setValues(a)}function ma(a,b,c){if(1===c)return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."),new ca(a,b);A.call(this);this.type="Line";this.geometry=void 0!==a?a:new D;this.material=void 0!==b?b:new O({color:16777215*Math.random()})}function ca(a,b){ma.call(this,a,b);this.type="LineSegments"}function rd(a,b){ma.call(this,a,b);this.type="LineLoop"}function Ba(a){Q.call(this);this.type="PointsMaterial";this.color=new H(16777215);
this.map=null;this.size=1;this.sizeAttenuation=!0;this.lights=!1;this.setValues(a)}function Qb(a,b){A.call(this);this.type="Points";this.geometry=void 0!==a?a:new D;this.material=void 0!==b?b:new Ba({color:16777215*Math.random()})}function Fc(){A.call(this);this.type="Group"}function sd(a,b,c,d,e,f,g,h,k){function l(){var a=q.image;a.readyState>=a.HAVE_CURRENT_DATA&&(q.needsUpdate=!0);requestAnimationFrame(l)}ea.call(this,a,b,c,d,e,f,g,h,k);this.generateMipmaps=!1;var q=this;requestAnimationFrame(l)}
function Rb(a,b,c,d,e,f,g,h,k,l,q,n){ea.call(this,null,f,g,h,k,l,d,e,q,n);this.image={width:b,height:c};this.mipmaps=a;this.generateMipmaps=this.flipY=!1}function Gc(a,b,c,d,e,f,g,h,k,l){l=void 0!==l?l:1026;if(1026!==l&&1027!==l)throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===c&&1026===l&&(c=1012);void 0===c&&1027===l&&(c=1020);ea.call(this,null,d,e,f,g,h,l,c,k);this.image={width:a,height:b};this.magFilter=void 0!==g?g:1003;this.minFilter=void 0!==
h?h:1003;this.generateMipmaps=this.flipY=!1}function Sb(a){D.call(this);this.type="WireframeGeometry";var b=[],c,d,e,f=[0,0],g={},h=["a","b","c"];if(a&&a.isGeometry){var k=a.faces;var l=0;for(d=k.length;l<d;l++){var q=k[l];for(c=0;3>c;c++){var n=q[h[c]];var t=q[h[(c+1)%3]];f[0]=Math.min(n,t);f[1]=Math.max(n,t);n=f[0]+","+f[1];void 0===g[n]&&(g[n]={index1:f[0],index2:f[1]})}}for(n in g)l=g[n],h=a.vertices[l.index1],b.push(h.x,h.y,h.z),h=a.vertices[l.index2],b.push(h.x,h.y,h.z)}else if(a&&a.isBufferGeometry){var h=
new p;if(null!==a.index){k=a.attributes.position;q=a.index;var r=a.groups;0===r.length&&(r=[{start:0,count:q.count,materialIndex:0}]);a=0;for(e=r.length;a<e;++a)for(l=r[a],c=l.start,d=l.count,l=c,d=c+d;l<d;l+=3)for(c=0;3>c;c++)n=q.getX(l+c),t=q.getX(l+(c+1)%3),f[0]=Math.min(n,t),f[1]=Math.max(n,t),n=f[0]+","+f[1],void 0===g[n]&&(g[n]={index1:f[0],index2:f[1]});for(n in g)l=g[n],h.fromBufferAttribute(k,l.index1),b.push(h.x,h.y,h.z),h.fromBufferAttribute(k,l.index2),b.push(h.x,h.y,h.z)}else for(k=a.attributes.position,
l=0,d=k.count/3;l<d;l++)for(c=0;3>c;c++)g=3*l+c,h.fromBufferAttribute(k,g),b.push(h.x,h.y,h.z),g=3*l+(c+1)%3,h.fromBufferAttribute(k,g),b.push(h.x,h.y,h.z)}this.addAttribute("position",new y(b,3))}function Hc(a,b,c){N.call(this);this.type="ParametricGeometry";this.parameters={func:a,slices:b,stacks:c};this.fromBufferGeometry(new Tb(a,b,c));this.mergeVertices()}function Tb(a,b,c){D.call(this);this.type="ParametricBufferGeometry";this.parameters={func:a,slices:b,stacks:c};var d=[],e=[],f=[],g=[],h=
new p,k=new p,l=new p,q=new p,n=new p,t,r,m=b+1;for(t=0;t<=c;t++){var v=t/c;for(r=0;r<=b;r++){var w=r/b,k=a(w,v,k);e.push(k.x,k.y,k.z);0<=w-1E-5?(l=a(w-1E-5,v,l),q.subVectors(k,l)):(l=a(w+1E-5,v,l),q.subVectors(l,k));0<=v-1E-5?(l=a(w,v-1E-5,l),n.subVectors(k,l)):(l=a(w,v+1E-5,l),n.subVectors(l,k));h.crossVectors(q,n).normalize();f.push(h.x,h.y,h.z);g.push(w,v)}}for(t=0;t<c;t++)for(r=0;r<b;r++)a=t*m+r+1,h=(t+1)*m+r+1,k=(t+1)*m+r,d.push(t*m+r,a,k),d.push(a,h,k);this.setIndex(d);this.addAttribute("position",
new y(e,3));this.addAttribute("normal",new y(f,3));this.addAttribute("uv",new y(g,2))}function Ic(a,b,c,d){N.call(this);this.type="PolyhedronGeometry";this.parameters={vertices:a,indices:b,radius:c,detail:d};this.fromBufferGeometry(new qa(a,b,c,d));this.mergeVertices()}function qa(a,b,c,d){function e(a){h.push(a.x,a.y,a.z)}function f(b,c){b*=3;c.x=a[b+0];c.y=a[b+1];c.z=a[b+2]}function g(a,b,c,d){0>d&&1===a.x&&(k[b]=a.x-1);0===c.x&&0===c.z&&(k[b]=d/2/Math.PI+.5)}D.call(this);this.type="PolyhedronBufferGeometry";
this.parameters={vertices:a,indices:b,radius:c,detail:d};c=c||1;d=d||0;var h=[],k=[];(function(a){for(var c=new p,d=new p,g=new p,h=0;h<b.length;h+=3){f(b[h+0],c);f(b[h+1],d);f(b[h+2],g);var k,l,m=c,x=d,z=g,I=Math.pow(2,a),B=[];for(l=0;l<=I;l++){B[l]=[];var J=m.clone().lerp(z,l/I),y=x.clone().lerp(z,l/I),C=I-l;for(k=0;k<=C;k++)B[l][k]=0===k&&l===I?J:J.clone().lerp(y,k/C)}for(l=0;l<I;l++)for(k=0;k<2*(I-l)-1;k++)m=Math.floor(k/2),0===k%2?(e(B[l][m+1]),e(B[l+1][m]),e(B[l][m])):(e(B[l][m+1]),e(B[l+1][m+
1]),e(B[l+1][m]))}})(d);(function(a){for(var b=new p,c=0;c<h.length;c+=3)b.x=h[c+0],b.y=h[c+1],b.z=h[c+2],b.normalize().multiplyScalar(a),h[c+0]=b.x,h[c+1]=b.y,h[c+2]=b.z})(c);(function(){for(var a=new p,b=0;b<h.length;b+=3)a.x=h[b+0],a.y=h[b+1],a.z=h[b+2],k.push(Math.atan2(a.z,-a.x)/2/Math.PI+.5,1-(Math.atan2(-a.y,Math.sqrt(a.x*a.x+a.z*a.z))/Math.PI+.5));for(var a=new p,b=new p,c=new p,d=new p,e=new C,f=new C,m=new C,w=0,x=0;w<h.length;w+=9,x+=6){a.set(h[w+0],h[w+1],h[w+2]);b.set(h[w+3],h[w+4],h[w+
5]);c.set(h[w+6],h[w+7],h[w+8]);e.set(k[x+0],k[x+1]);f.set(k[x+2],k[x+3]);m.set(k[x+4],k[x+5]);d.copy(a).add(b).add(c).divideScalar(3);var z=Math.atan2(d.z,-d.x);g(e,x+0,a,z);g(f,x+2,b,z);g(m,x+4,c,z)}for(a=0;a<k.length;a+=6)b=k[a+0],c=k[a+2],d=k[a+4],e=Math.min(b,c,d),.9<Math.max(b,c,d)&&.1>e&&(.2>b&&(k[a+0]+=1),.2>c&&(k[a+2]+=1),.2>d&&(k[a+4]+=1))})();this.addAttribute("position",new y(h,3));this.addAttribute("normal",new y(h.slice(),3));this.addAttribute("uv",new y(k,2));0===d?this.computeVertexNormals():
this.normalizeNormals()}function Jc(a,b){N.call(this);this.type="TetrahedronGeometry";this.parameters={radius:a,detail:b};this.fromBufferGeometry(new Ub(a,b));this.mergeVertices()}function Ub(a,b){qa.call(this,[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],a,b);this.type="TetrahedronBufferGeometry";this.parameters={radius:a,detail:b}}function Kc(a,b){N.call(this);this.type="OctahedronGeometry";this.parameters={radius:a,detail:b};this.fromBufferGeometry(new nb(a,b));this.mergeVertices()}
function nb(a,b){qa.call(this,[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],a,b);this.type="OctahedronBufferGeometry";this.parameters={radius:a,detail:b}}function Lc(a,b){N.call(this);this.type="IcosahedronGeometry";this.parameters={radius:a,detail:b};this.fromBufferGeometry(new Vb(a,b));this.mergeVertices()}function Vb(a,b){var c=(1+Math.sqrt(5))/2;qa.call(this,[-1,c,0,1,c,0,-1,-c,0,1,-c,0,0,-1,c,0,1,c,0,-1,-c,0,1,-c,c,0,-1,c,0,1,-c,0,-1,-c,0,1],[0,11,
5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],a,b);this.type="IcosahedronBufferGeometry";this.parameters={radius:a,detail:b}}function Mc(a,b){N.call(this);this.type="DodecahedronGeometry";this.parameters={radius:a,detail:b};this.fromBufferGeometry(new Wb(a,b));this.mergeVertices()}function Wb(a,b){var c=(1+Math.sqrt(5))/2,d=1/c;qa.call(this,[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-d,-c,0,-d,c,0,
d,-c,0,d,c,-d,-c,0,-d,c,0,d,-c,0,d,c,0,-c,0,-d,c,0,-d,-c,0,d,c,0,d],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],a,b);this.type="DodecahedronBufferGeometry";this.parameters={radius:a,detail:b}}function Nc(a,b,c,d,e,f){N.call(this);this.type="TubeGeometry";this.parameters={path:a,
tubularSegments:b,radius:c,radialSegments:d,closed:e};void 0!==f&&console.warn("THREE.TubeGeometry: taper has been removed.");a=new Xb(a,b,c,d,e);this.tangents=a.tangents;this.normals=a.normals;this.binormals=a.binormals;this.fromBufferGeometry(a);this.mergeVertices()}function Xb(a,b,c,d,e){function f(e){q=a.getPointAt(e/b,q);var f=g.normals[e];e=g.binormals[e];for(t=0;t<=d;t++){var l=t/d*Math.PI*2,n=Math.sin(l),l=-Math.cos(l);k.x=l*f.x+n*e.x;k.y=l*f.y+n*e.y;k.z=l*f.z+n*e.z;k.normalize();u.push(k.x,
k.y,k.z);h.x=q.x+c*k.x;h.y=q.y+c*k.y;h.z=q.z+c*k.z;m.push(h.x,h.y,h.z)}}D.call(this);this.type="TubeBufferGeometry";this.parameters={path:a,tubularSegments:b,radius:c,radialSegments:d,closed:e};b=b||64;c=c||1;d=d||8;e=e||!1;var g=a.computeFrenetFrames(b,e);this.tangents=g.tangents;this.normals=g.normals;this.binormals=g.binormals;var h=new p,k=new p,l=new C,q=new p,n,t,m=[],u=[],v=[],w=[];for(n=0;n<b;n++)f(n);f(!1===e?b:0);for(n=0;n<=b;n++)for(t=0;t<=d;t++)l.x=n/b,l.y=t/d,v.push(l.x,l.y);(function(){for(t=
1;t<=b;t++)for(n=1;n<=d;n++){var a=(d+1)*t+(n-1),c=(d+1)*t+n,e=(d+1)*(t-1)+n;w.push((d+1)*(t-1)+(n-1),a,e);w.push(a,c,e)}})();this.setIndex(w);this.addAttribute("position",new y(m,3));this.addAttribute("normal",new y(u,3));this.addAttribute("uv",new y(v,2))}function Oc(a,b,c,d,e,f,g){N.call(this);this.type="TorusKnotGeometry";this.parameters={radius:a,tube:b,tubularSegments:c,radialSegments:d,p:e,q:f};void 0!==g&&console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
this.fromBufferGeometry(new Yb(a,b,c,d,e,f));this.mergeVertices()}function Yb(a,b,c,d,e,f){function g(a,b,c,d,e){var f=Math.sin(a);b=c/b*a;c=Math.cos(b);e.x=d*(2+c)*.5*Math.cos(a);e.y=d*(2+c)*f*.5;e.z=d*Math.sin(b)*.5}D.call(this);this.type="TorusKnotBufferGeometry";this.parameters={radius:a,tube:b,tubularSegments:c,radialSegments:d,p:e,q:f};a=a||1;b=b||.4;c=Math.floor(c)||64;d=Math.floor(d)||8;e=e||2;f=f||3;var h=[],k=[],l=[],q=[],n,t=new p,m=new p,u=new p,v=new p,w=new p,x=new p,z=new p;for(n=0;n<=
c;++n){var I=n/c*e*Math.PI*2;g(I,e,f,a,u);g(I+.01,e,f,a,v);x.subVectors(v,u);z.addVectors(v,u);w.crossVectors(x,z);z.crossVectors(w,x);w.normalize();z.normalize();for(I=0;I<=d;++I){var B=I/d*Math.PI*2,J=-b*Math.cos(B),B=b*Math.sin(B);t.x=u.x+(J*z.x+B*w.x);t.y=u.y+(J*z.y+B*w.y);t.z=u.z+(J*z.z+B*w.z);k.push(t.x,t.y,t.z);m.subVectors(t,u).normalize();l.push(m.x,m.y,m.z);q.push(n/c);q.push(I/d)}}for(I=1;I<=c;I++)for(n=1;n<=d;n++)a=(d+1)*I+(n-1),b=(d+1)*I+n,e=(d+1)*(I-1)+n,h.push((d+1)*(I-1)+(n-1),a,e),
h.push(a,b,e);this.setIndex(h);this.addAttribute("position",new y(k,3));this.addAttribute("normal",new y(l,3));this.addAttribute("uv",new y(q,2))}function Pc(a,b,c,d,e){N.call(this);this.type="TorusGeometry";this.parameters={radius:a,tube:b,radialSegments:c,tubularSegments:d,arc:e};this.fromBufferGeometry(new Zb(a,b,c,d,e));this.mergeVertices()}function Zb(a,b,c,d,e){D.call(this);this.type="TorusBufferGeometry";this.parameters={radius:a,tube:b,radialSegments:c,tubularSegments:d,arc:e};a=a||1;b=b||
.4;c=Math.floor(c)||8;d=Math.floor(d)||6;e=e||2*Math.PI;var f=[],g=[],h=[],k=[],l=new p,q=new p,n=new p,t,m;for(t=0;t<=c;t++)for(m=0;m<=d;m++){var u=m/d*e,v=t/c*Math.PI*2;q.x=(a+b*Math.cos(v))*Math.cos(u);q.y=(a+b*Math.cos(v))*Math.sin(u);q.z=b*Math.sin(v);g.push(q.x,q.y,q.z);l.x=a*Math.cos(u);l.y=a*Math.sin(u);n.subVectors(q,l).normalize();h.push(n.x,n.y,n.z);k.push(m/d);k.push(t/c)}for(t=1;t<=c;t++)for(m=1;m<=d;m++)a=(d+1)*(t-1)+m-1,b=(d+1)*(t-1)+m,e=(d+1)*t+m,f.push((d+1)*t+m-1,a,e),f.push(a,b,
e);this.setIndex(f);this.addAttribute("position",new y(g,3));this.addAttribute("normal",new y(h,3));this.addAttribute("uv",new y(k,2))}function $a(a,b){N.call(this);this.type="ExtrudeGeometry";this.parameters={shapes:a,options:b};this.fromBufferGeometry(new Ga(a,b));this.mergeVertices()}function Ga(a,b){"undefined"!==typeof a&&(D.call(this),this.type="ExtrudeBufferGeometry",a=Array.isArray(a)?a:[a],this.addShapeList(a,b),this.computeVertexNormals())}function Qc(a,b){N.call(this);this.type="TextGeometry";
this.parameters={text:a,parameters:b};this.fromBufferGeometry(new $b(a,b));this.mergeVertices()}function $b(a,b){b=b||{};var c=b.font;if(!c||!c.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new N;a=c.generateShapes(a,b.size,b.curveSegments);b.amount=void 0!==b.height?b.height:50;void 0===b.bevelThickness&&(b.bevelThickness=10);void 0===b.bevelSize&&(b.bevelSize=8);void 0===b.bevelEnabled&&(b.bevelEnabled=!1);Ga.call(this,a,b);this.type="TextBufferGeometry"}
function Rc(a,b,c,d,e,f,g){N.call(this);this.type="SphereGeometry";this.parameters={radius:a,widthSegments:b,heightSegments:c,phiStart:d,phiLength:e,thetaStart:f,thetaLength:g};this.fromBufferGeometry(new ob(a,b,c,d,e,f,g));this.mergeVertices()}function ob(a,b,c,d,e,f,g){D.call(this);this.type="SphereBufferGeometry";this.parameters={radius:a,widthSegments:b,heightSegments:c,phiStart:d,phiLength:e,thetaStart:f,thetaLength:g};a=a||1;b=Math.max(3,Math.floor(b)||8);c=Math.max(2,Math.floor(c)||6);d=void 0!==
d?d:0;e=void 0!==e?e:2*Math.PI;f=void 0!==f?f:0;g=void 0!==g?g:Math.PI;var h=f+g,k,l,q=0,n=[],t=new p,m=new p,u=[],v=[],w=[],x=[];for(l=0;l<=c;l++){var z=[],I=l/c;for(k=0;k<=b;k++){var B=k/b;t.x=-a*Math.cos(d+B*e)*Math.sin(f+I*g);t.y=a*Math.cos(f+I*g);t.z=a*Math.sin(d+B*e)*Math.sin(f+I*g);v.push(t.x,t.y,t.z);m.set(t.x,t.y,t.z).normalize();w.push(m.x,m.y,m.z);x.push(B,1-I);z.push(q++)}n.push(z)}for(l=0;l<c;l++)for(k=0;k<b;k++)a=n[l][k+1],d=n[l][k],e=n[l+1][k],g=n[l+1][k+1],(0!==l||0<f)&&u.push(a,d,
g),(l!==c-1||h<Math.PI)&&u.push(d,e,g);this.setIndex(u);this.addAttribute("position",new y(v,3));this.addAttribute("normal",new y(w,3));this.addAttribute("uv",new y(x,2))}function Sc(a,b,c,d,e,f){N.call(this);this.type="RingGeometry";this.parameters={innerRadius:a,outerRadius:b,thetaSegments:c,phiSegments:d,thetaStart:e,thetaLength:f};this.fromBufferGeometry(new ac(a,b,c,d,e,f));this.mergeVertices()}function ac(a,b,c,d,e,f){D.call(this);this.type="RingBufferGeometry";this.parameters={innerRadius:a,
outerRadius:b,thetaSegments:c,phiSegments:d,thetaStart:e,thetaLength:f};a=a||.5;b=b||1;e=void 0!==e?e:0;f=void 0!==f?f:2*Math.PI;c=void 0!==c?Math.max(3,c):8;d=void 0!==d?Math.max(1,d):1;var g=[],h=[],k=[],l=[],q=a,n=(b-a)/d,t=new p,m=new C,u,v;for(u=0;u<=d;u++){for(v=0;v<=c;v++)a=e+v/c*f,t.x=q*Math.cos(a),t.y=q*Math.sin(a),h.push(t.x,t.y,t.z),k.push(0,0,1),m.x=(t.x/b+1)/2,m.y=(t.y/b+1)/2,l.push(m.x,m.y);q+=n}for(u=0;u<d;u++)for(b=u*(c+1),v=0;v<c;v++)a=v+b,e=a+c+1,f=a+c+2,q=a+1,g.push(a,e,q),g.push(e,
f,q);this.setIndex(g);this.addAttribute("position",new y(h,3));this.addAttribute("normal",new y(k,3));this.addAttribute("uv",new y(l,2))}function Tc(a,b,c,d){N.call(this);this.type="LatheGeometry";this.parameters={points:a,segments:b,phiStart:c,phiLength:d};this.fromBufferGeometry(new bc(a,b,c,d));this.mergeVertices()}function bc(a,b,c,d){D.call(this);this.type="LatheBufferGeometry";this.parameters={points:a,segments:b,phiStart:c,phiLength:d};b=Math.floor(b)||12;c=c||0;d=d||2*Math.PI;d=R.clamp(d,
0,2*Math.PI);var e=[],f=[],g=[],h=1/b,k=new p,l=new C,q;for(q=0;q<=b;q++){var n=c+q*h*d;var t=Math.sin(n),m=Math.cos(n);for(n=0;n<=a.length-1;n++)k.x=a[n].x*t,k.y=a[n].y,k.z=a[n].x*m,f.push(k.x,k.y,k.z),l.x=q/b,l.y=n/(a.length-1),g.push(l.x,l.y)}for(q=0;q<b;q++)for(n=0;n<a.length-1;n++)c=n+q*a.length,h=c+a.length,k=c+a.length+1,l=c+1,e.push(c,h,l),e.push(h,k,l);this.setIndex(e);this.addAttribute("position",new y(f,3));this.addAttribute("uv",new y(g,2));this.computeVertexNormals();if(d===2*Math.PI)for(d=
this.attributes.normal.array,e=new p,f=new p,g=new p,c=b*a.length*3,n=q=0;q<a.length;q++,n+=3)e.x=d[n+0],e.y=d[n+1],e.z=d[n+2],f.x=d[c+n+0],f.y=d[c+n+1],f.z=d[c+n+2],g.addVectors(e,f).normalize(),d[n+0]=d[c+n+0]=g.x,d[n+1]=d[c+n+1]=g.y,d[n+2]=d[c+n+2]=g.z}function cc(a,b){N.call(this);this.type="ShapeGeometry";"object"===typeof b&&(console.warn("THREE.ShapeGeometry: Options parameter has been removed."),b=b.curveSegments);this.parameters={shapes:a,curveSegments:b};this.fromBufferGeometry(new dc(a,
b));this.mergeVertices()}function dc(a,b){function c(a){var c,h=e.length/3;a=a.extractPoints(b);var l=a.shape,q=a.holes;if(!1===Ha.isClockWise(l))for(l=l.reverse(),a=0,c=q.length;a<c;a++){var m=q[a];!0===Ha.isClockWise(m)&&(q[a]=m.reverse())}var p=Ha.triangulateShape(l,q);a=0;for(c=q.length;a<c;a++)m=q[a],l=l.concat(m);a=0;for(c=l.length;a<c;a++)m=l[a],e.push(m.x,m.y,0),f.push(0,0,1),g.push(m.x,m.y);a=0;for(c=p.length;a<c;a++)l=p[a],d.push(l[0]+h,l[1]+h,l[2]+h),k+=3}D.call(this);this.type="ShapeBufferGeometry";
this.parameters={shapes:a,curveSegments:b};b=b||12;var d=[],e=[],f=[],g=[],h=0,k=0;if(!1===Array.isArray(a))c(a);else for(var l=0;l<a.length;l++)c(a[l]),this.addGroup(h,k,l),h+=k,k=0;this.setIndex(d);this.addAttribute("position",new y(e,3));this.addAttribute("normal",new y(f,3));this.addAttribute("uv",new y(g,2))}function ec(a,b){D.call(this);this.type="EdgesGeometry";this.parameters={thresholdAngle:b};var c=[];b=Math.cos(R.DEG2RAD*(void 0!==b?b:1));var d=[0,0],e={},f=["a","b","c"];if(a.isBufferGeometry){var g=
new N;g.fromBufferGeometry(a)}else g=a.clone();g.mergeVertices();g.computeFaceNormals();a=g.vertices;g=g.faces;for(var h=0,k=g.length;h<k;h++)for(var l=g[h],q=0;3>q;q++){var n=l[f[q]];var t=l[f[(q+1)%3]];d[0]=Math.min(n,t);d[1]=Math.max(n,t);n=d[0]+","+d[1];void 0===e[n]?e[n]={index1:d[0],index2:d[1],face1:h,face2:void 0}:e[n].face2=h}for(n in e)if(d=e[n],void 0===d.face2||g[d.face1].normal.dot(g[d.face2].normal)<=b)f=a[d.index1],c.push(f.x,f.y,f.z),f=a[d.index2],c.push(f.x,f.y,f.z);this.addAttribute("position",
new y(c,3))}function pb(a,b,c,d,e,f,g,h){N.call(this);this.type="CylinderGeometry";this.parameters={radiusTop:a,radiusBottom:b,height:c,radialSegments:d,heightSegments:e,openEnded:f,thetaStart:g,thetaLength:h};this.fromBufferGeometry(new Sa(a,b,c,d,e,f,g,h));this.mergeVertices()}function Sa(a,b,c,d,e,f,g,h){function k(c){var e,f=new C,k=new p,r=0,v=!0===c?a:b,z=!0===c?1:-1;var y=u;for(e=1;e<=d;e++)n.push(0,w*z,0),t.push(0,z,0),m.push(.5,.5),u++;var A=u;for(e=0;e<=d;e++){var D=e/d*h+g,L=Math.cos(D),
D=Math.sin(D);k.x=v*D;k.y=w*z;k.z=v*L;n.push(k.x,k.y,k.z);t.push(0,z,0);f.x=.5*L+.5;f.y=.5*D*z+.5;m.push(f.x,f.y);u++}for(e=0;e<d;e++)f=y+e,k=A+e,!0===c?q.push(k,k+1,f):q.push(k+1,k,f),r+=3;l.addGroup(x,r,!0===c?1:2);x+=r}D.call(this);this.type="CylinderBufferGeometry";this.parameters={radiusTop:a,radiusBottom:b,height:c,radialSegments:d,heightSegments:e,openEnded:f,thetaStart:g,thetaLength:h};var l=this;a=void 0!==a?a:1;b=void 0!==b?b:1;c=c||1;d=Math.floor(d)||8;e=Math.floor(e)||1;f=void 0!==f?f:
!1;g=void 0!==g?g:0;h=void 0!==h?h:2*Math.PI;var q=[],n=[],t=[],m=[],u=0,v=[],w=c/2,x=0;(function(){var f,k,r=new p,J=new p,y=0,C=(b-a)/c;for(k=0;k<=e;k++){var A=[],D=k/e,E=D*(b-a)+a;for(f=0;f<=d;f++){var H=f/d,L=H*h+g,Y=Math.sin(L),L=Math.cos(L);J.x=E*Y;J.y=-D*c+w;J.z=E*L;n.push(J.x,J.y,J.z);r.set(Y,C,L).normalize();t.push(r.x,r.y,r.z);m.push(H,1-D);A.push(u++)}v.push(A)}for(f=0;f<d;f++)for(k=0;k<e;k++)r=v[k+1][f],J=v[k+1][f+1],C=v[k][f+1],q.push(v[k][f],r,C),q.push(r,J,C),y+=6;l.addGroup(x,y,0);
x+=y})();!1===f&&(0<a&&k(!0),0<b&&k(!1));this.setIndex(q);this.addAttribute("position",new y(n,3));this.addAttribute("normal",new y(t,3));this.addAttribute("uv",new y(m,2))}function Uc(a,b,c,d,e,f,g){pb.call(this,0,a,b,c,d,e,f,g);this.type="ConeGeometry";this.parameters={radius:a,height:b,radialSegments:c,heightSegments:d,openEnded:e,thetaStart:f,thetaLength:g}}function Vc(a,b,c,d,e,f,g){Sa.call(this,0,a,b,c,d,e,f,g);this.type="ConeBufferGeometry";this.parameters={radius:a,height:b,radialSegments:c,
heightSegments:d,openEnded:e,thetaStart:f,thetaLength:g}}function Wc(a,b,c,d){N.call(this);this.type="CircleGeometry";this.parameters={radius:a,segments:b,thetaStart:c,thetaLength:d};this.fromBufferGeometry(new fc(a,b,c,d));this.mergeVertices()}function fc(a,b,c,d){D.call(this);this.type="CircleBufferGeometry";this.parameters={radius:a,segments:b,thetaStart:c,thetaLength:d};a=a||1;b=void 0!==b?Math.max(3,b):8;c=void 0!==c?c:0;d=void 0!==d?d:2*Math.PI;var e=[],f=[],g=[],h=[],k,l=new p,q=new C;f.push(0,
0,0);g.push(0,0,1);h.push(.5,.5);var n=0;for(k=3;n<=b;n++,k+=3){var t=c+n/b*d;l.x=a*Math.cos(t);l.y=a*Math.sin(t);f.push(l.x,l.y,l.z);g.push(0,0,1);q.x=(f[k]/a+1)/2;q.y=(f[k+1]/a+1)/2;h.push(q.x,q.y)}for(k=1;k<=b;k++)e.push(k,k+1,0);this.setIndex(e);this.addAttribute("position",new y(f,3));this.addAttribute("normal",new y(g,3));this.addAttribute("uv",new y(h,2))}function gc(a){Q.call(this);this.type="ShadowMaterial";this.color=new H(0);this.opacity=1;this.transparent=this.lights=!0;this.setValues(a)}
function hc(a){oa.call(this,a);this.type="RawShaderMaterial"}function Ma(a){Q.call(this);this.defines={STANDARD:""};this.type="MeshStandardMaterial";this.color=new H(16777215);this.metalness=this.roughness=.5;this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new H(0);this.emissiveIntensity=1;this.bumpMap=this.emissiveMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new C(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=
0;this.envMap=this.alphaMap=this.metalnessMap=this.roughnessMap=null;this.envMapIntensity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)}function qb(a){Ma.call(this);this.defines={PHYSICAL:""};this.type="MeshPhysicalMaterial";this.reflectivity=.5;this.clearCoatRoughness=this.clearCoat=0;this.setValues(a)}function Ia(a){Q.call(this);this.type="MeshPhongMaterial";
this.color=new H(16777215);this.specular=new H(1118481);this.shininess=30;this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new H(0);this.emissiveIntensity=1;this.bumpMap=this.emissiveMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new C(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.envMap=this.alphaMap=this.specularMap=null;this.combine=0;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=
!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)}function rb(a){Ia.call(this);this.defines={TOON:""};this.type="MeshToonMaterial";this.gradientMap=null;this.setValues(a)}function sb(a){Q.call(this);this.type="MeshNormalMaterial";this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new C(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=
!1;this.wireframeLinewidth=1;this.morphNormals=this.morphTargets=this.skinning=this.lights=this.fog=!1;this.setValues(a)}function tb(a){Q.call(this);this.type="MeshLambertMaterial";this.color=new H(16777215);this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new H(0);this.emissiveIntensity=1;this.envMap=this.alphaMap=this.specularMap=this.emissiveMap=null;this.combine=0;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=
1;this.wireframeLinejoin=this.wireframeLinecap="round";this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)}function ub(a){O.call(this);this.type="LineDashedMaterial";this.scale=1;this.dashSize=3;this.gapSize=1;this.setValues(a)}function Yd(a,b,c){var d=this,e=!1,f=0,g=0,h=void 0;this.onStart=void 0;this.onLoad=a;this.onProgress=b;this.onError=c;this.itemStart=function(a){g++;if(!1===e&&void 0!==d.onStart)d.onStart(a,f,g);e=!0};this.itemEnd=function(a){f++;if(void 0!==d.onProgress)d.onProgress(a,
f,g);if(f===g&&(e=!1,void 0!==d.onLoad))d.onLoad()};this.itemError=function(a){if(void 0!==d.onError)d.onError(a)};this.resolveURL=function(a){return h?h(a):a};this.setURLModifier=function(a){h=a}}function Ja(a){this.manager=void 0!==a?a:wa}function Qe(a){this.manager=void 0!==a?a:wa;this._parser=null}function Zd(a){this.manager=void 0!==a?a:wa;this._parser=null}function Xc(a){this.manager=void 0!==a?a:wa}function $d(a){this.manager=void 0!==a?a:wa}function td(a){this.manager=void 0!==a?a:wa}function ga(a,
b){A.call(this);this.type="Light";this.color=new H(a);this.intensity=void 0!==b?b:1;this.receiveShadow=void 0}function ud(a,b,c){ga.call(this,a,c);this.type="HemisphereLight";this.castShadow=void 0;this.position.copy(A.DefaultUp);this.updateMatrix();this.groundColor=new H(b)}function vb(a){this.camera=a;this.bias=0;this.radius=1;this.mapSize=new C(512,512);this.map=null;this.matrix=new K}function vd(){vb.call(this,new U(50,1,.5,500))}function wd(a,b,c,d,e,f){ga.call(this,a,b);this.type="SpotLight";
this.position.copy(A.DefaultUp);this.updateMatrix();this.target=new A;Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(a){this.intensity=a/Math.PI}});this.distance=void 0!==c?c:0;this.angle=void 0!==d?d:Math.PI/3;this.penumbra=void 0!==e?e:0;this.decay=void 0!==f?f:1;this.shadow=new vd}function xd(a,b,c,d){ga.call(this,a,b);this.type="PointLight";Object.defineProperty(this,"power",{get:function(){return 4*this.intensity*Math.PI},set:function(a){this.intensity=
a/(4*Math.PI)}});this.distance=void 0!==c?c:0;this.decay=void 0!==d?d:1;this.shadow=new vb(new U(90,1,.5,500))}function yd(){vb.call(this,new Kb(-5,5,5,-5,.5,500))}function zd(a,b){ga.call(this,a,b);this.type="DirectionalLight";this.position.copy(A.DefaultUp);this.updateMatrix();this.target=new A;this.shadow=new yd}function Ad(a,b){ga.call(this,a,b);this.type="AmbientLight";this.castShadow=void 0}function Bd(a,b,c,d){ga.call(this,a,b);this.type="RectAreaLight";this.position.set(0,1,0);this.updateMatrix();
this.width=void 0!==c?c:10;this.height=void 0!==d?d:10}function xa(a,b,c,d){this.parameterPositions=a;this._cachedIndex=0;this.resultBuffer=void 0!==d?d:new b.constructor(c);this.sampleValues=b;this.valueSize=c}function Cd(a,b,c,d){xa.call(this,a,b,c,d);this._offsetNext=this._weightNext=this._offsetPrev=this._weightPrev=-0}function Yc(a,b,c,d){xa.call(this,a,b,c,d)}function Dd(a,b,c,d){xa.call(this,a,b,c,d)}function wb(a,b,c,d){if(void 0===a)throw Error("track name is undefined");if(void 0===b||0===
b.length)throw Error("no keyframes in track named "+a);this.name=a;this.times=T.convertArray(b,this.TimeBufferType);this.values=T.convertArray(c,this.ValueBufferType);this.setInterpolation(d||this.DefaultInterpolation);this.validate();this.optimize()}function ic(a,b,c,d){wb.call(this,a,b,c,d)}function Ed(a,b,c,d){xa.call(this,a,b,c,d)}function Zc(a,b,c,d){wb.call(this,a,b,c,d)}function jc(a,b,c,d){wb.call(this,a,b,c,d)}function Fd(a,b,c,d){wb.call(this,a,b,c,d)}function Gd(a,b,c){wb.call(this,a,b,
c)}function Hd(a,b,c,d){wb.call(this,a,b,c,d)}function xb(a,b,c,d){wb.apply(this,a,b,c,d)}function ka(a,b,c){this.name=a;this.tracks=c;this.duration=void 0!==b?b:-1;this.uuid=R.generateUUID();0>this.duration&&this.resetDuration();this.optimize()}function Id(a){this.manager=void 0!==a?a:wa;this.textures={}}function ae(a){this.manager=void 0!==a?a:wa}function kc(){this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){}}function be(a){"boolean"===typeof a&&(console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."),
a=void 0);this.manager=void 0!==a?a:wa;this.withCredentials=!1}function Re(a){this.manager=void 0!==a?a:wa;this.texturePath=""}function Se(a,b,c,d,e){b=.5*(d-b);e=.5*(e-c);var f=a*a;return(2*c-2*d+b+e)*a*f+(-3*c+3*d-2*b-e)*f+b*a+c}function yb(a,b,c,d){var e=1-a;return e*e*b+2*(1-a)*a*c+a*a*d}function zb(a,b,c,d,e){var f=1-a,g=1-a;return f*f*f*b+3*g*g*a*c+3*(1-a)*a*a*d+a*a*a*e}function S(){this.type="Curve";this.arcLengthDivisions=200}function Ka(a,b){S.call(this);this.type="LineCurve";this.v1=a||
new C;this.v2=b||new C}function Ab(){S.call(this);this.type="CurvePath";this.curves=[];this.autoClose=!1}function Na(a,b,c,d,e,f,g,h){S.call(this);this.type="EllipseCurve";this.aX=a||0;this.aY=b||0;this.xRadius=c||1;this.yRadius=d||1;this.aStartAngle=e||0;this.aEndAngle=f||2*Math.PI;this.aClockwise=g||!1;this.aRotation=h||0}function ab(a){S.call(this);this.type="SplineCurve";this.points=a||[]}function bb(a,b,c,d){S.call(this);this.type="CubicBezierCurve";this.v0=a||new C;this.v1=b||new C;this.v2=
c||new C;this.v3=d||new C}function cb(a,b,c){S.call(this);this.type="QuadraticBezierCurve";this.v0=a||new C;this.v1=b||new C;this.v2=c||new C}function Bb(a){Ab.call(this);this.type="Path";this.currentPoint=new C;a&&this.setFromPoints(a)}function Cb(a){Bb.call(this,a);this.type="Shape";this.holes=[]}function ce(){this.type="ShapePath";this.subPaths=[];this.currentPath=null}function de(a){this.type="Font";this.data=a}function Te(a){this.manager=void 0!==a?a:wa}function ee(a){this.manager=void 0!==a?
a:wa}function Ue(){this.type="StereoCamera";this.aspect=1;this.eyeSep=.064;this.cameraL=new U;this.cameraL.layers.enable(1);this.cameraL.matrixAutoUpdate=!1;this.cameraR=new U;this.cameraR.layers.enable(2);this.cameraR.matrixAutoUpdate=!1}function $c(a,b,c){A.call(this);this.type="CubeCamera";var d=new U(90,1,a,b);d.up.set(0,-1,0);d.lookAt(new p(1,0,0));this.add(d);var e=new U(90,1,a,b);e.up.set(0,-1,0);e.lookAt(new p(-1,0,0));this.add(e);var f=new U(90,1,a,b);f.up.set(0,0,1);f.lookAt(new p(0,1,0));
this.add(f);var g=new U(90,1,a,b);g.up.set(0,0,-1);g.lookAt(new p(0,-1,0));this.add(g);var h=new U(90,1,a,b);h.up.set(0,-1,0);h.lookAt(new p(0,0,1));this.add(h);var k=new U(90,1,a,b);k.up.set(0,-1,0);k.lookAt(new p(0,0,-1));this.add(k);this.renderTarget=new Ib(c,c,{format:1022,magFilter:1006,minFilter:1006});this.renderTarget.texture.name="CubeCamera";this.update=function(a,b){null===this.parent&&this.updateMatrixWorld();var c=this.renderTarget,l=c.texture.generateMipmaps;c.texture.generateMipmaps=
!1;c.activeCubeFace=0;a.render(b,d,c);c.activeCubeFace=1;a.render(b,e,c);c.activeCubeFace=2;a.render(b,f,c);c.activeCubeFace=3;a.render(b,g,c);c.activeCubeFace=4;a.render(b,h,c);c.texture.generateMipmaps=l;c.activeCubeFace=5;a.render(b,k,c);a.setRenderTarget(null)};this.clear=function(a,b,c,d){for(var e=this.renderTarget,f=0;6>f;f++)e.activeCubeFace=f,a.setRenderTarget(e),a.clear(b,c,d);a.setRenderTarget(null)}}function fe(){A.call(this);this.type="AudioListener";this.context=ge.getContext();this.gain=
this.context.createGain();this.gain.connect(this.context.destination);this.filter=null}function lc(a){A.call(this);this.type="Audio";this.context=a.context;this.gain=this.context.createGain();this.gain.connect(a.getInput());this.autoplay=!1;this.buffer=null;this.loop=!1;this.offset=this.startTime=0;this.playbackRate=1;this.isPlaying=!1;this.hasPlaybackControl=!0;this.sourceType="empty";this.filters=[]}function he(a){lc.call(this,a);this.panner=this.context.createPanner();this.panner.connect(this.gain)}
function ie(a,b){this.analyser=a.context.createAnalyser();this.analyser.fftSize=void 0!==b?b:2048;this.data=new Uint8Array(this.analyser.frequencyBinCount);a.getOutput().connect(this.analyser)}function je(a,b,c){this.binding=a;this.valueSize=c;a=Float64Array;switch(b){case "quaternion":b=this._slerp;break;case "string":case "bool":a=Array;b=this._select;break;default:b=this._lerp}this.buffer=new a(4*c);this._mixBufferRegion=b;this.referenceCount=this.useCount=this.cumulativeWeight=0}function Ve(a,
b,c){c=c||na.parseTrackName(b);this._targetGroup=a;this._bindings=a.subscribe_(b,c)}function na(a,b,c){this.path=b;this.parsedPath=c||na.parseTrackName(b);this.node=na.findNode(a,this.parsedPath.nodeName)||a;this.rootNode=a}function We(){this.uuid=R.generateUUID();this._objects=Array.prototype.slice.call(arguments);this.nCachedObjects_=0;var a={};this._indicesByUUID=a;for(var b=0,c=arguments.length;b!==c;++b)a[arguments[b].uuid]=b;this._paths=[];this._parsedPaths=[];this._bindings=[];this._bindingsIndicesByPath=
{};var d=this;this.stats={objects:{get total(){return d._objects.length},get inUse(){return this.total-d.nCachedObjects_}},get bindingsPerObject(){return d._bindings.length}}}function Xe(a,b,c){this._mixer=a;this._clip=b;this._localRoot=c||null;a=b.tracks;b=a.length;c=Array(b);for(var d={endingStart:2400,endingEnd:2400},e=0;e!==b;++e){var f=a[e].createInterpolant(null);c[e]=f;f.settings=d}this._interpolantSettings=d;this._interpolants=c;this._propertyBindings=Array(b);this._weightInterpolant=this._timeScaleInterpolant=
this._byClipCacheIndex=this._cacheIndex=null;this.loop=2201;this._loopCount=-1;this._startTime=null;this.time=0;this._effectiveWeight=this.weight=this._effectiveTimeScale=this.timeScale=1;this.repetitions=Infinity;this.paused=!1;this.enabled=!0;this.clampWhenFinished=!1;this.zeroSlopeAtEnd=this.zeroSlopeAtStart=!0}function Ye(a){this._root=a;this._initMemoryManager();this.time=this._accuIndex=0;this.timeScale=1}function Jd(a,b){"string"===typeof a&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),
a=b);this.value=a}function ke(){D.call(this);this.type="InstancedBufferGeometry";this.maxInstancedCount=void 0}function le(a,b,c,d){this.uuid=R.generateUUID();this.data=a;this.itemSize=b;this.offset=c;this.normalized=!0===d}function mc(a,b){this.uuid=R.generateUUID();this.array=a;this.stride=b;this.count=void 0!==a?a.length/b:0;this.dynamic=!1;this.updateRange={offset:0,count:-1};this.onUploadCallback=function(){};this.version=0}function me(a,b,c){mc.call(this,a,b);this.meshPerAttribute=c||1}function ne(a,
b,c){P.call(this,a,b);this.meshPerAttribute=c||1}function Ze(a,b,c,d){this.ray=new lb(a,b);this.near=c||0;this.far=d||Infinity;this.params={Mesh:{},Line:{},LOD:{},Points:{threshold:1},Sprite:{}};Object.defineProperties(this.params,{PointCloud:{get:function(){console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");return this.Points}}})}function $e(a,b){return a.distance-b.distance}function oe(a,b,c,d){if(!1!==a.visible&&(a.raycast(b,c),!0===d)){a=a.children;d=0;for(var e=
a.length;d<e;d++)oe(a[d],b,c,!0)}}function af(a){this.autoStart=void 0!==a?a:!0;this.elapsedTime=this.oldTime=this.startTime=0;this.running=!1}function bf(a,b,c){this.radius=void 0!==a?a:1;this.phi=void 0!==b?b:0;this.theta=void 0!==c?c:0;return this}function cf(a,b,c){this.radius=void 0!==a?a:1;this.theta=void 0!==b?b:0;this.y=void 0!==c?c:0;return this}function ad(a){A.call(this);this.material=a;this.render=function(){}}function bd(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;a=void 0!==c?c:
16711680;d=void 0!==d?d:1;b=0;(c=this.object.geometry)&&c.isGeometry?b=3*c.faces.length:c&&c.isBufferGeometry&&(b=c.attributes.normal.count);c=new D;b=new y(6*b,3);c.addAttribute("position",b);ca.call(this,c,new O({color:a,linewidth:d}));this.matrixAutoUpdate=!1;this.update()}function nc(a,b){A.call(this);this.light=a;this.light.updateMatrixWorld();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.color=b;a=new D;b=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(var c=0,
d=1;32>c;c++,d++){var e=c/32*Math.PI*2,f=d/32*Math.PI*2;b.push(Math.cos(e),Math.sin(e),1,Math.cos(f),Math.sin(f),1)}a.addAttribute("position",new y(b,3));b=new O({fog:!1});this.cone=new ca(a,b);this.add(this.cone);this.update()}function df(a){var b=[];a&&a.isBone&&b.push(a);for(var c=0;c<a.children.length;c++)b.push.apply(b,df(a.children[c]));return b}function oc(a){for(var b=df(a),c=new D,d=[],e=[],f=new H(0,0,1),g=new H(0,1,0),h=0;h<b.length;h++){var k=b[h];k.parent&&k.parent.isBone&&(d.push(0,
0,0),d.push(0,0,0),e.push(f.r,f.g,f.b),e.push(g.r,g.g,g.b))}c.addAttribute("position",new y(d,3));c.addAttribute("color",new y(e,3));d=new O({vertexColors:2,depthTest:!1,depthWrite:!1,transparent:!0});ca.call(this,c,d);this.root=a;this.bones=b;this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1}function pc(a,b,c){this.light=a;this.light.updateMatrixWorld();this.color=c;a=new ob(b,4,2);b=new va({wireframe:!0,fog:!1});pa.call(this,a,b);this.matrix=this.light.matrixWorld;this.matrixAutoUpdate=!1;this.update()}
function qc(a,b){A.call(this);this.light=a;this.light.updateMatrixWorld();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.color=b;a=new O({fog:!1});b=new D;b.addAttribute("position",new P(new Float32Array(15),3));this.line=new ma(b,a);this.add(this.line);this.update()}function rc(a,b,c){A.call(this);this.light=a;this.light.updateMatrixWorld();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.color=c;a=new nb(b);a.rotateY(.5*Math.PI);this.material=new va({wireframe:!0,fog:!1});void 0===
this.color&&(this.material.vertexColors=2);b=a.getAttribute("position");b=new Float32Array(3*b.count);a.addAttribute("color",new P(b,3));this.add(new pa(a,this.material));this.update()}function cd(a,b,c,d){a=a||10;b=b||10;c=new H(void 0!==c?c:4473924);d=new H(void 0!==d?d:8947848);var e=b/2,f=a/b,g=a/2;a=[];for(var h=[],k=0,l=0,q=-g;k<=b;k++,q+=f){a.push(-g,0,q,g,0,q);a.push(q,0,-g,q,0,g);var n=k===e?c:d;n.toArray(h,l);l+=3;n.toArray(h,l);l+=3;n.toArray(h,l);l+=3;n.toArray(h,l);l+=3}b=new D;b.addAttribute("position",
new y(a,3));b.addAttribute("color",new y(h,3));c=new O({vertexColors:2});ca.call(this,b,c)}function Kd(a,b,c,d,e,f){a=a||10;b=b||16;c=c||8;d=d||64;e=new H(void 0!==e?e:4473924);f=new H(void 0!==f?f:8947848);var g=[],h=[],k;for(k=0;k<=b;k++){var l=k/b*2*Math.PI;var q=Math.sin(l)*a;l=Math.cos(l)*a;g.push(0,0,0);g.push(q,0,l);var n=k&1?e:f;h.push(n.r,n.g,n.b);h.push(n.r,n.g,n.b)}for(k=0;k<=c;k++){n=k&1?e:f;var t=a-a/c*k;for(b=0;b<d;b++)l=b/d*2*Math.PI,q=Math.sin(l)*t,l=Math.cos(l)*t,g.push(q,0,l),h.push(n.r,
n.g,n.b),l=(b+1)/d*2*Math.PI,q=Math.sin(l)*t,l=Math.cos(l)*t,g.push(q,0,l),h.push(n.r,n.g,n.b)}a=new D;a.addAttribute("position",new y(g,3));a.addAttribute("color",new y(h,3));g=new O({vertexColors:2});ca.call(this,a,g)}function dd(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;a=void 0!==c?c:16776960;d=void 0!==d?d:1;b=0;(c=this.object.geometry)&&c.isGeometry?b=c.faces.length:console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");c=new D;
b=new y(6*b,3);c.addAttribute("position",b);ca.call(this,c,new O({color:a,linewidth:d}));this.matrixAutoUpdate=!1;this.update()}function sc(a,b,c){A.call(this);this.light=a;this.light.updateMatrixWorld();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.color=c;void 0===b&&(b=1);a=new D;a.addAttribute("position",new y([-b,b,0,b,b,0,b,-b,0,-b,-b,0,-b,b,0],3));b=new O({fog:!1});this.lightPlane=new ma(a,b);this.add(this.lightPlane);a=new D;a.addAttribute("position",new y([0,0,0,0,0,1],3));this.targetLine=
new ma(a,b);this.add(this.targetLine);this.update()}function ed(a){function b(a,b,d){c(a,d);c(b,d)}function c(a,b){f.push(0,0,0);g.push(b.r,b.g,b.b);void 0===h[a]&&(h[a]=[]);h[a].push(f.length/3-1)}var d=new D,e=new O({color:16777215,vertexColors:1}),f=[],g=[],h={},k=new H(16755200),l=new H(16711680),q=new H(43775),n=new H(16777215),t=new H(3355443);b("n1","n2",k);b("n2","n4",k);b("n4","n3",k);b("n3","n1",k);b("f1","f2",k);b("f2","f4",k);b("f4","f3",k);b("f3","f1",k);b("n1","f1",k);b("n2","f2",k);
b("n3","f3",k);b("n4","f4",k);b("p","n1",l);b("p","n2",l);b("p","n3",l);b("p","n4",l);b("u1","u2",q);b("u2","u3",q);b("u3","u1",q);b("c","t",n);b("p","c",t);b("cn1","cn2",t);b("cn3","cn4",t);b("cf1","cf2",t);b("cf3","cf4",t);d.addAttribute("position",new y(f,3));d.addAttribute("color",new y(g,3));ca.call(this,d,e);this.camera=a;this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.pointMap=h;this.update()}function Db(a,b){this.object=
a;void 0===b&&(b=16776960);a=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);var c=new Float32Array(24),d=new D;d.setIndex(new P(a,1));d.addAttribute("position",new P(c,3));ca.call(this,d,new O({color:b}));this.matrixAutoUpdate=!1;this.update()}function fd(a,b){this.type="Box3Helper";this.box=a;a=void 0!==b?b:16776960;b=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);var c=new D;c.setIndex(new P(b,1));c.addAttribute("position",new y([1,1,1,-1,1,1,-1,-1,1,1,-1,
1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3));ca.call(this,c,new O({color:a}));this.geometry.computeBoundingSphere()}function gd(a,b,c){this.type="PlaneHelper";this.plane=a;this.size=void 0===b?1:b;a=void 0!==c?c:16776960;b=new D;b.addAttribute("position",new y([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3));b.computeBoundingSphere();ma.call(this,b,new O({color:a}));b=new D;b.addAttribute("position",new y([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3));b.computeBoundingSphere();
this.add(new pa(b,new va({color:a,opacity:.2,transparent:!0,depthWrite:!1})))}function Eb(a,b,c,d,e,f){A.call(this);void 0===d&&(d=16776960);void 0===c&&(c=1);void 0===e&&(e=.2*c);void 0===f&&(f=.2*e);void 0===Ld&&(Ld=new D,Ld.addAttribute("position",new y([0,0,0,0,1,0],3)),pe=new Sa(0,.5,1,5,1),pe.translate(0,-.5,0));this.position.copy(b);this.line=new ma(Ld,new O({color:d}));this.line.matrixAutoUpdate=!1;this.add(this.line);this.cone=new pa(pe,new va({color:d}));this.cone.matrixAutoUpdate=!1;this.add(this.cone);
this.setDirection(a);this.setLength(c,e,f)}function hd(a){a=a||1;var b=[0,0,0,a,0,0,0,0,0,0,a,0,0,0,0,0,0,a];a=new D;a.addAttribute("position",new y(b,3));a.addAttribute("color",new y([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3));b=new O({vertexColors:2});ca.call(this,a,b)}function qe(){var a=0,b=0,c=0,d=0;return{initCatmullRom:function(e,f,g,h,k){e=k*(g-e);h=k*(h-f);a=f;b=e;c=-3*f+3*g-2*e-h;d=2*f-2*g+e+h},initNonuniformCatmullRom:function(e,f,g,h,k,l,q){e=((f-e)/k-(g-e)/(k+l)+(g-f)/l)*l;h=((g-f)/
l-(h-f)/(l+q)+(h-g)/q)*l;a=f;b=e;c=-3*f+3*g-2*e-h;d=2*f-2*g+e+h},calc:function(e){var f=e*e;return a+b*e+c*f+d*f*e}}}function ya(a,b,c,d){S.call(this);this.type="CatmullRomCurve3";this.points=a||[];this.closed=b||!1;this.curveType=c||"centripetal";this.tension=d||.5}function Fb(a,b,c,d){S.call(this);this.type="CubicBezierCurve3";this.v0=a||new p;this.v1=b||new p;this.v2=c||new p;this.v3=d||new p}function Gb(a,b,c){S.call(this);this.type="QuadraticBezierCurve3";this.v0=a||new p;this.v1=b||new p;this.v2=
c||new p}function db(a,b){S.call(this);this.type="LineCurve3";this.v1=a||new p;this.v2=b||new p}function id(a,b,c,d,e,f){Na.call(this,a,b,c,c,d,e,f);this.type="ArcCurve"}function ef(a){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");ya.call(this,a);this.type="catmullrom";this.closed=!0}function ff(a){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");ya.call(this,a);this.type="catmullrom"}function re(a){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
ya.call(this,a);this.type="catmullrom"}void 0===Number.EPSILON&&(Number.EPSILON=Math.pow(2,-52));void 0===Number.isInteger&&(Number.isInteger=function(a){return"number"===typeof a&&isFinite(a)&&Math.floor(a)===a});void 0===Math.sign&&(Math.sign=function(a){return 0>a?-1:0<a?1:+a});!1==="name"in Function.prototype&&Object.defineProperty(Function.prototype,"name",{get:function(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]}});void 0===Object.assign&&function(){Object.assign=function(a){if(void 0===
a||null===a)throw new TypeError("Cannot convert undefined or null to object");for(var b=Object(a),c=1;c<arguments.length;c++){var d=arguments[c];if(void 0!==d&&null!==d)for(var e in d)Object.prototype.hasOwnProperty.call(d,e)&&(b[e]=d[e])}return b}}();Object.assign(ja.prototype,{addEventListener:function(a,b){void 0===this._listeners&&(this._listeners={});var c=this._listeners;void 0===c[a]&&(c[a]=[]);-1===c[a].indexOf(b)&&c[a].push(b)},hasEventListener:function(a,b){if(void 0===this._listeners)return!1;
var c=this._listeners;return void 0!==c[a]&&-1!==c[a].indexOf(b)},removeEventListener:function(a,b){void 0!==this._listeners&&(a=this._listeners[a],void 0!==a&&(b=a.indexOf(b),-1!==b&&a.splice(b,1)))},dispatchEvent:function(a){if(void 0!==this._listeners){var b=this._listeners[a.type];if(void 0!==b){a.target=this;for(var b=b.slice(0),c=0,d=b.length;c<d;c++)b[c].call(this,a)}}}});var R={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){var a="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
b=0,c;return function(){for(var d="",e=0;36>e;e++)8===e||13===e||18===e||23===e?d+="-":14===e?d+="4":(2>=b&&(b=33554432+16777216*Math.random()|0),c=b&15,b>>=4,d+=a[19===e?c&3|8:c]);return d}}(),clamp:function(a,b,c){return Math.max(b,Math.min(c,a))},euclideanModulo:function(a,b){return(a%b+b)%b},mapLinear:function(a,b,c,d,e){return d+(a-b)*(e-d)/(c-b)},lerp:function(a,b,c){return(1-c)*a+c*b},smoothstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*(3-2*a)},smootherstep:function(a,
b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*a*(a*(6*a-15)+10)},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(.5-Math.random())},degToRad:function(a){return a*R.DEG2RAD},radToDeg:function(a){return a*R.RAD2DEG},isPowerOfTwo:function(a){return 0===(a&a-1)&&0!==a},ceilPowerOfTwo:function(a){return Math.pow(2,Math.ceil(Math.log(a)/Math.LN2))},floorPowerOfTwo:function(a){return Math.pow(2,
Math.floor(Math.log(a)/Math.LN2))}};Object.defineProperties(C.prototype,{width:{get:function(){return this.x},set:function(a){this.x=a}},height:{get:function(){return this.y},set:function(a){this.y=a}}});Object.assign(C.prototype,{isVector2:!0,set:function(a,b){this.x=a;this.y=b;return this},setScalar:function(a){this.y=this.x=a;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;
default:throw Error("index is out of range: "+a);}return this},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;default:throw Error("index is out of range: "+a);}},clone:function(){return new this.constructor(this.x,this.y)},copy:function(a){this.x=a.x;this.y=a.y;return this},add:function(a,b){if(void 0!==b)return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;return this},
addScalar:function(a){this.x+=a;this.y+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this},addScaledVector:function(a,b){this.x+=a.x*b;this.y+=a.y*b;return this},sub:function(a,b){if(void 0!==b)return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;return this},subScalar:function(a){this.x-=a;this.y-=a;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;
return this},multiply:function(a){this.x*=a.x;this.y*=a.y;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;return this},divide:function(a){this.x/=a.x;this.y/=a.y;return this},divideScalar:function(a){return this.multiplyScalar(1/a)},applyMatrix3:function(a){var b=this.x,c=this.y;a=a.elements;this.x=a[0]*b+a[3]*c+a[6];this.y=a[1]*b+a[4]*c+a[7];return this},min:function(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,a.y);return this},max:function(a){this.x=Math.max(this.x,a.x);this.y=
Math.max(this.y,a.y);return this},clamp:function(a,b){this.x=Math.max(a.x,Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));return this},clampScalar:function(){var a=new C,b=new C;return function(c,d){a.set(c,c);b.set(d,d);return this.clamp(a,b)}}(),clampLength:function(a,b){var c=this.length();return this.divideScalar(c||1).multiplyScalar(Math.max(a,Math.min(b,c)))},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this},ceil:function(){this.x=Math.ceil(this.x);
this.y=Math.ceil(this.y);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);return this},negate:function(){this.x=-this.x;this.y=-this.y;return this},dot:function(a){return this.x*a.x+this.y*a.y},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},manhattanLength:function(){return Math.abs(this.x)+
Math.abs(this.y)},normalize:function(){return this.divideScalar(this.length()||1)},angle:function(){var a=Math.atan2(this.y,this.x);0>a&&(a+=2*Math.PI);return a},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x;a=this.y-a.y;return b*b+a*a},manhattanDistanceTo:function(a){return Math.abs(this.x-a.x)+Math.abs(this.y-a.y)},setLength:function(a){return this.normalize().multiplyScalar(a)},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=
(a.y-this.y)*b;return this},lerpVectors:function(a,b,c){return this.subVectors(b,a).multiplyScalar(c).add(a)},equals:function(a){return a.x===this.x&&a.y===this.y},fromArray:function(a,b){void 0===b&&(b=0);this.x=a[b];this.y=a[b+1];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.x;a[b+1]=this.y;return a},fromBufferAttribute:function(a,b,c){void 0!==c&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");this.x=a.getX(b);this.y=a.getY(b);
return this},rotateAround:function(a,b){var c=Math.cos(b);b=Math.sin(b);var d=this.x-a.x,e=this.y-a.y;this.x=d*c-e*b+a.x;this.y=d*b+e*c+a.y;return this}});Object.assign(K.prototype,{isMatrix4:!0,set:function(a,b,c,d,e,f,g,h,k,l,q,n,t,m,p,v){var r=this.elements;r[0]=a;r[4]=b;r[8]=c;r[12]=d;r[1]=e;r[5]=f;r[9]=g;r[13]=h;r[2]=k;r[6]=l;r[10]=q;r[14]=n;r[3]=t;r[7]=m;r[11]=p;r[15]=v;return this},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this},clone:function(){return(new K).fromArray(this.elements)},
copy:function(a){var b=this.elements;a=a.elements;b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return this},copyPosition:function(a){var b=this.elements;a=a.elements;b[12]=a[12];b[13]=a[13];b[14]=a[14];return this},extractBasis:function(a,b,c){a.setFromMatrixColumn(this,0);b.setFromMatrixColumn(this,1);c.setFromMatrixColumn(this,2);return this},makeBasis:function(a,b,c){this.set(a.x,
b.x,c.x,0,a.y,b.y,c.y,0,a.z,b.z,c.z,0,0,0,0,1);return this},extractRotation:function(){var a=new p;return function(b){var c=this.elements,d=b.elements,e=1/a.setFromMatrixColumn(b,0).length(),f=1/a.setFromMatrixColumn(b,1).length();b=1/a.setFromMatrixColumn(b,2).length();c[0]=d[0]*e;c[1]=d[1]*e;c[2]=d[2]*e;c[4]=d[4]*f;c[5]=d[5]*f;c[6]=d[6]*f;c[8]=d[8]*b;c[9]=d[9]*b;c[10]=d[10]*b;return this}}(),makeRotationFromEuler:function(a){a&&a.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
var b=this.elements,c=a.x,d=a.y,e=a.z,f=Math.cos(c),c=Math.sin(c),g=Math.cos(d),d=Math.sin(d),h=Math.cos(e),e=Math.sin(e);if("XYZ"===a.order){var k=f*h;var l=f*e;var q=c*h;a=c*e;b[0]=g*h;b[4]=-g*e;b[8]=d;b[1]=l+q*d;b[5]=k-a*d;b[9]=-c*g;b[2]=a-k*d;b[6]=q+l*d;b[10]=f*g}else"YXZ"===a.order?(k=g*h,l=g*e,q=d*h,a=d*e,b[0]=k+a*c,b[4]=q*c-l,b[8]=f*d,b[1]=f*e,b[5]=f*h,b[9]=-c,b[2]=l*c-q,b[6]=a+k*c,b[10]=f*g):"ZXY"===a.order?(k=g*h,l=g*e,q=d*h,a=d*e,b[0]=k-a*c,b[4]=-f*e,b[8]=q+l*c,b[1]=l+q*c,b[5]=f*h,b[9]=
a-k*c,b[2]=-f*d,b[6]=c,b[10]=f*g):"ZYX"===a.order?(k=f*h,l=f*e,q=c*h,a=c*e,b[0]=g*h,b[4]=q*d-l,b[8]=k*d+a,b[1]=g*e,b[5]=a*d+k,b[9]=l*d-q,b[2]=-d,b[6]=c*g,b[10]=f*g):"YZX"===a.order?(k=f*g,l=f*d,q=c*g,a=c*d,b[0]=g*h,b[4]=a-k*e,b[8]=q*e+l,b[1]=e,b[5]=f*h,b[9]=-c*h,b[2]=-d*h,b[6]=l*e+q,b[10]=k-a*e):"XZY"===a.order&&(k=f*g,l=f*d,q=c*g,a=c*d,b[0]=g*h,b[4]=-e,b[8]=d*h,b[1]=k*e+a,b[5]=f*h,b[9]=l*e-q,b[2]=q*e-l,b[6]=c*h,b[10]=a*e+k);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},makeRotationFromQuaternion:function(a){var b=
this.elements,c=a._x,d=a._y,e=a._z,f=a._w,g=c+c,h=d+d,k=e+e;a=c*g;var l=c*h,c=c*k,q=d*h,d=d*k,e=e*k,g=f*g,h=f*h,f=f*k;b[0]=1-(q+e);b[4]=l-f;b[8]=c+h;b[1]=l+f;b[5]=1-(a+e);b[9]=d-g;b[2]=c-h;b[6]=d+g;b[10]=1-(a+q);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},lookAt:function(){var a=new p,b=new p,c=new p;return function(d,e,f){var g=this.elements;c.subVectors(d,e);0===c.lengthSq()&&(c.z=1);c.normalize();a.crossVectors(f,c);0===a.lengthSq()&&(1===Math.abs(f.z)?c.x+=1E-4:c.z+=1E-4,
c.normalize(),a.crossVectors(f,c));a.normalize();b.crossVectors(c,a);g[0]=a.x;g[4]=b.x;g[8]=c.x;g[1]=a.y;g[5]=b.y;g[9]=c.y;g[2]=a.z;g[6]=b.z;g[10]=c.z;return this}}(),multiply:function(a,b){return void 0!==b?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(a,b)):this.multiplyMatrices(this,a)},premultiply:function(a){return this.multiplyMatrices(a,this)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements;
b=this.elements;a=c[0];var e=c[4],f=c[8],g=c[12],h=c[1],k=c[5],l=c[9],q=c[13],n=c[2],m=c[6],r=c[10],p=c[14],v=c[3],w=c[7],x=c[11],c=c[15],z=d[0],I=d[4],B=d[8],J=d[12],y=d[1],C=d[5],A=d[9],D=d[13],E=d[2],H=d[6],L=d[10],Y=d[14],N=d[3],M=d[7],V=d[11],d=d[15];b[0]=a*z+e*y+f*E+g*N;b[4]=a*I+e*C+f*H+g*M;b[8]=a*B+e*A+f*L+g*V;b[12]=a*J+e*D+f*Y+g*d;b[1]=h*z+k*y+l*E+q*N;b[5]=h*I+k*C+l*H+q*M;b[9]=h*B+k*A+l*L+q*V;b[13]=h*J+k*D+l*Y+q*d;b[2]=n*z+m*y+r*E+p*N;b[6]=n*I+m*C+r*H+p*M;b[10]=n*B+m*A+r*L+p*V;b[14]=n*J+m*
D+r*Y+p*d;b[3]=v*z+w*y+x*E+c*N;b[7]=v*I+w*C+x*H+c*M;b[11]=v*B+w*A+x*L+c*V;b[15]=v*J+w*D+x*Y+c*d;return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[4]*=a;b[8]*=a;b[12]*=a;b[1]*=a;b[5]*=a;b[9]*=a;b[13]*=a;b[2]*=a;b[6]*=a;b[10]*=a;b[14]*=a;b[3]*=a;b[7]*=a;b[11]*=a;b[15]*=a;return this},applyToBufferAttribute:function(){var a=new p;return function(b){for(var c=0,d=b.count;c<d;c++)a.x=b.getX(c),a.y=b.getY(c),a.z=b.getZ(c),a.applyMatrix4(this),b.setXYZ(c,a.x,a.y,a.z);return b}}(),determinant:function(){var a=
this.elements,b=a[0],c=a[4],d=a[8],e=a[12],f=a[1],g=a[5],h=a[9],k=a[13],l=a[2],q=a[6],n=a[10],m=a[14];return a[3]*(+e*h*q-d*k*q-e*g*n+c*k*n+d*g*m-c*h*m)+a[7]*(+b*h*m-b*k*n+e*f*n-d*f*m+d*k*l-e*h*l)+a[11]*(+b*k*q-b*g*m-e*f*q+c*f*m+e*g*l-c*k*l)+a[15]*(-d*g*l-b*h*q+b*g*n+d*f*q-c*f*n+c*h*l)},transpose:function(){var a=this.elements;var b=a[1];a[1]=a[4];a[4]=b;b=a[2];a[2]=a[8];a[8]=b;b=a[6];a[6]=a[9];a[9]=b;b=a[3];a[3]=a[12];a[12]=b;b=a[7];a[7]=a[13];a[13]=b;b=a[11];a[11]=a[14];a[14]=b;return this},setPosition:function(a){var b=
this.elements;b[12]=a.x;b[13]=a.y;b[14]=a.z;return this},getInverse:function(a,b){var c=this.elements,d=a.elements;a=d[0];var e=d[1],f=d[2],g=d[3],h=d[4],k=d[5],l=d[6],q=d[7],n=d[8],m=d[9],r=d[10],p=d[11],v=d[12],w=d[13],x=d[14],d=d[15],z=m*x*q-w*r*q+w*l*p-k*x*p-m*l*d+k*r*d,I=v*r*q-n*x*q-v*l*p+h*x*p+n*l*d-h*r*d,B=n*w*q-v*m*q+v*k*p-h*w*p-n*k*d+h*m*d,J=v*m*l-n*w*l-v*k*r+h*w*r+n*k*x-h*m*x,y=a*z+e*I+f*B+g*J;if(0===y){if(!0===b)throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");return this.identity()}b=1/y;c[0]=z*b;c[1]=(w*r*g-m*x*g-w*f*p+e*x*p+m*f*d-e*r*d)*b;c[2]=(k*x*g-w*l*g+w*f*q-e*x*q-k*f*d+e*l*d)*b;c[3]=(m*l*g-k*r*g-m*f*q+e*r*q+k*f*p-e*l*p)*b;c[4]=I*b;c[5]=(n*x*g-v*r*g+v*f*p-a*x*p-n*f*d+a*r*d)*b;c[6]=(v*l*g-h*x*g-v*f*q+a*x*q+h*f*d-a*l*d)*b;c[7]=(h*r*g-n*l*g+n*f*q-a*r*q-h*f*p+a*l*p)*b;c[8]=B*b;c[9]=(v*m*g-n*w*g-v*e*p+a*w*p+n*e*d-a*m*d)*b;c[10]=(h*w*g-v*k*g+v*e*q-a*w*q-h*e*d+a*k*d)*b;c[11]=
(n*k*g-h*m*g-n*e*q+a*m*q+h*e*p-a*k*p)*b;c[12]=J*b;c[13]=(n*w*f-v*m*f+v*e*r-a*w*r-n*e*x+a*m*x)*b;c[14]=(v*k*f-h*w*f-v*e*l+a*w*l+h*e*x-a*k*x)*b;c[15]=(h*m*f-n*k*f+n*e*l-a*m*l-h*e*r+a*k*r)*b;return this},scale:function(a){var b=this.elements,c=a.x,d=a.y;a=a.z;b[0]*=c;b[4]*=d;b[8]*=a;b[1]*=c;b[5]*=d;b[9]*=a;b[2]*=c;b[6]*=d;b[10]*=a;b[3]*=c;b[7]*=d;b[11]*=a;return this},getMaxScaleOnAxis:function(){var a=this.elements;return Math.sqrt(Math.max(a[0]*a[0]+a[1]*a[1]+a[2]*a[2],a[4]*a[4]+a[5]*a[5]+a[6]*a[6],
a[8]*a[8]+a[9]*a[9]+a[10]*a[10]))},makeTranslation:function(a,b,c){this.set(1,0,0,a,0,1,0,b,0,0,1,c,0,0,0,1);return this},makeRotationX:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(1,0,0,0,0,b,-a,0,0,a,b,0,0,0,0,1);return this},makeRotationY:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(b,0,a,0,0,1,0,0,-a,0,b,0,0,0,0,1);return this},makeRotationZ:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(b,-a,0,0,a,b,0,0,0,0,1,0,0,0,0,1);return this},makeRotationAxis:function(a,b){var c=
Math.cos(b);b=Math.sin(b);var d=1-c,e=a.x,f=a.y;a=a.z;var g=d*e,h=d*f;this.set(g*e+c,g*f-b*a,g*a+b*f,0,g*f+b*a,h*f+c,h*a-b*e,0,g*a-b*f,h*a+b*e,d*a*a+c,0,0,0,0,1);return this},makeScale:function(a,b,c){this.set(a,0,0,0,0,b,0,0,0,0,c,0,0,0,0,1);return this},makeShear:function(a,b,c){this.set(1,b,c,0,a,1,c,0,a,b,1,0,0,0,0,1);return this},compose:function(a,b,c){this.makeRotationFromQuaternion(b);this.scale(c);this.setPosition(a);return this},decompose:function(){var a=new p,b=new K;return function(c,
d,e){var f=this.elements,g=a.set(f[0],f[1],f[2]).length(),h=a.set(f[4],f[5],f[6]).length(),k=a.set(f[8],f[9],f[10]).length();0>this.determinant()&&(g=-g);c.x=f[12];c.y=f[13];c.z=f[14];b.copy(this);c=1/g;var f=1/h,l=1/k;b.elements[0]*=c;b.elements[1]*=c;b.elements[2]*=c;b.elements[4]*=f;b.elements[5]*=f;b.elements[6]*=f;b.elements[8]*=l;b.elements[9]*=l;b.elements[10]*=l;d.setFromRotationMatrix(b);e.x=g;e.y=h;e.z=k;return this}}(),makePerspective:function(a,b,c,d,e,f){void 0===f&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
var g=this.elements;g[0]=2*e/(b-a);g[4]=0;g[8]=(b+a)/(b-a);g[12]=0;g[1]=0;g[5]=2*e/(c-d);g[9]=(c+d)/(c-d);g[13]=0;g[2]=0;g[6]=0;g[10]=-(f+e)/(f-e);g[14]=-2*f*e/(f-e);g[3]=0;g[7]=0;g[11]=-1;g[15]=0;return this},makeOrthographic:function(a,b,c,d,e,f){var g=this.elements,h=1/(b-a),k=1/(c-d),l=1/(f-e);g[0]=2*h;g[4]=0;g[8]=0;g[12]=-((b+a)*h);g[1]=0;g[5]=2*k;g[9]=0;g[13]=-((c+d)*k);g[2]=0;g[6]=0;g[10]=-2*l;g[14]=-((f+e)*l);g[3]=0;g[7]=0;g[11]=0;g[15]=1;return this},equals:function(a){var b=this.elements;
a=a.elements;for(var c=0;16>c;c++)if(b[c]!==a[c])return!1;return!0},fromArray:function(a,b){void 0===b&&(b=0);for(var c=0;16>c;c++)this.elements[c]=a[c+b];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);var c=this.elements;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];a[b+9]=c[9];a[b+10]=c[10];a[b+11]=c[11];a[b+12]=c[12];a[b+13]=c[13];a[b+14]=c[14];a[b+15]=c[15];return a}});Object.assign(Z,{slerp:function(a,b,c,d){return c.copy(a).slerp(b,
d)},slerpFlat:function(a,b,c,d,e,f,g){var h=c[d+0],k=c[d+1],l=c[d+2];c=c[d+3];d=e[f+0];var q=e[f+1],n=e[f+2];e=e[f+3];if(c!==e||h!==d||k!==q||l!==n){f=1-g;var m=h*d+k*q+l*n+c*e,r=0<=m?1:-1,p=1-m*m;p>Number.EPSILON&&(p=Math.sqrt(p),m=Math.atan2(p,m*r),f=Math.sin(f*m)/p,g=Math.sin(g*m)/p);r*=g;h=h*f+d*r;k=k*f+q*r;l=l*f+n*r;c=c*f+e*r;f===1-g&&(g=1/Math.sqrt(h*h+k*k+l*l+c*c),h*=g,k*=g,l*=g,c*=g)}a[b]=h;a[b+1]=k;a[b+2]=l;a[b+3]=c}});Object.defineProperties(Z.prototype,{x:{get:function(){return this._x},
set:function(a){this._x=a;this.onChangeCallback()}},y:{get:function(){return this._y},set:function(a){this._y=a;this.onChangeCallback()}},z:{get:function(){return this._z},set:function(a){this._z=a;this.onChangeCallback()}},w:{get:function(){return this._w},set:function(a){this._w=a;this.onChangeCallback()}}});Object.assign(Z.prototype,{set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._w=d;this.onChangeCallback();return this},clone:function(){return new this.constructor(this._x,this._y,this._z,
this._w)},copy:function(a){this._x=a.x;this._y=a.y;this._z=a.z;this._w=a.w;this.onChangeCallback();return this},setFromEuler:function(a,b){if(!a||!a.isEuler)throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");var c=a._x,d=a._y,e=a._z;a=a.order;var f=Math.cos,g=Math.sin,h=f(c/2),k=f(d/2),f=f(e/2),c=g(c/2),d=g(d/2),e=g(e/2);"XYZ"===a?(this._x=c*k*f+h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f-c*d*e):"YXZ"===a?(this._x=c*k*f+
h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f+c*d*e):"ZXY"===a?(this._x=c*k*f-h*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f-c*d*e):"ZYX"===a?(this._x=c*k*f-h*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f+c*d*e):"YZX"===a?(this._x=c*k*f+h*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f-c*d*e):"XZY"===a&&(this._x=c*k*f-h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f+c*d*e);if(!1!==b)this.onChangeCallback();return this},setFromAxisAngle:function(a,
b){b/=2;var c=Math.sin(b);this._x=a.x*c;this._y=a.y*c;this._z=a.z*c;this._w=Math.cos(b);this.onChangeCallback();return this},setFromRotationMatrix:function(a){var b=a.elements,c=b[0];a=b[4];var d=b[8],e=b[1],f=b[5],g=b[9],h=b[2],k=b[6],b=b[10],l=c+f+b;0<l?(c=.5/Math.sqrt(l+1),this._w=.25/c,this._x=(k-g)*c,this._y=(d-h)*c,this._z=(e-a)*c):c>f&&c>b?(c=2*Math.sqrt(1+c-f-b),this._w=(k-g)/c,this._x=.25*c,this._y=(a+e)/c,this._z=(d+h)/c):f>b?(c=2*Math.sqrt(1+f-c-b),this._w=(d-h)/c,this._x=(a+e)/c,this._y=
.25*c,this._z=(g+k)/c):(c=2*Math.sqrt(1+b-c-f),this._w=(e-a)/c,this._x=(d+h)/c,this._y=(g+k)/c,this._z=.25*c);this.onChangeCallback();return this},setFromUnitVectors:function(){var a=new p,b;return function(c,d){void 0===a&&(a=new p);b=c.dot(d)+1;1E-6>b?(b=0,Math.abs(c.x)>Math.abs(c.z)?a.set(-c.y,c.x,0):a.set(0,-c.z,c.y)):a.crossVectors(c,d);this._x=a.x;this._y=a.y;this._z=a.z;this._w=b;return this.normalize()}}(),inverse:function(){return this.conjugate().normalize()},conjugate:function(){this._x*=
-1;this._y*=-1;this._z*=-1;this.onChangeCallback();return this},dot:function(a){return this._x*a._x+this._y*a._y+this._z*a._z+this._w*a._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var a=this.length();0===a?(this._z=this._y=this._x=0,this._w=1):(a=1/a,this._x*=a,this._y*=a,this._z*=a,this._w*=a);this.onChangeCallback();return this},
multiply:function(a,b){return void 0!==b?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(a,b)):this.multiplyQuaternions(this,a)},premultiply:function(a){return this.multiplyQuaternions(a,this)},multiplyQuaternions:function(a,b){var c=a._x,d=a._y,e=a._z;a=a._w;var f=b._x,g=b._y,h=b._z;b=b._w;this._x=c*b+a*f+d*h-e*g;this._y=d*b+a*g+e*f-c*h;this._z=e*b+a*h+c*g-d*f;this._w=a*b-c*f-d*g-e*h;this.onChangeCallback();
return this},slerp:function(a,b){if(0===b)return this;if(1===b)return this.copy(a);var c=this._x,d=this._y,e=this._z,f=this._w,g=f*a._w+c*a._x+d*a._y+e*a._z;0>g?(this._w=-a._w,this._x=-a._x,this._y=-a._y,this._z=-a._z,g=-g):this.copy(a);if(1<=g)return this._w=f,this._x=c,this._y=d,this._z=e,this;a=Math.sqrt(1-g*g);if(.001>Math.abs(a))return this._w=.5*(f+this._w),this._x=.5*(c+this._x),this._y=.5*(d+this._y),this._z=.5*(e+this._z),this;var h=Math.atan2(a,g),g=Math.sin((1-b)*h)/a;b=Math.sin(b*h)/a;
this._w=f*g+this._w*b;this._x=c*g+this._x*b;this._y=d*g+this._y*b;this._z=e*g+this._z*b;this.onChangeCallback();return this},equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._w===this._w},fromArray:function(a,b){void 0===b&&(b=0);this._x=a[b];this._y=a[b+1];this._z=a[b+2];this._w=a[b+3];this.onChangeCallback();return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this._x;a[b+1]=this._y;a[b+2]=this._z;a[b+3]=this._w;return a},onChange:function(a){this.onChangeCallback=
a;return this},onChangeCallback:function(){}});Object.assign(p.prototype,{isVector3:!0,set:function(a,b,c){this.x=a;this.y=b;this.z=c;return this},setScalar:function(a){this.z=this.y=this.x=a;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;default:throw Error("index is out of range: "+a);}return this},getComponent:function(a){switch(a){case 0:return this.x;
case 1:return this.y;case 2:return this.z;default:throw Error("index is out of range: "+a);}},clone:function(){return new this.constructor(this.x,this.y,this.z)},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;return this},add:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;return this},
addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this},addScaledVector:function(a,b){this.x+=a.x*b;this.y+=a.y*b;this.z+=a.z*b;return this},sub:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;return this},subScalar:function(a){this.x-=a;this.y-=a;this.z-=a;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=
a.z-b.z;return this},multiply:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(a,b);this.x*=a.x;this.y*=a.y;this.z*=a.z;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;return this},multiplyVectors:function(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this},applyEuler:function(){var a=new Z;return function(b){b&&b.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
return this.applyQuaternion(a.setFromEuler(b))}}(),applyAxisAngle:function(){var a=new Z;return function(b,c){return this.applyQuaternion(a.setFromAxisAngle(b,c))}}(),applyMatrix3:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[3]*c+a[6]*d;this.y=a[1]*b+a[4]*c+a[7]*d;this.z=a[2]*b+a[5]*c+a[8]*d;return this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;var e=1/(a[3]*b+a[7]*c+a[11]*d+a[15]);this.x=(a[0]*b+a[4]*c+a[8]*d+a[12])*e;this.y=(a[1]*b+a[5]*c+a[9]*
d+a[13])*e;this.z=(a[2]*b+a[6]*c+a[10]*d+a[14])*e;return this},applyQuaternion:function(a){var b=this.x,c=this.y,d=this.z,e=a.x,f=a.y,g=a.z;a=a.w;var h=a*b+f*d-g*c,k=a*c+g*b-e*d,l=a*d+e*c-f*b,b=-e*b-f*c-g*d;this.x=h*a+b*-e+k*-g-l*-f;this.y=k*a+b*-f+l*-e-h*-g;this.z=l*a+b*-g+h*-f-k*-e;return this},project:function(){var a=new K;return function(b){a.multiplyMatrices(b.projectionMatrix,a.getInverse(b.matrixWorld));return this.applyMatrix4(a)}}(),unproject:function(){var a=new K;return function(b){a.multiplyMatrices(b.matrixWorld,
a.getInverse(b.projectionMatrix));return this.applyMatrix4(a)}}(),transformDirection:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d;this.y=a[1]*b+a[5]*c+a[9]*d;this.z=a[2]*b+a[6]*c+a[10]*d;return this.normalize()},divide:function(a){this.x/=a.x;this.y/=a.y;this.z/=a.z;return this},divideScalar:function(a){return this.multiplyScalar(1/a)},min:function(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,a.y);this.z=Math.min(this.z,a.z);return this},max:function(a){this.x=
Math.max(this.x,a.x);this.y=Math.max(this.y,a.y);this.z=Math.max(this.z,a.z);return this},clamp:function(a,b){this.x=Math.max(a.x,Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));this.z=Math.max(a.z,Math.min(b.z,this.z));return this},clampScalar:function(){var a=new p,b=new p;return function(c,d){a.set(c,c,c);b.set(d,d,d);return this.clamp(a,b)}}(),clampLength:function(a,b){var c=this.length();return this.divideScalar(c||1).multiplyScalar(Math.max(a,Math.min(b,c)))},floor:function(){this.x=
Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z);return this},negate:function(){this.x=
-this.x;this.y=-this.y;this.z=-this.z;return this},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(a){return this.normalize().multiplyScalar(a)},lerp:function(a,b){this.x+=(a.x-
this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;return this},lerpVectors:function(a,b,c){return this.subVectors(b,a).multiplyScalar(c).add(a)},cross:function(a,b){return void 0!==b?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(a,b)):this.crossVectors(this,a)},crossVectors:function(a,b){var c=a.x,d=a.y;a=a.z;var e=b.x,f=b.y;b=b.z;this.x=d*b-a*f;this.y=a*e-c*b;this.z=c*f-d*e;return this},projectOnVector:function(a){var b=
a.dot(this)/a.lengthSq();return this.copy(a).multiplyScalar(b)},projectOnPlane:function(){var a=new p;return function(b){a.copy(this).projectOnVector(b);return this.sub(a)}}(),reflect:function(){var a=new p;return function(b){return this.sub(a.copy(b).multiplyScalar(2*this.dot(b)))}}(),angleTo:function(a){a=this.dot(a)/Math.sqrt(this.lengthSq()*a.lengthSq());return Math.acos(R.clamp(a,-1,1))},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-
a.x,c=this.y-a.y;a=this.z-a.z;return b*b+c*c+a*a},manhattanDistanceTo:function(a){return Math.abs(this.x-a.x)+Math.abs(this.y-a.y)+Math.abs(this.z-a.z)},setFromSpherical:function(a){var b=Math.sin(a.phi)*a.radius;this.x=b*Math.sin(a.theta);this.y=Math.cos(a.phi)*a.radius;this.z=b*Math.cos(a.theta);return this},setFromCylindrical:function(a){this.x=a.radius*Math.sin(a.theta);this.y=a.y;this.z=a.radius*Math.cos(a.theta);return this},setFromMatrixPosition:function(a){a=a.elements;this.x=a[12];this.y=
a[13];this.z=a[14];return this},setFromMatrixScale:function(a){var b=this.setFromMatrixColumn(a,0).length(),c=this.setFromMatrixColumn(a,1).length();a=this.setFromMatrixColumn(a,2).length();this.x=b;this.y=c;this.z=a;return this},setFromMatrixColumn:function(a,b){return this.fromArray(a.elements,4*b)},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z},fromArray:function(a,b){void 0===b&&(b=0);this.x=a[b];this.y=a[b+1];this.z=a[b+2];return this},toArray:function(a,b){void 0===a&&(a=
[]);void 0===b&&(b=0);a[b]=this.x;a[b+1]=this.y;a[b+2]=this.z;return a},fromBufferAttribute:function(a,b,c){void 0!==c&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");this.x=a.getX(b);this.y=a.getY(b);this.z=a.getZ(b);return this}});Object.assign(ra.prototype,{isMatrix3:!0,set:function(a,b,c,d,e,f,g,h,k){var l=this.elements;l[0]=a;l[1]=d;l[2]=g;l[3]=b;l[4]=e;l[5]=h;l[6]=c;l[7]=f;l[8]=k;return this},identity:function(){this.set(1,0,0,0,1,0,0,0,1);return this},clone:function(){return(new this.constructor).fromArray(this.elements)},
copy:function(a){var b=this.elements;a=a.elements;b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];return this},setFromMatrix4:function(a){a=a.elements;this.set(a[0],a[4],a[8],a[1],a[5],a[9],a[2],a[6],a[10]);return this},applyToBufferAttribute:function(){var a=new p;return function(b){for(var c=0,d=b.count;c<d;c++)a.x=b.getX(c),a.y=b.getY(c),a.z=b.getZ(c),a.applyMatrix3(this),b.setXYZ(c,a.x,a.y,a.z);return b}}(),multiply:function(a){return this.multiplyMatrices(this,
a)},premultiply:function(a){return this.multiplyMatrices(a,this)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements;b=this.elements;a=c[0];var e=c[3],f=c[6],g=c[1],h=c[4],k=c[7],l=c[2],q=c[5],c=c[8],n=d[0],m=d[3],r=d[6],p=d[1],v=d[4],w=d[7],x=d[2],z=d[5],d=d[8];b[0]=a*n+e*p+f*x;b[3]=a*m+e*v+f*z;b[6]=a*r+e*w+f*d;b[1]=g*n+h*p+k*x;b[4]=g*m+h*v+k*z;b[7]=g*r+h*w+k*d;b[2]=l*n+q*p+c*x;b[5]=l*m+q*v+c*z;b[8]=l*r+q*w+c*d;return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[3]*=a;
b[6]*=a;b[1]*=a;b[4]*=a;b[7]*=a;b[2]*=a;b[5]*=a;b[8]*=a;return this},determinant:function(){var a=this.elements,b=a[0],c=a[1],d=a[2],e=a[3],f=a[4],g=a[5],h=a[6],k=a[7],a=a[8];return b*f*a-b*g*k-c*e*a+c*g*h+d*e*k-d*f*h},getInverse:function(a,b){a&&a.isMatrix4&&console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");var c=a.elements;a=this.elements;var d=c[0],e=c[1],f=c[2],g=c[3],h=c[4],k=c[5],l=c[6],q=c[7],c=c[8],n=c*h-k*q,m=k*l-c*g,r=q*g-h*l,p=d*n+e*m+f*r;if(0===p){if(!0===
b)throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");return this.identity()}b=1/p;a[0]=n*b;a[1]=(f*q-c*e)*b;a[2]=(k*e-f*h)*b;a[3]=m*b;a[4]=(c*d-f*l)*b;a[5]=(f*g-k*d)*b;a[6]=r*b;a[7]=(e*l-q*d)*b;a[8]=(h*d-e*g)*b;return this},transpose:function(){var a=this.elements;var b=a[1];a[1]=a[3];a[3]=b;b=a[2];a[2]=a[6];a[6]=b;b=a[5];a[5]=a[7];a[7]=b;return this},getNormalMatrix:function(a){return this.setFromMatrix4(a).getInverse(this).transpose()},
transposeIntoArray:function(a){var b=this.elements;a[0]=b[0];a[1]=b[3];a[2]=b[6];a[3]=b[1];a[4]=b[4];a[5]=b[7];a[6]=b[2];a[7]=b[5];a[8]=b[8];return this},setUvTransform:function(a,b,c,d,e,f,g){var h=Math.cos(e);e=Math.sin(e);this.set(c*h,c*e,-c*(h*f+e*g)+f+a,-d*e,d*h,-d*(-e*f+h*g)+g+b,0,0,1)},scale:function(a,b){var c=this.elements;c[0]*=a;c[3]*=a;c[6]*=a;c[1]*=b;c[4]*=b;c[7]*=b;return this},rotate:function(a){var b=Math.cos(a);a=Math.sin(a);var c=this.elements,d=c[0],e=c[3],f=c[6],g=c[1],h=c[4],
k=c[7];c[0]=b*d+a*g;c[3]=b*e+a*h;c[6]=b*f+a*k;c[1]=-a*d+b*g;c[4]=-a*e+b*h;c[7]=-a*f+b*k;return this},translate:function(a,b){var c=this.elements;c[0]+=a*c[2];c[3]+=a*c[5];c[6]+=a*c[8];c[1]+=b*c[2];c[4]+=b*c[5];c[7]+=b*c[8];return this},equals:function(a){var b=this.elements;a=a.elements;for(var c=0;9>c;c++)if(b[c]!==a[c])return!1;return!0},fromArray:function(a,b){void 0===b&&(b=0);for(var c=0;9>c;c++)this.elements[c]=a[c+b];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);var c=
this.elements;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];return a}});var kf=0;ea.DEFAULT_IMAGE=void 0;ea.DEFAULT_MAPPING=300;Object.defineProperty(ea.prototype,"needsUpdate",{set:function(a){!0===a&&this.version++}});Object.assign(ea.prototype,ja.prototype,{constructor:ea,isTexture:!0,clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.name=a.name;this.image=a.image;this.mipmaps=a.mipmaps.slice(0);this.mapping=
a.mapping;this.wrapS=a.wrapS;this.wrapT=a.wrapT;this.magFilter=a.magFilter;this.minFilter=a.minFilter;this.anisotropy=a.anisotropy;this.format=a.format;this.type=a.type;this.offset.copy(a.offset);this.repeat.copy(a.repeat);this.center.copy(a.center);this.rotation=a.rotation;this.matrixAutoUpdate=a.matrixAutoUpdate;this.matrix.copy(a.matrix);this.generateMipmaps=a.generateMipmaps;this.premultiplyAlpha=a.premultiplyAlpha;this.flipY=a.flipY;this.unpackAlignment=a.unpackAlignment;this.encoding=a.encoding;
return this},toJSON:function(a){var b=void 0===a||"string"===typeof a;if(!b&&void 0!==a.textures[this.uuid])return a.textures[this.uuid];var c={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY};
if(void 0!==this.image){var d=this.image;void 0===d.uuid&&(d.uuid=R.generateUUID());if(!b&&void 0===a.images[d.uuid]){var e=a.images,f=d.uuid,g=d.uuid;if(d instanceof HTMLCanvasElement)var h=d;else{h=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");h.width=d.width;h.height=d.height;var k=h.getContext("2d");d instanceof ImageData?k.putImageData(d,0,0):k.drawImage(d,0,0,d.width,d.height)}h=2048<h.width||2048<h.height?h.toDataURL("image/jpeg",.6):h.toDataURL("image/png");e[f]={uuid:g,
url:h}}c.image=d.uuid}b||(a.textures[this.uuid]=c);return c},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(a){if(300===this.mapping){a.applyMatrix3(this.matrix);if(0>a.x||1<a.x)switch(this.wrapS){case 1E3:a.x-=Math.floor(a.x);break;case 1001:a.x=0>a.x?0:1;break;case 1002:a.x=1===Math.abs(Math.floor(a.x)%2)?Math.ceil(a.x)-a.x:a.x-Math.floor(a.x)}if(0>a.y||1<a.y)switch(this.wrapT){case 1E3:a.y-=Math.floor(a.y);break;case 1001:a.y=0>a.y?0:1;break;case 1002:a.y=1===Math.abs(Math.floor(a.y)%
2)?Math.ceil(a.y)-a.y:a.y-Math.floor(a.y)}this.flipY&&(a.y=1-a.y)}}});Object.assign(da.prototype,{isVector4:!0,set:function(a,b,c,d){this.x=a;this.y=b;this.z=c;this.w=d;return this},setScalar:function(a){this.w=this.z=this.y=this.x=a;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setW:function(a){this.w=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;
case 3:this.w=b;break;default:throw Error("index is out of range: "+a);}return this},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error("index is out of range: "+a);}},clone:function(){return new this.constructor(this.x,this.y,this.z,this.w)},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;this.w=void 0!==a.w?a.w:1;return this},add:function(a,b){if(void 0!==b)return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;this.w+=a.w;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;this.w+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this},addScaledVector:function(a,b){this.x+=a.x*b;this.y+=a.y*b;this.z+=a.z*b;this.w+=a.w*b;return this},sub:function(a,b){if(void 0!==b)return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,
b);this.x-=a.x;this.y-=a.y;this.z-=a.z;this.w-=a.w;return this},subScalar:function(a){this.x-=a;this.y-=a;this.z-=a;this.w-=a;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;this.w*=a;return this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z,e=this.w;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12]*e;this.y=a[1]*b+a[5]*c+a[9]*d+a[13]*e;this.z=a[2]*b+a[6]*c+a[10]*d+a[14]*
e;this.w=a[3]*b+a[7]*c+a[11]*d+a[15]*e;return this},divideScalar:function(a){return this.multiplyScalar(1/a)},setAxisAngleFromQuaternion:function(a){this.w=2*Math.acos(a.w);var b=Math.sqrt(1-a.w*a.w);1E-4>b?(this.x=1,this.z=this.y=0):(this.x=a.x/b,this.y=a.y/b,this.z=a.z/b);return this},setAxisAngleFromRotationMatrix:function(a){a=a.elements;var b=a[0];var c=a[4];var d=a[8],e=a[1],f=a[5],g=a[9];var h=a[2];var k=a[6];var l=a[10];if(.01>Math.abs(c-e)&&.01>Math.abs(d-h)&&.01>Math.abs(g-k)){if(.1>Math.abs(c+
e)&&.1>Math.abs(d+h)&&.1>Math.abs(g+k)&&.1>Math.abs(b+f+l-3))return this.set(1,0,0,0),this;a=Math.PI;b=(b+1)/2;f=(f+1)/2;l=(l+1)/2;c=(c+e)/4;d=(d+h)/4;g=(g+k)/4;b>f&&b>l?.01>b?(k=0,c=h=.707106781):(k=Math.sqrt(b),h=c/k,c=d/k):f>l?.01>f?(k=.707106781,h=0,c=.707106781):(h=Math.sqrt(f),k=c/h,c=g/h):.01>l?(h=k=.707106781,c=0):(c=Math.sqrt(l),k=d/c,h=g/c);this.set(k,h,c,a);return this}a=Math.sqrt((k-g)*(k-g)+(d-h)*(d-h)+(e-c)*(e-c));.001>Math.abs(a)&&(a=1);this.x=(k-g)/a;this.y=(d-h)/a;this.z=(e-c)/a;
this.w=Math.acos((b+f+l-1)/2);return this},min:function(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,a.y);this.z=Math.min(this.z,a.z);this.w=Math.min(this.w,a.w);return this},max:function(a){this.x=Math.max(this.x,a.x);this.y=Math.max(this.y,a.y);this.z=Math.max(this.z,a.z);this.w=Math.max(this.w,a.w);return this},clamp:function(a,b){this.x=Math.max(a.x,Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));this.z=Math.max(a.z,Math.min(b.z,this.z));this.w=Math.max(a.w,Math.min(b.w,
this.w));return this},clampScalar:function(){var a,b;return function(c,d){void 0===a&&(a=new da,b=new da);a.set(c,c,c,c);b.set(d,d,d,d);return this.clamp(a,b)}}(),clampLength:function(a,b){var c=this.length();return this.divideScalar(c||1).multiplyScalar(Math.max(a,Math.min(b,c)))},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);
this.w=Math.ceil(this.w);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z);this.w=0>this.w?Math.ceil(this.w):Math.floor(this.w);return this},negate:function(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this},
dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z+this.w*a.w},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(a){return this.normalize().multiplyScalar(a)},lerp:function(a,b){this.x+=
(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;this.w+=(a.w-this.w)*b;return this},lerpVectors:function(a,b,c){return this.subVectors(b,a).multiplyScalar(c).add(a)},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z&&a.w===this.w},fromArray:function(a,b){void 0===b&&(b=0);this.x=a[b];this.y=a[b+1];this.z=a[b+2];this.w=a[b+3];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.x;a[b+1]=this.y;a[b+2]=this.z;a[b+3]=this.w;return a},fromBufferAttribute:function(a,
b,c){void 0!==c&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");this.x=a.getX(b);this.y=a.getY(b);this.z=a.getZ(b);this.w=a.getW(b);return this}});Object.assign(Hb.prototype,ja.prototype,{isWebGLRenderTarget:!0,setSize:function(a,b){if(this.width!==a||this.height!==b)this.width=a,this.height=b,this.dispose();this.viewport.set(0,0,a,b);this.scissor.set(0,0,a,b)},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.width=a.width;this.height=
a.height;this.viewport.copy(a.viewport);this.texture=a.texture.clone();this.depthBuffer=a.depthBuffer;this.stencilBuffer=a.stencilBuffer;this.depthTexture=a.depthTexture;return this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Ib.prototype=Object.create(Hb.prototype);Ib.prototype.constructor=Ib;Ib.prototype.isWebGLRenderTargetCube=!0;fb.prototype=Object.create(ea.prototype);fb.prototype.constructor=fb;fb.prototype.isDataTexture=!0;Ua.prototype=Object.create(ea.prototype);Ua.prototype.constructor=
Ua;Ua.prototype.isCubeTexture=!0;Object.defineProperty(Ua.prototype,"images",{get:function(){return this.image},set:function(a){this.image=a}});var Be=new ea,Ce=new Ua,we=[],ye=[],Ae=new Float32Array(16),ze=new Float32Array(9);Ge.prototype.setValue=function(a,b){for(var c=this.seq,d=0,e=c.length;d!==e;++d){var f=c[d];f.setValue(a,b[f.id])}};var Od=/([\w\d_]+)(\])?(\[|\.)?/g;gb.prototype.setValue=function(a,b,c){b=this.map[b];void 0!==b&&b.setValue(a,c,this.renderer)};gb.prototype.setOptional=function(a,
b,c){b=b[c];void 0!==b&&this.setValue(a,c,b)};gb.upload=function(a,b,c,d){for(var e=0,f=b.length;e!==f;++e){var g=b[e],h=c[g.id];!1!==h.needsUpdate&&g.setValue(a,h.value,d)}};gb.seqWithValue=function(a,b){for(var c=[],d=0,e=a.length;d!==e;++d){var f=a[d];f.id in b&&c.push(f)}return c};var sg={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,
cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,
deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,
lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,
mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,
royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};Object.assign(H.prototype,{isColor:!0,r:1,g:1,b:1,set:function(a){a&&
a.isColor?this.copy(a):"number"===typeof a?this.setHex(a):"string"===typeof a&&this.setStyle(a);return this},setScalar:function(a){this.b=this.g=this.r=a;return this},setHex:function(a){a=Math.floor(a);this.r=(a>>16&255)/255;this.g=(a>>8&255)/255;this.b=(a&255)/255;return this},setRGB:function(a,b,c){this.r=a;this.g=b;this.b=c;return this},setHSL:function(){function a(a,c,d){0>d&&(d+=1);1<d&&--d;return d<1/6?a+6*(c-a)*d:.5>d?c:d<2/3?a+6*(c-a)*(2/3-d):a}return function(b,c,d){b=R.euclideanModulo(b,
1);c=R.clamp(c,0,1);d=R.clamp(d,0,1);0===c?this.r=this.g=this.b=d:(c=.5>=d?d*(1+c):d+c-d*c,d=2*d-c,this.r=a(d,c,b+1/3),this.g=a(d,c,b),this.b=a(d,c,b-1/3));return this}}(),setStyle:function(a){function b(b){void 0!==b&&1>parseFloat(b)&&console.warn("THREE.Color: Alpha component of "+a+" will be ignored.")}var c;if(c=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)){var d=c[2];switch(c[1]){case "rgb":case "rgba":if(c=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d))return this.r=Math.min(255,
parseInt(c[1],10))/255,this.g=Math.min(255,parseInt(c[2],10))/255,this.b=Math.min(255,parseInt(c[3],10))/255,b(c[5]),this;if(c=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d))return this.r=Math.min(100,parseInt(c[1],10))/100,this.g=Math.min(100,parseInt(c[2],10))/100,this.b=Math.min(100,parseInt(c[3],10))/100,b(c[5]),this;break;case "hsl":case "hsla":if(c=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)){var d=parseFloat(c[1])/360,
e=parseInt(c[2],10)/100,f=parseInt(c[3],10)/100;b(c[5]);return this.setHSL(d,e,f)}}}else if(c=/^\#([A-Fa-f0-9]+)$/.exec(a)){c=c[1];d=c.length;if(3===d)return this.r=parseInt(c.charAt(0)+c.charAt(0),16)/255,this.g=parseInt(c.charAt(1)+c.charAt(1),16)/255,this.b=parseInt(c.charAt(2)+c.charAt(2),16)/255,this;if(6===d)return this.r=parseInt(c.charAt(0)+c.charAt(1),16)/255,this.g=parseInt(c.charAt(2)+c.charAt(3),16)/255,this.b=parseInt(c.charAt(4)+c.charAt(5),16)/255,this}a&&0<a.length&&(c=sg[a],void 0!==
c?this.setHex(c):console.warn("THREE.Color: Unknown color "+a));return this},clone:function(){return new this.constructor(this.r,this.g,this.b)},copy:function(a){this.r=a.r;this.g=a.g;this.b=a.b;return this},copyGammaToLinear:function(a,b){void 0===b&&(b=2);this.r=Math.pow(a.r,b);this.g=Math.pow(a.g,b);this.b=Math.pow(a.b,b);return this},copyLinearToGamma:function(a,b){void 0===b&&(b=2);b=0<b?1/b:1;this.r=Math.pow(a.r,b);this.g=Math.pow(a.g,b);this.b=Math.pow(a.b,b);return this},convertGammaToLinear:function(){var a=
this.r,b=this.g,c=this.b;this.r=a*a;this.g=b*b;this.b=c*c;return this},convertLinearToGamma:function(){this.r=Math.sqrt(this.r);this.g=Math.sqrt(this.g);this.b=Math.sqrt(this.b);return this},getHex:function(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0},getHexString:function(){return("000000"+this.getHex().toString(16)).slice(-6)},getHSL:function(a){a=a||{h:0,s:0,l:0};var b=this.r,c=this.g,d=this.b,e=Math.max(b,c,d),f=Math.min(b,c,d),g,h=(f+e)/2;if(f===e)f=g=0;else{var k=e-f,f=.5>=h?k/(e+f):
k/(2-e-f);switch(e){case b:g=(c-d)/k+(c<d?6:0);break;case c:g=(d-b)/k+2;break;case d:g=(b-c)/k+4}g/=6}a.h=g;a.s=f;a.l=h;return a},getStyle:function(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"},offsetHSL:function(a,b,c){var d=this.getHSL();d.h+=a;d.s+=b;d.l+=c;this.setHSL(d.h,d.s,d.l);return this},add:function(a){this.r+=a.r;this.g+=a.g;this.b+=a.b;return this},addColors:function(a,b){this.r=a.r+b.r;this.g=a.g+b.g;this.b=a.b+b.b;return this},addScalar:function(a){this.r+=
a;this.g+=a;this.b+=a;return this},sub:function(a){this.r=Math.max(0,this.r-a.r);this.g=Math.max(0,this.g-a.g);this.b=Math.max(0,this.b-a.b);return this},multiply:function(a){this.r*=a.r;this.g*=a.g;this.b*=a.b;return this},multiplyScalar:function(a){this.r*=a;this.g*=a;this.b*=a;return this},lerp:function(a,b){this.r+=(a.r-this.r)*b;this.g+=(a.g-this.g)*b;this.b+=(a.b-this.b)*b;return this},equals:function(a){return a.r===this.r&&a.g===this.g&&a.b===this.b},fromArray:function(a,b){void 0===b&&(b=
0);this.r=a[b];this.g=a[b+1];this.b=a[b+2];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.r;a[b+1]=this.g;a[b+2]=this.b;return a},toJSON:function(){return this.getHex()}});var E={common:{diffuse:{value:new H(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new ra},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},
aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new C(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:2.5E-4},fogNear:{value:1},
fogFar:{value:2E3},fogColor:{value:new H(16777215)}},lights:{ambientLightColor:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},
pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new H(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},uvTransform:{value:new ra}}},
Ea={merge:function(a){for(var b={},c=0;c<a.length;c++){var d=this.clone(a[c]),e;for(e in d)b[e]=d[e]}return b},clone:function(a){var b={},c;for(c in a){b[c]={};for(var d in a[c]){var e=a[c][d];e&&(e.isColor||e.isMatrix3||e.isMatrix4||e.isVector2||e.isVector3||e.isVector4||e.isTexture)?b[c][d]=e.clone():Array.isArray(e)?b[c][d]=e.slice():b[c][d]=e}}return b}},W={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"\nvec3 transformed = vec3( position );\n",beginnormal_vertex:"\nvec3 objectNormal = vec3( normal );\n",bsdfs:"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",color_pars_vertex:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",color_vertex:"#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",common:"#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
defaultnormal_vertex:"vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",encodings_fragment:"  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
envmap_fragment:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
envmap_pars_fragment:"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",envmap_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
fog_vertex:"\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
gradientmap_pars_fragment:"#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
lights_pars:"uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
lights_template:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",map_particle_fragment:"#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",map_particle_pars_fragment:"#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
normal_fragment:"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",project_vertex:"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",dithering_fragment:"#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",dithering_pars_fragment:"#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",tonemapping_pars_fragment:"#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
uv_pars_fragment:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
uv_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
cube_vert:"varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",equirect_vert:"varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
meshphysical_frag:"#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
meshphysical_vert:"#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",shadow_vert:"#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n"},
mb={basic:{uniforms:Ea.merge([E.common,E.specularmap,E.envmap,E.aomap,E.lightmap,E.fog]),vertexShader:W.meshbasic_vert,fragmentShader:W.meshbasic_frag},lambert:{uniforms:Ea.merge([E.common,E.specularmap,E.envmap,E.aomap,E.lightmap,E.emissivemap,E.fog,E.lights,{emissive:{value:new H(0)}}]),vertexShader:W.meshlambert_vert,fragmentShader:W.meshlambert_frag},phong:{uniforms:Ea.merge([E.common,E.specularmap,E.envmap,E.aomap,E.lightmap,E.emissivemap,E.bumpmap,E.normalmap,E.displacementmap,E.gradientmap,
E.fog,E.lights,{emissive:{value:new H(0)},specular:{value:new H(1118481)},shininess:{value:30}}]),vertexShader:W.meshphong_vert,fragmentShader:W.meshphong_frag},standard:{uniforms:Ea.merge([E.common,E.envmap,E.aomap,E.lightmap,E.emissivemap,E.bumpmap,E.normalmap,E.displacementmap,E.roughnessmap,E.metalnessmap,E.fog,E.lights,{emissive:{value:new H(0)},roughness:{value:.5},metalness:{value:.5},envMapIntensity:{value:1}}]),vertexShader:W.meshphysical_vert,fragmentShader:W.meshphysical_frag},points:{uniforms:Ea.merge([E.points,
E.fog]),vertexShader:W.points_vert,fragmentShader:W.points_frag},dashed:{uniforms:Ea.merge([E.common,E.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:W.linedashed_vert,fragmentShader:W.linedashed_frag},depth:{uniforms:Ea.merge([E.common,E.displacementmap]),vertexShader:W.depth_vert,fragmentShader:W.depth_frag},normal:{uniforms:Ea.merge([E.common,E.bumpmap,E.normalmap,E.displacementmap,{opacity:{value:1}}]),vertexShader:W.normal_vert,fragmentShader:W.normal_frag},cube:{uniforms:{tCube:{value:null},
tFlip:{value:-1},opacity:{value:1}},vertexShader:W.cube_vert,fragmentShader:W.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:W.equirect_vert,fragmentShader:W.equirect_frag},distanceRGBA:{uniforms:Ea.merge([E.common,E.displacementmap,{referencePosition:{value:new p},nearDistance:{value:1},farDistance:{value:1E3}}]),vertexShader:W.distanceRGBA_vert,fragmentShader:W.distanceRGBA_frag},shadow:{uniforms:Ea.merge([E.lights,E.fog,{color:{value:new H(0)},opacity:{value:1}}]),vertexShader:W.shadow_vert,
fragmentShader:W.shadow_frag}};mb.physical={uniforms:Ea.merge([mb.standard.uniforms,{clearCoat:{value:0},clearCoatRoughness:{value:0}}]),vertexShader:W.meshphysical_vert,fragmentShader:W.meshphysical_frag};Object.assign(kd.prototype,{set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromPoints:function(a){this.makeEmpty();for(var b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this},setFromCenterAndSize:function(){var a=new C;return function(b,c){c=a.copy(c).multiplyScalar(.5);
this.min.copy(b).sub(c);this.max.copy(b).add(c);return this}}(),clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.min.copy(a.min);this.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=Infinity;this.max.x=this.max.y=-Infinity;return this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},getCenter:function(a){a=a||new C;return this.isEmpty()?a.set(0,0):a.addVectors(this.min,this.max).multiplyScalar(.5)},getSize:function(a){a=
a||new C;return this.isEmpty()?a.set(0,0):a.subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=
this.max.y},getParameter:function(a,b){return(b||new C).set((a.x-this.min.x)/(this.max.x-this.min.x),(a.y-this.min.y)/(this.max.y-this.min.y))},intersectsBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y?!1:!0},clampPoint:function(a,b){return(b||new C).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new C;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),intersect:function(a){this.min.max(a.min);
this.max.min(a.max);return this},union:function(a){this.min.min(a.min);this.max.max(a.max);return this},translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)}});tc.prototype=Object.create(ea.prototype);tc.prototype.constructor=tc;var Lf=0;Object.assign(Q.prototype,ja.prototype,{isMaterial:!0,onBeforeCompile:function(){},setValues:function(a){if(void 0!==a)for(var b in a){var c=a[b];if(void 0===c)console.warn("THREE.Material: '"+
b+"' parameter is undefined.");else if("shading"===b)console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===c?!0:!1;else{var d=this[b];void 0===d?console.warn("THREE."+this.type+": '"+b+"' is not a property of this material."):d&&d.isColor?d.set(c):d&&d.isVector3&&c&&c.isVector3?d.copy(c):this[b]="overdraw"===b?Number(c):c}}},toJSON:function(a){function b(a){var b=[],c;for(c in a){var d=a[c];delete d.metadata;b.push(d)}return b}var c=
void 0===a||"string"===typeof a;c&&(a={textures:{},images:{}});var d={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};d.uuid=this.uuid;d.type=this.type;""!==this.name&&(d.name=this.name);this.color&&this.color.isColor&&(d.color=this.color.getHex());void 0!==this.roughness&&(d.roughness=this.roughness);void 0!==this.metalness&&(d.metalness=this.metalness);this.emissive&&this.emissive.isColor&&(d.emissive=this.emissive.getHex());1!==this.emissiveIntensity&&(d.emissiveIntensity=this.emissiveIntensity);
this.specular&&this.specular.isColor&&(d.specular=this.specular.getHex());void 0!==this.shininess&&(d.shininess=this.shininess);void 0!==this.clearCoat&&(d.clearCoat=this.clearCoat);void 0!==this.clearCoatRoughness&&(d.clearCoatRoughness=this.clearCoatRoughness);this.map&&this.map.isTexture&&(d.map=this.map.toJSON(a).uuid);this.alphaMap&&this.alphaMap.isTexture&&(d.alphaMap=this.alphaMap.toJSON(a).uuid);this.lightMap&&this.lightMap.isTexture&&(d.lightMap=this.lightMap.toJSON(a).uuid);this.bumpMap&&
this.bumpMap.isTexture&&(d.bumpMap=this.bumpMap.toJSON(a).uuid,d.bumpScale=this.bumpScale);this.normalMap&&this.normalMap.isTexture&&(d.normalMap=this.normalMap.toJSON(a).uuid,d.normalScale=this.normalScale.toArray());this.displacementMap&&this.displacementMap.isTexture&&(d.displacementMap=this.displacementMap.toJSON(a).uuid,d.displacementScale=this.displacementScale,d.displacementBias=this.displacementBias);this.roughnessMap&&this.roughnessMap.isTexture&&(d.roughnessMap=this.roughnessMap.toJSON(a).uuid);
this.metalnessMap&&this.metalnessMap.isTexture&&(d.metalnessMap=this.metalnessMap.toJSON(a).uuid);this.emissiveMap&&this.emissiveMap.isTexture&&(d.emissiveMap=this.emissiveMap.toJSON(a).uuid);this.specularMap&&this.specularMap.isTexture&&(d.specularMap=this.specularMap.toJSON(a).uuid);this.envMap&&this.envMap.isTexture&&(d.envMap=this.envMap.toJSON(a).uuid,d.reflectivity=this.reflectivity);this.gradientMap&&this.gradientMap.isTexture&&(d.gradientMap=this.gradientMap.toJSON(a).uuid);void 0!==this.size&&
(d.size=this.size);void 0!==this.sizeAttenuation&&(d.sizeAttenuation=this.sizeAttenuation);1!==this.blending&&(d.blending=this.blending);!0===this.flatShading&&(d.flatShading=this.flatShading);0!==this.side&&(d.side=this.side);0!==this.vertexColors&&(d.vertexColors=this.vertexColors);1>this.opacity&&(d.opacity=this.opacity);!0===this.transparent&&(d.transparent=this.transparent);d.depthFunc=this.depthFunc;d.depthTest=this.depthTest;d.depthWrite=this.depthWrite;0!==this.rotation&&(d.rotation=this.rotation);
1!==this.linewidth&&(d.linewidth=this.linewidth);void 0!==this.dashSize&&(d.dashSize=this.dashSize);void 0!==this.gapSize&&(d.gapSize=this.gapSize);void 0!==this.scale&&(d.scale=this.scale);!0===this.dithering&&(d.dithering=!0);0<this.alphaTest&&(d.alphaTest=this.alphaTest);!0===this.premultipliedAlpha&&(d.premultipliedAlpha=this.premultipliedAlpha);!0===this.wireframe&&(d.wireframe=this.wireframe);1<this.wireframeLinewidth&&(d.wireframeLinewidth=this.wireframeLinewidth);"round"!==this.wireframeLinecap&&
(d.wireframeLinecap=this.wireframeLinecap);"round"!==this.wireframeLinejoin&&(d.wireframeLinejoin=this.wireframeLinejoin);!0===this.morphTargets&&(d.morphTargets=!0);!0===this.skinning&&(d.skinning=!0);!1===this.visible&&(d.visible=!1);"{}"!==JSON.stringify(this.userData)&&(d.userData=this.userData);c&&(c=b(a.textures),a=b(a.images),0<c.length&&(d.textures=c),0<a.length&&(d.images=a));return d},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.name=a.name;this.fog=a.fog;
this.lights=a.lights;this.blending=a.blending;this.side=a.side;this.flatShading=a.flatShading;this.vertexColors=a.vertexColors;this.opacity=a.opacity;this.transparent=a.transparent;this.blendSrc=a.blendSrc;this.blendDst=a.blendDst;this.blendEquation=a.blendEquation;this.blendSrcAlpha=a.blendSrcAlpha;this.blendDstAlpha=a.blendDstAlpha;this.blendEquationAlpha=a.blendEquationAlpha;this.depthFunc=a.depthFunc;this.depthTest=a.depthTest;this.depthWrite=a.depthWrite;this.colorWrite=a.colorWrite;this.precision=
a.precision;this.polygonOffset=a.polygonOffset;this.polygonOffsetFactor=a.polygonOffsetFactor;this.polygonOffsetUnits=a.polygonOffsetUnits;this.dithering=a.dithering;this.alphaTest=a.alphaTest;this.premultipliedAlpha=a.premultipliedAlpha;this.overdraw=a.overdraw;this.visible=a.visible;this.userData=JSON.parse(JSON.stringify(a.userData));this.clipShadows=a.clipShadows;this.clipIntersection=a.clipIntersection;a=a.clippingPlanes;var b=null;if(null!==a)for(var c=a.length,b=Array(c),d=0;d!==c;++d)b[d]=
a[d].clone();this.clippingPlanes=b;return this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Wa.prototype=Object.create(Q.prototype);Wa.prototype.constructor=Wa;Wa.prototype.isMeshDepthMaterial=!0;Wa.prototype.copy=function(a){Q.prototype.copy.call(this,a);this.depthPacking=a.depthPacking;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.map=a.map;this.alphaMap=a.alphaMap;this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=
a.displacementBias;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;return this};Xa.prototype=Object.create(Q.prototype);Xa.prototype.constructor=Xa;Xa.prototype.isMeshDistanceMaterial=!0;Xa.prototype.copy=function(a){Q.prototype.copy.call(this,a);this.referencePosition.copy(a.referencePosition);this.nearDistance=a.nearDistance;this.farDistance=a.farDistance;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.map=a.map;this.alphaMap=a.alphaMap;this.displacementMap=
a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;return this};Object.assign(Oa.prototype,{isBox3:!0,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromArray:function(a){for(var b=Infinity,c=Infinity,d=Infinity,e=-Infinity,f=-Infinity,g=-Infinity,h=0,k=a.length;h<k;h+=3){var l=a[h],q=a[h+1],n=a[h+2];l<b&&(b=l);q<c&&(c=q);n<d&&(d=n);l>e&&(e=l);q>f&&(f=q);n>g&&(g=n)}this.min.set(b,c,d);this.max.set(e,f,g);return this},setFromBufferAttribute:function(a){for(var b=
Infinity,c=Infinity,d=Infinity,e=-Infinity,f=-Infinity,g=-Infinity,h=0,k=a.count;h<k;h++){var l=a.getX(h),q=a.getY(h),n=a.getZ(h);l<b&&(b=l);q<c&&(c=q);n<d&&(d=n);l>e&&(e=l);q>f&&(f=q);n>g&&(g=n)}this.min.set(b,c,d);this.max.set(e,f,g);return this},setFromPoints:function(a){this.makeEmpty();for(var b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this},setFromCenterAndSize:function(){var a=new p;return function(b,c){c=a.copy(c).multiplyScalar(.5);this.min.copy(b).sub(c);this.max.copy(b).add(c);
return this}}(),setFromObject:function(a){this.makeEmpty();return this.expandByObject(a)},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.min.copy(a.min);this.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=this.min.z=Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},getCenter:function(a){a=a||new p;return this.isEmpty()?a.set(0,0,0):
a.addVectors(this.min,this.max).multiplyScalar(.5)},getSize:function(a){a=a||new p;return this.isEmpty()?a.set(0,0,0):a.subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},expandByObject:function(){function a(a){var f=a.geometry;if(void 0!==f)if(f.isGeometry)for(f=f.vertices,c=0,d=f.length;c<d;c++)e.copy(f[c]),
e.applyMatrix4(a.matrixWorld),b.expandByPoint(e);else if(f.isBufferGeometry&&(f=f.attributes.position,void 0!==f))for(c=0,d=f.count;c<d;c++)e.fromBufferAttribute(f,c).applyMatrix4(a.matrixWorld),b.expandByPoint(e)}var b,c,d,e=new p;return function(c){b=this;c.updateMatrixWorld(!0);c.traverse(a);return this}}(),containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y||a.z<this.min.z||a.z>this.max.z?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=
this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y&&this.min.z<=a.min.z&&a.max.z<=this.max.z},getParameter:function(a,b){return(b||new p).set((a.x-this.min.x)/(this.max.x-this.min.x),(a.y-this.min.y)/(this.max.y-this.min.y),(a.z-this.min.z)/(this.max.z-this.min.z))},intersectsBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y||a.max.z<this.min.z||a.min.z>this.max.z?!1:!0},intersectsSphere:function(){var a=new p;return function(b){this.clampPoint(b.center,
a);return a.distanceToSquared(b.center)<=b.radius*b.radius}}(),intersectsPlane:function(a){if(0<a.normal.x){var b=a.normal.x*this.min.x;var c=a.normal.x*this.max.x}else b=a.normal.x*this.max.x,c=a.normal.x*this.min.x;0<a.normal.y?(b+=a.normal.y*this.min.y,c+=a.normal.y*this.max.y):(b+=a.normal.y*this.max.y,c+=a.normal.y*this.min.y);0<a.normal.z?(b+=a.normal.z*this.min.z,c+=a.normal.z*this.max.z):(b+=a.normal.z*this.max.z,c+=a.normal.z*this.min.z);return b<=a.constant&&c>=a.constant},clampPoint:function(a,
b){return(b||new p).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new p;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),getBoundingSphere:function(){var a=new p;return function(b){b=b||new Da;this.getCenter(b.center);b.radius=.5*this.getSize(a).length();return b}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);this.isEmpty()&&this.makeEmpty();return this},union:function(a){this.min.min(a.min);this.max.max(a.max);return this},applyMatrix4:function(){var a=
[new p,new p,new p,new p,new p,new p,new p,new p];return function(b){if(this.isEmpty())return this;a[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(b);a[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(b);a[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(b);a[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(b);a[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(b);a[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(b);a[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(b);
a[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(b);this.setFromPoints(a);return this}}(),translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)}});Object.assign(Da.prototype,{set:function(a,b){this.center.copy(a);this.radius=b;return this},setFromPoints:function(){var a=new Oa;return function(b,c){var d=this.center;void 0!==c?d.copy(c):a.setFromPoints(b).getCenter(d);for(var e=c=0,f=b.length;e<f;e++)c=Math.max(c,
d.distanceToSquared(b[e]));this.radius=Math.sqrt(c);return this}}(),clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.center.copy(a.center);this.radius=a.radius;return this},empty:function(){return 0>=this.radius},containsPoint:function(a){return a.distanceToSquared(this.center)<=this.radius*this.radius},distanceToPoint:function(a){return a.distanceTo(this.center)-this.radius},intersectsSphere:function(a){var b=this.radius+a.radius;return a.center.distanceToSquared(this.center)<=
b*b},intersectsBox:function(a){return a.intersectsSphere(this)},intersectsPlane:function(a){return Math.abs(a.distanceToPoint(this.center))<=this.radius},clampPoint:function(a,b){var c=this.center.distanceToSquared(a);b=b||new p;b.copy(a);c>this.radius*this.radius&&(b.sub(this.center).normalize(),b.multiplyScalar(this.radius).add(this.center));return b},getBoundingBox:function(a){a=a||new Oa;a.set(this.center,this.center);a.expandByScalar(this.radius);return a},applyMatrix4:function(a){this.center.applyMatrix4(a);
this.radius*=a.getMaxScaleOnAxis();return this},translate:function(a){this.center.add(a);return this},equals:function(a){return a.center.equals(this.center)&&a.radius===this.radius}});Object.assign(Aa.prototype,{set:function(a,b){this.normal.copy(a);this.constant=b;return this},setComponents:function(a,b,c,d){this.normal.set(a,b,c);this.constant=d;return this},setFromNormalAndCoplanarPoint:function(a,b){this.normal.copy(a);this.constant=-b.dot(this.normal);return this},setFromCoplanarPoints:function(){var a=
new p,b=new p;return function(c,d,e){d=a.subVectors(e,d).cross(b.subVectors(c,d)).normalize();this.setFromNormalAndCoplanarPoint(d,c);return this}}(),clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.normal.copy(a.normal);this.constant=a.constant;return this},normalize:function(){var a=1/this.normal.length();this.normal.multiplyScalar(a);this.constant*=a;return this},negate:function(){this.constant*=-1;this.normal.negate();return this},distanceToPoint:function(a){return this.normal.dot(a)+
this.constant},distanceToSphere:function(a){return this.distanceToPoint(a.center)-a.radius},projectPoint:function(a,b){return(b||new p).copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a)},intersectLine:function(){var a=new p;return function(b,c){c=c||new p;var d=b.delta(a),e=this.normal.dot(d);if(0===e){if(0===this.distanceToPoint(b.start))return c.copy(b.start)}else if(e=-(b.start.dot(this.normal)+this.constant)/e,!(0>e||1<e))return c.copy(d).multiplyScalar(e).add(b.start)}}(),intersectsLine:function(a){var b=
this.distanceToPoint(a.start);a=this.distanceToPoint(a.end);return 0>b&&0<a||0>a&&0<b},intersectsBox:function(a){return a.intersectsPlane(this)},intersectsSphere:function(a){return a.intersectsPlane(this)},coplanarPoint:function(a){return(a||new p).copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(){var a=new p,b=new ra;return function(c,d){d=d||b.getNormalMatrix(c);c=this.coplanarPoint(a).applyMatrix4(c);d=this.normal.applyMatrix3(d).normalize();this.constant=-c.dot(d);return this}}(),
translate:function(a){this.constant-=a.dot(this.normal);return this},equals:function(a){return a.normal.equals(this.normal)&&a.constant===this.constant}});Object.assign(ld.prototype,{set:function(a,b,c,d,e,f){var g=this.planes;g[0].copy(a);g[1].copy(b);g[2].copy(c);g[3].copy(d);g[4].copy(e);g[5].copy(f);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){for(var b=this.planes,c=0;6>c;c++)b[c].copy(a.planes[c]);return this},setFromMatrix:function(a){var b=this.planes,
c=a.elements;a=c[0];var d=c[1],e=c[2],f=c[3],g=c[4],h=c[5],k=c[6],l=c[7],q=c[8],n=c[9],m=c[10],r=c[11],p=c[12],v=c[13],w=c[14],c=c[15];b[0].setComponents(f-a,l-g,r-q,c-p).normalize();b[1].setComponents(f+a,l+g,r+q,c+p).normalize();b[2].setComponents(f+d,l+h,r+n,c+v).normalize();b[3].setComponents(f-d,l-h,r-n,c-v).normalize();b[4].setComponents(f-e,l-k,r-m,c-w).normalize();b[5].setComponents(f+e,l+k,r+m,c+w).normalize();return this},intersectsObject:function(){var a=new Da;return function(b){var c=
b.geometry;null===c.boundingSphere&&c.computeBoundingSphere();a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld);return this.intersectsSphere(a)}}(),intersectsSprite:function(){var a=new Da;return function(b){a.center.set(0,0,0);a.radius=.7071067811865476;a.applyMatrix4(b.matrixWorld);return this.intersectsSphere(a)}}(),intersectsSphere:function(a){var b=this.planes,c=a.center;a=-a.radius;for(var d=0;6>d;d++)if(b[d].distanceToPoint(c)<a)return!1;return!0},intersectsBox:function(){var a=new p,b=
new p;return function(c){for(var d=this.planes,e=0;6>e;e++){var f=d[e];a.x=0<f.normal.x?c.min.x:c.max.x;b.x=0<f.normal.x?c.max.x:c.min.x;a.y=0<f.normal.y?c.min.y:c.max.y;b.y=0<f.normal.y?c.max.y:c.min.y;a.z=0<f.normal.z?c.min.z:c.max.z;b.z=0<f.normal.z?c.max.z:c.min.z;var g=f.distanceToPoint(a),f=f.distanceToPoint(b);if(0>g&&0>f)return!1}return!0}}(),containsPoint:function(a){for(var b=this.planes,c=0;6>c;c++)if(0>b[c].distanceToPoint(a))return!1;return!0}});Ya.RotationOrders="XYZ YZX ZXY XZY YXZ ZYX".split(" ");
Ya.DefaultOrder="XYZ";Object.defineProperties(Ya.prototype,{x:{get:function(){return this._x},set:function(a){this._x=a;this.onChangeCallback()}},y:{get:function(){return this._y},set:function(a){this._y=a;this.onChangeCallback()}},z:{get:function(){return this._z},set:function(a){this._z=a;this.onChangeCallback()}},order:{get:function(){return this._order},set:function(a){this._order=a;this.onChangeCallback()}}});Object.assign(Ya.prototype,{isEuler:!0,set:function(a,b,c,d){this._x=a;this._y=b;this._z=
c;this._order=d||this._order;this.onChangeCallback();return this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._order)},copy:function(a){this._x=a._x;this._y=a._y;this._z=a._z;this._order=a._order;this.onChangeCallback();return this},setFromRotationMatrix:function(a,b,c){var d=R.clamp,e=a.elements;a=e[0];var f=e[4],g=e[8],h=e[1],k=e[5],l=e[9],q=e[2],n=e[6],e=e[10];b=b||this._order;"XYZ"===b?(this._y=Math.asin(d(g,-1,1)),.99999>Math.abs(g)?(this._x=Math.atan2(-l,e),this._z=
Math.atan2(-f,a)):(this._x=Math.atan2(n,k),this._z=0)):"YXZ"===b?(this._x=Math.asin(-d(l,-1,1)),.99999>Math.abs(l)?(this._y=Math.atan2(g,e),this._z=Math.atan2(h,k)):(this._y=Math.atan2(-q,a),this._z=0)):"ZXY"===b?(this._x=Math.asin(d(n,-1,1)),.99999>Math.abs(n)?(this._y=Math.atan2(-q,e),this._z=Math.atan2(-f,k)):(this._y=0,this._z=Math.atan2(h,a))):"ZYX"===b?(this._y=Math.asin(-d(q,-1,1)),.99999>Math.abs(q)?(this._x=Math.atan2(n,e),this._z=Math.atan2(h,a)):(this._x=0,this._z=Math.atan2(-f,k))):"YZX"===
b?(this._z=Math.asin(d(h,-1,1)),.99999>Math.abs(h)?(this._x=Math.atan2(-l,k),this._y=Math.atan2(-q,a)):(this._x=0,this._y=Math.atan2(g,e))):"XZY"===b?(this._z=Math.asin(-d(f,-1,1)),.99999>Math.abs(f)?(this._x=Math.atan2(n,k),this._y=Math.atan2(g,a)):(this._x=Math.atan2(-l,e),this._y=0)):console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: "+b);this._order=b;if(!1!==c)this.onChangeCallback();return this},setFromQuaternion:function(){var a=new K;return function(b,c,d){a.makeRotationFromQuaternion(b);
return this.setFromRotationMatrix(a,c,d)}}(),setFromVector3:function(a,b){return this.set(a.x,a.y,a.z,b||this._order)},reorder:function(){var a=new Z;return function(b){a.setFromEuler(this);return this.setFromQuaternion(a,b)}}(),equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._order===this._order},fromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];void 0!==a[3]&&(this._order=a[3]);this.onChangeCallback();return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===
b&&(b=0);a[b]=this._x;a[b+1]=this._y;a[b+2]=this._z;a[b+3]=this._order;return a},toVector3:function(a){return a?a.set(this._x,this._y,this._z):new p(this._x,this._y,this._z)},onChange:function(a){this.onChangeCallback=a;return this},onChangeCallback:function(){}});Object.assign(Pd.prototype,{set:function(a){this.mask=1<<a|0},enable:function(a){this.mask=this.mask|1<<a|0},toggle:function(a){this.mask^=1<<a|0},disable:function(a){this.mask&=~(1<<a|0)},test:function(a){return 0!==(this.mask&a.mask)}});
var Nf=0;A.DefaultUp=new p(0,1,0);A.DefaultMatrixAutoUpdate=!0;Object.assign(A.prototype,ja.prototype,{isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix:function(a){this.matrix.multiplyMatrices(a,this.matrix);this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(a){this.quaternion.premultiply(a);return this},setRotationFromAxisAngle:function(a,b){this.quaternion.setFromAxisAngle(a,b)},setRotationFromEuler:function(a){this.quaternion.setFromEuler(a,
!0)},setRotationFromMatrix:function(a){this.quaternion.setFromRotationMatrix(a)},setRotationFromQuaternion:function(a){this.quaternion.copy(a)},rotateOnAxis:function(){var a=new Z;return function(b,c){a.setFromAxisAngle(b,c);this.quaternion.multiply(a);return this}}(),rotateOnWorldAxis:function(){var a=new Z;return function(b,c){a.setFromAxisAngle(b,c);this.quaternion.premultiply(a);return this}}(),rotateX:function(){var a=new p(1,0,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateY:function(){var a=
new p(0,1,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateZ:function(){var a=new p(0,0,1);return function(b){return this.rotateOnAxis(a,b)}}(),translateOnAxis:function(){var a=new p;return function(b,c){a.copy(b).applyQuaternion(this.quaternion);this.position.add(a.multiplyScalar(c));return this}}(),translateX:function(){var a=new p(1,0,0);return function(b){return this.translateOnAxis(a,b)}}(),translateY:function(){var a=new p(0,1,0);return function(b){return this.translateOnAxis(a,
b)}}(),translateZ:function(){var a=new p(0,0,1);return function(b){return this.translateOnAxis(a,b)}}(),localToWorld:function(a){return a.applyMatrix4(this.matrixWorld)},worldToLocal:function(){var a=new K;return function(b){return b.applyMatrix4(a.getInverse(this.matrixWorld))}}(),lookAt:function(){var a=new K,b=new p;return function(c,d,e){c.isVector3?b.copy(c):b.set(c,d,e);this.isCamera?a.lookAt(this.position,b,this.up):a.lookAt(b,this.position,this.up);this.quaternion.setFromRotationMatrix(a)}}(),
add:function(a){if(1<arguments.length){for(var b=0;b<arguments.length;b++)this.add(arguments[b]);return this}if(a===this)return console.error("THREE.Object3D.add: object can't be added as a child of itself.",a),this;a&&a.isObject3D?(null!==a.parent&&a.parent.remove(a),a.parent=this,a.dispatchEvent({type:"added"}),this.children.push(a)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",a);return this},remove:function(a){if(1<arguments.length){for(var b=0;b<arguments.length;b++)this.remove(arguments[b]);
return this}b=this.children.indexOf(a);-1!==b&&(a.parent=null,a.dispatchEvent({type:"removed"}),this.children.splice(b,1));return this},getObjectById:function(a){return this.getObjectByProperty("id",a)},getObjectByName:function(a){return this.getObjectByProperty("name",a)},getObjectByProperty:function(a,b){if(this[a]===b)return this;for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c].getObjectByProperty(a,b);if(void 0!==e)return e}},getWorldPosition:function(a){a=a||new p;this.updateMatrixWorld(!0);
return a.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(){var a=new p,b=new p;return function(c){c=c||new Z;this.updateMatrixWorld(!0);this.matrixWorld.decompose(a,c,b);return c}}(),getWorldRotation:function(){var a=new Z;return function(b){b=b||new Ya;this.getWorldQuaternion(a);return b.setFromQuaternion(a,this.rotation.order,!1)}}(),getWorldScale:function(){var a=new p,b=new Z;return function(c){c=c||new p;this.updateMatrixWorld(!0);this.matrixWorld.decompose(a,b,c);return c}}(),
getWorldDirection:function(){var a=new Z;return function(b){b=b||new p;this.getWorldQuaternion(a);return b.set(0,0,1).applyQuaternion(a)}}(),raycast:function(){},traverse:function(a){a(this);for(var b=this.children,c=0,d=b.length;c<d;c++)b[c].traverse(a)},traverseVisible:function(a){if(!1!==this.visible){a(this);for(var b=this.children,c=0,d=b.length;c<d;c++)b[c].traverseVisible(a)}},traverseAncestors:function(a){var b=this.parent;null!==b&&(a(b),b.traverseAncestors(a))},updateMatrix:function(){this.matrix.compose(this.position,
this.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(a){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||a)null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,a=!0;for(var b=this.children,c=0,d=b.length;c<d;c++)b[c].updateMatrixWorld(a)},toJSON:function(a){function b(b,c){void 0===b[c.uuid]&&(b[c.uuid]=c.toJSON(a));return c.uuid}function c(a){var b=
[],c;for(c in a){var d=a[c];delete d.metadata;b.push(d)}return b}var d=void 0===a||"string"===typeof a,e={};d&&(a={geometries:{},materials:{},textures:{},images:{}},e.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});var f={};f.uuid=this.uuid;f.type=this.type;""!==this.name&&(f.name=this.name);!0===this.castShadow&&(f.castShadow=!0);!0===this.receiveShadow&&(f.receiveShadow=!0);!1===this.visible&&(f.visible=!1);"{}"!==JSON.stringify(this.userData)&&(f.userData=this.userData);f.matrix=
this.matrix.toArray();void 0!==this.geometry&&(f.geometry=b(a.geometries,this.geometry));if(void 0!==this.material)if(Array.isArray(this.material)){for(var g=[],h=0,k=this.material.length;h<k;h++)g.push(b(a.materials,this.material[h]));f.material=g}else f.material=b(a.materials,this.material);if(0<this.children.length)for(f.children=[],h=0;h<this.children.length;h++)f.children.push(this.children[h].toJSON(a).object);d&&(d=c(a.geometries),g=c(a.materials),h=c(a.textures),k=c(a.images),0<d.length&&
(e.geometries=d),0<g.length&&(e.materials=g),0<h.length&&(e.textures=h),0<k.length&&(e.images=k));e.object=f;return e},clone:function(a){return(new this.constructor).copy(this,a)},copy:function(a,b){void 0===b&&(b=!0);this.name=a.name;this.up.copy(a.up);this.position.copy(a.position);this.quaternion.copy(a.quaternion);this.scale.copy(a.scale);this.matrix.copy(a.matrix);this.matrixWorld.copy(a.matrixWorld);this.matrixAutoUpdate=a.matrixAutoUpdate;this.matrixWorldNeedsUpdate=a.matrixWorldNeedsUpdate;
this.layers.mask=a.layers.mask;this.visible=a.visible;this.castShadow=a.castShadow;this.receiveShadow=a.receiveShadow;this.frustumCulled=a.frustumCulled;this.renderOrder=a.renderOrder;this.userData=JSON.parse(JSON.stringify(a.userData));if(!0===b)for(b=0;b<a.children.length;b++)this.add(a.children[b].clone());return this}});La.prototype=Object.assign(Object.create(A.prototype),{constructor:La,isCamera:!0,copy:function(a,b){A.prototype.copy.call(this,a,b);this.matrixWorldInverse.copy(a.matrixWorldInverse);
this.projectionMatrix.copy(a.projectionMatrix);return this},getWorldDirection:function(){var a=new Z;return function(b){b=b||new p;this.getWorldQuaternion(a);return b.set(0,0,-1).applyQuaternion(a)}}(),updateMatrixWorld:function(a){A.prototype.updateMatrixWorld.call(this,a);this.matrixWorldInverse.getInverse(this.matrixWorld)},clone:function(){return(new this.constructor).copy(this)}});Kb.prototype=Object.assign(Object.create(La.prototype),{constructor:Kb,isOrthographicCamera:!0,copy:function(a,b){La.prototype.copy.call(this,
a,b);this.left=a.left;this.right=a.right;this.top=a.top;this.bottom=a.bottom;this.near=a.near;this.far=a.far;this.zoom=a.zoom;this.view=null===a.view?null:Object.assign({},a.view);return this},setViewOffset:function(a,b,c,d,e,f){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1});this.view.enabled=!0;this.view.fullWidth=a;this.view.fullHeight=b;this.view.offsetX=c;this.view.offsetY=d;this.view.width=e;this.view.height=f;this.updateProjectionMatrix()},
clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1);this.updateProjectionMatrix()},updateProjectionMatrix:function(){var a=(this.right-this.left)/(2*this.zoom),b=(this.top-this.bottom)/(2*this.zoom),c=(this.right+this.left)/2,d=(this.top+this.bottom)/2,e=c-a,c=c+a,a=d+b,b=d-b;if(null!==this.view&&this.view.enabled)var c=this.zoom/(this.view.width/this.view.fullWidth),b=this.zoom/(this.view.height/this.view.fullHeight),f=(this.right-this.left)/this.view.width,d=(this.top-this.bottom)/
this.view.height,e=e+this.view.offsetX/c*f,c=e+this.view.width/c*f,a=a-this.view.offsetY/b*d,b=a-this.view.height/b*d;this.projectionMatrix.makeOrthographic(e,c,a,b,this.near,this.far)},toJSON:function(a){a=A.prototype.toJSON.call(this,a);a.object.zoom=this.zoom;a.object.left=this.left;a.object.right=this.right;a.object.top=this.top;a.object.bottom=this.bottom;a.object.near=this.near;a.object.far=this.far;null!==this.view&&(a.object.view=Object.assign({},this.view));return a}});Object.assign(Pa.prototype,
{clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.a=a.a;this.b=a.b;this.c=a.c;this.normal.copy(a.normal);this.color.copy(a.color);this.materialIndex=a.materialIndex;for(var b=0,c=a.vertexNormals.length;b<c;b++)this.vertexNormals[b]=a.vertexNormals[b].clone();b=0;for(c=a.vertexColors.length;b<c;b++)this.vertexColors[b]=a.vertexColors[b].clone();return this}});var Of=0;Object.assign(N.prototype,ja.prototype,{isGeometry:!0,applyMatrix:function(a){for(var b=(new ra).getNormalMatrix(a),
c=0,d=this.vertices.length;c<d;c++)this.vertices[c].applyMatrix4(a);c=0;for(d=this.faces.length;c<d;c++){a=this.faces[c];a.normal.applyMatrix3(b).normalize();for(var e=0,f=a.vertexNormals.length;e<f;e++)a.vertexNormals[e].applyMatrix3(b).normalize()}null!==this.boundingBox&&this.computeBoundingBox();null!==this.boundingSphere&&this.computeBoundingSphere();this.normalsNeedUpdate=this.verticesNeedUpdate=!0;return this},rotateX:function(){var a=new K;return function(b){a.makeRotationX(b);this.applyMatrix(a);
return this}}(),rotateY:function(){var a=new K;return function(b){a.makeRotationY(b);this.applyMatrix(a);return this}}(),rotateZ:function(){var a=new K;return function(b){a.makeRotationZ(b);this.applyMatrix(a);return this}}(),translate:function(){var a=new K;return function(b,c,d){a.makeTranslation(b,c,d);this.applyMatrix(a);return this}}(),scale:function(){var a=new K;return function(b,c,d){a.makeScale(b,c,d);this.applyMatrix(a);return this}}(),lookAt:function(){var a=new A;return function(b){a.lookAt(b);
a.updateMatrix();this.applyMatrix(a.matrix)}}(),fromBufferGeometry:function(a){function b(a,b,d,e){var f=void 0!==g?[q[a].clone(),q[b].clone(),q[d].clone()]:[],t=void 0!==h?[c.colors[a].clone(),c.colors[b].clone(),c.colors[d].clone()]:[];e=new Pa(a,b,d,f,t,e);c.faces.push(e);void 0!==k&&c.faceVertexUvs[0].push([n[a].clone(),n[b].clone(),n[d].clone()]);void 0!==l&&c.faceVertexUvs[1].push([m[a].clone(),m[b].clone(),m[d].clone()])}var c=this,d=null!==a.index?a.index.array:void 0,e=a.attributes,f=e.position.array,
g=void 0!==e.normal?e.normal.array:void 0,h=void 0!==e.color?e.color.array:void 0,k=void 0!==e.uv?e.uv.array:void 0,l=void 0!==e.uv2?e.uv2.array:void 0;void 0!==l&&(this.faceVertexUvs[1]=[]);for(var q=[],n=[],m=[],r=e=0;e<f.length;e+=3,r+=2)c.vertices.push(new p(f[e],f[e+1],f[e+2])),void 0!==g&&q.push(new p(g[e],g[e+1],g[e+2])),void 0!==h&&c.colors.push(new H(h[e],h[e+1],h[e+2])),void 0!==k&&n.push(new C(k[r],k[r+1])),void 0!==l&&m.push(new C(l[r],l[r+1]));var u=a.groups;if(0<u.length)for(e=0;e<u.length;e++)for(var f=
u[e],v=f.start,w=f.count,r=v,v=v+w;r<v;r+=3)void 0!==d?b(d[r],d[r+1],d[r+2],f.materialIndex):b(r,r+1,r+2,f.materialIndex);else if(void 0!==d)for(e=0;e<d.length;e+=3)b(d[e],d[e+1],d[e+2]);else for(e=0;e<f.length/3;e+=3)b(e,e+1,e+2);this.computeFaceNormals();null!==a.boundingBox&&(this.boundingBox=a.boundingBox.clone());null!==a.boundingSphere&&(this.boundingSphere=a.boundingSphere.clone());return this},center:function(){this.computeBoundingBox();var a=this.boundingBox.getCenter().negate();this.translate(a.x,
a.y,a.z);return a},normalize:function(){this.computeBoundingSphere();var a=this.boundingSphere.center,b=this.boundingSphere.radius,b=0===b?1:1/b,c=new K;c.set(b,0,0,-b*a.x,0,b,0,-b*a.y,0,0,b,-b*a.z,0,0,0,1);this.applyMatrix(c);return this},computeFaceNormals:function(){for(var a=new p,b=new p,c=0,d=this.faces.length;c<d;c++){var e=this.faces[c],f=this.vertices[e.a],g=this.vertices[e.b];a.subVectors(this.vertices[e.c],g);b.subVectors(f,g);a.cross(b);a.normalize();e.normal.copy(a)}},computeVertexNormals:function(a){void 0===
a&&(a=!0);var b;var c=Array(this.vertices.length);var d=0;for(b=this.vertices.length;d<b;d++)c[d]=new p;if(a){var e=new p,f=new p;a=0;for(d=this.faces.length;a<d;a++){b=this.faces[a];var g=this.vertices[b.a];var h=this.vertices[b.b];var k=this.vertices[b.c];e.subVectors(k,h);f.subVectors(g,h);e.cross(f);c[b.a].add(e);c[b.b].add(e);c[b.c].add(e)}}else for(this.computeFaceNormals(),a=0,d=this.faces.length;a<d;a++)b=this.faces[a],c[b.a].add(b.normal),c[b.b].add(b.normal),c[b.c].add(b.normal);d=0;for(b=
this.vertices.length;d<b;d++)c[d].normalize();a=0;for(d=this.faces.length;a<d;a++)b=this.faces[a],g=b.vertexNormals,3===g.length?(g[0].copy(c[b.a]),g[1].copy(c[b.b]),g[2].copy(c[b.c])):(g[0]=c[b.a].clone(),g[1]=c[b.b].clone(),g[2]=c[b.c].clone());0<this.faces.length&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){var a;this.computeFaceNormals();var b=0;for(a=this.faces.length;b<a;b++){var c=this.faces[b];var d=c.vertexNormals;3===d.length?(d[0].copy(c.normal),d[1].copy(c.normal),
d[2].copy(c.normal)):(d[0]=c.normal.clone(),d[1]=c.normal.clone(),d[2]=c.normal.clone())}0<this.faces.length&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){var a,b;var c=0;for(b=this.faces.length;c<b;c++){var d=this.faces[c];d.__originalFaceNormal?d.__originalFaceNormal.copy(d.normal):d.__originalFaceNormal=d.normal.clone();d.__originalVertexNormals||(d.__originalVertexNormals=[]);var e=0;for(a=d.vertexNormals.length;e<a;e++)d.__originalVertexNormals[e]?d.__originalVertexNormals[e].copy(d.vertexNormals[e]):
d.__originalVertexNormals[e]=d.vertexNormals[e].clone()}var f=new N;f.faces=this.faces;e=0;for(a=this.morphTargets.length;e<a;e++){if(!this.morphNormals[e]){this.morphNormals[e]={};this.morphNormals[e].faceNormals=[];this.morphNormals[e].vertexNormals=[];d=this.morphNormals[e].faceNormals;var g=this.morphNormals[e].vertexNormals;c=0;for(b=this.faces.length;c<b;c++){var h=new p;var k={a:new p,b:new p,c:new p};d.push(h);g.push(k)}}g=this.morphNormals[e];f.vertices=this.morphTargets[e].vertices;f.computeFaceNormals();
f.computeVertexNormals();c=0;for(b=this.faces.length;c<b;c++)d=this.faces[c],h=g.faceNormals[c],k=g.vertexNormals[c],h.copy(d.normal),k.a.copy(d.vertexNormals[0]),k.b.copy(d.vertexNormals[1]),k.c.copy(d.vertexNormals[2])}c=0;for(b=this.faces.length;c<b;c++)d=this.faces[c],d.normal=d.__originalFaceNormal,d.vertexNormals=d.__originalVertexNormals},computeLineDistances:function(){for(var a=0,b=this.vertices,c=0,d=b.length;c<d;c++)0<c&&(a+=b[c].distanceTo(b[c-1])),this.lineDistances[c]=a},computeBoundingBox:function(){null===
this.boundingBox&&(this.boundingBox=new Oa);this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Da);this.boundingSphere.setFromPoints(this.vertices)},merge:function(a,b,c){if(a&&a.isGeometry){var d,e=this.vertices.length,f=this.vertices,g=a.vertices,h=this.faces,k=a.faces,l=this.faceVertexUvs[0],q=a.faceVertexUvs[0],n=this.colors,m=a.colors;void 0===c&&(c=0);void 0!==b&&(d=(new ra).getNormalMatrix(b));a=0;for(var r=g.length;a<
r;a++){var p=g[a].clone();void 0!==b&&p.applyMatrix4(b);f.push(p)}a=0;for(r=m.length;a<r;a++)n.push(m[a].clone());a=0;for(r=k.length;a<r;a++){var g=k[a],v=g.vertexNormals,m=g.vertexColors,n=new Pa(g.a+e,g.b+e,g.c+e);n.normal.copy(g.normal);void 0!==d&&n.normal.applyMatrix3(d).normalize();b=0;for(f=v.length;b<f;b++)p=v[b].clone(),void 0!==d&&p.applyMatrix3(d).normalize(),n.vertexNormals.push(p);n.color.copy(g.color);b=0;for(f=m.length;b<f;b++)p=m[b],n.vertexColors.push(p.clone());n.materialIndex=g.materialIndex+
c;h.push(n)}a=0;for(r=q.length;a<r;a++)if(c=q[a],d=[],void 0!==c){b=0;for(f=c.length;b<f;b++)d.push(c[b].clone());l.push(d)}}else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",a)},mergeMesh:function(a){a&&a.isMesh?(a.matrixAutoUpdate&&a.updateMatrix(),this.merge(a.geometry,a.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",a)},mergeVertices:function(){var a={},b=[],c=[],d=Math.pow(10,4),e;var f=0;for(e=this.vertices.length;f<
e;f++){var g=this.vertices[f];g=Math.round(g.x*d)+"_"+Math.round(g.y*d)+"_"+Math.round(g.z*d);void 0===a[g]?(a[g]=f,b.push(this.vertices[f]),c[f]=b.length-1):c[f]=c[a[g]]}a=[];f=0;for(e=this.faces.length;f<e;f++)for(d=this.faces[f],d.a=c[d.a],d.b=c[d.b],d.c=c[d.c],d=[d.a,d.b,d.c],g=0;3>g;g++)if(d[g]===d[(g+1)%3]){a.push(f);break}for(f=a.length-1;0<=f;f--)for(d=a[f],this.faces.splice(d,1),c=0,e=this.faceVertexUvs.length;c<e;c++)this.faceVertexUvs[c].splice(d,1);f=this.vertices.length-b.length;this.vertices=
b;return f},setFromPoints:function(a){this.vertices=[];for(var b=0,c=a.length;b<c;b++){var d=a[b];this.vertices.push(new p(d.x,d.y,d.z||0))}return this},sortFacesByMaterialIndex:function(){for(var a=this.faces,b=a.length,c=0;c<b;c++)a[c]._id=c;a.sort(function(a,b){return a.materialIndex-b.materialIndex});var d=this.faceVertexUvs[0],e=this.faceVertexUvs[1],f,g;d&&d.length===b&&(f=[]);e&&e.length===b&&(g=[]);for(c=0;c<b;c++){var h=a[c]._id;f&&f.push(d[h]);g&&g.push(e[h])}f&&(this.faceVertexUvs[0]=f);
g&&(this.faceVertexUvs[1]=g)},toJSON:function(){function a(a,b,c){return c?a|1<<b:a&~(1<<b)}function b(a){var b=a.x.toString()+a.y.toString()+a.z.toString();if(void 0!==l[b])return l[b];l[b]=k.length/3;k.push(a.x,a.y,a.z);return l[b]}function c(a){var b=a.r.toString()+a.g.toString()+a.b.toString();if(void 0!==n[b])return n[b];n[b]=q.length;q.push(a.getHex());return n[b]}function d(a){var b=a.x.toString()+a.y.toString();if(void 0!==p[b])return p[b];p[b]=m.length/2;m.push(a.x,a.y);return p[b]}var e=
{metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};e.uuid=this.uuid;e.type=this.type;""!==this.name&&(e.name=this.name);if(void 0!==this.parameters){var f=this.parameters,g;for(g in f)void 0!==f[g]&&(e[g]=f[g]);return e}f=[];for(g=0;g<this.vertices.length;g++){var h=this.vertices[g];f.push(h.x,h.y,h.z)}var h=[],k=[],l={},q=[],n={},m=[],p={};for(g=0;g<this.faces.length;g++){var u=this.faces[g],v=void 0!==this.faceVertexUvs[0][g],w=0<u.normal.length(),x=0<u.vertexNormals.length,z=
1!==u.color.r||1!==u.color.g||1!==u.color.b,I=0<u.vertexColors.length,B=0,B=a(B,0,0),B=a(B,1,!0),B=a(B,2,!1),B=a(B,3,v),B=a(B,4,w),B=a(B,5,x),B=a(B,6,z),B=a(B,7,I);h.push(B);h.push(u.a,u.b,u.c);h.push(u.materialIndex);v&&(v=this.faceVertexUvs[0][g],h.push(d(v[0]),d(v[1]),d(v[2])));w&&h.push(b(u.normal));x&&(w=u.vertexNormals,h.push(b(w[0]),b(w[1]),b(w[2])));z&&h.push(c(u.color));I&&(u=u.vertexColors,h.push(c(u[0]),c(u[1]),c(u[2])))}e.data={};e.data.vertices=f;e.data.normals=k;0<q.length&&(e.data.colors=
q);0<m.length&&(e.data.uvs=[m]);e.data.faces=h;return e},clone:function(){return(new N).copy(this)},copy:function(a){var b,c,d;this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingSphere=this.boundingBox=null;this.name=a.name;var e=a.vertices;var f=0;for(b=e.length;f<b;f++)this.vertices.push(e[f].clone());e=a.colors;f=0;for(b=e.length;f<b;f++)this.colors.push(e[f].clone());
e=a.faces;f=0;for(b=e.length;f<b;f++)this.faces.push(e[f].clone());f=0;for(b=a.faceVertexUvs.length;f<b;f++){var g=a.faceVertexUvs[f];void 0===this.faceVertexUvs[f]&&(this.faceVertexUvs[f]=[]);e=0;for(c=g.length;e<c;e++){var h=g[e],k=[];var l=0;for(d=h.length;l<d;l++)k.push(h[l].clone());this.faceVertexUvs[f].push(k)}}l=a.morphTargets;f=0;for(b=l.length;f<b;f++){d={};d.name=l[f].name;if(void 0!==l[f].vertices)for(d.vertices=[],e=0,c=l[f].vertices.length;e<c;e++)d.vertices.push(l[f].vertices[e].clone());
if(void 0!==l[f].normals)for(d.normals=[],e=0,c=l[f].normals.length;e<c;e++)d.normals.push(l[f].normals[e].clone());this.morphTargets.push(d)}l=a.morphNormals;f=0;for(b=l.length;f<b;f++){d={};if(void 0!==l[f].vertexNormals)for(d.vertexNormals=[],e=0,c=l[f].vertexNormals.length;e<c;e++)g=l[f].vertexNormals[e],h={},h.a=g.a.clone(),h.b=g.b.clone(),h.c=g.c.clone(),d.vertexNormals.push(h);if(void 0!==l[f].faceNormals)for(d.faceNormals=[],e=0,c=l[f].faceNormals.length;e<c;e++)d.faceNormals.push(l[f].faceNormals[e].clone());
this.morphNormals.push(d)}e=a.skinWeights;f=0;for(b=e.length;f<b;f++)this.skinWeights.push(e[f].clone());e=a.skinIndices;f=0;for(b=e.length;f<b;f++)this.skinIndices.push(e[f].clone());e=a.lineDistances;f=0;for(b=e.length;f<b;f++)this.lineDistances.push(e[f]);f=a.boundingBox;null!==f&&(this.boundingBox=f.clone());f=a.boundingSphere;null!==f&&(this.boundingSphere=f.clone());this.elementsNeedUpdate=a.elementsNeedUpdate;this.verticesNeedUpdate=a.verticesNeedUpdate;this.uvsNeedUpdate=a.uvsNeedUpdate;this.normalsNeedUpdate=
a.normalsNeedUpdate;this.colorsNeedUpdate=a.colorsNeedUpdate;this.lineDistancesNeedUpdate=a.lineDistancesNeedUpdate;this.groupsNeedUpdate=a.groupsNeedUpdate;return this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Object.defineProperty(P.prototype,"needsUpdate",{set:function(a){!0===a&&this.version++}});Object.assign(P.prototype,{isBufferAttribute:!0,setArray:function(a){if(Array.isArray(a))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.count=void 0!==
a?a.length/this.itemSize:0;this.array=a},setDynamic:function(a){this.dynamic=a;return this},copy:function(a){this.array=new a.array.constructor(a.array);this.itemSize=a.itemSize;this.count=a.count;this.normalized=a.normalized;this.dynamic=a.dynamic;return this},copyAt:function(a,b,c){a*=this.itemSize;c*=b.itemSize;for(var d=0,e=this.itemSize;d<e;d++)this.array[a+d]=b.array[c+d];return this},copyArray:function(a){this.array.set(a);return this},copyColorsArray:function(a){for(var b=this.array,c=0,d=
0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",d),f=new H);b[c++]=f.r;b[c++]=f.g;b[c++]=f.b}return this},copyIndicesArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];b[c++]=f.a;b[c++]=f.b;b[c++]=f.c}return this},copyVector2sArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",d),f=new C);
b[c++]=f.x;b[c++]=f.y}return this},copyVector3sArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",d),f=new p);b[c++]=f.x;b[c++]=f.y;b[c++]=f.z}return this},copyVector4sArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",d),f=new da);b[c++]=f.x;b[c++]=f.y;b[c++]=f.z;
b[c++]=f.w}return this},set:function(a,b){void 0===b&&(b=0);this.array.set(a,b);return this},getX:function(a){return this.array[a*this.itemSize]},setX:function(a,b){this.array[a*this.itemSize]=b;return this},getY:function(a){return this.array[a*this.itemSize+1]},setY:function(a,b){this.array[a*this.itemSize+1]=b;return this},getZ:function(a){return this.array[a*this.itemSize+2]},setZ:function(a,b){this.array[a*this.itemSize+2]=b;return this},getW:function(a){return this.array[a*this.itemSize+3]},
setW:function(a,b){this.array[a*this.itemSize+3]=b;return this},setXY:function(a,b,c){a*=this.itemSize;this.array[a+0]=b;this.array[a+1]=c;return this},setXYZ:function(a,b,c,d){a*=this.itemSize;this.array[a+0]=b;this.array[a+1]=c;this.array[a+2]=d;return this},setXYZW:function(a,b,c,d,e){a*=this.itemSize;this.array[a+0]=b;this.array[a+1]=c;this.array[a+2]=d;this.array[a+3]=e;return this},onUpload:function(a){this.onUploadCallback=a;return this},clone:function(){return(new this.constructor(this.array,
this.itemSize)).copy(this)}});uc.prototype=Object.create(P.prototype);uc.prototype.constructor=uc;vc.prototype=Object.create(P.prototype);vc.prototype.constructor=vc;wc.prototype=Object.create(P.prototype);wc.prototype.constructor=wc;xc.prototype=Object.create(P.prototype);xc.prototype.constructor=xc;hb.prototype=Object.create(P.prototype);hb.prototype.constructor=hb;yc.prototype=Object.create(P.prototype);yc.prototype.constructor=yc;ib.prototype=Object.create(P.prototype);ib.prototype.constructor=
ib;y.prototype=Object.create(P.prototype);y.prototype.constructor=y;zc.prototype=Object.create(P.prototype);zc.prototype.constructor=zc;Object.assign(Je.prototype,{computeGroups:function(a){var b=[],c=void 0;a=a.faces;for(var d=0;d<a.length;d++){var e=a[d];if(e.materialIndex!==c){c=e.materialIndex;void 0!==f&&(f.count=3*d-f.start,b.push(f));var f={start:3*d,materialIndex:c}}}void 0!==f&&(f.count=3*d-f.start,b.push(f));this.groups=b},fromGeometry:function(a){var b=a.faces,c=a.vertices,d=a.faceVertexUvs,
e=d[0]&&0<d[0].length,f=d[1]&&0<d[1].length,g=a.morphTargets,h=g.length;if(0<h){var k=[];for(var l=0;l<h;l++)k[l]=[];this.morphTargets.position=k}var q=a.morphNormals,n=q.length;if(0<n){var m=[];for(l=0;l<n;l++)m[l]=[];this.morphTargets.normal=m}for(var p=a.skinIndices,u=a.skinWeights,v=p.length===c.length,w=u.length===c.length,l=0;l<b.length;l++){var x=b[l];this.vertices.push(c[x.a],c[x.b],c[x.c]);var z=x.vertexNormals;3===z.length?this.normals.push(z[0],z[1],z[2]):(z=x.normal,this.normals.push(z,
z,z));z=x.vertexColors;3===z.length?this.colors.push(z[0],z[1],z[2]):(z=x.color,this.colors.push(z,z,z));!0===e&&(z=d[0][l],void 0!==z?this.uvs.push(z[0],z[1],z[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",l),this.uvs.push(new C,new C,new C)));!0===f&&(z=d[1][l],void 0!==z?this.uvs2.push(z[0],z[1],z[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",l),this.uvs2.push(new C,new C,new C)));for(z=0;z<h;z++){var I=g[z].vertices;k[z].push(I[x.a],
I[x.b],I[x.c])}for(z=0;z<n;z++)I=q[z].vertexNormals[l],m[z].push(I.a,I.b,I.c);v&&this.skinIndices.push(p[x.a],p[x.b],p[x.c]);w&&this.skinWeights.push(u[x.a],u[x.b],u[x.c])}this.computeGroups(a);this.verticesNeedUpdate=a.verticesNeedUpdate;this.normalsNeedUpdate=a.normalsNeedUpdate;this.colorsNeedUpdate=a.colorsNeedUpdate;this.uvsNeedUpdate=a.uvsNeedUpdate;this.groupsNeedUpdate=a.groupsNeedUpdate;return this}});var Pf=1;Object.assign(D.prototype,ja.prototype,{isBufferGeometry:!0,getIndex:function(){return this.index},
setIndex:function(a){Array.isArray(a)?this.index=new (65535<Qd(a)?ib:hb)(a,1):this.index=a},addAttribute:function(a,b,c){if(b&&b.isBufferAttribute||b&&b.isInterleavedBufferAttribute)if("index"===a)console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(b);else return this.attributes[a]=b,this;else console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.addAttribute(a,new P(b,c))},getAttribute:function(a){return this.attributes[a]},
removeAttribute:function(a){delete this.attributes[a];return this},addGroup:function(a,b,c){this.groups.push({start:a,count:b,materialIndex:void 0!==c?c:0})},clearGroups:function(){this.groups=[]},setDrawRange:function(a,b){this.drawRange.start=a;this.drawRange.count=b},applyMatrix:function(a){var b=this.attributes.position;void 0!==b&&(a.applyToBufferAttribute(b),b.needsUpdate=!0);b=this.attributes.normal;void 0!==b&&((new ra).getNormalMatrix(a).applyToBufferAttribute(b),b.needsUpdate=!0);null!==
this.boundingBox&&this.computeBoundingBox();null!==this.boundingSphere&&this.computeBoundingSphere();return this},rotateX:function(){var a=new K;return function(b){a.makeRotationX(b);this.applyMatrix(a);return this}}(),rotateY:function(){var a=new K;return function(b){a.makeRotationY(b);this.applyMatrix(a);return this}}(),rotateZ:function(){var a=new K;return function(b){a.makeRotationZ(b);this.applyMatrix(a);return this}}(),translate:function(){var a=new K;return function(b,c,d){a.makeTranslation(b,
c,d);this.applyMatrix(a);return this}}(),scale:function(){var a=new K;return function(b,c,d){a.makeScale(b,c,d);this.applyMatrix(a);return this}}(),lookAt:function(){var a=new A;return function(b){a.lookAt(b);a.updateMatrix();this.applyMatrix(a.matrix)}}(),center:function(){this.computeBoundingBox();var a=this.boundingBox.getCenter().negate();this.translate(a.x,a.y,a.z);return a},setFromObject:function(a){var b=a.geometry;if(a.isPoints||a.isLine){a=new y(3*b.vertices.length,3);var c=new y(3*b.colors.length,
3);this.addAttribute("position",a.copyVector3sArray(b.vertices));this.addAttribute("color",c.copyColorsArray(b.colors));b.lineDistances&&b.lineDistances.length===b.vertices.length&&(a=new y(b.lineDistances.length,1),this.addAttribute("lineDistance",a.copyArray(b.lineDistances)));null!==b.boundingSphere&&(this.boundingSphere=b.boundingSphere.clone());null!==b.boundingBox&&(this.boundingBox=b.boundingBox.clone())}else a.isMesh&&b&&b.isGeometry&&this.fromGeometry(b);return this},setFromPoints:function(a){for(var b=
[],c=0,d=a.length;c<d;c++){var e=a[c];b.push(e.x,e.y,e.z||0)}this.addAttribute("position",new y(b,3));return this},updateFromObject:function(a){var b=a.geometry;if(a.isMesh){var c=b.__directGeometry;!0===b.elementsNeedUpdate&&(c=void 0,b.elementsNeedUpdate=!1);if(void 0===c)return this.fromGeometry(b);c.verticesNeedUpdate=b.verticesNeedUpdate;c.normalsNeedUpdate=b.normalsNeedUpdate;c.colorsNeedUpdate=b.colorsNeedUpdate;c.uvsNeedUpdate=b.uvsNeedUpdate;c.groupsNeedUpdate=b.groupsNeedUpdate;b.verticesNeedUpdate=
!1;b.normalsNeedUpdate=!1;b.colorsNeedUpdate=!1;b.uvsNeedUpdate=!1;b.groupsNeedUpdate=!1;b=c}!0===b.verticesNeedUpdate&&(c=this.attributes.position,void 0!==c&&(c.copyVector3sArray(b.vertices),c.needsUpdate=!0),b.verticesNeedUpdate=!1);!0===b.normalsNeedUpdate&&(c=this.attributes.normal,void 0!==c&&(c.copyVector3sArray(b.normals),c.needsUpdate=!0),b.normalsNeedUpdate=!1);!0===b.colorsNeedUpdate&&(c=this.attributes.color,void 0!==c&&(c.copyColorsArray(b.colors),c.needsUpdate=!0),b.colorsNeedUpdate=
!1);b.uvsNeedUpdate&&(c=this.attributes.uv,void 0!==c&&(c.copyVector2sArray(b.uvs),c.needsUpdate=!0),b.uvsNeedUpdate=!1);b.lineDistancesNeedUpdate&&(c=this.attributes.lineDistance,void 0!==c&&(c.copyArray(b.lineDistances),c.needsUpdate=!0),b.lineDistancesNeedUpdate=!1);b.groupsNeedUpdate&&(b.computeGroups(a.geometry),this.groups=b.groups,b.groupsNeedUpdate=!1);return this},fromGeometry:function(a){a.__directGeometry=(new Je).fromGeometry(a);return this.fromDirectGeometry(a.__directGeometry)},fromDirectGeometry:function(a){var b=
new Float32Array(3*a.vertices.length);this.addAttribute("position",(new P(b,3)).copyVector3sArray(a.vertices));0<a.normals.length&&(b=new Float32Array(3*a.normals.length),this.addAttribute("normal",(new P(b,3)).copyVector3sArray(a.normals)));0<a.colors.length&&(b=new Float32Array(3*a.colors.length),this.addAttribute("color",(new P(b,3)).copyColorsArray(a.colors)));0<a.uvs.length&&(b=new Float32Array(2*a.uvs.length),this.addAttribute("uv",(new P(b,2)).copyVector2sArray(a.uvs)));0<a.uvs2.length&&(b=
new Float32Array(2*a.uvs2.length),this.addAttribute("uv2",(new P(b,2)).copyVector2sArray(a.uvs2)));0<a.indices.length&&(b=new (65535<Qd(a.indices)?Uint32Array:Uint16Array)(3*a.indices.length),this.setIndex((new P(b,1)).copyIndicesArray(a.indices)));this.groups=a.groups;for(var c in a.morphTargets){for(var b=[],d=a.morphTargets[c],e=0,f=d.length;e<f;e++){var g=d[e],h=new y(3*g.length,3);b.push(h.copyVector3sArray(g))}this.morphAttributes[c]=b}0<a.skinIndices.length&&(c=new y(4*a.skinIndices.length,
4),this.addAttribute("skinIndex",c.copyVector4sArray(a.skinIndices)));0<a.skinWeights.length&&(c=new y(4*a.skinWeights.length,4),this.addAttribute("skinWeight",c.copyVector4sArray(a.skinWeights)));null!==a.boundingSphere&&(this.boundingSphere=a.boundingSphere.clone());null!==a.boundingBox&&(this.boundingBox=a.boundingBox.clone());return this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new Oa);var a=this.attributes.position;void 0!==a?this.boundingBox.setFromBufferAttribute(a):
this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){var a=new Oa,b=new p;return function(){null===this.boundingSphere&&(this.boundingSphere=new Da);var c=this.attributes.position;if(c){var d=this.boundingSphere.center;a.setFromBufferAttribute(c);
a.getCenter(d);for(var e=0,f=0,g=c.count;f<g;f++)b.x=c.getX(f),b.y=c.getY(f),b.z=c.getZ(f),e=Math.max(e,d.distanceToSquared(b));this.boundingSphere.radius=Math.sqrt(e);isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}}(),computeFaceNormals:function(){},computeVertexNormals:function(){var a=this.index,b=this.attributes,c=this.groups;if(b.position){var d=b.position.array;
if(void 0===b.normal)this.addAttribute("normal",new P(new Float32Array(d.length),3));else for(var e=b.normal.array,f=0,g=e.length;f<g;f++)e[f]=0;var e=b.normal.array,h=new p,k=new p,l=new p,q=new p,n=new p;if(a){a=a.array;0===c.length&&this.addGroup(0,a.length);for(var m=0,r=c.length;m<r;++m){f=c[m];g=f.start;var u=f.count;f=g;for(g+=u;f<g;f+=3){u=3*a[f+0];var v=3*a[f+1];var w=3*a[f+2];h.fromArray(d,u);k.fromArray(d,v);l.fromArray(d,w);q.subVectors(l,k);n.subVectors(h,k);q.cross(n);e[u]+=q.x;e[u+
1]+=q.y;e[u+2]+=q.z;e[v]+=q.x;e[v+1]+=q.y;e[v+2]+=q.z;e[w]+=q.x;e[w+1]+=q.y;e[w+2]+=q.z}}}else for(f=0,g=d.length;f<g;f+=9)h.fromArray(d,f),k.fromArray(d,f+3),l.fromArray(d,f+6),q.subVectors(l,k),n.subVectors(h,k),q.cross(n),e[f]=q.x,e[f+1]=q.y,e[f+2]=q.z,e[f+3]=q.x,e[f+4]=q.y,e[f+5]=q.z,e[f+6]=q.x,e[f+7]=q.y,e[f+8]=q.z;this.normalizeNormals();b.normal.needsUpdate=!0}},merge:function(a,b){if(a&&a.isBufferGeometry){void 0===b&&(b=0);var c=this.attributes,d;for(d in c)if(void 0!==a.attributes[d])for(var e=
c[d].array,f=a.attributes[d],g=f.array,h=0,f=f.itemSize*b;h<g.length;h++,f++)e[f]=g[h];return this}console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",a)},normalizeNormals:function(){var a=new p;return function(){for(var b=this.attributes.normal,c=0,d=b.count;c<d;c++)a.x=b.getX(c),a.y=b.getY(c),a.z=b.getZ(c),a.normalize(),b.setXYZ(c,a.x,a.y,a.z)}}(),toNonIndexed:function(){if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
this;var a=new D,b=this.index.array,c=this.attributes,d;for(d in c){for(var e=c[d],f=e.array,e=e.itemSize,g=new f.constructor(b.length*e),h,k=0,l=0,q=b.length;l<q;l++){h=b[l]*e;for(var n=0;n<e;n++)g[k++]=f[h++]}a.addAttribute(d,new P(g,e))}return a},toJSON:function(){var a={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};a.uuid=this.uuid;a.type=this.type;""!==this.name&&(a.name=this.name);if(void 0!==this.parameters){var b=this.parameters;for(var c in b)void 0!==b[c]&&
(a[c]=b[c]);return a}a.data={attributes:{}};var d=this.index;null!==d&&(b=Array.prototype.slice.call(d.array),a.data.index={type:d.array.constructor.name,array:b});d=this.attributes;for(c in d){var e=d[c];b=Array.prototype.slice.call(e.array);a.data.attributes[c]={itemSize:e.itemSize,type:e.array.constructor.name,array:b,normalized:e.normalized}}c=this.groups;0<c.length&&(a.data.groups=JSON.parse(JSON.stringify(c)));c=this.boundingSphere;null!==c&&(a.data.boundingSphere={center:c.center.toArray(),
radius:c.radius});return a},clone:function(){return(new D).copy(this)},copy:function(a){var b;this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingSphere=this.boundingBox=null;this.name=a.name;var c=a.index;null!==c&&this.setIndex(c.clone());c=a.attributes;for(g in c)this.addAttribute(g,c[g].clone());var d=a.morphAttributes;for(g in d){var e=[],f=d[g];c=0;for(b=f.length;c<b;c++)e.push(f[c].clone());this.morphAttributes[g]=e}var g=a.groups;c=0;for(b=g.length;c<b;c++)d=
g[c],this.addGroup(d.start,d.count,d.materialIndex);g=a.boundingBox;null!==g&&(this.boundingBox=g.clone());g=a.boundingSphere;null!==g&&(this.boundingSphere=g.clone());this.drawRange.start=a.drawRange.start;this.drawRange.count=a.drawRange.count;return this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Lb.prototype=Object.create(N.prototype);Lb.prototype.constructor=Lb;jb.prototype=Object.create(D.prototype);jb.prototype.constructor=jb;Ac.prototype=Object.create(N.prototype);Ac.prototype.constructor=
Ac;kb.prototype=Object.create(D.prototype);kb.prototype.constructor=kb;va.prototype=Object.create(Q.prototype);va.prototype.constructor=va;va.prototype.isMeshBasicMaterial=!0;va.prototype.copy=function(a){Q.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.lightMap=a.lightMap;this.lightMapIntensity=a.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.specularMap=a.specularMap;this.alphaMap=a.alphaMap;this.envMap=a.envMap;this.combine=a.combine;this.reflectivity=
a.reflectivity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;this.skinning=a.skinning;this.morphTargets=a.morphTargets;return this};oa.prototype=Object.create(Q.prototype);oa.prototype.constructor=oa;oa.prototype.isShaderMaterial=!0;oa.prototype.copy=function(a){Q.prototype.copy.call(this,a);this.fragmentShader=a.fragmentShader;this.vertexShader=a.vertexShader;
this.uniforms=Ea.clone(a.uniforms);this.defines=a.defines;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.lights=a.lights;this.clipping=a.clipping;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;this.extensions=a.extensions;return this};oa.prototype.toJSON=function(a){a=Q.prototype.toJSON.call(this,a);a.uniforms=this.uniforms;a.vertexShader=this.vertexShader;a.fragmentShader=this.fragmentShader;return a};Object.assign(lb.prototype,
{set:function(a,b){this.origin.copy(a);this.direction.copy(b);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.origin.copy(a.origin);this.direction.copy(a.direction);return this},at:function(a,b){return(b||new p).copy(this.direction).multiplyScalar(a).add(this.origin)},lookAt:function(a){this.direction.copy(a).sub(this.origin).normalize();return this},recast:function(){var a=new p;return function(b){this.origin.copy(this.at(b,a));return this}}(),closestPointToPoint:function(a,
b){b=b||new p;b.subVectors(a,this.origin);a=b.dot(this.direction);return 0>a?b.copy(this.origin):b.copy(this.direction).multiplyScalar(a).add(this.origin)},distanceToPoint:function(a){return Math.sqrt(this.distanceSqToPoint(a))},distanceSqToPoint:function(){var a=new p;return function(b){var c=a.subVectors(b,this.origin).dot(this.direction);if(0>c)return this.origin.distanceToSquared(b);a.copy(this.direction).multiplyScalar(c).add(this.origin);return a.distanceToSquared(b)}}(),distanceSqToSegment:function(){var a=
new p,b=new p,c=new p;return function(d,e,f,g){a.copy(d).add(e).multiplyScalar(.5);b.copy(e).sub(d).normalize();c.copy(this.origin).sub(a);var h=.5*d.distanceTo(e),k=-this.direction.dot(b),l=c.dot(this.direction),q=-c.dot(b),n=c.lengthSq(),m=Math.abs(1-k*k);if(0<m){d=k*q-l;e=k*l-q;var p=h*m;0<=d?e>=-p?e<=p?(h=1/m,d*=h,e*=h,k=d*(d+k*e+2*l)+e*(k*d+e+2*q)+n):(e=h,d=Math.max(0,-(k*e+l)),k=-d*d+e*(e+2*q)+n):(e=-h,d=Math.max(0,-(k*e+l)),k=-d*d+e*(e+2*q)+n):e<=-p?(d=Math.max(0,-(-k*h+l)),e=0<d?-h:Math.min(Math.max(-h,
-q),h),k=-d*d+e*(e+2*q)+n):e<=p?(d=0,e=Math.min(Math.max(-h,-q),h),k=e*(e+2*q)+n):(d=Math.max(0,-(k*h+l)),e=0<d?h:Math.min(Math.max(-h,-q),h),k=-d*d+e*(e+2*q)+n)}else e=0<k?-h:h,d=Math.max(0,-(k*e+l)),k=-d*d+e*(e+2*q)+n;f&&f.copy(this.direction).multiplyScalar(d).add(this.origin);g&&g.copy(b).multiplyScalar(e).add(a);return k}}(),intersectSphere:function(){var a=new p;return function(b,c){a.subVectors(b.center,this.origin);var d=a.dot(this.direction),e=a.dot(a)-d*d;b=b.radius*b.radius;if(e>b)return null;
b=Math.sqrt(b-e);e=d-b;d+=b;return 0>e&&0>d?null:0>e?this.at(d,c):this.at(e,c)}}(),intersectsSphere:function(a){return this.distanceToPoint(a.center)<=a.radius},distanceToPlane:function(a){var b=a.normal.dot(this.direction);if(0===b)return 0===a.distanceToPoint(this.origin)?0:null;a=-(this.origin.dot(a.normal)+a.constant)/b;return 0<=a?a:null},intersectPlane:function(a,b){a=this.distanceToPlane(a);return null===a?null:this.at(a,b)},intersectsPlane:function(a){var b=a.distanceToPoint(this.origin);
return 0===b||0>a.normal.dot(this.direction)*b?!0:!1},intersectBox:function(a,b){var c=1/this.direction.x;var d=1/this.direction.y;var e=1/this.direction.z,f=this.origin;if(0<=c){var g=(a.min.x-f.x)*c;c*=a.max.x-f.x}else g=(a.max.x-f.x)*c,c*=a.min.x-f.x;if(0<=d){var h=(a.min.y-f.y)*d;d*=a.max.y-f.y}else h=(a.max.y-f.y)*d,d*=a.min.y-f.y;if(g>d||h>c)return null;if(h>g||g!==g)g=h;if(d<c||c!==c)c=d;0<=e?(h=(a.min.z-f.z)*e,a=(a.max.z-f.z)*e):(h=(a.max.z-f.z)*e,a=(a.min.z-f.z)*e);if(g>a||h>c)return null;
if(h>g||g!==g)g=h;if(a<c||c!==c)c=a;return 0>c?null:this.at(0<=g?g:c,b)},intersectsBox:function(){var a=new p;return function(b){return null!==this.intersectBox(b,a)}}(),intersectTriangle:function(){var a=new p,b=new p,c=new p,d=new p;return function(e,f,g,h,k){b.subVectors(f,e);c.subVectors(g,e);d.crossVectors(b,c);f=this.direction.dot(d);if(0<f){if(h)return null;h=1}else if(0>f)h=-1,f=-f;else return null;a.subVectors(this.origin,e);e=h*this.direction.dot(c.crossVectors(a,c));if(0>e)return null;
g=h*this.direction.dot(b.cross(a));if(0>g||e+g>f)return null;e=-h*a.dot(d);return 0>e?null:this.at(e/f,k)}}(),applyMatrix4:function(a){this.origin.applyMatrix4(a);this.direction.transformDirection(a);return this},equals:function(a){return a.origin.equals(this.origin)&&a.direction.equals(this.direction)}});Object.assign(Mb.prototype,{set:function(a,b){this.start.copy(a);this.end.copy(b);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.start.copy(a.start);
this.end.copy(a.end);return this},getCenter:function(a){return(a||new p).addVectors(this.start,this.end).multiplyScalar(.5)},delta:function(a){return(a||new p).subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},at:function(a,b){b=b||new p;return this.delta(b).multiplyScalar(a).add(this.start)},closestPointToPointParameter:function(){var a=new p,b=new p;return function(c,d){a.subVectors(c,
this.start);b.subVectors(this.end,this.start);c=b.dot(b);c=b.dot(a)/c;d&&(c=R.clamp(c,0,1));return c}}(),closestPointToPoint:function(a,b,c){a=this.closestPointToPointParameter(a,b);c=c||new p;return this.delta(c).multiplyScalar(a).add(this.start)},applyMatrix4:function(a){this.start.applyMatrix4(a);this.end.applyMatrix4(a);return this},equals:function(a){return a.start.equals(this.start)&&a.end.equals(this.end)}});Object.assign(Qa,{normal:function(){var a=new p;return function(b,c,d,e){e=e||new p;
e.subVectors(d,c);a.subVectors(b,c);e.cross(a);b=e.lengthSq();return 0<b?e.multiplyScalar(1/Math.sqrt(b)):e.set(0,0,0)}}(),barycoordFromPoint:function(){var a=new p,b=new p,c=new p;return function(d,e,f,g,h){a.subVectors(g,e);b.subVectors(f,e);c.subVectors(d,e);d=a.dot(a);e=a.dot(b);f=a.dot(c);var k=b.dot(b);g=b.dot(c);var l=d*k-e*e;h=h||new p;if(0===l)return h.set(-2,-1,-1);l=1/l;k=(k*f-e*g)*l;d=(d*g-e*f)*l;return h.set(1-k-d,d,k)}}(),containsPoint:function(){var a=new p;return function(b,c,d,e){b=
Qa.barycoordFromPoint(b,c,d,e,a);return 0<=b.x&&0<=b.y&&1>=b.x+b.y}}()});Object.assign(Qa.prototype,{set:function(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this},setFromPointsAndIndices:function(a,b,c,d){this.a.copy(a[b]);this.b.copy(a[c]);this.c.copy(a[d]);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.a.copy(a.a);this.b.copy(a.b);this.c.copy(a.c);return this},area:function(){var a=new p,b=new p;return function(){a.subVectors(this.c,
this.b);b.subVectors(this.a,this.b);return.5*a.cross(b).length()}}(),midpoint:function(a){return(a||new p).addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},normal:function(a){return Qa.normal(this.a,this.b,this.c,a)},plane:function(a){return(a||new Aa).setFromCoplanarPoints(this.a,this.b,this.c)},barycoordFromPoint:function(a,b){return Qa.barycoordFromPoint(a,this.a,this.b,this.c,b)},containsPoint:function(a){return Qa.containsPoint(a,this.a,this.b,this.c)},closestPointToPoint:function(){var a=
new Aa,b=[new Mb,new Mb,new Mb],c=new p,d=new p;return function(e,f){f=f||new p;var g=Infinity;a.setFromCoplanarPoints(this.a,this.b,this.c);a.projectPoint(e,c);if(!0===this.containsPoint(c))f.copy(c);else for(b[0].set(this.a,this.b),b[1].set(this.b,this.c),b[2].set(this.c,this.a),e=0;e<b.length;e++){b[e].closestPointToPoint(c,!0,d);var h=c.distanceToSquared(d);h<g&&(g=h,f.copy(d))}return f}}(),equals:function(a){return a.a.equals(this.a)&&a.b.equals(this.b)&&a.c.equals(this.c)}});pa.prototype=Object.assign(Object.create(A.prototype),
{constructor:pa,isMesh:!0,setDrawMode:function(a){this.drawMode=a},copy:function(a){A.prototype.copy.call(this,a);this.drawMode=a.drawMode;void 0!==a.morphTargetInfluences&&(this.morphTargetInfluences=a.morphTargetInfluences.slice());void 0!==a.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},a.morphTargetDictionary));return this},updateMorphTargets:function(){var a=this.geometry;if(a.isBufferGeometry){a=a.morphAttributes;var b=Object.keys(a);if(0<b.length){var c=a[b[0]];if(void 0!==
c)for(this.morphTargetInfluences=[],this.morphTargetDictionary={},a=0,b=c.length;a<b;a++){var d=c[a].name||String(a);this.morphTargetInfluences.push(0);this.morphTargetDictionary[d]=a}}}else if(c=a.morphTargets,void 0!==c&&0<c.length)for(this.morphTargetInfluences=[],this.morphTargetDictionary={},a=0,b=c.length;a<b;a++)d=c[a].name||String(a),this.morphTargetInfluences.push(0),this.morphTargetDictionary[d]=a},raycast:function(){function a(a,b,c,d,e,f,g){Qa.barycoordFromPoint(a,b,c,d,v);e.multiplyScalar(v.x);
f.multiplyScalar(v.y);g.multiplyScalar(v.z);e.add(f).add(g);return e.clone()}function b(a,b,c,d,e,f,g,h){if(null===(1===b.side?d.intersectTriangle(g,f,e,!0,h):d.intersectTriangle(e,f,g,2!==b.side,h)))return null;x.copy(h);x.applyMatrix4(a.matrixWorld);b=c.ray.origin.distanceTo(x);return b<c.near||b>c.far?null:{distance:b,point:x.clone(),object:a}}function c(c,d,e,f,l,n,q,t){g.fromBufferAttribute(f,n);h.fromBufferAttribute(f,q);k.fromBufferAttribute(f,t);if(c=b(c,c.material,d,e,g,h,k,w))l&&(m.fromBufferAttribute(l,
n),r.fromBufferAttribute(l,q),u.fromBufferAttribute(l,t),c.uv=a(w,g,h,k,m,r,u)),c.face=new Pa(n,q,t,Qa.normal(g,h,k)),c.faceIndex=n;return c}var d=new K,e=new lb,f=new Da,g=new p,h=new p,k=new p,l=new p,q=new p,n=new p,m=new C,r=new C,u=new C,v=new p,w=new p,x=new p;return function(t,p){var v=this.geometry,x=this.material,z=this.matrixWorld;if(void 0!==x&&(null===v.boundingSphere&&v.computeBoundingSphere(),f.copy(v.boundingSphere),f.applyMatrix4(z),!1!==t.ray.intersectsSphere(f)&&(d.getInverse(z),
e.copy(t.ray).applyMatrix4(d),null===v.boundingBox||!1!==e.intersectsBox(v.boundingBox)))){var y;if(v.isBufferGeometry){var x=v.index,I=v.attributes.position,z=v.attributes.uv,C;if(null!==x){var A=0;for(C=x.count;A<C;A+=3){v=x.getX(A);var D=x.getX(A+1);var E=x.getX(A+2);if(y=c(this,t,e,I,z,v,D,E))y.faceIndex=Math.floor(A/3),p.push(y)}}else if(void 0!==I)for(A=0,C=I.count;A<C;A+=3)if(v=A,D=A+1,E=A+2,y=c(this,t,e,I,z,v,D,E))y.index=v,p.push(y)}else if(v.isGeometry){var z=Array.isArray(x);A=v.vertices;
C=v.faces;D=v.faceVertexUvs[0];0<D.length&&(I=D);for(var H=0,N=C.length;H<N;H++){var M=C[H];y=z?x[M.materialIndex]:x;if(void 0!==y){D=A[M.a];E=A[M.b];var V=A[M.c];if(!0===y.morphTargets){var K=v.morphTargets,P=this.morphTargetInfluences;g.set(0,0,0);h.set(0,0,0);k.set(0,0,0);for(var Q=0,R=K.length;Q<R;Q++){var O=P[Q];if(0!==O){var S=K[Q].vertices;g.addScaledVector(l.subVectors(S[M.a],D),O);h.addScaledVector(q.subVectors(S[M.b],E),O);k.addScaledVector(n.subVectors(S[M.c],V),O)}}g.add(D);h.add(E);k.add(V);
D=g;E=h;V=k}if(y=b(this,y,t,e,D,E,V,w))I&&I[H]&&(K=I[H],m.copy(K[0]),r.copy(K[1]),u.copy(K[2]),y.uv=a(w,D,E,V,m,r,u)),y.face=M,y.faceIndex=H,p.push(y)}}}}}}(),clone:function(){return(new this.constructor(this.geometry,this.material)).copy(this)}});var ig=0;U.prototype=Object.assign(Object.create(La.prototype),{constructor:U,isPerspectiveCamera:!0,copy:function(a,b){La.prototype.copy.call(this,a,b);this.fov=a.fov;this.zoom=a.zoom;this.near=a.near;this.far=a.far;this.focus=a.focus;this.aspect=a.aspect;
this.view=null===a.view?null:Object.assign({},a.view);this.filmGauge=a.filmGauge;this.filmOffset=a.filmOffset;return this},setFocalLength:function(a){a=.5*this.getFilmHeight()/a;this.fov=2*R.RAD2DEG*Math.atan(a);this.updateProjectionMatrix()},getFocalLength:function(){var a=Math.tan(.5*R.DEG2RAD*this.fov);return.5*this.getFilmHeight()/a},getEffectiveFOV:function(){return 2*R.RAD2DEG*Math.atan(Math.tan(.5*R.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,
1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(a,b,c,d,e,f){this.aspect=a/b;null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1});this.view.enabled=!0;this.view.fullWidth=a;this.view.fullHeight=b;this.view.offsetX=c;this.view.offsetY=d;this.view.width=e;this.view.height=f;this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1);this.updateProjectionMatrix()},
updateProjectionMatrix:function(){var a=this.near,b=a*Math.tan(.5*R.DEG2RAD*this.fov)/this.zoom,c=2*b,d=this.aspect*c,e=-.5*d,f=this.view;if(null!==this.view&&this.view.enabled)var g=f.fullWidth,h=f.fullHeight,e=e+f.offsetX*d/g,b=b-f.offsetY*c/h,d=f.width/g*d,c=f.height/h*c;f=this.filmOffset;0!==f&&(e+=a*f/this.getFilmWidth());this.projectionMatrix.makePerspective(e,e+d,b,b-c,a,this.far)},toJSON:function(a){a=A.prototype.toJSON.call(this,a);a.object.fov=this.fov;a.object.zoom=this.zoom;a.object.near=
this.near;a.object.far=this.far;a.object.focus=this.focus;a.object.aspect=this.aspect;null!==this.view&&(a.object.view=Object.assign({},this.view));a.object.filmGauge=this.filmGauge;a.object.filmOffset=this.filmOffset;return a}});nd.prototype=Object.assign(Object.create(U.prototype),{constructor:nd,isArrayCamera:!0});Ob.prototype.isFogExp2=!0;Ob.prototype.clone=function(){return new Ob(this.color.getHex(),this.density)};Ob.prototype.toJSON=function(){return{type:"FogExp2",color:this.color.getHex(),
density:this.density}};Pb.prototype.isFog=!0;Pb.prototype.clone=function(){return new Pb(this.color.getHex(),this.near,this.far)};Pb.prototype.toJSON=function(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}};od.prototype=Object.assign(Object.create(A.prototype),{constructor:od,copy:function(a,b){A.prototype.copy.call(this,a,b);null!==a.background&&(this.background=a.background.clone());null!==a.fog&&(this.fog=a.fog.clone());null!==a.overrideMaterial&&(this.overrideMaterial=
a.overrideMaterial.clone());this.autoUpdate=a.autoUpdate;this.matrixAutoUpdate=a.matrixAutoUpdate;return this},toJSON:function(a){var b=A.prototype.toJSON.call(this,a);null!==this.background&&(b.object.background=this.background.toJSON(a));null!==this.fog&&(b.object.fog=this.fog.toJSON());return b}});Xd.prototype=Object.assign(Object.create(A.prototype),{constructor:Xd,isLensFlare:!0,copy:function(a){A.prototype.copy.call(this,a);this.positionScreen.copy(a.positionScreen);this.customUpdateCallback=
a.customUpdateCallback;for(var b=0,c=a.lensFlares.length;b<c;b++)this.lensFlares.push(a.lensFlares[b]);return this},add:function(a,b,c,d,e,f){void 0===b&&(b=-1);void 0===c&&(c=0);void 0===f&&(f=1);void 0===e&&(e=new H(16777215));void 0===d&&(d=1);c=Math.min(c,Math.max(0,c));this.lensFlares.push({texture:a,size:b,distance:c,x:0,y:0,z:0,scale:1,rotation:0,opacity:f,color:e,blending:d})},updateLensFlares:function(){var a,b=this.lensFlares.length,c=2*-this.positionScreen.x,d=2*-this.positionScreen.y;
for(a=0;a<b;a++){var e=this.lensFlares[a];e.x=this.positionScreen.x+c*e.distance;e.y=this.positionScreen.y+d*e.distance;e.wantedRotation=e.x*Math.PI*.25;e.rotation+=.25*(e.wantedRotation-e.rotation)}}});Za.prototype=Object.create(Q.prototype);Za.prototype.constructor=Za;Za.prototype.isSpriteMaterial=!0;Za.prototype.copy=function(a){Q.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.rotation=a.rotation;return this};Cc.prototype=Object.assign(Object.create(A.prototype),{constructor:Cc,
isSprite:!0,raycast:function(){var a=new p,b=new p,c=new p;return function(d,e){b.setFromMatrixPosition(this.matrixWorld);d.ray.closestPointToPoint(b,a);c.setFromMatrixScale(this.matrixWorld);var f=c.x*c.y/4;b.distanceToSquared(a)>f||(f=d.ray.origin.distanceTo(a),f<d.near||f>d.far||e.push({distance:f,point:a.clone(),face:null,object:this}))}}(),clone:function(){return(new this.constructor(this.material)).copy(this)}});Dc.prototype=Object.assign(Object.create(A.prototype),{constructor:Dc,copy:function(a){A.prototype.copy.call(this,
a,!1);a=a.levels;for(var b=0,c=a.length;b<c;b++){var d=a[b];this.addLevel(d.object.clone(),d.distance)}return this},addLevel:function(a,b){void 0===b&&(b=0);b=Math.abs(b);for(var c=this.levels,d=0;d<c.length&&!(b<c[d].distance);d++);c.splice(d,0,{distance:b,object:a});this.add(a)},getObjectForDistance:function(a){for(var b=this.levels,c=1,d=b.length;c<d&&!(a<b[c].distance);c++);return b[c-1].object},raycast:function(){var a=new p;return function(b,c){a.setFromMatrixPosition(this.matrixWorld);var d=
b.ray.origin.distanceTo(a);this.getObjectForDistance(d).raycast(b,c)}}(),update:function(){var a=new p,b=new p;return function(c){var d=this.levels;if(1<d.length){a.setFromMatrixPosition(c.matrixWorld);b.setFromMatrixPosition(this.matrixWorld);c=a.distanceTo(b);d[0].object.visible=!0;for(var e=1,f=d.length;e<f;e++)if(c>=d[e].distance)d[e-1].object.visible=!1,d[e].object.visible=!0;else break;for(;e<f;e++)d[e].object.visible=!1}}}(),toJSON:function(a){a=A.prototype.toJSON.call(this,a);a.object.levels=
[];for(var b=this.levels,c=0,d=b.length;c<d;c++){var e=b[c];a.object.levels.push({object:e.object.uuid,distance:e.distance})}return a}});Object.assign(Ec.prototype,{calculateInverses:function(){this.boneInverses=[];for(var a=0,b=this.bones.length;a<b;a++){var c=new K;this.bones[a]&&c.getInverse(this.bones[a].matrixWorld);this.boneInverses.push(c)}},pose:function(){var a,b;var c=0;for(b=this.bones.length;c<b;c++)(a=this.bones[c])&&a.matrixWorld.getInverse(this.boneInverses[c]);c=0;for(b=this.bones.length;c<
b;c++)if(a=this.bones[c])a.parent&&a.parent.isBone?(a.matrix.getInverse(a.parent.matrixWorld),a.matrix.multiply(a.matrixWorld)):a.matrix.copy(a.matrixWorld),a.matrix.decompose(a.position,a.quaternion,a.scale)},update:function(){var a=new K,b=new K;return function(){for(var c=this.bones,d=this.boneInverses,e=this.boneMatrices,f=this.boneTexture,g=0,h=c.length;g<h;g++)a.multiplyMatrices(c[g]?c[g].matrixWorld:b,d[g]),a.toArray(e,16*g);void 0!==f&&(f.needsUpdate=!0)}}(),clone:function(){return new Ec(this.bones,
this.boneInverses)}});pd.prototype=Object.assign(Object.create(A.prototype),{constructor:pd,isBone:!0});qd.prototype=Object.assign(Object.create(pa.prototype),{constructor:qd,isSkinnedMesh:!0,initBones:function(){var a=[],b;if(this.geometry&&void 0!==this.geometry.bones){var c=0;for(b=this.geometry.bones.length;c<b;c++){var d=this.geometry.bones[c];var e=new pd;a.push(e);e.name=d.name;e.position.fromArray(d.pos);e.quaternion.fromArray(d.rotq);void 0!==d.scl&&e.scale.fromArray(d.scl)}c=0;for(b=this.geometry.bones.length;c<
b;c++)d=this.geometry.bones[c],-1!==d.parent&&null!==d.parent&&void 0!==a[d.parent]?a[d.parent].add(a[c]):this.add(a[c])}this.updateMatrixWorld(!0);return a},bind:function(a,b){this.skeleton=a;void 0===b&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),b=this.matrixWorld);this.bindMatrix.copy(b);this.bindMatrixInverse.getInverse(b)},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){var a;if(this.geometry&&this.geometry.isGeometry)for(a=0;a<this.geometry.skinWeights.length;a++){var b=
this.geometry.skinWeights[a];var c=1/b.manhattanLength();Infinity!==c?b.multiplyScalar(c):b.set(1,0,0,0)}else if(this.geometry&&this.geometry.isBufferGeometry){var b=new da,d=this.geometry.attributes.skinWeight;for(a=0;a<d.count;a++)b.x=d.getX(a),b.y=d.getY(a),b.z=d.getZ(a),b.w=d.getW(a),c=1/b.manhattanLength(),Infinity!==c?b.multiplyScalar(c):b.set(1,0,0,0),d.setXYZW(a,b.x,b.y,b.z,b.w)}},updateMatrixWorld:function(a){pa.prototype.updateMatrixWorld.call(this,a);"attached"===this.bindMode?this.bindMatrixInverse.getInverse(this.matrixWorld):
"detached"===this.bindMode?this.bindMatrixInverse.getInverse(this.bindMatrix):console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},clone:function(){return(new this.constructor(this.geometry,this.material)).copy(this)}});O.prototype=Object.create(Q.prototype);O.prototype.constructor=O;O.prototype.isLineBasicMaterial=!0;O.prototype.copy=function(a){Q.prototype.copy.call(this,a);this.color.copy(a.color);this.linewidth=a.linewidth;this.linecap=a.linecap;this.linejoin=a.linejoin;return this};
ma.prototype=Object.assign(Object.create(A.prototype),{constructor:ma,isLine:!0,raycast:function(){var a=new K,b=new lb,c=new Da;return function(d,e){var f=d.linePrecision,f=f*f,g=this.geometry,h=this.matrixWorld;null===g.boundingSphere&&g.computeBoundingSphere();c.copy(g.boundingSphere);c.applyMatrix4(h);if(!1!==d.ray.intersectsSphere(c)){a.getInverse(h);b.copy(d.ray).applyMatrix4(a);var k=new p,l=new p,h=new p,q=new p,n=this&&this.isLineSegments?2:1;if(g.isBufferGeometry){var m=g.index;var r=g.attributes.position.array;
if(null!==m)for(var u=m.array,g=0,v=u.length-1;g<v;g+=n)m=u[g+1],k.fromArray(r,3*u[g]),l.fromArray(r,3*m),m=b.distanceSqToSegment(k,l,q,h),m>f||(q.applyMatrix4(this.matrixWorld),m=d.ray.origin.distanceTo(q),m<d.near||m>d.far||e.push({distance:m,point:h.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this}));else for(g=0,v=r.length/3-1;g<v;g+=n)k.fromArray(r,3*g),l.fromArray(r,3*g+3),m=b.distanceSqToSegment(k,l,q,h),m>f||(q.applyMatrix4(this.matrixWorld),m=d.ray.origin.distanceTo(q),
m<d.near||m>d.far||e.push({distance:m,point:h.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this}))}else if(g.isGeometry)for(k=g.vertices,l=k.length,g=0;g<l-1;g+=n)m=b.distanceSqToSegment(k[g],k[g+1],q,h),m>f||(q.applyMatrix4(this.matrixWorld),m=d.ray.origin.distanceTo(q),m<d.near||m>d.far||e.push({distance:m,point:h.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this}))}}}(),clone:function(){return(new this.constructor(this.geometry,
this.material)).copy(this)}});ca.prototype=Object.assign(Object.create(ma.prototype),{constructor:ca,isLineSegments:!0});rd.prototype=Object.assign(Object.create(ma.prototype),{constructor:rd,isLineLoop:!0});Ba.prototype=Object.create(Q.prototype);Ba.prototype.constructor=Ba;Ba.prototype.isPointsMaterial=!0;Ba.prototype.copy=function(a){Q.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.size=a.size;this.sizeAttenuation=a.sizeAttenuation;return this};Qb.prototype=Object.assign(Object.create(A.prototype),
{constructor:Qb,isPoints:!0,raycast:function(){var a=new K,b=new lb,c=new Da;return function(d,e){function f(a,c){var f=b.distanceSqToPoint(a);if(f<m){a=b.closestPointToPoint(a);a.applyMatrix4(k);var h=d.ray.origin.distanceTo(a);h<d.near||h>d.far||e.push({distance:h,distanceToRay:Math.sqrt(f),point:a.clone(),index:c,face:null,object:g})}}var g=this,h=this.geometry,k=this.matrixWorld,l=d.params.Points.threshold;null===h.boundingSphere&&h.computeBoundingSphere();c.copy(h.boundingSphere);c.applyMatrix4(k);
c.radius+=l;if(!1!==d.ray.intersectsSphere(c)){a.getInverse(k);b.copy(d.ray).applyMatrix4(a);var l=l/((this.scale.x+this.scale.y+this.scale.z)/3),m=l*l,l=new p;if(h.isBufferGeometry){var n=h.index,h=h.attributes.position.array;if(null!==n)for(var t=n.array,n=0,r=t.length;n<r;n++){var u=t[n];l.fromArray(h,3*u);f(l,u)}else for(n=0,t=h.length/3;n<t;n++)l.fromArray(h,3*n),f(l,n)}else for(l=h.vertices,n=0,t=l.length;n<t;n++)f(l[n],n)}}}(),clone:function(){return(new this.constructor(this.geometry,this.material)).copy(this)}});
Fc.prototype=Object.assign(Object.create(A.prototype),{constructor:Fc});sd.prototype=Object.create(ea.prototype);sd.prototype.constructor=sd;Rb.prototype=Object.create(ea.prototype);Rb.prototype.constructor=Rb;Rb.prototype.isCompressedTexture=!0;Gc.prototype=Object.create(ea.prototype);Gc.prototype.constructor=Gc;Gc.prototype.isDepthTexture=!0;Sb.prototype=Object.create(D.prototype);Sb.prototype.constructor=Sb;Hc.prototype=Object.create(N.prototype);Hc.prototype.constructor=Hc;Tb.prototype=Object.create(D.prototype);
Tb.prototype.constructor=Tb;Ic.prototype=Object.create(N.prototype);Ic.prototype.constructor=Ic;qa.prototype=Object.create(D.prototype);qa.prototype.constructor=qa;Jc.prototype=Object.create(N.prototype);Jc.prototype.constructor=Jc;Ub.prototype=Object.create(qa.prototype);Ub.prototype.constructor=Ub;Kc.prototype=Object.create(N.prototype);Kc.prototype.constructor=Kc;nb.prototype=Object.create(qa.prototype);nb.prototype.constructor=nb;Lc.prototype=Object.create(N.prototype);Lc.prototype.constructor=
Lc;Vb.prototype=Object.create(qa.prototype);Vb.prototype.constructor=Vb;Mc.prototype=Object.create(N.prototype);Mc.prototype.constructor=Mc;Wb.prototype=Object.create(qa.prototype);Wb.prototype.constructor=Wb;Nc.prototype=Object.create(N.prototype);Nc.prototype.constructor=Nc;Xb.prototype=Object.create(D.prototype);Xb.prototype.constructor=Xb;Oc.prototype=Object.create(N.prototype);Oc.prototype.constructor=Oc;Yb.prototype=Object.create(D.prototype);Yb.prototype.constructor=Yb;Pc.prototype=Object.create(N.prototype);
Pc.prototype.constructor=Pc;Zb.prototype=Object.create(D.prototype);Zb.prototype.constructor=Zb;var Ha={area:function(a){for(var b=a.length,c=0,d=b-1,e=0;e<b;d=e++)c+=a[d].x*a[e].y-a[e].x*a[d].y;return.5*c},triangulate:function(){return function(a,b){var c=a.length;if(3>c)return null;var d=[],e=[],f=[],g;if(0<Ha.area(a))for(g=0;g<c;g++)e[g]=g;else for(g=0;g<c;g++)e[g]=c-1-g;var h=2*c;for(g=c-1;2<c;){if(0>=h--){console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");break}var k=
g;c<=k&&(k=0);g=k+1;c<=g&&(g=0);var l=g+1;c<=l&&(l=0);a:{var m;var n=a[e[k]].x;var p=a[e[k]].y;var r=a[e[g]].x;var u=a[e[g]].y;var v=a[e[l]].x;var w=a[e[l]].y;if(0>=(r-n)*(w-p)-(u-p)*(v-n))var x=!1;else{var z=v-r;var y=w-u;var B=n-v;var C=p-w;var A=r-n;x=u-p;for(m=0;m<c;m++){var D=a[e[m]].x;var E=a[e[m]].y;if(!(D===n&&E===p||D===r&&E===u||D===v&&E===w)){var H=D-n;var N=E-p;var K=D-r;var L=E-u;D-=v;E-=w;L=z*L-y*K;N=A*N-x*H;D=B*E-C*D;if(L>=-Number.EPSILON&&D>=-Number.EPSILON&&N>=-Number.EPSILON){x=
!1;break a}}}x=!0}}if(x){d.push([a[e[k]],a[e[g]],a[e[l]]]);f.push([e[k],e[g],e[l]]);k=g;for(l=g+1;l<c;k++,l++)e[k]=e[l];c--;h=2*c}}return b?f:d}}(),triangulateShape:function(a,b){function c(a){var b=a.length;2<b&&a[b-1].equals(a[0])&&a.pop()}function d(a,b,c){return a.x!==b.x?a.x<b.x?a.x<=c.x&&c.x<=b.x:b.x<=c.x&&c.x<=a.x:a.y<b.y?a.y<=c.y&&c.y<=b.y:b.y<=c.y&&c.y<=a.y}function e(a,b,c,e,f){var g=b.x-a.x,h=b.y-a.y,k=e.x-c.x,l=e.y-c.y,m=a.x-c.x,n=a.y-c.y,q=h*k-g*l,p=h*m-g*n;if(Math.abs(q)>Number.EPSILON){if(0<
q){if(0>p||p>q)return[];k=l*m-k*n;if(0>k||k>q)return[]}else{if(0<p||p<q)return[];k=l*m-k*n;if(0<k||k<q)return[]}if(0===k)return!f||0!==p&&p!==q?[a]:[];if(k===q)return!f||0!==p&&p!==q?[b]:[];if(0===p)return[c];if(p===q)return[e];f=k/q;return[{x:a.x+f*g,y:a.y+f*h}]}if(0!==p||l*m!==k*n)return[];h=0===g&&0===h;k=0===k&&0===l;if(h&&k)return a.x!==c.x||a.y!==c.y?[]:[a];if(h)return d(c,e,a)?[a]:[];if(k)return d(a,b,c)?[c]:[];0!==g?(a.x<b.x?(g=a,k=a.x,h=b,a=b.x):(g=b,k=b.x,h=a,a=a.x),c.x<e.x?(b=c,q=c.x,l=
e,c=e.x):(b=e,q=e.x,l=c,c=c.x)):(a.y<b.y?(g=a,k=a.y,h=b,a=b.y):(g=b,k=b.y,h=a,a=a.y),c.y<e.y?(b=c,q=c.y,l=e,c=e.y):(b=e,q=e.y,l=c,c=c.y));return k<=q?a<q?[]:a===q?f?[]:[b]:a<=c?[b,h]:[b,l]:k>c?[]:k===c?f?[]:[g]:a<=c?[g,h]:[g,l]}function f(a,b,c,d){var e=b.x-a.x,f=b.y-a.y;b=c.x-a.x;c=c.y-a.y;var g=d.x-a.x;d=d.y-a.y;a=e*c-f*b;e=e*d-f*g;return Math.abs(a)>Number.EPSILON?(b=g*c-d*b,0<a?0<=e&&0<=b:0<=e||0<=b):0<e}c(a);b.forEach(c);var g,h={},k=a.concat();var l=0;for(g=b.length;l<g;l++)Array.prototype.push.apply(k,
b[l]);l=0;for(g=k.length;l<g;l++){var m=k[l].x+":"+k[l].y;void 0!==h[m]&&console.warn("THREE.ShapeUtils: Duplicate point",m,l);h[m]=l}l=function(a,b){function c(a,b){var c=h.length-1,d=a-1;0>d&&(d=c);var e=a+1;e>c&&(e=0);c=f(h[a],h[d],h[e],D[b]);if(!c)return!1;c=D.length-1;d=b-1;0>d&&(d=c);e=b+1;e>c&&(e=0);return(c=f(D[b],D[d],D[e],h[a]))?!0:!1}function d(a,b){var c;for(c=0;c<h.length;c++){var d=c+1;d%=h.length;d=e(a,b,h[c],h[d],!0);if(0<d.length)return!0}return!1}function g(a,c){var d,f;for(d=0;d<
k.length;d++){var g=b[k[d]];for(f=0;f<g.length;f++){var h=f+1;h%=g.length;h=e(a,c,g[f],g[h],!0);if(0<h.length)return!0}}return!1}var h=a.concat(),k=[],l,m;a=[];var q,n=0;for(l=b.length;n<l;n++)k.push(n);var p=0;for(var t=2*k.length;0<k.length;){t--;if(0>t){console.log('THREE.ShapeUtils: Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!');break}for(m=p;m<h.length;m++){var y=h[m];l=-1;for(n=0;n<k.length;n++){var C=k[n];var A=y.x+":"+y.y+":"+C;if(void 0===a[A]){var D=
b[C];for(q=0;q<D.length;q++)if(C=D[q],c(m,q)&&!d(y,C)&&!g(y,C)){l=q;k.splice(n,1);p=h.slice(0,m+1);C=h.slice(m);q=D.slice(l);var E=D.slice(0,l+1);h=p.concat(q).concat(E).concat(C);p=m;break}if(0<=l)break;a[A]=!0}}if(0<=l)break}}return h}(a,b);k=Ha.triangulate(l,!1);l=0;for(g=k.length;l<g;l++)for(b=k[l],a=0;3>a;a++)m=b[a].x+":"+b[a].y,m=h[m],void 0!==m&&(b[a]=m);return k.concat()},isClockWise:function(a){return 0>Ha.area(a)}};$a.prototype=Object.create(N.prototype);$a.prototype.constructor=$a;Ga.prototype=
Object.create(D.prototype);Ga.prototype.constructor=Ga;Ga.prototype.getArrays=function(){var a=this.getAttribute("position"),a=a?Array.prototype.slice.call(a.array):[],b=this.getAttribute("uv"),b=b?Array.prototype.slice.call(b.array):[],c=this.index,c=c?Array.prototype.slice.call(c.array):[];return{position:a,uv:b,index:c}};Ga.prototype.addShapeList=function(a,b){var c=a.length;b.arrays=this.getArrays();for(var d=0;d<c;d++)this.addShape(a[d],b);this.setIndex(b.arrays.index);this.addAttribute("position",
new y(b.arrays.position,3));this.addAttribute("uv",new y(b.arrays.uv,2))};Ga.prototype.addShape=function(a,b){function c(a,b,c){b||console.error("THREE.ExtrudeGeometry: vec does not exist");return b.clone().multiplyScalar(c).add(a)}function d(a,b,c){var d=a.x-b.x;var e=a.y-b.y;var f=c.x-a.x;var g=c.y-a.y,h=d*d+e*e;if(Math.abs(d*g-e*f)>Number.EPSILON){var k=Math.sqrt(h),l=Math.sqrt(f*f+g*g),h=b.x-e/k;b=b.y+d/k;g=((c.x-g/l-h)*g-(c.y+f/l-b)*f)/(d*g-e*f);f=h+d*g-a.x;d=b+e*g-a.y;e=f*f+d*d;if(2>=e)return new C(f,
d);e=Math.sqrt(e/2)}else a=!1,d>Number.EPSILON?f>Number.EPSILON&&(a=!0):d<-Number.EPSILON?f<-Number.EPSILON&&(a=!0):Math.sign(e)===Math.sign(g)&&(a=!0),a?(f=-e,e=Math.sqrt(h)):(f=d,d=e,e=Math.sqrt(h/2));return new C(f/e,d/e)}function e(a,b){for(G=a.length;0<=--G;){var c=G;var d=G-1;0>d&&(d=a.length-1);var e,f=A+2*w;for(e=0;e<f;e++){var g=Z*e,l=Z*(e+1),q=b+d+g,n=b+d+l,l=b+c+l;h(b+c+g);h(q);h(l);h(q);h(n);h(l);g=m.length/3;g=E.generateSideWallUV(R,m,g-6,g-3,g-2,g-1);k(g[0]);k(g[1]);k(g[3]);k(g[1]);
k(g[2]);k(g[3])}}}function f(a,b,c){r.push(a);r.push(b);r.push(c)}function g(a,b,c){h(a);h(b);h(c);a=m.length/3;a=E.generateTopUV(R,m,a-3,a-2,a-1);k(a[0]);k(a[1]);k(a[2])}function h(a){n.push(m.length/3);m.push(r[3*a+0]);m.push(r[3*a+1]);m.push(r[3*a+2])}function k(a){t.push(a.x);t.push(a.y)}var l=b.arrays?b.arrays:this.getArrays(),m=l.position,n=l.index,t=l.uv,r=[],l=void 0!==b.amount?b.amount:100,u=void 0!==b.bevelThickness?b.bevelThickness:6,v=void 0!==b.bevelSize?b.bevelSize:u-2,w=void 0!==b.bevelSegments?
b.bevelSegments:3,x=void 0!==b.bevelEnabled?b.bevelEnabled:!0,z=void 0!==b.curveSegments?b.curveSegments:12,A=void 0!==b.steps?b.steps:1,B=b.extrudePath,D=!1,E=void 0!==b.UVGenerator?b.UVGenerator:$a.WorldUVGenerator;if(B){var H=B.getSpacedPoints(A);D=!0;x=!1;var N=void 0!==b.frames?b.frames:B.computeFrenetFrames(A,!1);var K=new p;var Q=new p;var P=new p}x||(v=u=w=0);var L,R=this,z=a.extractPoints(z);a=z.shape;var O=z.holes;if(!Ha.isClockWise(a)){a=a.reverse();var M=0;for(L=O.length;M<L;M++){var V=
O[M];Ha.isClockWise(V)&&(O[M]=V.reverse())}}var S=Ha.triangulateShape(a,O),W=a;M=0;for(L=O.length;M<L;M++)V=O[M],a=a.concat(V);var aa,Z=a.length,U,ca=S.length,z=[],G=0;var X=W.length;var fa=X-1;for(aa=G+1;G<X;G++,fa++,aa++)fa===X&&(fa=0),aa===X&&(aa=0),z[G]=d(W[G],W[fa],W[aa]);var B=[],ea=z.concat();M=0;for(L=O.length;M<L;M++){V=O[M];var da=[];G=0;X=V.length;fa=X-1;for(aa=G+1;G<X;G++,fa++,aa++)fa===X&&(fa=0),aa===X&&(aa=0),da[G]=d(V[G],V[fa],V[aa]);B.push(da);ea=ea.concat(da)}for(fa=0;fa<w;fa++){X=
fa/w;var ga=u*Math.cos(X*Math.PI/2);aa=v*Math.sin(X*Math.PI/2);G=0;for(X=W.length;G<X;G++){var T=c(W[G],z[G],aa);f(T.x,T.y,-ga)}M=0;for(L=O.length;M<L;M++)for(V=O[M],da=B[M],G=0,X=V.length;G<X;G++)T=c(V[G],da[G],aa),f(T.x,T.y,-ga)}aa=v;for(G=0;G<Z;G++)T=x?c(a[G],ea[G],aa):a[G],D?(Q.copy(N.normals[0]).multiplyScalar(T.x),K.copy(N.binormals[0]).multiplyScalar(T.y),P.copy(H[0]).add(Q).add(K),f(P.x,P.y,P.z)):f(T.x,T.y,0);for(X=1;X<=A;X++)for(G=0;G<Z;G++)T=x?c(a[G],ea[G],aa):a[G],D?(Q.copy(N.normals[X]).multiplyScalar(T.x),
K.copy(N.binormals[X]).multiplyScalar(T.y),P.copy(H[X]).add(Q).add(K),f(P.x,P.y,P.z)):f(T.x,T.y,l/A*X);for(fa=w-1;0<=fa;fa--){X=fa/w;ga=u*Math.cos(X*Math.PI/2);aa=v*Math.sin(X*Math.PI/2);G=0;for(X=W.length;G<X;G++)T=c(W[G],z[G],aa),f(T.x,T.y,l+ga);M=0;for(L=O.length;M<L;M++)for(V=O[M],da=B[M],G=0,X=V.length;G<X;G++)T=c(V[G],da[G],aa),D?f(T.x,T.y+H[A-1].y,H[A-1].x+ga):f(T.x,T.y,l+ga)}(function(){var a=m.length/3;if(x){var c=0*Z;for(G=0;G<ca;G++)U=S[G],g(U[2]+c,U[1]+c,U[0]+c);c=Z*(A+2*w);for(G=0;G<
ca;G++)U=S[G],g(U[0]+c,U[1]+c,U[2]+c)}else{for(G=0;G<ca;G++)U=S[G],g(U[2],U[1],U[0]);for(G=0;G<ca;G++)U=S[G],g(U[0]+Z*A,U[1]+Z*A,U[2]+Z*A)}R.addGroup(a,m.length/3-a,void 0!==b.material?b.material:0)})();(function(){var a=m.length/3,c=0;e(W,c);c+=W.length;M=0;for(L=O.length;M<L;M++)V=O[M],e(V,c),c+=V.length;R.addGroup(a,m.length/3-a,void 0!==b.extrudeMaterial?b.extrudeMaterial:1)})();b.arrays||(this.setIndex(n),this.addAttribute("position",new y(m,3)),this.addAttribute("uv",new y(b.arrays.uv,2)))};
$a.WorldUVGenerator={generateTopUV:function(a,b,c,d,e){a=b[3*d];d=b[3*d+1];var f=b[3*e];e=b[3*e+1];return[new C(b[3*c],b[3*c+1]),new C(a,d),new C(f,e)]},generateSideWallUV:function(a,b,c,d,e,f){a=b[3*c];var g=b[3*c+1];c=b[3*c+2];var h=b[3*d],k=b[3*d+1];d=b[3*d+2];var l=b[3*e],m=b[3*e+1];e=b[3*e+2];var n=b[3*f],p=b[3*f+1];b=b[3*f+2];return.01>Math.abs(g-k)?[new C(a,1-c),new C(h,1-d),new C(l,1-e),new C(n,1-b)]:[new C(g,1-c),new C(k,1-d),new C(m,1-e),new C(p,1-b)]}};Qc.prototype=Object.create(N.prototype);
Qc.prototype.constructor=Qc;$b.prototype=Object.create(Ga.prototype);$b.prototype.constructor=$b;Rc.prototype=Object.create(N.prototype);Rc.prototype.constructor=Rc;ob.prototype=Object.create(D.prototype);ob.prototype.constructor=ob;Sc.prototype=Object.create(N.prototype);Sc.prototype.constructor=Sc;ac.prototype=Object.create(D.prototype);ac.prototype.constructor=ac;Tc.prototype=Object.create(N.prototype);Tc.prototype.constructor=Tc;bc.prototype=Object.create(D.prototype);bc.prototype.constructor=
bc;cc.prototype=Object.create(N.prototype);cc.prototype.constructor=cc;dc.prototype=Object.create(D.prototype);dc.prototype.constructor=dc;ec.prototype=Object.create(D.prototype);ec.prototype.constructor=ec;pb.prototype=Object.create(N.prototype);pb.prototype.constructor=pb;Sa.prototype=Object.create(D.prototype);Sa.prototype.constructor=Sa;Uc.prototype=Object.create(pb.prototype);Uc.prototype.constructor=Uc;Vc.prototype=Object.create(Sa.prototype);Vc.prototype.constructor=Vc;Wc.prototype=Object.create(N.prototype);
Wc.prototype.constructor=Wc;fc.prototype=Object.create(D.prototype);fc.prototype.constructor=fc;var Ca=Object.freeze({WireframeGeometry:Sb,ParametricGeometry:Hc,ParametricBufferGeometry:Tb,TetrahedronGeometry:Jc,TetrahedronBufferGeometry:Ub,OctahedronGeometry:Kc,OctahedronBufferGeometry:nb,IcosahedronGeometry:Lc,IcosahedronBufferGeometry:Vb,DodecahedronGeometry:Mc,DodecahedronBufferGeometry:Wb,PolyhedronGeometry:Ic,PolyhedronBufferGeometry:qa,TubeGeometry:Nc,TubeBufferGeometry:Xb,TorusKnotGeometry:Oc,
TorusKnotBufferGeometry:Yb,TorusGeometry:Pc,TorusBufferGeometry:Zb,TextGeometry:Qc,TextBufferGeometry:$b,SphereGeometry:Rc,SphereBufferGeometry:ob,RingGeometry:Sc,RingBufferGeometry:ac,PlaneGeometry:Ac,PlaneBufferGeometry:kb,LatheGeometry:Tc,LatheBufferGeometry:bc,ShapeGeometry:cc,ShapeBufferGeometry:dc,ExtrudeGeometry:$a,ExtrudeBufferGeometry:Ga,EdgesGeometry:ec,ConeGeometry:Uc,ConeBufferGeometry:Vc,CylinderGeometry:pb,CylinderBufferGeometry:Sa,CircleGeometry:Wc,CircleBufferGeometry:fc,BoxGeometry:Lb,
BoxBufferGeometry:jb});gc.prototype=Object.create(Q.prototype);gc.prototype.constructor=gc;gc.prototype.isShadowMaterial=!0;hc.prototype=Object.create(oa.prototype);hc.prototype.constructor=hc;hc.prototype.isRawShaderMaterial=!0;Ma.prototype=Object.create(Q.prototype);Ma.prototype.constructor=Ma;Ma.prototype.isMeshStandardMaterial=!0;Ma.prototype.copy=function(a){Q.prototype.copy.call(this,a);this.defines={STANDARD:""};this.color.copy(a.color);this.roughness=a.roughness;this.metalness=a.metalness;
this.map=a.map;this.lightMap=a.lightMap;this.lightMapIntensity=a.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.emissive.copy(a.emissive);this.emissiveMap=a.emissiveMap;this.emissiveIntensity=a.emissiveIntensity;this.bumpMap=a.bumpMap;this.bumpScale=a.bumpScale;this.normalMap=a.normalMap;this.normalScale.copy(a.normalScale);this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;this.roughnessMap=a.roughnessMap;
this.metalnessMap=a.metalnessMap;this.alphaMap=a.alphaMap;this.envMap=a.envMap;this.envMapIntensity=a.envMapIntensity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};qb.prototype=Object.create(Ma.prototype);qb.prototype.constructor=qb;qb.prototype.isMeshPhysicalMaterial=
!0;qb.prototype.copy=function(a){Ma.prototype.copy.call(this,a);this.defines={PHYSICAL:""};this.reflectivity=a.reflectivity;this.clearCoat=a.clearCoat;this.clearCoatRoughness=a.clearCoatRoughness;return this};Ia.prototype=Object.create(Q.prototype);Ia.prototype.constructor=Ia;Ia.prototype.isMeshPhongMaterial=!0;Ia.prototype.copy=function(a){Q.prototype.copy.call(this,a);this.color.copy(a.color);this.specular.copy(a.specular);this.shininess=a.shininess;this.map=a.map;this.lightMap=a.lightMap;this.lightMapIntensity=
a.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.emissive.copy(a.emissive);this.emissiveMap=a.emissiveMap;this.emissiveIntensity=a.emissiveIntensity;this.bumpMap=a.bumpMap;this.bumpScale=a.bumpScale;this.normalMap=a.normalMap;this.normalScale.copy(a.normalScale);this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;this.specularMap=a.specularMap;this.alphaMap=a.alphaMap;this.envMap=a.envMap;this.combine=
a.combine;this.reflectivity=a.reflectivity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};rb.prototype=Object.create(Ia.prototype);rb.prototype.constructor=rb;rb.prototype.isMeshToonMaterial=!0;rb.prototype.copy=function(a){Ia.prototype.copy.call(this,
a);this.gradientMap=a.gradientMap;return this};sb.prototype=Object.create(Q.prototype);sb.prototype.constructor=sb;sb.prototype.isMeshNormalMaterial=!0;sb.prototype.copy=function(a){Q.prototype.copy.call(this,a);this.bumpMap=a.bumpMap;this.bumpScale=a.bumpScale;this.normalMap=a.normalMap;this.normalScale.copy(a.normalScale);this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;
this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};tb.prototype=Object.create(Q.prototype);tb.prototype.constructor=tb;tb.prototype.isMeshLambertMaterial=!0;tb.prototype.copy=function(a){Q.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.lightMap=a.lightMap;this.lightMapIntensity=a.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.emissive.copy(a.emissive);this.emissiveMap=a.emissiveMap;this.emissiveIntensity=
a.emissiveIntensity;this.specularMap=a.specularMap;this.alphaMap=a.alphaMap;this.envMap=a.envMap;this.combine=a.combine;this.reflectivity=a.reflectivity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};ub.prototype=Object.create(O.prototype);ub.prototype.constructor=
ub;ub.prototype.isLineDashedMaterial=!0;ub.prototype.copy=function(a){O.prototype.copy.call(this,a);this.scale=a.scale;this.dashSize=a.dashSize;this.gapSize=a.gapSize;return this};var tg=Object.freeze({ShadowMaterial:gc,SpriteMaterial:Za,RawShaderMaterial:hc,ShaderMaterial:oa,PointsMaterial:Ba,MeshPhysicalMaterial:qb,MeshStandardMaterial:Ma,MeshPhongMaterial:Ia,MeshToonMaterial:rb,MeshNormalMaterial:sb,MeshLambertMaterial:tb,MeshDepthMaterial:Wa,MeshDistanceMaterial:Xa,MeshBasicMaterial:va,LineDashedMaterial:ub,
LineBasicMaterial:O,Material:Q}),jd={enabled:!1,files:{},add:function(a,b){!1!==this.enabled&&(this.files[a]=b)},get:function(a){if(!1!==this.enabled)return this.files[a]},remove:function(a){delete this.files[a]},clear:function(){this.files={}}},wa=new Yd,Ta={};Object.assign(Ja.prototype,{load:function(a,b,c,d){void 0===a&&(a="");void 0!==this.path&&(a=this.path+a);a=this.manager.resolveURL(a);var e=this,f=jd.get(a);if(void 0!==f)return e.manager.itemStart(a),setTimeout(function(){b&&b(f);e.manager.itemEnd(a)},
0),f;if(void 0!==Ta[a])Ta[a].push({onLoad:b,onProgress:c,onError:d});else{var g=a.match(/^data:(.*?)(;base64)?,(.*)$/);if(g){c=g[1];var h=!!g[2],g=g[3],g=window.decodeURIComponent(g);h&&(g=window.atob(g));try{var k=(this.responseType||"").toLowerCase();switch(k){case "arraybuffer":case "blob":for(var l=new Uint8Array(g.length),h=0;h<g.length;h++)l[h]=g.charCodeAt(h);var m="blob"===k?new Blob([l.buffer],{type:c}):l.buffer;break;case "document":m=(new DOMParser).parseFromString(g,c);break;case "json":m=
JSON.parse(g);break;default:m=g}window.setTimeout(function(){b&&b(m);e.manager.itemEnd(a)},0)}catch(t){window.setTimeout(function(){d&&d(t);e.manager.itemEnd(a);e.manager.itemError(a)},0)}}else{Ta[a]=[];Ta[a].push({onLoad:b,onProgress:c,onError:d});var n=new XMLHttpRequest;n.open("GET",a,!0);n.addEventListener("load",function(b){var c=b.target.response;jd.add(a,c);var d=Ta[a];delete Ta[a];if(200===this.status){for(var f=0,g=d.length;f<g;f++){var h=d[f];if(h.onLoad)h.onLoad(c)}e.manager.itemEnd(a)}else if(0===
this.status){console.warn("THREE.FileLoader: HTTP Status 0 received.");f=0;for(g=d.length;f<g;f++)if(h=d[f],h.onLoad)h.onLoad(c);e.manager.itemEnd(a)}else{f=0;for(g=d.length;f<g;f++)if(h=d[f],h.onError)h.onError(b);e.manager.itemEnd(a);e.manager.itemError(a)}},!1);n.addEventListener("progress",function(b){for(var c=Ta[a],d=0,e=c.length;d<e;d++){var f=c[d];if(f.onProgress)f.onProgress(b)}},!1);n.addEventListener("error",function(b){var c=Ta[a];delete Ta[a];for(var d=0,f=c.length;d<f;d++){var g=c[d];
if(g.onError)g.onError(b)}e.manager.itemEnd(a);e.manager.itemError(a)},!1);void 0!==this.responseType&&(n.responseType=this.responseType);void 0!==this.withCredentials&&(n.withCredentials=this.withCredentials);n.overrideMimeType&&n.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(h in this.requestHeader)n.setRequestHeader(h,this.requestHeader[h]);n.send(null)}e.manager.itemStart(a);return n}},setPath:function(a){this.path=a;return this},setResponseType:function(a){this.responseType=
a;return this},setWithCredentials:function(a){this.withCredentials=a;return this},setMimeType:function(a){this.mimeType=a;return this},setRequestHeader:function(a){this.requestHeader=a;return this}});Object.assign(Qe.prototype,{load:function(a,b,c,d){function e(e){l.load(a[e],function(a){a=g._parser(a,!0);h[e]={width:a.width,height:a.height,format:a.format,mipmaps:a.mipmaps};f+=1;6===f&&(1===a.mipmapCount&&(k.minFilter=1006),k.format=a.format,k.needsUpdate=!0,b&&b(k))},c,d)}var f,g=this,h=[],k=new Rb;
k.image=h;var l=new Ja(this.manager);l.setPath(this.path);l.setResponseType("arraybuffer");if(Array.isArray(a))for(var m=f=0,n=a.length;m<n;++m)e(m);else l.load(a,function(a){a=g._parser(a,!0);if(a.isCubemap)for(var c=a.mipmaps.length/a.mipmapCount,d=0;d<c;d++){h[d]={mipmaps:[]};for(var e=0;e<a.mipmapCount;e++)h[d].mipmaps.push(a.mipmaps[d*a.mipmapCount+e]),h[d].format=a.format,h[d].width=a.width,h[d].height=a.height}else k.image.width=a.width,k.image.height=a.height,k.mipmaps=a.mipmaps;1===a.mipmapCount&&
(k.minFilter=1006);k.format=a.format;k.needsUpdate=!0;b&&b(k)},c,d);return k},setPath:function(a){this.path=a;return this}});Object.assign(Zd.prototype,{load:function(a,b,c,d){var e=this,f=new fb,g=new Ja(this.manager);g.setResponseType("arraybuffer");g.load(a,function(a){if(a=e._parser(a))void 0!==a.image?f.image=a.image:void 0!==a.data&&(f.image.width=a.width,f.image.height=a.height,f.image.data=a.data),f.wrapS=void 0!==a.wrapS?a.wrapS:1001,f.wrapT=void 0!==a.wrapT?a.wrapT:1001,f.magFilter=void 0!==
a.magFilter?a.magFilter:1006,f.minFilter=void 0!==a.minFilter?a.minFilter:1008,f.anisotropy=void 0!==a.anisotropy?a.anisotropy:1,void 0!==a.format&&(f.format=a.format),void 0!==a.type&&(f.type=a.type),void 0!==a.mipmaps&&(f.mipmaps=a.mipmaps),1===a.mipmapCount&&(f.minFilter=1006),f.needsUpdate=!0,b&&b(f,a)},c,d);return f}});Object.assign(Xc.prototype,{crossOrigin:"Anonymous",load:function(a,b,c,d){void 0===a&&(a="");void 0!==this.path&&(a=this.path+a);a=this.manager.resolveURL(a);var e=this,f=jd.get(a);
if(void 0!==f)return e.manager.itemStart(a),setTimeout(function(){b&&b(f);e.manager.itemEnd(a)},0),f;c=document.createElementNS("http://www.w3.org/1999/xhtml","img");c.addEventListener("load",function(){jd.add(a,this);b&&b(this);e.manager.itemEnd(a)},!1);c.addEventListener("error",function(b){d&&d(b);e.manager.itemEnd(a);e.manager.itemError(a)},!1);"data:"!==a.substr(0,5)&&void 0!==this.crossOrigin&&(c.crossOrigin=this.crossOrigin);e.manager.itemStart(a);c.src=a;return c},setCrossOrigin:function(a){this.crossOrigin=
a;return this},setPath:function(a){this.path=a;return this}});Object.assign($d.prototype,{crossOrigin:"Anonymous",load:function(a,b,c,d){function e(c){g.load(a[c],function(a){f.images[c]=a;h++;6===h&&(f.needsUpdate=!0,b&&b(f))},void 0,d)}var f=new Ua,g=new Xc(this.manager);g.setCrossOrigin(this.crossOrigin);g.setPath(this.path);var h=0;for(c=0;c<a.length;++c)e(c);return f},setCrossOrigin:function(a){this.crossOrigin=a;return this},setPath:function(a){this.path=a;return this}});Object.assign(td.prototype,
{crossOrigin:"Anonymous",load:function(a,b,c,d){var e=new Xc(this.manager);e.setCrossOrigin(this.crossOrigin);e.setPath(this.path);var f=new ea;f.image=e.load(a,function(){var c=0<a.search(/\.(jpg|jpeg)$/)||0===a.search(/^data\:image\/jpeg/);f.format=c?1022:1023;f.needsUpdate=!0;void 0!==b&&b(f)},c,d);return f},setCrossOrigin:function(a){this.crossOrigin=a;return this},setPath:function(a){this.path=a;return this}});ga.prototype=Object.assign(Object.create(A.prototype),{constructor:ga,isLight:!0,copy:function(a){A.prototype.copy.call(this,
a);this.color.copy(a.color);this.intensity=a.intensity;return this},toJSON:function(a){a=A.prototype.toJSON.call(this,a);a.object.color=this.color.getHex();a.object.intensity=this.intensity;void 0!==this.groundColor&&(a.object.groundColor=this.groundColor.getHex());void 0!==this.distance&&(a.object.distance=this.distance);void 0!==this.angle&&(a.object.angle=this.angle);void 0!==this.decay&&(a.object.decay=this.decay);void 0!==this.penumbra&&(a.object.penumbra=this.penumbra);void 0!==this.shadow&&
(a.object.shadow=this.shadow.toJSON());return a}});ud.prototype=Object.assign(Object.create(ga.prototype),{constructor:ud,isHemisphereLight:!0,copy:function(a){ga.prototype.copy.call(this,a);this.groundColor.copy(a.groundColor);return this}});Object.assign(vb.prototype,{copy:function(a){this.camera=a.camera.clone();this.bias=a.bias;this.radius=a.radius;this.mapSize.copy(a.mapSize);return this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){var a={};0!==this.bias&&(a.bias=
this.bias);1!==this.radius&&(a.radius=this.radius);if(512!==this.mapSize.x||512!==this.mapSize.y)a.mapSize=this.mapSize.toArray();a.camera=this.camera.toJSON(!1).object;delete a.camera.matrix;return a}});vd.prototype=Object.assign(Object.create(vb.prototype),{constructor:vd,isSpotLightShadow:!0,update:function(a){var b=this.camera,c=2*R.RAD2DEG*a.angle,d=this.mapSize.width/this.mapSize.height;a=a.distance||b.far;if(c!==b.fov||d!==b.aspect||a!==b.far)b.fov=c,b.aspect=d,b.far=a,b.updateProjectionMatrix()}});
wd.prototype=Object.assign(Object.create(ga.prototype),{constructor:wd,isSpotLight:!0,copy:function(a){ga.prototype.copy.call(this,a);this.distance=a.distance;this.angle=a.angle;this.penumbra=a.penumbra;this.decay=a.decay;this.target=a.target.clone();this.shadow=a.shadow.clone();return this}});xd.prototype=Object.assign(Object.create(ga.prototype),{constructor:xd,isPointLight:!0,copy:function(a){ga.prototype.copy.call(this,a);this.distance=a.distance;this.decay=a.decay;this.shadow=a.shadow.clone();
return this}});yd.prototype=Object.assign(Object.create(vb.prototype),{constructor:yd});zd.prototype=Object.assign(Object.create(ga.prototype),{constructor:zd,isDirectionalLight:!0,copy:function(a){ga.prototype.copy.call(this,a);this.target=a.target.clone();this.shadow=a.shadow.clone();return this}});Ad.prototype=Object.assign(Object.create(ga.prototype),{constructor:Ad,isAmbientLight:!0});Bd.prototype=Object.assign(Object.create(ga.prototype),{constructor:Bd,isRectAreaLight:!0,copy:function(a){ga.prototype.copy.call(this,
a);this.width=a.width;this.height=a.height;return this},toJSON:function(a){a=ga.prototype.toJSON.call(this,a);a.object.width=this.width;a.object.height=this.height;return a}});var T={arraySlice:function(a,b,c){return T.isTypedArray(a)?new a.constructor(a.subarray(b,void 0!==c?c:a.length)):a.slice(b,c)},convertArray:function(a,b,c){return!a||!c&&a.constructor===b?a:"number"===typeof b.BYTES_PER_ELEMENT?new b(a):Array.prototype.slice.call(a)},isTypedArray:function(a){return ArrayBuffer.isView(a)&&!(a instanceof
DataView)},getKeyframeOrder:function(a){for(var b=a.length,c=Array(b),d=0;d!==b;++d)c[d]=d;c.sort(function(b,c){return a[b]-a[c]});return c},sortedArray:function(a,b,c){for(var d=a.length,e=new a.constructor(d),f=0,g=0;g!==d;++f)for(var h=c[f]*b,k=0;k!==b;++k)e[g++]=a[h+k];return e},flattenJSON:function(a,b,c,d){for(var e=1,f=a[0];void 0!==f&&void 0===f[d];)f=a[e++];if(void 0!==f){var g=f[d];if(void 0!==g)if(Array.isArray(g)){do g=f[d],void 0!==g&&(b.push(f.time),c.push.apply(c,g)),f=a[e++];while(void 0!==
f)}else if(void 0!==g.toArray){do g=f[d],void 0!==g&&(b.push(f.time),g.toArray(c,c.length)),f=a[e++];while(void 0!==f)}else{do g=f[d],void 0!==g&&(b.push(f.time),c.push(g)),f=a[e++];while(void 0!==f)}}}};Object.assign(xa.prototype,{evaluate:function(a){var b=this.parameterPositions,c=this._cachedIndex,d=b[c],e=b[c-1];a:{b:{c:{d:if(!(a<d)){for(var f=c+2;;){if(void 0===d){if(a<e)break d;this._cachedIndex=c=b.length;return this.afterEnd_(c-1,a,e)}if(c===f)break;e=d;d=b[++c];if(a<d)break b}d=b.length;
break c}if(a>=e)break a;else{f=b[1];a<f&&(c=2,e=f);for(f=c-2;;){if(void 0===e)return this._cachedIndex=0,this.beforeStart_(0,a,d);if(c===f)break;d=e;e=b[--c-1];if(a>=e)break b}d=c;c=0}}for(;c<d;)e=c+d>>>1,a<b[e]?d=e:c=e+1;d=b[c];e=b[c-1];if(void 0===e)return this._cachedIndex=0,this.beforeStart_(0,a,d);if(void 0===d)return this._cachedIndex=c=b.length,this.afterEnd_(c-1,e,a)}this._cachedIndex=c;this.intervalChanged_(c,e,d)}return this.interpolate_(c,e,a,d)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||
this.DefaultSettings_},copySampleValue_:function(a){var b=this.resultBuffer,c=this.sampleValues,d=this.valueSize;a*=d;for(var e=0;e!==d;++e)b[e]=c[a+e];return b},interpolate_:function(){throw Error("call to abstract method");},intervalChanged_:function(){}});Object.assign(xa.prototype,{beforeStart_:xa.prototype.copySampleValue_,afterEnd_:xa.prototype.copySampleValue_});Cd.prototype=Object.assign(Object.create(xa.prototype),{constructor:Cd,DefaultSettings_:{endingStart:2400,endingEnd:2400},intervalChanged_:function(a,
b,c){var d=this.parameterPositions,e=a-2,f=a+1,g=d[e],h=d[f];if(void 0===g)switch(this.getSettings_().endingStart){case 2401:e=a;g=2*b-c;break;case 2402:e=d.length-2;g=b+d[e]-d[e+1];break;default:e=a,g=c}if(void 0===h)switch(this.getSettings_().endingEnd){case 2401:f=a;h=2*c-b;break;case 2402:f=1;h=c+d[1]-d[0];break;default:f=a-1,h=b}a=.5*(c-b);d=this.valueSize;this._weightPrev=a/(b-g);this._weightNext=a/(h-c);this._offsetPrev=e*d;this._offsetNext=f*d},interpolate_:function(a,b,c,d){var e=this.resultBuffer,
f=this.sampleValues,g=this.valueSize;a*=g;var h=a-g,k=this._offsetPrev,l=this._offsetNext,m=this._weightPrev,n=this._weightNext,p=(c-b)/(d-b);c=p*p;d=c*p;b=-m*d+2*m*c-m*p;m=(1+m)*d+(-1.5-2*m)*c+(-.5+m)*p+1;p=(-1-n)*d+(1.5+n)*c+.5*p;n=n*d-n*c;for(c=0;c!==g;++c)e[c]=b*f[k+c]+m*f[h+c]+p*f[a+c]+n*f[l+c];return e}});Yc.prototype=Object.assign(Object.create(xa.prototype),{constructor:Yc,interpolate_:function(a,b,c,d){var e=this.resultBuffer,f=this.sampleValues,g=this.valueSize;a*=g;var h=a-g;b=(c-b)/(d-
b);c=1-b;for(d=0;d!==g;++d)e[d]=f[h+d]*c+f[a+d]*b;return e}});Dd.prototype=Object.assign(Object.create(xa.prototype),{constructor:Dd,interpolate_:function(a){return this.copySampleValue_(a-1)}});var eb={TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:2301,InterpolantFactoryMethodDiscrete:function(a){return new Dd(this.times,this.values,this.getValueSize(),a)},InterpolantFactoryMethodLinear:function(a){return new Yc(this.times,this.values,this.getValueSize(),a)},InterpolantFactoryMethodSmooth:function(a){return new Cd(this.times,
this.values,this.getValueSize(),a)},setInterpolation:function(a){switch(a){case 2300:var b=this.InterpolantFactoryMethodDiscrete;break;case 2301:b=this.InterpolantFactoryMethodLinear;break;case 2302:b=this.InterpolantFactoryMethodSmooth}if(void 0===b){b="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant)if(a!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw Error(b);console.warn("THREE.KeyframeTrackPrototype:",
b)}else this.createInterpolant=b},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}},getValueSize:function(){return this.values.length/this.times.length},shift:function(a){if(0!==a)for(var b=this.times,c=0,d=b.length;c!==d;++c)b[c]+=a;return this},scale:function(a){if(1!==a)for(var b=this.times,c=0,d=b.length;c!==d;++c)b[c]*=a;return this},
trim:function(a,b){for(var c=this.times,d=c.length,e=0,f=d-1;e!==d&&c[e]<a;)++e;for(;-1!==f&&c[f]>b;)--f;++f;if(0!==e||f!==d)e>=f&&(f=Math.max(f,1),e=f-1),a=this.getValueSize(),this.times=T.arraySlice(c,e,f),this.values=T.arraySlice(this.values,e*a,f*a);return this},validate:function(){var a=!0,b=this.getValueSize();0!==b-Math.floor(b)&&(console.error("THREE.KeyframeTrackPrototype: Invalid value size in track.",this),a=!1);var c=this.times,b=this.values,d=c.length;0===d&&(console.error("THREE.KeyframeTrackPrototype: Track is empty.",
this),a=!1);for(var e=null,f=0;f!==d;f++){var g=c[f];if("number"===typeof g&&isNaN(g)){console.error("THREE.KeyframeTrackPrototype: Time is not a valid number.",this,f,g);a=!1;break}if(null!==e&&e>g){console.error("THREE.KeyframeTrackPrototype: Out of order keys.",this,f,g,e);a=!1;break}e=g}if(void 0!==b&&T.isTypedArray(b))for(f=0,c=b.length;f!==c;++f)if(d=b[f],isNaN(d)){console.error("THREE.KeyframeTrackPrototype: Value is not a valid number.",this,f,d);a=!1;break}return a},optimize:function(){for(var a,
b,c=this.times,d=this.values,e=this.getValueSize(),f=2302===this.getInterpolation(),g=1,h=c.length-1,k=1;k<h;++k){a=!1;var l=c[k];if(l!==c[k+1]&&(1!==k||l!==l[0]))if(f)a=!0;else{b=k*e;for(var m=b-e,n=b+e,l=0;l!==e;++l){var p=d[b+l];if(p!==d[m+l]||p!==d[n+l]){a=!0;break}}}if(a){if(k!==g)for(c[g]=c[k],b=k*e,a=g*e,l=0;l!==e;++l)d[a+l]=d[b+l];++g}}if(0<h){c[g]=c[h];b=h*e;a=g*e;for(l=0;l!==e;++l)d[a+l]=d[b+l];++g}g!==c.length&&(this.times=T.arraySlice(c,0,g),this.values=T.arraySlice(d,0,g*e));return this}};
ic.prototype=Object.assign(Object.create(eb),{constructor:ic,ValueTypeName:"vector"});Ed.prototype=Object.assign(Object.create(xa.prototype),{constructor:Ed,interpolate_:function(a,b,c,d){var e=this.resultBuffer,f=this.sampleValues,g=this.valueSize;a*=g;b=(c-b)/(d-b);for(c=a+g;a!==c;a+=4)Z.slerpFlat(e,0,f,a-g,f,a,b);return e}});Zc.prototype=Object.assign(Object.create(eb),{constructor:Zc,ValueTypeName:"quaternion",DefaultInterpolation:2301,InterpolantFactoryMethodLinear:function(a){return new Ed(this.times,
this.values,this.getValueSize(),a)},InterpolantFactoryMethodSmooth:void 0});jc.prototype=Object.assign(Object.create(eb),{constructor:jc,ValueTypeName:"number"});Fd.prototype=Object.assign(Object.create(eb),{constructor:Fd,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:2300,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});Gd.prototype=Object.assign(Object.create(eb),{constructor:Gd,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:2300,
InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});Hd.prototype=Object.assign(Object.create(eb),{constructor:Hd,ValueTypeName:"color"});xb.prototype=eb;eb.constructor=xb;Object.assign(xb,{parse:function(a){if(void 0===a.type)throw Error("track type undefined, can not parse");var b=xb._getTrackTypeForValueTypeName(a.type);if(void 0===a.times){var c=[],d=[];T.flattenJSON(a.keys,c,d,"value");a.times=c;a.values=d}return void 0!==b.parse?b.parse(a):new b(a.name,a.times,a.values,
a.interpolation)},toJSON:function(a){var b=a.constructor;if(void 0!==b.toJSON)b=b.toJSON(a);else{var b={name:a.name,times:T.convertArray(a.times,Array),values:T.convertArray(a.values,Array)},c=a.getInterpolation();c!==a.DefaultInterpolation&&(b.interpolation=c)}b.type=a.ValueTypeName;return b},_getTrackTypeForValueTypeName:function(a){switch(a.toLowerCase()){case "scalar":case "double":case "float":case "number":case "integer":return jc;case "vector":case "vector2":case "vector3":case "vector4":return ic;
case "color":return Hd;case "quaternion":return Zc;case "bool":case "boolean":return Gd;case "string":return Fd}throw Error("Unsupported typeName: "+a);}});Object.assign(ka,{parse:function(a){for(var b=[],c=a.tracks,d=1/(a.fps||1),e=0,f=c.length;e!==f;++e)b.push(xb.parse(c[e]).scale(d));return new ka(a.name,a.duration,b)},toJSON:function(a){var b=[],c=a.tracks;a={name:a.name,duration:a.duration,tracks:b};for(var d=0,e=c.length;d!==e;++d)b.push(xb.toJSON(c[d]));return a},CreateFromMorphTargetSequence:function(a,
b,c,d){for(var e=b.length,f=[],g=0;g<e;g++){var h=[],k=[];h.push((g+e-1)%e,g,(g+1)%e);k.push(0,1,0);var l=T.getKeyframeOrder(h),h=T.sortedArray(h,1,l),k=T.sortedArray(k,1,l);d||0!==h[0]||(h.push(e),k.push(k[0]));f.push((new jc(".morphTargetInfluences["+b[g].name+"]",h,k)).scale(1/c))}return new ka(a,-1,f)},findByName:function(a,b){var c=a;Array.isArray(a)||(c=a.geometry&&a.geometry.animations||a.animations);for(a=0;a<c.length;a++)if(c[a].name===b)return c[a];return null},CreateClipsFromMorphTargetSequences:function(a,
b,c){for(var d,e={},f=/^([\w-]*?)([\d]+)$/,g=0,h=a.length;g<h;g++){var k=a[g],l=k.name.match(f);l&&1<l.length&&(d=l[1],(l=e[d])||(e[d]=l=[]),l.push(k))}a=[];for(d in e)a.push(ka.CreateFromMorphTargetSequence(d,e[d],b,c));return a},parseAnimation:function(a,b){if(!a)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;var c=function(a,b,c,d,e){if(0!==c.length){var f=[],g=[];T.flattenJSON(c,f,g,d);0!==f.length&&e.push(new a(b,f,g))}},d=[],e=a.name||"default",f=a.length||
-1,g=a.fps||30;a=a.hierarchy||[];for(var h=0;h<a.length;h++){var k=a[h].keys;if(k&&0!==k.length)if(k[0].morphTargets){for(var f={},l=0;l<k.length;l++)if(k[l].morphTargets)for(var m=0;m<k[l].morphTargets.length;m++)f[k[l].morphTargets[m]]=-1;for(var n in f){for(var p=[],r=[],m=0;m!==k[l].morphTargets.length;++m){var u=k[l];p.push(u.time);r.push(u.morphTarget===n?1:0)}d.push(new jc(".morphTargetInfluence["+n+"]",p,r))}f=f.length*(g||1)}else l=".bones["+b[h].name+"]",c(ic,l+".position",k,"pos",d),c(Zc,
l+".quaternion",k,"rot",d),c(ic,l+".scale",k,"scl",d)}return 0===d.length?null:new ka(e,f,d)}});Object.assign(ka.prototype,{resetDuration:function(){for(var a=0,b=0,c=this.tracks.length;b!==c;++b)var d=this.tracks[b],a=Math.max(a,d.times[d.times.length-1]);this.duration=a},trim:function(){for(var a=0;a<this.tracks.length;a++)this.tracks[a].trim(0,this.duration);return this},optimize:function(){for(var a=0;a<this.tracks.length;a++)this.tracks[a].optimize();return this}});Object.assign(Id.prototype,
{load:function(a,b,c,d){var e=this;(new Ja(e.manager)).load(a,function(a){b(e.parse(JSON.parse(a)))},c,d)},setTextures:function(a){this.textures=a},parse:function(a){function b(a){void 0===c[a]&&console.warn("THREE.MaterialLoader: Undefined texture",a);return c[a]}var c=this.textures,d=new tg[a.type];void 0!==a.uuid&&(d.uuid=a.uuid);void 0!==a.name&&(d.name=a.name);void 0!==a.color&&d.color.setHex(a.color);void 0!==a.roughness&&(d.roughness=a.roughness);void 0!==a.metalness&&(d.metalness=a.metalness);
void 0!==a.emissive&&d.emissive.setHex(a.emissive);void 0!==a.specular&&d.specular.setHex(a.specular);void 0!==a.shininess&&(d.shininess=a.shininess);void 0!==a.clearCoat&&(d.clearCoat=a.clearCoat);void 0!==a.clearCoatRoughness&&(d.clearCoatRoughness=a.clearCoatRoughness);void 0!==a.uniforms&&(d.uniforms=a.uniforms);void 0!==a.vertexShader&&(d.vertexShader=a.vertexShader);void 0!==a.fragmentShader&&(d.fragmentShader=a.fragmentShader);void 0!==a.vertexColors&&(d.vertexColors=a.vertexColors);void 0!==
a.fog&&(d.fog=a.fog);void 0!==a.flatShading&&(d.flatShading=a.flatShading);void 0!==a.blending&&(d.blending=a.blending);void 0!==a.side&&(d.side=a.side);void 0!==a.opacity&&(d.opacity=a.opacity);void 0!==a.transparent&&(d.transparent=a.transparent);void 0!==a.alphaTest&&(d.alphaTest=a.alphaTest);void 0!==a.depthTest&&(d.depthTest=a.depthTest);void 0!==a.depthWrite&&(d.depthWrite=a.depthWrite);void 0!==a.colorWrite&&(d.colorWrite=a.colorWrite);void 0!==a.wireframe&&(d.wireframe=a.wireframe);void 0!==
a.wireframeLinewidth&&(d.wireframeLinewidth=a.wireframeLinewidth);void 0!==a.wireframeLinecap&&(d.wireframeLinecap=a.wireframeLinecap);void 0!==a.wireframeLinejoin&&(d.wireframeLinejoin=a.wireframeLinejoin);void 0!==a.rotation&&(d.rotation=a.rotation);1!==a.linewidth&&(d.linewidth=a.linewidth);void 0!==a.dashSize&&(d.dashSize=a.dashSize);void 0!==a.gapSize&&(d.gapSize=a.gapSize);void 0!==a.scale&&(d.scale=a.scale);void 0!==a.skinning&&(d.skinning=a.skinning);void 0!==a.morphTargets&&(d.morphTargets=
a.morphTargets);void 0!==a.dithering&&(d.dithering=a.dithering);void 0!==a.visible&&(d.visible=a.visible);void 0!==a.userData&&(d.userData=a.userData);void 0!==a.shading&&(d.flatShading=1===a.shading);void 0!==a.size&&(d.size=a.size);void 0!==a.sizeAttenuation&&(d.sizeAttenuation=a.sizeAttenuation);void 0!==a.map&&(d.map=b(a.map));void 0!==a.alphaMap&&(d.alphaMap=b(a.alphaMap),d.transparent=!0);void 0!==a.bumpMap&&(d.bumpMap=b(a.bumpMap));void 0!==a.bumpScale&&(d.bumpScale=a.bumpScale);void 0!==a.normalMap&&
(d.normalMap=b(a.normalMap));if(void 0!==a.normalScale){var e=a.normalScale;!1===Array.isArray(e)&&(e=[e,e]);d.normalScale=(new C).fromArray(e)}void 0!==a.displacementMap&&(d.displacementMap=b(a.displacementMap));void 0!==a.displacementScale&&(d.displacementScale=a.displacementScale);void 0!==a.displacementBias&&(d.displacementBias=a.displacementBias);void 0!==a.roughnessMap&&(d.roughnessMap=b(a.roughnessMap));void 0!==a.metalnessMap&&(d.metalnessMap=b(a.metalnessMap));void 0!==a.emissiveMap&&(d.emissiveMap=
b(a.emissiveMap));void 0!==a.emissiveIntensity&&(d.emissiveIntensity=a.emissiveIntensity);void 0!==a.specularMap&&(d.specularMap=b(a.specularMap));void 0!==a.envMap&&(d.envMap=b(a.envMap));void 0!==a.reflectivity&&(d.reflectivity=a.reflectivity);void 0!==a.lightMap&&(d.lightMap=b(a.lightMap));void 0!==a.lightMapIntensity&&(d.lightMapIntensity=a.lightMapIntensity);void 0!==a.aoMap&&(d.aoMap=b(a.aoMap));void 0!==a.aoMapIntensity&&(d.aoMapIntensity=a.aoMapIntensity);void 0!==a.gradientMap&&(d.gradientMap=
b(a.gradientMap));return d}});Object.assign(ae.prototype,{load:function(a,b,c,d){var e=this;(new Ja(e.manager)).load(a,function(a){b(e.parse(JSON.parse(a)))},c,d)},parse:function(a){var b=new D;var c=a.data.index;void 0!==c&&(c=new gf[c.type](c.array),b.setIndex(new P(c,1)));var d=a.data.attributes;for(f in d){var e=d[f];c=new gf[e.type](e.array);b.addAttribute(f,new P(c,e.itemSize,e.normalized))}var f=a.data.groups||a.data.drawcalls||a.data.offsets;if(void 0!==f)for(c=0,d=f.length;c!==d;++c)e=f[c],
b.addGroup(e.start,e.count,e.materialIndex);a=a.data.boundingSphere;void 0!==a&&(f=new p,void 0!==a.center&&f.fromArray(a.center),b.boundingSphere=new Da(f,a.radius));return b}});var gf={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:"undefined"!==typeof Uint8ClampedArray?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};kc.Handlers={handlers:[],add:function(a,b){this.handlers.push(a,
b)},get:function(a){for(var b=this.handlers,c=0,d=b.length;c<d;c+=2){var e=b[c+1];if(b[c].test(a))return e}return null}};Object.assign(kc.prototype,{crossOrigin:void 0,extractUrlBase:function(a){a=a.split("/");if(1===a.length)return"./";a.pop();return a.join("/")+"/"},initMaterials:function(a,b,c){for(var d=[],e=0;e<a.length;++e)d[e]=this.createMaterial(a[e],b,c);return d},createMaterial:function(){var a={NoBlending:0,NormalBlending:1,AdditiveBlending:2,SubtractiveBlending:3,MultiplyBlending:4,CustomBlending:5},
b=new H,c=new td,d=new Id;return function(e,f,g){function h(a,b,d,e,h){a=f+a;var l=kc.Handlers.get(a);null!==l?a=l.load(a):(c.setCrossOrigin(g),a=c.load(a));void 0!==b&&(a.repeat.fromArray(b),1!==b[0]&&(a.wrapS=1E3),1!==b[1]&&(a.wrapT=1E3));void 0!==d&&a.offset.fromArray(d);void 0!==e&&("repeat"===e[0]&&(a.wrapS=1E3),"mirror"===e[0]&&(a.wrapS=1002),"repeat"===e[1]&&(a.wrapT=1E3),"mirror"===e[1]&&(a.wrapT=1002));void 0!==h&&(a.anisotropy=h);b=R.generateUUID();k[b]=a;return b}var k={},l={uuid:R.generateUUID(),
type:"MeshLambertMaterial"},m;for(m in e){var n=e[m];switch(m){case "DbgColor":case "DbgIndex":case "opticalDensity":case "illumination":break;case "DbgName":l.name=n;break;case "blending":l.blending=a[n];break;case "colorAmbient":case "mapAmbient":console.warn("THREE.Loader.createMaterial:",m,"is no longer supported.");break;case "colorDiffuse":l.color=b.fromArray(n).getHex();break;case "colorSpecular":l.specular=b.fromArray(n).getHex();break;case "colorEmissive":l.emissive=b.fromArray(n).getHex();
break;case "specularCoef":l.shininess=n;break;case "shading":"basic"===n.toLowerCase()&&(l.type="MeshBasicMaterial");"phong"===n.toLowerCase()&&(l.type="MeshPhongMaterial");"standard"===n.toLowerCase()&&(l.type="MeshStandardMaterial");break;case "mapDiffuse":l.map=h(n,e.mapDiffuseRepeat,e.mapDiffuseOffset,e.mapDiffuseWrap,e.mapDiffuseAnisotropy);break;case "mapDiffuseRepeat":case "mapDiffuseOffset":case "mapDiffuseWrap":case "mapDiffuseAnisotropy":break;case "mapEmissive":l.emissiveMap=h(n,e.mapEmissiveRepeat,
e.mapEmissiveOffset,e.mapEmissiveWrap,e.mapEmissiveAnisotropy);break;case "mapEmissiveRepeat":case "mapEmissiveOffset":case "mapEmissiveWrap":case "mapEmissiveAnisotropy":break;case "mapLight":l.lightMap=h(n,e.mapLightRepeat,e.mapLightOffset,e.mapLightWrap,e.mapLightAnisotropy);break;case "mapLightRepeat":case "mapLightOffset":case "mapLightWrap":case "mapLightAnisotropy":break;case "mapAO":l.aoMap=h(n,e.mapAORepeat,e.mapAOOffset,e.mapAOWrap,e.mapAOAnisotropy);break;case "mapAORepeat":case "mapAOOffset":case "mapAOWrap":case "mapAOAnisotropy":break;
case "mapBump":l.bumpMap=h(n,e.mapBumpRepeat,e.mapBumpOffset,e.mapBumpWrap,e.mapBumpAnisotropy);break;case "mapBumpScale":l.bumpScale=n;break;case "mapBumpRepeat":case "mapBumpOffset":case "mapBumpWrap":case "mapBumpAnisotropy":break;case "mapNormal":l.normalMap=h(n,e.mapNormalRepeat,e.mapNormalOffset,e.mapNormalWrap,e.mapNormalAnisotropy);break;case "mapNormalFactor":l.normalScale=[n,n];break;case "mapNormalRepeat":case "mapNormalOffset":case "mapNormalWrap":case "mapNormalAnisotropy":break;case "mapSpecular":l.specularMap=
h(n,e.mapSpecularRepeat,e.mapSpecularOffset,e.mapSpecularWrap,e.mapSpecularAnisotropy);break;case "mapSpecularRepeat":case "mapSpecularOffset":case "mapSpecularWrap":case "mapSpecularAnisotropy":break;case "mapMetalness":l.metalnessMap=h(n,e.mapMetalnessRepeat,e.mapMetalnessOffset,e.mapMetalnessWrap,e.mapMetalnessAnisotropy);break;case "mapMetalnessRepeat":case "mapMetalnessOffset":case "mapMetalnessWrap":case "mapMetalnessAnisotropy":break;case "mapRoughness":l.roughnessMap=h(n,e.mapRoughnessRepeat,
e.mapRoughnessOffset,e.mapRoughnessWrap,e.mapRoughnessAnisotropy);break;case "mapRoughnessRepeat":case "mapRoughnessOffset":case "mapRoughnessWrap":case "mapRoughnessAnisotropy":break;case "mapAlpha":l.alphaMap=h(n,e.mapAlphaRepeat,e.mapAlphaOffset,e.mapAlphaWrap,e.mapAlphaAnisotropy);break;case "mapAlphaRepeat":case "mapAlphaOffset":case "mapAlphaWrap":case "mapAlphaAnisotropy":break;case "flipSided":l.side=1;break;case "doubleSided":l.side=2;break;case "transparency":console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
l.opacity=n;break;case "depthTest":case "depthWrite":case "colorWrite":case "opacity":case "reflectivity":case "transparent":case "visible":case "wireframe":l[m]=n;break;case "vertexColors":!0===n&&(l.vertexColors=2);"face"===n&&(l.vertexColors=1);break;default:console.error("THREE.Loader.createMaterial: Unsupported",m,n)}}"MeshBasicMaterial"===l.type&&delete l.emissive;"MeshPhongMaterial"!==l.type&&delete l.specular;1>l.opacity&&(l.transparent=!0);d.setTextures(k);return d.parse(l)}}()});Object.assign(be.prototype,
{load:function(a,b,c,d){var e=this,f=this.texturePath&&"string"===typeof this.texturePath?this.texturePath:kc.prototype.extractUrlBase(a),g=new Ja(this.manager);g.setWithCredentials(this.withCredentials);g.load(a,function(c){c=JSON.parse(c);var d=c.metadata;if(void 0!==d&&(d=d.type,void 0!==d)){if("object"===d.toLowerCase()){console.error("THREE.JSONLoader: "+a+" should be loaded with THREE.ObjectLoader instead.");return}if("scene"===d.toLowerCase()){console.error("THREE.JSONLoader: "+a+" should be loaded with THREE.SceneLoader instead.");
return}}c=e.parse(c,f);b(c.geometry,c.materials)},c,d)},setTexturePath:function(a){this.texturePath=a},parse:function(){return function(a,b){void 0!==a.data&&(a=a.data);a.scale=void 0!==a.scale?1/a.scale:1;var c=new N,d=a,e,f,g,h=d.faces;var k=d.vertices;var l=d.normals,m=d.colors;var n=d.scale;var t=0;if(void 0!==d.uvs){for(e=0;e<d.uvs.length;e++)d.uvs[e].length&&t++;for(e=0;e<t;e++)c.faceVertexUvs[e]=[]}var r=0;for(g=k.length;r<g;)e=new p,e.x=k[r++]*n,e.y=k[r++]*n,e.z=k[r++]*n,c.vertices.push(e);
r=0;for(g=h.length;r<g;){k=h[r++];var u=k&1;var v=k&2;e=k&8;var w=k&16;var x=k&32;n=k&64;k&=128;if(u){u=new Pa;u.a=h[r];u.b=h[r+1];u.c=h[r+3];var z=new Pa;z.a=h[r+1];z.b=h[r+2];z.c=h[r+3];r+=4;v&&(v=h[r++],u.materialIndex=v,z.materialIndex=v);v=c.faces.length;if(e)for(e=0;e<t;e++){var y=d.uvs[e];c.faceVertexUvs[e][v]=[];c.faceVertexUvs[e][v+1]=[];for(f=0;4>f;f++){var B=h[r++];var A=y[2*B];B=y[2*B+1];A=new C(A,B);2!==f&&c.faceVertexUvs[e][v].push(A);0!==f&&c.faceVertexUvs[e][v+1].push(A)}}w&&(w=3*
h[r++],u.normal.set(l[w++],l[w++],l[w]),z.normal.copy(u.normal));if(x)for(e=0;4>e;e++)w=3*h[r++],x=new p(l[w++],l[w++],l[w]),2!==e&&u.vertexNormals.push(x),0!==e&&z.vertexNormals.push(x);n&&(n=h[r++],n=m[n],u.color.setHex(n),z.color.setHex(n));if(k)for(e=0;4>e;e++)n=h[r++],n=m[n],2!==e&&u.vertexColors.push(new H(n)),0!==e&&z.vertexColors.push(new H(n));c.faces.push(u);c.faces.push(z)}else{u=new Pa;u.a=h[r++];u.b=h[r++];u.c=h[r++];v&&(v=h[r++],u.materialIndex=v);v=c.faces.length;if(e)for(e=0;e<t;e++)for(y=
d.uvs[e],c.faceVertexUvs[e][v]=[],f=0;3>f;f++)B=h[r++],A=y[2*B],B=y[2*B+1],A=new C(A,B),c.faceVertexUvs[e][v].push(A);w&&(w=3*h[r++],u.normal.set(l[w++],l[w++],l[w]));if(x)for(e=0;3>e;e++)w=3*h[r++],x=new p(l[w++],l[w++],l[w]),u.vertexNormals.push(x);n&&(n=h[r++],u.color.setHex(m[n]));if(k)for(e=0;3>e;e++)n=h[r++],u.vertexColors.push(new H(m[n]));c.faces.push(u)}}d=a;r=void 0!==d.influencesPerVertex?d.influencesPerVertex:2;if(d.skinWeights)for(g=0,h=d.skinWeights.length;g<h;g+=r)c.skinWeights.push(new da(d.skinWeights[g],
1<r?d.skinWeights[g+1]:0,2<r?d.skinWeights[g+2]:0,3<r?d.skinWeights[g+3]:0));if(d.skinIndices)for(g=0,h=d.skinIndices.length;g<h;g+=r)c.skinIndices.push(new da(d.skinIndices[g],1<r?d.skinIndices[g+1]:0,2<r?d.skinIndices[g+2]:0,3<r?d.skinIndices[g+3]:0));c.bones=d.bones;c.bones&&0<c.bones.length&&(c.skinWeights.length!==c.skinIndices.length||c.skinIndices.length!==c.vertices.length)&&console.warn("When skinning, number of vertices ("+c.vertices.length+"), skinIndices ("+c.skinIndices.length+"), and skinWeights ("+
c.skinWeights.length+") should match.");g=a;h=g.scale;if(void 0!==g.morphTargets)for(d=0,r=g.morphTargets.length;d<r;d++)for(c.morphTargets[d]={},c.morphTargets[d].name=g.morphTargets[d].name,c.morphTargets[d].vertices=[],l=c.morphTargets[d].vertices,m=g.morphTargets[d].vertices,t=0,k=m.length;t<k;t+=3)n=new p,n.x=m[t]*h,n.y=m[t+1]*h,n.z=m[t+2]*h,l.push(n);if(void 0!==g.morphColors&&0<g.morphColors.length)for(console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'),
h=c.faces,g=g.morphColors[0].colors,d=0,r=h.length;d<r;d++)h[d].color.fromArray(g,3*d);g=a;d=[];r=[];void 0!==g.animation&&r.push(g.animation);void 0!==g.animations&&(g.animations.length?r=r.concat(g.animations):r.push(g.animations));for(g=0;g<r.length;g++)(h=ka.parseAnimation(r[g],c.bones))&&d.push(h);c.morphTargets&&(r=ka.CreateClipsFromMorphTargetSequences(c.morphTargets,10),d=d.concat(r));0<d.length&&(c.animations=d);c.computeFaceNormals();c.computeBoundingSphere();if(void 0===a.materials||0===
a.materials.length)return{geometry:c};a=kc.prototype.initMaterials(a.materials,b,this.crossOrigin);return{geometry:c,materials:a}}}()});Object.assign(Re.prototype,{load:function(a,b,c,d){""===this.texturePath&&(this.texturePath=a.substring(0,a.lastIndexOf("/")+1));var e=this;(new Ja(e.manager)).load(a,function(c){var f=null;try{f=JSON.parse(c)}catch(h){void 0!==d&&d(h);console.error("THREE:ObjectLoader: Can't parse "+a+".",h.message);return}c=f.metadata;void 0===c||void 0===c.type||"geometry"===c.type.toLowerCase()?
console.error("THREE.ObjectLoader: Can't load "+a+". Use THREE.JSONLoader instead."):e.parse(f,b)},c,d)},setTexturePath:function(a){this.texturePath=a},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a,b){var c=this.parseGeometries(a.geometries),d=this.parseImages(a.images,function(){void 0!==b&&b(e)}),d=this.parseTextures(a.textures,d),d=this.parseMaterials(a.materials,d),e=this.parseObject(a.object,c,d);a.animations&&(e.animations=this.parseAnimations(a.animations));void 0!==a.images&&
0!==a.images.length||void 0===b||b(e);return e},parseGeometries:function(a){var b={};if(void 0!==a)for(var c=new be,d=new ae,e=0,f=a.length;e<f;e++){var g=a[e];switch(g.type){case "PlaneGeometry":case "PlaneBufferGeometry":var h=new Ca[g.type](g.width,g.height,g.widthSegments,g.heightSegments);break;case "BoxGeometry":case "BoxBufferGeometry":case "CubeGeometry":h=new Ca[g.type](g.width,g.height,g.depth,g.widthSegments,g.heightSegments,g.depthSegments);break;case "CircleGeometry":case "CircleBufferGeometry":h=
new Ca[g.type](g.radius,g.segments,g.thetaStart,g.thetaLength);break;case "CylinderGeometry":case "CylinderBufferGeometry":h=new Ca[g.type](g.radiusTop,g.radiusBottom,g.height,g.radialSegments,g.heightSegments,g.openEnded,g.thetaStart,g.thetaLength);break;case "ConeGeometry":case "ConeBufferGeometry":h=new Ca[g.type](g.radius,g.height,g.radialSegments,g.heightSegments,g.openEnded,g.thetaStart,g.thetaLength);break;case "SphereGeometry":case "SphereBufferGeometry":h=new Ca[g.type](g.radius,g.widthSegments,
g.heightSegments,g.phiStart,g.phiLength,g.thetaStart,g.thetaLength);break;case "DodecahedronGeometry":case "DodecahedronBufferGeometry":case "IcosahedronGeometry":case "IcosahedronBufferGeometry":case "OctahedronGeometry":case "OctahedronBufferGeometry":case "TetrahedronGeometry":case "TetrahedronBufferGeometry":h=new Ca[g.type](g.radius,g.detail);break;case "RingGeometry":case "RingBufferGeometry":h=new Ca[g.type](g.innerRadius,g.outerRadius,g.thetaSegments,g.phiSegments,g.thetaStart,g.thetaLength);
break;case "TorusGeometry":case "TorusBufferGeometry":h=new Ca[g.type](g.radius,g.tube,g.radialSegments,g.tubularSegments,g.arc);break;case "TorusKnotGeometry":case "TorusKnotBufferGeometry":h=new Ca[g.type](g.radius,g.tube,g.tubularSegments,g.radialSegments,g.p,g.q);break;case "LatheGeometry":case "LatheBufferGeometry":h=new Ca[g.type](g.points,g.segments,g.phiStart,g.phiLength);break;case "PolyhedronGeometry":case "PolyhedronBufferGeometry":h=new Ca[g.type](g.vertices,g.indices,g.radius,g.details);
break;case "BufferGeometry":h=d.parse(g);break;case "Geometry":h=c.parse(g,this.texturePath).geometry;break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+g.type+'"');continue}h.uuid=g.uuid;void 0!==g.name&&(h.name=g.name);b[g.uuid]=h}return b},parseMaterials:function(a,b){var c={};if(void 0!==a){var d=new Id;d.setTextures(b);b=0;for(var e=a.length;b<e;b++){var f=a[b];if("MultiMaterial"===f.type){for(var g=[],h=0;h<f.materials.length;h++)g.push(d.parse(f.materials[h]));c[f.uuid]=
g}else c[f.uuid]=d.parse(f)}}return c},parseAnimations:function(a){for(var b=[],c=0;c<a.length;c++){var d=ka.parse(a[c]);b.push(d)}return b},parseImages:function(a,b){function c(a){d.manager.itemStart(a);return f.load(a,function(){d.manager.itemEnd(a)},void 0,function(){d.manager.itemEnd(a);d.manager.itemError(a)})}var d=this,e={};if(void 0!==a&&0<a.length){b=new Yd(b);var f=new Xc(b);f.setCrossOrigin(this.crossOrigin);b=0;for(var g=a.length;b<g;b++){var h=a[b],k=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url)?
h.url:d.texturePath+h.url;e[h.uuid]=c(k)}}return e},parseTextures:function(a,b){function c(a,b){if("number"===typeof a)return a;console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",a);return b[a]}var d={};if(void 0!==a)for(var e=0,f=a.length;e<f;e++){var g=a[e];void 0===g.image&&console.warn('THREE.ObjectLoader: No "image" specified for',g.uuid);void 0===b[g.image]&&console.warn("THREE.ObjectLoader: Undefined image",g.image);var h=new ea(b[g.image]);h.needsUpdate=!0;
h.uuid=g.uuid;void 0!==g.name&&(h.name=g.name);void 0!==g.mapping&&(h.mapping=c(g.mapping,ug));void 0!==g.offset&&h.offset.fromArray(g.offset);void 0!==g.repeat&&h.repeat.fromArray(g.repeat);void 0!==g.center&&h.center.fromArray(g.center);void 0!==g.rotation&&(h.rotation=g.rotation);void 0!==g.wrap&&(h.wrapS=c(g.wrap[0],hf),h.wrapT=c(g.wrap[1],hf));void 0!==g.minFilter&&(h.minFilter=c(g.minFilter,jf));void 0!==g.magFilter&&(h.magFilter=c(g.magFilter,jf));void 0!==g.anisotropy&&(h.anisotropy=g.anisotropy);
void 0!==g.flipY&&(h.flipY=g.flipY);d[g.uuid]=h}return d},parseObject:function(){var a=new K;return function(b,c,d){function e(a){void 0===c[a]&&console.warn("THREE.ObjectLoader: Undefined geometry",a);return c[a]}function f(a){if(void 0!==a){if(Array.isArray(a)){for(var b=[],c=0,e=a.length;c<e;c++){var f=a[c];void 0===d[f]&&console.warn("THREE.ObjectLoader: Undefined material",f);b.push(d[f])}return b}void 0===d[a]&&console.warn("THREE.ObjectLoader: Undefined material",a);return d[a]}}switch(b.type){case "Scene":var g=
new od;void 0!==b.background&&Number.isInteger(b.background)&&(g.background=new H(b.background));void 0!==b.fog&&("Fog"===b.fog.type?g.fog=new Pb(b.fog.color,b.fog.near,b.fog.far):"FogExp2"===b.fog.type&&(g.fog=new Ob(b.fog.color,b.fog.density)));break;case "PerspectiveCamera":g=new U(b.fov,b.aspect,b.near,b.far);void 0!==b.focus&&(g.focus=b.focus);void 0!==b.zoom&&(g.zoom=b.zoom);void 0!==b.filmGauge&&(g.filmGauge=b.filmGauge);void 0!==b.filmOffset&&(g.filmOffset=b.filmOffset);void 0!==b.view&&(g.view=
Object.assign({},b.view));break;case "OrthographicCamera":g=new Kb(b.left,b.right,b.top,b.bottom,b.near,b.far);break;case "AmbientLight":g=new Ad(b.color,b.intensity);break;case "DirectionalLight":g=new zd(b.color,b.intensity);break;case "PointLight":g=new xd(b.color,b.intensity,b.distance,b.decay);break;case "RectAreaLight":g=new Bd(b.color,b.intensity,b.width,b.height);break;case "SpotLight":g=new wd(b.color,b.intensity,b.distance,b.angle,b.penumbra,b.decay);break;case "HemisphereLight":g=new ud(b.color,
b.groundColor,b.intensity);break;case "SkinnedMesh":console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");case "Mesh":g=e(b.geometry);var h=f(b.material);g=g.bones&&0<g.bones.length?new qd(g,h):new pa(g,h);break;case "LOD":g=new Dc;break;case "Line":g=new ma(e(b.geometry),f(b.material),b.mode);break;case "LineLoop":g=new rd(e(b.geometry),f(b.material));break;case "LineSegments":g=new ca(e(b.geometry),f(b.material));break;case "PointCloud":case "Points":g=new Qb(e(b.geometry),
f(b.material));break;case "Sprite":g=new Cc(f(b.material));break;case "Group":g=new Fc;break;default:g=new A}g.uuid=b.uuid;void 0!==b.name&&(g.name=b.name);void 0!==b.matrix?(a.fromArray(b.matrix),a.decompose(g.position,g.quaternion,g.scale)):(void 0!==b.position&&g.position.fromArray(b.position),void 0!==b.rotation&&g.rotation.fromArray(b.rotation),void 0!==b.quaternion&&g.quaternion.fromArray(b.quaternion),void 0!==b.scale&&g.scale.fromArray(b.scale));void 0!==b.castShadow&&(g.castShadow=b.castShadow);
void 0!==b.receiveShadow&&(g.receiveShadow=b.receiveShadow);b.shadow&&(void 0!==b.shadow.bias&&(g.shadow.bias=b.shadow.bias),void 0!==b.shadow.radius&&(g.shadow.radius=b.shadow.radius),void 0!==b.shadow.mapSize&&g.shadow.mapSize.fromArray(b.shadow.mapSize),void 0!==b.shadow.camera&&(g.shadow.camera=this.parseObject(b.shadow.camera)));void 0!==b.visible&&(g.visible=b.visible);void 0!==b.userData&&(g.userData=b.userData);if(void 0!==b.children)for(var h=b.children,k=0;k<h.length;k++)g.add(this.parseObject(h[k],
c,d));if("LOD"===b.type)for(b=b.levels,h=0;h<b.length;h++){var k=b[h],l=g.getObjectByProperty("uuid",k.object);void 0!==l&&g.addLevel(l,k.distance)}return g}}()});var ug={UVMapping:300,CubeReflectionMapping:301,CubeRefractionMapping:302,EquirectangularReflectionMapping:303,EquirectangularRefractionMapping:304,SphericalReflectionMapping:305,CubeUVReflectionMapping:306,CubeUVRefractionMapping:307},hf={RepeatWrapping:1E3,ClampToEdgeWrapping:1001,MirroredRepeatWrapping:1002},jf={NearestFilter:1003,NearestMipMapNearestFilter:1004,
NearestMipMapLinearFilter:1005,LinearFilter:1006,LinearMipMapNearestFilter:1007,LinearMipMapLinearFilter:1008};Object.assign(S.prototype,{getPoint:function(){console.warn("THREE.Curve: .getPoint() not implemented.");return null},getPointAt:function(a,b){a=this.getUtoTmapping(a);return this.getPoint(a,b)},getPoints:function(a){void 0===a&&(a=5);for(var b=[],c=0;c<=a;c++)b.push(this.getPoint(c/a));return b},getSpacedPoints:function(a){void 0===a&&(a=5);for(var b=[],c=0;c<=a;c++)b.push(this.getPointAt(c/
a));return b},getLength:function(){var a=this.getLengths();return a[a.length-1]},getLengths:function(a){void 0===a&&(a=this.arcLengthDivisions);if(this.cacheArcLengths&&this.cacheArcLengths.length===a+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;var b=[],c=this.getPoint(0),d,e=0;b.push(0);for(d=1;d<=a;d++){var f=this.getPoint(d/a);e+=f.distanceTo(c);b.push(e);c=f}return this.cacheArcLengths=b},updateArcLengths:function(){this.needsUpdate=!0;this.getLengths()},getUtoTmapping:function(a,
b){var c=this.getLengths(),d=c.length;b=b?b:a*c[d-1];for(var e=0,f=d-1,g;e<=f;)if(a=Math.floor(e+(f-e)/2),g=c[a]-b,0>g)e=a+1;else if(0<g)f=a-1;else{f=a;break}a=f;if(c[a]===b)return a/(d-1);e=c[a];return(a+(b-e)/(c[a+1]-e))/(d-1)},getTangent:function(a){var b=a-1E-4;a+=1E-4;0>b&&(b=0);1<a&&(a=1);b=this.getPoint(b);return this.getPoint(a).clone().sub(b).normalize()},getTangentAt:function(a){a=this.getUtoTmapping(a);return this.getTangent(a)},computeFrenetFrames:function(a,b){var c=new p,d=[],e=[],f=
[],g=new p,h=new K,k;for(k=0;k<=a;k++){var l=k/a;d[k]=this.getTangentAt(l);d[k].normalize()}e[0]=new p;f[0]=new p;k=Number.MAX_VALUE;l=Math.abs(d[0].x);var m=Math.abs(d[0].y),n=Math.abs(d[0].z);l<=k&&(k=l,c.set(1,0,0));m<=k&&(k=m,c.set(0,1,0));n<=k&&c.set(0,0,1);g.crossVectors(d[0],c).normalize();e[0].crossVectors(d[0],g);f[0].crossVectors(d[0],e[0]);for(k=1;k<=a;k++)e[k]=e[k-1].clone(),f[k]=f[k-1].clone(),g.crossVectors(d[k-1],d[k]),g.length()>Number.EPSILON&&(g.normalize(),c=Math.acos(R.clamp(d[k-
1].dot(d[k]),-1,1)),e[k].applyMatrix4(h.makeRotationAxis(g,c))),f[k].crossVectors(d[k],e[k]);if(!0===b)for(c=Math.acos(R.clamp(e[0].dot(e[a]),-1,1)),c/=a,0<d[0].dot(g.crossVectors(e[0],e[a]))&&(c=-c),k=1;k<=a;k++)e[k].applyMatrix4(h.makeRotationAxis(d[k],c*k)),f[k].crossVectors(d[k],e[k]);return{tangents:d,normals:e,binormals:f}},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.arcLengthDivisions=a.arcLengthDivisions;return this}});Ka.prototype=Object.create(S.prototype);
Ka.prototype.constructor=Ka;Ka.prototype.isLineCurve=!0;Ka.prototype.getPoint=function(a,b){b=b||new C;1===a?b.copy(this.v2):(b.copy(this.v2).sub(this.v1),b.multiplyScalar(a).add(this.v1));return b};Ka.prototype.getPointAt=function(a,b){return this.getPoint(a,b)};Ka.prototype.getTangent=function(){return this.v2.clone().sub(this.v1).normalize()};Ka.prototype.copy=function(a){S.prototype.copy.call(this,a);this.v1.copy(a.v1);this.v2.copy(a.v2);return this};Ab.prototype=Object.assign(Object.create(S.prototype),
{constructor:Ab,add:function(a){this.curves.push(a)},closePath:function(){var a=this.curves[0].getPoint(0),b=this.curves[this.curves.length-1].getPoint(1);a.equals(b)||this.curves.push(new Ka(b,a))},getPoint:function(a){var b=a*this.getLength(),c=this.getCurveLengths();for(a=0;a<c.length;){if(c[a]>=b)return b=c[a]-b,a=this.curves[a],c=a.getLength(),a.getPointAt(0===c?0:1-b/c);a++}return null},getLength:function(){var a=this.getCurveLengths();return a[a.length-1]},updateArcLengths:function(){this.needsUpdate=
!0;this.cacheLengths=null;this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;for(var a=[],b=0,c=0,d=this.curves.length;c<d;c++)b+=this.curves[c].getLength(),a.push(b);return this.cacheLengths=a},getSpacedPoints:function(a){void 0===a&&(a=40);for(var b=[],c=0;c<=a;c++)b.push(this.getPoint(c/a));this.autoClose&&b.push(b[0]);return b},getPoints:function(a){a=a||12;for(var b=[],c,d=0,e=this.curves;d<e.length;d++)for(var f=
e[d],f=f.getPoints(f&&f.isEllipseCurve?2*a:f&&f.isLineCurve?1:f&&f.isSplineCurve?a*f.points.length:a),g=0;g<f.length;g++){var h=f[g];c&&c.equals(h)||(b.push(h),c=h)}this.autoClose&&1<b.length&&!b[b.length-1].equals(b[0])&&b.push(b[0]);return b},copy:function(a){S.prototype.copy.call(this,a);this.curves=[];for(var b=0,c=a.curves.length;b<c;b++)this.curves.push(a.curves[b].clone());this.autoClose=a.autoClose;return this}});Na.prototype=Object.create(S.prototype);Na.prototype.constructor=Na;Na.prototype.isEllipseCurve=
!0;Na.prototype.getPoint=function(a,b){b=b||new C;for(var c=2*Math.PI,d=this.aEndAngle-this.aStartAngle,e=Math.abs(d)<Number.EPSILON;0>d;)d+=c;for(;d>c;)d-=c;d<Number.EPSILON&&(d=e?0:c);!0!==this.aClockwise||e||(d=d===c?-c:d-c);c=this.aStartAngle+a*d;a=this.aX+this.xRadius*Math.cos(c);var f=this.aY+this.yRadius*Math.sin(c);0!==this.aRotation&&(c=Math.cos(this.aRotation),d=Math.sin(this.aRotation),e=a-this.aX,f-=this.aY,a=e*c-f*d+this.aX,f=e*d+f*c+this.aY);return b.set(a,f)};Na.prototype.copy=function(a){S.prototype.copy.call(this,
a);this.aX=a.aX;this.aY=a.aY;this.xRadius=a.xRadius;this.yRadius=a.yRadius;this.aStartAngle=a.aStartAngle;this.aEndAngle=a.aEndAngle;this.aClockwise=a.aClockwise;this.aRotation=a.aRotation;return this};ab.prototype=Object.create(S.prototype);ab.prototype.constructor=ab;ab.prototype.isSplineCurve=!0;ab.prototype.getPoint=function(a,b){b=b||new C;var c=this.points,d=(c.length-1)*a;a=Math.floor(d);var d=d-a,e=c[0===a?a:a-1],f=c[a],g=c[a>c.length-2?c.length-1:a+1],c=c[a>c.length-3?c.length-1:a+2];b.set(Se(d,
e.x,f.x,g.x,c.x),Se(d,e.y,f.y,g.y,c.y));return b};ab.prototype.copy=function(a){S.prototype.copy.call(this,a);this.points=[];for(var b=0,c=a.points.length;b<c;b++)this.points.push(a.points[b].clone());return this};bb.prototype=Object.create(S.prototype);bb.prototype.constructor=bb;bb.prototype.isCubicBezierCurve=!0;bb.prototype.getPoint=function(a,b){b=b||new C;var c=this.v0,d=this.v1,e=this.v2,f=this.v3;b.set(zb(a,c.x,d.x,e.x,f.x),zb(a,c.y,d.y,e.y,f.y));return b};bb.prototype.copy=function(a){S.prototype.copy.call(this,
a);this.v0.copy(a.v0);this.v1.copy(a.v1);this.v2.copy(a.v2);this.v3.copy(a.v3);return this};cb.prototype=Object.create(S.prototype);cb.prototype.constructor=cb;cb.prototype.isQuadraticBezierCurve=!0;cb.prototype.getPoint=function(a,b){b=b||new C;var c=this.v0,d=this.v1,e=this.v2;b.set(yb(a,c.x,d.x,e.x),yb(a,c.y,d.y,e.y));return b};cb.prototype.copy=function(a){S.prototype.copy.call(this,a);this.v0.copy(a.v0);this.v1.copy(a.v1);this.v2.copy(a.v2);return this};var se=Object.assign(Object.create(Ab.prototype),
{setFromPoints:function(a){this.moveTo(a[0].x,a[0].y);for(var b=1,c=a.length;b<c;b++)this.lineTo(a[b].x,a[b].y)},moveTo:function(a,b){this.currentPoint.set(a,b)},lineTo:function(a,b){var c=new Ka(this.currentPoint.clone(),new C(a,b));this.curves.push(c);this.currentPoint.set(a,b)},quadraticCurveTo:function(a,b,c,d){a=new cb(this.currentPoint.clone(),new C(a,b),new C(c,d));this.curves.push(a);this.currentPoint.set(c,d)},bezierCurveTo:function(a,b,c,d,e,f){a=new bb(this.currentPoint.clone(),new C(a,
b),new C(c,d),new C(e,f));this.curves.push(a);this.currentPoint.set(e,f)},splineThru:function(a){var b=[this.currentPoint.clone()].concat(a),b=new ab(b);this.curves.push(b);this.currentPoint.copy(a[a.length-1])},arc:function(a,b,c,d,e,f){this.absarc(a+this.currentPoint.x,b+this.currentPoint.y,c,d,e,f)},absarc:function(a,b,c,d,e,f){this.absellipse(a,b,c,c,d,e,f)},ellipse:function(a,b,c,d,e,f,g,h){this.absellipse(a+this.currentPoint.x,b+this.currentPoint.y,c,d,e,f,g,h)},absellipse:function(a,b,c,d,
e,f,g,h){a=new Na(a,b,c,d,e,f,g,h);0<this.curves.length&&(b=a.getPoint(0),b.equals(this.currentPoint)||this.lineTo(b.x,b.y));this.curves.push(a);a=a.getPoint(1);this.currentPoint.copy(a)},copy:function(a){Ab.prototype.copy.call(this,a);this.currentPoint.copy(a.currentPoint);return this}});Bb.prototype=se;se.constructor=Bb;Cb.prototype=Object.assign(Object.create(se),{constructor:Cb,getPointsHoles:function(a){for(var b=[],c=0,d=this.holes.length;c<d;c++)b[c]=this.holes[c].getPoints(a);return b},extractPoints:function(a){return{shape:this.getPoints(a),
holes:this.getPointsHoles(a)}},copy:function(a){Bb.prototype.copy.call(this,a);this.holes=[];for(var b=0,c=a.holes.length;b<c;b++)this.holes.push(a.holes[b].clone());return this}});Object.assign(ce.prototype,{moveTo:function(a,b){this.currentPath=new Bb;this.subPaths.push(this.currentPath);this.currentPath.moveTo(a,b)},lineTo:function(a,b){this.currentPath.lineTo(a,b)},quadraticCurveTo:function(a,b,c,d){this.currentPath.quadraticCurveTo(a,b,c,d)},bezierCurveTo:function(a,b,c,d,e,f){this.currentPath.bezierCurveTo(a,
b,c,d,e,f)},splineThru:function(a){this.currentPath.splineThru(a)},toShapes:function(a,b){function c(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c],f=new Cb;f.curves=e.curves;b.push(f)}return b}function d(a,b){for(var c=b.length,d=!1,e=c-1,f=0;f<c;e=f++){var g=b[e],h=b[f],k=h.x-g.x,l=h.y-g.y;if(Math.abs(l)>Number.EPSILON){if(0>l&&(g=b[f],k=-k,h=b[e],l=-l),!(a.y<g.y||a.y>h.y))if(a.y===g.y){if(a.x===g.x)return!0}else{e=l*(a.x-g.x)-k*(a.y-g.y);if(0===e)return!0;0>e||(d=!d)}}else if(a.y===g.y&&(h.x<=
a.x&&a.x<=g.x||g.x<=a.x&&a.x<=h.x))return!0}return d}var e=Ha.isClockWise,f=this.subPaths;if(0===f.length)return[];if(!0===b)return c(f);b=[];if(1===f.length){var g=f[0];var h=new Cb;h.curves=g.curves;b.push(h);return b}var k=!e(f[0].getPoints()),k=a?!k:k;h=[];var l=[],m=[],n=0;l[n]=void 0;m[n]=[];for(var p=0,r=f.length;p<r;p++){g=f[p];var u=g.getPoints();var v=e(u);(v=a?!v:v)?(!k&&l[n]&&n++,l[n]={s:new Cb,p:u},l[n].s.curves=g.curves,k&&n++,m[n]=[]):m[n].push({h:g,p:u[0]})}if(!l[0])return c(f);if(1<
l.length){p=!1;a=[];e=0;for(f=l.length;e<f;e++)h[e]=[];e=0;for(f=l.length;e<f;e++)for(g=m[e],v=0;v<g.length;v++){k=g[v];n=!0;for(u=0;u<l.length;u++)d(k.p,l[u].p)&&(e!==u&&a.push({froms:e,tos:u,hole:v}),n?(n=!1,h[u].push(k)):p=!0);n&&h[e].push(k)}0<a.length&&(p||(m=h))}p=0;for(e=l.length;p<e;p++)for(h=l[p].s,b.push(h),a=m[p],f=0,g=a.length;f<g;f++)h.holes.push(a[f].h);return b}});Object.assign(de.prototype,{isFont:!0,generateShapes:function(a,b,c){void 0===b&&(b=100);void 0===c&&(c=4);var d=this.data;
a=String(a).split("");var e=b/d.resolution,f=(d.boundingBox.yMax-d.boundingBox.yMin+d.underlineThickness)*e,g=0,h=0;b=[];for(var k=0;k<a.length;k++){var l=a[k];if("\n"===l)g=0,h-=f;else{var m;var n=e;var p=g,r=h;if(l=d.glyphs[l]||d.glyphs["?"]){var u=new ce,v=[];if(l.o)for(var w=l._cachedOutline||(l._cachedOutline=l.o.split(" ")),x=0,y=w.length;x<y;)switch(w[x++]){case "m":var A=w[x++]*n+p;var B=w[x++]*n+r;u.moveTo(A,B);break;case "l":A=w[x++]*n+p;B=w[x++]*n+r;u.lineTo(A,B);break;case "q":var C=w[x++]*
n+p;var D=w[x++]*n+r;var E=w[x++]*n+p;var H=w[x++]*n+r;u.quadraticCurveTo(E,H,C,D);if(m=v[v.length-1]){var N=m.x;m=m.y;for(var K=1;K<=c;K++){var O=K/c;yb(O,N,E,C);yb(O,m,H,D)}}break;case "b":if(C=w[x++]*n+p,D=w[x++]*n+r,E=w[x++]*n+p,H=w[x++]*n+r,A=w[x++]*n+p,B=w[x++]*n+r,u.bezierCurveTo(E,H,A,B,C,D),m=v[v.length-1])for(N=m.x,m=m.y,K=1;K<=c;K++)O=K/c,zb(O,N,E,A,C),zb(O,m,H,B,D)}n={offsetX:l.ha*n,path:u}}else n=void 0;g+=n.offsetX;b.push(n.path)}}c=[];d=0;for(a=b.length;d<a;d++)Array.prototype.push.apply(c,
b[d].toShapes());return c}});Object.assign(Te.prototype,{load:function(a,b,c,d){var e=this,f=new Ja(this.manager);f.setPath(this.path);f.load(a,function(a){try{var c=JSON.parse(a)}catch(k){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),c=JSON.parse(a.substring(65,a.length-2))}a=e.parse(c);b&&b(a)},c,d)},parse:function(a){return new de(a)},setPath:function(a){this.path=a;return this}});var Md,ge={getContext:function(){void 0===Md&&(Md=new (window.AudioContext||
window.webkitAudioContext));return Md},setContext:function(a){Md=a}};Object.assign(ee.prototype,{load:function(a,b,c,d){var e=new Ja(this.manager);e.setResponseType("arraybuffer");e.load(a,function(a){ge.getContext().decodeAudioData(a,function(a){b(a)})},c,d)}});Object.assign(Ue.prototype,{update:function(){var a,b,c,d,e,f,g,h,k=new K,l=new K;return function(m){if(a!==this||b!==m.focus||c!==m.fov||d!==m.aspect*this.aspect||e!==m.near||f!==m.far||g!==m.zoom||h!==this.eyeSep){a=this;b=m.focus;c=m.fov;
d=m.aspect*this.aspect;e=m.near;f=m.far;g=m.zoom;var n=m.projectionMatrix.clone();h=this.eyeSep/2;var q=h*e/b,p=e*Math.tan(R.DEG2RAD*c*.5)/g;l.elements[12]=-h;k.elements[12]=h;var u=-p*d+q;var v=p*d+q;n.elements[0]=2*e/(v-u);n.elements[8]=(v+u)/(v-u);this.cameraL.projectionMatrix.copy(n);u=-p*d-q;v=p*d-q;n.elements[0]=2*e/(v-u);n.elements[8]=(v+u)/(v-u);this.cameraR.projectionMatrix.copy(n)}this.cameraL.matrixWorld.copy(m.matrixWorld).multiply(l);this.cameraR.matrixWorld.copy(m.matrixWorld).multiply(k)}}()});
$c.prototype=Object.create(A.prototype);$c.prototype.constructor=$c;fe.prototype=Object.assign(Object.create(A.prototype),{constructor:fe,getInput:function(){return this.gain},removeFilter:function(){null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null)},getFilter:function(){return this.filter},setFilter:function(a){null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):
this.gain.disconnect(this.context.destination);this.filter=a;this.gain.connect(this.filter);this.filter.connect(this.context.destination)},getMasterVolume:function(){return this.gain.gain.value},setMasterVolume:function(a){this.gain.gain.value=a},updateMatrixWorld:function(){var a=new p,b=new Z,c=new p,d=new p;return function(e){A.prototype.updateMatrixWorld.call(this,e);e=this.context.listener;var f=this.up;this.matrixWorld.decompose(a,b,c);d.set(0,0,-1).applyQuaternion(b);e.positionX?(e.positionX.setValueAtTime(a.x,
this.context.currentTime),e.positionY.setValueAtTime(a.y,this.context.currentTime),e.positionZ.setValueAtTime(a.z,this.context.currentTime),e.forwardX.setValueAtTime(d.x,this.context.currentTime),e.forwardY.setValueAtTime(d.y,this.context.currentTime),e.forwardZ.setValueAtTime(d.z,this.context.currentTime),e.upX.setValueAtTime(f.x,this.context.currentTime),e.upY.setValueAtTime(f.y,this.context.currentTime),e.upZ.setValueAtTime(f.z,this.context.currentTime)):(e.setPosition(a.x,a.y,a.z),e.setOrientation(d.x,
d.y,d.z,f.x,f.y,f.z))}}()});lc.prototype=Object.assign(Object.create(A.prototype),{constructor:lc,getOutput:function(){return this.gain},setNodeSource:function(a){this.hasPlaybackControl=!1;this.sourceType="audioNode";this.source=a;this.connect();return this},setBuffer:function(a){this.buffer=a;this.sourceType="buffer";this.autoplay&&this.play();return this},play:function(){if(!0===this.isPlaying)console.warn("THREE.Audio: Audio is already playing.");else if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");
else{var a=this.context.createBufferSource();a.buffer=this.buffer;a.loop=this.loop;a.onended=this.onEnded.bind(this);a.playbackRate.setValueAtTime(this.playbackRate,this.startTime);this.startTime=this.context.currentTime;a.start(this.startTime,this.offset);this.isPlaying=!0;this.source=a;return this.connect()}},pause:function(){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");else return!0===this.isPlaying&&(this.source.stop(),this.offset+=(this.context.currentTime-
this.startTime)*this.playbackRate,this.isPlaying=!1),this},stop:function(){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");else return this.source.stop(),this.offset=0,this.isPlaying=!1,this},connect:function(){if(0<this.filters.length){this.source.connect(this.filters[0]);for(var a=1,b=this.filters.length;a<b;a++)this.filters[a-1].connect(this.filters[a]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());
return this},disconnect:function(){if(0<this.filters.length){this.source.disconnect(this.filters[0]);for(var a=1,b=this.filters.length;a<b;a++)this.filters[a-1].disconnect(this.filters[a]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this},getFilters:function(){return this.filters},setFilters:function(a){a||(a=[]);!0===this.isPlaying?(this.disconnect(),this.filters=a,this.connect()):this.filters=a;return this},getFilter:function(){return this.getFilters()[0]},
setFilter:function(a){return this.setFilters(a?[a]:[])},setPlaybackRate:function(a){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");else return this.playbackRate=a,!0===this.isPlaying&&this.source.playbackRate.setValueAtTime(this.playbackRate,this.context.currentTime),this},getPlaybackRate:function(){return this.playbackRate},onEnded:function(){this.isPlaying=!1},getLoop:function(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),
!1):this.loop},setLoop:function(a){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");else return this.loop=a,!0===this.isPlaying&&(this.source.loop=this.loop),this},getVolume:function(){return this.gain.gain.value},setVolume:function(a){this.gain.gain.value=a;return this}});he.prototype=Object.assign(Object.create(lc.prototype),{constructor:he,getOutput:function(){return this.panner},getRefDistance:function(){return this.panner.refDistance},setRefDistance:function(a){this.panner.refDistance=
a},getRolloffFactor:function(){return this.panner.rolloffFactor},setRolloffFactor:function(a){this.panner.rolloffFactor=a},getDistanceModel:function(){return this.panner.distanceModel},setDistanceModel:function(a){this.panner.distanceModel=a},getMaxDistance:function(){return this.panner.maxDistance},setMaxDistance:function(a){this.panner.maxDistance=a},updateMatrixWorld:function(){var a=new p;return function(b){A.prototype.updateMatrixWorld.call(this,b);a.setFromMatrixPosition(this.matrixWorld);this.panner.setPosition(a.x,
a.y,a.z)}}()});Object.assign(ie.prototype,{getFrequencyData:function(){this.analyser.getByteFrequencyData(this.data);return this.data},getAverageFrequency:function(){for(var a=0,b=this.getFrequencyData(),c=0;c<b.length;c++)a+=b[c];return a/b.length}});Object.assign(je.prototype,{accumulate:function(a,b){var c=this.buffer,d=this.valueSize;a=a*d+d;var e=this.cumulativeWeight;if(0===e){for(e=0;e!==d;++e)c[a+e]=c[e];e=b}else e+=b,this._mixBufferRegion(c,a,0,b/e,d);this.cumulativeWeight=e},apply:function(a){var b=
this.valueSize,c=this.buffer;a=a*b+b;var d=this.cumulativeWeight,e=this.binding;this.cumulativeWeight=0;1>d&&this._mixBufferRegion(c,a,3*b,1-d,b);for(var d=b,f=b+b;d!==f;++d)if(c[d]!==c[d+b]){e.setValue(c,a);break}},saveOriginalState:function(){var a=this.buffer,b=this.valueSize,c=3*b;this.binding.getValue(a,c);for(var d=b;d!==c;++d)a[d]=a[c+d%b];this.cumulativeWeight=0},restoreOriginalState:function(){this.binding.setValue(this.buffer,3*this.valueSize)},_select:function(a,b,c,d,e){if(.5<=d)for(d=
0;d!==e;++d)a[b+d]=a[c+d]},_slerp:function(a,b,c,d){Z.slerpFlat(a,b,a,b,a,c,d)},_lerp:function(a,b,c,d,e){for(var f=1-d,g=0;g!==e;++g){var h=b+g;a[h]=a[h]*f+a[c+g]*d}}});Object.assign(Ve.prototype,{getValue:function(a,b){this.bind();var c=this._bindings[this._targetGroup.nCachedObjects_];void 0!==c&&c.getValue(a,b)},setValue:function(a,b){for(var c=this._bindings,d=this._targetGroup.nCachedObjects_,e=c.length;d!==e;++d)c[d].setValue(a,b)},bind:function(){for(var a=this._bindings,b=this._targetGroup.nCachedObjects_,
c=a.length;b!==c;++b)a[b].bind()},unbind:function(){for(var a=this._bindings,b=this._targetGroup.nCachedObjects_,c=a.length;b!==c;++b)a[b].unbind()}});Object.assign(na,{Composite:Ve,create:function(a,b,c){return a&&a.isAnimationObjectGroup?new na.Composite(a,b,c):new na(a,b,c)},sanitizeNodeName:function(a){return a.replace(/\s/g,"_").replace(/[^\w-]/g,"")},parseTrackName:function(){var a=new RegExp("^"+/((?:[\w-]+[\/:])*)/.source+/([\w-\.]+)?/.source+/(?:\.([\w-]+)(?:\[(.+)\])?)?/.source+/\.([\w-]+)(?:\[(.+)\])?/.source+
"$"),b=["material","materials","bones"];return function(c){var d=a.exec(c);if(!d)throw Error("PropertyBinding: Cannot parse trackName: "+c);var d={nodeName:d[2],objectName:d[3],objectIndex:d[4],propertyName:d[5],propertyIndex:d[6]},e=d.nodeName&&d.nodeName.lastIndexOf(".");if(void 0!==e&&-1!==e){var f=d.nodeName.substring(e+1);-1!==b.indexOf(f)&&(d.nodeName=d.nodeName.substring(0,e),d.objectName=f)}if(null===d.propertyName||0===d.propertyName.length)throw Error("PropertyBinding: can not parse propertyName from trackName: "+
c);return d}}(),findNode:function(a,b){if(!b||""===b||"root"===b||"."===b||-1===b||b===a.name||b===a.uuid)return a;if(a.skeleton){var c=function(a){for(var c=0;c<a.bones.length;c++){var d=a.bones[c];if(d.name===b)return d}return null}(a.skeleton);if(c)return c}if(a.children){var d=function(a){for(var c=0;c<a.length;c++){var e=a[c];if(e.name===b||e.uuid===b||(e=d(e.children)))return e}return null};if(a=d(a.children))return a}return null}});Object.assign(na.prototype,{_getValue_unavailable:function(){},
_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(a,b){a[b]=this.node[this.propertyName]},function(a,b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)a[b++]=c[d]},function(a,b){a[b]=this.resolvedProperty[this.propertyIndex]},function(a,b){this.resolvedProperty.toArray(a,b)}],SetterByBindingTypeAndVersioning:[[function(a,b){this.targetObject[this.propertyName]=
a[b]},function(a,b){this.targetObject[this.propertyName]=a[b];this.targetObject.needsUpdate=!0},function(a,b){this.targetObject[this.propertyName]=a[b];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(a,b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)c[d]=a[b++]},function(a,b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)c[d]=a[b++];this.targetObject.needsUpdate=!0},function(a,b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)c[d]=a[b++];this.targetObject.matrixWorldNeedsUpdate=
!0}],[function(a,b){this.resolvedProperty[this.propertyIndex]=a[b]},function(a,b){this.resolvedProperty[this.propertyIndex]=a[b];this.targetObject.needsUpdate=!0},function(a,b){this.resolvedProperty[this.propertyIndex]=a[b];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(a,b){this.resolvedProperty.fromArray(a,b)},function(a,b){this.resolvedProperty.fromArray(a,b);this.targetObject.needsUpdate=!0},function(a,b){this.resolvedProperty.fromArray(a,b);this.targetObject.matrixWorldNeedsUpdate=!0}]],
getValue:function(a,b){this.bind();this.getValue(a,b)},setValue:function(a,b){this.bind();this.setValue(a,b)},bind:function(){var a=this.node,b=this.parsedPath,c=b.objectName,d=b.propertyName,e=b.propertyIndex;a||(this.node=a=na.findNode(this.rootNode,b.nodeName)||this.rootNode);this.getValue=this._getValue_unavailable;this.setValue=this._setValue_unavailable;if(a){if(c){var f=b.objectIndex;switch(c){case "materials":if(!a.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",
this);return}if(!a.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}a=a.material.materials;break;case "bones":if(!a.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}a=a.skeleton.bones;for(c=0;c<a.length;c++)if(a[c].name===f){f=c;break}break;default:if(void 0===a[c]){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",
this);return}a=a[c]}if(void 0!==f){if(void 0===a[f]){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,a);return}a=a[f]}}f=a[d];if(void 0===f)console.error("THREE.PropertyBinding: Trying to update property for track: "+b.nodeName+"."+d+" but it wasn't found.",a);else{b=this.Versioning.None;void 0!==a.needsUpdate?(b=this.Versioning.NeedsUpdate,this.targetObject=a):void 0!==a.matrixWorldNeedsUpdate&&(b=this.Versioning.MatrixWorldNeedsUpdate,this.targetObject=
a);c=this.BindingType.Direct;if(void 0!==e){if("morphTargetInfluences"===d){if(!a.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(a.geometry.isBufferGeometry){if(!a.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}for(c=0;c<this.node.geometry.morphAttributes.position.length;c++)if(a.geometry.morphAttributes.position[c].name===
e){e=c;break}}else{if(!a.geometry.morphTargets){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",this);return}for(c=0;c<this.node.geometry.morphTargets.length;c++)if(a.geometry.morphTargets[c].name===e){e=c;break}}}c=this.BindingType.ArrayElement;this.resolvedProperty=f;this.propertyIndex=e}else void 0!==f.fromArray&&void 0!==f.toArray?(c=this.BindingType.HasFromToArray,this.resolvedProperty=f):Array.isArray(f)?(c=this.BindingType.EntireArray,
this.resolvedProperty=f):this.propertyName=d;this.getValue=this.GetterByBindingType[c];this.setValue=this.SetterByBindingTypeAndVersioning[c][b]}}else console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.")},unbind:function(){this.node=null;this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound}});Object.assign(na.prototype,{_getValue_unbound:na.prototype.getValue,_setValue_unbound:na.prototype.setValue});Object.assign(We.prototype,
{isAnimationObjectGroup:!0,add:function(){for(var a=this._objects,b=a.length,c=this.nCachedObjects_,d=this._indicesByUUID,e=this._paths,f=this._parsedPaths,g=this._bindings,h=g.length,k=0,l=arguments.length;k!==l;++k){var m=arguments[k],n=m.uuid,p=d[n];if(void 0===p){p=b++;d[n]=p;a.push(m);for(var n=0,r=h;n!==r;++n)g[n].push(new na(m,e[n],f[n]))}else if(p<c){var u=--c,r=a[u];d[r.uuid]=p;a[p]=r;d[n]=u;a[u]=m;n=0;for(r=h;n!==r;++n){var v=g[n],w=v[p];v[p]=v[u];void 0===w&&(w=new na(m,e[n],f[n]));v[u]=
w}}else void 0!==a[p]&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c},remove:function(){for(var a=this._objects,b=this.nCachedObjects_,c=this._indicesByUUID,d=this._bindings,e=d.length,f=0,g=arguments.length;f!==g;++f){var h=arguments[f],k=h.uuid,l=c[k];if(void 0!==l&&l>=b){var m=b++,n=a[m];c[n.uuid]=l;a[l]=n;c[k]=m;a[m]=h;h=0;for(k=e;h!==k;++h){var n=d[h],p=
n[l];n[l]=n[m];n[m]=p}}}this.nCachedObjects_=b},uncache:function(){for(var a,b,c=this._objects,d=c.length,e=this.nCachedObjects_,f=this._indicesByUUID,g=this._bindings,h=g.length,k=0,l=arguments.length;k!==l;++k){b=arguments[k].uuid;var m=f[b];if(void 0!==m)if(delete f[b],m<e){var n=--e,p=c[n];b=--d;a=c[b];f[p.uuid]=m;c[m]=p;f[a.uuid]=n;c[n]=a;c.pop();for(var p=0,r=h;p!==r;++p){a=g[p];var u=a[b];a[m]=a[n];a[n]=u;a.pop()}}else for(b=--d,a=c[b],f[a.uuid]=m,c[m]=a,c.pop(),p=0,r=h;p!==r;++p)a=g[p],a[m]=
a[b],a.pop()}this.nCachedObjects_=e},subscribe_:function(a,b){var c=this._bindingsIndicesByPath,d=c[a],e=this._bindings;if(void 0!==d)return e[d];var f=this._paths,g=this._parsedPaths,h=this._objects,k=this.nCachedObjects_,l=Array(h.length),d=e.length;c[a]=d;f.push(a);g.push(b);e.push(l);c=k;for(d=h.length;c!==d;++c)l[c]=new na(h[c],a,b);return l},unsubscribe_:function(a){var b=this._bindingsIndicesByPath,c=b[a];if(void 0!==c){var d=this._paths,e=this._parsedPaths,f=this._bindings,g=f.length-1,h=
f[g];b[a[g]]=c;f[c]=h;f.pop();e[c]=e[g];e.pop();d[c]=d[g];d.pop()}}});Object.assign(Xe.prototype,{play:function(){this._mixer._activateAction(this);return this},stop:function(){this._mixer._deactivateAction(this);return this.reset()},reset:function(){this.paused=!1;this.enabled=!0;this.time=0;this._loopCount=-1;this._startTime=null;return this.stopFading().stopWarping()},isRunning:function(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)},
isScheduled:function(){return this._mixer._isActiveAction(this)},startAt:function(a){this._startTime=a;return this},setLoop:function(a,b){this.loop=a;this.repetitions=b;return this},setEffectiveWeight:function(a){this.weight=a;this._effectiveWeight=this.enabled?a:0;return this.stopFading()},getEffectiveWeight:function(){return this._effectiveWeight},fadeIn:function(a){return this._scheduleFading(a,0,1)},fadeOut:function(a){return this._scheduleFading(a,1,0)},crossFadeFrom:function(a,b,c){a.fadeOut(b);
this.fadeIn(b);if(c){c=this._clip.duration;var d=a._clip.duration,e=c/d;a.warp(1,d/c,b);this.warp(e,1,b)}return this},crossFadeTo:function(a,b,c){return a.crossFadeFrom(this,b,c)},stopFading:function(){var a=this._weightInterpolant;null!==a&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(a));return this},setEffectiveTimeScale:function(a){this.timeScale=a;this._effectiveTimeScale=this.paused?0:a;return this.stopWarping()},getEffectiveTimeScale:function(){return this._effectiveTimeScale},
setDuration:function(a){this.timeScale=this._clip.duration/a;return this.stopWarping()},syncWith:function(a){this.time=a.time;this.timeScale=a.timeScale;return this.stopWarping()},halt:function(a){return this.warp(this._effectiveTimeScale,0,a)},warp:function(a,b,c){var d=this._mixer,e=d.time,f=this._timeScaleInterpolant,g=this.timeScale;null===f&&(this._timeScaleInterpolant=f=d._lendControlInterpolant());d=f.parameterPositions;f=f.sampleValues;d[0]=e;d[1]=e+c;f[0]=a/g;f[1]=b/g;return this},stopWarping:function(){var a=
this._timeScaleInterpolant;null!==a&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(a));return this},getMixer:function(){return this._mixer},getClip:function(){return this._clip},getRoot:function(){return this._localRoot||this._mixer._root},_update:function(a,b,c,d){if(this.enabled){var e=this._startTime;if(null!==e){b=(a-e)*c;if(0>b||0===c)return;this._startTime=null;b*=c}b*=this._updateTimeScale(a);c=this._updateTime(b);a=this._updateWeight(a);if(0<a){b=this._interpolants;
for(var e=this._propertyBindings,f=0,g=b.length;f!==g;++f)b[f].evaluate(c),e[f].accumulate(d,a)}}else this._updateWeight(a)},_updateWeight:function(a){var b=0;if(this.enabled){var b=this.weight,c=this._weightInterpolant;if(null!==c){var d=c.evaluate(a)[0],b=b*d;a>c.parameterPositions[1]&&(this.stopFading(),0===d&&(this.enabled=!1))}}return this._effectiveWeight=b},_updateTimeScale:function(a){var b=0;if(!this.paused){var b=this.timeScale,c=this._timeScaleInterpolant;if(null!==c){var d=c.evaluate(a)[0],
b=b*d;a>c.parameterPositions[1]&&(this.stopWarping(),0===b?this.paused=!0:this.timeScale=b)}}return this._effectiveTimeScale=b},_updateTime:function(a){var b=this.time+a;if(0===a)return b;var c=this._clip.duration,d=this.loop,e=this._loopCount;if(2200===d)a:{if(-1===e&&(this._loopCount=0,this._setEndings(!0,!0,!1)),b>=c)b=c;else if(0>b)b=0;else break a;this.clampWhenFinished?this.paused=!0:this.enabled=!1;this._mixer.dispatchEvent({type:"finished",action:this,direction:0>a?-1:1})}else{d=2202===d;
-1===e&&(0<=a?(e=0,this._setEndings(!0,0===this.repetitions,d)):this._setEndings(0===this.repetitions,!0,d));if(b>=c||0>b){var f=Math.floor(b/c),b=b-c*f,e=e+Math.abs(f),g=this.repetitions-e;0>g?(this.clampWhenFinished?this.paused=!0:this.enabled=!1,b=0<a?c:0,this._mixer.dispatchEvent({type:"finished",action:this,direction:0<a?1:-1})):(0===g?(a=0>a,this._setEndings(a,!a,d)):this._setEndings(!1,!1,d),this._loopCount=e,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:f}))}if(d&&1===(e&1))return this.time=
b,c-b}return this.time=b},_setEndings:function(a,b,c){var d=this._interpolantSettings;c?(d.endingStart=2401,d.endingEnd=2401):(d.endingStart=a?this.zeroSlopeAtStart?2401:2400:2402,d.endingEnd=b?this.zeroSlopeAtEnd?2401:2400:2402)},_scheduleFading:function(a,b,c){var d=this._mixer,e=d.time,f=this._weightInterpolant;null===f&&(this._weightInterpolant=f=d._lendControlInterpolant());d=f.parameterPositions;f=f.sampleValues;d[0]=e;f[0]=b;d[1]=e+a;f[1]=c;return this}});Object.assign(Ye.prototype,ja.prototype,
{_bindAction:function(a,b){var c=a._localRoot||this._root,d=a._clip.tracks,e=d.length,f=a._propertyBindings;a=a._interpolants;var g=c.uuid,h=this._bindingsByRootAndName,k=h[g];void 0===k&&(k={},h[g]=k);for(h=0;h!==e;++h){var l=d[h],m=l.name,n=k[m];if(void 0===n){n=f[h];if(void 0!==n){null===n._cacheIndex&&(++n.referenceCount,this._addInactiveBinding(n,g,m));continue}n=new je(na.create(c,m,b&&b._propertyBindings[h].binding.parsedPath),l.ValueTypeName,l.getValueSize());++n.referenceCount;this._addInactiveBinding(n,
g,m)}f[h]=n;a[h].resultBuffer=n.buffer}},_activateAction:function(a){if(!this._isActiveAction(a)){if(null===a._cacheIndex){var b=(a._localRoot||this._root).uuid,c=a._clip.uuid,d=this._actionsByClip[c];this._bindAction(a,d&&d.knownActions[0]);this._addInactiveAction(a,c,b)}b=a._propertyBindings;c=0;for(d=b.length;c!==d;++c){var e=b[c];0===e.useCount++&&(this._lendBinding(e),e.saveOriginalState())}this._lendAction(a)}},_deactivateAction:function(a){if(this._isActiveAction(a)){for(var b=a._propertyBindings,
c=0,d=b.length;c!==d;++c){var e=b[c];0===--e.useCount&&(e.restoreOriginalState(),this._takeBackBinding(e))}this._takeBackAction(a)}},_initMemoryManager:function(){this._actions=[];this._nActiveActions=0;this._actionsByClip={};this._bindings=[];this._nActiveBindings=0;this._bindingsByRootAndName={};this._controlInterpolants=[];this._nActiveControlInterpolants=0;var a=this;this.stats={actions:{get total(){return a._actions.length},get inUse(){return a._nActiveActions}},bindings:{get total(){return a._bindings.length},
get inUse(){return a._nActiveBindings}},controlInterpolants:{get total(){return a._controlInterpolants.length},get inUse(){return a._nActiveControlInterpolants}}}},_isActiveAction:function(a){a=a._cacheIndex;return null!==a&&a<this._nActiveActions},_addInactiveAction:function(a,b,c){var d=this._actions,e=this._actionsByClip,f=e[b];void 0===f?(f={knownActions:[a],actionByRoot:{}},a._byClipCacheIndex=0,e[b]=f):(b=f.knownActions,a._byClipCacheIndex=b.length,b.push(a));a._cacheIndex=d.length;d.push(a);
f.actionByRoot[c]=a},_removeInactiveAction:function(a){var b=this._actions,c=b[b.length-1],d=a._cacheIndex;c._cacheIndex=d;b[d]=c;b.pop();a._cacheIndex=null;var b=a._clip.uuid,c=this._actionsByClip,d=c[b],e=d.knownActions,f=e[e.length-1],g=a._byClipCacheIndex;f._byClipCacheIndex=g;e[g]=f;e.pop();a._byClipCacheIndex=null;delete d.actionByRoot[(a._localRoot||this._root).uuid];0===e.length&&delete c[b];this._removeInactiveBindingsForAction(a)},_removeInactiveBindingsForAction:function(a){a=a._propertyBindings;
for(var b=0,c=a.length;b!==c;++b){var d=a[b];0===--d.referenceCount&&this._removeInactiveBinding(d)}},_lendAction:function(a){var b=this._actions,c=a._cacheIndex,d=this._nActiveActions++,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_takeBackAction:function(a){var b=this._actions,c=a._cacheIndex,d=--this._nActiveActions,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_addInactiveBinding:function(a,b,c){var d=this._bindingsByRootAndName,e=d[b],f=this._bindings;void 0===e&&(e={},d[b]=
e);e[c]=a;a._cacheIndex=f.length;f.push(a)},_removeInactiveBinding:function(a){var b=this._bindings,c=a.binding,d=c.rootNode.uuid,c=c.path,e=this._bindingsByRootAndName,f=e[d],g=b[b.length-1];a=a._cacheIndex;g._cacheIndex=a;b[a]=g;b.pop();delete f[c];a:{for(var h in f)break a;delete e[d]}},_lendBinding:function(a){var b=this._bindings,c=a._cacheIndex,d=this._nActiveBindings++,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_takeBackBinding:function(a){var b=this._bindings,c=a._cacheIndex,d=
--this._nActiveBindings,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_lendControlInterpolant:function(){var a=this._controlInterpolants,b=this._nActiveControlInterpolants++,c=a[b];void 0===c&&(c=new Yc(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),c.__cacheIndex=b,a[b]=c);return c},_takeBackControlInterpolant:function(a){var b=this._controlInterpolants,c=a.__cacheIndex,d=--this._nActiveControlInterpolants,e=b[d];a.__cacheIndex=d;b[d]=a;e.__cacheIndex=c;
b[c]=e},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(a,b){var c=b||this._root,d=c.uuid,c="string"===typeof a?ka.findByName(c,a):a;a=null!==c?c.uuid:a;var e=this._actionsByClip[a],f=null;if(void 0!==e){f=e.actionByRoot[d];if(void 0!==f)return f;f=e.knownActions[0];null===c&&(c=f._clip)}if(null===c)return null;b=new Xe(this,c,b);this._bindAction(b,f);this._addInactiveAction(b,a,d);return b},existingAction:function(a,b){var c=b||this._root;b=c.uuid;c="string"===typeof a?ka.findByName(c,
a):a;a=this._actionsByClip[c?c.uuid:a];return void 0!==a?a.actionByRoot[b]||null:null},stopAllAction:function(){for(var a=this._actions,b=this._nActiveActions,c=this._bindings,d=this._nActiveBindings,e=this._nActiveBindings=this._nActiveActions=0;e!==b;++e)a[e].reset();for(e=0;e!==d;++e)c[e].useCount=0;return this},update:function(a){a*=this.timeScale;for(var b=this._actions,c=this._nActiveActions,d=this.time+=a,e=Math.sign(a),f=this._accuIndex^=1,g=0;g!==c;++g)b[g]._update(d,a,e,f);a=this._bindings;
b=this._nActiveBindings;for(g=0;g!==b;++g)a[g].apply(f);return this},getRoot:function(){return this._root},uncacheClip:function(a){var b=this._actions;a=a.uuid;var c=this._actionsByClip,d=c[a];if(void 0!==d){for(var d=d.knownActions,e=0,f=d.length;e!==f;++e){var g=d[e];this._deactivateAction(g);var h=g._cacheIndex,k=b[b.length-1];g._cacheIndex=null;g._byClipCacheIndex=null;k._cacheIndex=h;b[h]=k;b.pop();this._removeInactiveBindingsForAction(g)}delete c[a]}},uncacheRoot:function(a){a=a.uuid;var b=
this._actionsByClip;for(d in b){var c=b[d].actionByRoot[a];void 0!==c&&(this._deactivateAction(c),this._removeInactiveAction(c))}var d=this._bindingsByRootAndName[a];if(void 0!==d)for(var e in d)a=d[e],a.restoreOriginalState(),this._removeInactiveBinding(a)},uncacheAction:function(a,b){a=this.existingAction(a,b);null!==a&&(this._deactivateAction(a),this._removeInactiveAction(a))}});Jd.prototype.clone=function(){return new Jd(void 0===this.value.clone?this.value:this.value.clone())};ke.prototype=Object.assign(Object.create(D.prototype),
{constructor:ke,isInstancedBufferGeometry:!0,copy:function(a){D.prototype.copy.call(this,a);this.maxInstancedCount=a.maxInstancedCount;return this},clone:function(){return(new this.constructor).copy(this)}});Object.defineProperties(le.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}}});Object.assign(le.prototype,{isInterleavedBufferAttribute:!0,setX:function(a,b){this.data.array[a*this.data.stride+this.offset]=b;return this},setY:function(a,b){this.data.array[a*
this.data.stride+this.offset+1]=b;return this},setZ:function(a,b){this.data.array[a*this.data.stride+this.offset+2]=b;return this},setW:function(a,b){this.data.array[a*this.data.stride+this.offset+3]=b;return this},getX:function(a){return this.data.array[a*this.data.stride+this.offset]},getY:function(a){return this.data.array[a*this.data.stride+this.offset+1]},getZ:function(a){return this.data.array[a*this.data.stride+this.offset+2]},getW:function(a){return this.data.array[a*this.data.stride+this.offset+
3]},setXY:function(a,b,c){a=a*this.data.stride+this.offset;this.data.array[a+0]=b;this.data.array[a+1]=c;return this},setXYZ:function(a,b,c,d){a=a*this.data.stride+this.offset;this.data.array[a+0]=b;this.data.array[a+1]=c;this.data.array[a+2]=d;return this},setXYZW:function(a,b,c,d,e){a=a*this.data.stride+this.offset;this.data.array[a+0]=b;this.data.array[a+1]=c;this.data.array[a+2]=d;this.data.array[a+3]=e;return this}});Object.defineProperty(mc.prototype,"needsUpdate",{set:function(a){!0===a&&this.version++}});
Object.assign(mc.prototype,{isInterleavedBuffer:!0,setArray:function(a){if(Array.isArray(a))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.count=void 0!==a?a.length/this.stride:0;this.array=a},setDynamic:function(a){this.dynamic=a;return this},copy:function(a){this.array=new a.array.constructor(a.array);this.count=a.count;this.stride=a.stride;this.dynamic=a.dynamic;return this},copyAt:function(a,b,c){a*=this.stride;c*=b.stride;for(var d=0,e=this.stride;d<e;d++)this.array[a+
d]=b.array[c+d];return this},set:function(a,b){void 0===b&&(b=0);this.array.set(a,b);return this},clone:function(){return(new this.constructor).copy(this)},onUpload:function(a){this.onUploadCallback=a;return this}});me.prototype=Object.assign(Object.create(mc.prototype),{constructor:me,isInstancedInterleavedBuffer:!0,copy:function(a){mc.prototype.copy.call(this,a);this.meshPerAttribute=a.meshPerAttribute;return this}});ne.prototype=Object.assign(Object.create(P.prototype),{constructor:ne,isInstancedBufferAttribute:!0,
copy:function(a){P.prototype.copy.call(this,a);this.meshPerAttribute=a.meshPerAttribute;return this}});Object.assign(Ze.prototype,{linePrecision:1,set:function(a,b){this.ray.set(a,b)},setFromCamera:function(a,b){b&&b.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(b.matrixWorld),this.ray.direction.set(a.x,a.y,.5).unproject(b).sub(this.ray.origin).normalize()):b&&b.isOrthographicCamera?(this.ray.origin.set(a.x,a.y,(b.near+b.far)/(b.near-b.far)).unproject(b),this.ray.direction.set(0,0,-1).transformDirection(b.matrixWorld)):
console.error("THREE.Raycaster: Unsupported camera type.")},intersectObject:function(a,b){var c=[];oe(a,this,c,b);c.sort($e);return c},intersectObjects:function(a,b){var c=[];if(!1===Array.isArray(a))return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),c;for(var d=0,e=a.length;d<e;d++)oe(a[d],this,c,b);c.sort($e);return c}});Object.assign(af.prototype,{start:function(){this.oldTime=this.startTime=("undefined"===typeof performance?Date:performance).now();this.elapsedTime=
0;this.running=!0},stop:function(){this.getElapsedTime();this.autoStart=this.running=!1},getElapsedTime:function(){this.getDelta();return this.elapsedTime},getDelta:function(){var a=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){var b=("undefined"===typeof performance?Date:performance).now(),a=(b-this.oldTime)/1E3;this.oldTime=b;this.elapsedTime+=a}return a}});Object.assign(bf.prototype,{set:function(a,b,c){this.radius=a;this.phi=b;this.theta=c;return this},clone:function(){return(new this.constructor).copy(this)},
copy:function(a){this.radius=a.radius;this.phi=a.phi;this.theta=a.theta;return this},makeSafe:function(){this.phi=Math.max(1E-6,Math.min(Math.PI-1E-6,this.phi));return this},setFromVector3:function(a){this.radius=a.length();0===this.radius?this.phi=this.theta=0:(this.theta=Math.atan2(a.x,a.z),this.phi=Math.acos(R.clamp(a.y/this.radius,-1,1)));return this}});Object.assign(cf.prototype,{set:function(a,b,c){this.radius=a;this.theta=b;this.y=c;return this},clone:function(){return(new this.constructor).copy(this)},
copy:function(a){this.radius=a.radius;this.theta=a.theta;this.y=a.y;return this},setFromVector3:function(a){this.radius=Math.sqrt(a.x*a.x+a.z*a.z);this.theta=Math.atan2(a.x,a.z);this.y=a.y;return this}});ad.prototype=Object.create(A.prototype);ad.prototype.constructor=ad;ad.prototype.isImmediateRenderObject=!0;bd.prototype=Object.create(ca.prototype);bd.prototype.constructor=bd;bd.prototype.update=function(){var a=new p,b=new p,c=new ra;return function(){var d,e=["a","b","c"];this.object.updateMatrixWorld(!0);
c.getNormalMatrix(this.object.matrixWorld);var f=this.object.matrixWorld,g=this.geometry.attributes.position;if((d=this.object.geometry)&&d.isGeometry)for(var h=d.vertices,k=d.faces,l=d=0,m=k.length;l<m;l++)for(var n=k[l],p=0,r=n.vertexNormals.length;p<r;p++){var u=n.vertexNormals[p];a.copy(h[n[e[p]]]).applyMatrix4(f);b.copy(u).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);g.setXYZ(d,a.x,a.y,a.z);d+=1;g.setXYZ(d,b.x,b.y,b.z);d+=1}else if(d&&d.isBufferGeometry)for(e=d.attributes.position,
h=d.attributes.normal,p=d=0,r=e.count;p<r;p++)a.set(e.getX(p),e.getY(p),e.getZ(p)).applyMatrix4(f),b.set(h.getX(p),h.getY(p),h.getZ(p)),b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a),g.setXYZ(d,a.x,a.y,a.z),d+=1,g.setXYZ(d,b.x,b.y,b.z),d+=1;g.needsUpdate=!0}}();nc.prototype=Object.create(A.prototype);nc.prototype.constructor=nc;nc.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose()};nc.prototype.update=function(){var a=new p,b=new p;return function(){this.light.updateMatrixWorld();
var c=this.light.distance?this.light.distance:1E3,d=c*Math.tan(this.light.angle);this.cone.scale.set(d,d,c);a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(b.sub(a));void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}();oc.prototype=Object.create(ca.prototype);oc.prototype.constructor=oc;oc.prototype.updateMatrixWorld=function(){var a=new p,b=new K,c=new K;return function(d){var e=
this.bones,f=this.geometry,g=f.getAttribute("position");c.getInverse(this.root.matrixWorld);for(var h=0,k=0;h<e.length;h++){var l=e[h];l.parent&&l.parent.isBone&&(b.multiplyMatrices(c,l.matrixWorld),a.setFromMatrixPosition(b),g.setXYZ(k,a.x,a.y,a.z),b.multiplyMatrices(c,l.parent.matrixWorld),a.setFromMatrixPosition(b),g.setXYZ(k+1,a.x,a.y,a.z),k+=2)}f.getAttribute("position").needsUpdate=!0;A.prototype.updateMatrixWorld.call(this,d)}}();pc.prototype=Object.create(pa.prototype);pc.prototype.constructor=
pc;pc.prototype.dispose=function(){this.geometry.dispose();this.material.dispose()};pc.prototype.update=function(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)};qc.prototype=Object.create(A.prototype);qc.prototype.constructor=qc;qc.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose()};qc.prototype.update=function(){var a=.5*this.light.width,b=.5*this.light.height,c=this.line.geometry.attributes.position,
d=c.array;d[0]=a;d[1]=-b;d[2]=0;d[3]=a;d[4]=b;d[5]=0;d[6]=-a;d[7]=b;d[8]=0;d[9]=-a;d[10]=-b;d[11]=0;d[12]=a;d[13]=-b;d[14]=0;c.needsUpdate=!0;void 0!==this.color?this.line.material.color.set(this.color):this.line.material.color.copy(this.light.color)};rc.prototype=Object.create(A.prototype);rc.prototype.constructor=rc;rc.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose()};rc.prototype.update=function(){var a=new p,b=new H,c=new H;return function(){var d=
this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{var e=d.geometry.getAttribute("color");b.copy(this.light.color);c.copy(this.light.groundColor);for(var f=0,g=e.count;f<g;f++){var h=f<g/2?b:c;e.setXYZ(f,h.r,h.g,h.b)}e.needsUpdate=!0}d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate())}}();cd.prototype=Object.create(ca.prototype);cd.prototype.constructor=cd;Kd.prototype=Object.create(ca.prototype);Kd.prototype.constructor=Kd;dd.prototype=Object.create(ca.prototype);
dd.prototype.constructor=dd;dd.prototype.update=function(){var a=new p,b=new p,c=new ra;return function(){this.object.updateMatrixWorld(!0);c.getNormalMatrix(this.object.matrixWorld);for(var d=this.object.matrixWorld,e=this.geometry.attributes.position,f=this.object.geometry,g=f.vertices,f=f.faces,h=0,k=0,l=f.length;k<l;k++){var m=f[k],n=m.normal;a.copy(g[m.a]).add(g[m.b]).add(g[m.c]).divideScalar(3).applyMatrix4(d);b.copy(n).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);e.setXYZ(h,
a.x,a.y,a.z);h+=1;e.setXYZ(h,b.x,b.y,b.z);h+=1}e.needsUpdate=!0}}();sc.prototype=Object.create(A.prototype);sc.prototype.constructor=sc;sc.prototype.dispose=function(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose()};sc.prototype.update=function(){var a=new p,b=new p,c=new p;return function(){a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);c.subVectors(b,
a);this.lightPlane.lookAt(c);void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color));this.targetLine.lookAt(c);this.targetLine.scale.z=c.length()}}();ed.prototype=Object.create(ca.prototype);ed.prototype.constructor=ed;ed.prototype.update=function(){function a(a,g,h,k){d.set(g,h,k).unproject(e);a=c[a];if(void 0!==a)for(g=b.getAttribute("position"),
h=0,k=a.length;h<k;h++)g.setXYZ(a[h],d.x,d.y,d.z)}var b,c,d=new p,e=new La;return function(){b=this.geometry;c=this.pointMap;e.projectionMatrix.copy(this.camera.projectionMatrix);a("c",0,0,-1);a("t",0,0,1);a("n1",-1,-1,-1);a("n2",1,-1,-1);a("n3",-1,1,-1);a("n4",1,1,-1);a("f1",-1,-1,1);a("f2",1,-1,1);a("f3",-1,1,1);a("f4",1,1,1);a("u1",.7,1.1,-1);a("u2",-.7,1.1,-1);a("u3",0,2,-1);a("cf1",-1,0,1);a("cf2",1,0,1);a("cf3",0,-1,1);a("cf4",0,1,1);a("cn1",-1,0,-1);a("cn2",1,0,-1);a("cn3",0,-1,-1);a("cn4",
0,1,-1);b.getAttribute("position").needsUpdate=!0}}();Db.prototype=Object.create(ca.prototype);Db.prototype.constructor=Db;Db.prototype.update=function(){var a=new Oa;return function(b){void 0!==b&&console.warn("THREE.BoxHelper: .update() has no longer arguments.");void 0!==this.object&&a.setFromObject(this.object);if(!a.isEmpty()){b=a.min;var c=a.max,d=this.geometry.attributes.position,e=d.array;e[0]=c.x;e[1]=c.y;e[2]=c.z;e[3]=b.x;e[4]=c.y;e[5]=c.z;e[6]=b.x;e[7]=b.y;e[8]=c.z;e[9]=c.x;e[10]=b.y;e[11]=
c.z;e[12]=c.x;e[13]=c.y;e[14]=b.z;e[15]=b.x;e[16]=c.y;e[17]=b.z;e[18]=b.x;e[19]=b.y;e[20]=b.z;e[21]=c.x;e[22]=b.y;e[23]=b.z;d.needsUpdate=!0;this.geometry.computeBoundingSphere()}}}();Db.prototype.setFromObject=function(a){this.object=a;this.update();return this};fd.prototype=Object.create(ca.prototype);fd.prototype.constructor=fd;fd.prototype.updateMatrixWorld=function(a){var b=this.box;b.isEmpty()||(b.getCenter(this.position),b.getSize(this.scale),this.scale.multiplyScalar(.5),A.prototype.updateMatrixWorld.call(this,
a))};gd.prototype=Object.create(ma.prototype);gd.prototype.constructor=gd;gd.prototype.updateMatrixWorld=function(a){var b=-this.plane.constant;1E-8>Math.abs(b)&&(b=1E-8);this.scale.set(.5*this.size,.5*this.size,b);this.lookAt(this.plane.normal);A.prototype.updateMatrixWorld.call(this,a)};var Ld,pe;Eb.prototype=Object.create(A.prototype);Eb.prototype.constructor=Eb;Eb.prototype.setDirection=function(){var a=new p,b;return function(c){.99999<c.y?this.quaternion.set(0,0,0,1):-.99999>c.y?this.quaternion.set(1,
0,0,0):(a.set(c.z,0,-c.x).normalize(),b=Math.acos(c.y),this.quaternion.setFromAxisAngle(a,b))}}();Eb.prototype.setLength=function(a,b,c){void 0===b&&(b=.2*a);void 0===c&&(c=.2*b);this.line.scale.set(1,Math.max(0,a-b),1);this.line.updateMatrix();this.cone.scale.set(c,b,c);this.cone.position.y=a;this.cone.updateMatrix()};Eb.prototype.setColor=function(a){this.line.material.color.copy(a);this.cone.material.color.copy(a)};hd.prototype=Object.create(ca.prototype);hd.prototype.constructor=hd;var Nd=new p,
te=new qe,ue=new qe,ve=new qe;ya.prototype=Object.create(S.prototype);ya.prototype.constructor=ya;ya.prototype.isCatmullRomCurve3=!0;ya.prototype.getPoint=function(a,b){b=b||new p;var c=this.points,d=c.length;a*=d-(this.closed?0:1);var e=Math.floor(a);a-=e;this.closed?e+=0<e?0:(Math.floor(Math.abs(e)/c.length)+1)*c.length:0===a&&e===d-1&&(e=d-2,a=1);if(this.closed||0<e)var f=c[(e-1)%d];else Nd.subVectors(c[0],c[1]).add(c[0]),f=Nd;var g=c[e%d];var h=c[(e+1)%d];this.closed||e+2<d?c=c[(e+2)%d]:(Nd.subVectors(c[d-
1],c[d-2]).add(c[d-1]),c=Nd);if("centripetal"===this.curveType||"chordal"===this.curveType){var k="chordal"===this.curveType?.5:.25,d=Math.pow(f.distanceToSquared(g),k),e=Math.pow(g.distanceToSquared(h),k),k=Math.pow(h.distanceToSquared(c),k);1E-4>e&&(e=1);1E-4>d&&(d=e);1E-4>k&&(k=e);te.initNonuniformCatmullRom(f.x,g.x,h.x,c.x,d,e,k);ue.initNonuniformCatmullRom(f.y,g.y,h.y,c.y,d,e,k);ve.initNonuniformCatmullRom(f.z,g.z,h.z,c.z,d,e,k)}else"catmullrom"===this.curveType&&(te.initCatmullRom(f.x,g.x,h.x,
c.x,this.tension),ue.initCatmullRom(f.y,g.y,h.y,c.y,this.tension),ve.initCatmullRom(f.z,g.z,h.z,c.z,this.tension));b.set(te.calc(a),ue.calc(a),ve.calc(a));return b};ya.prototype.copy=function(a){S.prototype.copy.call(this,a);this.points=[];for(var b=0,c=a.points.length;b<c;b++)this.points.push(a.points[b].clone());this.closed=a.closed;this.curveType=a.curveType;this.tension=a.tension;return this};Fb.prototype=Object.create(S.prototype);Fb.prototype.constructor=Fb;Fb.prototype.isCubicBezierCurve3=
!0;Fb.prototype.getPoint=function(a,b){b=b||new p;var c=this.v0,d=this.v1,e=this.v2,f=this.v3;b.set(zb(a,c.x,d.x,e.x,f.x),zb(a,c.y,d.y,e.y,f.y),zb(a,c.z,d.z,e.z,f.z));return b};Fb.prototype.copy=function(a){S.prototype.copy.call(this,a);this.v0.copy(a.v0);this.v1.copy(a.v1);this.v2.copy(a.v2);this.v3.copy(a.v3);return this};Gb.prototype=Object.create(S.prototype);Gb.prototype.constructor=Gb;Gb.prototype.isQuadraticBezierCurve3=!0;Gb.prototype.getPoint=function(a,b){b=b||new p;var c=this.v0,d=this.v1,
e=this.v2;b.set(yb(a,c.x,d.x,e.x),yb(a,c.y,d.y,e.y),yb(a,c.z,d.z,e.z));return b};Gb.prototype.copy=function(a){S.prototype.copy.call(this,a);this.v0.copy(a.v0);this.v1.copy(a.v1);this.v2.copy(a.v2);return this};db.prototype=Object.create(S.prototype);db.prototype.constructor=db;db.prototype.isLineCurve3=!0;db.prototype.getPoint=function(a,b){b=b||new p;1===a?b.copy(this.v2):(b.copy(this.v2).sub(this.v1),b.multiplyScalar(a).add(this.v1));return b};db.prototype.getPointAt=function(a,b){return this.getPoint(a,
b)};db.prototype.copy=function(a){S.prototype.copy.call(this,a);this.v1.copy(a.v1);this.v2.copy(a.v2);return this};id.prototype=Object.create(Na.prototype);id.prototype.constructor=id;id.prototype.isArcCurve=!0;S.create=function(a,b){console.log("THREE.Curve.create() has been deprecated");a.prototype=Object.create(S.prototype);a.prototype.constructor=a;a.prototype.getPoint=b;return a};Object.assign(Ab.prototype,{createPointsGeometry:function(a){console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
a=this.getPoints(a);return this.createGeometry(a)},createSpacedPointsGeometry:function(a){console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");a=this.getSpacedPoints(a);return this.createGeometry(a)},createGeometry:function(a){console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");for(var b=new N,c=0,d=a.length;c<d;c++){var e=a[c];b.vertices.push(new p(e.x,
e.y,e.z||0))}return b}});Object.assign(Bb.prototype,{fromPoints:function(a){console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");this.setFromPoints(a)}});ef.prototype=Object.create(ya.prototype);ff.prototype=Object.create(ya.prototype);re.prototype=Object.create(ya.prototype);Object.assign(re.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},
reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}});cd.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};oc.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};Object.assign(kd.prototype,{center:function(a){console.warn("THREE.Box2: .center() has been renamed to .getCenter().");return this.getCenter(a)},
empty:function(){console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");return this.isEmpty()},isIntersectionBox:function(a){console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");return this.intersectsBox(a)},size:function(a){console.warn("THREE.Box2: .size() has been renamed to .getSize().");return this.getSize(a)}});Object.assign(Oa.prototype,{center:function(a){console.warn("THREE.Box3: .center() has been renamed to .getCenter().");return this.getCenter(a)},
empty:function(){console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");return this.isEmpty()},isIntersectionBox:function(a){console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");return this.intersectsBox(a)},isIntersectionSphere:function(a){console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");return this.intersectsSphere(a)},size:function(a){console.warn("THREE.Box3: .size() has been renamed to .getSize().");return this.getSize(a)}});
Mb.prototype.center=function(a){console.warn("THREE.Line3: .center() has been renamed to .getCenter().");return this.getCenter(a)};Object.assign(R,{random16:function(){console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");return Math.random()},nearestPowerOfTwo:function(a){console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");return R.floorPowerOfTwo(a)},nextPowerOfTwo:function(a){console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
return R.ceilPowerOfTwo(a)}});Object.assign(ra.prototype,{flattenToArrayOffset:function(a,b){console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(a,b)},multiplyVector3:function(a){console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");return a.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBuffer:function(a){console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
return this.applyToBufferAttribute(a)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")}});Object.assign(K.prototype,{extractPosition:function(a){console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");return this.copyPosition(a)},flattenToArrayOffset:function(a,b){console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(a,b)},getPosition:function(){var a;
return function(){void 0===a&&(a=new p);console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");return a.setFromMatrixColumn(this,3)}}(),setRotationFromQuaternion:function(a){console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");return this.makeRotationFromQuaternion(a)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(a){console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
return a.applyMatrix4(this)},multiplyVector4:function(a){console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");return a.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(a){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");a.transformDirection(this)},crossVector:function(a){console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
return a.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBuffer:function(a){console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
return this.applyToBufferAttribute(a)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(a,b,c,d,e,f){console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");return this.makePerspective(a,b,d,c,e,f)}});Aa.prototype.isIntersectionLine=function(a){console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");return this.intersectsLine(a)};
Z.prototype.multiplyVector3=function(a){console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");return a.applyQuaternion(this)};Object.assign(lb.prototype,{isIntersectionBox:function(a){console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");return this.intersectsBox(a)},isIntersectionPlane:function(a){console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");return this.intersectsPlane(a)},
isIntersectionSphere:function(a){console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");return this.intersectsSphere(a)}});Object.assign(Cb.prototype,{extractAllPoints:function(a){console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");return this.extractPoints(a)},extrude:function(a){console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");return new $a(this,a)},makeGeometry:function(a){console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
return new cc(this,a)}});Object.assign(C.prototype,{fromAttribute:function(a,b,c){console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");return this.fromBufferAttribute(a,b,c)},distanceToManhattan:function(a){console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");return this.manhattanDistanceTo(a)},lengthManhattan:function(){console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");return this.manhattanLength()}});
Object.assign(p.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(a){console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");return this.setFromMatrixPosition(a)},
getScaleFromMatrix:function(a){console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");return this.setFromMatrixScale(a)},getColumnFromMatrix:function(a,b){console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");return this.setFromMatrixColumn(b,a)},applyProjection:function(a){console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");return this.applyMatrix4(a)},fromAttribute:function(a,
b,c){console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");return this.fromBufferAttribute(a,b,c)},distanceToManhattan:function(a){console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");return this.manhattanDistanceTo(a)},lengthManhattan:function(){console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");return this.manhattanLength()}});Object.assign(da.prototype,{fromAttribute:function(a,
b,c){console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");return this.fromBufferAttribute(a,b,c)},lengthManhattan:function(){console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");return this.manhattanLength()}});N.prototype.computeTangents=function(){console.warn("THREE.Geometry: .computeTangents() has been removed.")};Object.assign(A.prototype,{getChildByName:function(a){console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
return this.getObjectByName(a)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(a,b){console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");return this.translateOnAxis(b,a)}});Object.defineProperties(A.prototype,{eulerOrder:{get:function(){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");return this.rotation.order},set:function(a){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
this.rotation.order=a}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Object.defineProperties(Dc.prototype,{objects:{get:function(){console.warn("THREE.LOD: .objects has been renamed to .levels.");return this.levels}}});Object.defineProperty(Ec.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},
set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}});Object.defineProperty(S.prototype,"__arcLengthDivisions",{get:function(){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");return this.arcLengthDivisions},set:function(a){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");this.arcLengthDivisions=a}});U.prototype.setLens=function(a,b){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
void 0!==b&&(this.filmGauge=b);this.setFocalLength(a)};Object.defineProperties(ga.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(a){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");this.shadow.camera.fov=a}},shadowCameraLeft:{set:function(a){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");this.shadow.camera.left=a}},shadowCameraRight:{set:function(a){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
this.shadow.camera.right=a}},shadowCameraTop:{set:function(a){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");this.shadow.camera.top=a}},shadowCameraBottom:{set:function(a){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");this.shadow.camera.bottom=a}},shadowCameraNear:{set:function(a){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");this.shadow.camera.near=a}},shadowCameraFar:{set:function(a){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
this.shadow.camera.far=a}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(a){console.warn("THREE.Light: .shadowBias is now .shadow.bias.");this.shadow.bias=a}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(a){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
this.shadow.mapSize.width=a}},shadowMapHeight:{set:function(a){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");this.shadow.mapSize.height=a}}});Object.defineProperties(P.prototype,{length:{get:function(){console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");return this.array.length}}});Object.assign(D.prototype,{addIndex:function(a){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");this.setIndex(a)},addDrawCall:function(a,
b,c){void 0!==c&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");this.addGroup(a,b)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");this.clearGroups()},computeTangents:function(){console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")}});
Object.defineProperties(D.prototype,{drawcalls:{get:function(){console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");return this.groups}},offsets:{get:function(){console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");return this.groups}}});Object.defineProperties(Jd.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
return this}}});Object.defineProperties(Q.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},wrapRGB:{get:function(){console.warn("THREE.Material: .wrapRGB has been removed.");return new H}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(a){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.");
this.flatShading=1===a}}});Object.defineProperties(Ia.prototype,{metal:{get:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");return!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}});Object.defineProperties(oa.prototype,{derivatives:{get:function(){console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");return this.extensions.derivatives},
set:function(a){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");this.extensions.derivatives=a}}});Object.assign(Wd.prototype,{getCurrentRenderTarget:function(){console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");return this.getRenderTarget()},getMaxAnisotropy:function(){console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");return this.capabilities.getMaxAnisotropy()},getPrecision:function(){console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
return this.capabilities.precision},resetGLState:function(){console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");return this.state.reset()},supportsFloatTextures:function(){console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");return this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
return this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");return this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");return this.extensions.get("WEBGL_compressed_texture_s3tc")},
supportsCompressedTexturePVRTC:function(){console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");return this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");return this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
return this.capabilities.vertexTextures},supportsInstancedArrays:function(){console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");return this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(a){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");this.setScissorTest(a)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},
addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")}});Object.defineProperties(Wd.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");this.shadowMap.enabled=a}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
this.shadowMap.type=a}},shadowMapCullFace:{get:function(){return this.shadowMap.cullFace},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.");this.shadowMap.cullFace=a}}});Object.defineProperties(Ie.prototype,{cullFace:{get:function(){return this.renderReverseSided?2:1},set:function(a){a=1!==a;console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to "+a+".");this.renderReverseSided=a}}});Object.defineProperties(Hb.prototype,
{wrapS:{get:function(){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");return this.texture.wrapS},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");this.texture.wrapS=a}},wrapT:{get:function(){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");return this.texture.wrapT},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");this.texture.wrapT=a}},magFilter:{get:function(){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
return this.texture.magFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");this.texture.magFilter=a}},minFilter:{get:function(){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");return this.texture.minFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");this.texture.minFilter=a}},anisotropy:{get:function(){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
return this.texture.anisotropy},set:function(a){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");this.texture.anisotropy=a}},offset:{get:function(){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");return this.texture.offset},set:function(a){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");this.texture.offset=a}},repeat:{get:function(){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");return this.texture.repeat},
set:function(a){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");this.texture.repeat=a}},format:{get:function(){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");return this.texture.format},set:function(a){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");this.texture.format=a}},type:{get:function(){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");return this.texture.type},set:function(a){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
this.texture.type=a}},generateMipmaps:{get:function(){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");return this.texture.generateMipmaps},set:function(a){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");this.texture.generateMipmaps=a}}});lc.prototype.load=function(a){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");var b=this;(new ee).load(a,function(a){b.setBuffer(a)});return this};
ie.prototype.getData=function(){console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");return this.getFrequencyData()};$c.prototype.updateCubeMap=function(a,b){console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");return this.update(a,b)};m.WebGLRenderTargetCube=Ib;m.WebGLRenderTarget=Hb;m.WebGLRenderer=Wd;m.ShaderLib=mb;m.UniformsLib=E;m.UniformsUtils=Ea;m.ShaderChunk=W;m.FogExp2=Ob;m.Fog=Pb;m.Scene=od;m.LensFlare=Xd;m.Sprite=Cc;m.LOD=Dc;m.SkinnedMesh=qd;m.Skeleton=
Ec;m.Bone=pd;m.Mesh=pa;m.LineSegments=ca;m.LineLoop=rd;m.Line=ma;m.Points=Qb;m.Group=Fc;m.VideoTexture=sd;m.DataTexture=fb;m.CompressedTexture=Rb;m.CubeTexture=Ua;m.CanvasTexture=tc;m.DepthTexture=Gc;m.Texture=ea;m.CompressedTextureLoader=Qe;m.DataTextureLoader=Zd;m.CubeTextureLoader=$d;m.TextureLoader=td;m.ObjectLoader=Re;m.MaterialLoader=Id;m.BufferGeometryLoader=ae;m.DefaultLoadingManager=wa;m.LoadingManager=Yd;m.JSONLoader=be;m.ImageLoader=Xc;m.FontLoader=Te;m.FileLoader=Ja;m.Loader=kc;m.Cache=
jd;m.AudioLoader=ee;m.SpotLightShadow=vd;m.SpotLight=wd;m.PointLight=xd;m.RectAreaLight=Bd;m.HemisphereLight=ud;m.DirectionalLightShadow=yd;m.DirectionalLight=zd;m.AmbientLight=Ad;m.LightShadow=vb;m.Light=ga;m.StereoCamera=Ue;m.PerspectiveCamera=U;m.OrthographicCamera=Kb;m.CubeCamera=$c;m.ArrayCamera=nd;m.Camera=La;m.AudioListener=fe;m.PositionalAudio=he;m.AudioContext=ge;m.AudioAnalyser=ie;m.Audio=lc;m.VectorKeyframeTrack=ic;m.StringKeyframeTrack=Fd;m.QuaternionKeyframeTrack=Zc;m.NumberKeyframeTrack=
jc;m.ColorKeyframeTrack=Hd;m.BooleanKeyframeTrack=Gd;m.PropertyMixer=je;m.PropertyBinding=na;m.KeyframeTrack=xb;m.AnimationUtils=T;m.AnimationObjectGroup=We;m.AnimationMixer=Ye;m.AnimationClip=ka;m.Uniform=Jd;m.InstancedBufferGeometry=ke;m.BufferGeometry=D;m.Geometry=N;m.InterleavedBufferAttribute=le;m.InstancedInterleavedBuffer=me;m.InterleavedBuffer=mc;m.InstancedBufferAttribute=ne;m.Face3=Pa;m.Object3D=A;m.Raycaster=Ze;m.Layers=Pd;m.EventDispatcher=ja;m.Clock=af;m.QuaternionLinearInterpolant=Ed;
m.LinearInterpolant=Yc;m.DiscreteInterpolant=Dd;m.CubicInterpolant=Cd;m.Interpolant=xa;m.Triangle=Qa;m.Math=R;m.Spherical=bf;m.Cylindrical=cf;m.Plane=Aa;m.Frustum=ld;m.Sphere=Da;m.Ray=lb;m.Matrix4=K;m.Matrix3=ra;m.Box3=Oa;m.Box2=kd;m.Line3=Mb;m.Euler=Ya;m.Vector4=da;m.Vector3=p;m.Vector2=C;m.Quaternion=Z;m.Color=H;m.ImmediateRenderObject=ad;m.VertexNormalsHelper=bd;m.SpotLightHelper=nc;m.SkeletonHelper=oc;m.PointLightHelper=pc;m.RectAreaLightHelper=qc;m.HemisphereLightHelper=rc;m.GridHelper=cd;m.PolarGridHelper=
Kd;m.FaceNormalsHelper=dd;m.DirectionalLightHelper=sc;m.CameraHelper=ed;m.BoxHelper=Db;m.Box3Helper=fd;m.PlaneHelper=gd;m.ArrowHelper=Eb;m.AxesHelper=hd;m.CatmullRomCurve3=ya;m.CubicBezierCurve3=Fb;m.QuadraticBezierCurve3=Gb;m.LineCurve3=db;m.ArcCurve=id;m.EllipseCurve=Na;m.SplineCurve=ab;m.CubicBezierCurve=bb;m.QuadraticBezierCurve=cb;m.LineCurve=Ka;m.Shape=Cb;m.Path=Bb;m.ShapePath=ce;m.Font=de;m.CurvePath=Ab;m.Curve=S;m.ShapeUtils=Ha;m.SceneUtils={createMultiMaterialObject:function(a,b){for(var c=
new Fc,d=0,e=b.length;d<e;d++)c.add(new pa(a,b[d]));return c},detach:function(a,b,c){a.applyMatrix(b.matrixWorld);b.remove(a);c.add(a)},attach:function(a,b,c){a.applyMatrix((new K).getInverse(c.matrixWorld));b.remove(a);c.add(a)}};m.WebGLUtils=Pe;m.WireframeGeometry=Sb;m.ParametricGeometry=Hc;m.ParametricBufferGeometry=Tb;m.TetrahedronGeometry=Jc;m.TetrahedronBufferGeometry=Ub;m.OctahedronGeometry=Kc;m.OctahedronBufferGeometry=nb;m.IcosahedronGeometry=Lc;m.IcosahedronBufferGeometry=Vb;m.DodecahedronGeometry=
Mc;m.DodecahedronBufferGeometry=Wb;m.PolyhedronGeometry=Ic;m.PolyhedronBufferGeometry=qa;m.TubeGeometry=Nc;m.TubeBufferGeometry=Xb;m.TorusKnotGeometry=Oc;m.TorusKnotBufferGeometry=Yb;m.TorusGeometry=Pc;m.TorusBufferGeometry=Zb;m.TextGeometry=Qc;m.TextBufferGeometry=$b;m.SphereGeometry=Rc;m.SphereBufferGeometry=ob;m.RingGeometry=Sc;m.RingBufferGeometry=ac;m.PlaneGeometry=Ac;m.PlaneBufferGeometry=kb;m.LatheGeometry=Tc;m.LatheBufferGeometry=bc;m.ShapeGeometry=cc;m.ShapeBufferGeometry=dc;m.ExtrudeGeometry=
$a;m.ExtrudeBufferGeometry=Ga;m.EdgesGeometry=ec;m.ConeGeometry=Uc;m.ConeBufferGeometry=Vc;m.CylinderGeometry=pb;m.CylinderBufferGeometry=Sa;m.CircleGeometry=Wc;m.CircleBufferGeometry=fc;m.BoxGeometry=Lb;m.BoxBufferGeometry=jb;m.ShadowMaterial=gc;m.SpriteMaterial=Za;m.RawShaderMaterial=hc;m.ShaderMaterial=oa;m.PointsMaterial=Ba;m.MeshPhysicalMaterial=qb;m.MeshStandardMaterial=Ma;m.MeshPhongMaterial=Ia;m.MeshToonMaterial=rb;m.MeshNormalMaterial=sb;m.MeshLambertMaterial=tb;m.MeshDepthMaterial=Wa;m.MeshDistanceMaterial=
Xa;m.MeshBasicMaterial=va;m.LineDashedMaterial=ub;m.LineBasicMaterial=O;m.Material=Q;m.Float64BufferAttribute=zc;m.Float32BufferAttribute=y;m.Uint32BufferAttribute=ib;m.Int32BufferAttribute=yc;m.Uint16BufferAttribute=hb;m.Int16BufferAttribute=xc;m.Uint8ClampedBufferAttribute=wc;m.Uint8BufferAttribute=vc;m.Int8BufferAttribute=uc;m.BufferAttribute=P;m.REVISION="88";m.MOUSE={LEFT:0,MIDDLE:1,RIGHT:2};m.CullFaceNone=0;m.CullFaceBack=1;m.CullFaceFront=2;m.CullFaceFrontBack=3;m.FrontFaceDirectionCW=0;m.FrontFaceDirectionCCW=
1;m.BasicShadowMap=0;m.PCFShadowMap=1;m.PCFSoftShadowMap=2;m.FrontSide=0;m.BackSide=1;m.DoubleSide=2;m.FlatShading=1;m.SmoothShading=2;m.NoColors=0;m.FaceColors=1;m.VertexColors=2;m.NoBlending=0;m.NormalBlending=1;m.AdditiveBlending=2;m.SubtractiveBlending=3;m.MultiplyBlending=4;m.CustomBlending=5;m.AddEquation=100;m.SubtractEquation=101;m.ReverseSubtractEquation=102;m.MinEquation=103;m.MaxEquation=104;m.ZeroFactor=200;m.OneFactor=201;m.SrcColorFactor=202;m.OneMinusSrcColorFactor=203;m.SrcAlphaFactor=
204;m.OneMinusSrcAlphaFactor=205;m.DstAlphaFactor=206;m.OneMinusDstAlphaFactor=207;m.DstColorFactor=208;m.OneMinusDstColorFactor=209;m.SrcAlphaSaturateFactor=210;m.NeverDepth=0;m.AlwaysDepth=1;m.LessDepth=2;m.LessEqualDepth=3;m.EqualDepth=4;m.GreaterEqualDepth=5;m.GreaterDepth=6;m.NotEqualDepth=7;m.MultiplyOperation=0;m.MixOperation=1;m.AddOperation=2;m.NoToneMapping=0;m.LinearToneMapping=1;m.ReinhardToneMapping=2;m.Uncharted2ToneMapping=3;m.CineonToneMapping=4;m.UVMapping=300;m.CubeReflectionMapping=
301;m.CubeRefractionMapping=302;m.EquirectangularReflectionMapping=303;m.EquirectangularRefractionMapping=304;m.SphericalReflectionMapping=305;m.CubeUVReflectionMapping=306;m.CubeUVRefractionMapping=307;m.RepeatWrapping=1E3;m.ClampToEdgeWrapping=1001;m.MirroredRepeatWrapping=1002;m.NearestFilter=1003;m.NearestMipMapNearestFilter=1004;m.NearestMipMapLinearFilter=1005;m.LinearFilter=1006;m.LinearMipMapNearestFilter=1007;m.LinearMipMapLinearFilter=1008;m.UnsignedByteType=1009;m.ByteType=1010;m.ShortType=
1011;m.UnsignedShortType=1012;m.IntType=1013;m.UnsignedIntType=1014;m.FloatType=1015;m.HalfFloatType=1016;m.UnsignedShort4444Type=1017;m.UnsignedShort5551Type=1018;m.UnsignedShort565Type=1019;m.UnsignedInt248Type=1020;m.AlphaFormat=1021;m.RGBFormat=1022;m.RGBAFormat=1023;m.LuminanceFormat=1024;m.LuminanceAlphaFormat=1025;m.RGBEFormat=1023;m.DepthFormat=1026;m.DepthStencilFormat=1027;m.RGB_S3TC_DXT1_Format=2001;m.RGBA_S3TC_DXT1_Format=2002;m.RGBA_S3TC_DXT3_Format=2003;m.RGBA_S3TC_DXT5_Format=2004;
m.RGB_PVRTC_4BPPV1_Format=2100;m.RGB_PVRTC_2BPPV1_Format=2101;m.RGBA_PVRTC_4BPPV1_Format=2102;m.RGBA_PVRTC_2BPPV1_Format=2103;m.RGB_ETC1_Format=2151;m.LoopOnce=2200;m.LoopRepeat=2201;m.LoopPingPong=2202;m.InterpolateDiscrete=2300;m.InterpolateLinear=2301;m.InterpolateSmooth=2302;m.ZeroCurvatureEnding=2400;m.ZeroSlopeEnding=2401;m.WrapAroundEnding=2402;m.TrianglesDrawMode=0;m.TriangleStripDrawMode=1;m.TriangleFanDrawMode=2;m.LinearEncoding=3E3;m.sRGBEncoding=3001;m.GammaEncoding=3007;m.RGBEEncoding=
3002;m.LogLuvEncoding=3003;m.RGBM7Encoding=3004;m.RGBM16Encoding=3005;m.RGBDEncoding=3006;m.BasicDepthPacking=3200;m.RGBADepthPacking=3201;m.CubeGeometry=Lb;m.Face4=function(a,b,c,d,e,f,g){console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");return new Pa(a,b,c,e,f,g)};m.LineStrip=0;m.LinePieces=1;m.MeshFaceMaterial=function(a){console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");return a};m.MultiMaterial=function(a){void 0===a&&(a=[]);console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
a.isMultiMaterial=!0;a.materials=a;a.clone=function(){return a.slice()};return a};m.PointCloud=function(a,b){console.warn("THREE.PointCloud has been renamed to THREE.Points.");return new Qb(a,b)};m.Particle=function(a){console.warn("THREE.Particle has been renamed to THREE.Sprite.");return new Cc(a)};m.ParticleSystem=function(a,b){console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");return new Qb(a,b)};m.PointCloudMaterial=function(a){console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
return new Ba(a)};m.ParticleBasicMaterial=function(a){console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");return new Ba(a)};m.ParticleSystemMaterial=function(a){console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");return new Ba(a)};m.Vertex=function(a,b,c){console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");return new p(a,b,c)};m.DynamicBufferAttribute=function(a,b){console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");
return(new P(a,b)).setDynamic(!0)};m.Int8Attribute=function(a,b){console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");return new uc(a,b)};m.Uint8Attribute=function(a,b){console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");return new vc(a,b)};m.Uint8ClampedAttribute=function(a,b){console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");return new wc(a,
b)};m.Int16Attribute=function(a,b){console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");return new xc(a,b)};m.Uint16Attribute=function(a,b){console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");return new hb(a,b)};m.Int32Attribute=function(a,b){console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");return new yc(a,b)};m.Uint32Attribute=function(a,b){console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
return new ib(a,b)};m.Float32Attribute=function(a,b){console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");return new y(a,b)};m.Float64Attribute=function(a,b){console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");return new zc(a,b)};m.ClosedSplineCurve3=ef;m.SplineCurve3=ff;m.Spline=re;m.AxisHelper=function(a){console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");return new hd(a)};
m.BoundingBoxHelper=function(a,b){console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");return new Db(a,b)};m.EdgesHelper=function(a,b){console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");return new ca(new ec(a.geometry),new O({color:void 0!==b?b:16777215}))};m.WireframeHelper=function(a,b){console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");return new ca(new Sb(a.geometry),new O({color:void 0!==
b?b:16777215}))};m.XHRLoader=function(a){console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");return new Ja(a)};m.BinaryTextureLoader=function(a){console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");return new Zd(a)};m.GeometryUtils={merge:function(a,b,c){console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");if(b.isMesh){b.matrixAutoUpdate&&b.updateMatrix();
var d=b.matrix;b=b.geometry}a.merge(b,d,c)},center:function(a){console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");return a.center()}};m.ImageUtils={crossOrigin:void 0,loadTexture:function(a,b,c,d){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");var e=new td;e.setCrossOrigin(this.crossOrigin);a=e.load(a,c,void 0,d);b&&(a.mapping=b);return a},loadTextureCube:function(a,b,c,d){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
var e=new $d;e.setCrossOrigin(this.crossOrigin);a=e.load(a,c,void 0,d);b&&(a.mapping=b);return a},loadCompressedTexture:function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},loadCompressedTextureCube:function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")}};m.Projector=function(){console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");this.projectVector=
function(a,b){console.warn("THREE.Projector: .projectVector() is now vector.project().");a.project(b)};this.unprojectVector=function(a,b){console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");a.unproject(b)};this.pickingRay=function(){console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")}};m.CanvasRenderer=function(){console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js");this.domElement=document.createElementNS("http://www.w3.org/1999/xhtml",
"canvas");this.clear=function(){};this.render=function(){};this.setClearColor=function(){};this.setSize=function(){}};Object.defineProperty(m,"__esModule",{value:!0})});

},{}],242:[function(require,module,exports){
'use strict';

module.exports = TinyQueue;

function TinyQueue(data, compare) {
    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);

    this.data = data || [];
    this.length = this.data.length;
    this.compare = compare || defaultCompare;

    if (this.length > 0) {
        for (var i = (this.length >> 1); i >= 0; i--) this._down(i);
    }
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

TinyQueue.prototype = {

    push: function (item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
    },

    pop: function () {
        if (this.length === 0) return undefined;
        var top = this.data[0];
        this.length--;
        if (this.length > 0) {
            this.data[0] = this.data[this.length];
            this._down(0);
        }
        this.data.pop();
        return top;
    },

    peek: function () {
        return this.data[0];
    },

    _up: function (pos) {
        var data = this.data;
        var compare = this.compare;
        var item = data[pos];

        while (pos > 0) {
            var parent = (pos - 1) >> 1;
            var current = data[parent];
            if (compare(item, current) >= 0) break;
            data[pos] = current;
            pos = parent;
        }

        data[pos] = item;
    },

    _down: function (pos) {
        var data = this.data;
        var compare = this.compare;
        var len = this.length;
        var halfLen = len >> 1;
        var item = data[pos];

        while (pos < halfLen) {
            var left = (pos << 1) + 1;
            var right = left + 1;
            var best = data[left];

            if (right < len && compare(data[right], best) < 0) {
                left = right;
                best = data[right];
            }
            if (compare(best, item) >= 0) break;

            data[pos] = best;
            pos = left;
        }

        data[pos] = item;
    }
};

},{}],243:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],244:[function(require,module,exports){
var createElement = require("./vdom/create-element.js")

module.exports = createElement

},{"./vdom/create-element.js":250}],245:[function(require,module,exports){
var diff = require("./vtree/diff.js")

module.exports = diff

},{"./vtree/diff.js":270}],246:[function(require,module,exports){
var h = require("./virtual-hyperscript/index.js")

module.exports = h

},{"./virtual-hyperscript/index.js":257}],247:[function(require,module,exports){
var diff = require("./diff.js")
var patch = require("./patch.js")
var h = require("./h.js")
var create = require("./create-element.js")
var VNode = require('./vnode/vnode.js')
var VText = require('./vnode/vtext.js')

module.exports = {
    diff: diff,
    patch: patch,
    h: h,
    create: create,
    VNode: VNode,
    VText: VText
}

},{"./create-element.js":244,"./diff.js":245,"./h.js":246,"./patch.js":248,"./vnode/vnode.js":266,"./vnode/vtext.js":268}],248:[function(require,module,exports){
var patch = require("./vdom/patch.js")

module.exports = patch

},{"./vdom/patch.js":253}],249:[function(require,module,exports){
var isObject = require("is-object")
var isHook = require("../vnode/is-vhook.js")

module.exports = applyProperties

function applyProperties(node, props, previous) {
    for (var propName in props) {
        var propValue = props[propName]

        if (propValue === undefined) {
            removeProperty(node, propName, propValue, previous);
        } else if (isHook(propValue)) {
            removeProperty(node, propName, propValue, previous)
            if (propValue.hook) {
                propValue.hook(node,
                    propName,
                    previous ? previous[propName] : undefined)
            }
        } else {
            if (isObject(propValue)) {
                patchObject(node, props, previous, propName, propValue);
            } else {
                node[propName] = propValue
            }
        }
    }
}

function removeProperty(node, propName, propValue, previous) {
    if (previous) {
        var previousValue = previous[propName]

        if (!isHook(previousValue)) {
            if (propName === "attributes") {
                for (var attrName in previousValue) {
                    node.removeAttribute(attrName)
                }
            } else if (propName === "style") {
                for (var i in previousValue) {
                    node.style[i] = ""
                }
            } else if (typeof previousValue === "string") {
                node[propName] = ""
            } else {
                node[propName] = null
            }
        } else if (previousValue.unhook) {
            previousValue.unhook(node, propName, propValue)
        }
    }
}

function patchObject(node, props, previous, propName, propValue) {
    var previousValue = previous ? previous[propName] : undefined

    // Set attributes
    if (propName === "attributes") {
        for (var attrName in propValue) {
            var attrValue = propValue[attrName]

            if (attrValue === undefined) {
                node.removeAttribute(attrName)
            } else {
                node.setAttribute(attrName, attrValue)
            }
        }

        return
    }

    if(previousValue && isObject(previousValue) &&
        getPrototype(previousValue) !== getPrototype(propValue)) {
        node[propName] = propValue
        return
    }

    if (!isObject(node[propName])) {
        node[propName] = {}
    }

    var replacer = propName === "style" ? "" : undefined

    for (var k in propValue) {
        var value = propValue[k]
        node[propName][k] = (value === undefined) ? replacer : value
    }
}

function getPrototype(value) {
    if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(value)
    } else if (value.__proto__) {
        return value.__proto__
    } else if (value.constructor) {
        return value.constructor.prototype
    }
}

},{"../vnode/is-vhook.js":261,"is-object":20}],250:[function(require,module,exports){
var document = require("global/document")

var applyProperties = require("./apply-properties")

var isVNode = require("../vnode/is-vnode.js")
var isVText = require("../vnode/is-vtext.js")
var isWidget = require("../vnode/is-widget.js")
var handleThunk = require("../vnode/handle-thunk.js")

module.exports = createElement

function createElement(vnode, opts) {
    var doc = opts ? opts.document || document : document
    var warn = opts ? opts.warn : null

    vnode = handleThunk(vnode).a

    if (isWidget(vnode)) {
        return vnode.init()
    } else if (isVText(vnode)) {
        return doc.createTextNode(vnode.text)
    } else if (!isVNode(vnode)) {
        if (warn) {
            warn("Item is not a valid virtual dom node", vnode)
        }
        return null
    }

    var node = (vnode.namespace === null) ?
        doc.createElement(vnode.tagName) :
        doc.createElementNS(vnode.namespace, vnode.tagName)

    var props = vnode.properties
    applyProperties(node, props)

    var children = vnode.children

    for (var i = 0; i < children.length; i++) {
        var childNode = createElement(children[i], opts)
        if (childNode) {
            node.appendChild(childNode)
        }
    }

    return node
}

},{"../vnode/handle-thunk.js":259,"../vnode/is-vnode.js":262,"../vnode/is-vtext.js":263,"../vnode/is-widget.js":264,"./apply-properties":249,"global/document":16}],251:[function(require,module,exports){
// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.
// We don't want to read all of the DOM nodes in the tree so we use
// the in-order tree indexing to eliminate recursion down certain branches.
// We only recurse into a DOM node if we know that it contains a child of
// interest.

var noChild = {}

module.exports = domIndex

function domIndex(rootNode, tree, indices, nodes) {
    if (!indices || indices.length === 0) {
        return {}
    } else {
        indices.sort(ascending)
        return recurse(rootNode, tree, indices, nodes, 0)
    }
}

function recurse(rootNode, tree, indices, nodes, rootIndex) {
    nodes = nodes || {}


    if (rootNode) {
        if (indexInRange(indices, rootIndex, rootIndex)) {
            nodes[rootIndex] = rootNode
        }

        var vChildren = tree.children

        if (vChildren) {

            var childNodes = rootNode.childNodes

            for (var i = 0; i < tree.children.length; i++) {
                rootIndex += 1

                var vChild = vChildren[i] || noChild
                var nextIndex = rootIndex + (vChild.count || 0)

                // skip recursion down the tree if there are no nodes down here
                if (indexInRange(indices, rootIndex, nextIndex)) {
                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)
                }

                rootIndex = nextIndex
            }
        }
    }

    return nodes
}

// Binary search for an index in the interval [left, right]
function indexInRange(indices, left, right) {
    if (indices.length === 0) {
        return false
    }

    var minIndex = 0
    var maxIndex = indices.length - 1
    var currentIndex
    var currentItem

    while (minIndex <= maxIndex) {
        currentIndex = ((maxIndex + minIndex) / 2) >> 0
        currentItem = indices[currentIndex]

        if (minIndex === maxIndex) {
            return currentItem >= left && currentItem <= right
        } else if (currentItem < left) {
            minIndex = currentIndex + 1
        } else  if (currentItem > right) {
            maxIndex = currentIndex - 1
        } else {
            return true
        }
    }

    return false;
}

function ascending(a, b) {
    return a > b ? 1 : -1
}

},{}],252:[function(require,module,exports){
var applyProperties = require("./apply-properties")

var isWidget = require("../vnode/is-widget.js")
var VPatch = require("../vnode/vpatch.js")

var updateWidget = require("./update-widget")

module.exports = applyPatch

function applyPatch(vpatch, domNode, renderOptions) {
    var type = vpatch.type
    var vNode = vpatch.vNode
    var patch = vpatch.patch

    switch (type) {
        case VPatch.REMOVE:
            return removeNode(domNode, vNode)
        case VPatch.INSERT:
            return insertNode(domNode, patch, renderOptions)
        case VPatch.VTEXT:
            return stringPatch(domNode, vNode, patch, renderOptions)
        case VPatch.WIDGET:
            return widgetPatch(domNode, vNode, patch, renderOptions)
        case VPatch.VNODE:
            return vNodePatch(domNode, vNode, patch, renderOptions)
        case VPatch.ORDER:
            reorderChildren(domNode, patch)
            return domNode
        case VPatch.PROPS:
            applyProperties(domNode, patch, vNode.properties)
            return domNode
        case VPatch.THUNK:
            return replaceRoot(domNode,
                renderOptions.patch(domNode, patch, renderOptions))
        default:
            return domNode
    }
}

function removeNode(domNode, vNode) {
    var parentNode = domNode.parentNode

    if (parentNode) {
        parentNode.removeChild(domNode)
    }

    destroyWidget(domNode, vNode);

    return null
}

function insertNode(parentNode, vNode, renderOptions) {
    var newNode = renderOptions.render(vNode, renderOptions)

    if (parentNode) {
        parentNode.appendChild(newNode)
    }

    return parentNode
}

function stringPatch(domNode, leftVNode, vText, renderOptions) {
    var newNode

    if (domNode.nodeType === 3) {
        domNode.replaceData(0, domNode.length, vText.text)
        newNode = domNode
    } else {
        var parentNode = domNode.parentNode
        newNode = renderOptions.render(vText, renderOptions)

        if (parentNode && newNode !== domNode) {
            parentNode.replaceChild(newNode, domNode)
        }
    }

    return newNode
}

function widgetPatch(domNode, leftVNode, widget, renderOptions) {
    var updating = updateWidget(leftVNode, widget)
    var newNode

    if (updating) {
        newNode = widget.update(leftVNode, domNode) || domNode
    } else {
        newNode = renderOptions.render(widget, renderOptions)
    }

    var parentNode = domNode.parentNode

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode)
    }

    if (!updating) {
        destroyWidget(domNode, leftVNode)
    }

    return newNode
}

function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
    var parentNode = domNode.parentNode
    var newNode = renderOptions.render(vNode, renderOptions)

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode)
    }

    return newNode
}

function destroyWidget(domNode, w) {
    if (typeof w.destroy === "function" && isWidget(w)) {
        w.destroy(domNode)
    }
}

function reorderChildren(domNode, moves) {
    var childNodes = domNode.childNodes
    var keyMap = {}
    var node
    var remove
    var insert

    for (var i = 0; i < moves.removes.length; i++) {
        remove = moves.removes[i]
        node = childNodes[remove.from]
        if (remove.key) {
            keyMap[remove.key] = node
        }
        domNode.removeChild(node)
    }

    var length = childNodes.length
    for (var j = 0; j < moves.inserts.length; j++) {
        insert = moves.inserts[j]
        node = keyMap[insert.key]
        // this is the weirdest bug i've ever seen in webkit
        domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to])
    }
}

function replaceRoot(oldRoot, newRoot) {
    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
        oldRoot.parentNode.replaceChild(newRoot, oldRoot)
    }

    return newRoot;
}

},{"../vnode/is-widget.js":264,"../vnode/vpatch.js":267,"./apply-properties":249,"./update-widget":254}],253:[function(require,module,exports){
var document = require("global/document")
var isArray = require("x-is-array")

var render = require("./create-element")
var domIndex = require("./dom-index")
var patchOp = require("./patch-op")
module.exports = patch

function patch(rootNode, patches, renderOptions) {
    renderOptions = renderOptions || {}
    renderOptions.patch = renderOptions.patch && renderOptions.patch !== patch
        ? renderOptions.patch
        : patchRecursive
    renderOptions.render = renderOptions.render || render

    return renderOptions.patch(rootNode, patches, renderOptions)
}

function patchRecursive(rootNode, patches, renderOptions) {
    var indices = patchIndices(patches)

    if (indices.length === 0) {
        return rootNode
    }

    var index = domIndex(rootNode, patches.a, indices)
    var ownerDocument = rootNode.ownerDocument

    if (!renderOptions.document && ownerDocument !== document) {
        renderOptions.document = ownerDocument
    }

    for (var i = 0; i < indices.length; i++) {
        var nodeIndex = indices[i]
        rootNode = applyPatch(rootNode,
            index[nodeIndex],
            patches[nodeIndex],
            renderOptions)
    }

    return rootNode
}

function applyPatch(rootNode, domNode, patchList, renderOptions) {
    if (!domNode) {
        return rootNode
    }

    var newNode

    if (isArray(patchList)) {
        for (var i = 0; i < patchList.length; i++) {
            newNode = patchOp(patchList[i], domNode, renderOptions)

            if (domNode === rootNode) {
                rootNode = newNode
            }
        }
    } else {
        newNode = patchOp(patchList, domNode, renderOptions)

        if (domNode === rootNode) {
            rootNode = newNode
        }
    }

    return rootNode
}

function patchIndices(patches) {
    var indices = []

    for (var key in patches) {
        if (key !== "a") {
            indices.push(Number(key))
        }
    }

    return indices
}

},{"./create-element":250,"./dom-index":251,"./patch-op":252,"global/document":16,"x-is-array":289}],254:[function(require,module,exports){
var isWidget = require("../vnode/is-widget.js")

module.exports = updateWidget

function updateWidget(a, b) {
    if (isWidget(a) && isWidget(b)) {
        if ("name" in a && "name" in b) {
            return a.id === b.id
        } else {
            return a.init === b.init
        }
    }

    return false
}

},{"../vnode/is-widget.js":264}],255:[function(require,module,exports){
'use strict';

var EvStore = require('ev-store');

module.exports = EvHook;

function EvHook(value) {
    if (!(this instanceof EvHook)) {
        return new EvHook(value);
    }

    this.value = value;
}

EvHook.prototype.hook = function (node, propertyName) {
    var es = EvStore(node);
    var propName = propertyName.substr(3);

    es[propName] = this.value;
};

EvHook.prototype.unhook = function(node, propertyName) {
    var es = EvStore(node);
    var propName = propertyName.substr(3);

    es[propName] = undefined;
};

},{"ev-store":9}],256:[function(require,module,exports){
'use strict';

module.exports = SoftSetHook;

function SoftSetHook(value) {
    if (!(this instanceof SoftSetHook)) {
        return new SoftSetHook(value);
    }

    this.value = value;
}

SoftSetHook.prototype.hook = function (node, propertyName) {
    if (node[propertyName] !== this.value) {
        node[propertyName] = this.value;
    }
};

},{}],257:[function(require,module,exports){
'use strict';

var isArray = require('x-is-array');

var VNode = require('../vnode/vnode.js');
var VText = require('../vnode/vtext.js');
var isVNode = require('../vnode/is-vnode');
var isVText = require('../vnode/is-vtext');
var isWidget = require('../vnode/is-widget');
var isHook = require('../vnode/is-vhook');
var isVThunk = require('../vnode/is-thunk');

var parseTag = require('./parse-tag.js');
var softSetHook = require('./hooks/soft-set-hook.js');
var evHook = require('./hooks/ev-hook.js');

module.exports = h;

function h(tagName, properties, children) {
    var childNodes = [];
    var tag, props, key, namespace;

    if (!children && isChildren(properties)) {
        children = properties;
        props = {};
    }

    props = props || properties || {};
    tag = parseTag(tagName, props);

    // support keys
    if (props.hasOwnProperty('key')) {
        key = props.key;
        props.key = undefined;
    }

    // support namespace
    if (props.hasOwnProperty('namespace')) {
        namespace = props.namespace;
        props.namespace = undefined;
    }

    // fix cursor bug
    if (tag === 'INPUT' &&
        !namespace &&
        props.hasOwnProperty('value') &&
        props.value !== undefined &&
        !isHook(props.value)
    ) {
        props.value = softSetHook(props.value);
    }

    transformProperties(props);

    if (children !== undefined && children !== null) {
        addChild(children, childNodes, tag, props);
    }


    return new VNode(tag, props, childNodes, key, namespace);
}

function addChild(c, childNodes, tag, props) {
    if (typeof c === 'string') {
        childNodes.push(new VText(c));
    } else if (typeof c === 'number') {
        childNodes.push(new VText(String(c)));
    } else if (isChild(c)) {
        childNodes.push(c);
    } else if (isArray(c)) {
        for (var i = 0; i < c.length; i++) {
            addChild(c[i], childNodes, tag, props);
        }
    } else if (c === null || c === undefined) {
        return;
    } else {
        throw UnexpectedVirtualElement({
            foreignObject: c,
            parentVnode: {
                tagName: tag,
                properties: props
            }
        });
    }
}

function transformProperties(props) {
    for (var propName in props) {
        if (props.hasOwnProperty(propName)) {
            var value = props[propName];

            if (isHook(value)) {
                continue;
            }

            if (propName.substr(0, 3) === 'ev-') {
                // add ev-foo support
                props[propName] = evHook(value);
            }
        }
    }
}

function isChild(x) {
    return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x);
}

function isChildren(x) {
    return typeof x === 'string' || isArray(x) || isChild(x);
}

function UnexpectedVirtualElement(data) {
    var err = new Error();

    err.type = 'virtual-hyperscript.unexpected.virtual-element';
    err.message = 'Unexpected virtual child passed to h().\n' +
        'Expected a VNode / Vthunk / VWidget / string but:\n' +
        'got:\n' +
        errorString(data.foreignObject) +
        '.\n' +
        'The parent vnode is:\n' +
        errorString(data.parentVnode)
        '\n' +
        'Suggested fix: change your `h(..., [ ... ])` callsite.';
    err.foreignObject = data.foreignObject;
    err.parentVnode = data.parentVnode;

    return err;
}

function errorString(obj) {
    try {
        return JSON.stringify(obj, null, '    ');
    } catch (e) {
        return String(obj);
    }
}

},{"../vnode/is-thunk":260,"../vnode/is-vhook":261,"../vnode/is-vnode":262,"../vnode/is-vtext":263,"../vnode/is-widget":264,"../vnode/vnode.js":266,"../vnode/vtext.js":268,"./hooks/ev-hook.js":255,"./hooks/soft-set-hook.js":256,"./parse-tag.js":258,"x-is-array":289}],258:[function(require,module,exports){
'use strict';

var split = require('browser-split');

var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
var notClassId = /^\.|#/;

module.exports = parseTag;

function parseTag(tag, props) {
    if (!tag) {
        return 'DIV';
    }

    var noId = !(props.hasOwnProperty('id'));

    var tagParts = split(tag, classIdSplit);
    var tagName = null;

    if (notClassId.test(tagParts[1])) {
        tagName = 'DIV';
    }

    var classes, part, type, i;

    for (i = 0; i < tagParts.length; i++) {
        part = tagParts[i];

        if (!part) {
            continue;
        }

        type = part.charAt(0);

        if (!tagName) {
            tagName = part;
        } else if (type === '.') {
            classes = classes || [];
            classes.push(part.substring(1, part.length));
        } else if (type === '#' && noId) {
            props.id = part.substring(1, part.length);
        }
    }

    if (classes) {
        if (props.className) {
            classes.push(props.className);
        }

        props.className = classes.join(' ');
    }

    return props.namespace ? tagName : tagName.toUpperCase();
}

},{"browser-split":5}],259:[function(require,module,exports){
var isVNode = require("./is-vnode")
var isVText = require("./is-vtext")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")

module.exports = handleThunk

function handleThunk(a, b) {
    var renderedA = a
    var renderedB = b

    if (isThunk(b)) {
        renderedB = renderThunk(b, a)
    }

    if (isThunk(a)) {
        renderedA = renderThunk(a, null)
    }

    return {
        a: renderedA,
        b: renderedB
    }
}

function renderThunk(thunk, previous) {
    var renderedThunk = thunk.vnode

    if (!renderedThunk) {
        renderedThunk = thunk.vnode = thunk.render(previous)
    }

    if (!(isVNode(renderedThunk) ||
            isVText(renderedThunk) ||
            isWidget(renderedThunk))) {
        throw new Error("thunk did not return a valid node");
    }

    return renderedThunk
}

},{"./is-thunk":260,"./is-vnode":262,"./is-vtext":263,"./is-widget":264}],260:[function(require,module,exports){
module.exports = isThunk

function isThunk(t) {
    return t && t.type === "Thunk"
}

},{}],261:[function(require,module,exports){
module.exports = isHook

function isHook(hook) {
    return hook &&
      (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") ||
       typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"))
}

},{}],262:[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualNode

function isVirtualNode(x) {
    return x && x.type === "VirtualNode" && x.version === version
}

},{"./version":265}],263:[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualText

function isVirtualText(x) {
    return x && x.type === "VirtualText" && x.version === version
}

},{"./version":265}],264:[function(require,module,exports){
module.exports = isWidget

function isWidget(w) {
    return w && w.type === "Widget"
}

},{}],265:[function(require,module,exports){
module.exports = "2"

},{}],266:[function(require,module,exports){
var version = require("./version")
var isVNode = require("./is-vnode")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")
var isVHook = require("./is-vhook")

module.exports = VirtualNode

var noProperties = {}
var noChildren = []

function VirtualNode(tagName, properties, children, key, namespace) {
    this.tagName = tagName
    this.properties = properties || noProperties
    this.children = children || noChildren
    this.key = key != null ? String(key) : undefined
    this.namespace = (typeof namespace === "string") ? namespace : null

    var count = (children && children.length) || 0
    var descendants = 0
    var hasWidgets = false
    var hasThunks = false
    var descendantHooks = false
    var hooks

    for (var propName in properties) {
        if (properties.hasOwnProperty(propName)) {
            var property = properties[propName]
            if (isVHook(property) && property.unhook) {
                if (!hooks) {
                    hooks = {}
                }

                hooks[propName] = property
            }
        }
    }

    for (var i = 0; i < count; i++) {
        var child = children[i]
        if (isVNode(child)) {
            descendants += child.count || 0

            if (!hasWidgets && child.hasWidgets) {
                hasWidgets = true
            }

            if (!hasThunks && child.hasThunks) {
                hasThunks = true
            }

            if (!descendantHooks && (child.hooks || child.descendantHooks)) {
                descendantHooks = true
            }
        } else if (!hasWidgets && isWidget(child)) {
            if (typeof child.destroy === "function") {
                hasWidgets = true
            }
        } else if (!hasThunks && isThunk(child)) {
            hasThunks = true;
        }
    }

    this.count = count + descendants
    this.hasWidgets = hasWidgets
    this.hasThunks = hasThunks
    this.hooks = hooks
    this.descendantHooks = descendantHooks
}

VirtualNode.prototype.version = version
VirtualNode.prototype.type = "VirtualNode"

},{"./is-thunk":260,"./is-vhook":261,"./is-vnode":262,"./is-widget":264,"./version":265}],267:[function(require,module,exports){
var version = require("./version")

VirtualPatch.NONE = 0
VirtualPatch.VTEXT = 1
VirtualPatch.VNODE = 2
VirtualPatch.WIDGET = 3
VirtualPatch.PROPS = 4
VirtualPatch.ORDER = 5
VirtualPatch.INSERT = 6
VirtualPatch.REMOVE = 7
VirtualPatch.THUNK = 8

module.exports = VirtualPatch

function VirtualPatch(type, vNode, patch) {
    this.type = Number(type)
    this.vNode = vNode
    this.patch = patch
}

VirtualPatch.prototype.version = version
VirtualPatch.prototype.type = "VirtualPatch"

},{"./version":265}],268:[function(require,module,exports){
var version = require("./version")

module.exports = VirtualText

function VirtualText(text) {
    this.text = String(text)
}

VirtualText.prototype.version = version
VirtualText.prototype.type = "VirtualText"

},{"./version":265}],269:[function(require,module,exports){
var isObject = require("is-object")
var isHook = require("../vnode/is-vhook")

module.exports = diffProps

function diffProps(a, b) {
    var diff

    for (var aKey in a) {
        if (!(aKey in b)) {
            diff = diff || {}
            diff[aKey] = undefined
        }

        var aValue = a[aKey]
        var bValue = b[aKey]

        if (aValue === bValue) {
            continue
        } else if (isObject(aValue) && isObject(bValue)) {
            if (getPrototype(bValue) !== getPrototype(aValue)) {
                diff = diff || {}
                diff[aKey] = bValue
            } else if (isHook(bValue)) {
                 diff = diff || {}
                 diff[aKey] = bValue
            } else {
                var objectDiff = diffProps(aValue, bValue)
                if (objectDiff) {
                    diff = diff || {}
                    diff[aKey] = objectDiff
                }
            }
        } else {
            diff = diff || {}
            diff[aKey] = bValue
        }
    }

    for (var bKey in b) {
        if (!(bKey in a)) {
            diff = diff || {}
            diff[bKey] = b[bKey]
        }
    }

    return diff
}

function getPrototype(value) {
  if (Object.getPrototypeOf) {
    return Object.getPrototypeOf(value)
  } else if (value.__proto__) {
    return value.__proto__
  } else if (value.constructor) {
    return value.constructor.prototype
  }
}

},{"../vnode/is-vhook":261,"is-object":20}],270:[function(require,module,exports){
var isArray = require("x-is-array")

var VPatch = require("../vnode/vpatch")
var isVNode = require("../vnode/is-vnode")
var isVText = require("../vnode/is-vtext")
var isWidget = require("../vnode/is-widget")
var isThunk = require("../vnode/is-thunk")
var handleThunk = require("../vnode/handle-thunk")

var diffProps = require("./diff-props")

module.exports = diff

function diff(a, b) {
    var patch = { a: a }
    walk(a, b, patch, 0)
    return patch
}

function walk(a, b, patch, index) {
    if (a === b) {
        return
    }

    var apply = patch[index]
    var applyClear = false

    if (isThunk(a) || isThunk(b)) {
        thunks(a, b, patch, index)
    } else if (b == null) {

        // If a is a widget we will add a remove patch for it
        // Otherwise any child widgets/hooks must be destroyed.
        // This prevents adding two remove patches for a widget.
        if (!isWidget(a)) {
            clearState(a, patch, index)
            apply = patch[index]
        }

        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))
    } else if (isVNode(b)) {
        if (isVNode(a)) {
            if (a.tagName === b.tagName &&
                a.namespace === b.namespace &&
                a.key === b.key) {
                var propsPatch = diffProps(a.properties, b.properties)
                if (propsPatch) {
                    apply = appendPatch(apply,
                        new VPatch(VPatch.PROPS, a, propsPatch))
                }
                apply = diffChildren(a, b, patch, apply, index)
            } else {
                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
                applyClear = true
            }
        } else {
            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
            applyClear = true
        }
    } else if (isVText(b)) {
        if (!isVText(a)) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
            applyClear = true
        } else if (a.text !== b.text) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
        }
    } else if (isWidget(b)) {
        if (!isWidget(a)) {
            applyClear = true
        }

        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))
    }

    if (apply) {
        patch[index] = apply
    }

    if (applyClear) {
        clearState(a, patch, index)
    }
}

function diffChildren(a, b, patch, apply, index) {
    var aChildren = a.children
    var orderedSet = reorder(aChildren, b.children)
    var bChildren = orderedSet.children

    var aLen = aChildren.length
    var bLen = bChildren.length
    var len = aLen > bLen ? aLen : bLen

    for (var i = 0; i < len; i++) {
        var leftNode = aChildren[i]
        var rightNode = bChildren[i]
        index += 1

        if (!leftNode) {
            if (rightNode) {
                // Excess nodes in b need to be added
                apply = appendPatch(apply,
                    new VPatch(VPatch.INSERT, null, rightNode))
            }
        } else {
            walk(leftNode, rightNode, patch, index)
        }

        if (isVNode(leftNode) && leftNode.count) {
            index += leftNode.count
        }
    }

    if (orderedSet.moves) {
        // Reorder nodes last
        apply = appendPatch(apply, new VPatch(
            VPatch.ORDER,
            a,
            orderedSet.moves
        ))
    }

    return apply
}

function clearState(vNode, patch, index) {
    // TODO: Make this a single walk, not two
    unhook(vNode, patch, index)
    destroyWidgets(vNode, patch, index)
}

// Patch records for all destroyed widgets must be added because we need
// a DOM node reference for the destroy function
function destroyWidgets(vNode, patch, index) {
    if (isWidget(vNode)) {
        if (typeof vNode.destroy === "function") {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(VPatch.REMOVE, vNode, null)
            )
        }
    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {
        var children = vNode.children
        var len = children.length
        for (var i = 0; i < len; i++) {
            var child = children[i]
            index += 1

            destroyWidgets(child, patch, index)

            if (isVNode(child) && child.count) {
                index += child.count
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index)
    }
}

// Create a sub-patch for thunks
function thunks(a, b, patch, index) {
    var nodes = handleThunk(a, b)
    var thunkPatch = diff(nodes.a, nodes.b)
    if (hasPatches(thunkPatch)) {
        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)
    }
}

function hasPatches(patch) {
    for (var index in patch) {
        if (index !== "a") {
            return true
        }
    }

    return false
}

// Execute hooks when two nodes are identical
function unhook(vNode, patch, index) {
    if (isVNode(vNode)) {
        if (vNode.hooks) {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(
                    VPatch.PROPS,
                    vNode,
                    undefinedKeys(vNode.hooks)
                )
            )
        }

        if (vNode.descendantHooks || vNode.hasThunks) {
            var children = vNode.children
            var len = children.length
            for (var i = 0; i < len; i++) {
                var child = children[i]
                index += 1

                unhook(child, patch, index)

                if (isVNode(child) && child.count) {
                    index += child.count
                }
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index)
    }
}

function undefinedKeys(obj) {
    var result = {}

    for (var key in obj) {
        result[key] = undefined
    }

    return result
}

// List diff, naive left to right reordering
function reorder(aChildren, bChildren) {
    // O(M) time, O(M) memory
    var bChildIndex = keyIndex(bChildren)
    var bKeys = bChildIndex.keys
    var bFree = bChildIndex.free

    if (bFree.length === bChildren.length) {
        return {
            children: bChildren,
            moves: null
        }
    }

    // O(N) time, O(N) memory
    var aChildIndex = keyIndex(aChildren)
    var aKeys = aChildIndex.keys
    var aFree = aChildIndex.free

    if (aFree.length === aChildren.length) {
        return {
            children: bChildren,
            moves: null
        }
    }

    // O(MAX(N, M)) memory
    var newChildren = []

    var freeIndex = 0
    var freeCount = bFree.length
    var deletedItems = 0

    // Iterate through a and match a node in b
    // O(N) time,
    for (var i = 0 ; i < aChildren.length; i++) {
        var aItem = aChildren[i]
        var itemIndex

        if (aItem.key) {
            if (bKeys.hasOwnProperty(aItem.key)) {
                // Match up the old keys
                itemIndex = bKeys[aItem.key]
                newChildren.push(bChildren[itemIndex])

            } else {
                // Remove old keyed items
                itemIndex = i - deletedItems++
                newChildren.push(null)
            }
        } else {
            // Match the item in a with the next free item in b
            if (freeIndex < freeCount) {
                itemIndex = bFree[freeIndex++]
                newChildren.push(bChildren[itemIndex])
            } else {
                // There are no free items in b to match with
                // the free items in a, so the extra free nodes
                // are deleted.
                itemIndex = i - deletedItems++
                newChildren.push(null)
            }
        }
    }

    var lastFreeIndex = freeIndex >= bFree.length ?
        bChildren.length :
        bFree[freeIndex]

    // Iterate through b and append any new keys
    // O(M) time
    for (var j = 0; j < bChildren.length; j++) {
        var newItem = bChildren[j]

        if (newItem.key) {
            if (!aKeys.hasOwnProperty(newItem.key)) {
                // Add any new keyed items
                // We are adding new items to the end and then sorting them
                // in place. In future we should insert new items in place.
                newChildren.push(newItem)
            }
        } else if (j >= lastFreeIndex) {
            // Add any leftover non-keyed items
            newChildren.push(newItem)
        }
    }

    var simulate = newChildren.slice()
    var simulateIndex = 0
    var removes = []
    var inserts = []
    var simulateItem

    for (var k = 0; k < bChildren.length;) {
        var wantedItem = bChildren[k]
        simulateItem = simulate[simulateIndex]

        // remove items
        while (simulateItem === null && simulate.length) {
            removes.push(remove(simulate, simulateIndex, null))
            simulateItem = simulate[simulateIndex]
        }

        if (!simulateItem || simulateItem.key !== wantedItem.key) {
            // if we need a key in this position...
            if (wantedItem.key) {
                if (simulateItem && simulateItem.key) {
                    // if an insert doesn't put this key in place, it needs to move
                    if (bKeys[simulateItem.key] !== k + 1) {
                        removes.push(remove(simulate, simulateIndex, simulateItem.key))
                        simulateItem = simulate[simulateIndex]
                        // if the remove didn't put the wanted item in place, we need to insert it
                        if (!simulateItem || simulateItem.key !== wantedItem.key) {
                            inserts.push({key: wantedItem.key, to: k})
                        }
                        // items are matching, so skip ahead
                        else {
                            simulateIndex++
                        }
                    }
                    else {
                        inserts.push({key: wantedItem.key, to: k})
                    }
                }
                else {
                    inserts.push({key: wantedItem.key, to: k})
                }
                k++
            }
            // a key in simulate has no matching wanted key, remove it
            else if (simulateItem && simulateItem.key) {
                removes.push(remove(simulate, simulateIndex, simulateItem.key))
            }
        }
        else {
            simulateIndex++
            k++
        }
    }

    // remove all the remaining nodes from simulate
    while(simulateIndex < simulate.length) {
        simulateItem = simulate[simulateIndex]
        removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key))
    }

    // If the only moves we have are deletes then we can just
    // let the delete patch remove these items.
    if (removes.length === deletedItems && !inserts.length) {
        return {
            children: newChildren,
            moves: null
        }
    }

    return {
        children: newChildren,
        moves: {
            removes: removes,
            inserts: inserts
        }
    }
}

function remove(arr, index, key) {
    arr.splice(index, 1)

    return {
        from: index,
        key: key
    }
}

function keyIndex(children) {
    var keys = {}
    var free = []
    var length = children.length

    for (var i = 0; i < length; i++) {
        var child = children[i]

        if (child.key) {
            keys[child.key] = i
        } else {
            free.push(i)
        }
    }

    return {
        keys: keys,     // A hash of key name to index
        free: free      // An array of unkeyed item indices
    }
}

function appendPatch(apply, patch) {
    if (apply) {
        if (isArray(apply)) {
            apply.push(patch)
        } else {
            apply = [apply, patch]
        }

        return apply
    } else {
        return patch
    }
}

},{"../vnode/handle-thunk":259,"../vnode/is-thunk":260,"../vnode/is-vnode":262,"../vnode/is-vtext":263,"../vnode/is-widget":264,"../vnode/vpatch":267,"./diff-props":269,"x-is-array":289}],271:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function (require) {

	var makePromise = require('./makePromise');
	var Scheduler = require('./Scheduler');
	var async = require('./env').asap;

	return makePromise({
		scheduler: new Scheduler(async)
	});

});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./Scheduler":272,"./env":284,"./makePromise":286}],272:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	// Credit to Twisol (https://github.com/Twisol) for suggesting
	// this type of extensible queue + trampoline approach for next-tick conflation.

	/**
	 * Async task scheduler
	 * @param {function} async function to schedule a single async function
	 * @constructor
	 */
	function Scheduler(async) {
		this._async = async;
		this._running = false;

		this._queue = this;
		this._queueLen = 0;
		this._afterQueue = {};
		this._afterQueueLen = 0;

		var self = this;
		this.drain = function() {
			self._drain();
		};
	}

	/**
	 * Enqueue a task
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.enqueue = function(task) {
		this._queue[this._queueLen++] = task;
		this.run();
	};

	/**
	 * Enqueue a task to run after the main task queue
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.afterQueue = function(task) {
		this._afterQueue[this._afterQueueLen++] = task;
		this.run();
	};

	Scheduler.prototype.run = function() {
		if (!this._running) {
			this._running = true;
			this._async(this.drain);
		}
	};

	/**
	 * Drain the handler queue entirely, and then the after queue
	 */
	Scheduler.prototype._drain = function() {
		var i = 0;
		for (; i < this._queueLen; ++i) {
			this._queue[i].run();
			this._queue[i] = void 0;
		}

		this._queueLen = 0;
		this._running = false;

		for (i = 0; i < this._afterQueueLen; ++i) {
			this._afterQueue[i].run();
			this._afterQueue[i] = void 0;
		}

		this._afterQueueLen = 0;
	};

	return Scheduler;

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],273:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	/**
	 * Custom error type for promises rejected by promise.timeout
	 * @param {string} message
	 * @constructor
	 */
	function TimeoutError (message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === 'function') {
			Error.captureStackTrace(this, TimeoutError);
		}
	}

	TimeoutError.prototype = Object.create(Error.prototype);
	TimeoutError.prototype.constructor = TimeoutError;

	return TimeoutError;
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));
},{}],274:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	makeApply.tryCatchResolve = tryCatchResolve;

	return makeApply;

	function makeApply(Promise, call) {
		if(arguments.length < 2) {
			call = tryCatchResolve;
		}

		return apply;

		function apply(f, thisArg, args) {
			var p = Promise._defer();
			var l = args.length;
			var params = new Array(l);
			callAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);

			return p;
		}

		function callAndResolve(c, h) {
			if(c.i < 0) {
				return call(c.f, c.thisArg, c.params, h);
			}

			var handler = Promise._handler(c.args[c.i]);
			handler.fold(callAndResolveNext, c, void 0, h);
		}

		function callAndResolveNext(c, x, h) {
			c.params[c.i] = x;
			c.i -= 1;
			callAndResolve(c, h);
		}
	}

	function tryCatchResolve(f, thisArg, args, resolver) {
		try {
			resolver.resolve(f.apply(thisArg, args));
		} catch(e) {
			resolver.reject(e);
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));



},{}],275:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var state = require('../state');
	var applier = require('../apply');

	return function array(Promise) {

		var applyFold = applier(Promise);
		var toPromise = Promise.resolve;
		var all = Promise.all;

		var ar = Array.prototype.reduce;
		var arr = Array.prototype.reduceRight;
		var slice = Array.prototype.slice;

		// Additional array combinators

		Promise.any = any;
		Promise.some = some;
		Promise.settle = settle;

		Promise.map = map;
		Promise.filter = filter;
		Promise.reduce = reduce;
		Promise.reduceRight = reduceRight;

		/**
		 * When this promise fulfills with an array, do
		 * onFulfilled.apply(void 0, array)
		 * @param {function} onFulfilled function to apply
		 * @returns {Promise} promise for the result of applying onFulfilled
		 */
		Promise.prototype.spread = function(onFulfilled) {
			return this.then(all).then(function(array) {
				return onFulfilled.apply(this, array);
			});
		};

		return Promise;

		/**
		 * One-winner competitive race.
		 * Return a promise that will fulfill when one of the promises
		 * in the input array fulfills, or will reject when all promises
		 * have rejected.
		 * @param {array} promises
		 * @returns {Promise} promise for the first fulfilled value
		 */
		function any(promises) {
			var p = Promise._defer();
			var resolver = p._handler;
			var l = promises.length>>>0;

			var pending = l;
			var errors = [];

			for (var h, x, i = 0; i < l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				h = Promise._handler(x);
				if(h.state() > 0) {
					resolver.become(h);
					Promise._visitRemaining(promises, i, h);
					break;
				} else {
					h.visit(resolver, handleFulfill, handleReject);
				}
			}

			if(pending === 0) {
				resolver.reject(new RangeError('any(): array must not be empty'));
			}

			return p;

			function handleFulfill(x) {
				/*jshint validthis:true*/
				errors = null;
				this.resolve(x); // this === resolver
			}

			function handleReject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--pending === 0) {
					this.reject(errors);
				}
			}
		}

		/**
		 * N-winner competitive race
		 * Return a promise that will fulfill when n input promises have
		 * fulfilled, or will reject when it becomes impossible for n
		 * input promises to fulfill (ie when promises.length - n + 1
		 * have rejected)
		 * @param {array} promises
		 * @param {number} n
		 * @returns {Promise} promise for the earliest n fulfillment values
		 *
		 * @deprecated
		 */
		function some(promises, n) {
			/*jshint maxcomplexity:7*/
			var p = Promise._defer();
			var resolver = p._handler;

			var results = [];
			var errors = [];

			var l = promises.length>>>0;
			var nFulfill = 0;
			var nReject;
			var x, i; // reused in both for() loops

			// First pass: count actual array items
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}
				++nFulfill;
			}

			// Compute actual goals
			n = Math.max(n, 0);
			nReject = (nFulfill - n + 1);
			nFulfill = Math.min(n, nFulfill);

			if(n > nFulfill) {
				resolver.reject(new RangeError('some(): array must contain at least '
				+ n + ' item(s), but had ' + nFulfill));
			} else if(nFulfill === 0) {
				resolver.resolve(results);
			}

			// Second pass: observe each array item, make progress toward goals
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}

				Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);
			}

			return p;

			function fulfill(x) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				results.push(x);
				if(--nFulfill === 0) {
					errors = null;
					this.resolve(results);
				}
			}

			function reject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--nReject === 0) {
					results = null;
					this.reject(errors);
				}
			}
		}

		/**
		 * Apply f to the value of each promise in a list of promises
		 * and return a new list containing the results.
		 * @param {array} promises
		 * @param {function(x:*, index:Number):*} f mapping function
		 * @returns {Promise}
		 */
		function map(promises, f) {
			return Promise._traverse(f, promises);
		}

		/**
		 * Filter the provided array of promises using the provided predicate.  Input may
		 * contain promises and values
		 * @param {Array} promises array of promises and values
		 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
		 *  Must return truthy (or promise for truthy) for items to retain.
		 * @returns {Promise} promise that will fulfill with an array containing all items
		 *  for which predicate returned truthy.
		 */
		function filter(promises, predicate) {
			var a = slice.call(promises);
			return Promise._traverse(predicate, a).then(function(keep) {
				return filterSync(a, keep);
			});
		}

		function filterSync(promises, keep) {
			// Safe because we know all promises have fulfilled if we've made it this far
			var l = keep.length;
			var filtered = new Array(l);
			for(var i=0, j=0; i<l; ++i) {
				if(keep[i]) {
					filtered[j++] = Promise._handler(promises[i]).value;
				}
			}
			filtered.length = j;
			return filtered;

		}

		/**
		 * Return a promise that will always fulfill with an array containing
		 * the outcome states of all input promises.  The returned promise
		 * will never reject.
		 * @param {Array} promises
		 * @returns {Promise} promise for array of settled state descriptors
		 */
		function settle(promises) {
			return all(promises.map(settleOne));
		}

		function settleOne(p) {
			// Optimize the case where we get an already-resolved when.js promise
			//  by extracting its state:
			var handler;
			if (p instanceof Promise) {
				// This is our own Promise type and we can reach its handler internals:
				handler = p._handler.join();
			}
			if((handler && handler.state() === 0) || !handler) {
				// Either still pending, or not a Promise at all:
				return toPromise(p).then(state.fulfilled, state.rejected);
			}

			// The promise is our own, but it is already resolved. Take a shortcut.
			// Since we're not actually handling the resolution, we need to disable
			// rejection reporting.
			handler._unreport();
			return state.inspect(handler);
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduce(promises, f /*, initialValue */) {
			return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])
					: ar.call(promises, liftCombine(f));
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduceRight(promises, f /*, initialValue */) {
			return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])
					: arr.call(promises, liftCombine(f));
		}

		function liftCombine(f) {
			return function(z, x, i) {
				return applyFold(f, void 0, [z,x,i]);
			};
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../apply":274,"../state":287}],276:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function flow(Promise) {

		var resolve = Promise.resolve;
		var reject = Promise.reject;
		var origCatch = Promise.prototype['catch'];

		/**
		 * Handle the ultimate fulfillment value or rejection reason, and assume
		 * responsibility for all errors.  If an error propagates out of result
		 * or handleFatalError, it will be rethrown to the host, resulting in a
		 * loud stack track on most platforms and a crash on some.
		 * @param {function?} onResult
		 * @param {function?} onError
		 * @returns {undefined}
		 */
		Promise.prototype.done = function(onResult, onError) {
			this._handler.visit(this._handler.receiver, onResult, onError);
		};

		/**
		 * Add Error-type and predicate matching to catch.  Examples:
		 * promise.catch(TypeError, handleTypeError)
		 *   .catch(predicate, handleMatchedErrors)
		 *   .catch(handleRemainingErrors)
		 * @param onRejected
		 * @returns {*}
		 */
		Promise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {
			if (arguments.length < 2) {
				return origCatch.call(this, onRejected);
			}

			if(typeof onRejected !== 'function') {
				return this.ensure(rejectInvalidPredicate);
			}

			return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
		};

		/**
		 * Wraps the provided catch handler, so that it will only be called
		 * if the predicate evaluates truthy
		 * @param {?function} handler
		 * @param {function} predicate
		 * @returns {function} conditional catch handler
		 */
		function createCatchFilter(handler, predicate) {
			return function(e) {
				return evaluatePredicate(e, predicate)
					? handler.call(this, e)
					: reject(e);
			};
		}

		/**
		 * Ensures that onFulfilledOrRejected will be called regardless of whether
		 * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT
		 * receive the promises' value or reason.  Any returned value will be disregarded.
		 * onFulfilledOrRejected may throw or return a rejected promise to signal
		 * an additional error.
		 * @param {function} handler handler to be called regardless of
		 *  fulfillment or rejection
		 * @returns {Promise}
		 */
		Promise.prototype['finally'] = Promise.prototype.ensure = function(handler) {
			if(typeof handler !== 'function') {
				return this;
			}

			return this.then(function(x) {
				return runSideEffect(handler, this, identity, x);
			}, function(e) {
				return runSideEffect(handler, this, reject, e);
			});
		};

		function runSideEffect (handler, thisArg, propagate, value) {
			var result = handler.call(thisArg);
			return maybeThenable(result)
				? propagateValue(result, propagate, value)
				: propagate(value);
		}

		function propagateValue (result, propagate, x) {
			return resolve(result).then(function () {
				return propagate(x);
			});
		}

		/**
		 * Recover from a failure by returning a defaultValue.  If defaultValue
		 * is a promise, it's fulfillment value will be used.  If defaultValue is
		 * a promise that rejects, the returned promise will reject with the
		 * same reason.
		 * @param {*} defaultValue
		 * @returns {Promise} new promise
		 */
		Promise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {
			return this.then(void 0, function() {
				return defaultValue;
			});
		};

		/**
		 * Shortcut for .then(function() { return value; })
		 * @param  {*} value
		 * @return {Promise} a promise that:
		 *  - is fulfilled if value is not a promise, or
		 *  - if value is a promise, will fulfill with its value, or reject
		 *    with its reason.
		 */
		Promise.prototype['yield'] = function(value) {
			return this.then(function() {
				return value;
			});
		};

		/**
		 * Runs a side effect when this promise fulfills, without changing the
		 * fulfillment value.
		 * @param {function} onFulfilledSideEffect
		 * @returns {Promise}
		 */
		Promise.prototype.tap = function(onFulfilledSideEffect) {
			return this.then(onFulfilledSideEffect)['yield'](this);
		};

		return Promise;
	};

	function rejectInvalidPredicate() {
		throw new TypeError('catch predicate must be a function');
	}

	function evaluatePredicate(e, predicate) {
		return isError(predicate) ? e instanceof predicate : predicate(e);
	}

	function isError(predicate) {
		return predicate === Error
			|| (predicate != null && predicate.prototype instanceof Error);
	}

	function maybeThenable(x) {
		return (typeof x === 'object' || typeof x === 'function') && x !== null;
	}

	function identity(x) {
		return x;
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],277:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */
/** @author Jeff Escalante */

(function(define) { 'use strict';
define(function() {

	return function fold(Promise) {

		Promise.prototype.fold = function(f, z) {
			var promise = this._beget();

			this._handler.fold(function(z, x, to) {
				Promise._handler(z).fold(function(x, z, to) {
					to.resolve(f.call(this, z, x));
				}, x, this, to);
			}, z, promise._handler.receiver, promise._handler);

			return promise;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],278:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var inspect = require('../state').inspect;

	return function inspection(Promise) {

		Promise.prototype.inspect = function() {
			return inspect(Promise._handler(this));
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../state":287}],279:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function generate(Promise) {

		var resolve = Promise.resolve;

		Promise.iterate = iterate;
		Promise.unfold = unfold;

		return Promise;

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.iterate
		 * Generate a (potentially infinite) stream of promised values:
		 * x, f(x), f(f(x)), etc. until condition(x) returns true
		 * @param {function} f function to generate a new x from the previous x
		 * @param {function} condition function that, given the current x, returns
		 *  truthy when the iterate should stop
		 * @param {function} handler function to handle the value produced by f
		 * @param {*|Promise} x starting value, may be a promise
		 * @return {Promise} the result of the last call to f before
		 *  condition returns true
		 */
		function iterate(f, condition, handler, x) {
			return unfold(function(x) {
				return [x, f(x)];
			}, condition, handler, x);
		}

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.unfold
		 * Generate a (potentially infinite) stream of promised values
		 * by applying handler(generator(seed)) iteratively until
		 * condition(seed) returns true.
		 * @param {function} unspool function that generates a [value, newSeed]
		 *  given a seed.
		 * @param {function} condition function that, given the current seed, returns
		 *  truthy when the unfold should stop
		 * @param {function} handler function to handle the value produced by unspool
		 * @param x {*|Promise} starting value, may be a promise
		 * @return {Promise} the result of the last value produced by unspool before
		 *  condition returns true
		 */
		function unfold(unspool, condition, handler, x) {
			return resolve(x).then(function(seed) {
				return resolve(condition(seed)).then(function(done) {
					return done ? seed : resolve(unspool(seed)).spread(next);
				});
			});

			function next(item, newSeed) {
				return resolve(handler(item)).then(function() {
					return unfold(unspool, condition, handler, newSeed);
				});
			}
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],280:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function progress(Promise) {

		/**
		 * @deprecated
		 * Register a progress handler for this promise
		 * @param {function} onProgress
		 * @returns {Promise}
		 */
		Promise.prototype.progress = function(onProgress) {
			return this.then(void 0, void 0, onProgress);
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],281:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var env = require('../env');
	var TimeoutError = require('../TimeoutError');

	function setTimeout(f, ms, x, y) {
		return env.setTimer(function() {
			f(x, y, ms);
		}, ms);
	}

	return function timed(Promise) {
		/**
		 * Return a new promise whose fulfillment value is revealed only
		 * after ms milliseconds
		 * @param {number} ms milliseconds
		 * @returns {Promise}
		 */
		Promise.prototype.delay = function(ms) {
			var p = this._beget();
			this._handler.fold(handleDelay, ms, void 0, p._handler);
			return p;
		};

		function handleDelay(ms, x, h) {
			setTimeout(resolveDelay, ms, x, h);
		}

		function resolveDelay(x, h) {
			h.resolve(x);
		}

		/**
		 * Return a new promise that rejects after ms milliseconds unless
		 * this promise fulfills earlier, in which case the returned promise
		 * fulfills with the same value.
		 * @param {number} ms milliseconds
		 * @param {Error|*=} reason optional rejection reason to use, defaults
		 *   to a TimeoutError if not provided
		 * @returns {Promise}
		 */
		Promise.prototype.timeout = function(ms, reason) {
			var p = this._beget();
			var h = p._handler;

			var t = setTimeout(onTimeout, ms, reason, p._handler);

			this._handler.visit(h,
				function onFulfill(x) {
					env.clearTimer(t);
					this.resolve(x); // this = h
				},
				function onReject(x) {
					env.clearTimer(t);
					this.reject(x); // this = h
				},
				h.notify);

			return p;
		};

		function onTimeout(reason, h, ms) {
			var e = typeof reason === 'undefined'
				? new TimeoutError('timed out after ' + ms + 'ms')
				: reason;
			h.reject(e);
		}

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../TimeoutError":273,"../env":284}],282:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var setTimer = require('../env').setTimer;
	var format = require('../format');

	return function unhandledRejection(Promise) {

		var logError = noop;
		var logInfo = noop;
		var localConsole;

		if(typeof console !== 'undefined') {
			// Alias console to prevent things like uglify's drop_console option from
			// removing console.log/error. Unhandled rejections fall into the same
			// category as uncaught exceptions, and build tools shouldn't silence them.
			localConsole = console;
			logError = typeof localConsole.error !== 'undefined'
				? function (e) { localConsole.error(e); }
				: function (e) { localConsole.log(e); };

			logInfo = typeof localConsole.info !== 'undefined'
				? function (e) { localConsole.info(e); }
				: function (e) { localConsole.log(e); };
		}

		Promise.onPotentiallyUnhandledRejection = function(rejection) {
			enqueue(report, rejection);
		};

		Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
			enqueue(unreport, rejection);
		};

		Promise.onFatalRejection = function(rejection) {
			enqueue(throwit, rejection.value);
		};

		var tasks = [];
		var reported = [];
		var running = null;

		function report(r) {
			if(!r.handled) {
				reported.push(r);
				logError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));
			}
		}

		function unreport(r) {
			var i = reported.indexOf(r);
			if(i >= 0) {
				reported.splice(i, 1);
				logInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));
			}
		}

		function enqueue(f, x) {
			tasks.push(f, x);
			if(running === null) {
				running = setTimer(flush, 0);
			}
		}

		function flush() {
			running = null;
			while(tasks.length > 0) {
				tasks.shift()(tasks.shift());
			}
		}

		return Promise;
	};

	function throwit(e) {
		throw e;
	}

	function noop() {}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../env":284,"../format":285}],283:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function addWith(Promise) {
		/**
		 * Returns a promise whose handlers will be called with `this` set to
		 * the supplied receiver.  Subsequent promises derived from the
		 * returned promise will also have their handlers called with receiver
		 * as `this`. Calling `with` with undefined or no arguments will return
		 * a promise whose handlers will again be called in the usual Promises/A+
		 * way (no `this`) thus safely undoing any previous `with` in the
		 * promise chain.
		 *
		 * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+
		 * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)
		 *
		 * @param {object} receiver `this` value for all handlers attached to
		 *  the returned promise.
		 * @returns {Promise}
		 */
		Promise.prototype['with'] = Promise.prototype.withThis = function(receiver) {
			var p = this._beget();
			var child = p._handler;
			child.receiver = receiver;
			this._handler.chain(child, receiver);
			return p;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));


},{}],284:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/
(function(define) { 'use strict';
define(function(require) {
	/*jshint maxcomplexity:6*/

	// Sniff "best" async scheduling option
	// Prefer process.nextTick or MutationObserver, then check for
	// setTimeout, and finally vertx, since its the only env that doesn't
	// have setTimeout

	var MutationObs;
	var capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;

	// Default env
	var setTimer = function(f, ms) { return setTimeout(f, ms); };
	var clearTimer = function(t) { return clearTimeout(t); };
	var asap = function (f) { return capturedSetTimeout(f, 0); };

	// Detect specific env
	if (isNode()) { // Node
		asap = function (f) { return process.nextTick(f); };

	} else if (MutationObs = hasMutationObserver()) { // Modern browser
		asap = initMutationObserver(MutationObs);

	} else if (!capturedSetTimeout) { // vert.x
		var vertxRequire = require;
		var vertx = vertxRequire('vertx');
		setTimer = function (f, ms) { return vertx.setTimer(ms, f); };
		clearTimer = vertx.cancelTimer;
		asap = vertx.runOnLoop || vertx.runOnContext;
	}

	return {
		setTimer: setTimer,
		clearTimer: clearTimer,
		asap: asap
	};

	function isNode () {
		return typeof process !== 'undefined' &&
			Object.prototype.toString.call(process) === '[object process]';
	}

	function hasMutationObserver () {
	    return (typeof MutationObserver !== 'undefined' && MutationObserver) ||
			(typeof WebKitMutationObserver !== 'undefined' && WebKitMutationObserver);
	}

	function initMutationObserver(MutationObserver) {
		var scheduled;
		var node = document.createTextNode('');
		var o = new MutationObserver(run);
		o.observe(node, { characterData: true });

		function run() {
			var f = scheduled;
			scheduled = void 0;
			f();
		}

		var i = 0;
		return function (f) {
			scheduled = f;
			node.data = (i ^= 1);
		};
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

}).call(this,require('_process'))

},{"_process":6}],285:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		formatError: formatError,
		formatObject: formatObject,
		tryStringify: tryStringify
	};

	/**
	 * Format an error into a string.  If e is an Error and has a stack property,
	 * it's returned.  Otherwise, e is formatted using formatObject, with a
	 * warning added about e not being a proper Error.
	 * @param {*} e
	 * @returns {String} formatted string, suitable for output to developers
	 */
	function formatError(e) {
		var s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);
		return e instanceof Error ? s : s + ' (WARNING: non-Error used)';
	}

	/**
	 * Format an object, detecting "plain" objects and running them through
	 * JSON.stringify if possible.
	 * @param {Object} o
	 * @returns {string}
	 */
	function formatObject(o) {
		var s = String(o);
		if(s === '[object Object]' && typeof JSON !== 'undefined') {
			s = tryStringify(o, s);
		}
		return s;
	}

	/**
	 * Try to return the result of JSON.stringify(x).  If that fails, return
	 * defaultValue
	 * @param {*} x
	 * @param {*} defaultValue
	 * @returns {String|*} JSON.stringify(x) or defaultValue
	 */
	function tryStringify(x, defaultValue) {
		try {
			return JSON.stringify(x);
		} catch(e) {
			return defaultValue;
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],286:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function makePromise(environment) {

		var tasks = environment.scheduler;
		var emitRejection = initEmitRejection();

		var objectCreate = Object.create ||
			function(proto) {
				function Child() {}
				Child.prototype = proto;
				return new Child();
			};

		/**
		 * Create a promise whose fate is determined by resolver
		 * @constructor
		 * @returns {Promise} promise
		 * @name Promise
		 */
		function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}

		/**
		 * Run the supplied resolver
		 * @param resolver
		 * @returns {Pending}
		 */
		function init(resolver) {
			var handler = new Pending();

			try {
				resolver(promiseResolve, promiseReject, promiseNotify);
			} catch (e) {
				promiseReject(e);
			}

			return handler;

			/**
			 * Transition from pre-resolution state to post-resolution state, notifying
			 * all listeners of the ultimate fulfillment or rejection
			 * @param {*} x resolution value
			 */
			function promiseResolve (x) {
				handler.resolve(x);
			}
			/**
			 * Reject this promise with reason, which will be used verbatim
			 * @param {Error|*} reason rejection reason, strongly suggested
			 *   to be an Error type
			 */
			function promiseReject (reason) {
				handler.reject(reason);
			}

			/**
			 * @deprecated
			 * Issue a progress event, notifying all progress listeners
			 * @param {*} x progress event payload to pass to all listeners
			 */
			function promiseNotify (x) {
				handler.notify(x);
			}
		}

		// Creation

		Promise.resolve = resolve;
		Promise.reject = reject;
		Promise.never = never;

		Promise._defer = defer;
		Promise._handler = getHandler;

		/**
		 * Returns a trusted promise. If x is already a trusted promise, it is
		 * returned, otherwise returns a new trusted Promise which follows x.
		 * @param  {*} x
		 * @return {Promise} promise
		 */
		function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}

		/**
		 * Return a reject promise with x as its reason (x is used verbatim)
		 * @param {*} x
		 * @returns {Promise} rejected promise
		 */
		function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}

		/**
		 * Return a promise that remains pending forever
		 * @returns {Promise} forever-pending promise.
		 */
		function never() {
			return foreverPendingPromise; // Should be frozen
		}

		/**
		 * Creates an internal {promise, resolver} pair
		 * @private
		 * @returns {Promise}
		 */
		function defer() {
			return new Promise(Handler, new Pending());
		}

		// Transformation and flow control

		/**
		 * Transform this promise's fulfillment value, returning a new Promise
		 * for the transformed result.  If the promise cannot be fulfilled, onRejected
		 * is called with the reason.  onProgress *may* be called with updates toward
		 * this promise's fulfillment.
		 * @param {function=} onFulfilled fulfillment handler
		 * @param {function=} onRejected rejection handler
		 * @param {function=} onProgress @deprecated progress handler
		 * @return {Promise} new promise
		 */
		Promise.prototype.then = function(onFulfilled, onRejected, onProgress) {
			var parent = this._handler;
			var state = parent.join().state();

			if ((typeof onFulfilled !== 'function' && state > 0) ||
				(typeof onRejected !== 'function' && state < 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}

			var p = this._beget();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

			return p;
		};

		/**
		 * If this promise cannot be fulfilled due to an error, call onRejected to
		 * handle the error. Shortcut for .then(undefined, onRejected)
		 * @param {function?} onRejected
		 * @return {Promise}
		 */
		Promise.prototype['catch'] = function(onRejected) {
			return this.then(void 0, onRejected);
		};

		/**
		 * Creates a new, pending promise of the same type as this promise
		 * @private
		 * @returns {Promise}
		 */
		Promise.prototype._beget = function() {
			return begetFrom(this._handler, this.constructor);
		};

		function begetFrom(parent, Promise) {
			var child = new Pending(parent.receiver, parent.join().context);
			return new Promise(Handler, child);
		}

		// Array combinators

		Promise.all = all;
		Promise.race = race;
		Promise._traverse = traverse;

		/**
		 * Return a promise that will fulfill when all promises in the
		 * input array have fulfilled, or will reject when one of the
		 * promises rejects.
		 * @param {array} promises array of promises
		 * @returns {Promise} promise for array of fulfillment values
		 */
		function all(promises) {
			return traverseWith(snd, null, promises);
		}

		/**
		 * Array<Promise<X>> -> Promise<Array<f(X)>>
		 * @private
		 * @param {function} f function to apply to each promise's value
		 * @param {Array} promises array of promises
		 * @returns {Promise} promise for transformed values
		 */
		function traverse(f, promises) {
			return traverseWith(tryCatch2, f, promises);
		}

		function traverseWith(tryMap, f, promises) {
			var handler = typeof f === 'function' ? mapAt : settleAt;

			var resolver = new Pending();
			var pending = promises.length >>> 0;
			var results = new Array(pending);

			for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {
				x = promises[i];

				if (x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				traverseAt(promises, handler, i, x, resolver);
			}

			if(pending === 0) {
				resolver.become(new Fulfilled(results));
			}

			return new Promise(Handler, resolver);

			function mapAt(i, x, resolver) {
				if(!resolver.resolved) {
					traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);
				}
			}

			function settleAt(i, x, resolver) {
				results[i] = x;
				if(--pending === 0) {
					resolver.become(new Fulfilled(results));
				}
			}
		}

		function traverseAt(promises, handler, i, x, resolver) {
			if (maybeThenable(x)) {
				var h = getHandlerMaybeThenable(x);
				var s = h.state();

				if (s === 0) {
					h.fold(handler, i, void 0, resolver);
				} else if (s > 0) {
					handler(i, h.value, resolver);
				} else {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
				}
			} else {
				handler(i, x, resolver);
			}
		}

		Promise._visitRemaining = visitRemaining;
		function visitRemaining(promises, start, handler) {
			for(var i=start; i<promises.length; ++i) {
				markAsHandled(getHandler(promises[i]), handler);
			}
		}

		function markAsHandled(h, handler) {
			if(h === handler) {
				return;
			}

			var s = h.state();
			if(s === 0) {
				h.visit(h, void 0, h._unreport);
			} else if(s < 0) {
				h._unreport();
			}
		}

		/**
		 * Fulfill-reject competitive race. Return a promise that will settle
		 * to the same state as the earliest input promise to settle.
		 *
		 * WARNING: The ES6 Promise spec requires that race()ing an empty array
		 * must return a promise that is pending forever.  This implementation
		 * returns a singleton forever-pending promise, the same singleton that is
		 * returned by Promise.never(), thus can be checked with ===
		 *
		 * @param {array} promises array of promises to race
		 * @returns {Promise} if input is non-empty, a promise that will settle
		 * to the same outcome as the earliest input promise to settle. if empty
		 * is empty, returns a promise that will never settle.
		 */
		function race(promises) {
			if(typeof promises !== 'object' || promises === null) {
				return reject(new TypeError('non-iterable passed to race()'));
			}

			// Sigh, race([]) is untestable unless we return *something*
			// that is recognizable without calling .then() on it.
			return promises.length === 0 ? never()
				 : promises.length === 1 ? resolve(promises[0])
				 : runRace(promises);
		}

		function runRace(promises) {
			var resolver = new Pending();
			var i, x, h;
			for(i=0; i<promises.length; ++i) {
				x = promises[i];
				if (x === void 0 && !(i in promises)) {
					continue;
				}

				h = getHandler(x);
				if(h.state() !== 0) {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
					break;
				} else {
					h.visit(resolver, resolver.resolve, resolver.reject);
				}
			}
			return new Promise(Handler, resolver);
		}

		// Promise internals
		// Below this, everything is @private

		/**
		 * Get an appropriate handler for x, without checking for cycles
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandler(x) {
			if(isPromise(x)) {
				return x._handler.join();
			}
			return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
		}

		/**
		 * Get a handler for thenable x.
		 * NOTE: You must only call this if maybeThenable(x) == true
		 * @param {object|function|Promise} x
		 * @returns {object} handler
		 */
		function getHandlerMaybeThenable(x) {
			return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);
		}

		/**
		 * Get a handler for potentially untrusted thenable x
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandlerUntrusted(x) {
			try {
				var untrustedThen = x.then;
				return typeof untrustedThen === 'function'
					? new Thenable(untrustedThen, x)
					: new Fulfilled(x);
			} catch(e) {
				return new Rejected(e);
			}
		}

		/**
		 * Handler for a promise that is pending forever
		 * @constructor
		 */
		function Handler() {}

		Handler.prototype.when
			= Handler.prototype.become
			= Handler.prototype.notify // deprecated
			= Handler.prototype.fail
			= Handler.prototype._unreport
			= Handler.prototype._report
			= noop;

		Handler.prototype._state = 0;

		Handler.prototype.state = function() {
			return this._state;
		};

		/**
		 * Recursively collapse handler chain to find the handler
		 * nearest to the fully resolved value.
		 * @returns {object} handler nearest the fully resolved value
		 */
		Handler.prototype.join = function() {
			var h = this;
			while(h.handler !== void 0) {
				h = h.handler;
			}
			return h;
		};

		Handler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {
			this.when({
				resolver: to,
				receiver: receiver,
				fulfilled: fulfilled,
				rejected: rejected,
				progress: progress
			});
		};

		Handler.prototype.visit = function(receiver, fulfilled, rejected, progress) {
			this.chain(failIfRejected, receiver, fulfilled, rejected, progress);
		};

		Handler.prototype.fold = function(f, z, c, to) {
			this.when(new Fold(f, z, c, to));
		};

		/**
		 * Handler that invokes fail() on any handler it becomes
		 * @constructor
		 */
		function FailIfRejected() {}

		inherit(Handler, FailIfRejected);

		FailIfRejected.prototype.become = function(h) {
			h.fail();
		};

		var failIfRejected = new FailIfRejected();

		/**
		 * Handler that manages a queue of consumers waiting on a pending promise
		 * @constructor
		 */
		function Pending(receiver, inheritedContext) {
			Promise.createContext(this, inheritedContext);

			this.consumers = void 0;
			this.receiver = receiver;
			this.handler = void 0;
			this.resolved = false;
		}

		inherit(Handler, Pending);

		Pending.prototype._state = 0;

		Pending.prototype.resolve = function(x) {
			this.become(getHandler(x));
		};

		Pending.prototype.reject = function(x) {
			if(this.resolved) {
				return;
			}

			this.become(new Rejected(x));
		};

		Pending.prototype.join = function() {
			if (!this.resolved) {
				return this;
			}

			var h = this;

			while (h.handler !== void 0) {
				h = h.handler;
				if (h === this) {
					return this.handler = cycle();
				}
			}

			return h;
		};

		Pending.prototype.run = function() {
			var q = this.consumers;
			var handler = this.handler;
			this.handler = this.handler.join();
			this.consumers = void 0;

			for (var i = 0; i < q.length; ++i) {
				handler.when(q[i]);
			}
		};

		Pending.prototype.become = function(handler) {
			if(this.resolved) {
				return;
			}

			this.resolved = true;
			this.handler = handler;
			if(this.consumers !== void 0) {
				tasks.enqueue(this);
			}

			if(this.context !== void 0) {
				handler._report(this.context);
			}
		};

		Pending.prototype.when = function(continuation) {
			if(this.resolved) {
				tasks.enqueue(new ContinuationTask(continuation, this.handler));
			} else {
				if(this.consumers === void 0) {
					this.consumers = [continuation];
				} else {
					this.consumers.push(continuation);
				}
			}
		};

		/**
		 * @deprecated
		 */
		Pending.prototype.notify = function(x) {
			if(!this.resolved) {
				tasks.enqueue(new ProgressTask(x, this));
			}
		};

		Pending.prototype.fail = function(context) {
			var c = typeof context === 'undefined' ? this.context : context;
			this.resolved && this.handler.join().fail(c);
		};

		Pending.prototype._report = function(context) {
			this.resolved && this.handler.join()._report(context);
		};

		Pending.prototype._unreport = function() {
			this.resolved && this.handler.join()._unreport();
		};

		/**
		 * Wrap another handler and force it into a future stack
		 * @param {object} handler
		 * @constructor
		 */
		function Async(handler) {
			this.handler = handler;
		}

		inherit(Handler, Async);

		Async.prototype.when = function(continuation) {
			tasks.enqueue(new ContinuationTask(continuation, this));
		};

		Async.prototype._report = function(context) {
			this.join()._report(context);
		};

		Async.prototype._unreport = function() {
			this.join()._unreport();
		};

		/**
		 * Handler that wraps an untrusted thenable and assimilates it in a future stack
		 * @param {function} then
		 * @param {{then: function}} thenable
		 * @constructor
		 */
		function Thenable(then, thenable) {
			Pending.call(this);
			tasks.enqueue(new AssimilateTask(then, thenable, this));
		}

		inherit(Pending, Thenable);

		/**
		 * Handler for a fulfilled promise
		 * @param {*} x fulfillment value
		 * @constructor
		 */
		function Fulfilled(x) {
			Promise.createContext(this);
			this.value = x;
		}

		inherit(Handler, Fulfilled);

		Fulfilled.prototype._state = 1;

		Fulfilled.prototype.fold = function(f, z, c, to) {
			runContinuation3(f, z, this, c, to);
		};

		Fulfilled.prototype.when = function(cont) {
			runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);
		};

		var errorId = 0;

		/**
		 * Handler for a rejected promise
		 * @param {*} x rejection reason
		 * @constructor
		 */
		function Rejected(x) {
			Promise.createContext(this);

			this.id = ++errorId;
			this.value = x;
			this.handled = false;
			this.reported = false;

			this._report();
		}

		inherit(Handler, Rejected);

		Rejected.prototype._state = -1;

		Rejected.prototype.fold = function(f, z, c, to) {
			to.become(this);
		};

		Rejected.prototype.when = function(cont) {
			if(typeof cont.rejected === 'function') {
				this._unreport();
			}
			runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
		};

		Rejected.prototype._report = function(context) {
			tasks.afterQueue(new ReportTask(this, context));
		};

		Rejected.prototype._unreport = function() {
			if(this.handled) {
				return;
			}
			this.handled = true;
			tasks.afterQueue(new UnreportTask(this));
		};

		Rejected.prototype.fail = function(context) {
			this.reported = true;
			emitRejection('unhandledRejection', this);
			Promise.onFatalRejection(this, context === void 0 ? this.context : context);
		};

		function ReportTask(rejection, context) {
			this.rejection = rejection;
			this.context = context;
		}

		ReportTask.prototype.run = function() {
			if(!this.rejection.handled && !this.rejection.reported) {
				this.rejection.reported = true;
				emitRejection('unhandledRejection', this.rejection) ||
					Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);
			}
		};

		function UnreportTask(rejection) {
			this.rejection = rejection;
		}

		UnreportTask.prototype.run = function() {
			if(this.rejection.reported) {
				emitRejection('rejectionHandled', this.rejection) ||
					Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);
			}
		};

		// Unhandled rejection hooks
		// By default, everything is a noop

		Promise.createContext
			= Promise.enterContext
			= Promise.exitContext
			= Promise.onPotentiallyUnhandledRejection
			= Promise.onPotentiallyUnhandledRejectionHandled
			= Promise.onFatalRejection
			= noop;

		// Errors and singletons

		var foreverPendingHandler = new Handler();
		var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);

		function cycle() {
			return new Rejected(new TypeError('Promise cycle'));
		}

		// Task runners

		/**
		 * Run a single consumer
		 * @constructor
		 */
		function ContinuationTask(continuation, handler) {
			this.continuation = continuation;
			this.handler = handler;
		}

		ContinuationTask.prototype.run = function() {
			this.handler.join().when(this.continuation);
		};

		/**
		 * Run a queue of progress handlers
		 * @constructor
		 */
		function ProgressTask(value, handler) {
			this.handler = handler;
			this.value = value;
		}

		ProgressTask.prototype.run = function() {
			var q = this.handler.consumers;
			if(q === void 0) {
				return;
			}

			for (var c, i = 0; i < q.length; ++i) {
				c = q[i];
				runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);
			}
		};

		/**
		 * Assimilate a thenable, sending it's value to resolver
		 * @param {function} then
		 * @param {object|function} thenable
		 * @param {object} resolver
		 * @constructor
		 */
		function AssimilateTask(then, thenable, resolver) {
			this._then = then;
			this.thenable = thenable;
			this.resolver = resolver;
		}

		AssimilateTask.prototype.run = function() {
			var h = this.resolver;
			tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);

			function _resolve(x) { h.resolve(x); }
			function _reject(x)  { h.reject(x); }
			function _notify(x)  { h.notify(x); }
		};

		function tryAssimilate(then, thenable, resolve, reject, notify) {
			try {
				then.call(thenable, resolve, reject, notify);
			} catch (e) {
				reject(e);
			}
		}

		/**
		 * Fold a handler value with z
		 * @constructor
		 */
		function Fold(f, z, c, to) {
			this.f = f; this.z = z; this.c = c; this.to = to;
			this.resolver = failIfRejected;
			this.receiver = this;
		}

		Fold.prototype.fulfilled = function(x) {
			this.f.call(this.c, this.z, x, this.to);
		};

		Fold.prototype.rejected = function(x) {
			this.to.reject(x);
		};

		Fold.prototype.progress = function(x) {
			this.to.notify(x);
		};

		// Other helpers

		/**
		 * @param {*} x
		 * @returns {boolean} true iff x is a trusted Promise
		 */
		function isPromise(x) {
			return x instanceof Promise;
		}

		/**
		 * Test just enough to rule out primitives, in order to take faster
		 * paths in some code
		 * @param {*} x
		 * @returns {boolean} false iff x is guaranteed *not* to be a thenable
		 */
		function maybeThenable(x) {
			return (typeof x === 'object' || typeof x === 'function') && x !== null;
		}

		function runContinuation1(f, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject(f, h.value, receiver, next);
			Promise.exitContext();
		}

		function runContinuation3(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject3(f, x, h.value, receiver, next);
			Promise.exitContext();
		}

		/**
		 * @deprecated
		 */
		function runNotify(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.notify(x);
			}

			Promise.enterContext(h);
			tryCatchReturn(f, x, receiver, next);
			Promise.exitContext();
		}

		function tryCatch2(f, a, b) {
			try {
				return f(a, b);
			} catch(e) {
				return reject(e);
			}
		}

		/**
		 * Return f.call(thisArg, x), or if it throws return a rejected promise for
		 * the thrown exception
		 */
		function tryCatchReject(f, x, thisArg, next) {
			try {
				next.become(getHandler(f.call(thisArg, x)));
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * Same as above, but includes the extra argument parameter.
		 */
		function tryCatchReject3(f, x, y, thisArg, next) {
			try {
				f.call(thisArg, x, y, next);
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * @deprecated
		 * Return f.call(thisArg, x), or if it throws, *return* the exception
		 */
		function tryCatchReturn(f, x, thisArg, next) {
			try {
				next.notify(f.call(thisArg, x));
			} catch(e) {
				next.notify(e);
			}
		}

		function inherit(Parent, Child) {
			Child.prototype = objectCreate(Parent.prototype);
			Child.prototype.constructor = Child;
		}

		function snd(x, y) {
			return y;
		}

		function noop() {}

		function hasCustomEvent() {
			if(typeof CustomEvent === 'function') {
				try {
					var ev = new CustomEvent('unhandledRejection');
					return ev instanceof CustomEvent;
				} catch (ignoredException) {}
			}
			return false;
		}

		function hasInternetExplorerCustomEvent() {
			if(typeof document !== 'undefined' && typeof document.createEvent === 'function') {
				try {
					// Try to create one event to make sure it's supported
					var ev = document.createEvent('CustomEvent');
					ev.initCustomEvent('eventType', false, true, {});
					return true;
				} catch (ignoredException) {}
			}
			return false;
		}

		function initEmitRejection() {
			/*global process, self, CustomEvent*/
			if(typeof process !== 'undefined' && process !== null
				&& typeof process.emit === 'function') {
				// Returning falsy here means to call the default
				// onPotentiallyUnhandledRejection API.  This is safe even in
				// browserify since process.emit always returns falsy in browserify:
				// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46
				return function(type, rejection) {
					return type === 'unhandledRejection'
						? process.emit(type, rejection.value, rejection)
						: process.emit(type, rejection);
				};
			} else if(typeof self !== 'undefined' && hasCustomEvent()) {
				return (function (self, CustomEvent) {
					return function (type, rejection) {
						var ev = new CustomEvent(type, {
							detail: {
								reason: rejection.value,
								key: rejection
							},
							bubbles: false,
							cancelable: true
						});

						return !self.dispatchEvent(ev);
					};
				}(self, CustomEvent));
			} else if(typeof self !== 'undefined' && hasInternetExplorerCustomEvent()) {
				return (function(self, document) {
					return function(type, rejection) {
						var ev = document.createEvent('CustomEvent');
						ev.initCustomEvent(type, false, true, {
							reason: rejection.value,
							key: rejection
						});

						return !self.dispatchEvent(ev);
					};
				}(self, document));
			}

			return noop;
		}

		return Promise;
	};
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

}).call(this,require('_process'))

},{"_process":6}],287:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		pending: toPendingState,
		fulfilled: toFulfilledState,
		rejected: toRejectedState,
		inspect: inspect
	};

	function toPendingState() {
		return { state: 'pending' };
	}

	function toRejectedState(e) {
		return { state: 'rejected', reason: e };
	}

	function toFulfilledState(x) {
		return { state: 'fulfilled', value: x };
	}

	function inspect(handler) {
		var state = handler.state();
		return state === 0 ? toPendingState()
			 : state > 0   ? toFulfilledState(handler.value)
			               : toRejectedState(handler.value);
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],288:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */

/**
 * Promises/A+ and when() implementation
 * when is part of the cujoJS family of libraries (http://cujojs.com/)
 * @author Brian Cavalier
 * @author John Hann
 */
(function(define) { 'use strict';
define(function (require) {

	var timed = require('./lib/decorators/timed');
	var array = require('./lib/decorators/array');
	var flow = require('./lib/decorators/flow');
	var fold = require('./lib/decorators/fold');
	var inspect = require('./lib/decorators/inspect');
	var generate = require('./lib/decorators/iterate');
	var progress = require('./lib/decorators/progress');
	var withThis = require('./lib/decorators/with');
	var unhandledRejection = require('./lib/decorators/unhandledRejection');
	var TimeoutError = require('./lib/TimeoutError');

	var Promise = [array, flow, fold, generate, progress,
		inspect, withThis, timed, unhandledRejection]
		.reduce(function(Promise, feature) {
			return feature(Promise);
		}, require('./lib/Promise'));

	var apply = require('./lib/apply')(Promise);

	// Public API

	when.promise     = promise;              // Create a pending promise
	when.resolve     = Promise.resolve;      // Create a resolved promise
	when.reject      = Promise.reject;       // Create a rejected promise

	when.lift        = lift;                 // lift a function to return promises
	when['try']      = attempt;              // call a function and return a promise
	when.attempt     = attempt;              // alias for when.try

	when.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises
	when.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises

	when.join        = join;                 // Join 2 or more promises

	when.all         = all;                  // Resolve a list of promises
	when.settle      = settle;               // Settle a list of promises

	when.any         = lift(Promise.any);    // One-winner race
	when.some        = lift(Promise.some);   // Multi-winner race
	when.race        = lift(Promise.race);   // First-to-settle race

	when.map         = map;                  // Array.map() for promises
	when.filter      = filter;               // Array.filter() for promises
	when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
	when.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises

	when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

	when.Promise     = Promise;              // Promise constructor
	when.defer       = defer;                // Create a {promise, resolve, reject} tuple

	// Error types

	when.TimeoutError = TimeoutError;

	/**
	 * Get a trusted promise for x, or by transforming x with onFulfilled
	 *
	 * @param {*} x
	 * @param {function?} onFulfilled callback to be called when x is
	 *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
	 *   will be invoked immediately.
	 * @param {function?} onRejected callback to be called when x is
	 *   rejected.
	 * @param {function?} onProgress callback to be called when progress updates
	 *   are issued for x. @deprecated
	 * @returns {Promise} a new promise that will fulfill with the return
	 *   value of callback or errback or the completion value of promiseOrValue if
	 *   callback and/or errback is not supplied.
	 */
	function when(x, onFulfilled, onRejected, onProgress) {
		var p = Promise.resolve(x);
		if (arguments.length < 2) {
			return p;
		}

		return p.then(onFulfilled, onRejected, onProgress);
	}

	/**
	 * Creates a new promise whose fate is determined by resolver.
	 * @param {function} resolver function(resolve, reject, notify)
	 * @returns {Promise} promise whose fate is determine by resolver
	 */
	function promise(resolver) {
		return new Promise(resolver);
	}

	/**
	 * Lift the supplied function, creating a version of f that returns
	 * promises, and accepts promises as arguments.
	 * @param {function} f
	 * @returns {Function} version of f that returns promises
	 */
	function lift(f) {
		return function() {
			for(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		};
	}

	/**
	 * Call f in a future turn, with the supplied args, and return a promise
	 * for the result.
	 * @param {function} f
	 * @returns {Promise}
	 */
	function attempt(f /*, args... */) {
		/*jshint validthis:true */
		for(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {
			a[i] = arguments[i+1];
		}
		return apply(f, this, a);
	}

	/**
	 * Creates a {promise, resolver} pair, either or both of which
	 * may be given out safely to consumers.
	 * @return {{promise: Promise, resolve: function, reject: function, notify: function}}
	 */
	function defer() {
		return new Deferred();
	}

	function Deferred() {
		var p = Promise._defer();

		function resolve(x) { p._handler.resolve(x); }
		function reject(x) { p._handler.reject(x); }
		function notify(x) { p._handler.notify(x); }

		this.promise = p;
		this.resolve = resolve;
		this.reject = reject;
		this.notify = notify;
		this.resolver = { resolve: resolve, reject: reject, notify: notify };
	}

	/**
	 * Determines if x is promise-like, i.e. a thenable object
	 * NOTE: Will return true for *any thenable object*, and isn't truly
	 * safe, since it may attempt to access the `then` property of x (i.e.
	 *  clever/malicious getters may do weird things)
	 * @param {*} x anything
	 * @returns {boolean} true if x is promise-like
	 */
	function isPromiseLike(x) {
		return x && typeof x.then === 'function';
	}

	/**
	 * Return a promise that will resolve only once all the supplied arguments
	 * have resolved. The resolution value of the returned promise will be an array
	 * containing the resolution values of each of the arguments.
	 * @param {...*} arguments may be a mix of promises and values
	 * @returns {Promise}
	 */
	function join(/* ...promises */) {
		return Promise.all(arguments);
	}

	/**
	 * Return a promise that will fulfill once all input promises have
	 * fulfilled, or reject when any one input promise rejects.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise}
	 */
	function all(promises) {
		return when(promises, Promise.all);
	}

	/**
	 * Return a promise that will always fulfill with an array containing
	 * the outcome states of all input promises.  The returned promise
	 * will only reject if `promises` itself is a rejected promise.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise} promise for array of settled state descriptors
	 */
	function settle(promises) {
		return when(promises, Promise.settle);
	}

	/**
	 * Promise-aware array map function, similar to `Array.prototype.map()`,
	 * but input array may contain promises or values.
	 * @param {Array|Promise} promises array of anything, may contain promises and values
	 * @param {function(x:*, index:Number):*} mapFunc map function which may
	 *  return a promise or value
	 * @returns {Promise} promise that will fulfill with an array of mapped values
	 *  or reject if any input promise rejects.
	 */
	function map(promises, mapFunc) {
		return when(promises, function(promises) {
			return Promise.map(promises, mapFunc);
		});
	}

	/**
	 * Filter the provided array of promises using the provided predicate.  Input may
	 * contain promises and values
	 * @param {Array|Promise} promises array of promises and values
	 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
	 *  Must return truthy (or promise for truthy) for items to retain.
	 * @returns {Promise} promise that will fulfill with an array containing all items
	 *  for which predicate returned truthy.
	 */
	function filter(promises, predicate) {
		return when(promises, function(promises) {
			return Promise.filter(promises, predicate);
		});
	}

	return when;
});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./lib/Promise":271,"./lib/TimeoutError":273,"./lib/apply":274,"./lib/decorators/array":275,"./lib/decorators/flow":276,"./lib/decorators/fold":277,"./lib/decorators/inspect":278,"./lib/decorators/iterate":279,"./lib/decorators/progress":280,"./lib/decorators/timed":281,"./lib/decorators/unhandledRejection":282,"./lib/decorators/with":283}],289:[function(require,module,exports){
var nativeIsArray = Array.isArray
var toString = Object.prototype.toString

module.exports = nativeIsArray || isArray

function isArray(obj) {
    return toString.call(obj) === "[object Array]"
}

},{}],290:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var APIv3_1 = require("./api/APIv3");
exports.APIv3 = APIv3_1.APIv3;
var ModelCreator_1 = require("./api/ModelCreator");
exports.ModelCreator = ModelCreator_1.ModelCreator;

},{"./api/APIv3":303,"./api/ModelCreator":304}],291:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var Component_1 = require("./component/Component");
exports.Component = Component_1.Component;
var ComponentService_1 = require("./component/ComponentService");
exports.ComponentService = ComponentService_1.ComponentService;
var HandlerBase_1 = require("./component/utils/HandlerBase");
exports.HandlerBase = HandlerBase_1.HandlerBase;
var AttributionComponent_1 = require("./component/AttributionComponent");
exports.AttributionComponent = AttributionComponent_1.AttributionComponent;
var BackgroundComponent_1 = require("./component/BackgroundComponent");
exports.BackgroundComponent = BackgroundComponent_1.BackgroundComponent;
var BearingComponent_1 = require("./component/BearingComponent");
exports.BearingComponent = BearingComponent_1.BearingComponent;
var CacheComponent_1 = require("./component/CacheComponent");
exports.CacheComponent = CacheComponent_1.CacheComponent;
var CoverComponent_1 = require("./component/CoverComponent");
exports.CoverComponent = CoverComponent_1.CoverComponent;
var DebugComponent_1 = require("./component/DebugComponent");
exports.DebugComponent = DebugComponent_1.DebugComponent;
var DirectionComponent_1 = require("./component/direction/DirectionComponent");
exports.DirectionComponent = DirectionComponent_1.DirectionComponent;
var DirectionDOMCalculator_1 = require("./component/direction/DirectionDOMCalculator");
exports.DirectionDOMCalculator = DirectionDOMCalculator_1.DirectionDOMCalculator;
var DirectionDOMRenderer_1 = require("./component/direction/DirectionDOMRenderer");
exports.DirectionDOMRenderer = DirectionDOMRenderer_1.DirectionDOMRenderer;
var ImageComponent_1 = require("./component/ImageComponent");
exports.ImageComponent = ImageComponent_1.ImageComponent;
var KeyboardComponent_1 = require("./component/keyboard/KeyboardComponent");
exports.KeyboardComponent = KeyboardComponent_1.KeyboardComponent;
var KeyPlayHandler_1 = require("./component/keyboard/KeyPlayHandler");
exports.KeyPlayHandler = KeyPlayHandler_1.KeyPlayHandler;
var KeyZoomHandler_1 = require("./component/keyboard/KeyZoomHandler");
exports.KeyZoomHandler = KeyZoomHandler_1.KeyZoomHandler;
var KeySequenceNavigationHandler_1 = require("./component/keyboard/KeySequenceNavigationHandler");
exports.KeySequenceNavigationHandler = KeySequenceNavigationHandler_1.KeySequenceNavigationHandler;
var KeySpatialNavigationHandler_1 = require("./component/keyboard/KeySpatialNavigationHandler");
exports.KeySpatialNavigationHandler = KeySpatialNavigationHandler_1.KeySpatialNavigationHandler;
var LoadingComponent_1 = require("./component/LoadingComponent");
exports.LoadingComponent = LoadingComponent_1.LoadingComponent;
var Marker_1 = require("./component/marker/marker/Marker");
exports.Marker = Marker_1.Marker;
var MarkerComponent_1 = require("./component/marker/MarkerComponent");
exports.MarkerComponent = MarkerComponent_1.MarkerComponent;
var MarkerScene_1 = require("./component/marker/MarkerScene");
exports.MarkerScene = MarkerScene_1.MarkerScene;
var MarkerSet_1 = require("./component/marker/MarkerSet");
exports.MarkerSet = MarkerSet_1.MarkerSet;
var MouseComponent_1 = require("./component/mouse/MouseComponent");
exports.MouseComponent = MouseComponent_1.MouseComponent;
var BounceHandler_1 = require("./component/mouse/BounceHandler");
exports.BounceHandler = BounceHandler_1.BounceHandler;
var DragPanHandler_1 = require("./component/mouse/DragPanHandler");
exports.DragPanHandler = DragPanHandler_1.DragPanHandler;
var DoubleClickZoomHandler_1 = require("./component/mouse/DoubleClickZoomHandler");
exports.DoubleClickZoomHandler = DoubleClickZoomHandler_1.DoubleClickZoomHandler;
var ScrollZoomHandler_1 = require("./component/mouse/ScrollZoomHandler");
exports.ScrollZoomHandler = ScrollZoomHandler_1.ScrollZoomHandler;
var TouchZoomHandler_1 = require("./component/mouse/TouchZoomHandler");
exports.TouchZoomHandler = TouchZoomHandler_1.TouchZoomHandler;
var Popup_1 = require("./component/popup/popup/Popup");
exports.Popup = Popup_1.Popup;
var PopupComponent_1 = require("./component/popup/PopupComponent");
exports.PopupComponent = PopupComponent_1.PopupComponent;
var NavigationComponent_1 = require("./component/NavigationComponent");
exports.NavigationComponent = NavigationComponent_1.NavigationComponent;
var RouteComponent_1 = require("./component/RouteComponent");
exports.RouteComponent = RouteComponent_1.RouteComponent;
var SequenceComponent_1 = require("./component/sequence/SequenceComponent");
exports.SequenceComponent = SequenceComponent_1.SequenceComponent;
var SequenceDOMRenderer_1 = require("./component/sequence/SequenceDOMRenderer");
exports.SequenceDOMRenderer = SequenceDOMRenderer_1.SequenceDOMRenderer;
var SequenceMode_1 = require("./component/sequence/SequenceMode");
exports.SequenceMode = SequenceMode_1.SequenceMode;
var ImagePlaneComponent_1 = require("./component/imageplane/ImagePlaneComponent");
exports.ImagePlaneComponent = ImagePlaneComponent_1.ImagePlaneComponent;
var ImagePlaneFactory_1 = require("./component/imageplane/ImagePlaneFactory");
exports.ImagePlaneFactory = ImagePlaneFactory_1.ImagePlaneFactory;
var ImagePlaneGLRenderer_1 = require("./component/imageplane/ImagePlaneGLRenderer");
exports.ImagePlaneGLRenderer = ImagePlaneGLRenderer_1.ImagePlaneGLRenderer;
var ImagePlaneScene_1 = require("./component/imageplane/ImagePlaneScene");
exports.ImagePlaneScene = ImagePlaneScene_1.ImagePlaneScene;
var ImagePlaneShaders_1 = require("./component/imageplane/ImagePlaneShaders");
exports.ImagePlaneShaders = ImagePlaneShaders_1.ImagePlaneShaders;
var SimpleMarker_1 = require("./component/marker/marker/SimpleMarker");
exports.SimpleMarker = SimpleMarker_1.SimpleMarker;
var CircleMarker_1 = require("./component/marker/marker/CircleMarker");
exports.CircleMarker = CircleMarker_1.CircleMarker;
var SliderComponent_1 = require("./component/imageplane/SliderComponent");
exports.SliderComponent = SliderComponent_1.SliderComponent;
var StatsComponent_1 = require("./component/StatsComponent");
exports.StatsComponent = StatsComponent_1.StatsComponent;
var TagHandlerBase_1 = require("./component/tag/handlers/TagHandlerBase");
exports.TagHandlerBase = TagHandlerBase_1.TagHandlerBase;
var CreateHandlerBase_1 = require("./component/tag/handlers/CreateHandlerBase");
exports.CreateHandlerBase = CreateHandlerBase_1.CreateHandlerBase;
var CreatePointHandler_1 = require("./component/tag/handlers/CreatePointHandler");
exports.CreatePointHandler = CreatePointHandler_1.CreatePointHandler;
var CreateVertexHandler_1 = require("./component/tag/handlers/CreateVertexHandler");
exports.CreateVertexHandler = CreateVertexHandler_1.CreateVertexHandler;
var CreatePolygonHandler_1 = require("./component/tag/handlers/CreatePolygonHandler");
exports.CreatePolygonHandler = CreatePolygonHandler_1.CreatePolygonHandler;
var CreateRectHandler_1 = require("./component/tag/handlers/CreateRectHandler");
exports.CreateRectHandler = CreateRectHandler_1.CreateRectHandler;
var CreateRectDragHandler_1 = require("./component/tag/handlers/CreateRectDragHandler");
exports.CreateRectDragHandler = CreateRectDragHandler_1.CreateRectDragHandler;
var EditVertexHandler_1 = require("./component/tag/handlers/EditVertexHandler");
exports.EditVertexHandler = EditVertexHandler_1.EditVertexHandler;
var Tag_1 = require("./component/tag/tag/Tag");
exports.Tag = Tag_1.Tag;
var OutlineTag_1 = require("./component/tag/tag/OutlineTag");
exports.OutlineTag = OutlineTag_1.OutlineTag;
var RenderTag_1 = require("./component/tag/tag/RenderTag");
exports.RenderTag = RenderTag_1.RenderTag;
var OutlineRenderTag_1 = require("./component/tag/tag/OutlineRenderTag");
exports.OutlineRenderTag = OutlineRenderTag_1.OutlineRenderTag;
var OutlineCreateTag_1 = require("./component/tag/tag/OutlineCreateTag");
exports.OutlineCreateTag = OutlineCreateTag_1.OutlineCreateTag;
var SpotTag_1 = require("./component/tag/tag/SpotTag");
exports.SpotTag = SpotTag_1.SpotTag;
var SpotRenderTag_1 = require("./component/tag/tag/SpotRenderTag");
exports.SpotRenderTag = SpotRenderTag_1.SpotRenderTag;
var TagComponent_1 = require("./component/tag/TagComponent");
exports.TagComponent = TagComponent_1.TagComponent;
var TagCreator_1 = require("./component/tag/TagCreator");
exports.TagCreator = TagCreator_1.TagCreator;
var TagDOMRenderer_1 = require("./component/tag/TagDOMRenderer");
exports.TagDOMRenderer = TagDOMRenderer_1.TagDOMRenderer;
var TagMode_1 = require("./component/tag/TagMode");
exports.TagMode = TagMode_1.TagMode;
var TagOperation_1 = require("./component/tag/TagOperation");
exports.TagOperation = TagOperation_1.TagOperation;
var TagScene_1 = require("./component/tag/TagScene");
exports.TagScene = TagScene_1.TagScene;
var TagSet_1 = require("./component/tag/TagSet");
exports.TagSet = TagSet_1.TagSet;
var Geometry_1 = require("./component/tag/geometry/Geometry");
exports.Geometry = Geometry_1.Geometry;
var VertexGeometry_1 = require("./component/tag/geometry/VertexGeometry");
exports.VertexGeometry = VertexGeometry_1.VertexGeometry;
var RectGeometry_1 = require("./component/tag/geometry/RectGeometry");
exports.RectGeometry = RectGeometry_1.RectGeometry;
var PointGeometry_1 = require("./component/tag/geometry/PointGeometry");
exports.PointGeometry = PointGeometry_1.PointGeometry;
var PolygonGeometry_1 = require("./component/tag/geometry/PolygonGeometry");
exports.PolygonGeometry = PolygonGeometry_1.PolygonGeometry;
var GeometryTagError_1 = require("./component/tag/error/GeometryTagError");
exports.GeometryTagError = GeometryTagError_1.GeometryTagError;
__export(require("./component/interfaces/interfaces"));

},{"./component/AttributionComponent":305,"./component/BackgroundComponent":306,"./component/BearingComponent":307,"./component/CacheComponent":308,"./component/Component":309,"./component/ComponentService":310,"./component/CoverComponent":311,"./component/DebugComponent":312,"./component/ImageComponent":313,"./component/LoadingComponent":314,"./component/NavigationComponent":315,"./component/RouteComponent":316,"./component/StatsComponent":317,"./component/direction/DirectionComponent":318,"./component/direction/DirectionDOMCalculator":319,"./component/direction/DirectionDOMRenderer":320,"./component/imageplane/ImagePlaneComponent":321,"./component/imageplane/ImagePlaneFactory":322,"./component/imageplane/ImagePlaneGLRenderer":323,"./component/imageplane/ImagePlaneScene":324,"./component/imageplane/ImagePlaneShaders":325,"./component/imageplane/SliderComponent":326,"./component/interfaces/interfaces":328,"./component/keyboard/KeyPlayHandler":329,"./component/keyboard/KeySequenceNavigationHandler":330,"./component/keyboard/KeySpatialNavigationHandler":331,"./component/keyboard/KeyZoomHandler":332,"./component/keyboard/KeyboardComponent":333,"./component/marker/MarkerComponent":335,"./component/marker/MarkerScene":336,"./component/marker/MarkerSet":337,"./component/marker/marker/CircleMarker":338,"./component/marker/marker/Marker":339,"./component/marker/marker/SimpleMarker":340,"./component/mouse/BounceHandler":341,"./component/mouse/DoubleClickZoomHandler":342,"./component/mouse/DragPanHandler":343,"./component/mouse/MouseComponent":344,"./component/mouse/ScrollZoomHandler":345,"./component/mouse/TouchZoomHandler":346,"./component/popup/PopupComponent":348,"./component/popup/popup/Popup":349,"./component/sequence/SequenceComponent":350,"./component/sequence/SequenceDOMRenderer":351,"./component/sequence/SequenceMode":352,"./component/tag/TagComponent":354,"./component/tag/TagCreator":355,"./component/tag/TagDOMRenderer":356,"./component/tag/TagMode":357,"./component/tag/TagOperation":358,"./component/tag/TagScene":359,"./component/tag/TagSet":360,"./component/tag/error/GeometryTagError":361,"./component/tag/geometry/Geometry":362,"./component/tag/geometry/PointGeometry":363,"./component/tag/geometry/PolygonGeometry":364,"./component/tag/geometry/RectGeometry":365,"./component/tag/geometry/VertexGeometry":366,"./component/tag/handlers/CreateHandlerBase":367,"./component/tag/handlers/CreatePointHandler":368,"./component/tag/handlers/CreatePolygonHandler":369,"./component/tag/handlers/CreateRectDragHandler":370,"./component/tag/handlers/CreateRectHandler":371,"./component/tag/handlers/CreateVertexHandler":372,"./component/tag/handlers/EditVertexHandler":373,"./component/tag/handlers/TagHandlerBase":374,"./component/tag/tag/OutlineCreateTag":375,"./component/tag/tag/OutlineRenderTag":376,"./component/tag/tag/OutlineTag":377,"./component/tag/tag/RenderTag":378,"./component/tag/tag/SpotRenderTag":379,"./component/tag/tag/SpotTag":380,"./component/tag/tag/Tag":381,"./component/utils/HandlerBase":382}],292:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EdgeDirection_1 = require("./graph/edge/EdgeDirection");
exports.EdgeDirection = EdgeDirection_1.EdgeDirection;
var EdgeCalculatorSettings_1 = require("./graph/edge/EdgeCalculatorSettings");
exports.EdgeCalculatorSettings = EdgeCalculatorSettings_1.EdgeCalculatorSettings;
var EdgeCalculatorDirections_1 = require("./graph/edge/EdgeCalculatorDirections");
exports.EdgeCalculatorDirections = EdgeCalculatorDirections_1.EdgeCalculatorDirections;
var EdgeCalculatorCoefficients_1 = require("./graph/edge/EdgeCalculatorCoefficients");
exports.EdgeCalculatorCoefficients = EdgeCalculatorCoefficients_1.EdgeCalculatorCoefficients;
var EdgeCalculator_1 = require("./graph/edge/EdgeCalculator");
exports.EdgeCalculator = EdgeCalculator_1.EdgeCalculator;

},{"./graph/edge/EdgeCalculator":402,"./graph/edge/EdgeCalculatorCoefficients":403,"./graph/edge/EdgeCalculatorDirections":404,"./graph/edge/EdgeCalculatorSettings":405,"./graph/edge/EdgeDirection":406}],293:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AbortMapillaryError_1 = require("./error/AbortMapillaryError");
exports.AbortMapillaryError = AbortMapillaryError_1.AbortMapillaryError;
var ArgumentMapillaryError_1 = require("./error/ArgumentMapillaryError");
exports.ArgumentMapillaryError = ArgumentMapillaryError_1.ArgumentMapillaryError;
var GraphMapillaryError_1 = require("./error/GraphMapillaryError");
exports.GraphMapillaryError = GraphMapillaryError_1.GraphMapillaryError;
var MapillaryError_1 = require("./error/MapillaryError");
exports.MapillaryError = MapillaryError_1.MapillaryError;

},{"./error/AbortMapillaryError":383,"./error/ArgumentMapillaryError":384,"./error/GraphMapillaryError":385,"./error/MapillaryError":386}],294:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Camera_1 = require("./geo/Camera");
exports.Camera = Camera_1.Camera;
var GeoCoords_1 = require("./geo/GeoCoords");
exports.GeoCoords = GeoCoords_1.GeoCoords;
var ViewportCoords_1 = require("./geo/ViewportCoords");
exports.ViewportCoords = ViewportCoords_1.ViewportCoords;
var Spatial_1 = require("./geo/Spatial");
exports.Spatial = Spatial_1.Spatial;
var Transform_1 = require("./geo/Transform");
exports.Transform = Transform_1.Transform;

},{"./geo/Camera":387,"./geo/GeoCoords":388,"./geo/Spatial":389,"./geo/Transform":390,"./geo/ViewportCoords":391}],295:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FilterCreator_1 = require("./graph/FilterCreator");
exports.FilterCreator = FilterCreator_1.FilterCreator;
var Graph_1 = require("./graph/Graph");
exports.Graph = Graph_1.Graph;
var GraphCalculator_1 = require("./graph/GraphCalculator");
exports.GraphCalculator = GraphCalculator_1.GraphCalculator;
var GraphMode_1 = require("./graph/GraphMode");
exports.GraphMode = GraphMode_1.GraphMode;
var GraphService_1 = require("./graph/GraphService");
exports.GraphService = GraphService_1.GraphService;
var ImageLoadingService_1 = require("./graph/ImageLoadingService");
exports.ImageLoadingService = ImageLoadingService_1.ImageLoadingService;
var MeshReader_1 = require("./graph/MeshReader");
exports.MeshReader = MeshReader_1.MeshReader;
var Node_1 = require("./graph/Node");
exports.Node = Node_1.Node;
var NodeCache_1 = require("./graph/NodeCache");
exports.NodeCache = NodeCache_1.NodeCache;
var Sequence_1 = require("./graph/Sequence");
exports.Sequence = Sequence_1.Sequence;

},{"./graph/FilterCreator":392,"./graph/Graph":393,"./graph/GraphCalculator":394,"./graph/GraphMode":395,"./graph/GraphService":396,"./graph/ImageLoadingService":397,"./graph/MeshReader":398,"./graph/Node":399,"./graph/NodeCache":400,"./graph/Sequence":401}],296:[function(require,module,exports){
"use strict";
/**
 * MapillaryJS is a WebGL JavaScript library for exploring street level imagery
 * @name Mapillary
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./Support"));
var Edge_1 = require("./Edge");
exports.EdgeDirection = Edge_1.EdgeDirection;
var Render_1 = require("./Render");
exports.RenderMode = Render_1.RenderMode;
var State_1 = require("./State");
exports.TransitionMode = State_1.TransitionMode;
var Viewer_1 = require("./Viewer");
exports.Alignment = Viewer_1.Alignment;
exports.ImageSize = Viewer_1.ImageSize;
exports.Viewer = Viewer_1.Viewer;
var TagComponent = require("./component/tag/Tag");
exports.TagComponent = TagComponent;
var MarkerComponent = require("./component/marker/Marker");
exports.MarkerComponent = MarkerComponent;
var PopupComponent = require("./component/popup/Popup");
exports.PopupComponent = PopupComponent;

},{"./Edge":292,"./Render":297,"./State":298,"./Support":299,"./Viewer":302,"./component/marker/Marker":334,"./component/popup/Popup":347,"./component/tag/Tag":353}],297:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DOMRenderer_1 = require("./render/DOMRenderer");
exports.DOMRenderer = DOMRenderer_1.DOMRenderer;
var GLRenderer_1 = require("./render/GLRenderer");
exports.GLRenderer = GLRenderer_1.GLRenderer;
var GLRenderStage_1 = require("./render/GLRenderStage");
exports.GLRenderStage = GLRenderStage_1.GLRenderStage;
var RenderCamera_1 = require("./render/RenderCamera");
exports.RenderCamera = RenderCamera_1.RenderCamera;
var RenderMode_1 = require("./render/RenderMode");
exports.RenderMode = RenderMode_1.RenderMode;
var RenderService_1 = require("./render/RenderService");
exports.RenderService = RenderService_1.RenderService;

},{"./render/DOMRenderer":407,"./render/GLRenderStage":408,"./render/GLRenderer":409,"./render/RenderCamera":410,"./render/RenderMode":411,"./render/RenderService":412}],298:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var State_1 = require("./state/State");
exports.State = State_1.State;
var StateBase_1 = require("./state/states/StateBase");
exports.StateBase = StateBase_1.StateBase;
var StateContext_1 = require("./state/StateContext");
exports.StateContext = StateContext_1.StateContext;
var StateService_1 = require("./state/StateService");
exports.StateService = StateService_1.StateService;
var TransitionMode_1 = require("./state/TransitionMode");
exports.TransitionMode = TransitionMode_1.TransitionMode;
var TraversingState_1 = require("./state/states/TraversingState");
exports.TraversingState = TraversingState_1.TraversingState;
var WaitingState_1 = require("./state/states/WaitingState");
exports.WaitingState = WaitingState_1.WaitingState;

},{"./state/State":413,"./state/StateContext":414,"./state/StateService":415,"./state/TransitionMode":416,"./state/states/StateBase":417,"./state/states/TraversingState":418,"./state/states/WaitingState":419}],299:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var support = require("./utils/Support");
/**
 * Test whether the current browser supports the full
 * functionality of MapillaryJS.
 *
 * @description The full functionality includes WebGL rendering.
 *
 * @return {boolean}
 *
 * @example `var supported = Mapillary.isSupported();`
 */
function isSupported() {
    return isFallbackSupported() &&
        support.isWebGLSupportedCached();
}
exports.isSupported = isSupported;
/**
 * Test whether the current browser supports the fallback
 * functionality of MapillaryJS.
 *
 * @description The fallback functionality does not include WebGL
 * rendering, only 2D canvas rendering.
 *
 * @return {boolean}
 *
 * @example `var fallbackSupported = Mapillary.isFallbackSupported();`
 */
function isFallbackSupported() {
    return support.isBrowser() &&
        support.isArraySupported() &&
        support.isFunctionSupported() &&
        support.isJSONSupported() &&
        support.isObjectSupported();
}
exports.isFallbackSupported = isFallbackSupported;

},{"./utils/Support":427}],300:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ImageTileLoader_1 = require("./tiles/ImageTileLoader");
exports.ImageTileLoader = ImageTileLoader_1.ImageTileLoader;
var ImageTileStore_1 = require("./tiles/ImageTileStore");
exports.ImageTileStore = ImageTileStore_1.ImageTileStore;
var TextureProvider_1 = require("./tiles/TextureProvider");
exports.TextureProvider = TextureProvider_1.TextureProvider;
var RegionOfInterestCalculator_1 = require("./tiles/RegionOfInterestCalculator");
exports.RegionOfInterestCalculator = RegionOfInterestCalculator_1.RegionOfInterestCalculator;

},{"./tiles/ImageTileLoader":420,"./tiles/ImageTileStore":421,"./tiles/RegionOfInterestCalculator":422,"./tiles/TextureProvider":423}],301:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var DOM_1 = require("./utils/DOM");
exports.DOM = DOM_1.DOM;
var EventEmitter_1 = require("./utils/EventEmitter");
exports.EventEmitter = EventEmitter_1.EventEmitter;
var Settings_1 = require("./utils/Settings");
exports.Settings = Settings_1.Settings;
__export(require("./utils/Support"));
var Urls_1 = require("./utils/Urls");
exports.Urls = Urls_1.Urls;

},{"./utils/DOM":424,"./utils/EventEmitter":425,"./utils/Settings":426,"./utils/Support":427,"./utils/Urls":428}],302:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Alignment_1 = require("./viewer/Alignment");
exports.Alignment = Alignment_1.Alignment;
var CacheService_1 = require("./viewer/CacheService");
exports.CacheService = CacheService_1.CacheService;
var ComponentController_1 = require("./viewer/ComponentController");
exports.ComponentController = ComponentController_1.ComponentController;
var Container_1 = require("./viewer/Container");
exports.Container = Container_1.Container;
var Observer_1 = require("./viewer/Observer");
exports.Observer = Observer_1.Observer;
var ImageSize_1 = require("./viewer/ImageSize");
exports.ImageSize = ImageSize_1.ImageSize;
var KeyboardService_1 = require("./viewer/KeyboardService");
exports.KeyboardService = KeyboardService_1.KeyboardService;
var LoadingService_1 = require("./viewer/LoadingService");
exports.LoadingService = LoadingService_1.LoadingService;
var MouseService_1 = require("./viewer/MouseService");
exports.MouseService = MouseService_1.MouseService;
var Navigator_1 = require("./viewer/Navigator");
exports.Navigator = Navigator_1.Navigator;
var PlayService_1 = require("./viewer/PlayService");
exports.PlayService = PlayService_1.PlayService;
var Projection_1 = require("./viewer/Projection");
exports.Projection = Projection_1.Projection;
var SpriteService_1 = require("./viewer/SpriteService");
exports.SpriteService = SpriteService_1.SpriteService;
var TouchService_1 = require("./viewer/TouchService");
exports.TouchService = TouchService_1.TouchService;
var Viewer_1 = require("./viewer/Viewer");
exports.Viewer = Viewer_1.Viewer;

},{"./viewer/Alignment":429,"./viewer/CacheService":430,"./viewer/ComponentController":431,"./viewer/Container":432,"./viewer/ImageSize":433,"./viewer/KeyboardService":434,"./viewer/LoadingService":435,"./viewer/MouseService":436,"./viewer/Navigator":437,"./viewer/Observer":438,"./viewer/PlayService":439,"./viewer/Projection":440,"./viewer/SpriteService":441,"./viewer/TouchService":442,"./viewer/Viewer":443}],303:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
require("rxjs/add/observable/defer");
require("rxjs/add/observable/fromPromise");
require("rxjs/add/operator/catch");
require("rxjs/add/operator/map");
var API_1 = require("../API");
/**
 * @class APIv3
 *
 * @classdesc Provides methods for access of API v3.
 */
var APIv3 = /** @class */ (function () {
    /**
     * Create a new api v3 instance.
     *
     * @param {number} clientId - Client id for API requests.
     * @param {number} [token] - Optional bearer token for API requests of
     * protected resources.
     * @param {ModelCreator} [creator] - Optional model creator instance.
     */
    function APIv3(clientId, token, creator) {
        this._clientId = clientId;
        this._modelCreator = creator != null ? creator : new API_1.ModelCreator();
        this._model = this._modelCreator.createModel(clientId, token);
        this._pageCount = 999;
        this._pathImageByKey = "imageByKey";
        this._pathImageCloseTo = "imageCloseTo";
        this._pathImagesByH = "imagesByH";
        this._pathImageViewAdd = "imageViewAdd";
        this._pathSequenceByKey = "sequenceByKey";
        this._pathSequenceViewAdd = "sequenceViewAdd";
        this._propertiesCore = [
            "cl",
            "l",
            "sequence_key",
        ];
        this._propertiesFill = [
            "captured_at",
            "captured_with_camera_uuid",
            "user",
            "organization_key",
            "private",
            "project",
        ];
        this._propertiesKey = [
            "key",
        ];
        this._propertiesSequence = [
            "keys",
        ];
        this._propertiesSpatial = [
            "atomic_scale",
            "ca",
            "calt",
            "cca",
            "cfocal",
            "gpano",
            "height",
            "merge_cc",
            "merge_version",
            "c_rotation",
            "orientation",
            "width",
        ];
        this._propertiesUser = [
            "username",
        ];
    }
    APIv3.prototype.imageByKeyFill$ = function (keys) {
        return this._catchInvalidateGet$(this._wrapPromise$(this._model.get([
            this._pathImageByKey,
            keys,
            this._propertiesKey
                .concat(this._propertiesFill)
                .concat(this._propertiesSpatial),
            this._propertiesKey
                .concat(this._propertiesUser)
        ]))
            .map(function (value) {
            if (!value) {
                throw new Error("Images (" + keys.join(", ") + ") could not be found.");
            }
            return value.json.imageByKey;
        }), this._pathImageByKey, keys);
    };
    APIv3.prototype.imageByKeyFull$ = function (keys) {
        return this._catchInvalidateGet$(this._wrapPromise$(this._model.get([
            this._pathImageByKey,
            keys,
            this._propertiesKey
                .concat(this._propertiesCore)
                .concat(this._propertiesFill)
                .concat(this._propertiesSpatial),
            this._propertiesKey
                .concat(this._propertiesUser)
        ]))
            .map(function (value) {
            if (!value) {
                throw new Error("Images (" + keys.join(", ") + ") could not be found.");
            }
            return value.json.imageByKey;
        }), this._pathImageByKey, keys);
    };
    APIv3.prototype.imageCloseTo$ = function (lat, lon) {
        var lonLat = lon + ":" + lat;
        return this._catchInvalidateGet$(this._wrapPromise$(this._model.get([
            this._pathImageCloseTo,
            [lonLat],
            this._propertiesKey
                .concat(this._propertiesCore)
                .concat(this._propertiesFill)
                .concat(this._propertiesSpatial),
            this._propertiesKey
                .concat(this._propertiesUser)
        ]))
            .map(function (value) {
            return value != null ? value.json.imageCloseTo[lonLat] : null;
        }), this._pathImageCloseTo, [lonLat]);
    };
    APIv3.prototype.imagesByH$ = function (hs) {
        var _this = this;
        return this._catchInvalidateGet$(this._wrapPromise$(this._model.get([
            this._pathImagesByH,
            hs,
            { from: 0, to: this._pageCount },
            this._propertiesKey
                .concat(this._propertiesCore)
        ]))
            .map(function (value) {
            if (!value) {
                value = { json: { imagesByH: {} } };
                for (var _i = 0, hs_1 = hs; _i < hs_1.length; _i++) {
                    var h = hs_1[_i];
                    value.json.imagesByH[h] = {};
                    for (var i = 0; i <= _this._pageCount; i++) {
                        value.json.imagesByH[h][i] = null;
                    }
                }
            }
            return value.json.imagesByH;
        }), this._pathImagesByH, hs);
    };
    APIv3.prototype.imageViewAdd$ = function (keys) {
        return this._catchInvalidateCall$(this._wrapPromise$(this._model.call([this._pathImageViewAdd], [keys])), this._pathImageViewAdd, keys);
    };
    APIv3.prototype.invalidateImageByKey = function (keys) {
        this._invalidateGet(this._pathImageByKey, keys);
    };
    APIv3.prototype.invalidateImagesByH = function (hs) {
        this._invalidateGet(this._pathImagesByH, hs);
    };
    APIv3.prototype.invalidateSequenceByKey = function (sKeys) {
        this._invalidateGet(this._pathSequenceByKey, sKeys);
    };
    APIv3.prototype.setToken = function (token) {
        this._model.invalidate([]);
        this._model = null;
        this._model = this._modelCreator.createModel(this._clientId, token);
    };
    APIv3.prototype.sequenceByKey$ = function (sequenceKeys) {
        return this._catchInvalidateGet$(this._wrapPromise$(this._model.get([
            this._pathSequenceByKey,
            sequenceKeys,
            this._propertiesKey
                .concat(this._propertiesSequence)
        ]))
            .map(function (value) {
            if (!value) {
                value = { json: { sequenceByKey: {} } };
            }
            for (var _i = 0, sequenceKeys_1 = sequenceKeys; _i < sequenceKeys_1.length; _i++) {
                var sequenceKey = sequenceKeys_1[_i];
                if (!(sequenceKey in value.json.sequenceByKey)) {
                    console.warn("Sequence data missing (" + sequenceKey + ")");
                    value.json.sequenceByKey[sequenceKey] = { key: sequenceKey, keys: [] };
                }
            }
            return value.json.sequenceByKey;
        }), this._pathSequenceByKey, sequenceKeys);
    };
    APIv3.prototype.sequenceViewAdd$ = function (sequenceKeys) {
        return this._catchInvalidateCall$(this._wrapPromise$(this._model.call([this._pathSequenceViewAdd], [sequenceKeys])), this._pathSequenceViewAdd, sequenceKeys);
    };
    Object.defineProperty(APIv3.prototype, "clientId", {
        get: function () {
            return this._clientId;
        },
        enumerable: true,
        configurable: true
    });
    APIv3.prototype._catchInvalidateGet$ = function (observable, path, paths) {
        var _this = this;
        return observable
            .catch(function (error) {
            _this._invalidateGet(path, paths);
            throw error;
        });
    };
    APIv3.prototype._catchInvalidateCall$ = function (observable, path, paths) {
        var _this = this;
        return observable
            .catch(function (error) {
            _this._invalidateCall(path, paths);
            throw error;
        });
    };
    APIv3.prototype._invalidateGet = function (path, paths) {
        this._model.invalidate([path, paths]);
    };
    APIv3.prototype._invalidateCall = function (path, paths) {
        this._model.invalidate([path], [paths]);
    };
    APIv3.prototype._wrapPromise$ = function (promise) {
        return Observable_1.Observable.defer(function () { return Observable_1.Observable.fromPromise(promise); });
    };
    return APIv3;
}());
exports.APIv3 = APIv3;
exports.default = APIv3;

},{"../API":290,"rxjs/Observable":29,"rxjs/add/observable/defer":40,"rxjs/add/observable/fromPromise":44,"rxjs/add/operator/catch":54,"rxjs/add/operator/map":67}],304:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var falcor = require("falcor");
var HttpDataSource = require("falcor-http-datasource");
var Utils_1 = require("../Utils");
/**
 * @class ModelCreator
 *
 * @classdesc Creates API models.
 */
var ModelCreator = /** @class */ (function () {
    function ModelCreator() {
    }
    /**
     * Creates a Falcor model.
     *
     * @description Max cache size will be set to 16 MB. Authorization
     * header will be added if bearer token is supplied.
     *
     * @param {number} clientId - Client id for API requests.
     * @param {number} [token] - Optional bearer token for API requests of
     * protected resources.
     * @returns {falcor.Model} Falcor model for HTTP requests.
     */
    ModelCreator.prototype.createModel = function (clientId, token) {
        var configuration = {
            crossDomain: true,
            withCredentials: false,
        };
        if (token != null) {
            configuration.headers = { "Authorization": "Bearer " + token };
        }
        return new falcor.Model({
            maxSize: 16 * 1024 * 1024,
            source: new HttpDataSource(Utils_1.Urls.falcorModel(clientId), configuration),
        });
    };
    return ModelCreator;
}());
exports.ModelCreator = ModelCreator;
exports.default = ModelCreator;

},{"../Utils":301,"falcor":15,"falcor-http-datasource":10}],305:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var vd = require("virtual-dom");
var Component_1 = require("../Component");
var Utils_1 = require("../Utils");
var AttributionComponent = /** @class */ (function (_super) {
    __extends(AttributionComponent, _super);
    function AttributionComponent(name, container, navigator) {
        return _super.call(this, name, container, navigator) || this;
    }
    AttributionComponent.prototype._activate = function () {
        var _this = this;
        this._disposable = this._navigator.stateService.currentNode$
            .map(function (node) {
            return { name: _this._name, vnode: _this._getAttributionNode(node.username, node.key) };
        })
            .subscribe(this._container.domRenderer.render$);
    };
    AttributionComponent.prototype._deactivate = function () {
        this._disposable.unsubscribe();
    };
    AttributionComponent.prototype._getDefaultConfiguration = function () {
        return {};
    };
    AttributionComponent.prototype._getAttributionNode = function (username, key) {
        return vd.h("div.Attribution", {}, [
            vd.h("a", { href: Utils_1.Urls.exporeUser(username),
                target: "_blank",
                textContent: "@" + username,
            }, []),
            vd.h("span", { textContent: "|" }, []),
            vd.h("a", { href: Utils_1.Urls.exporeImage(key),
                target: "_blank",
                textContent: "mapillary.com",
            }, []),
        ]);
    };
    AttributionComponent.componentName = "attribution";
    return AttributionComponent;
}(Component_1.Component));
exports.AttributionComponent = AttributionComponent;
Component_1.ComponentService.register(AttributionComponent);
exports.default = AttributionComponent;

},{"../Component":291,"../Utils":301,"virtual-dom":247}],306:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var vd = require("virtual-dom");
var Component_1 = require("../Component");
var BackgroundComponent = /** @class */ (function (_super) {
    __extends(BackgroundComponent, _super);
    function BackgroundComponent(name, container, navigator) {
        return _super.call(this, name, container, navigator) || this;
    }
    BackgroundComponent.prototype._activate = function () {
        this._container.domRenderer.render$
            .next({ name: this._name, vnode: this._getBackgroundNode("The viewer can't display the given image.") });
    };
    BackgroundComponent.prototype._deactivate = function () {
        return;
    };
    BackgroundComponent.prototype._getDefaultConfiguration = function () {
        return {};
    };
    BackgroundComponent.prototype._getBackgroundNode = function (notice) {
        // todo: add condition for when to display the DOM node
        return vd.h("div.BackgroundWrapper", {}, [
            vd.h("p", { textContent: notice }, []),
        ]);
    };
    BackgroundComponent.componentName = "background";
    return BackgroundComponent;
}(Component_1.Component));
exports.BackgroundComponent = BackgroundComponent;
Component_1.ComponentService.register(BackgroundComponent);
exports.default = BackgroundComponent;

},{"../Component":291,"virtual-dom":247}],307:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var vd = require("virtual-dom");
var Observable_1 = require("rxjs/Observable");
var Component_1 = require("../Component");
var Geo_1 = require("../Geo");
var BearingComponent = /** @class */ (function (_super) {
    __extends(BearingComponent, _super);
    function BearingComponent(name, container, navigator) {
        var _this = _super.call(this, name, container, navigator) || this;
        _this._spatial = new Geo_1.Spatial();
        _this._svgNamespace = "http://www.w3.org/2000/svg";
        _this._distinctThreshold = Math.PI / 90;
        return _this;
    }
    BearingComponent.prototype._activate = function () {
        var _this = this;
        var nodeBearingFov$ = this._navigator.stateService.currentState$
            .distinctUntilChanged(undefined, function (frame) {
            return frame.state.currentNode.key;
        })
            .map(function (frame) {
            var node = frame.state.currentNode;
            var transform = frame.state.currentTransform;
            if (node.pano) {
                var panoHFov = 2 * Math.PI * node.gpano.CroppedAreaImageWidthPixels / node.gpano.FullPanoWidthPixels;
                return [_this._spatial.degToRad(node.ca), panoHFov];
            }
            var size = Math.max(transform.basicWidth, transform.basicHeight);
            if (size <= 0) {
                console.warn("Original image size (" + transform.basicWidth + ", " + transform.basicHeight + ") is invalid (" + node.key + ". " +
                    "Not showing available fov.");
            }
            var hFov = size > 0 ?
                2 * Math.atan(0.5 * transform.basicWidth / (size * transform.focal)) :
                0;
            return [_this._spatial.degToRad(node.ca), hFov];
        })
            .distinctUntilChanged(function (a1, a2) {
            return Math.abs(a2[0] - a1[0]) < _this._distinctThreshold &&
                Math.abs(a2[1] - a1[1]) < _this._distinctThreshold;
        });
        var cameraBearingFov$ = this._container.renderService.renderCamera$
            .map(function (rc) {
            var vFov = _this._spatial.degToRad(rc.perspective.fov);
            var hFov = rc.perspective.aspect === Number.POSITIVE_INFINITY ?
                Math.PI :
                Math.atan(rc.perspective.aspect * Math.tan(0.5 * vFov)) * 2;
            return [_this._spatial.azimuthalToBearing(rc.rotation.phi), hFov];
        })
            .distinctUntilChanged(function (a1, a2) {
            return Math.abs(a2[0] - a1[0]) < _this._distinctThreshold &&
                Math.abs(a2[1] - a1[1]) < _this._distinctThreshold;
        });
        this._renderSubscription = Observable_1.Observable
            .combineLatest(nodeBearingFov$, cameraBearingFov$)
            .map(function (args) {
            var background = vd.h("div.BearingIndicatorBackground", { oncontextmenu: function (event) { event.preventDefault(); } }, [
                vd.h("div.BearingIndicatorBackgroundRectangle", {}, []),
                vd.h("div.BearingIndicatorBackgroundCircle", {}, []),
            ]);
            var north = vd.h("div.BearingIndicatorNorth", {}, []);
            var nodeSector = _this._createCircleSector(args[0][0], args[0][1], "#000");
            var cameraSector = _this._createCircleSector(args[1][0], args[1][1], "#fff");
            var compass = _this._createCircleSectorCompass(nodeSector, cameraSector);
            return {
                name: _this._name,
                vnode: vd.h("div.BearingIndicator", {}, [
                    background,
                    north,
                    compass,
                ]),
            };
        })
            .subscribe(this._container.domRenderer.render$);
    };
    BearingComponent.prototype._deactivate = function () {
        this._renderSubscription.unsubscribe();
    };
    BearingComponent.prototype._getDefaultConfiguration = function () {
        return {};
    };
    BearingComponent.prototype._createCircleSectorCompass = function (nodeSector, cameraSector) {
        var group = vd.h("g", {
            attributes: { transform: "translate(1,1)" },
            namespace: this._svgNamespace,
        }, [nodeSector, cameraSector]);
        var centerCircle = vd.h("circle", {
            attributes: {
                cx: "1",
                cy: "1",
                fill: "#abb1b9",
                r: "0.291667",
                stroke: "#000",
                "stroke-width": "0.0833333",
            },
            namespace: this._svgNamespace,
        }, []);
        var svg = vd.h("svg", {
            attributes: { viewBox: "0 0 2 2" },
            namespace: this._svgNamespace,
            style: {
                bottom: "4px",
                height: "48px",
                left: "4px",
                position: "absolute",
                width: "48px",
            },
        }, [group, centerCircle]);
        return svg;
    };
    BearingComponent.prototype._createCircleSector = function (bearing, fov, fill) {
        if (fov > 2 * Math.PI - Math.PI / 90) {
            return vd.h("circle", {
                attributes: { cx: "0", cy: "0", fill: fill, r: "1" },
                namespace: this._svgNamespace,
            }, []);
        }
        var arcStart = bearing - fov / 2 - Math.PI / 2;
        var arcEnd = arcStart + fov;
        var startX = Math.cos(arcStart);
        var startY = Math.sin(arcStart);
        var endX = Math.cos(arcEnd);
        var endY = Math.sin(arcEnd);
        var largeArc = fov >= Math.PI ? 1 : 0;
        var description = "M 0 0 " + startX + " " + startY + " A 1 1 0 " + largeArc + " 1 " + endX + " " + endY;
        return vd.h("path", {
            attributes: { d: description, fill: fill },
            namespace: this._svgNamespace,
        }, []);
    };
    BearingComponent.componentName = "bearing";
    return BearingComponent;
}(Component_1.Component));
exports.BearingComponent = BearingComponent;
Component_1.ComponentService.register(BearingComponent);
exports.default = BearingComponent;

},{"../Component":291,"../Geo":294,"rxjs/Observable":29,"virtual-dom":247}],308:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
require("rxjs/add/observable/combineLatest");
require("rxjs/add/observable/from");
require("rxjs/add/observable/merge");
require("rxjs/add/observable/of");
require("rxjs/add/observable/zip");
require("rxjs/add/operator/catch");
require("rxjs/add/operator/combineLatest");
require("rxjs/add/operator/distinct");
require("rxjs/add/operator/expand");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/map");
require("rxjs/add/operator/merge");
require("rxjs/add/operator/mergeMap");
require("rxjs/add/operator/mergeAll");
require("rxjs/add/operator/skip");
require("rxjs/add/operator/switchMap");
var Edge_1 = require("../Edge");
var Component_1 = require("../Component");
var CacheComponent = /** @class */ (function (_super) {
    __extends(CacheComponent, _super);
    function CacheComponent(name, container, navigator) {
        return _super.call(this, name, container, navigator) || this;
    }
    /**
     * Set the cache depth.
     *
     * Configures the cache depth. The cache depth can be different for
     * different edge direction types.
     *
     * @param {ICacheDepth} depth - Cache depth structure.
     */
    CacheComponent.prototype.setDepth = function (depth) {
        this.configure({ depth: depth });
    };
    CacheComponent.prototype._activate = function () {
        var _this = this;
        this._sequenceSubscription = Observable_1.Observable
            .combineLatest(this._navigator.stateService.currentNode$
            .switchMap(function (node) {
            return node.sequenceEdges$;
        })
            .filter(function (status) {
            return status.cached;
        }), this._configuration$)
            .switchMap(function (nc) {
            var status = nc[0];
            var configuration = nc[1];
            var sequenceDepth = Math.max(0, Math.min(4, configuration.depth.sequence));
            var next$ = _this._cache$(status.edges, Edge_1.EdgeDirection.Next, sequenceDepth);
            var prev$ = _this._cache$(status.edges, Edge_1.EdgeDirection.Prev, sequenceDepth);
            return Observable_1.Observable
                .merge(next$, prev$)
                .catch(function (error, caught) {
                console.error("Failed to cache sequence edges.", error);
                return Observable_1.Observable.empty();
            });
        })
            .subscribe(function () { });
        this._spatialSubscription = this._navigator.stateService.currentNode$
            .switchMap(function (node) {
            return Observable_1.Observable
                .combineLatest(Observable_1.Observable.of(node), node.spatialEdges$
                .filter(function (status) {
                return status.cached;
            }));
        })
            .combineLatest(this._configuration$, function (ns, configuration) {
            return [ns[0], ns[1], configuration];
        })
            .switchMap(function (args) {
            var node = args[0];
            var edges = args[1].edges;
            var depth = args[2].depth;
            var panoDepth = Math.max(0, Math.min(2, depth.pano));
            var stepDepth = node.pano ? 0 : Math.max(0, Math.min(3, depth.step));
            var turnDepth = node.pano ? 0 : Math.max(0, Math.min(1, depth.turn));
            var pano$ = _this._cache$(edges, Edge_1.EdgeDirection.Pano, panoDepth);
            var forward$ = _this._cache$(edges, Edge_1.EdgeDirection.StepForward, stepDepth);
            var backward$ = _this._cache$(edges, Edge_1.EdgeDirection.StepBackward, stepDepth);
            var left$ = _this._cache$(edges, Edge_1.EdgeDirection.StepLeft, stepDepth);
            var right$ = _this._cache$(edges, Edge_1.EdgeDirection.StepRight, stepDepth);
            var turnLeft$ = _this._cache$(edges, Edge_1.EdgeDirection.TurnLeft, turnDepth);
            var turnRight$ = _this._cache$(edges, Edge_1.EdgeDirection.TurnRight, turnDepth);
            var turnU$ = _this._cache$(edges, Edge_1.EdgeDirection.TurnU, turnDepth);
            return Observable_1.Observable
                .merge(forward$, backward$, left$, right$, pano$, turnLeft$, turnRight$, turnU$)
                .catch(function (error, caught) {
                console.error("Failed to cache spatial edges.", error);
                return Observable_1.Observable.empty();
            });
        })
            .subscribe(function () { });
    };
    CacheComponent.prototype._deactivate = function () {
        this._sequenceSubscription.unsubscribe();
        this._spatialSubscription.unsubscribe();
    };
    CacheComponent.prototype._getDefaultConfiguration = function () {
        return { depth: { pano: 1, sequence: 2, step: 1, turn: 0 } };
    };
    CacheComponent.prototype._cache$ = function (edges, direction, depth) {
        var _this = this;
        return Observable_1.Observable
            .zip(Observable_1.Observable.of(edges), Observable_1.Observable.of(depth))
            .expand(function (ed) {
            var es = ed[0];
            var d = ed[1];
            var edgesDepths$ = [];
            if (d > 0) {
                for (var _i = 0, es_1 = es; _i < es_1.length; _i++) {
                    var edge = es_1[_i];
                    if (edge.data.direction === direction) {
                        edgesDepths$.push(Observable_1.Observable
                            .zip(_this._navigator.graphService.cacheNode$(edge.to)
                            .mergeMap(function (n) {
                            return _this._nodeToEdges$(n, direction);
                        }), Observable_1.Observable.of(d - 1)));
                    }
                }
            }
            return Observable_1.Observable
                .from(edgesDepths$)
                .mergeAll();
        })
            .skip(1);
    };
    CacheComponent.prototype._nodeToEdges$ = function (node, direction) {
        return ([Edge_1.EdgeDirection.Next, Edge_1.EdgeDirection.Prev].indexOf(direction) > -1 ?
            node.sequenceEdges$ :
            node.spatialEdges$)
            .first(function (status) {
            return status.cached;
        })
            .map(function (status) {
            return status.edges;
        });
    };
    CacheComponent.componentName = "cache";
    return CacheComponent;
}(Component_1.Component));
exports.CacheComponent = CacheComponent;
Component_1.ComponentService.register(CacheComponent);
exports.default = CacheComponent;

},{"../Component":291,"../Edge":292,"rxjs/Observable":29,"rxjs/add/observable/combineLatest":38,"rxjs/add/observable/from":42,"rxjs/add/observable/merge":45,"rxjs/add/observable/of":46,"rxjs/add/observable/zip":49,"rxjs/add/operator/catch":54,"rxjs/add/operator/combineLatest":55,"rxjs/add/operator/distinct":59,"rxjs/add/operator/expand":62,"rxjs/add/operator/filter":63,"rxjs/add/operator/map":67,"rxjs/add/operator/merge":68,"rxjs/add/operator/mergeAll":69,"rxjs/add/operator/mergeMap":70,"rxjs/add/operator/skip":80,"rxjs/add/operator/switchMap":84}],309:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BehaviorSubject_1 = require("rxjs/BehaviorSubject");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/operator/publishReplay");
require("rxjs/add/operator/scan");
require("rxjs/add/operator/startWith");
var Utils_1 = require("../Utils");
var Component = /** @class */ (function (_super) {
    __extends(Component, _super);
    function Component(name, container, navigator) {
        var _this = _super.call(this) || this;
        _this._activated$ = new BehaviorSubject_1.BehaviorSubject(false);
        _this._configurationSubject$ = new Subject_1.Subject();
        _this._activated = false;
        _this._container = container;
        _this._name = name;
        _this._navigator = navigator;
        _this._configuration$ =
            _this._configurationSubject$
                .startWith(_this.defaultConfiguration)
                .scan(function (conf, newConf) {
                for (var key in newConf) {
                    if (newConf.hasOwnProperty(key)) {
                        conf[key] = newConf[key];
                    }
                }
                return conf;
            })
                .publishReplay(1)
                .refCount();
        _this._configuration$.subscribe(function () { });
        return _this;
    }
    Object.defineProperty(Component.prototype, "activated", {
        get: function () {
            return this._activated;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "activated$", {
        get: function () {
            return this._activated$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "defaultConfiguration", {
        /**
         * Get default configuration.
         *
         * @returns {TConfiguration} Default configuration for component.
         */
        get: function () {
            return this._getDefaultConfiguration();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "configuration$", {
        get: function () {
            return this._configuration$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Component.prototype.activate = function (conf) {
        if (this._activated) {
            return;
        }
        if (conf !== undefined) {
            this._configurationSubject$.next(conf);
        }
        this._activated = true;
        this._activate();
        this._activated$.next(true);
    };
    Component.prototype.configure = function (conf) {
        this._configurationSubject$.next(conf);
    };
    Component.prototype.deactivate = function () {
        if (!this._activated) {
            return;
        }
        this._activated = false;
        this._deactivate();
        this._container.domRenderer.clear(this._name);
        this._container.glRenderer.clear(this._name);
        this._activated$.next(false);
    };
    /**
     * Detect the viewer's new width and height and resize the component's
     * rendered elements accordingly if applicable.
     */
    Component.prototype.resize = function () { return; };
    /**
     * Component name. Used when interacting with component through the Viewer's API.
     */
    Component.componentName = "not_worthy";
    return Component;
}(Utils_1.EventEmitter));
exports.Component = Component;
exports.default = Component;

},{"../Utils":301,"rxjs/BehaviorSubject":26,"rxjs/Subject":34,"rxjs/add/operator/publishReplay":74,"rxjs/add/operator/scan":78,"rxjs/add/operator/startWith":83}],310:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("underscore");
var Error_1 = require("../Error");
var ComponentService = /** @class */ (function () {
    function ComponentService(container, navigator) {
        this._components = {};
        for (var _i = 0, _a = _.values(ComponentService.registeredComponents); _i < _a.length; _i++) {
            var component = _a[_i];
            this._components[component.componentName] = {
                active: false,
                component: new component(component.componentName, container, navigator),
            };
        }
        this._coverComponent = new ComponentService.registeredCoverComponent("cover", container, navigator);
        this._coverComponent.activate();
        this._coverActivated = true;
    }
    ComponentService.register = function (component) {
        if (ComponentService.registeredComponents[component.componentName] === undefined) {
            ComponentService.registeredComponents[component.componentName] = component;
        }
    };
    ComponentService.registerCover = function (coverComponent) {
        ComponentService.registeredCoverComponent = coverComponent;
    };
    Object.defineProperty(ComponentService.prototype, "coverActivated", {
        get: function () {
            return this._coverActivated;
        },
        enumerable: true,
        configurable: true
    });
    ComponentService.prototype.activateCover = function () {
        if (this._coverActivated) {
            return;
        }
        this._coverActivated = true;
        for (var _i = 0, _a = _.values(this._components); _i < _a.length; _i++) {
            var component = _a[_i];
            if (component.active) {
                component.component.deactivate();
            }
        }
        return;
    };
    ComponentService.prototype.deactivateCover = function () {
        if (!this._coverActivated) {
            return;
        }
        this._coverActivated = false;
        for (var _i = 0, _a = _.values(this._components); _i < _a.length; _i++) {
            var component = _a[_i];
            if (component.active) {
                component.component.activate();
            }
        }
        return;
    };
    ComponentService.prototype.activate = function (name) {
        this._checkName(name);
        this._components[name].active = true;
        if (!this._coverActivated) {
            this.get(name).activate();
        }
    };
    ComponentService.prototype.configure = function (name, conf) {
        this._checkName(name);
        this.get(name).configure(conf);
    };
    ComponentService.prototype.deactivate = function (name) {
        this._checkName(name);
        this._components[name].active = false;
        if (!this._coverActivated) {
            this.get(name).deactivate();
        }
    };
    ComponentService.prototype.resize = function () {
        for (var _i = 0, _a = _.values(this._components); _i < _a.length; _i++) {
            var component = _a[_i];
            component.component.resize();
        }
    };
    ComponentService.prototype.get = function (name) {
        return this._components[name].component;
    };
    ComponentService.prototype.getCover = function () {
        return this._coverComponent;
    };
    ComponentService.prototype._checkName = function (name) {
        if (!(name in this._components)) {
            throw new Error_1.ArgumentMapillaryError("Component does not exist: " + name);
        }
    };
    ComponentService.registeredComponents = {};
    return ComponentService;
}());
exports.ComponentService = ComponentService;
exports.default = ComponentService;

},{"../Error":293,"underscore":243}],311:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var vd = require("virtual-dom");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/map");
require("rxjs/add/operator/withLatestFrom");
var Component_1 = require("../Component");
var Utils_1 = require("../Utils");
var Viewer_1 = require("../Viewer");
var CoverComponent = /** @class */ (function (_super) {
    __extends(CoverComponent, _super);
    function CoverComponent(name, container, navigator) {
        return _super.call(this, name, container, navigator) || this;
    }
    CoverComponent.prototype._activate = function () {
        var _this = this;
        this._keyDisposable = this._navigator.stateService.currentNode$
            .withLatestFrom(this._configuration$, function (node, configuration) {
            return [node, configuration];
        })
            .filter(function (_a) {
            var node = _a[0], configuration = _a[1];
            return node.key !== configuration.key;
        })
            .map(function (_a) {
            var node = _a[0], configuration = _a[1];
            return node;
        })
            .map(function (node) {
            return { key: node.key, src: node.image.src };
        })
            .subscribe(this._configurationSubject$);
        this._disposable = this._configuration$
            .map(function (conf) {
            if (!conf.key) {
                return { name: _this._name, vnode: vd.h("div", []) };
            }
            if (conf.state === Component_1.CoverState.Hidden) {
                return { name: _this._name, vnode: vd.h("div.Cover.CoverDone", [_this._getCoverBackgroundVNode(conf)]) };
            }
            return { name: _this._name, vnode: _this._getCoverButtonVNode(conf) };
        })
            .subscribe(this._container.domRenderer.render$);
    };
    CoverComponent.prototype._deactivate = function () {
        this._disposable.unsubscribe();
        this._keyDisposable.unsubscribe();
    };
    CoverComponent.prototype._getDefaultConfiguration = function () {
        return { state: Component_1.CoverState.Visible };
    };
    CoverComponent.prototype._getCoverButtonVNode = function (conf) {
        var _this = this;
        var cover = conf.state === Component_1.CoverState.Loading ? "div.Cover.CoverLoading" : "div.Cover";
        return vd.h(cover, [
            this._getCoverBackgroundVNode(conf),
            vd.h("button.CoverButton", { onclick: function () { _this.configure({ state: Component_1.CoverState.Loading }); } }, ["Explore"]),
            vd.h("a.CoverLogo", { href: Utils_1.Urls.explore, target: "_blank" }, []),
        ]);
    };
    CoverComponent.prototype._getCoverBackgroundVNode = function (conf) {
        var url = conf.src != null ?
            conf.src : Utils_1.Urls.thumbnail(conf.key, Viewer_1.ImageSize.Size640);
        var properties = { style: { backgroundImage: "url(" + url + ")" } };
        var children = [];
        if (conf.state === Component_1.CoverState.Loading) {
            children.push(vd.h("div.Spinner", {}, []));
        }
        children.push(vd.h("div.CoverBackgroundGradient", {}, []));
        return vd.h("div.CoverBackground", properties, children);
    };
    CoverComponent.componentName = "cover";
    return CoverComponent;
}(Component_1.Component));
exports.CoverComponent = CoverComponent;
Component_1.ComponentService.registerCover(CoverComponent);
exports.default = CoverComponent;

},{"../Component":291,"../Utils":301,"../Viewer":302,"rxjs/add/operator/filter":63,"rxjs/add/operator/map":67,"rxjs/add/operator/withLatestFrom":90,"virtual-dom":247}],312:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("underscore");
var vd = require("virtual-dom");
var BehaviorSubject_1 = require("rxjs/BehaviorSubject");
require("rxjs/add/operator/combineLatest");
var Component_1 = require("../Component");
var DebugComponent = /** @class */ (function (_super) {
    __extends(DebugComponent, _super);
    function DebugComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._open$ = new BehaviorSubject_1.BehaviorSubject(false);
        return _this;
    }
    DebugComponent.prototype._activate = function () {
        var _this = this;
        this._disposable = this._navigator.stateService.currentState$
            .combineLatest(this._open$, this._navigator.imageLoadingService.loadstatus$, function (frame, open, loadStatus) {
            return { name: _this._name, vnode: _this._getDebugVNode(open, _this._getDebugInfo(frame, loadStatus)) };
        })
            .subscribe(this._container.domRenderer.render$);
    };
    DebugComponent.prototype._deactivate = function () {
        this._disposable.unsubscribe();
    };
    DebugComponent.prototype._getDefaultConfiguration = function () {
        return {};
    };
    DebugComponent.prototype._getDebugInfo = function (frame, loadStatus) {
        var ret = [];
        ret.push(vd.h("h2", "Node"));
        if (frame.state.currentNode) {
            ret.push(vd.h("p", "currentNode: " + frame.state.currentNode.key));
        }
        if (frame.state.previousNode) {
            ret.push(vd.h("p", "previousNode: " + frame.state.previousNode.key));
        }
        ret.push(vd.h("h2", "Loading"));
        var total = 0;
        var loaded = 0;
        var loading = 0;
        for (var _i = 0, _a = _.values(loadStatus); _i < _a.length; _i++) {
            var loadStat = _a[_i];
            total += loadStat.loaded;
            if (loadStat.loaded !== loadStat.total) {
                loading++;
            }
            else {
                loaded++;
            }
        }
        ret.push(vd.h("p", "Loaded Images: " + loaded));
        ret.push(vd.h("p", "Loading Images: " + loading));
        ret.push(vd.h("p", "Total bytes loaded: " + total));
        ret.push(vd.h("h2", "Camera"));
        ret.push(vd.h("p", "camera.position.x: " + frame.state.camera.position.x));
        ret.push(vd.h("p", "camera.position.y: " + frame.state.camera.position.y));
        ret.push(vd.h("p", "camera.position.z: " + frame.state.camera.position.z));
        ret.push(vd.h("p", "camera.lookat.x: " + frame.state.camera.lookat.x));
        ret.push(vd.h("p", "camera.lookat.y: " + frame.state.camera.lookat.y));
        ret.push(vd.h("p", "camera.lookat.z: " + frame.state.camera.lookat.z));
        ret.push(vd.h("p", "camera.up.x: " + frame.state.camera.up.x));
        ret.push(vd.h("p", "camera.up.y: " + frame.state.camera.up.y));
        ret.push(vd.h("p", "camera.up.z: " + frame.state.camera.up.z));
        return ret;
    };
    DebugComponent.prototype._getDebugVNode = function (open, info) {
        if (open) {
            return vd.h("div.Debug", {}, [
                vd.h("h2", {}, ["Debug"]),
                this._getDebugVNodeButton(open),
                vd.h("pre", {}, info),
            ]);
        }
        else {
            return this._getDebugVNodeButton(open);
        }
    };
    DebugComponent.prototype._getDebugVNodeButton = function (open) {
        var buttonText = open ? "Disable Debug" : "D";
        var buttonCssClass = open ? "" : ".DebugButtonFixed";
        if (open) {
            return vd.h("button.DebugButton" + buttonCssClass, { onclick: this._closeDebugElement.bind(this) }, [buttonText]);
        }
        else {
            return vd.h("button.DebugButton" + buttonCssClass, { onclick: this._openDebugElement.bind(this) }, [buttonText]);
        }
    };
    DebugComponent.prototype._closeDebugElement = function (open) {
        this._open$.next(false);
    };
    DebugComponent.prototype._openDebugElement = function () {
        this._open$.next(true);
    };
    DebugComponent.componentName = "debug";
    return DebugComponent;
}(Component_1.Component));
exports.DebugComponent = DebugComponent;
Component_1.ComponentService.register(DebugComponent);
exports.default = DebugComponent;

},{"../Component":291,"rxjs/BehaviorSubject":26,"rxjs/add/operator/combineLatest":55,"underscore":243,"virtual-dom":247}],313:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var vd = require("virtual-dom");
var Observable_1 = require("rxjs/Observable");
require("rxjs/add/operator/combineLatest");
var Component_1 = require("../Component");
var Utils_1 = require("../Utils");
var ImageComponent = /** @class */ (function (_super) {
    __extends(ImageComponent, _super);
    function ImageComponent(name, container, navigator, dom) {
        var _this = _super.call(this, name, container, navigator) || this;
        _this._canvasId = container.id + "-" + _this._name;
        _this._dom = !!dom ? dom : new Utils_1.DOM();
        return _this;
    }
    ImageComponent.prototype._activate = function () {
        var _this = this;
        var canvasSize$ = this._container.domRenderer.element$
            .map(function (element) {
            return _this._dom.document.getElementById(_this._canvasId);
        })
            .filter(function (canvas) {
            return !!canvas;
        })
            .map(function (canvas) {
            var adaptableDomRenderer = canvas.parentElement;
            var width = adaptableDomRenderer.offsetWidth;
            var height = adaptableDomRenderer.offsetHeight;
            return [canvas, { height: height, width: width }];
        })
            .distinctUntilChanged(function (s1, s2) {
            return s1.height === s2.height && s1.width === s2.width;
        }, function (_a) {
            var canvas = _a[0], size = _a[1];
            return size;
        });
        this.drawSubscription = Observable_1.Observable
            .combineLatest(canvasSize$, this._navigator.stateService.currentNode$)
            .subscribe(function (_a) {
            var _b = _a[0], canvas = _b[0], size = _b[1], node = _a[1];
            canvas.width = size.width;
            canvas.height = size.height;
            canvas
                .getContext("2d")
                .drawImage(node.image, 0, 0, size.width, size.height);
        });
        this._container.domRenderer.renderAdaptive$.next({ name: this._name, vnode: vd.h("canvas#" + this._canvasId, []) });
    };
    ImageComponent.prototype._deactivate = function () {
        this.drawSubscription.unsubscribe();
    };
    ImageComponent.prototype._getDefaultConfiguration = function () {
        return {};
    };
    ImageComponent.componentName = "image";
    return ImageComponent;
}(Component_1.Component));
exports.ImageComponent = ImageComponent;
Component_1.ComponentService.register(ImageComponent);
exports.default = ImageComponent;

},{"../Component":291,"../Utils":301,"rxjs/Observable":29,"rxjs/add/operator/combineLatest":55,"virtual-dom":247}],314:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("underscore");
var vd = require("virtual-dom");
var Observable_1 = require("rxjs/Observable");
require("rxjs/add/operator/combineLatest");
var Component_1 = require("../Component");
var LoadingComponent = /** @class */ (function (_super) {
    __extends(LoadingComponent, _super);
    function LoadingComponent(name, container, navigator) {
        return _super.call(this, name, container, navigator) || this;
    }
    LoadingComponent.prototype._activate = function () {
        var _this = this;
        this._loadingSubscription = this._navigator.loadingService.loading$
            .switchMap(function (loading) {
            return loading ?
                _this._navigator.imageLoadingService.loadstatus$ :
                Observable_1.Observable.of({});
        })
            .map(function (loadStatus) {
            var total = 0;
            var loaded = 0;
            for (var _i = 0, _a = _.values(loadStatus); _i < _a.length; _i++) {
                var loadStat = _a[_i];
                if (loadStat.loaded !== loadStat.total) {
                    loaded += loadStat.loaded;
                    total += loadStat.total;
                }
            }
            var percentage = 100;
            if (total !== 0) {
                percentage = (loaded / total) * 100;
            }
            return { name: _this._name, vnode: _this._getBarVNode(percentage) };
        })
            .subscribe(this._container.domRenderer.render$);
    };
    LoadingComponent.prototype._deactivate = function () {
        this._loadingSubscription.unsubscribe();
    };
    LoadingComponent.prototype._getDefaultConfiguration = function () {
        return {};
    };
    LoadingComponent.prototype._getBarVNode = function (percentage) {
        var loadingBarStyle = {};
        var loadingContainerStyle = {};
        if (percentage !== 100) {
            loadingBarStyle.width = percentage.toFixed(0) + "%";
            loadingBarStyle.opacity = "1";
        }
        else {
            loadingBarStyle.width = "100%";
            loadingBarStyle.opacity = "0";
        }
        return vd.h("div.Loading", { style: loadingContainerStyle }, [vd.h("div.LoadingBar", { style: loadingBarStyle }, [])]);
    };
    LoadingComponent.componentName = "loading";
    return LoadingComponent;
}(Component_1.Component));
exports.LoadingComponent = LoadingComponent;
Component_1.ComponentService.register(LoadingComponent);
exports.default = LoadingComponent;

},{"../Component":291,"rxjs/Observable":29,"rxjs/add/operator/combineLatest":55,"underscore":243,"virtual-dom":247}],315:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var vd = require("virtual-dom");
var Observable_1 = require("rxjs/Observable");
require("rxjs/add/operator/map");
require("rxjs/add/operator/first");
var Edge_1 = require("../Edge");
var Error_1 = require("../Error");
var Component_1 = require("../Component");
/**
 * @class NavigationComponent
 *
 * @classdesc Fallback navigation component for environments without WebGL support.
 *
 * Replaces the functionality in the Direction and Sequence components.
 */
var NavigationComponent = /** @class */ (function (_super) {
    __extends(NavigationComponent, _super);
    function NavigationComponent(name, container, navigator) {
        var _this = _super.call(this, name, container, navigator) || this;
        _this._seqNames = {};
        _this._seqNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.Prev]] = "Prev";
        _this._seqNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.Next]] = "Next";
        _this._spaTopNames = {};
        _this._spaTopNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.TurnLeft]] = "Turnleft";
        _this._spaTopNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.StepLeft]] = "Left";
        _this._spaTopNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.StepForward]] = "Forward";
        _this._spaTopNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.StepRight]] = "Right";
        _this._spaTopNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.TurnRight]] = "Turnright";
        _this._spaBottomNames = {};
        _this._spaBottomNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.TurnU]] = "Turnaround";
        _this._spaBottomNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.StepBackward]] = "Backward";
        return _this;
    }
    NavigationComponent.prototype._activate = function () {
        var _this = this;
        this._renderSubscription = Observable_1.Observable
            .combineLatest(this._navigator.stateService.currentNode$, this._configuration$)
            .switchMap(function (_a) {
            var node = _a[0], configuration = _a[1];
            var sequenceEdges$ = configuration.sequence ?
                node.sequenceEdges$
                    .map(function (status) {
                    return status.edges
                        .map(function (edge) {
                        return edge.data.direction;
                    });
                }) :
                Observable_1.Observable.of([]);
            var spatialEdges$ = !node.pano && configuration.spatial ?
                node.spatialEdges$
                    .map(function (status) {
                    return status.edges
                        .map(function (edge) {
                        return edge.data.direction;
                    });
                }) :
                Observable_1.Observable.of([]);
            return Observable_1.Observable
                .combineLatest(sequenceEdges$, spatialEdges$)
                .map(function (_a) {
                var seq = _a[0], spa = _a[1];
                return seq.concat(spa);
            });
        })
            .map(function (edgeDirections) {
            var seqs = _this._createArrowRow(_this._seqNames, edgeDirections);
            var spaTops = _this._createArrowRow(_this._spaTopNames, edgeDirections);
            var spaBottoms = _this._createArrowRow(_this._spaBottomNames, edgeDirections);
            var seqContainer = vd.h("div.NavigationSequence", seqs);
            var spaTopContainer = vd.h("div.NavigationSpatialTop", spaTops);
            var spaBottomContainer = vd.h("div.NavigationSpatialBottom", spaBottoms);
            var spaContainer = vd.h("div.NavigationSpatial", [spaTopContainer, spaBottomContainer]);
            return { name: _this._name, vnode: vd.h("div.NavigationContainer", [seqContainer, spaContainer]) };
        })
            .subscribe(this._container.domRenderer.render$);
    };
    NavigationComponent.prototype._deactivate = function () {
        this._renderSubscription.unsubscribe();
    };
    NavigationComponent.prototype._getDefaultConfiguration = function () {
        return { sequence: true, spatial: true };
    };
    NavigationComponent.prototype._createArrowRow = function (arrowNames, edgeDirections) {
        var arrows = [];
        for (var arrowName in arrowNames) {
            if (!(arrowNames.hasOwnProperty(arrowName))) {
                continue;
            }
            var direction = Edge_1.EdgeDirection[arrowName];
            if (edgeDirections.indexOf(direction) !== -1) {
                arrows.push(this._createVNode(direction, arrowNames[arrowName], "visible"));
            }
            else {
                arrows.push(this._createVNode(direction, arrowNames[arrowName], "hidden"));
            }
        }
        return arrows;
    };
    NavigationComponent.prototype._createVNode = function (direction, name, visibility) {
        var _this = this;
        return vd.h("span.Direction.Direction" + name, {
            onclick: function (ev) {
                _this._navigator.moveDir$(direction)
                    .subscribe(undefined, function (error) {
                    if (!(error instanceof Error_1.AbortMapillaryError)) {
                        console.error(error);
                    }
                });
            },
            style: {
                visibility: visibility,
            },
        }, []);
    };
    NavigationComponent.componentName = "navigation";
    return NavigationComponent;
}(Component_1.Component));
exports.NavigationComponent = NavigationComponent;
Component_1.ComponentService.register(NavigationComponent);
exports.default = NavigationComponent;

},{"../Component":291,"../Edge":292,"../Error":293,"rxjs/Observable":29,"rxjs/add/operator/first":65,"rxjs/add/operator/map":67,"virtual-dom":247}],316:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("underscore");
var vd = require("virtual-dom");
var Observable_1 = require("rxjs/Observable");
require("rxjs/add/observable/fromPromise");
require("rxjs/add/observable/of");
require("rxjs/add/operator/combineLatest");
require("rxjs/add/operator/distinct");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/map");
require("rxjs/add/operator/mergeMap");
require("rxjs/add/operator/pluck");
require("rxjs/add/operator/scan");
var Component_1 = require("../Component");
var DescriptionState = /** @class */ (function () {
    function DescriptionState() {
    }
    return DescriptionState;
}());
var RouteState = /** @class */ (function () {
    function RouteState() {
    }
    return RouteState;
}());
var RouteTrack = /** @class */ (function () {
    function RouteTrack() {
        this.nodeInstructions = [];
        this.nodeInstructionsOrdered = [];
    }
    return RouteTrack;
}());
var RouteComponent = /** @class */ (function (_super) {
    __extends(RouteComponent, _super);
    function RouteComponent(name, container, navigator) {
        return _super.call(this, name, container, navigator) || this;
    }
    RouteComponent.prototype._activate = function () {
        var _this = this;
        var _slowedStream$;
        _slowedStream$ = this._navigator.stateService.currentState$.filter(function (frame) {
            return (frame.id % 2) === 0;
        }).filter(function (frame) {
            return frame.state.nodesAhead < 15;
        }).distinctUntilChanged(undefined, function (frame) {
            return frame.state.lastNode.key;
        });
        var _routeTrack$;
        _routeTrack$ = this.configuration$.mergeMap(function (conf) {
            return Observable_1.Observable.from(conf.paths);
        }).distinct(function (p) {
            return p.sequenceKey;
        }).mergeMap(function (path) {
            return _this._navigator.apiV3.sequenceByKey$([path.sequenceKey])
                .map(function (sequenceByKey) {
                return sequenceByKey[path.sequenceKey];
            });
        }).combineLatest(this.configuration$, function (sequence, conf) {
            var i = 0;
            var instructionPlaces = [];
            for (var _i = 0, _a = conf.paths; _i < _a.length; _i++) {
                var path = _a[_i];
                if (path.sequenceKey === sequence.key) {
                    var nodeInstructions = [];
                    var saveKey = false;
                    for (var _b = 0, _c = sequence.keys; _b < _c.length; _b++) {
                        var key = _c[_b];
                        if (path.startKey === key) {
                            saveKey = true;
                        }
                        if (saveKey) {
                            var description = null;
                            for (var _d = 0, _e = path.infoKeys; _d < _e.length; _d++) {
                                var infoKey = _e[_d];
                                if (infoKey.key === key) {
                                    description = infoKey.description;
                                }
                            }
                            nodeInstructions.push({ description: description, key: key });
                        }
                        if (path.stopKey === key) {
                            saveKey = false;
                        }
                    }
                    instructionPlaces.push({ nodeInstructions: nodeInstructions, place: i });
                }
                i++;
            }
            return instructionPlaces;
        }).scan(function (routeTrack, instructionPlaces) {
            for (var _i = 0, instructionPlaces_1 = instructionPlaces; _i < instructionPlaces_1.length; _i++) {
                var instructionPlace = instructionPlaces_1[_i];
                routeTrack.nodeInstructionsOrdered[instructionPlace.place] = instructionPlace.nodeInstructions;
            }
            routeTrack.nodeInstructions = _.flatten(routeTrack.nodeInstructionsOrdered);
            return routeTrack;
        }, new RouteTrack());
        this._disposable = _slowedStream$
            .combineLatest(_routeTrack$, this.configuration$, function (frame, routeTrack, conf) {
            return { conf: conf, frame: frame, routeTrack: routeTrack };
        }).scan(function (routeState, rtAndFrame) {
            if (rtAndFrame.conf.playing === undefined || rtAndFrame.conf.playing) {
                routeState.routeTrack = rtAndFrame.routeTrack;
                routeState.currentNode = rtAndFrame.frame.state.currentNode;
                routeState.lastNode = rtAndFrame.frame.state.lastNode;
                routeState.playing = true;
            }
            else {
                _this._navigator.stateService.cutNodes();
                routeState.playing = false;
            }
            return routeState;
        }, new RouteState())
            .filter(function (routeState) {
            return routeState.playing;
        }).filter(function (routeState) {
            for (var _i = 0, _a = routeState.routeTrack.nodeInstructions; _i < _a.length; _i++) {
                var nodeInstruction = _a[_i];
                if (!nodeInstruction) {
                    continue;
                }
                if (nodeInstruction.key === routeState.lastNode.key) {
                    return true;
                }
            }
            return false;
        }).distinctUntilChanged(undefined, function (routeState) {
            return routeState.lastNode.key;
        }).mergeMap(function (routeState) {
            var i = 0;
            for (var _i = 0, _a = routeState.routeTrack.nodeInstructions; _i < _a.length; _i++) {
                var nodeInstruction = _a[_i];
                if (nodeInstruction.key === routeState.lastNode.key) {
                    break;
                }
                i++;
            }
            var nextInstruction = routeState.routeTrack.nodeInstructions[i + 1];
            if (!nextInstruction) {
                return Observable_1.Observable.of(null);
            }
            return _this._navigator.graphService.cacheNode$(nextInstruction.key);
        }).combineLatest(this.configuration$, function (node, conf) {
            return { conf: conf, node: node };
        }).filter(function (cAN) {
            return cAN.node !== null && cAN.conf.playing;
        }).pluck("node").subscribe(this._navigator.stateService.appendNode$);
        this._disposableDescription = this._navigator.stateService.currentNode$
            .combineLatest(_routeTrack$, this.configuration$, function (node, routeTrack, conf) {
            if (conf.playing !== undefined && !conf.playing) {
                return "quit";
            }
            var description = null;
            for (var _i = 0, _a = routeTrack.nodeInstructions; _i < _a.length; _i++) {
                var nodeInstruction = _a[_i];
                if (nodeInstruction.key === node.key) {
                    description = nodeInstruction.description;
                    break;
                }
            }
            return description;
        }).scan(function (descriptionState, description) {
            if (description !== descriptionState.description && description !== null) {
                descriptionState.description = description;
                descriptionState.showsLeft = 6;
            }
            else {
                descriptionState.showsLeft--;
            }
            if (description === "quit") {
                descriptionState.description = null;
            }
            return descriptionState;
        }, new DescriptionState()).map(function (descriptionState) {
            if (descriptionState.showsLeft > 0 && descriptionState.description) {
                return { name: _this._name, vnode: _this._getRouteAnnotationNode(descriptionState.description) };
            }
            else {
                return { name: _this._name, vnode: vd.h("div", []) };
            }
        }).subscribe(this._container.domRenderer.render$);
    };
    RouteComponent.prototype._deactivate = function () {
        this._disposable.unsubscribe();
        this._disposableDescription.unsubscribe();
    };
    RouteComponent.prototype._getDefaultConfiguration = function () {
        return {};
    };
    RouteComponent.prototype.play = function () {
        this.configure({ playing: true });
    };
    RouteComponent.prototype.stop = function () {
        this.configure({ playing: false });
    };
    RouteComponent.prototype._getRouteAnnotationNode = function (description) {
        return vd.h("div.RouteFrame", {}, [
            vd.h("p", { textContent: description }, []),
        ]);
    };
    RouteComponent.componentName = "route";
    return RouteComponent;
}(Component_1.Component));
exports.RouteComponent = RouteComponent;
Component_1.ComponentService.register(RouteComponent);
exports.default = RouteComponent;

},{"../Component":291,"rxjs/Observable":29,"rxjs/add/observable/fromPromise":44,"rxjs/add/observable/of":46,"rxjs/add/operator/combineLatest":55,"rxjs/add/operator/distinct":59,"rxjs/add/operator/distinctUntilChanged":60,"rxjs/add/operator/filter":63,"rxjs/add/operator/map":67,"rxjs/add/operator/mergeMap":70,"rxjs/add/operator/pluck":72,"rxjs/add/operator/scan":78,"underscore":243,"virtual-dom":247}],317:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
require("rxjs/add/operator/buffer");
require("rxjs/add/operator/debounceTime");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/map");
require("rxjs/add/operator/scan");
var Component_1 = require("../Component");
var StatsComponent = /** @class */ (function (_super) {
    __extends(StatsComponent, _super);
    function StatsComponent(name, container, navigator) {
        return _super.call(this, name, container, navigator) || this;
    }
    StatsComponent.prototype._activate = function () {
        var _this = this;
        this._sequenceSubscription = this._navigator.stateService.currentNode$
            .scan(function (keys, node) {
            var sKey = node.sequenceKey;
            keys.report = [];
            if (!(sKey in keys.reported)) {
                keys.report = [sKey];
                keys.reported[sKey] = true;
            }
            return keys;
        }, { report: [], reported: {} })
            .filter(function (keys) {
            return keys.report.length > 0;
        })
            .mergeMap(function (keys) {
            return _this._navigator.apiV3.sequenceViewAdd$(keys.report)
                .catch(function (error, caught) {
                console.error("Failed to report sequence stats (" + keys.report + ")", error);
                return Observable_1.Observable.empty();
            });
        })
            .subscribe(function () { });
        this._imageSubscription = this._navigator.stateService.currentNode$
            .map(function (node) {
            return node.key;
        })
            .buffer(this._navigator.stateService.currentNode$.debounceTime(5000))
            .scan(function (keys, newKeys) {
            keys.report = [];
            for (var _i = 0, newKeys_1 = newKeys; _i < newKeys_1.length; _i++) {
                var key = newKeys_1[_i];
                if (!(key in keys.reported)) {
                    keys.report.push(key);
                    keys.reported[key] = true;
                }
            }
            return keys;
        }, { report: [], reported: {} })
            .filter(function (keys) {
            return keys.report.length > 0;
        })
            .mergeMap(function (keys) {
            return _this._navigator.apiV3.imageViewAdd$(keys.report)
                .catch(function (error, caught) {
                console.error("Failed to report image stats (" + keys.report + ")", error);
                return Observable_1.Observable.empty();
            });
        })
            .subscribe(function () { });
    };
    StatsComponent.prototype._deactivate = function () {
        this._sequenceSubscription.unsubscribe();
        this._imageSubscription.unsubscribe();
    };
    StatsComponent.prototype._getDefaultConfiguration = function () {
        return {};
    };
    StatsComponent.componentName = "stats";
    return StatsComponent;
}(Component_1.Component));
exports.StatsComponent = StatsComponent;
Component_1.ComponentService.register(StatsComponent);
exports.default = StatsComponent;

},{"../Component":291,"rxjs/Observable":29,"rxjs/add/operator/buffer":51,"rxjs/add/operator/debounceTime":57,"rxjs/add/operator/filter":63,"rxjs/add/operator/map":67,"rxjs/add/operator/scan":78}],318:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var vd = require("virtual-dom");
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/observable/combineLatest");
require("rxjs/add/operator/do");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/map");
require("rxjs/add/operator/share");
var Component_1 = require("../../Component");
/**
 * @class DirectionComponent
 * @classdesc Component showing navigation arrows for steps and turns.
 */
var DirectionComponent = /** @class */ (function (_super) {
    __extends(DirectionComponent, _super);
    function DirectionComponent(name, container, navigator, directionDOMRenderer) {
        var _this = _super.call(this, name, container, navigator) || this;
        _this._renderer = !!directionDOMRenderer ?
            directionDOMRenderer :
            new Component_1.DirectionDOMRenderer(_this.defaultConfiguration, container.element);
        _this._hoveredKeySubject$ = new Subject_1.Subject();
        _this._hoveredKey$ = _this._hoveredKeySubject$.share();
        return _this;
    }
    Object.defineProperty(DirectionComponent.prototype, "hoveredKey$", {
        /**
         * Get hovered key observable.
         *
         * @description An observable emitting the key of the node for the direction
         * arrow that is being hovered. When the mouse leaves a direction arrow null
         * is emitted.
         *
         * @returns {Observable<string>}
         */
        get: function () {
            return this._hoveredKey$;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set highlight key.
     *
     * @description The arrow pointing towards the node corresponding to the
     * highlight key will be highlighted.
     *
     * @param {string} highlightKey Key of node to be highlighted if existing
     * among arrows.
     */
    DirectionComponent.prototype.setHighlightKey = function (highlightKey) {
        this.configure({ highlightKey: highlightKey });
    };
    /**
     * Set min width of container element.
     *
     * @description  Set min width of the non transformed container element holding
     * the navigation arrows. If the min width is larger than the max width the
     * min width value will be used.
     *
     * The container element is automatically resized when the resize
     * method on the Viewer class is called.
     *
     * @param {number} minWidth
     */
    DirectionComponent.prototype.setMinWidth = function (minWidth) {
        this.configure({ minWidth: minWidth });
    };
    /**
     * Set max width of container element.
     *
     * @description Set max width of the non transformed container element holding
     * the navigation arrows. If the min width is larger than the max width the
     * min width value will be used.
     *
     * The container element is automatically resized when the resize
     * method on the Viewer class is called.
     *
     * @param {number} minWidth
     */
    DirectionComponent.prototype.setMaxWidth = function (maxWidth) {
        this.configure({ maxWidth: maxWidth });
    };
    /** @inheritdoc */
    DirectionComponent.prototype.resize = function () {
        this._renderer.resize(this._container.element);
    };
    DirectionComponent.prototype._activate = function () {
        var _this = this;
        this._configurationSubscription = this._configuration$
            .subscribe(function (configuration) {
            _this._renderer.setConfiguration(configuration);
        });
        this._nodeSubscription = this._navigator.stateService.currentNode$
            .do(function (node) {
            _this._container.domRenderer.render$.next({ name: _this._name, vnode: vd.h("div", {}, []) });
            _this._renderer.setNode(node);
        })
            .withLatestFrom(this._configuration$)
            .switchMap(function (_a) {
            var node = _a[0], configuration = _a[1];
            return Observable_1.Observable
                .combineLatest(node.spatialEdges$, configuration.distinguishSequence ?
                _this._navigator.graphService
                    .cacheSequence$(node.sequenceKey)
                    .catch(function (error, caught) {
                    console.error("Failed to cache sequence (" + node.sequenceKey + ")", error);
                    return Observable_1.Observable.of(null);
                }) :
                Observable_1.Observable.of(null));
        })
            .subscribe(function (_a) {
            var edgeStatus = _a[0], sequence = _a[1];
            _this._renderer.setEdges(edgeStatus, sequence);
        });
        this._renderCameraSubscription = this._container.renderService.renderCameraFrame$
            .do(function (renderCamera) {
            _this._renderer.setRenderCamera(renderCamera);
        })
            .map(function (renderCamera) {
            return _this._renderer;
        })
            .filter(function (renderer) {
            return renderer.needsRender;
        })
            .map(function (renderer) {
            return { name: _this._name, vnode: renderer.render(_this._navigator) };
        })
            .subscribe(this._container.domRenderer.render$);
        this._hoveredKeySubscription = Observable_1.Observable
            .combineLatest([
            this._container.domRenderer.element$,
            this._container.renderService.renderCamera$,
            this._container.mouseService.mouseMove$.startWith(null),
            this._container.mouseService.mouseUp$.startWith(null),
        ], function (e, rc, mm, mu) {
            return e;
        })
            .map(function (element) {
            var elements = element.getElementsByClassName("DirectionsPerspective");
            for (var i = 0; i < elements.length; i++) {
                var hovered = elements.item(i).querySelector(":hover");
                if (hovered != null && hovered.hasAttribute("data-key")) {
                    return hovered.getAttribute("data-key");
                }
            }
            return null;
        })
            .distinctUntilChanged()
            .subscribe(this._hoveredKeySubject$);
    };
    DirectionComponent.prototype._deactivate = function () {
        this._configurationSubscription.unsubscribe();
        this._nodeSubscription.unsubscribe();
        this._renderCameraSubscription.unsubscribe();
        this._hoveredKeySubscription.unsubscribe();
    };
    DirectionComponent.prototype._getDefaultConfiguration = function () {
        return {
            distinguishSequence: false,
            maxWidth: 460,
            minWidth: 260,
        };
    };
    /** @inheritdoc */
    DirectionComponent.componentName = "direction";
    return DirectionComponent;
}(Component_1.Component));
exports.DirectionComponent = DirectionComponent;
Component_1.ComponentService.register(DirectionComponent);
exports.default = DirectionComponent;

},{"../../Component":291,"rxjs/Observable":29,"rxjs/Subject":34,"rxjs/add/observable/combineLatest":38,"rxjs/add/operator/distinctUntilChanged":60,"rxjs/add/operator/do":61,"rxjs/add/operator/filter":63,"rxjs/add/operator/map":67,"rxjs/add/operator/share":79,"virtual-dom":247}],319:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Geo_1 = require("../../Geo");
/**
 * @class DirectionDOMCalculator
 * @classdesc Helper class for calculating DOM CSS properties.
 */
var DirectionDOMCalculator = /** @class */ (function () {
    function DirectionDOMCalculator(configuration, element) {
        this._spatial = new Geo_1.Spatial();
        this._minThresholdWidth = 320;
        this._maxThresholdWidth = 1480;
        this._minThresholdHeight = 240;
        this._maxThresholdHeight = 820;
        this._configure(configuration);
        this._resize(element);
        this._reset();
    }
    Object.defineProperty(DirectionDOMCalculator.prototype, "minWidth", {
        get: function () {
            return this._minWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "maxWidth", {
        get: function () {
            return this._maxWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "containerWidth", {
        get: function () {
            return this._containerWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "containerWidthCss", {
        get: function () {
            return this._containerWidthCss;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "containerMarginCss", {
        get: function () {
            return this._containerMarginCss;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "containerLeftCss", {
        get: function () {
            return this._containerLeftCss;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "containerHeight", {
        get: function () {
            return this._containerHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "containerHeightCss", {
        get: function () {
            return this._containerHeightCss;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "containerBottomCss", {
        get: function () {
            return this._containerBottomCss;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "stepCircleSize", {
        get: function () {
            return this._stepCircleSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "stepCircleSizeCss", {
        get: function () {
            return this._stepCircleSizeCss;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "stepCircleMarginCss", {
        get: function () {
            return this._stepCircleMarginCss;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "turnCircleSize", {
        get: function () {
            return this._turnCircleSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "turnCircleSizeCss", {
        get: function () {
            return this._turnCircleSizeCss;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "outerRadius", {
        get: function () {
            return this._outerRadius;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "innerRadius", {
        get: function () {
            return this._innerRadius;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionDOMCalculator.prototype, "shadowOffset", {
        get: function () {
            return this._shadowOffset;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Configures the min and max width values.
     *
     * @param {IDirectionConfiguration} configuration Configuration
     * with min and max width values.
     */
    DirectionDOMCalculator.prototype.configure = function (configuration) {
        this._configure(configuration);
        this._reset();
    };
    /**
     * Resizes all properties according to the width and height
     * of the element.
     *
     * @param {HTMLElement} element The container element from which to extract
     * the width and height.
     */
    DirectionDOMCalculator.prototype.resize = function (element) {
        this._resize(element);
        this._reset();
    };
    /**
     * Calculates the coordinates on the unit circle for an angle.
     *
     * @param {number} angle Angle in radians.
     * @returns {Array<number>} The x and y coordinates on the unit circle.
     */
    DirectionDOMCalculator.prototype.angleToCoordinates = function (angle) {
        return [Math.cos(angle), Math.sin(angle)];
    };
    /**
     * Calculates the coordinates on the unit circle for the
     * relative angle between the first and second angle.
     *
     * @param {number} first Angle in radians.
     * @param {number} second Angle in radians.
     * @returns {Array<number>} The x and y coordinates on the unit circle
     * for the relative angle between the first and second angle.
     */
    DirectionDOMCalculator.prototype.relativeAngleToCoordiantes = function (first, second) {
        var relativeAngle = this._spatial.wrapAngle(first - second);
        return this.angleToCoordinates(relativeAngle);
    };
    DirectionDOMCalculator.prototype._configure = function (configuration) {
        this._minWidth = configuration.minWidth;
        this._maxWidth = this._getMaxWidth(configuration.minWidth, configuration.maxWidth);
    };
    DirectionDOMCalculator.prototype._resize = function (element) {
        this._elementWidth = element.offsetWidth;
        this._elementHeight = element.offsetHeight;
    };
    DirectionDOMCalculator.prototype._reset = function () {
        this._containerWidth = this._getContainerWidth(this._elementWidth, this._elementHeight);
        this._containerHeight = this._getContainerHeight(this.containerWidth);
        this._stepCircleSize = this._getStepCircleDiameter(this._containerHeight);
        this._turnCircleSize = this._getTurnCircleDiameter(this.containerHeight);
        this._outerRadius = this._getOuterRadius(this._containerHeight);
        this._innerRadius = this._getInnerRadius(this._containerHeight);
        this._shadowOffset = 3;
        this._containerWidthCss = this._numberToCssPixels(this._containerWidth);
        this._containerMarginCss = this._numberToCssPixels(-0.5 * this._containerWidth);
        this._containerLeftCss = this._numberToCssPixels(Math.floor(0.5 * this._elementWidth));
        this._containerHeightCss = this._numberToCssPixels(this._containerHeight);
        this._containerBottomCss = this._numberToCssPixels(Math.floor(-0.08 * this._containerHeight));
        this._stepCircleSizeCss = this._numberToCssPixels(this._stepCircleSize);
        this._stepCircleMarginCss = this._numberToCssPixels(-0.5 * this._stepCircleSize);
        this._turnCircleSizeCss = this._numberToCssPixels(this._turnCircleSize);
    };
    DirectionDOMCalculator.prototype._getContainerWidth = function (elementWidth, elementHeight) {
        var relativeWidth = (elementWidth - this._minThresholdWidth) / (this._maxThresholdWidth - this._minThresholdWidth);
        var relativeHeight = (elementHeight - this._minThresholdHeight) / (this._maxThresholdHeight - this._minThresholdHeight);
        var coeff = Math.max(0, Math.min(1, Math.min(relativeWidth, relativeHeight)));
        coeff = 0.04 * Math.round(25 * coeff);
        return this._minWidth + coeff * (this._maxWidth - this._minWidth);
    };
    DirectionDOMCalculator.prototype._getContainerHeight = function (containerWidth) {
        return 0.77 * containerWidth;
    };
    DirectionDOMCalculator.prototype._getStepCircleDiameter = function (containerHeight) {
        return 0.34 * containerHeight;
    };
    DirectionDOMCalculator.prototype._getTurnCircleDiameter = function (containerHeight) {
        return 0.3 * containerHeight;
    };
    DirectionDOMCalculator.prototype._getOuterRadius = function (containerHeight) {
        return 0.31 * containerHeight;
    };
    DirectionDOMCalculator.prototype._getInnerRadius = function (containerHeight) {
        return 0.125 * containerHeight;
    };
    DirectionDOMCalculator.prototype._numberToCssPixels = function (value) {
        return value + "px";
    };
    DirectionDOMCalculator.prototype._getMaxWidth = function (value, minWidth) {
        return value > minWidth ? value : minWidth;
    };
    return DirectionDOMCalculator;
}());
exports.DirectionDOMCalculator = DirectionDOMCalculator;
exports.default = DirectionDOMCalculator;

},{"../../Geo":294}],320:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var vd = require("virtual-dom");
var Component_1 = require("../../Component");
var Edge_1 = require("../../Edge");
var Error_1 = require("../../Error");
var Geo_1 = require("../../Geo");
/**
 * @class DirectionDOMRenderer
 * @classdesc DOM renderer for direction arrows.
 */
var DirectionDOMRenderer = /** @class */ (function () {
    function DirectionDOMRenderer(configuration, element) {
        this._isEdge = false;
        this._spatial = new Geo_1.Spatial();
        this._calculator = new Component_1.DirectionDOMCalculator(configuration, element);
        this._node = null;
        this._rotation = { phi: 0, theta: 0 };
        this._epsilon = 0.5 * Math.PI / 180;
        this._highlightKey = null;
        this._distinguishSequence = false;
        this._needsRender = false;
        this._stepEdges = [];
        this._turnEdges = [];
        this._panoEdges = [];
        this._sequenceEdgeKeys = [];
        this._stepDirections = [
            Edge_1.EdgeDirection.StepForward,
            Edge_1.EdgeDirection.StepBackward,
            Edge_1.EdgeDirection.StepLeft,
            Edge_1.EdgeDirection.StepRight,
        ];
        this._turnDirections = [
            Edge_1.EdgeDirection.TurnLeft,
            Edge_1.EdgeDirection.TurnRight,
            Edge_1.EdgeDirection.TurnU,
        ];
        this._turnNames = {};
        this._turnNames[Edge_1.EdgeDirection.TurnLeft] = "TurnLeft";
        this._turnNames[Edge_1.EdgeDirection.TurnRight] = "TurnRight";
        this._turnNames[Edge_1.EdgeDirection.TurnU] = "TurnAround";
        // detects IE 8-11, then Edge 20+.
        var isIE = !!document.documentMode;
        this._isEdge = !isIE && !!window.StyleMedia;
    }
    Object.defineProperty(DirectionDOMRenderer.prototype, "needsRender", {
        /**
         * Get needs render.
         *
         * @returns {boolean} Value indicating whether render should be called.
         */
        get: function () {
            return this._needsRender;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Renders virtual DOM elements.
     *
     * @description Calling render resets the needs render property.
     */
    DirectionDOMRenderer.prototype.render = function (navigator) {
        this._needsRender = false;
        var rotation = this._rotation;
        var steps = [];
        var turns = [];
        if (this._node.pano) {
            steps = steps.concat(this._createPanoArrows(navigator, rotation));
        }
        else {
            steps = steps.concat(this._createPerspectiveToPanoArrows(navigator, rotation));
            steps = steps.concat(this._createStepArrows(navigator, rotation));
            turns = turns.concat(this._createTurnArrows(navigator));
        }
        return this._getContainer(steps, turns, rotation);
    };
    DirectionDOMRenderer.prototype.setEdges = function (edgeStatus, sequence) {
        this._setEdges(edgeStatus, sequence);
        this._setNeedsRender();
    };
    /**
     * Set node for which to show edges.
     *
     * @param {Node} node
     */
    DirectionDOMRenderer.prototype.setNode = function (node) {
        this._node = node;
        this._clearEdges();
        this._setNeedsRender();
    };
    /**
     * Set the render camera to use for calculating rotations.
     *
     * @param {RenderCamera} renderCamera
     */
    DirectionDOMRenderer.prototype.setRenderCamera = function (renderCamera) {
        var rotation = renderCamera.rotation;
        if (Math.abs(rotation.phi - this._rotation.phi) < this._epsilon) {
            return;
        }
        this._rotation = rotation;
        this._setNeedsRender();
    };
    /**
     * Set configuration values.
     *
     * @param {IDirectionConfiguration} configuration
     */
    DirectionDOMRenderer.prototype.setConfiguration = function (configuration) {
        var needsRender = false;
        if (this._highlightKey !== configuration.highlightKey ||
            this._distinguishSequence !== configuration.distinguishSequence) {
            this._highlightKey = configuration.highlightKey;
            this._distinguishSequence = configuration.distinguishSequence;
            needsRender = true;
        }
        if (this._calculator.minWidth !== configuration.minWidth ||
            this._calculator.maxWidth !== configuration.maxWidth) {
            this._calculator.configure(configuration);
            needsRender = true;
        }
        if (needsRender) {
            this._setNeedsRender();
        }
    };
    /**
     * Detect the element's width and height and resize
     * elements accordingly.
     *
     * @param {HTMLElement} element Viewer container element.
     */
    DirectionDOMRenderer.prototype.resize = function (element) {
        this._calculator.resize(element);
        this._setNeedsRender();
    };
    DirectionDOMRenderer.prototype._setNeedsRender = function () {
        if (this._node != null) {
            this._needsRender = true;
        }
    };
    DirectionDOMRenderer.prototype._clearEdges = function () {
        this._stepEdges = [];
        this._turnEdges = [];
        this._panoEdges = [];
        this._sequenceEdgeKeys = [];
    };
    DirectionDOMRenderer.prototype._setEdges = function (edgeStatus, sequence) {
        this._stepEdges = [];
        this._turnEdges = [];
        this._panoEdges = [];
        this._sequenceEdgeKeys = [];
        for (var _i = 0, _a = edgeStatus.edges; _i < _a.length; _i++) {
            var edge = _a[_i];
            var direction = edge.data.direction;
            if (this._stepDirections.indexOf(direction) > -1) {
                this._stepEdges.push(edge);
                continue;
            }
            if (this._turnDirections.indexOf(direction) > -1) {
                this._turnEdges.push(edge);
                continue;
            }
            if (edge.data.direction === Edge_1.EdgeDirection.Pano) {
                this._panoEdges.push(edge);
            }
        }
        if (this._distinguishSequence && sequence != null) {
            var edges = this._panoEdges
                .concat(this._stepEdges)
                .concat(this._turnEdges);
            for (var _b = 0, edges_1 = edges; _b < edges_1.length; _b++) {
                var edge = edges_1[_b];
                var edgeKey = edge.to;
                for (var _c = 0, _d = sequence.keys; _c < _d.length; _c++) {
                    var sequenceKey = _d[_c];
                    if (sequenceKey === edgeKey) {
                        this._sequenceEdgeKeys.push(edgeKey);
                        break;
                    }
                }
            }
        }
    };
    DirectionDOMRenderer.prototype._createPanoArrows = function (navigator, rotation) {
        var arrows = [];
        for (var _i = 0, _a = this._panoEdges; _i < _a.length; _i++) {
            var panoEdge = _a[_i];
            arrows.push(this._createVNodeByKey(navigator, panoEdge.to, panoEdge.data.worldMotionAzimuth, rotation, this._calculator.outerRadius, "DirectionsArrowPano"));
        }
        for (var _b = 0, _c = this._stepEdges; _b < _c.length; _b++) {
            var stepEdge = _c[_b];
            arrows.push(this._createPanoToPerspectiveArrow(navigator, stepEdge.to, stepEdge.data.worldMotionAzimuth, rotation, stepEdge.data.direction));
        }
        return arrows;
    };
    DirectionDOMRenderer.prototype._createPanoToPerspectiveArrow = function (navigator, key, azimuth, rotation, direction) {
        var threshold = Math.PI / 8;
        var relativePhi = rotation.phi;
        switch (direction) {
            case Edge_1.EdgeDirection.StepBackward:
                relativePhi = rotation.phi - Math.PI;
                break;
            case Edge_1.EdgeDirection.StepLeft:
                relativePhi = rotation.phi + Math.PI / 2;
                break;
            case Edge_1.EdgeDirection.StepRight:
                relativePhi = rotation.phi - Math.PI / 2;
                break;
            default:
                break;
        }
        if (Math.abs(this._spatial.wrapAngle(azimuth - relativePhi)) < threshold) {
            return this._createVNodeByKey(navigator, key, azimuth, rotation, this._calculator.outerRadius, "DirectionsArrowStep");
        }
        return this._createVNodeDisabled(key, azimuth, rotation);
    };
    DirectionDOMRenderer.prototype._createPerspectiveToPanoArrows = function (navigator, rotation) {
        var arrows = [];
        for (var _i = 0, _a = this._panoEdges; _i < _a.length; _i++) {
            var panoEdge = _a[_i];
            arrows.push(this._createVNodeByKey(navigator, panoEdge.to, panoEdge.data.worldMotionAzimuth, rotation, this._calculator.innerRadius, "DirectionsArrowPano", true));
        }
        return arrows;
    };
    DirectionDOMRenderer.prototype._createStepArrows = function (navigator, rotation) {
        var arrows = [];
        for (var _i = 0, _a = this._stepEdges; _i < _a.length; _i++) {
            var stepEdge = _a[_i];
            arrows.push(this._createVNodeByDirection(navigator, stepEdge.to, stepEdge.data.worldMotionAzimuth, rotation, stepEdge.data.direction));
        }
        return arrows;
    };
    DirectionDOMRenderer.prototype._createTurnArrows = function (navigator) {
        var turns = [];
        for (var _i = 0, _a = this._turnEdges; _i < _a.length; _i++) {
            var turnEdge = _a[_i];
            var direction = turnEdge.data.direction;
            var name_1 = this._turnNames[direction];
            turns.push(this._createVNodeByTurn(navigator, turnEdge.to, name_1, direction));
        }
        return turns;
    };
    DirectionDOMRenderer.prototype._createVNodeByKey = function (navigator, key, azimuth, rotation, offset, className, shiftVertically) {
        var onClick = function (e) {
            navigator.moveToKey$(key)
                .subscribe(undefined, function (error) {
                if (!(error instanceof Error_1.AbortMapillaryError)) {
                    console.error(error);
                }
            });
        };
        return this._createVNode(key, azimuth, rotation, offset, className, "DirectionsCircle", onClick, shiftVertically);
    };
    DirectionDOMRenderer.prototype._createVNodeByDirection = function (navigator, key, azimuth, rotation, direction) {
        var onClick = function (e) {
            navigator.moveDir$(direction)
                .subscribe(undefined, function (error) {
                if (!(error instanceof Error_1.AbortMapillaryError)) {
                    console.error(error);
                }
            });
        };
        return this._createVNode(key, azimuth, rotation, this._calculator.outerRadius, "DirectionsArrowStep", "DirectionsCircle", onClick);
    };
    DirectionDOMRenderer.prototype._createVNodeByTurn = function (navigator, key, className, direction) {
        var onClick = function (e) {
            navigator.moveDir$(direction)
                .subscribe(undefined, function (error) {
                if (!(error instanceof Error_1.AbortMapillaryError)) {
                    console.error(error);
                }
            });
        };
        var style = {
            height: this._calculator.turnCircleSizeCss,
            transform: "rotate(0)",
            width: this._calculator.turnCircleSizeCss,
        };
        switch (direction) {
            case Edge_1.EdgeDirection.TurnLeft:
                style.left = "5px";
                style.top = "5px";
                break;
            case Edge_1.EdgeDirection.TurnRight:
                style.right = "5px";
                style.top = "5px";
                break;
            case Edge_1.EdgeDirection.TurnU:
                style.left = "5px";
                style.bottom = "5px";
                break;
            default:
                break;
        }
        var circleProperties = {
            attributes: {
                "data-key": key,
            },
            onclick: onClick,
            style: style,
        };
        var circleClassName = "TurnCircle";
        if (this._sequenceEdgeKeys.indexOf(key) > -1) {
            circleClassName += "Sequence";
        }
        if (this._highlightKey === key) {
            circleClassName += "Highlight";
        }
        var turn = vd.h("div." + className, {}, []);
        return vd.h("div." + circleClassName, circleProperties, [turn]);
    };
    DirectionDOMRenderer.prototype._createVNodeDisabled = function (key, azimuth, rotation) {
        return this._createVNode(key, azimuth, rotation, this._calculator.outerRadius, "DirectionsArrowDisabled", "DirectionsCircleDisabled");
    };
    DirectionDOMRenderer.prototype._createVNode = function (key, azimuth, rotation, radius, className, circleClassName, onClick, shiftVertically) {
        var translation = this._calculator.angleToCoordinates(azimuth - rotation.phi);
        // rotate 90 degrees clockwise and flip over X-axis
        var translationX = Math.round(-radius * translation[1] + 0.5 * this._calculator.containerWidth);
        var translationY = Math.round(-radius * translation[0] + 0.5 * this._calculator.containerHeight);
        var shadowTranslation = this._calculator.relativeAngleToCoordiantes(azimuth, rotation.phi);
        var shadowOffset = this._calculator.shadowOffset;
        var shadowTranslationX = -shadowOffset * shadowTranslation[1];
        var shadowTranslationY = shadowOffset * shadowTranslation[0];
        var filter = "drop-shadow(" + shadowTranslationX + "px " + shadowTranslationY + "px 1px rgba(0,0,0,0.8))";
        var properties = {
            style: {
                "-webkit-filter": filter,
                filter: filter,
            },
        };
        var chevron = vd.h("div." + className, properties, []);
        var azimuthDeg = -this._spatial.radToDeg(azimuth - rotation.phi);
        var circleTransform = shiftVertically ?
            "translate(" + translationX + "px, " + translationY + "px) rotate(" + azimuthDeg + "deg) translateZ(-0.01px)" :
            "translate(" + translationX + "px, " + translationY + "px) rotate(" + azimuthDeg + "deg)";
        var circleProperties = {
            attributes: { "data-key": key },
            onclick: onClick,
            style: {
                height: this._calculator.stepCircleSizeCss,
                marginLeft: this._calculator.stepCircleMarginCss,
                marginTop: this._calculator.stepCircleMarginCss,
                transform: circleTransform,
                width: this._calculator.stepCircleSizeCss,
            },
        };
        if (this._sequenceEdgeKeys.indexOf(key) > -1) {
            circleClassName += "Sequence";
        }
        if (this._highlightKey === key) {
            circleClassName += "Highlight";
        }
        return vd.h("div." + circleClassName, circleProperties, [chevron]);
    };
    DirectionDOMRenderer.prototype._getContainer = function (steps, turns, rotation) {
        // edge does not handle hover on perspective transforms.
        var transform = this._isEdge ?
            "rotateX(60deg)" :
            "perspective(" + this._calculator.containerWidthCss + ") rotateX(60deg)";
        var properties = {
            oncontextmenu: function (event) { event.preventDefault(); },
            style: {
                bottom: this._calculator.containerBottomCss,
                height: this._calculator.containerHeightCss,
                left: this._calculator.containerLeftCss,
                marginLeft: this._calculator.containerMarginCss,
                transform: transform,
                width: this._calculator.containerWidthCss,
            },
        };
        return vd.h("div.DirectionsPerspective", properties, turns.concat(steps));
    };
    return DirectionDOMRenderer;
}());
exports.DirectionDOMRenderer = DirectionDOMRenderer;
exports.default = DirectionDOMRenderer;

},{"../../Component":291,"../../Edge":292,"../../Error":293,"../../Geo":294,"virtual-dom":247}],321:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/operator/catch");
require("rxjs/add/operator/combineLatest");
require("rxjs/add/operator/debounceTime");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/map");
require("rxjs/add/operator/pairwise");
require("rxjs/add/operator/publish");
require("rxjs/add/operator/publishReplay");
require("rxjs/add/operator/scan");
require("rxjs/add/operator/skipWhile");
require("rxjs/add/operator/startWith");
require("rxjs/add/operator/switchMap");
require("rxjs/add/operator/takeUntil");
require("rxjs/add/operator/withLatestFrom");
var Component_1 = require("../../Component");
var Render_1 = require("../../Render");
var Tiles_1 = require("../../Tiles");
var Utils_1 = require("../../Utils");
var ImagePlaneComponent = /** @class */ (function (_super) {
    __extends(ImagePlaneComponent, _super);
    function ImagePlaneComponent(name, container, navigator) {
        var _this = _super.call(this, name, container, navigator) || this;
        _this._imageTileLoader = new Tiles_1.ImageTileLoader(Utils_1.Urls.tileScheme, Utils_1.Urls.tileDomain, Utils_1.Urls.origin);
        _this._roiCalculator = new Tiles_1.RegionOfInterestCalculator();
        _this._rendererOperation$ = new Subject_1.Subject();
        _this._rendererCreator$ = new Subject_1.Subject();
        _this._rendererDisposer$ = new Subject_1.Subject();
        _this._renderer$ = _this._rendererOperation$
            .scan(function (renderer, operation) {
            return operation(renderer);
        }, null)
            .filter(function (renderer) {
            return renderer != null;
        })
            .distinctUntilChanged(undefined, function (renderer) {
            return renderer.frameId;
        });
        _this._rendererCreator$
            .map(function () {
            return function (renderer) {
                if (renderer != null) {
                    throw new Error("Multiple image plane states can not be created at the same time");
                }
                return new Component_1.ImagePlaneGLRenderer();
            };
        })
            .subscribe(_this._rendererOperation$);
        _this._rendererDisposer$
            .map(function () {
            return function (renderer) {
                renderer.dispose();
                return null;
            };
        })
            .subscribe(_this._rendererOperation$);
        return _this;
    }
    ImagePlaneComponent.prototype._activate = function () {
        var _this = this;
        this._rendererSubscription = this._renderer$
            .map(function (renderer) {
            var renderHash = {
                name: _this._name,
                render: {
                    frameId: renderer.frameId,
                    needsRender: renderer.needsRender,
                    render: renderer.render.bind(renderer),
                    stage: Render_1.GLRenderStage.Background,
                },
            };
            renderer.clearNeedsRender();
            return renderHash;
        })
            .subscribe(this._container.glRenderer.render$);
        this._rendererCreator$.next(null);
        this._stateSubscription = this._navigator.stateService.currentState$
            .map(function (frame) {
            return function (renderer) {
                renderer.updateFrame(frame);
                return renderer;
            };
        })
            .subscribe(this._rendererOperation$);
        var textureProvider$ = this._navigator.stateService.currentState$
            .distinctUntilChanged(undefined, function (frame) {
            return frame.state.currentNode.key;
        })
            .combineLatest(this._configuration$)
            .filter(function (args) {
            return args[1].imageTiling === true;
        })
            .map(function (args) {
            return args[0];
        })
            .withLatestFrom(this._container.glRenderer.webGLRenderer$, this._container.renderService.size$)
            .map(function (_a) {
            var frame = _a[0], renderer = _a[1], size = _a[2];
            var state = frame.state;
            var viewportSize = Math.max(size.width, size.height);
            var currentNode = state.currentNode;
            var currentTransform = state.currentTransform;
            var tileSize = viewportSize > 2048 ? 2048 : viewportSize > 1024 ? 1024 : 512;
            return new Tiles_1.TextureProvider(currentNode.key, currentTransform.basicWidth, currentTransform.basicHeight, tileSize, currentNode.image, _this._imageTileLoader, new Tiles_1.ImageTileStore(), renderer);
        })
            .publishReplay(1)
            .refCount();
        this._textureProviderSubscription = textureProvider$.subscribe(function () { });
        this._setTextureProviderSubscription = textureProvider$
            .map(function (provider) {
            return function (renderer) {
                renderer.setTextureProvider(provider.key, provider);
                return renderer;
            };
        })
            .subscribe(this._rendererOperation$);
        this._setTileSizeSubscription = this._container.renderService.size$
            .switchMap(function (size) {
            return Observable_1.Observable
                .combineLatest(textureProvider$, Observable_1.Observable.of(size))
                .first();
        })
            .subscribe(function (_a) {
            var provider = _a[0], size = _a[1];
            var viewportSize = Math.max(size.width, size.height);
            var tileSize = viewportSize > 2048 ? 2048 : viewportSize > 1024 ? 1024 : 512;
            provider.setTileSize(tileSize);
        });
        this._abortTextureProviderSubscription = textureProvider$
            .pairwise()
            .subscribe(function (pair) {
            var previous = pair[0];
            previous.abort();
        });
        var roiTrigger$ = Observable_1.Observable
            .combineLatest(this._container.renderService.renderCameraFrame$, this._container.renderService.size$.debounceTime(250))
            .map(function (_a) {
            var camera = _a[0], size = _a[1];
            return [
                camera.camera.position.clone(),
                camera.camera.lookat.clone(),
                camera.zoom.valueOf(),
                size.height.valueOf(),
                size.width.valueOf()
            ];
        })
            .pairwise()
            .skipWhile(function (pls) {
            return pls[1][2] - pls[0][2] < 0 || pls[1][2] === 0;
        })
            .map(function (pls) {
            var samePosition = pls[0][0].equals(pls[1][0]);
            var sameLookat = pls[0][1].equals(pls[1][1]);
            var sameZoom = pls[0][2] === pls[1][2];
            var sameHeight = pls[0][3] === pls[1][3];
            var sameWidth = pls[0][4] === pls[1][4];
            return samePosition && sameLookat && sameZoom && sameHeight && sameWidth;
        })
            .distinctUntilChanged()
            .filter(function (stalled) {
            return stalled;
        })
            .switchMap(function (stalled) {
            return _this._container.renderService.renderCameraFrame$
                .first();
        })
            .withLatestFrom(this._container.renderService.size$, this._navigator.stateService.currentTransform$);
        this._setRegionOfInterestSubscription = textureProvider$
            .switchMap(function (provider) {
            return roiTrigger$
                .map(function (_a) {
                var camera = _a[0], size = _a[1], transform = _a[2];
                return [
                    _this._roiCalculator.computeRegionOfInterest(camera, size, transform),
                    provider,
                ];
            });
        })
            .filter(function (args) {
            return !args[1].disposed;
        })
            .subscribe(function (args) {
            var roi = args[0];
            var provider = args[1];
            provider.setRegionOfInterest(roi);
        });
        var hasTexture$ = textureProvider$
            .switchMap(function (provider) {
            return provider.hasTexture$;
        })
            .startWith(false)
            .publishReplay(1)
            .refCount();
        this._hasTextureSubscription = hasTexture$.subscribe(function () { });
        var nodeImage$ = this._navigator.stateService.currentState$
            .filter(function (frame) {
            return frame.state.nodesAhead === 0;
        })
            .map(function (frame) {
            return frame.state.currentNode;
        })
            .distinctUntilChanged(undefined, function (node) {
            return node.key;
        })
            .debounceTime(1000)
            .withLatestFrom(hasTexture$)
            .filter(function (args) {
            return !args[1];
        })
            .map(function (args) {
            return args[0];
        })
            .filter(function (node) {
            return node.pano ?
                Utils_1.Settings.maxImageSize > Utils_1.Settings.basePanoramaSize :
                Utils_1.Settings.maxImageSize > Utils_1.Settings.baseImageSize;
        })
            .switchMap(function (node) {
            var baseImageSize = node.pano ?
                Utils_1.Settings.basePanoramaSize :
                Utils_1.Settings.baseImageSize;
            if (Math.max(node.image.width, node.image.height) > baseImageSize) {
                return Observable_1.Observable.empty();
            }
            var image$ = node
                .cacheImage$(Utils_1.Settings.maxImageSize)
                .map(function (n) {
                return [n.image, n];
            });
            return image$
                .takeUntil(hasTexture$
                .filter(function (hasTexture) {
                return hasTexture;
            }))
                .catch(function (error, caught) {
                console.error("Failed to fetch high res image (" + node.key + ")", error);
                return Observable_1.Observable.empty();
            });
        })
            .publish()
            .refCount();
        this._updateBackgroundSubscription = nodeImage$
            .withLatestFrom(textureProvider$)
            .subscribe(function (args) {
            if (args[0][1].key !== args[1].key ||
                args[1].disposed) {
                return;
            }
            args[1].updateBackground(args[0][0]);
        });
        this._updateTextureImageSubscription = nodeImage$
            .map(function (imn) {
            return function (renderer) {
                renderer.updateTextureImage(imn[0], imn[1]);
                return renderer;
            };
        })
            .subscribe(this._rendererOperation$);
    };
    ImagePlaneComponent.prototype._deactivate = function () {
        this._rendererDisposer$.next(null);
        this._abortTextureProviderSubscription.unsubscribe();
        this._hasTextureSubscription.unsubscribe();
        this._rendererSubscription.unsubscribe();
        this._setRegionOfInterestSubscription.unsubscribe();
        this._setTextureProviderSubscription.unsubscribe();
        this._setTileSizeSubscription.unsubscribe();
        this._stateSubscription.unsubscribe();
        this._textureProviderSubscription.unsubscribe();
        this._updateBackgroundSubscription.unsubscribe();
        this._updateTextureImageSubscription.unsubscribe();
    };
    ImagePlaneComponent.prototype._getDefaultConfiguration = function () {
        return { imageTiling: false };
    };
    ImagePlaneComponent.componentName = "imagePlane";
    return ImagePlaneComponent;
}(Component_1.Component));
exports.ImagePlaneComponent = ImagePlaneComponent;
Component_1.ComponentService.register(ImagePlaneComponent);
exports.default = ImagePlaneComponent;

},{"../../Component":291,"../../Render":297,"../../Tiles":300,"../../Utils":301,"rxjs/Observable":29,"rxjs/Subject":34,"rxjs/add/operator/catch":54,"rxjs/add/operator/combineLatest":55,"rxjs/add/operator/debounceTime":57,"rxjs/add/operator/distinctUntilChanged":60,"rxjs/add/operator/filter":63,"rxjs/add/operator/map":67,"rxjs/add/operator/pairwise":71,"rxjs/add/operator/publish":73,"rxjs/add/operator/publishReplay":74,"rxjs/add/operator/scan":78,"rxjs/add/operator/skipWhile":82,"rxjs/add/operator/startWith":83,"rxjs/add/operator/switchMap":84,"rxjs/add/operator/takeUntil":86,"rxjs/add/operator/withLatestFrom":90}],322:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var Component_1 = require("../../Component");
var ImagePlaneFactory = /** @class */ (function () {
    function ImagePlaneFactory(imagePlaneDepth, imageSphereRadius) {
        this._imagePlaneDepth = imagePlaneDepth != null ? imagePlaneDepth : 200;
        this._imageSphereRadius = imageSphereRadius != null ? imageSphereRadius : 200;
    }
    ImagePlaneFactory.prototype.createMesh = function (node, transform) {
        var mesh = node.pano ?
            this._createImageSphere(node, transform) :
            this._createImagePlane(node, transform);
        return mesh;
    };
    ImagePlaneFactory.prototype._createImageSphere = function (node, transform) {
        var texture = this._createTexture(node.image);
        var materialParameters = this._createSphereMaterialParameters(transform, texture);
        var material = new THREE.ShaderMaterial(materialParameters);
        var mesh = this._useMesh(transform, node) ?
            new THREE.Mesh(this._getImageSphereGeo(transform, node), material) :
            new THREE.Mesh(this._getFlatImageSphereGeo(transform), material);
        return mesh;
    };
    ImagePlaneFactory.prototype._createImagePlane = function (node, transform) {
        var texture = this._createTexture(node.image);
        var materialParameters = this._createPlaneMaterialParameters(transform, texture);
        var material = new THREE.ShaderMaterial(materialParameters);
        var geometry = this._useMesh(transform, node) ?
            this._getImagePlaneGeo(transform, node) :
            this._getFlatImagePlaneGeo(transform);
        return new THREE.Mesh(geometry, material);
    };
    ImagePlaneFactory.prototype._createSphereMaterialParameters = function (transform, texture) {
        var gpano = transform.gpano;
        var halfCroppedWidth = (gpano.FullPanoWidthPixels - gpano.CroppedAreaImageWidthPixels) / 2;
        var phiShift = 2 * Math.PI * (gpano.CroppedAreaLeftPixels - halfCroppedWidth) / gpano.FullPanoWidthPixels;
        var phiLength = 2 * Math.PI * gpano.CroppedAreaImageWidthPixels / gpano.FullPanoWidthPixels;
        var halfCroppedHeight = (gpano.FullPanoHeightPixels - gpano.CroppedAreaImageHeightPixels) / 2;
        var thetaShift = Math.PI * (halfCroppedHeight - gpano.CroppedAreaTopPixels) / gpano.FullPanoHeightPixels;
        var thetaLength = Math.PI * gpano.CroppedAreaImageHeightPixels / gpano.FullPanoHeightPixels;
        var materialParameters = {
            depthWrite: false,
            fragmentShader: Component_1.ImagePlaneShaders.equirectangular.fragment,
            side: THREE.DoubleSide,
            transparent: true,
            uniforms: {
                opacity: {
                    type: "f",
                    value: 1,
                },
                phiLength: {
                    type: "f",
                    value: phiLength,
                },
                phiShift: {
                    type: "f",
                    value: phiShift,
                },
                projectorMat: {
                    type: "m4",
                    value: transform.rt,
                },
                projectorTex: {
                    type: "t",
                    value: texture,
                },
                thetaLength: {
                    type: "f",
                    value: thetaLength,
                },
                thetaShift: {
                    type: "f",
                    value: thetaShift,
                },
            },
            vertexShader: Component_1.ImagePlaneShaders.equirectangular.vertex,
        };
        return materialParameters;
    };
    ImagePlaneFactory.prototype._createPlaneMaterialParameters = function (transform, texture) {
        var materialParameters = {
            depthWrite: false,
            fragmentShader: Component_1.ImagePlaneShaders.perspective.fragment,
            side: THREE.DoubleSide,
            transparent: true,
            uniforms: {
                bbox: {
                    type: "v4",
                    value: new THREE.Vector4(0, 0, 1, 1),
                },
                opacity: {
                    type: "f",
                    value: 1,
                },
                projectorMat: {
                    type: "m4",
                    value: transform.projectorMatrix(),
                },
                projectorTex: {
                    type: "t",
                    value: texture,
                },
            },
            vertexShader: Component_1.ImagePlaneShaders.perspective.vertex,
        };
        return materialParameters;
    };
    ImagePlaneFactory.prototype._createTexture = function (image) {
        var texture = new THREE.Texture(image);
        texture.minFilter = THREE.LinearFilter;
        texture.needsUpdate = true;
        return texture;
    };
    ImagePlaneFactory.prototype._useMesh = function (transform, node) {
        return node.mesh.vertices.length && transform.hasValidScale;
    };
    ImagePlaneFactory.prototype._getImageSphereGeo = function (transform, node) {
        var t = new THREE.Matrix4().getInverse(transform.srt);
        // push everything at least 5 meters in front of the camera
        var minZ = 5.0 * transform.scale;
        var maxZ = this._imageSphereRadius * transform.scale;
        var vertices = node.mesh.vertices;
        var numVertices = vertices.length / 3;
        var positions = new Float32Array(vertices.length);
        for (var i = 0; i < numVertices; ++i) {
            var index = 3 * i;
            var x = vertices[index + 0];
            var y = vertices[index + 1];
            var z = vertices[index + 2];
            var l = Math.sqrt(x * x + y * y + z * z);
            var boundedL = Math.max(minZ, Math.min(l, maxZ));
            var factor = boundedL / l;
            var p = new THREE.Vector3(x * factor, y * factor, z * factor);
            p.applyMatrix4(t);
            positions[index + 0] = p.x;
            positions[index + 1] = p.y;
            positions[index + 2] = p.z;
        }
        var faces = node.mesh.faces;
        var indices = new Uint16Array(faces.length);
        for (var i = 0; i < faces.length; ++i) {
            indices[i] = faces[i];
        }
        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute("position", new THREE.BufferAttribute(positions, 3));
        geometry.setIndex(new THREE.BufferAttribute(indices, 1));
        return geometry;
    };
    ImagePlaneFactory.prototype._getImagePlaneGeo = function (transform, node) {
        var t = new THREE.Matrix4().getInverse(transform.srt);
        // push everything at least 5 meters in front of the camera
        var minZ = 5.0 * transform.scale;
        var maxZ = this._imagePlaneDepth * transform.scale;
        var vertices = node.mesh.vertices;
        var numVertices = vertices.length / 3;
        var positions = new Float32Array(vertices.length);
        for (var i = 0; i < numVertices; ++i) {
            var index = 3 * i;
            var x = vertices[index + 0];
            var y = vertices[index + 1];
            var z = vertices[index + 2];
            var boundedZ = Math.max(minZ, Math.min(z, maxZ));
            var factor = boundedZ / z;
            var p = new THREE.Vector3(x * factor, y * factor, boundedZ);
            p.applyMatrix4(t);
            positions[index + 0] = p.x;
            positions[index + 1] = p.y;
            positions[index + 2] = p.z;
        }
        var faces = node.mesh.faces;
        var indices = new Uint16Array(faces.length);
        for (var i = 0; i < faces.length; ++i) {
            indices[i] = faces[i];
        }
        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute("position", new THREE.BufferAttribute(positions, 3));
        geometry.setIndex(new THREE.BufferAttribute(indices, 1));
        return geometry;
    };
    ImagePlaneFactory.prototype._getFlatImageSphereGeo = function (transform) {
        var gpano = transform.gpano;
        var phiStart = 2 * Math.PI * gpano.CroppedAreaLeftPixels / gpano.FullPanoWidthPixels;
        var phiLength = 2 * Math.PI * gpano.CroppedAreaImageWidthPixels / gpano.FullPanoWidthPixels;
        var thetaStart = Math.PI *
            (gpano.FullPanoHeightPixels - gpano.CroppedAreaImageHeightPixels - gpano.CroppedAreaTopPixels) /
            gpano.FullPanoHeightPixels;
        var thetaLength = Math.PI * gpano.CroppedAreaImageHeightPixels / gpano.FullPanoHeightPixels;
        var geometry = new THREE.SphereGeometry(this._imageSphereRadius, 20, 40, phiStart - Math.PI / 2, phiLength, thetaStart, thetaLength);
        geometry.applyMatrix(new THREE.Matrix4().getInverse(transform.rt));
        return geometry;
    };
    ImagePlaneFactory.prototype._getFlatImagePlaneGeo = function (transform) {
        var width = transform.width;
        var height = transform.height;
        var size = Math.max(width, height);
        var dx = width / 2.0 / size;
        var dy = height / 2.0 / size;
        var vertices = [];
        vertices.push(transform.unprojectSfM([-dx, -dy], this._imagePlaneDepth));
        vertices.push(transform.unprojectSfM([dx, -dy], this._imagePlaneDepth));
        vertices.push(transform.unprojectSfM([dx, dy], this._imagePlaneDepth));
        vertices.push(transform.unprojectSfM([-dx, dy], this._imagePlaneDepth));
        var positions = new Float32Array(12);
        for (var i = 0; i < vertices.length; i++) {
            var index = 3 * i;
            positions[index + 0] = vertices[i][0];
            positions[index + 1] = vertices[i][1];
            positions[index + 2] = vertices[i][2];
        }
        var indices = new Uint16Array(6);
        indices[0] = 0;
        indices[1] = 1;
        indices[2] = 3;
        indices[3] = 1;
        indices[4] = 2;
        indices[5] = 3;
        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute("position", new THREE.BufferAttribute(positions, 3));
        geometry.setIndex(new THREE.BufferAttribute(indices, 1));
        return geometry;
    };
    return ImagePlaneFactory;
}());
exports.ImagePlaneFactory = ImagePlaneFactory;
exports.default = ImagePlaneFactory;

},{"../../Component":291,"three":241}],323:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var Component_1 = require("../../Component");
var ImagePlaneGLRenderer = /** @class */ (function () {
    function ImagePlaneGLRenderer() {
        this._imagePlaneFactory = new Component_1.ImagePlaneFactory();
        this._imagePlaneScene = new Component_1.ImagePlaneScene();
        this._alpha = 0;
        this._alphaOld = 0;
        this._fadeOutSpeed = 0.05;
        this._currentKey = null;
        this._previousKey = null;
        this._providerDisposers = {};
        this._frameId = 0;
        this._needsRender = false;
    }
    Object.defineProperty(ImagePlaneGLRenderer.prototype, "frameId", {
        get: function () {
            return this._frameId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImagePlaneGLRenderer.prototype, "needsRender", {
        get: function () {
            return this._needsRender;
        },
        enumerable: true,
        configurable: true
    });
    ImagePlaneGLRenderer.prototype.indicateNeedsRender = function () {
        this._needsRender = true;
    };
    ImagePlaneGLRenderer.prototype.updateFrame = function (frame) {
        this._updateFrameId(frame.id);
        this._needsRender = this._updateAlpha(frame.state.alpha) || this._needsRender;
        this._needsRender = this._updateAlphaOld(frame.state.alpha) || this._needsRender;
        this._needsRender = this._updateImagePlanes(frame.state) || this._needsRender;
    };
    ImagePlaneGLRenderer.prototype.setTextureProvider = function (key, provider) {
        var _this = this;
        if (key !== this._currentKey) {
            return;
        }
        var createdSubscription = provider.textureCreated$
            .subscribe(function (texture) {
            _this._updateTexture(texture);
        });
        var updatedSubscription = provider.textureUpdated$
            .subscribe(function (updated) {
            _this._needsRender = true;
        });
        var dispose = function () {
            createdSubscription.unsubscribe();
            updatedSubscription.unsubscribe();
            provider.dispose();
        };
        if (key in this._providerDisposers) {
            var disposeProvider = this._providerDisposers[key];
            disposeProvider();
            delete this._providerDisposers[key];
        }
        this._providerDisposers[key] = dispose;
    };
    ImagePlaneGLRenderer.prototype._updateTexture = function (texture) {
        this._needsRender = true;
        for (var _i = 0, _a = this._imagePlaneScene.imagePlanes; _i < _a.length; _i++) {
            var plane = _a[_i];
            var material = plane.material;
            var oldTexture = material.uniforms.projectorTex.value;
            material.uniforms.projectorTex.value = null;
            oldTexture.dispose();
            material.uniforms.projectorTex.value = texture;
        }
    };
    ImagePlaneGLRenderer.prototype.updateTextureImage = function (image, node) {
        if (this._currentKey !== node.key) {
            return;
        }
        this._needsRender = true;
        for (var _i = 0, _a = this._imagePlaneScene.imagePlanes; _i < _a.length; _i++) {
            var plane = _a[_i];
            var material = plane.material;
            var texture = material.uniforms.projectorTex.value;
            texture.image = image;
            texture.needsUpdate = true;
        }
    };
    ImagePlaneGLRenderer.prototype.render = function (perspectiveCamera, renderer) {
        var planeAlpha = this._imagePlaneScene.imagePlanesOld.length ? 1 : this._alpha;
        for (var _i = 0, _a = this._imagePlaneScene.imagePlanes; _i < _a.length; _i++) {
            var plane = _a[_i];
            plane.material.uniforms.opacity.value = planeAlpha;
        }
        for (var _b = 0, _c = this._imagePlaneScene.imagePlanesOld; _b < _c.length; _b++) {
            var plane = _c[_b];
            plane.material.uniforms.opacity.value = this._alphaOld;
        }
        renderer.render(this._imagePlaneScene.scene, perspectiveCamera);
        renderer.render(this._imagePlaneScene.sceneOld, perspectiveCamera);
        for (var _d = 0, _e = this._imagePlaneScene.imagePlanes; _d < _e.length; _d++) {
            var plane = _e[_d];
            plane.material.uniforms.opacity.value = this._alpha;
        }
        renderer.render(this._imagePlaneScene.scene, perspectiveCamera);
    };
    ImagePlaneGLRenderer.prototype.clearNeedsRender = function () {
        this._needsRender = false;
    };
    ImagePlaneGLRenderer.prototype.dispose = function () {
        this._imagePlaneScene.clear();
    };
    ImagePlaneGLRenderer.prototype._updateFrameId = function (frameId) {
        this._frameId = frameId;
    };
    ImagePlaneGLRenderer.prototype._updateAlpha = function (alpha) {
        if (alpha === this._alpha) {
            return false;
        }
        this._alpha = alpha;
        return true;
    };
    ImagePlaneGLRenderer.prototype._updateAlphaOld = function (alpha) {
        if (alpha < 1 || this._alphaOld === 0) {
            return false;
        }
        this._alphaOld = Math.max(0, this._alphaOld - this._fadeOutSpeed);
        return true;
    };
    ImagePlaneGLRenderer.prototype._updateImagePlanes = function (state) {
        if (state.currentNode == null || state.currentNode.key === this._currentKey) {
            return false;
        }
        var previousKey = state.previousNode != null ? state.previousNode.key : null;
        var currentKey = state.currentNode.key;
        if (this._previousKey !== previousKey &&
            this._previousKey !== currentKey &&
            this._previousKey in this._providerDisposers) {
            var disposeProvider = this._providerDisposers[this._previousKey];
            disposeProvider();
            delete this._providerDisposers[this._previousKey];
        }
        if (previousKey != null) {
            if (previousKey !== this._currentKey && previousKey !== this._previousKey) {
                var previousMesh = this._imagePlaneFactory.createMesh(state.previousNode, state.previousTransform);
                this._imagePlaneScene.updateImagePlanes([previousMesh]);
            }
            this._previousKey = previousKey;
        }
        this._currentKey = currentKey;
        var currentMesh = this._imagePlaneFactory.createMesh(state.currentNode, state.currentTransform);
        this._imagePlaneScene.updateImagePlanes([currentMesh]);
        this._alphaOld = 1;
        return true;
    };
    return ImagePlaneGLRenderer;
}());
exports.ImagePlaneGLRenderer = ImagePlaneGLRenderer;
exports.default = ImagePlaneGLRenderer;

},{"../../Component":291}],324:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var ImagePlaneScene = /** @class */ (function () {
    function ImagePlaneScene() {
        this.scene = new THREE.Scene();
        this.sceneOld = new THREE.Scene();
        this.imagePlanes = [];
        this.imagePlanesOld = [];
    }
    ImagePlaneScene.prototype.updateImagePlanes = function (planes) {
        this._dispose(this.imagePlanesOld, this.sceneOld);
        for (var _i = 0, _a = this.imagePlanes; _i < _a.length; _i++) {
            var plane = _a[_i];
            this.scene.remove(plane);
            this.sceneOld.add(plane);
        }
        for (var _b = 0, planes_1 = planes; _b < planes_1.length; _b++) {
            var plane = planes_1[_b];
            this.scene.add(plane);
        }
        this.imagePlanesOld = this.imagePlanes;
        this.imagePlanes = planes;
    };
    ImagePlaneScene.prototype.addImagePlanes = function (planes) {
        for (var _i = 0, planes_2 = planes; _i < planes_2.length; _i++) {
            var plane = planes_2[_i];
            this.scene.add(plane);
            this.imagePlanes.push(plane);
        }
    };
    ImagePlaneScene.prototype.addImagePlanesOld = function (planes) {
        for (var _i = 0, planes_3 = planes; _i < planes_3.length; _i++) {
            var plane = planes_3[_i];
            this.sceneOld.add(plane);
            this.imagePlanesOld.push(plane);
        }
    };
    ImagePlaneScene.prototype.setImagePlanes = function (planes) {
        this._clear();
        this.addImagePlanes(planes);
    };
    ImagePlaneScene.prototype.setImagePlanesOld = function (planes) {
        this._clearOld();
        this.addImagePlanesOld(planes);
    };
    ImagePlaneScene.prototype.clear = function () {
        this._clear();
        this._clearOld();
    };
    ImagePlaneScene.prototype._clear = function () {
        this._dispose(this.imagePlanes, this.scene);
        this.imagePlanes.length = 0;
    };
    ImagePlaneScene.prototype._clearOld = function () {
        this._dispose(this.imagePlanesOld, this.sceneOld);
        this.imagePlanesOld.length = 0;
    };
    ImagePlaneScene.prototype._dispose = function (planes, scene) {
        for (var _i = 0, planes_4 = planes; _i < planes_4.length; _i++) {
            var plane = planes_4[_i];
            scene.remove(plane);
            plane.geometry.dispose();
            plane.material.dispose();
            var texture = plane.material.uniforms.projectorTex.value;
            if (texture != null) {
                texture.dispose();
            }
        }
    };
    return ImagePlaneScene;
}());
exports.ImagePlaneScene = ImagePlaneScene;
exports.default = ImagePlaneScene;

},{"three":241}],325:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });

var path = require("path");
var ImagePlaneShaders = /** @class */ (function () {
    function ImagePlaneShaders() {
    }
    ImagePlaneShaders.equirectangular = {
        fragment: "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D projectorTex;\nuniform float opacity;\nuniform float phiLength;\nuniform float phiShift;\nuniform float thetaLength;\nuniform float thetaShift;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    vec3 b = normalize(vRstq.xyz);\n    float lat = -asin(b.y);\n    float lon = atan(b.x, b.z);\n    float x = (lon - phiShift) / phiLength + 0.5;\n    float y = (lat - thetaShift) / thetaLength + 0.5;\n    vec4 baseColor = texture2D(projectorTex, vec2(x, y));\n    baseColor.a = opacity;\n    gl_FragColor = baseColor;\n}",
        vertex: "#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform mat4 projectorMat;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    vRstq = projectorMat * vec4(position, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
    };
    ImagePlaneShaders.perspective = {
        fragment: "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D projectorTex;\nuniform float opacity;\nuniform vec4 bbox;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    float x = vRstq.x / vRstq.w;\n    float y = vRstq.y / vRstq.w;\n\n    vec4 baseColor;\n    if (x > bbox[0] && y > bbox[1] && x < bbox[2] && y < bbox[3]) {\n        baseColor = texture2D(projectorTex, vec2(x, y));\n        baseColor.a = opacity;\n    } else {\n        baseColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n\n    gl_FragColor = baseColor;\n}",
        vertex: "#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform mat4 projectorMat;\n\nvarying vec4 vRstq;\n\nvoid main()\n{\n    vRstq = projectorMat * vec4(position, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
    };
    return ImagePlaneShaders;
}());
exports.ImagePlaneShaders = ImagePlaneShaders;

},{"path":22}],326:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/observable/combineLatest");
require("rxjs/add/observable/fromEvent");
require("rxjs/add/observable/of");
require("rxjs/add/observable/zip");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/first");
require("rxjs/add/operator/map");
require("rxjs/add/operator/merge");
require("rxjs/add/operator/mergeMap");
require("rxjs/add/operator/scan");
require("rxjs/add/operator/switchMap");
require("rxjs/add/operator/withLatestFrom");
require("rxjs/add/operator/zip");
var State_1 = require("../../State");
var Render_1 = require("../../Render");
var Utils_1 = require("../../Utils");
var Component_1 = require("../../Component");
var SliderState = /** @class */ (function () {
    function SliderState() {
        this._imagePlaneFactory = new Component_1.ImagePlaneFactory();
        this._imagePlaneScene = new Component_1.ImagePlaneScene();
        this._currentKey = null;
        this._previousKey = null;
        this._currentPano = false;
        this._frameId = 0;
        this._glNeedsRender = false;
        this._domNeedsRender = true;
        this._curtain = 1;
    }
    Object.defineProperty(SliderState.prototype, "frameId", {
        get: function () {
            return this._frameId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderState.prototype, "curtain", {
        get: function () {
            return this._curtain;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderState.prototype, "glNeedsRender", {
        get: function () {
            return this._glNeedsRender;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderState.prototype, "domNeedsRender", {
        get: function () {
            return this._domNeedsRender;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderState.prototype, "sliderVisible", {
        get: function () {
            return this._sliderVisible;
        },
        set: function (value) {
            this._sliderVisible = value;
            this._domNeedsRender = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderState.prototype, "disabled", {
        get: function () {
            return this._currentKey == null ||
                this._previousKey == null ||
                this._currentPano;
        },
        enumerable: true,
        configurable: true
    });
    SliderState.prototype.update = function (frame) {
        this._updateFrameId(frame.id);
        var needsRender = this._updateImagePlanes(frame.state);
        this._domNeedsRender = needsRender || this._domNeedsRender;
        needsRender = this._updateCurtain(frame.state.alpha) || needsRender;
        this._glNeedsRender = needsRender || this._glNeedsRender;
    };
    SliderState.prototype.updateTexture = function (image, node) {
        var imagePlanes = node.key === this._currentKey ?
            this._imagePlaneScene.imagePlanes :
            node.key === this._previousKey ?
                this._imagePlaneScene.imagePlanesOld :
                [];
        if (imagePlanes.length === 0) {
            return;
        }
        this._glNeedsRender = true;
        for (var _i = 0, imagePlanes_1 = imagePlanes; _i < imagePlanes_1.length; _i++) {
            var plane = imagePlanes_1[_i];
            var material = plane.material;
            var texture = material.uniforms.projectorTex.value;
            texture.image = image;
            texture.needsUpdate = true;
        }
    };
    SliderState.prototype.render = function (perspectiveCamera, renderer) {
        if (!this.disabled) {
            renderer.render(this._imagePlaneScene.sceneOld, perspectiveCamera);
        }
        renderer.render(this._imagePlaneScene.scene, perspectiveCamera);
    };
    SliderState.prototype.dispose = function () {
        this._imagePlaneScene.clear();
    };
    SliderState.prototype.clearGLNeedsRender = function () {
        this._glNeedsRender = false;
    };
    SliderState.prototype.clearDomNeedsRender = function () {
        this._domNeedsRender = false;
    };
    SliderState.prototype._updateFrameId = function (frameId) {
        this._frameId = frameId;
    };
    SliderState.prototype._updateImagePlanes = function (state) {
        if (state.currentNode == null) {
            return;
        }
        var needsRender = false;
        if (state.previousNode != null && this._previousKey !== state.previousNode.key) {
            needsRender = true;
            this._previousKey = state.previousNode.key;
            this._imagePlaneScene.setImagePlanesOld([
                this._imagePlaneFactory.createMesh(state.previousNode, state.previousTransform),
            ]);
        }
        if (this._currentKey !== state.currentNode.key) {
            needsRender = true;
            this._currentKey = state.currentNode.key;
            this._currentPano = state.currentNode.pano;
            this._imagePlaneScene.setImagePlanes([
                this._imagePlaneFactory.createMesh(state.currentNode, state.currentTransform),
            ]);
            if (!this.disabled) {
                this._updateBbox();
            }
        }
        return needsRender;
    };
    SliderState.prototype._updateCurtain = function (alpha) {
        if (this.disabled ||
            Math.abs(this._curtain - alpha) < 0.001) {
            return false;
        }
        this._curtain = alpha;
        this._updateBbox();
        return true;
    };
    SliderState.prototype._updateBbox = function () {
        for (var _i = 0, _a = this._imagePlaneScene.imagePlanes; _i < _a.length; _i++) {
            var plane = _a[_i];
            var shaderMaterial = plane.material;
            var bbox = shaderMaterial.uniforms.bbox.value;
            bbox.z = this._curtain;
        }
    };
    return SliderState;
}());
var SliderComponent = /** @class */ (function (_super) {
    __extends(SliderComponent, _super);
    /**
     * Create a new slider component instance.
     * @class SliderComponent
     */
    function SliderComponent(name, container, navigator, dom) {
        var _this = _super.call(this, name, container, navigator) || this;
        _this._dom = !!dom ? dom : new Utils_1.DOM();
        _this._sliderStateOperation$ = new Subject_1.Subject();
        _this._sliderStateCreator$ = new Subject_1.Subject();
        _this._sliderStateDisposer$ = new Subject_1.Subject();
        _this._sliderState$ = _this._sliderStateOperation$
            .scan(function (sliderState, operation) {
            return operation(sliderState);
        }, null)
            .filter(function (sliderState) {
            return sliderState != null;
        })
            .distinctUntilChanged(undefined, function (sliderState) {
            return sliderState.frameId;
        });
        _this._sliderStateCreator$
            .map(function () {
            return function (sliderState) {
                if (sliderState != null) {
                    throw new Error("Multiple slider states can not be created at the same time");
                }
                return new SliderState();
            };
        })
            .subscribe(_this._sliderStateOperation$);
        _this._sliderStateDisposer$
            .map(function () {
            return function (sliderState) {
                sliderState.dispose();
                return null;
            };
        })
            .subscribe(_this._sliderStateOperation$);
        return _this;
    }
    /**
     * Set the image keys.
     *
     * Configures the component to show the image planes for the supplied image keys.
     *
     * @param {keys} ISliderKeys - Slider keys object specifying the images to be shown in the foreground and the background.
     */
    SliderComponent.prototype.setKeys = function (keys) {
        this.configure({ keys: keys });
    };
    /**
     * Set the initial position.
     *
     * Configures the intial position of the slider. The inital position value will be used when the component is activated.
     *
     * @param {number} initialPosition - Initial slider position.
     */
    SliderComponent.prototype.setInitialPosition = function (initialPosition) {
        this.configure({ initialPosition: initialPosition });
    };
    /**
     * Set the value controlling if the slider is visible.
     *
     * @param {boolean} sliderVisible - Value indicating if the slider should be visible or not.
     */
    SliderComponent.prototype.setSliderVisible = function (sliderVisible) {
        this.configure({ sliderVisible: sliderVisible });
    };
    SliderComponent.prototype._activate = function () {
        var _this = this;
        this._sliderContainer = this._dom.createElement("div", "mapillary-js-slider-container", this._container.element);
        this._sliderWrapper = this._dom.createElement("div", "SliderWrapper", this._sliderContainer);
        this._sliderControl = this._dom.createElement("input", "SliderControl", this._sliderWrapper);
        this._sliderControl.setAttribute("type", "range");
        this._sliderControl.setAttribute("min", "0");
        this._sliderControl.setAttribute("max", "1000");
        this._sliderControl.style.visibility = "hidden";
        this._moveToHandler = function (e) {
            var curtain = Number(e.target.value) / 1000;
            _this._navigator.stateService.moveTo(curtain);
        };
        this._sliderControl.addEventListener("input", this._moveToHandler);
        this._sliderControl.addEventListener("change", this._moveToHandler);
        Observable_1.Observable
            .combineLatest(this._navigator.stateService.state$, this._configuration$)
            .first()
            .subscribe(function (_a) {
            var state = _a[0], configuration = _a[1];
            if (state === State_1.State.Traversing) {
                _this._navigator.stateService.wait();
                var position = configuration.initialPosition != null ? configuration.initialPosition : 1;
                _this._sliderControl.value = (1000 * position).toString();
                _this._navigator.stateService.moveTo(position);
            }
        });
        this._glRenderSubscription = this._sliderState$
            .map(function (sliderState) {
            var renderHash = {
                name: _this._name,
                render: {
                    frameId: sliderState.frameId,
                    needsRender: sliderState.glNeedsRender,
                    render: sliderState.render.bind(sliderState),
                    stage: Render_1.GLRenderStage.Background,
                },
            };
            sliderState.clearGLNeedsRender();
            return renderHash;
        })
            .subscribe(this._container.glRenderer.render$);
        this._domRenderSubscription = this._sliderState$
            .filter(function (sliderState) {
            return sliderState.domNeedsRender;
        })
            .subscribe(function (sliderState) {
            _this._sliderControl.value = (1000 * sliderState.curtain).toString();
            var visibility = sliderState.disabled || !sliderState.sliderVisible ? "hidden" : "visible";
            _this._sliderControl.style.visibility = visibility;
            sliderState.clearDomNeedsRender();
        });
        this._sliderStateCreator$.next(null);
        this._stateSubscription = this._navigator.stateService.currentState$
            .map(function (frame) {
            return function (sliderState) {
                sliderState.update(frame);
                return sliderState;
            };
        })
            .subscribe(this._sliderStateOperation$);
        this._setSliderVisibleSubscription = this._configuration$
            .map(function (configuration) {
            return configuration.sliderVisible == null || configuration.sliderVisible;
        })
            .distinctUntilChanged()
            .map(function (sliderVisible) {
            return function (sliderState) {
                sliderState.sliderVisible = sliderVisible;
                return sliderState;
            };
        })
            .subscribe(this._sliderStateOperation$);
        this._setKeysSubscription = this._configuration$
            .filter(function (configuration) {
            return configuration.keys != null;
        })
            .switchMap(function (configuration) {
            return Observable_1.Observable
                .zip(_this._catchCacheNode$(configuration.keys.background), _this._catchCacheNode$(configuration.keys.foreground))
                .map(function (nodes) {
                return { background: nodes[0], foreground: nodes[1] };
            })
                .zip(_this._navigator.stateService.currentState$.first())
                .map(function (nf) {
                return { nodes: nf[0], state: nf[1].state };
            });
        })
            .subscribe(function (co) {
            if (co.state.currentNode != null &&
                co.state.previousNode != null &&
                co.state.currentNode.key === co.nodes.foreground.key &&
                co.state.previousNode.key === co.nodes.background.key) {
                return;
            }
            if (co.state.currentNode.key === co.nodes.background.key) {
                _this._navigator.stateService.setNodes([co.nodes.foreground]);
                return;
            }
            if (co.state.currentNode.key === co.nodes.foreground.key &&
                co.state.trajectory.length === 1) {
                _this._navigator.stateService.prependNodes([co.nodes.background]);
                return;
            }
            _this._navigator.stateService.setNodes([co.nodes.background]);
            _this._navigator.stateService.setNodes([co.nodes.foreground]);
        }, function (e) {
            console.error(e);
        });
        var previousNode$ = this._navigator.stateService.currentState$
            .map(function (frame) {
            return frame.state.previousNode;
        })
            .filter(function (node) {
            return node != null;
        })
            .distinctUntilChanged(undefined, function (node) {
            return node.key;
        });
        this._nodeSubscription = Observable_1.Observable
            .merge(previousNode$, this._navigator.stateService.currentNode$)
            .filter(function (node) {
            return node.pano ?
                Utils_1.Settings.maxImageSize > Utils_1.Settings.basePanoramaSize :
                Utils_1.Settings.maxImageSize > Utils_1.Settings.baseImageSize;
        })
            .mergeMap(function (node) {
            var baseImageSize = node.pano ?
                Utils_1.Settings.basePanoramaSize :
                Utils_1.Settings.baseImageSize;
            if (Math.max(node.image.width, node.image.height) > baseImageSize) {
                return Observable_1.Observable.empty();
            }
            return node.cacheImage$(Utils_1.Settings.maxImageSize)
                .map(function (n) {
                return [n.image, n];
            })
                .catch(function (error, caught) {
                console.error("Failed to fetch high res slider image (" + node.key + ")", error);
                return Observable_1.Observable.empty();
            });
        })
            .map(function (_a) {
            var element = _a[0], node = _a[1];
            return function (sliderState) {
                sliderState.updateTexture(element, node);
                return sliderState;
            };
        })
            .subscribe(this._sliderStateOperation$);
    };
    SliderComponent.prototype._deactivate = function () {
        var _this = this;
        this._navigator.stateService.state$
            .first()
            .subscribe(function (state) {
            if (state === State_1.State.Waiting) {
                _this._navigator.stateService.traverse();
            }
        });
        this._sliderStateDisposer$.next(null);
        this._setKeysSubscription.unsubscribe();
        this._setSliderVisibleSubscription.unsubscribe();
        this._stateSubscription.unsubscribe();
        this._glRenderSubscription.unsubscribe();
        this._domRenderSubscription.unsubscribe();
        this._nodeSubscription.unsubscribe();
        this.configure({ keys: null });
        this._sliderControl.removeEventListener("input", this._moveToHandler);
        this._sliderControl.removeEventListener("change", this._moveToHandler);
        this._container.element.removeChild(this._sliderContainer);
        this._moveToHandler = null;
        this._sliderControl = null;
        this._sliderWrapper = null;
        this._sliderContainer = null;
    };
    SliderComponent.prototype._getDefaultConfiguration = function () {
        return {};
    };
    SliderComponent.prototype._catchCacheNode$ = function (key) {
        return this._navigator.graphService.cacheNode$(key)
            .catch(function (error, caught) {
            console.error("Failed to cache slider node (" + key + ")", error);
            return Observable_1.Observable.empty();
        });
    };
    SliderComponent.componentName = "slider";
    return SliderComponent;
}(Component_1.Component));
exports.SliderComponent = SliderComponent;
Component_1.ComponentService.register(SliderComponent);
exports.default = SliderComponent;

},{"../../Component":291,"../../Render":297,"../../State":298,"../../Utils":301,"rxjs/Observable":29,"rxjs/Subject":34,"rxjs/add/observable/combineLatest":38,"rxjs/add/observable/fromEvent":43,"rxjs/add/observable/of":46,"rxjs/add/observable/zip":49,"rxjs/add/operator/distinctUntilChanged":60,"rxjs/add/operator/filter":63,"rxjs/add/operator/first":65,"rxjs/add/operator/map":67,"rxjs/add/operator/merge":68,"rxjs/add/operator/mergeMap":70,"rxjs/add/operator/scan":78,"rxjs/add/operator/switchMap":84,"rxjs/add/operator/withLatestFrom":90,"rxjs/add/operator/zip":91}],327:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CoverState;
(function (CoverState) {
    CoverState[CoverState["Hidden"] = 0] = "Hidden";
    CoverState[CoverState["Loading"] = 1] = "Loading";
    CoverState[CoverState["Visible"] = 2] = "Visible";
})(CoverState = exports.CoverState || (exports.CoverState = {}));

},{}],328:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ICoverConfiguration_1 = require("./ICoverConfiguration");
exports.CoverState = ICoverConfiguration_1.CoverState;

},{"./ICoverConfiguration":327}],329:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Component_1 = require("../../Component");
var Edge_1 = require("../../Edge");
/**
 * The `KeyPlayHandler` allows the user to control the play behavior
 * using the following key commands:
 *
 * `Spacebar`: Start or stop playing.
 * `SHIFT` + `D`: Switch direction.
 * `<`: Decrease speed.
 * `>`: Increase speed.
 *
 * @example
 * ```
 * var keyboardComponent = viewer.getComponent("keyboard");
 *
 * keyboardComponent.keyPlay.disable();
 * keyboardComponent.keyPlay.enable();
 *
 * var isEnabled = keyboardComponent.keyPlay.isEnabled;
 * ```
 */
var KeyPlayHandler = /** @class */ (function (_super) {
    __extends(KeyPlayHandler, _super);
    function KeyPlayHandler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    KeyPlayHandler.prototype._enable = function () {
        var _this = this;
        this._keyDownSubscription = this._container.keyboardService.keyDown$
            .withLatestFrom(this._navigator.playService.playing$, this._navigator.playService.direction$, this._navigator.playService.speed$, this._navigator.stateService.currentNode$
            .switchMap(function (node) {
            return node.sequenceEdges$;
        }))
            .subscribe(function (_a) {
            var event = _a[0], playing = _a[1], direction = _a[2], speed = _a[3], status = _a[4];
            if (event.altKey || event.ctrlKey || event.metaKey) {
                return;
            }
            switch (event.key) {
                case "D":
                    if (!event.shiftKey) {
                        return;
                    }
                    var newDirection = playing ?
                        null : direction === Edge_1.EdgeDirection.Next ?
                        Edge_1.EdgeDirection.Prev : direction === Edge_1.EdgeDirection.Prev ?
                        Edge_1.EdgeDirection.Next : null;
                    if (newDirection != null) {
                        _this._navigator.playService.setDirection(newDirection);
                    }
                    break;
                case " ":
                    if (event.shiftKey) {
                        return;
                    }
                    if (playing) {
                        _this._navigator.playService.stop();
                    }
                    else {
                        for (var _i = 0, _b = status.edges; _i < _b.length; _i++) {
                            var edge = _b[_i];
                            if (edge.data.direction === direction) {
                                _this._navigator.playService.play();
                            }
                        }
                    }
                    break;
                case "<":
                    _this._navigator.playService.setSpeed(speed - 0.05);
                    break;
                case ">":
                    _this._navigator.playService.setSpeed(speed + 0.05);
                    break;
                default:
                    return;
            }
            event.preventDefault();
        });
    };
    KeyPlayHandler.prototype._disable = function () {
        this._keyDownSubscription.unsubscribe();
    };
    KeyPlayHandler.prototype._getConfiguration = function (enable) {
        return { keyZoom: enable };
    };
    return KeyPlayHandler;
}(Component_1.HandlerBase));
exports.KeyPlayHandler = KeyPlayHandler;
exports.default = KeyPlayHandler;

},{"../../Component":291,"../../Edge":292}],330:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
require("rxjs/add/operator/switchMap");
require("rxjs/add/operator/withLatestFrom");
var Component_1 = require("../../Component");
var Edge_1 = require("../../Edge");
var Error_1 = require("../../Error");
/**
 * The `KeySequenceNavigationHandler` allows the user to navigate through a sequence using the
 * following key commands:
 *
 * `ALT` + `Up Arrow`: Navigate to next image in the sequence.
 * `ALT` + `Down Arrow`: Navigate to previous image in sequence.
 *
 * @example
 * ```
 * var keyboardComponent = viewer.getComponent("keyboard");
 *
 * keyboardComponent.keySequenceNavigation.disable();
 * keyboardComponent.keySequenceNavigation.enable();
 *
 * var isEnabled = keyboardComponent.keySequenceNavigation.isEnabled;
 * ```
 */
var KeySequenceNavigationHandler = /** @class */ (function (_super) {
    __extends(KeySequenceNavigationHandler, _super);
    function KeySequenceNavigationHandler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    KeySequenceNavigationHandler.prototype._enable = function () {
        var _this = this;
        var sequenceEdges$ = this._navigator.stateService.currentNode$
            .switchMap(function (node) {
            return node.sequenceEdges$;
        });
        this._keyDownSubscription = this._container.keyboardService.keyDown$
            .withLatestFrom(sequenceEdges$)
            .subscribe(function (_a) {
            var event = _a[0], edgeStatus = _a[1];
            var direction = null;
            switch (event.keyCode) {
                case 38:// up
                    direction = Edge_1.EdgeDirection.Next;
                    break;
                case 40:// down
                    direction = Edge_1.EdgeDirection.Prev;
                    break;
                default:
                    return;
            }
            event.preventDefault();
            if (!event.altKey || event.shiftKey || !edgeStatus.cached) {
                return;
            }
            for (var _i = 0, _b = edgeStatus.edges; _i < _b.length; _i++) {
                var edge = _b[_i];
                if (edge.data.direction === direction) {
                    _this._navigator.moveToKey$(edge.to)
                        .subscribe(undefined, function (error) {
                        if (!(error instanceof Error_1.AbortMapillaryError)) {
                            console.error(error);
                        }
                    });
                    return;
                }
            }
        });
    };
    KeySequenceNavigationHandler.prototype._disable = function () {
        this._keyDownSubscription.unsubscribe();
    };
    KeySequenceNavigationHandler.prototype._getConfiguration = function (enable) {
        return { keySequenceNavigation: enable };
    };
    return KeySequenceNavigationHandler;
}(Component_1.HandlerBase));
exports.KeySequenceNavigationHandler = KeySequenceNavigationHandler;
exports.default = KeySequenceNavigationHandler;

},{"../../Component":291,"../../Edge":292,"../../Error":293,"rxjs/add/operator/switchMap":84,"rxjs/add/operator/withLatestFrom":90}],331:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
require("rxjs/add/operator/switchMap");
require("rxjs/add/operator/withLatestFrom");
var Component_1 = require("../../Component");
var Edge_1 = require("../../Edge");
var Error_1 = require("../../Error");
/**
 * The `KeySpatialNavigationHandler` allows the user to navigate through a sequence using the
 * following key commands:
 *
 * `Up Arrow`: Step forward.
 * `Down Arrow`: Step backward.
 * `Left Arrow`: Step to the left.
 * `Rigth Arrow`: Step to the right.
 * `SHIFT` + `Down Arrow`: Turn around.
 * `SHIFT` + `Left Arrow`: Turn to the left.
 * `SHIFT` + `Rigth Arrow`: Turn to the right.
 *
 * @example
 * ```
 * var keyboardComponent = viewer.getComponent("keyboard");
 *
 * keyboardComponent.keySpatialNavigation.disable();
 * keyboardComponent.keySpatialNavigation.enable();
 *
 * var isEnabled = keyboardComponent.keySpatialNavigation.isEnabled;
 * ```
 */
var KeySpatialNavigationHandler = /** @class */ (function (_super) {
    __extends(KeySpatialNavigationHandler, _super);
    function KeySpatialNavigationHandler(component, container, navigator, spatial) {
        var _this = _super.call(this, component, container, navigator) || this;
        _this._spatial = spatial;
        return _this;
    }
    KeySpatialNavigationHandler.prototype._enable = function () {
        var _this = this;
        var spatialEdges$ = this._navigator.stateService.currentNode$
            .switchMap(function (node) {
            return node.spatialEdges$;
        });
        this._keyDownSubscription = this._container.keyboardService.keyDown$
            .withLatestFrom(spatialEdges$, this._navigator.stateService.currentState$)
            .subscribe(function (_a) {
            var event = _a[0], edgeStatus = _a[1], frame = _a[2];
            var pano = frame.state.currentNode.pano;
            var direction = null;
            switch (event.keyCode) {
                case 37:// left
                    direction = event.shiftKey && !pano ? Edge_1.EdgeDirection.TurnLeft : Edge_1.EdgeDirection.StepLeft;
                    break;
                case 38:// up
                    direction = event.shiftKey && !pano ? Edge_1.EdgeDirection.Pano : Edge_1.EdgeDirection.StepForward;
                    break;
                case 39:// right
                    direction = event.shiftKey && !pano ? Edge_1.EdgeDirection.TurnRight : Edge_1.EdgeDirection.StepRight;
                    break;
                case 40:// down
                    direction = event.shiftKey && !pano ? Edge_1.EdgeDirection.TurnU : Edge_1.EdgeDirection.StepBackward;
                    break;
                default:
                    return;
            }
            event.preventDefault();
            if (event.altKey || !edgeStatus.cached ||
                (event.shiftKey && pano)) {
                return;
            }
            if (!pano) {
                _this._moveDir(direction, edgeStatus);
            }
            else {
                var shifts = {};
                shifts[Edge_1.EdgeDirection.StepBackward] = Math.PI;
                shifts[Edge_1.EdgeDirection.StepForward] = 0;
                shifts[Edge_1.EdgeDirection.StepLeft] = Math.PI / 2;
                shifts[Edge_1.EdgeDirection.StepRight] = -Math.PI / 2;
                var phi = _this._rotationFromCamera(frame.state.camera).phi;
                var navigationAngle = _this._spatial.wrapAngle(phi + shifts[direction]);
                var threshold = Math.PI / 4;
                var edges = edgeStatus.edges.filter(function (e) {
                    return e.data.direction === Edge_1.EdgeDirection.Pano || e.data.direction === direction;
                });
                var smallestAngle = Number.MAX_VALUE;
                var toKey = null;
                for (var _i = 0, edges_1 = edges; _i < edges_1.length; _i++) {
                    var edge = edges_1[_i];
                    var angle = Math.abs(_this._spatial.wrapAngle(edge.data.worldMotionAzimuth - navigationAngle));
                    if (angle < Math.min(smallestAngle, threshold)) {
                        smallestAngle = angle;
                        toKey = edge.to;
                    }
                }
                if (toKey == null) {
                    return;
                }
                _this._moveToKey(toKey);
            }
        });
    };
    KeySpatialNavigationHandler.prototype._disable = function () {
        this._keyDownSubscription.unsubscribe();
    };
    KeySpatialNavigationHandler.prototype._getConfiguration = function (enable) {
        return { keySpatialNavigation: enable };
    };
    KeySpatialNavigationHandler.prototype._moveDir = function (direction, edgeStatus) {
        for (var _i = 0, _a = edgeStatus.edges; _i < _a.length; _i++) {
            var edge = _a[_i];
            if (edge.data.direction === direction) {
                this._moveToKey(edge.to);
                return;
            }
        }
    };
    KeySpatialNavigationHandler.prototype._moveToKey = function (key) {
        this._navigator.moveToKey$(key)
            .subscribe(undefined, function (error) {
            if (!(error instanceof Error_1.AbortMapillaryError)) {
                console.error(error);
            }
        });
    };
    KeySpatialNavigationHandler.prototype._rotationFromCamera = function (camera) {
        var direction = camera.lookat.clone().sub(camera.position);
        var upProjection = direction.clone().dot(camera.up);
        var planeProjection = direction.clone().sub(camera.up.clone().multiplyScalar(upProjection));
        var phi = Math.atan2(planeProjection.y, planeProjection.x);
        var theta = Math.PI / 2 - this._spatial.angleToPlane(direction.toArray(), [0, 0, 1]);
        return { phi: phi, theta: theta };
    };
    return KeySpatialNavigationHandler;
}(Component_1.HandlerBase));
exports.KeySpatialNavigationHandler = KeySpatialNavigationHandler;
exports.default = KeySpatialNavigationHandler;

},{"../../Component":291,"../../Edge":292,"../../Error":293,"rxjs/add/operator/switchMap":84,"rxjs/add/operator/withLatestFrom":90}],332:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
require("rxjs/add/operator/withLatestFrom");
var Component_1 = require("../../Component");
/**
 * The `KeyZoomHandler` allows the user to zoom in and out using the
 * following key commands:
 *
 * `+`: Zoom in.
 * `-`: Zoom out.
 *
 * @example
 * ```
 * var keyboardComponent = viewer.getComponent("keyboard");
 *
 * keyboardComponent.keyZoom.disable();
 * keyboardComponent.keyZoom.enable();
 *
 * var isEnabled = keyboardComponent.keyZoom.isEnabled;
 * ```
 */
var KeyZoomHandler = /** @class */ (function (_super) {
    __extends(KeyZoomHandler, _super);
    function KeyZoomHandler(component, container, navigator, viewportCoords) {
        var _this = _super.call(this, component, container, navigator) || this;
        _this._viewportCoords = viewportCoords;
        return _this;
    }
    KeyZoomHandler.prototype._enable = function () {
        var _this = this;
        this._keyDownSubscription = this._container.keyboardService.keyDown$
            .withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$)
            .subscribe(function (_a) {
            var event = _a[0], render = _a[1], transform = _a[2];
            if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
                return;
            }
            var delta = 0;
            switch (event.key) {
                case "+":
                    delta = 1;
                    break;
                case "-":
                    delta = -1;
                    break;
                default:
                    return;
            }
            event.preventDefault();
            var unprojected = _this._viewportCoords.unprojectFromViewport(0, 0, render.perspective);
            var reference = transform.projectBasic(unprojected.toArray());
            _this._navigator.stateService.zoomIn(delta, reference);
        });
    };
    KeyZoomHandler.prototype._disable = function () {
        this._keyDownSubscription.unsubscribe();
    };
    KeyZoomHandler.prototype._getConfiguration = function (enable) {
        return { keyZoom: enable };
    };
    return KeyZoomHandler;
}(Component_1.HandlerBase));
exports.KeyZoomHandler = KeyZoomHandler;
exports.default = KeyZoomHandler;

},{"../../Component":291,"rxjs/add/operator/withLatestFrom":90}],333:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Component_1 = require("../../Component");
var Geo_1 = require("../../Geo");
/**
 * @class KeyboardComponent
 *
 * @classdesc Component for keyboard event handling.
 *
 * To retrive and use the keyboard component
 *
 * @example
 * ```
 * var viewer = new Mapillary.Viewer(
 *     "<element-id>",
 *     "<client-id>",
 *     "<my key>");
 *
 * var keyboardComponent = viewer.getComponent("keyboard");
 * ```
 */
var KeyboardComponent = /** @class */ (function (_super) {
    __extends(KeyboardComponent, _super);
    function KeyboardComponent(name, container, navigator) {
        var _this = _super.call(this, name, container, navigator) || this;
        _this._keyPlayHandler = new Component_1.KeyPlayHandler(_this, container, navigator);
        _this._keySequenceNavigationHandler = new Component_1.KeySequenceNavigationHandler(_this, container, navigator);
        _this._keySpatialNavigationHandler = new Component_1.KeySpatialNavigationHandler(_this, container, navigator, new Geo_1.Spatial());
        _this._keyZoomHandler = new Component_1.KeyZoomHandler(_this, container, navigator, new Geo_1.ViewportCoords());
        return _this;
    }
    Object.defineProperty(KeyboardComponent.prototype, "keyPlay", {
        /**
         * Get key play.
         *
         * @returns {KeyPlayHandler} The key play handler.
         */
        get: function () {
            return this._keyPlayHandler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KeyboardComponent.prototype, "keySequenceNavigation", {
        /**
         * Get key sequence navigation.
         *
         * @returns {KeySequenceNavigationHandler} The key sequence navigation handler.
         */
        get: function () {
            return this._keySequenceNavigationHandler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KeyboardComponent.prototype, "keySpatialNavigation", {
        /**
         * Get spatial.
         *
         * @returns {KeySpatialNavigationHandler} The spatial handler.
         */
        get: function () {
            return this._keySpatialNavigationHandler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KeyboardComponent.prototype, "keyZoom", {
        /**
         * Get key zoom.
         *
         * @returns {KeyZoomHandler} The key zoom handler.
         */
        get: function () {
            return this._keyZoomHandler;
        },
        enumerable: true,
        configurable: true
    });
    KeyboardComponent.prototype._activate = function () {
        var _this = this;
        this._configurationSubscription = this._configuration$
            .subscribe(function (configuration) {
            if (configuration.keyPlay) {
                _this._keyPlayHandler.enable();
            }
            else {
                _this._keyPlayHandler.disable();
            }
            if (configuration.keySequenceNavigation) {
                _this._keySequenceNavigationHandler.enable();
            }
            else {
                _this._keySequenceNavigationHandler.disable();
            }
            if (configuration.keySpatialNavigation) {
                _this._keySpatialNavigationHandler.enable();
            }
            else {
                _this._keySpatialNavigationHandler.disable();
            }
            if (configuration.keyZoom) {
                _this._keyZoomHandler.enable();
            }
            else {
                _this._keyZoomHandler.disable();
            }
        });
    };
    KeyboardComponent.prototype._deactivate = function () {
        this._configurationSubscription.unsubscribe();
        this._keyPlayHandler.disable();
        this._keySequenceNavigationHandler.disable();
        this._keySpatialNavigationHandler.disable();
        this._keyZoomHandler.disable();
    };
    KeyboardComponent.prototype._getDefaultConfiguration = function () {
        return { keyPlay: true, keySequenceNavigation: true, keySpatialNavigation: true, keyZoom: true };
    };
    KeyboardComponent.componentName = "keyboard";
    return KeyboardComponent;
}(Component_1.Component));
exports.KeyboardComponent = KeyboardComponent;
Component_1.ComponentService.register(KeyboardComponent);
exports.default = KeyboardComponent;

},{"../../Component":291,"../../Geo":294}],334:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MarkerComponent_1 = require("./MarkerComponent");
exports.MarkerComponent = MarkerComponent_1.MarkerComponent;
var SimpleMarker_1 = require("./marker/SimpleMarker");
exports.SimpleMarker = SimpleMarker_1.SimpleMarker;
var CircleMarker_1 = require("./marker/CircleMarker");
exports.CircleMarker = CircleMarker_1.CircleMarker;

},{"./MarkerComponent":335,"./marker/CircleMarker":338,"./marker/SimpleMarker":340}],335:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var when = require("when");
var Observable_1 = require("rxjs/Observable");
require("rxjs/add/observable/combineLatest");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/map");
var Component_1 = require("../../Component");
var Render_1 = require("../../Render");
var Graph_1 = require("../../Graph");
var Geo_1 = require("../../Geo");
/**
 * @class MarkerComponent
 *
 * @classdesc Component for showing and editing 3D marker objects.
 *
 * The `add` method is used for adding new markers or replacing
 * markers already in the set.
 *
 * If a marker already in the set has the same
 * id as one of the markers added, the old marker will be removed and
 * the added marker will take its place.
 *
 * It is not possible to update markers in the set by updating any properties
 * directly on the marker object. Markers need to be replaced by
 * re-adding them for updates to geographic position or configuration
 * to be reflected.
 *
 * Markers added to the marker component can be either interactive
 * or non-interactive. Different marker types define their behavior.
 * Markers with interaction support can be configured with options
 * to respond to dragging inside the viewer and be detected when
 * retrieving markers from pixel points with the `getMarkerIdAt` method.
 *
 * To retrive and use the marker component
 *
 * @example
 * ```
 * var viewer = new Mapillary.Viewer(
 *     "<element-id>",
 *     "<client-id>",
 *     "<my key>",
 *     { component: { marker: true } });
 *
 * var markerComponent = viewer.getComponent("marker");
 * ```
 */
var MarkerComponent = /** @class */ (function (_super) {
    __extends(MarkerComponent, _super);
    function MarkerComponent(name, container, navigator) {
        var _this = _super.call(this, name, container, navigator) || this;
        _this._relativeGroundAltitude = -2;
        _this._geoCoords = new Geo_1.GeoCoords();
        _this._graphCalculator = new Graph_1.GraphCalculator();
        _this._markerScene = new Component_1.MarkerScene();
        _this._markerSet = new Component_1.MarkerSet();
        _this._viewportCoords = new Geo_1.ViewportCoords();
        return _this;
    }
    /**
     * Add markers to the marker set or replace markers in the marker set.
     *
     * @description If a marker already in the set has the same
     * id as one of the markers added, the old marker will be removed
     * the added marker will take its place.
     *
     * Any marker inside the visible bounding bbox
     * will be initialized and placed in the viewer.
     *
     * @param {Array<Marker>} markers - Markers to add.
     *
     * @example ```markerComponent.add([marker1, marker2]);```
     */
    MarkerComponent.prototype.add = function (markers) {
        this._markerSet.add(markers);
    };
    /**
     * Returns the marker in the marker set with the specified id, or
     * undefined if the id matches no marker.
     *
     * @param {string} markerId - Id of the marker.
     *
     * @example ```var marker = markerComponent.get("markerId");```
     *
     */
    MarkerComponent.prototype.get = function (markerId) {
        return this._markerSet.get(markerId);
    };
    /**
     * Returns an array of all markers.
     *
     * @example ```var markers = markerComponent.getAll();```
     */
    MarkerComponent.prototype.getAll = function () {
        return this._markerSet.getAll();
    };
    /**
     * Returns the id of the interactive marker closest to the current camera
     * position at the specified point.
     *
     * @description Notice that the pixelPoint argument requires x, y
     * coordinates from pixel space.
     *
     * With this function, you can use the coordinates provided by mouse
     * events to get information out of the marker component.
     *
     * If no interactive geometry of an interactive marker exist at the pixel
     * point, `null` will be returned.
     *
     * @param {Array<number>} pixelPoint - Pixel coordinates on the viewer element.
     * @returns {string} Id of the interactive marker closest to the camera. If no
     * interactive marker exist at the pixel point, `null` will be returned.
     *
     * @example
     * ```
     * markerComponent.getMarkerIdAt([100, 100])
     *     .then((markerId) => { console.log(markerId); });
     * ```
     */
    MarkerComponent.prototype.getMarkerIdAt = function (pixelPoint) {
        var _this = this;
        return when.promise(function (resolve, reject) {
            _this._container.renderService.renderCamera$
                .first()
                .map(function (render) {
                var viewport = _this._viewportCoords
                    .canvasToViewport(pixelPoint[0], pixelPoint[1], _this._container.element);
                var id = _this._markerScene.intersectObjects(viewport, render.perspective);
                return id;
            })
                .subscribe(function (id) {
                resolve(id);
            }, function (error) {
                reject(error);
            });
        });
    };
    /**
     * Check if a marker exist in the marker set.
     *
     * @param {string} markerId - Id of the marker.
     *
     * @example ```var markerExists = markerComponent.has("markerId");```
     */
    MarkerComponent.prototype.has = function (markerId) {
        return this._markerSet.has(markerId);
    };
    /**
     * Remove markers with the specified ids from the marker set.
     *
     * @param {Array<string>} markerIds - Ids for markers to remove.
     *
     * @example ```markerComponent.remove(["id-1", "id-2"]);```
     */
    MarkerComponent.prototype.remove = function (markerIds) {
        this._markerSet.remove(markerIds);
    };
    /**
     * Remove all markers from the marker set.
     *
     * @example ```markerComponent.removeAll();```
     */
    MarkerComponent.prototype.removeAll = function () {
        this._markerSet.removeAll();
    };
    MarkerComponent.prototype._activate = function () {
        var _this = this;
        var groundAltitude$ = this._navigator.stateService.currentState$
            .map(function (frame) {
            return frame.state.camera.position.z + _this._relativeGroundAltitude;
        })
            .distinctUntilChanged(function (a1, a2) {
            return Math.abs(a1 - a2) < 0.01;
        })
            .publishReplay(1)
            .refCount();
        var geoInitiated$ = Observable_1.Observable
            .combineLatest(groundAltitude$, this._navigator.stateService.reference$)
            .first()
            .map(function () { })
            .publishReplay(1)
            .refCount();
        var clampedConfiguration$ = this._configuration$
            .map(function (configuration) {
            return { visibleBBoxSize: Math.max(1, Math.min(200, configuration.visibleBBoxSize)) };
        });
        var currentlatLon$ = this._navigator.stateService.currentNode$
            .map(function (node) { return node.latLon; })
            .publishReplay(1)
            .refCount();
        var visibleBBox$ = Observable_1.Observable
            .combineLatest(clampedConfiguration$, currentlatLon$)
            .map(function (_a) {
            var configuration = _a[0], latLon = _a[1];
            return _this._graphCalculator
                .boundingBoxCorners(latLon, configuration.visibleBBoxSize / 2);
        })
            .publishReplay(1)
            .refCount();
        var visibleMarkers$ = Observable_1.Observable
            .combineLatest(Observable_1.Observable
            .of(this._markerSet)
            .concat(this._markerSet.changed$), visibleBBox$)
            .map(function (_a) {
            var set = _a[0], bbox = _a[1];
            return set.search(bbox);
        });
        this._setChangedSubscription = geoInitiated$
            .switchMap(function () {
            return visibleMarkers$
                .withLatestFrom(_this._navigator.stateService.reference$, groundAltitude$);
        })
            .subscribe(function (_a) {
            var markers = _a[0], reference = _a[1], alt = _a[2];
            var geoCoords = _this._geoCoords;
            var markerScene = _this._markerScene;
            var sceneMarkers = markerScene.markers;
            var markersToRemove = Object.assign({}, sceneMarkers);
            for (var _i = 0, markers_1 = markers; _i < markers_1.length; _i++) {
                var marker = markers_1[_i];
                if (marker.id in sceneMarkers) {
                    delete markersToRemove[marker.id];
                }
                else {
                    var point3d = geoCoords
                        .geodeticToEnu(marker.latLon.lat, marker.latLon.lon, reference.alt + alt, reference.lat, reference.lon, reference.alt);
                    markerScene.add(marker, point3d);
                }
            }
            for (var id in markersToRemove) {
                if (!markersToRemove.hasOwnProperty(id)) {
                    continue;
                }
                markerScene.remove(id);
            }
        });
        this._markersUpdatedSubscription = geoInitiated$
            .switchMap(function () {
            return _this._markerSet.updated$
                .withLatestFrom(visibleBBox$, _this._navigator.stateService.reference$, groundAltitude$);
        })
            .subscribe(function (_a) {
            var markers = _a[0], _b = _a[1], sw = _b[0], ne = _b[1], reference = _a[2], alt = _a[3];
            var geoCoords = _this._geoCoords;
            var markerScene = _this._markerScene;
            for (var _i = 0, markers_2 = markers; _i < markers_2.length; _i++) {
                var marker = markers_2[_i];
                var exists = markerScene.has(marker.id);
                var visible = marker.latLon.lat > sw.lat &&
                    marker.latLon.lat < ne.lat &&
                    marker.latLon.lon > sw.lon &&
                    marker.latLon.lon < ne.lon;
                if (visible) {
                    var point3d = geoCoords
                        .geodeticToEnu(marker.latLon.lat, marker.latLon.lon, reference.alt + alt, reference.lat, reference.lon, reference.alt);
                    markerScene.add(marker, point3d);
                }
                else if (!visible && exists) {
                    markerScene.remove(marker.id);
                }
            }
        });
        this._referenceSubscription = this._navigator.stateService.reference$
            .skip(1)
            .withLatestFrom(groundAltitude$)
            .subscribe(function (_a) {
            var reference = _a[0], alt = _a[1];
            var geoCoords = _this._geoCoords;
            var markerScene = _this._markerScene;
            for (var _i = 0, _b = markerScene.getAll(); _i < _b.length; _i++) {
                var marker = _b[_i];
                var point3d = geoCoords
                    .geodeticToEnu(marker.latLon.lat, marker.latLon.lon, reference.alt + alt, reference.lat, reference.lon, reference.alt);
                markerScene.update(marker.id, point3d);
            }
        });
        this._adjustHeightSubscription = groundAltitude$
            .skip(1)
            .withLatestFrom(this._navigator.stateService.reference$, currentlatLon$)
            .subscribe(function (_a) {
            var alt = _a[0], reference = _a[1], latLon = _a[2];
            var geoCoords = _this._geoCoords;
            var markerScene = _this._markerScene;
            var position = geoCoords
                .geodeticToEnu(latLon.lat, latLon.lon, reference.alt + alt, reference.lat, reference.lon, reference.alt);
            for (var _i = 0, _b = markerScene.getAll(); _i < _b.length; _i++) {
                var marker = _b[_i];
                var point3d = geoCoords
                    .geodeticToEnu(marker.latLon.lat, marker.latLon.lon, reference.alt + alt, reference.lat, reference.lon, reference.alt);
                var distanceX = point3d[0] - position[0];
                var distanceY = point3d[1] - position[1];
                var groundDistance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                if (groundDistance > 50) {
                    continue;
                }
                markerScene.lerpAltitude(marker.id, alt, Math.min(1, Math.max(0, 1.2 - 1.2 * groundDistance / 50)));
            }
        });
        this._renderSubscription = this._navigator.stateService.currentState$
            .map(function (frame) {
            var scene = _this._markerScene;
            return {
                name: _this._name,
                render: {
                    frameId: frame.id,
                    needsRender: scene.needsRender,
                    render: scene.render.bind(scene),
                    stage: Render_1.GLRenderStage.Foreground,
                },
            };
        })
            .subscribe(this._container.glRenderer.render$);
        var hoveredMarkerId$ = Observable_1.Observable
            .combineLatest(this._container.renderService.renderCamera$, this._container.mouseService.mouseMove$)
            .map(function (_a) {
            var render = _a[0], event = _a[1];
            var element = _this._container.element;
            var _b = _this._viewportCoords.canvasPosition(event, element), canvasX = _b[0], canvasY = _b[1];
            var viewport = _this._viewportCoords.canvasToViewport(canvasX, canvasY, element);
            var markerId = _this._markerScene.intersectObjects(viewport, render.perspective);
            return markerId;
        })
            .publishReplay(1)
            .refCount();
        var draggingStarted$ = this._container.mouseService
            .filtered$(this._name, this._container.mouseService.mouseDragStart$)
            .map(function (event) {
            return true;
        });
        var draggingStopped$ = this._container.mouseService
            .filtered$(this._name, this._container.mouseService.mouseDragEnd$)
            .map(function (event) {
            return false;
        });
        var filteredDragging$ = Observable_1.Observable
            .merge(draggingStarted$, draggingStopped$)
            .startWith(false);
        this._dragEventSubscription = draggingStarted$
            .withLatestFrom(hoveredMarkerId$)
            .merge(Observable_1.Observable
            .combineLatest(draggingStopped$, Observable_1.Observable.of(null)))
            .startWith([false, null])
            .pairwise()
            .subscribe(function (_a) {
            var previous = _a[0], current = _a[1];
            var dragging = current[0];
            var eventType = dragging ? MarkerComponent.dragstart : MarkerComponent.dragend;
            var id = dragging ? current[1] : previous[1];
            var marker = _this._markerScene.get(id);
            var markerEvent = { marker: marker, target: _this, type: eventType };
            _this.fire(eventType, markerEvent);
        });
        var mouseDown$ = Observable_1.Observable
            .merge(this._container.mouseService.mouseDown$
            .map(function (event) { return true; }), this._container.mouseService.documentMouseUp$
            .map(function (event) { return false; }))
            .startWith(false);
        this._mouseClaimSubscription = Observable_1.Observable
            .combineLatest(this._container.mouseService.active$, hoveredMarkerId$.distinctUntilChanged(), mouseDown$, filteredDragging$)
            .map(function (_a) {
            var active = _a[0], markerId = _a[1], mouseDown = _a[2], filteredDragging = _a[3];
            return (!active && markerId != null && mouseDown) || filteredDragging;
        })
            .distinctUntilChanged()
            .subscribe(function (claim) {
            if (claim) {
                _this._container.mouseService.claimMouse(_this._name, 1);
                _this._container.mouseService.claimWheel(_this._name, 1);
            }
            else {
                _this._container.mouseService.unclaimMouse(_this._name);
                _this._container.mouseService.unclaimWheel(_this._name);
            }
        });
        var offset$ = this._container.mouseService
            .filtered$(this._name, this._container.mouseService.mouseDragStart$)
            .withLatestFrom(hoveredMarkerId$, this._container.renderService.renderCamera$)
            .map(function (_a) {
            var e = _a[0], id = _a[1], r = _a[2];
            var marker = _this._markerScene.get(id);
            var element = _this._container.element;
            var _b = _this._viewportCoords.projectToCanvas(marker.geometry.position.toArray(), element, r.perspective), groundCanvasX = _b[0], groundCanvasY = _b[1];
            var _c = _this._viewportCoords.canvasPosition(e, element), canvasX = _c[0], canvasY = _c[1];
            var offset = [canvasX - groundCanvasX, canvasY - groundCanvasY];
            return [marker, offset, r];
        })
            .publishReplay(1)
            .refCount();
        this._updateMarkerSubscription = this._container.mouseService
            .filtered$(this._name, this._container.mouseService.mouseDrag$)
            .withLatestFrom(offset$, this._navigator.stateService.reference$, clampedConfiguration$)
            .subscribe(function (_a) {
            var event = _a[0], _b = _a[1], marker = _b[0], offset = _b[1], render = _b[2], reference = _a[2], configuration = _a[3];
            if (!_this._markerScene.has(marker.id)) {
                return;
            }
            var element = _this._container.element;
            var _c = _this._viewportCoords.canvasPosition(event, element), canvasX = _c[0], canvasY = _c[1];
            var groundX = canvasX - offset[0];
            var groundY = canvasY - offset[1];
            var _d = _this._viewportCoords
                .canvasToViewport(groundX, groundY, element), viewportX = _d[0], viewportY = _d[1];
            var direction = new THREE.Vector3(viewportX, viewportY, 1)
                .unproject(render.perspective)
                .sub(render.perspective.position)
                .normalize();
            var distance = Math.min(_this._relativeGroundAltitude / direction.z, configuration.visibleBBoxSize / 2 - 0.1);
            if (distance < 0) {
                return;
            }
            var intersection = direction
                .clone()
                .multiplyScalar(distance)
                .add(render.perspective.position);
            intersection.z = render.perspective.position.z + _this._relativeGroundAltitude;
            var _e = _this._geoCoords
                .enuToGeodetic(intersection.x, intersection.y, intersection.z, reference.lat, reference.lon, reference.alt), lat = _e[0], lon = _e[1];
            _this._markerScene.update(marker.id, intersection.toArray(), { lat: lat, lon: lon });
            _this._markerSet.update(marker);
            var markerEvent = { marker: marker, target: _this, type: MarkerComponent.changed };
            _this.fire(MarkerComponent.changed, markerEvent);
        });
    };
    MarkerComponent.prototype._deactivate = function () {
        this._adjustHeightSubscription.unsubscribe();
        this._dragEventSubscription.unsubscribe();
        this._markersUpdatedSubscription.unsubscribe();
        this._mouseClaimSubscription.unsubscribe();
        this._referenceSubscription.unsubscribe();
        this._renderSubscription.unsubscribe();
        this._setChangedSubscription.unsubscribe();
        this._updateMarkerSubscription.unsubscribe();
        this._markerScene.clear();
    };
    MarkerComponent.prototype._getDefaultConfiguration = function () {
        return { visibleBBoxSize: 100 };
    };
    MarkerComponent.componentName = "marker";
    /**
     * Fired when the position of a marker is changed.
     * @event
     * @type {IMarkerEvent} markerEvent - Marker event data.
     * @example
     * ```
     * markerComponent.on("changed", function(e) {
     *     console.log(e.marker.id, e.marker.latLon);
     * });
     * ```
     */
    MarkerComponent.changed = "changed";
    /**
     * Fired when a marker drag interaction starts.
     * @event
     * @type {IMarkerEvent} markerEvent - Marker event data.
     * @example
     * ```
     * markerComponent.on("dragstart", function(e) {
     *     console.log(e.marker.id, e.marker.latLon);
     * });
     * ```
     */
    MarkerComponent.dragstart = "dragstart";
    /**
     * Fired when a marker drag interaction ends.
     * @event
     * @type {IMarkerEvent} markerEvent - Marker event data.
     * @example
     * ```
     * markerComponent.on("dragend", function(e) {
     *     console.log(e.marker.id, e.marker.latLon);
     * });
     * ```
     */
    MarkerComponent.dragend = "dragend";
    return MarkerComponent;
}(Component_1.Component));
exports.MarkerComponent = MarkerComponent;
Component_1.ComponentService.register(MarkerComponent);
exports.default = MarkerComponent;

},{"../../Component":291,"../../Geo":294,"../../Graph":295,"../../Render":297,"rxjs/Observable":29,"rxjs/add/observable/combineLatest":38,"rxjs/add/operator/distinctUntilChanged":60,"rxjs/add/operator/map":67,"three":241,"when":288}],336:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var MarkerScene = /** @class */ (function () {
    function MarkerScene(scene, raycaster) {
        this._needsRender = false;
        this._interactiveObjects = [];
        this._markers = {};
        this._objectMarkers = {};
        this._raycaster = !!raycaster ? raycaster : new THREE.Raycaster();
        this._scene = !!scene ? scene : new THREE.Scene();
    }
    Object.defineProperty(MarkerScene.prototype, "markers", {
        get: function () {
            return this._markers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MarkerScene.prototype, "needsRender", {
        get: function () {
            return this._needsRender;
        },
        enumerable: true,
        configurable: true
    });
    MarkerScene.prototype.add = function (marker, position) {
        if (marker.id in this._markers) {
            this._dispose(marker.id);
        }
        marker.createGeometry(position);
        this._scene.add(marker.geometry);
        this._markers[marker.id] = marker;
        for (var _i = 0, _a = marker.getInteractiveObjects(); _i < _a.length; _i++) {
            var interactiveObject = _a[_i];
            this._interactiveObjects.push(interactiveObject);
            this._objectMarkers[interactiveObject.uuid] = marker.id;
        }
        this._needsRender = true;
    };
    MarkerScene.prototype.clear = function () {
        for (var id in this._markers) {
            if (!this._markers.hasOwnProperty) {
                continue;
            }
            this._dispose(id);
        }
        this._needsRender = true;
    };
    MarkerScene.prototype.get = function (id) {
        return this._markers[id];
    };
    MarkerScene.prototype.getAll = function () {
        var _this = this;
        return Object
            .keys(this._markers)
            .map(function (id) { return _this._markers[id]; });
    };
    MarkerScene.prototype.has = function (id) {
        return id in this._markers;
    };
    MarkerScene.prototype.intersectObjects = function (_a, camera) {
        var viewportX = _a[0], viewportY = _a[1];
        this._raycaster.setFromCamera(new THREE.Vector2(viewportX, viewportY), camera);
        var intersects = this._raycaster.intersectObjects(this._interactiveObjects);
        for (var _i = 0, intersects_1 = intersects; _i < intersects_1.length; _i++) {
            var intersect = intersects_1[_i];
            if (intersect.object.uuid in this._objectMarkers) {
                return this._objectMarkers[intersect.object.uuid];
            }
        }
        return null;
    };
    MarkerScene.prototype.lerpAltitude = function (id, alt, alpha) {
        if (!(id in this._markers)) {
            return;
        }
        this._markers[id].lerpAltitude(alt, alpha);
        this._needsRender = true;
    };
    MarkerScene.prototype.remove = function (id) {
        if (!(id in this._markers)) {
            return;
        }
        this._dispose(id);
        this._needsRender = true;
    };
    MarkerScene.prototype.render = function (perspectiveCamera, renderer) {
        renderer.render(this._scene, perspectiveCamera);
        this._needsRender = false;
    };
    MarkerScene.prototype.update = function (id, position, latLon) {
        if (!(id in this._markers)) {
            return;
        }
        var marker = this._markers[id];
        marker.updatePosition(position, latLon);
        this._needsRender = true;
    };
    MarkerScene.prototype._dispose = function (id) {
        var marker = this._markers[id];
        this._scene.remove(marker.geometry);
        for (var _i = 0, _a = marker.getInteractiveObjects(); _i < _a.length; _i++) {
            var interactiveObject = _a[_i];
            var index = this._interactiveObjects.indexOf(interactiveObject);
            if (index !== -1) {
                this._interactiveObjects.splice(index, 1);
            }
            else {
                console.warn("Object does not exist (" + interactiveObject.id + ") for " + id);
            }
            delete this._objectMarkers[interactiveObject.uuid];
        }
        marker.disposeGeometry();
        delete this._markers[id];
    };
    return MarkerScene;
}());
exports.MarkerScene = MarkerScene;
exports.default = MarkerScene;

},{"three":241}],337:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var rbush = require("rbush");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/operator/map");
require("rxjs/add/operator/publishReplay");
require("rxjs/add/operator/scan");
var MarkerSet = /** @class */ (function () {
    function MarkerSet() {
        this._hash = {};
        this._index = rbush(16, [".lon", ".lat", ".lon", ".lat"]);
        this._indexChanged$ = new Subject_1.Subject();
        this._updated$ = new Subject_1.Subject();
    }
    Object.defineProperty(MarkerSet.prototype, "changed$", {
        get: function () {
            return this._indexChanged$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MarkerSet.prototype, "updated$", {
        get: function () {
            return this._updated$;
        },
        enumerable: true,
        configurable: true
    });
    MarkerSet.prototype.add = function (markers) {
        var updated = [];
        var hash = this._hash;
        var index = this._index;
        for (var _i = 0, markers_1 = markers; _i < markers_1.length; _i++) {
            var marker = markers_1[_i];
            var id = marker.id;
            if (id in hash) {
                index.remove(hash[id]);
                updated.push(marker);
            }
            var item = {
                lat: marker.latLon.lat,
                lon: marker.latLon.lon,
                marker: marker,
            };
            hash[id] = item;
            index.insert(item);
        }
        if (updated.length > 0) {
            this._updated$.next(updated);
        }
        if (markers.length > updated.length) {
            this._indexChanged$.next(this);
        }
    };
    MarkerSet.prototype.has = function (id) {
        return id in this._hash;
    };
    MarkerSet.prototype.get = function (id) {
        return this.has(id) ? this._hash[id].marker : undefined;
    };
    MarkerSet.prototype.getAll = function () {
        return this._index
            .all()
            .map(function (indexItem) {
            return indexItem.marker;
        });
    };
    MarkerSet.prototype.remove = function (ids) {
        var hash = this._hash;
        var index = this._index;
        var changed = false;
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var id = ids_1[_i];
            if (!(id in hash)) {
                continue;
            }
            var item = hash[id];
            index.remove(item);
            delete hash[id];
            changed = true;
        }
        if (changed) {
            this._indexChanged$.next(this);
        }
    };
    MarkerSet.prototype.removeAll = function () {
        this._hash = {};
        this._index.clear();
        this._indexChanged$.next(this);
    };
    MarkerSet.prototype.search = function (_a) {
        var sw = _a[0], ne = _a[1];
        return this._index
            .search({ maxX: ne.lon, maxY: ne.lat, minX: sw.lon, minY: sw.lat })
            .map(function (indexItem) {
            return indexItem.marker;
        });
    };
    MarkerSet.prototype.update = function (marker) {
        var hash = this._hash;
        var index = this._index;
        var id = marker.id;
        if (!(id in hash)) {
            return;
        }
        index.remove(hash[id]);
        var item = {
            lat: marker.latLon.lat,
            lon: marker.latLon.lon,
            marker: marker,
        };
        hash[id] = item;
        index.insert(item);
    };
    return MarkerSet;
}());
exports.MarkerSet = MarkerSet;
exports.default = MarkerSet;

},{"rbush":25,"rxjs/Subject":34,"rxjs/add/operator/map":67,"rxjs/add/operator/publishReplay":74,"rxjs/add/operator/scan":78}],338:[function(require,module,exports){
"use strict";
/// <reference path="../../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var Component_1 = require("../../../Component");
/**
 * @class CircleMarker
 *
 * @classdesc Non-interactive marker with a flat circle shape. The circle
 * marker can not be configured to be interactive.
 *
 * Circle marker properties can not be updated after creation.
 *
 * To create and add one `CircleMarker` with default configuration
 * and one with configuration use
 *
 * @example
 * ```
 * var defaultMarker = new Mapillary.MarkerComponent.CircleMarker(
 *     "id-1",
 *     { lat: 0, lon: 0, });
 *
 * var configuredMarker = new Mapillary.MarkerComponent.CircleMarker(
 *     "id-2",
 *     { lat: 0, lon: 0, },
 *     {
 *         color: "#0Ff",
 *         opacity: 0.3,
 *         radius: 0.7,
 *     });
 *
 * markerComponent.add([defaultMarker, configuredMarker]);
 * ```
 */
var CircleMarker = /** @class */ (function (_super) {
    __extends(CircleMarker, _super);
    function CircleMarker(id, latLon, options) {
        var _this = _super.call(this, id, latLon) || this;
        options = !!options ? options : {};
        _this._color = options.color != null ? options.color : 0xffffff;
        _this._opacity = options.opacity != null ? options.opacity : 0.4;
        _this._radius = options.radius != null ? options.radius : 1;
        return _this;
    }
    CircleMarker.prototype._createGeometry = function (position) {
        var circle = new THREE.Mesh(new THREE.CircleGeometry(this._radius, 16), new THREE.MeshBasicMaterial({
            color: this._color,
            opacity: this._opacity,
            transparent: true,
        }));
        circle.up.fromArray([0, 0, 1]);
        circle.renderOrder = -1;
        var group = new THREE.Object3D();
        group.add(circle);
        group.position.fromArray(position);
        this._geometry = group;
    };
    CircleMarker.prototype._disposeGeometry = function () {
        for (var _i = 0, _a = this._geometry.children; _i < _a.length; _i++) {
            var mesh = _a[_i];
            mesh.geometry.dispose();
            mesh.material.dispose();
        }
    };
    CircleMarker.prototype._getInteractiveObjects = function () {
        return [];
    };
    return CircleMarker;
}(Component_1.Marker));
exports.CircleMarker = CircleMarker;
exports.default = CircleMarker;

},{"../../../Component":291,"three":241}],339:[function(require,module,exports){
"use strict";
/// <reference path="../../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @class Marker
 *
 * @classdesc Represents an abstract marker class that should be extended
 * by marker implementations used in the marker component.
 */
var Marker = /** @class */ (function () {
    function Marker(id, latLon) {
        this._id = id;
        this._latLon = latLon;
    }
    Object.defineProperty(Marker.prototype, "id", {
        /**
         * Get id.
         * @returns {string} The id of the marker.
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Marker.prototype, "geometry", {
        get: function () {
            return this._geometry;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Marker.prototype, "latLon", {
        /**
         * Get lat lon.
         * @returns {ILatLon} The geographic coordinates of the marker.
         */
        get: function () {
            return this._latLon;
        },
        enumerable: true,
        configurable: true
    });
    Marker.prototype.createGeometry = function (position) {
        if (!!this._geometry) {
            return;
        }
        this._createGeometry(position);
        // update matrix world if raycasting occurs before first render
        this._geometry.updateMatrixWorld(true);
    };
    Marker.prototype.disposeGeometry = function () {
        if (!this._geometry) {
            return;
        }
        this._disposeGeometry();
        this._geometry = undefined;
    };
    Marker.prototype.getInteractiveObjects = function () {
        if (!this._geometry) {
            return [];
        }
        return this._getInteractiveObjects();
    };
    Marker.prototype.lerpAltitude = function (alt, alpha) {
        if (!this._geometry) {
            return;
        }
        this._geometry.position.z = (1 - alpha) * this._geometry.position.z + alpha * alt;
    };
    Marker.prototype.updatePosition = function (position, latLon) {
        if (!!latLon) {
            this._latLon.lat = latLon.lat;
            this._latLon.lon = latLon.lon;
        }
        if (!this._geometry) {
            return;
        }
        this._geometry.position.fromArray(position);
        this._geometry.updateMatrixWorld(true);
    };
    return Marker;
}());
exports.Marker = Marker;
exports.default = Marker;

},{}],340:[function(require,module,exports){
"use strict";
/// <reference path="../../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var Component_1 = require("../../../Component");
/**
 * @class SimpleMarker
 *
 * @classdesc Interactive marker with ice cream shape. The sphere
 * inside the ice cream can be configured to be interactive.
 *
 * Simple marker properties can not be updated after creation.
 *
 * To create and add one `SimpleMarker` with default configuration
 * (non-interactive) and one interactive with configuration use
 *
 * @example
 * ```
 * var defaultMarker = new Mapillary.MarkerComponent.SimpleMarker(
 *     "id-1",
 *     { lat: 0, lon: 0, });
 *
 * var interactiveMarker = new Mapillary.MarkerComponent.SimpleMarker(
 *     "id-2",
 *     { lat: 0, lon: 0, },
 *     {
 *         ballColor: "#00f",
 *         ballOpacity: 0.5,
 *         color: "#00f",
 *         interactive: true,
 *         opacity: 0.3,
 *         radius: 0.7,
 *     });
 *
 * markerComponent.add([defaultMarker, interactiveMarker]);
 * ```
 */
var SimpleMarker = /** @class */ (function (_super) {
    __extends(SimpleMarker, _super);
    function SimpleMarker(id, latLon, options) {
        var _this = _super.call(this, id, latLon) || this;
        options = !!options ? options : {};
        _this._ballColor = options.ballColor != null ? options.ballColor : 0xff0000;
        _this._ballOpacity = options.ballOpacity != null ? options.ballOpacity : 0.8;
        _this._circleToRayAngle = 2;
        _this._color = options.color != null ? options.color : 0xff0000;
        _this._interactive = !!options.interactive;
        _this._opacity = options.opacity != null ? options.opacity : 0.4;
        _this._radius = options.radius != null ? options.radius : 1;
        return _this;
    }
    SimpleMarker.prototype._createGeometry = function (position) {
        var radius = this._radius;
        var cone = new THREE.Mesh(this._markerGeometry(radius, 8, 8), new THREE.MeshBasicMaterial({
            color: this._color,
            opacity: this._opacity,
            transparent: true,
        }));
        cone.renderOrder = 1;
        var ball = new THREE.Mesh(new THREE.SphereGeometry(radius / 2, 8, 8), new THREE.MeshBasicMaterial({
            color: this._ballColor,
            opacity: this._ballOpacity,
            transparent: true,
        }));
        ball.position.z = this._markerHeight(radius);
        var group = new THREE.Object3D();
        group.add(ball);
        group.add(cone);
        group.position.fromArray(position);
        this._geometry = group;
    };
    SimpleMarker.prototype._disposeGeometry = function () {
        for (var _i = 0, _a = this._geometry.children; _i < _a.length; _i++) {
            var mesh = _a[_i];
            mesh.geometry.dispose();
            mesh.material.dispose();
        }
    };
    SimpleMarker.prototype._getInteractiveObjects = function () {
        return this._interactive ? [this._geometry.children[0]] : [];
    };
    SimpleMarker.prototype._markerHeight = function (radius) {
        var t = Math.tan(Math.PI - this._circleToRayAngle);
        return radius * Math.sqrt(1 + t * t);
    };
    SimpleMarker.prototype._markerGeometry = function (radius, widthSegments, heightSegments) {
        var geometry = new THREE.Geometry();
        widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
        heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
        var height = this._markerHeight(radius);
        var vertices = [];
        for (var y = 0; y <= heightSegments; ++y) {
            var verticesRow = [];
            for (var x = 0; x <= widthSegments; ++x) {
                var u = x / widthSegments * Math.PI * 2;
                var v = y / heightSegments * Math.PI;
                var r = void 0;
                if (v < this._circleToRayAngle) {
                    r = radius;
                }
                else {
                    var t = Math.tan(v - this._circleToRayAngle);
                    r = radius * Math.sqrt(1 + t * t);
                }
                var vertex = new THREE.Vector3();
                vertex.x = r * Math.cos(u) * Math.sin(v);
                vertex.y = r * Math.sin(u) * Math.sin(v);
                vertex.z = r * Math.cos(v) + height;
                geometry.vertices.push(vertex);
                verticesRow.push(geometry.vertices.length - 1);
            }
            vertices.push(verticesRow);
        }
        for (var y = 0; y < heightSegments; ++y) {
            for (var x = 0; x < widthSegments; ++x) {
                var v1 = vertices[y][x + 1];
                var v2 = vertices[y][x];
                var v3 = vertices[y + 1][x];
                var v4 = vertices[y + 1][x + 1];
                var n1 = geometry.vertices[v1].clone().normalize();
                var n2 = geometry.vertices[v2].clone().normalize();
                var n3 = geometry.vertices[v3].clone().normalize();
                var n4 = geometry.vertices[v4].clone().normalize();
                geometry.faces.push(new THREE.Face3(v1, v2, v4, [n1, n2, n4]));
                geometry.faces.push(new THREE.Face3(v2, v3, v4, [n2.clone(), n3, n4.clone()]));
            }
        }
        geometry.computeFaceNormals();
        geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius + height);
        return geometry;
    };
    return SimpleMarker;
}(Component_1.Marker));
exports.SimpleMarker = SimpleMarker;
exports.default = SimpleMarker;

},{"../../../Component":291,"three":241}],341:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var Component_1 = require("../../Component");
/**
 * The `BounceHandler` ensures that the viewer bounces back to the image
 * when drag panning outside of the image edge.
 */
var BounceHandler = /** @class */ (function (_super) {
    __extends(BounceHandler, _super);
    function BounceHandler(component, container, navigator, viewportCoords, spatial) {
        var _this = _super.call(this, component, container, navigator) || this;
        _this._spatial = spatial;
        _this._viewportCoords = viewportCoords;
        _this._basicDistanceThreshold = 1e-3;
        _this._basicRotationThreshold = 5e-2;
        _this._bounceCoeff = 1e-1;
        return _this;
    }
    BounceHandler.prototype._enable = function () {
        var _this = this;
        var inTransition$ = this._navigator.stateService.currentState$
            .map(function (frame) {
            return frame.state.alpha < 1;
        });
        this._bounceSubscription = Observable_1.Observable
            .combineLatest(inTransition$, this._navigator.stateService.inTranslation$, this._container.mouseService.active$, this._container.touchService.active$)
            .map(function (noForce) {
            return noForce[0] || noForce[1] || noForce[2] || noForce[3];
        })
            .distinctUntilChanged()
            .switchMap(function (noForce) {
            return noForce ?
                Observable_1.Observable.empty() :
                Observable_1.Observable.combineLatest(_this._container.renderService.renderCamera$, _this._navigator.stateService.currentTransform$.first());
        })
            .subscribe(function (args) {
            var renderCamera = args[0];
            var perspectiveCamera = renderCamera.perspective;
            var transform = args[1];
            if (!transform.hasValidScale && renderCamera.camera.focal < 0.1) {
                return;
            }
            if (renderCamera.perspective.aspect === 0 || renderCamera.perspective.aspect === Number.POSITIVE_INFINITY) {
                return;
            }
            var distanceThreshold = _this._basicDistanceThreshold / Math.pow(2, renderCamera.zoom);
            var basicCenter = _this._viewportCoords.viewportToBasic(0, 0, transform, perspectiveCamera);
            if (Math.abs(basicCenter[0] - 0.5) < distanceThreshold && Math.abs(basicCenter[1] - 0.5) < distanceThreshold) {
                return;
            }
            var basicDistances = _this._viewportCoords.getBasicDistances(transform, perspectiveCamera);
            var basicX = 0;
            var basicY = 0;
            if (basicDistances[0] < distanceThreshold && basicDistances[1] < distanceThreshold &&
                basicDistances[2] < distanceThreshold && basicDistances[3] < distanceThreshold) {
                return;
            }
            if (Math.abs(basicDistances[0] - basicDistances[2]) < distanceThreshold &&
                Math.abs(basicDistances[1] - basicDistances[3]) < distanceThreshold) {
                return;
            }
            var coeff = _this._bounceCoeff;
            if (basicDistances[1] > 0 && basicDistances[3] === 0) {
                basicX = -coeff * basicDistances[1];
            }
            else if (basicDistances[1] === 0 && basicDistances[3] > 0) {
                basicX = coeff * basicDistances[3];
            }
            else if (basicDistances[1] > 0 && basicDistances[3] > 0) {
                basicX = coeff * (basicDistances[3] - basicDistances[1]) / 2;
            }
            if (basicDistances[0] > 0 && basicDistances[2] === 0) {
                basicY = coeff * basicDistances[0];
            }
            else if (basicDistances[0] === 0 && basicDistances[2] > 0) {
                basicY = -coeff * basicDistances[2];
            }
            else if (basicDistances[0] > 0 && basicDistances[2] > 0) {
                basicY = coeff * (basicDistances[0] - basicDistances[2]) / 2;
            }
            var rotationThreshold = _this._basicRotationThreshold;
            basicX = _this._spatial.clamp(basicX, -rotationThreshold, rotationThreshold);
            basicY = _this._spatial.clamp(basicY, -rotationThreshold, rotationThreshold);
            _this._navigator.stateService.rotateBasicUnbounded([basicX, basicY]);
        });
    };
    BounceHandler.prototype._disable = function () {
        this._bounceSubscription.unsubscribe();
    };
    BounceHandler.prototype._getConfiguration = function (enable) {
        return {};
    };
    return BounceHandler;
}(Component_1.HandlerBase));
exports.BounceHandler = BounceHandler;
exports.default = BounceHandler;

},{"../../Component":291,"rxjs/Observable":29}],342:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var Component_1 = require("../../Component");
/**
 * The `DoubleClickZoomHandler` allows the user to zoom the viewer image at a point by double clicking.
 *
 * @example
 * ```
 * var mouseComponent = viewer.getComponent("mouse");
 *
 * mouseComponent.doubleClickZoom.disable();
 * mouseComponent.doubleClickZoom.enable();
 *
 * var isEnabled = mouseComponent.doubleClickZoom.isEnabled;
 * ```
 */
var DoubleClickZoomHandler = /** @class */ (function (_super) {
    __extends(DoubleClickZoomHandler, _super);
    function DoubleClickZoomHandler(component, container, navigator, viewportCoords) {
        var _this = _super.call(this, component, container, navigator) || this;
        _this._viewportCoords = viewportCoords;
        return _this;
    }
    DoubleClickZoomHandler.prototype._enable = function () {
        var _this = this;
        this._zoomSubscription = Observable_1.Observable
            .merge(this._container.mouseService
            .filtered$(this._component.name, this._container.mouseService.dblClick$), this._container.touchService.doubleTap$
            .map(function (e) {
            var touch = e.touches[0];
            return { clientX: touch.clientX, clientY: touch.clientY, shiftKey: e.shiftKey };
        }))
            .withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$)
            .subscribe(function (_a) {
            var event = _a[0], render = _a[1], transform = _a[2];
            var element = _this._container.element;
            var _b = _this._viewportCoords.canvasPosition(event, element), canvasX = _b[0], canvasY = _b[1];
            var unprojected = _this._viewportCoords.unprojectFromCanvas(canvasX, canvasY, element, render.perspective);
            var reference = transform.projectBasic(unprojected.toArray());
            var delta = !!event.shiftKey ? -1 : 1;
            _this._navigator.stateService.zoomIn(delta, reference);
        });
    };
    DoubleClickZoomHandler.prototype._disable = function () {
        this._zoomSubscription.unsubscribe();
    };
    DoubleClickZoomHandler.prototype._getConfiguration = function (enable) {
        return { doubleClickZoom: enable };
    };
    return DoubleClickZoomHandler;
}(Component_1.HandlerBase));
exports.DoubleClickZoomHandler = DoubleClickZoomHandler;
exports.default = DoubleClickZoomHandler;

},{"../../Component":291,"rxjs/Observable":29}],343:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var Observable_1 = require("rxjs/Observable");
require("rxjs/add/operator/concat");
require("rxjs/add/operator/sample");
require("rxjs/add/operator/takeWhile");
var Component_1 = require("../../Component");
/**
 * The `DragPanHandler` allows the user to pan the viewer image by clicking and dragging the cursor.
 *
 * @example
 * ```
 * var mouseComponent = viewer.getComponent("mouse");
 *
 * mouseComponent.dragPan.disable();
 * mouseComponent.dragPan.enable();
 *
 * var isEnabled = mouseComponent.dragPan.isEnabled;
 * ```
 */
var DragPanHandler = /** @class */ (function (_super) {
    __extends(DragPanHandler, _super);
    function DragPanHandler(component, container, navigator, viewportCoords, spatial) {
        var _this = _super.call(this, component, container, navigator) || this;
        _this._spatial = spatial;
        _this._viewportCoords = viewportCoords;
        _this._basicRotationThreshold = 5e-2;
        _this._forceCoeff = 2e-1;
        return _this;
    }
    DragPanHandler.prototype._enable = function () {
        var _this = this;
        var draggingStarted$ = this._container.mouseService
            .filtered$(this._component.name, this._container.mouseService.mouseDragStart$)
            .map(function (event) {
            return true;
        })
            .share();
        var draggingStopped$ = this._container.mouseService
            .filtered$(this._component.name, this._container.mouseService.mouseDragEnd$)
            .map(function (event) {
            return false;
        })
            .share();
        this._activeMouseSubscription = Observable_1.Observable
            .merge(draggingStarted$, draggingStopped$)
            .subscribe(this._container.mouseService.activate$);
        this._preventDefaultSubscription = Observable_1.Observable
            .merge(draggingStarted$, draggingStopped$)
            .switchMap(function (dragging) {
            return dragging ?
                _this._container.mouseService.documentMouseMove$ :
                Observable_1.Observable.empty();
        })
            .merge(this._container.touchService.touchMove$)
            .subscribe(function (event) {
            event.preventDefault(); // prevent selection of content outside the viewer
        });
        var touchMovingStarted$ = this._container.touchService.singleTouchDragStart$
            .map(function (event) {
            return true;
        });
        var touchMovingStopped$ = this._container.touchService.singleTouchDragEnd$
            .map(function (event) {
            return false;
        });
        this._activeTouchSubscription = Observable_1.Observable
            .merge(touchMovingStarted$, touchMovingStopped$)
            .subscribe(this._container.touchService.activate$);
        var basicRotation$ = this._navigator.stateService.currentState$
            .map(function (frame) {
            return frame.state.currentNode.fullPano || frame.state.nodesAhead < 1;
        })
            .distinctUntilChanged()
            .switchMap(function (enable) {
            if (!enable) {
                return Observable_1.Observable.empty();
            }
            var mouseDrag$ = _this._container.mouseService
                .filtered$(_this._component.name, _this._container.mouseService.mouseDragStart$)
                .switchMap(function (mouseDragStart) {
                return Observable_1.Observable
                    .of(mouseDragStart)
                    .concat(_this._container.mouseService
                    .filtered$(_this._component.name, _this._container.mouseService.mouseDrag$))
                    .merge(_this._container.mouseService
                    .filtered$(_this._component.name, _this._container.mouseService.mouseDragEnd$)
                    .map(function (e) {
                    return null;
                }))
                    .takeWhile(function (e) {
                    return !!e;
                })
                    .startWith(null);
            })
                .pairwise()
                .filter(function (pair) {
                return pair[0] != null && pair[1] != null;
            });
            var singleTouchDrag$ = Observable_1.Observable
                .merge(_this._container.touchService.singleTouchDragStart$, _this._container.touchService.singleTouchDrag$, _this._container.touchService.singleTouchDragEnd$.map(function (t) { return null; }))
                .map(function (event) {
                return event != null && event.touches.length > 0 ?
                    event.touches[0] : null;
            })
                .pairwise()
                .filter(function (pair) {
                return pair[0] != null && pair[1] != null;
            });
            return Observable_1.Observable
                .merge(mouseDrag$, singleTouchDrag$);
        })
            .withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$, this._navigator.stateService.currentCamera$)
            .map(function (_a) {
            var events = _a[0], render = _a[1], transform = _a[2], c = _a[3];
            var camera = c.clone();
            var previousEvent = events[0];
            var event = events[1];
            var movementX = event.clientX - previousEvent.clientX;
            var movementY = event.clientY - previousEvent.clientY;
            var element = _this._container.element;
            var _b = _this._viewportCoords.canvasPosition(event, element), canvasX = _b[0], canvasY = _b[1];
            var currentDirection = _this._viewportCoords.unprojectFromCanvas(canvasX, canvasY, element, render.perspective)
                .sub(render.perspective.position);
            var directionX = _this._viewportCoords.unprojectFromCanvas(canvasX - movementX, canvasY, element, render.perspective)
                .sub(render.perspective.position);
            var directionY = _this._viewportCoords.unprojectFromCanvas(canvasX, canvasY - movementY, element, render.perspective)
                .sub(render.perspective.position);
            var deltaPhi = (movementX > 0 ? 1 : -1) * directionX.angleTo(currentDirection);
            var deltaTheta = (movementY > 0 ? -1 : 1) * directionY.angleTo(currentDirection);
            var upQuaternion = new THREE.Quaternion().setFromUnitVectors(camera.up, new THREE.Vector3(0, 0, 1));
            var upQuaternionInverse = upQuaternion.clone().inverse();
            var offset = new THREE.Vector3();
            offset.copy(camera.lookat).sub(camera.position);
            offset.applyQuaternion(upQuaternion);
            var length = offset.length();
            var phi = Math.atan2(offset.y, offset.x);
            phi += deltaPhi;
            var theta = Math.atan2(Math.sqrt(offset.x * offset.x + offset.y * offset.y), offset.z);
            theta += deltaTheta;
            theta = Math.max(0.01, Math.min(Math.PI - 0.01, theta));
            offset.x = Math.sin(theta) * Math.cos(phi);
            offset.y = Math.sin(theta) * Math.sin(phi);
            offset.z = Math.cos(theta);
            offset.applyQuaternion(upQuaternionInverse);
            var lookat = new THREE.Vector3().copy(camera.position).add(offset.multiplyScalar(length));
            var basic = transform.projectBasic(lookat.toArray());
            var original = transform.projectBasic(camera.lookat.toArray());
            var x = basic[0] - original[0];
            var y = basic[1] - original[1];
            if (Math.abs(x) > 1) {
                x = 0;
            }
            else if (x > 0.5) {
                x = x - 1;
            }
            else if (x < -0.5) {
                x = x + 1;
            }
            var rotationThreshold = _this._basicRotationThreshold;
            x = _this._spatial.clamp(x, -rotationThreshold, rotationThreshold);
            y = _this._spatial.clamp(y, -rotationThreshold, rotationThreshold);
            if (transform.fullPano) {
                return [x, y];
            }
            var pixelDistances = _this._viewportCoords.getPixelDistances(_this._container.element, transform, render.perspective);
            var coeff = _this._forceCoeff;
            if (pixelDistances[0] > 0 && y < 0 && basic[1] < 0.5) {
                y /= Math.max(1, coeff * pixelDistances[0]);
            }
            if (pixelDistances[1] > 0 && x > 0 && basic[0] > 0.5) {
                x /= Math.max(1, coeff * pixelDistances[1]);
            }
            if (pixelDistances[2] > 0 && y > 0 && basic[1] > 0.5) {
                y /= Math.max(1, coeff * pixelDistances[2]);
            }
            if (pixelDistances[3] > 0 && x < 0 && basic[0] < 0.5) {
                x /= Math.max(1, coeff * pixelDistances[3]);
            }
            return [x, y];
        })
            .share();
        this._rotateBasicWithoutInertiaSubscription = basicRotation$
            .subscribe(function (basicRotation) {
            _this._navigator.stateService.rotateBasicWithoutInertia(basicRotation);
        });
        this._rotateBasicSubscription = basicRotation$
            .scan(function (rotationBuffer, rotation) {
            _this._drainBuffer(rotationBuffer);
            rotationBuffer.push([Date.now(), rotation]);
            return rotationBuffer;
        }, [])
            .sample(Observable_1.Observable
            .merge(this._container.mouseService.filtered$(this._component.name, this._container.mouseService.mouseDragEnd$), this._container.touchService.singleTouchDragEnd$))
            .map(function (rotationBuffer) {
            var drainedBuffer = _this._drainBuffer(rotationBuffer.slice());
            var basicRotation = [0, 0];
            for (var _i = 0, drainedBuffer_1 = drainedBuffer; _i < drainedBuffer_1.length; _i++) {
                var rotation = drainedBuffer_1[_i];
                basicRotation[0] += rotation[1][0];
                basicRotation[1] += rotation[1][1];
            }
            var count = drainedBuffer.length;
            if (count > 0) {
                basicRotation[0] /= count;
                basicRotation[1] /= count;
            }
            return basicRotation;
        })
            .subscribe(function (basicRotation) {
            _this._navigator.stateService.rotateBasic(basicRotation);
        });
    };
    DragPanHandler.prototype._disable = function () {
        this._activeMouseSubscription.unsubscribe();
        this._activeTouchSubscription.unsubscribe();
        this._preventDefaultSubscription.unsubscribe();
        this._rotateBasicSubscription.unsubscribe();
        this._rotateBasicWithoutInertiaSubscription.unsubscribe();
        this._activeMouseSubscription = null;
        this._activeTouchSubscription = null;
        this._preventDefaultSubscription = null;
        this._rotateBasicSubscription = null;
    };
    DragPanHandler.prototype._getConfiguration = function (enable) {
        return { dragPan: enable };
    };
    DragPanHandler.prototype._drainBuffer = function (buffer) {
        var cutoff = 50;
        var now = Date.now();
        while (buffer.length > 0 && now - buffer[0][0] > cutoff) {
            buffer.shift();
        }
        return buffer;
    };
    return DragPanHandler;
}(Component_1.HandlerBase));
exports.DragPanHandler = DragPanHandler;
exports.default = DragPanHandler;

},{"../../Component":291,"rxjs/Observable":29,"rxjs/add/operator/concat":56,"rxjs/add/operator/sample":77,"rxjs/add/operator/takeWhile":87,"three":241}],344:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
require("rxjs/add/observable/merge");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/map");
require("rxjs/add/operator/withLatestFrom");
var Component_1 = require("../../Component");
var Geo_1 = require("../../Geo");
/**
 * @class MouseComponent
 *
 * @classdesc Component handling mouse and touch events for camera movement.
 *
 * To retrive and use the mouse component
 *
 * @example
 * ```
 * var viewer = new Mapillary.Viewer(
 *     "<element-id>",
 *     "<client-id>",
 *     "<my key>");
 *
 * var mouseComponent = viewer.getComponent("mouse");
 * ```
 */
var MouseComponent = /** @class */ (function (_super) {
    __extends(MouseComponent, _super);
    function MouseComponent(name, container, navigator) {
        var _this = _super.call(this, name, container, navigator) || this;
        var spatial = new Geo_1.Spatial();
        var viewportCoords = new Geo_1.ViewportCoords();
        _this._bounceHandler = new Component_1.BounceHandler(_this, container, navigator, viewportCoords, spatial);
        _this._doubleClickZoomHandler = new Component_1.DoubleClickZoomHandler(_this, container, navigator, viewportCoords);
        _this._dragPanHandler = new Component_1.DragPanHandler(_this, container, navigator, viewportCoords, spatial);
        _this._scrollZoomHandler = new Component_1.ScrollZoomHandler(_this, container, navigator, viewportCoords);
        _this._touchZoomHandler = new Component_1.TouchZoomHandler(_this, container, navigator, viewportCoords);
        return _this;
    }
    Object.defineProperty(MouseComponent.prototype, "doubleClickZoom", {
        /**
         * Get double click zoom.
         *
         * @returns {DoubleClickZoomHandler} The double click zoom handler.
         */
        get: function () {
            return this._doubleClickZoomHandler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseComponent.prototype, "dragPan", {
        /**
         * Get drag pan.
         *
         * @returns {DragPanHandler} The drag pan handler.
         */
        get: function () {
            return this._dragPanHandler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseComponent.prototype, "scrollZoom", {
        /**
         * Get scroll zoom.
         *
         * @returns {ScrollZoomHandler} The scroll zoom handler.
         */
        get: function () {
            return this._scrollZoomHandler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseComponent.prototype, "touchZoom", {
        /**
         * Get touch zoom.
         *
         * @returns {TouchZoomHandler} The touch zoom handler.
         */
        get: function () {
            return this._touchZoomHandler;
        },
        enumerable: true,
        configurable: true
    });
    MouseComponent.prototype._activate = function () {
        var _this = this;
        this._bounceHandler.enable();
        this._configurationSubscription = this._configuration$
            .subscribe(function (configuration) {
            if (configuration.doubleClickZoom) {
                _this._doubleClickZoomHandler.enable();
            }
            else {
                _this._doubleClickZoomHandler.disable();
            }
            if (configuration.dragPan) {
                _this._dragPanHandler.enable();
            }
            else {
                _this._dragPanHandler.disable();
            }
            if (configuration.scrollZoom) {
                _this._scrollZoomHandler.enable();
            }
            else {
                _this._scrollZoomHandler.disable();
            }
            if (configuration.touchZoom) {
                _this._touchZoomHandler.enable();
            }
            else {
                _this._touchZoomHandler.disable();
            }
        });
        this._container.mouseService.claimMouse(this._name, 0);
    };
    MouseComponent.prototype._deactivate = function () {
        this._container.mouseService.unclaimMouse(this._name);
        this._configurationSubscription.unsubscribe();
        this._bounceHandler.disable();
        this._doubleClickZoomHandler.disable();
        this._dragPanHandler.disable();
        this._scrollZoomHandler.disable();
        this._touchZoomHandler.disable();
    };
    MouseComponent.prototype._getDefaultConfiguration = function () {
        return { doubleClickZoom: false, dragPan: true, scrollZoom: true, touchZoom: true };
    };
    /** @inheritdoc */
    MouseComponent.componentName = "mouse";
    return MouseComponent;
}(Component_1.Component));
exports.MouseComponent = MouseComponent;
Component_1.ComponentService.register(MouseComponent);
exports.default = MouseComponent;

},{"../../Component":291,"../../Geo":294,"rxjs/add/observable/merge":45,"rxjs/add/operator/filter":63,"rxjs/add/operator/map":67,"rxjs/add/operator/withLatestFrom":90}],345:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Component_1 = require("../../Component");
/**
 * The `ScrollZoomHandler` allows the user to zoom the viewer image by scrolling.
 *
 * @example
 * ```
 * var mouseComponent = viewer.getComponent("mouse");
 *
 * mouseComponent.scrollZoom.disable();
 * mouseComponent.scrollZoom.enable();
 *
 * var isEnabled = mouseComponent.scrollZoom.isEnabled;
 * ```
 */
var ScrollZoomHandler = /** @class */ (function (_super) {
    __extends(ScrollZoomHandler, _super);
    function ScrollZoomHandler(component, container, navigator, viewportCoords) {
        var _this = _super.call(this, component, container, navigator) || this;
        _this._viewportCoords = viewportCoords;
        return _this;
    }
    ScrollZoomHandler.prototype._enable = function () {
        var _this = this;
        this._container.mouseService.claimWheel(this._component.name, 0);
        this._preventDefaultSubscription = this._container.mouseService.mouseWheel$
            .subscribe(function (event) {
            event.preventDefault();
        });
        this._zoomSubscription = this._container.mouseService
            .filteredWheel$(this._component.name, this._container.mouseService.mouseWheel$)
            .withLatestFrom(this._navigator.stateService.currentState$, function (w, f) {
            return [w, f];
        })
            .filter(function (args) {
            var state = args[1].state;
            return state.currentNode.fullPano || state.nodesAhead < 1;
        })
            .map(function (args) {
            return args[0];
        })
            .withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$, function (w, r, t) {
            return [w, r, t];
        })
            .subscribe(function (args) {
            var event = args[0];
            var render = args[1];
            var transform = args[2];
            var element = _this._container.element;
            var _a = _this._viewportCoords.canvasPosition(event, element), canvasX = _a[0], canvasY = _a[1];
            var unprojected = _this._viewportCoords.unprojectFromCanvas(canvasX, canvasY, element, render.perspective);
            var reference = transform.projectBasic(unprojected.toArray());
            var deltaY = event.deltaY;
            if (event.deltaMode === 1) {
                deltaY = 40 * deltaY;
            }
            else if (event.deltaMode === 2) {
                deltaY = 800 * deltaY;
            }
            var canvasSize = _this._viewportCoords.containerToCanvas(element);
            var zoom = -3 * deltaY / canvasSize[1];
            _this._navigator.stateService.zoomIn(zoom, reference);
        });
    };
    ScrollZoomHandler.prototype._disable = function () {
        this._container.mouseService.unclaimWheel(this._component.name);
        this._preventDefaultSubscription.unsubscribe();
        this._zoomSubscription.unsubscribe();
        this._preventDefaultSubscription = null;
        this._zoomSubscription = null;
    };
    ScrollZoomHandler.prototype._getConfiguration = function (enable) {
        return { scrollZoom: enable };
    };
    return ScrollZoomHandler;
}(Component_1.HandlerBase));
exports.ScrollZoomHandler = ScrollZoomHandler;
exports.default = ScrollZoomHandler;

},{"../../Component":291}],346:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var Component_1 = require("../../Component");
/**
 * The `TouchZoomHandler` allows the user to zoom the viewer image by pinching on a touchscreen.
 *
 * @example
 * ```
 * var mouseComponent = viewer.getComponent("mouse");
 *
 * mouseComponent.touchZoom.disable();
 * mouseComponent.touchZoom.enable();
 *
 * var isEnabled = mouseComponent.touchZoom.isEnabled;
 * ```
 */
var TouchZoomHandler = /** @class */ (function (_super) {
    __extends(TouchZoomHandler, _super);
    function TouchZoomHandler(component, container, navigator, viewportCoords) {
        var _this = _super.call(this, component, container, navigator) || this;
        _this._viewportCoords = viewportCoords;
        return _this;
    }
    TouchZoomHandler.prototype._enable = function () {
        var _this = this;
        this._preventDefaultSubscription = this._container.touchService.pinch$
            .subscribe(function (pinch) {
            pinch.originalEvent.preventDefault();
        });
        var pinchStarted$ = this._container.touchService.pinchStart$
            .map(function (event) {
            return true;
        });
        var pinchStopped$ = this._container.touchService.pinchEnd$
            .map(function (event) {
            return false;
        });
        this._activeSubscription = Observable_1.Observable
            .merge(pinchStarted$, pinchStopped$)
            .subscribe(this._container.touchService.activate$);
        this._zoomSubscription = this._container.touchService.pinch$
            .withLatestFrom(this._navigator.stateService.currentState$)
            .filter(function (args) {
            var state = args[1].state;
            return state.currentNode.fullPano || state.nodesAhead < 1;
        })
            .map(function (args) {
            return args[0];
        })
            .withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$)
            .subscribe(function (_a) {
            var pinch = _a[0], render = _a[1], transform = _a[2];
            var element = _this._container.element;
            var _b = _this._viewportCoords.canvasPosition(pinch, element), canvasX = _b[0], canvasY = _b[1];
            var unprojected = _this._viewportCoords.unprojectFromCanvas(canvasX, canvasY, element, render.perspective);
            var reference = transform.projectBasic(unprojected.toArray());
            var _c = _this._viewportCoords.containerToCanvas(element), canvasWidth = _c[0], canvasHeight = _c[1];
            var zoom = 3 * pinch.distanceChange / Math.min(canvasWidth, canvasHeight);
            _this._navigator.stateService.zoomIn(zoom, reference);
        });
    };
    TouchZoomHandler.prototype._disable = function () {
        this._activeSubscription.unsubscribe();
        this._preventDefaultSubscription.unsubscribe();
        this._zoomSubscription.unsubscribe();
        this._preventDefaultSubscription = null;
        this._zoomSubscription = null;
    };
    TouchZoomHandler.prototype._getConfiguration = function (enable) {
        return { touchZoom: enable };
    };
    return TouchZoomHandler;
}(Component_1.HandlerBase));
exports.TouchZoomHandler = TouchZoomHandler;
exports.default = TouchZoomHandler;

},{"../../Component":291,"rxjs/Observable":29}],347:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Popup_1 = require("./popup/Popup");
exports.Popup = Popup_1.Popup;
var PopupComponent_1 = require("./PopupComponent");
exports.PopupComponent = PopupComponent_1.PopupComponent;

},{"./PopupComponent":348,"./popup/Popup":349}],348:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
var Component_1 = require("../../Component");
var Utils_1 = require("../../Utils");
/**
 * @class PopupComponent
 *
 * @classdesc Component for showing HTML popup objects.
 *
 * The `add` method is used for adding new popups. Popups are removed by reference.
 *
 * It is not possible to update popups in the set by updating any properties
 * directly on the popup object. Popups need to be replaced by
 * removing them and creating new ones with relevant changed properties and
 * adding those instead.
 *
 * Popups are only relevant to a single image because they are based on
 * 2D basic image coordinates. Popups related to a certain image should
 * be removed when the viewer is moved to another node.
 *
 * To retrive and use the popup component
 *
 * @example
 * ```
 * var viewer = new Mapillary.Viewer(
 *     "<element-id>",
 *     "<client-id>",
 *     "<my key>",
 *     { component: { popup: true } });
 *
 * var popupComponent = viewer.getComponent("popup");
 * ```
 */
var PopupComponent = /** @class */ (function (_super) {
    __extends(PopupComponent, _super);
    function PopupComponent(name, container, navigator, dom) {
        var _this = _super.call(this, name, container, navigator) || this;
        _this._dom = !!dom ? dom : new Utils_1.DOM();
        _this._popups = [];
        _this._added$ = new Subject_1.Subject();
        _this._popups$ = new Subject_1.Subject();
        return _this;
    }
    /**
     * Add popups to the popups set.
     *
     * @description Adding a new popup never replaces an old one
     * because they are stored by reference. Adding an already
     * existing popup has no effect.
     *
     * @param {Array<Popup>} popups - Popups to add.
     *
     * @example ```popupComponent.add([popup1, popup2]);```
     */
    PopupComponent.prototype.add = function (popups) {
        for (var _i = 0, popups_1 = popups; _i < popups_1.length; _i++) {
            var popup = popups_1[_i];
            if (this._popups.indexOf(popup) !== -1) {
                continue;
            }
            this._popups.push(popup);
            if (this._activated) {
                popup.setParentContainer(this._popupContainer);
            }
        }
        this._added$.next(popups);
        this._popups$.next(this._popups);
    };
    /**
     * Returns an array of all popups.
     *
     * @example ```var popups = popupComponent.getAll();```
     */
    PopupComponent.prototype.getAll = function () {
        return this._popups.slice();
    };
    /**
     * Remove popups based on reference from the popup set.
     *
     * @param {Array<Popup>} popups - Popups to remove.
     *
     * @example ```popupComponent.remove([popup1, popup2]);```
     */
    PopupComponent.prototype.remove = function (popups) {
        for (var _i = 0, popups_2 = popups; _i < popups_2.length; _i++) {
            var popup = popups_2[_i];
            this._remove(popup);
        }
        this._popups$.next(this._popups);
    };
    /**
     * Remove all popups from the popup set.
     *
     * @example ```popupComponent.removeAll();```
     */
    PopupComponent.prototype.removeAll = function () {
        for (var _i = 0, _a = this._popups.slice(); _i < _a.length; _i++) {
            var popup = _a[_i];
            this._remove(popup);
        }
        this._popups$.next(this._popups);
    };
    PopupComponent.prototype._activate = function () {
        var _this = this;
        this._popupContainer = this._dom.createElement("div", "mapillary-js-popup-container", this._container.element);
        for (var _i = 0, _a = this._popups; _i < _a.length; _i++) {
            var popup = _a[_i];
            popup.setParentContainer(this._popupContainer);
        }
        this._updateAllSubscription = Observable_1.Observable
            .combineLatest(this._container.renderService.renderCamera$, this._container.renderService.size$, this._navigator.stateService.currentTransform$)
            .subscribe(function (_a) {
            var renderCamera = _a[0], size = _a[1], transform = _a[2];
            for (var _i = 0, _b = _this._popups; _i < _b.length; _i++) {
                var popup = _b[_i];
                popup.update(renderCamera, size, transform);
            }
        });
        var changed$ = this._popups$
            .startWith(this._popups)
            .switchMap(function (popups) {
            return Observable_1.Observable
                .from(popups)
                .mergeMap(function (popup) {
                return popup.changed$;
            });
        })
            .map(function (popup) {
            return [popup];
        });
        this._updateAddedChangedSubscription = this._added$
            .merge(changed$)
            .withLatestFrom(this._container.renderService.renderCamera$, this._container.renderService.size$, this._navigator.stateService.currentTransform$)
            .subscribe(function (_a) {
            var popups = _a[0], renderCamera = _a[1], size = _a[2], transform = _a[3];
            for (var _i = 0, popups_3 = popups; _i < popups_3.length; _i++) {
                var popup = popups_3[_i];
                popup.update(renderCamera, size, transform);
            }
        });
    };
    PopupComponent.prototype._deactivate = function () {
        this._updateAllSubscription.unsubscribe();
        this._updateAddedChangedSubscription.unsubscribe();
        for (var _i = 0, _a = this._popups; _i < _a.length; _i++) {
            var popup = _a[_i];
            popup.remove();
        }
        this._container.element.removeChild(this._popupContainer);
        delete this._popupContainer;
    };
    PopupComponent.prototype._getDefaultConfiguration = function () {
        return {};
    };
    PopupComponent.prototype._remove = function (popup) {
        var index = this._popups.indexOf(popup);
        if (index === -1) {
            return;
        }
        var removed = this._popups.splice(index, 1)[0];
        if (this._activated) {
            removed.remove();
        }
    };
    PopupComponent.componentName = "popup";
    return PopupComponent;
}(Component_1.Component));
exports.PopupComponent = PopupComponent;
Component_1.ComponentService.register(PopupComponent);
exports.default = PopupComponent;

},{"../../Component":291,"../../Utils":301,"rxjs/Observable":29,"rxjs/Subject":34}],349:[function(require,module,exports){
"use strict";
/// <reference path="../../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("rxjs/Subject");
var Geo_1 = require("../../../Geo");
var Utils_1 = require("../../../Utils");
var Viewer_1 = require("../../../Viewer");
/**
 * @class Popup
 *
 * @classdesc Popup instance for rendering custom HTML content
 * on top of images. Popups are based on 2D basic image coordinates
 * (see the {@link Viewer} class documentation for more information about coordinate
 * systems) and a certain popup is therefore only relevant to a single image.
 * Popups related to a certain image should be removed when moving
 * to another image.
 *
 * A popup must have both its content and its point or rect set to be
 * rendered. Popup options can not be updated after creation but the
 * basic point or rect as well as its content can be changed by calling
 * the appropriate methods.
 *
 * To create and add one `Popup` with default configuration
 * (tooltip visuals and automatic float) and one with specific options
 * use
 *
 * @example
 * ```
 * var defaultSpan = document.createElement('span');
 * defaultSpan.innerHTML = 'hello default';
 *
 * var defaultPopup = new Mapillary.PopupComponent.Popup();
 * defaultPopup.setDOMContent(defaultSpan);
 * defaultPopup.setBasicPoint([0.3, 0.3]);
 *
 * var cleanSpan = document.createElement('span');
 * cleanSpan.innerHTML = 'hello clean';
 *
 * var cleanPopup = new Mapillary.PopupComponent.Popup({
 *     clean: true,
 *     float: Mapillary.Alignment.Top,
 *     offset: 10,
 *     opacity: 0.7,
 * });
 *
 * cleanPopup.setDOMContent(cleanSpan);
 * cleanPopup.setBasicPoint([0.6, 0.6]);
 *
 * popupComponent.add([defaultPopup, cleanPopup]);
 * ```
 *
 * @description Implementation of API methods and API documentation inspired
 * by/used from https://github.com/mapbox/mapbox-gl-js/blob/v0.38.0/src/ui/popup.js
 */
var Popup = /** @class */ (function () {
    function Popup(options, viewportCoords, dom) {
        this._options = {};
        if (!!options) {
            this._options.capturePointer = options.capturePointer == null ? true : options.capturePointer;
            this._options.clean = options.clean;
            this._options.float = options.float;
            this._options.offset = options.offset;
            this._options.opacity = options.opacity;
            this._options.position = options.position;
        }
        this._dom = !!dom ? dom : new Utils_1.DOM();
        this._viewportCoords = !!viewportCoords ? viewportCoords : new Geo_1.ViewportCoords();
        this._notifyChanged$ = new Subject_1.Subject();
    }
    Object.defineProperty(Popup.prototype, "changed$", {
        /**
         * @ignore
         *
         * @description Internal observable used by the component to
         * render the popup when its position or content has changed.
         */
        get: function () {
            return this._notifyChanged$;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     *
     * @description Internal method used by the component to
     * remove all references to the popup.
     */
    Popup.prototype.remove = function () {
        if (this._content && this._content.parentNode) {
            this._content.parentNode.removeChild(this._content);
        }
        if (this._container) {
            this._container.parentNode.removeChild(this._container);
            delete this._container;
        }
        if (this._parentContainer) {
            delete this._parentContainer;
        }
    };
    /**
     * Sets a 2D basic image coordinates point to the popup's anchor, and
     * moves the popup to it.
     *
     * @description Overwrites any previously set point or rect.
     *
     * @param {Array<number>} basicPoint - Point in 2D basic image coordinates.
     *
     * @example
     * ```
     * var popup = new Mapillary.PopupComponent.Popup();
     * popup.setText('hello image');
     * popup.setBasicPoint([0.3, 0.3]);
     *
     * popupComponent.add([popup]);
     * ```
     */
    Popup.prototype.setBasicPoint = function (basicPoint) {
        this._point = basicPoint.slice();
        this._rect = null;
        this._notifyChanged$.next(this);
    };
    /**
     * Sets a 2D basic image coordinates rect to the popup's anchor, and
     * moves the popup to it.
     *
     * @description Overwrites any previously set point or rect.
     *
     * @param {Array<number>} basicRect - Rect in 2D basic image
     * coordinates ([topLeftX, topLeftY, bottomRightX, bottomRightY]) .
     *
     * @example
     * ```
     * var popup = new Mapillary.PopupComponent.Popup();
     * popup.setText('hello image');
     * popup.setBasicRect([0.3, 0.3, 0.5, 0.6]);
     *
     * popupComponent.add([popup]);
     * ```
     */
    Popup.prototype.setBasicRect = function (basicRect) {
        this._rect = basicRect.slice();
        this._point = null;
        this._notifyChanged$.next(this);
    };
    /**
     * Sets the popup's content to the element provided as a DOM node.
     *
     * @param {Node} htmlNode - A DOM node to be used as content for the popup.
     *
     * @example
     * ```
     * var div = document.createElement('div');
     * div.innerHTML = 'hello image';
     *
     * var popup = new Mapillary.PopupComponent.Popup();
     * popup.setDOMContent(div);
     * popup.setBasicPoint([0.3, 0.3]);
     *
     * popupComponent.add([popup]);
     * ```
     */
    Popup.prototype.setDOMContent = function (htmlNode) {
        if (this._content && this._content.parentNode) {
            this._content.parentNode.removeChild(this._content);
        }
        var className = "mapillaryjs-popup-content" +
            (this._options.clean === true ? "-clean" : "") +
            (this._options.capturePointer === true ? " mapillaryjs-popup-capture-pointer" : "");
        this._content = this._dom.createElement("div", className, this._container);
        this._content.appendChild(htmlNode);
        this._notifyChanged$.next(this);
    };
    /**
     * Sets the popup's content to the HTML provided as a string.
     *
     * @description This method does not perform HTML filtering or sanitization,
     * and must be used only with trusted content. Consider Popup#setText if the
     * content is an untrusted text string.
     *
     * @param {string} html - A string representing HTML content for the popup.
     *
     * @example
     * ```
     * var popup = new Mapillary.PopupComponent.Popup();
     * popup.setHTML('<div>hello image</div>');
     * popup.setBasicPoint([0.3, 0.3]);
     *
     * popupComponent.add([popup]);
     * ```
     */
    Popup.prototype.setHTML = function (html) {
        var frag = this._dom.document.createDocumentFragment();
        var temp = this._dom.createElement("body");
        var child;
        temp.innerHTML = html;
        while (true) {
            child = temp.firstChild;
            if (!child) {
                break;
            }
            frag.appendChild(child);
        }
        this.setDOMContent(frag);
    };
    /**
     * Sets the popup's content to a string of text.
     *
     * @description This function creates a Text node in the DOM, so it cannot insert raw HTML.
     * Use this method for security against XSS if the popup content is user-provided.
     *
     * @param {string} text - Textual content for the popup.
     *
     * @example
     * ```
     * var popup = new Mapillary.PopupComponent.Popup();
     * popup.setText('hello image');
     * popup.setBasicPoint([0.3, 0.3]);
     *
     * popupComponent.add([popup]);
     * ```
     */
    Popup.prototype.setText = function (text) {
        this.setDOMContent(this._dom.document.createTextNode(text));
    };
    /**
     * @ignore
     *
     * @description Internal method for attaching the popup to
     * its parent container so that it is rendered in the DOM tree.
     */
    Popup.prototype.setParentContainer = function (parentContainer) {
        this._parentContainer = parentContainer;
    };
    /**
     * @ignore
     *
     * @description Internal method for updating the rendered
     * position of the popup called by the popup component.
     */
    Popup.prototype.update = function (renderCamera, size, transform) {
        if (!this._parentContainer || !this._content) {
            return;
        }
        if (!this._point && !this._rect) {
            return;
        }
        if (!this._container) {
            this._container = this._dom.createElement("div", "mapillaryjs-popup", this._parentContainer);
            var showTip = this._options.clean !== true &&
                this._options.float !== Viewer_1.Alignment.Center;
            if (showTip) {
                var tipClassName = "mapillaryjs-popup-tip" +
                    (this._options.capturePointer === true ? " mapillaryjs-popup-capture-pointer" : "");
                this._tip = this._dom.createElement("div", tipClassName, this._container);
                this._dom.createElement("div", "mapillaryjs-popup-tip-inner", this._tip);
            }
            this._container.appendChild(this._content);
            this._parentContainer.appendChild(this._container);
            if (this._options.opacity != null) {
                this._container.style.opacity = this._options.opacity.toString();
            }
        }
        var pointPixel = null;
        var position = this._alignmentToPopupAligment(this._options.position);
        var float = this._alignmentToPopupAligment(this._options.float);
        var classList = this._container.classList;
        if (this._point != null) {
            pointPixel =
                this._viewportCoords.basicToCanvasSafe(this._point[0], this._point[1], { offsetHeight: size.height, offsetWidth: size.width }, transform, renderCamera.perspective);
        }
        else {
            var alignments = ["center", "top", "bottom", "left", "right", "top-left", "top-right", "bottom-left", "bottom-right"];
            var appliedPosition = null;
            for (var _i = 0, alignments_1 = alignments; _i < alignments_1.length; _i++) {
                var alignment = alignments_1[_i];
                if (classList.contains("mapillaryjs-popup-float-" + alignment)) {
                    appliedPosition = alignment;
                    break;
                }
            }
            _a = this._rectToPixel(this._rect, position, appliedPosition, renderCamera, size, transform), pointPixel = _a[0], position = _a[1];
            if (!float) {
                float = position;
            }
        }
        if (pointPixel == null) {
            this._container.style.visibility = "hidden";
            return;
        }
        this._container.style.visibility = "visible";
        if (!float) {
            var width = this._container.offsetWidth;
            var height = this._container.offsetHeight;
            var floats = this._pixelToFloats(pointPixel, size, width, height);
            float = floats.length === 0 ? "top" : floats.join("-");
        }
        var offset = this._normalizeOffset(this._options.offset);
        pointPixel = [pointPixel[0] + offset[float][0], pointPixel[1] + offset[float][1]];
        pointPixel = [Math.round(pointPixel[0]), Math.round(pointPixel[1])];
        var floatTranslate = {
            "bottom": "translate(-50%,0)",
            "bottom-left": "translate(-100%,0)",
            "bottom-right": "translate(0,0)",
            "center": "translate(-50%,-50%)",
            "left": "translate(-100%,-50%)",
            "right": "translate(0,-50%)",
            "top": "translate(-50%,-100%)",
            "top-left": "translate(-100%,-100%)",
            "top-right": "translate(0,-100%)",
        };
        for (var key in floatTranslate) {
            if (!floatTranslate.hasOwnProperty(key)) {
                continue;
            }
            classList.remove("mapillaryjs-popup-float-" + key);
        }
        classList.add("mapillaryjs-popup-float-" + float);
        this._container.style.transform = floatTranslate[float] + " translate(" + pointPixel[0] + "px," + pointPixel[1] + "px)";
        var _a;
    };
    Popup.prototype._rectToPixel = function (rect, position, appliedPosition, renderCamera, size, transform) {
        if (!position) {
            var width = this._container.offsetWidth;
            var height = this._container.offsetHeight;
            var floatOffsets = {
                "bottom": [0, height / 2],
                "bottom-left": [-width / 2, height / 2],
                "bottom-right": [width / 2, height / 2],
                "left": [-width / 2, 0],
                "right": [width / 2, 0],
                "top": [0, -height / 2],
                "top-left": [-width / 2, -height / 2],
                "top-right": [width / 2, -height / 2],
            };
            var automaticPositions = ["top", "bottom", "left", "right"];
            var largestVisibleArea = [0, null, null];
            for (var _i = 0, automaticPositions_1 = automaticPositions; _i < automaticPositions_1.length; _i++) {
                var automaticPosition = automaticPositions_1[_i];
                var autoPointBasic = this._pointFromRectPosition(rect, automaticPosition);
                var autoPointPixel = this._viewportCoords.basicToCanvasSafe(autoPointBasic[0], autoPointBasic[1], { offsetHeight: size.height, offsetWidth: size.width }, transform, renderCamera.perspective);
                if (autoPointPixel == null) {
                    continue;
                }
                var floatOffset = floatOffsets[automaticPosition];
                var offsetedPosition = [autoPointPixel[0] + floatOffset[0], autoPointPixel[1] + floatOffset[1]];
                var staticCoeff = appliedPosition != null && appliedPosition === automaticPosition ? 1 : 0.7;
                var floats = this._pixelToFloats(offsetedPosition, size, width / staticCoeff, height / (2 * staticCoeff));
                if (floats.length === 0 &&
                    autoPointPixel[0] > 0 &&
                    autoPointPixel[0] < size.width &&
                    autoPointPixel[1] > 0 &&
                    autoPointPixel[1] < size.height) {
                    return [autoPointPixel, automaticPosition];
                }
                var minX = Math.max(offsetedPosition[0] - width / 2, 0);
                var maxX = Math.min(offsetedPosition[0] + width / 2, size.width);
                var minY = Math.max(offsetedPosition[1] - height / 2, 0);
                var maxY = Math.min(offsetedPosition[1] + height / 2, size.height);
                var visibleX = Math.max(0, maxX - minX);
                var visibleY = Math.max(0, maxY - minY);
                var visibleArea = staticCoeff * visibleX * visibleY;
                if (visibleArea > largestVisibleArea[0]) {
                    largestVisibleArea[0] = visibleArea;
                    largestVisibleArea[1] = autoPointPixel;
                    largestVisibleArea[2] = automaticPosition;
                }
            }
            if (largestVisibleArea[0] > 0) {
                return [largestVisibleArea[1], largestVisibleArea[2]];
            }
        }
        var pointBasic = this._pointFromRectPosition(rect, position);
        var pointPixel = this._viewportCoords.basicToCanvasSafe(pointBasic[0], pointBasic[1], { offsetHeight: size.height, offsetWidth: size.width }, transform, renderCamera.perspective);
        return [pointPixel, position != null ? position : "top"];
    };
    Popup.prototype._alignmentToPopupAligment = function (float) {
        switch (float) {
            case Viewer_1.Alignment.Bottom:
                return "bottom";
            case Viewer_1.Alignment.BottomLeft:
                return "bottom-left";
            case Viewer_1.Alignment.BottomRight:
                return "bottom-right";
            case Viewer_1.Alignment.Center:
                return "center";
            case Viewer_1.Alignment.Left:
                return "left";
            case Viewer_1.Alignment.Right:
                return "right";
            case Viewer_1.Alignment.Top:
                return "top";
            case Viewer_1.Alignment.TopLeft:
                return "top-left";
            case Viewer_1.Alignment.TopRight:
                return "top-right";
            default:
                return null;
        }
    };
    Popup.prototype._normalizeOffset = function (offset) {
        if (offset == null) {
            return this._normalizeOffset(0);
        }
        if (typeof offset === "number") {
            // input specifies a radius
            var sideOffset = offset;
            var sign = sideOffset >= 0 ? 1 : -1;
            var cornerOffset = sign * Math.round(Math.sqrt(0.5 * Math.pow(sideOffset, 2)));
            return {
                "bottom": [0, sideOffset],
                "bottom-left": [-cornerOffset, cornerOffset],
                "bottom-right": [cornerOffset, cornerOffset],
                "center": [0, 0],
                "left": [-sideOffset, 0],
                "right": [sideOffset, 0],
                "top": [0, -sideOffset],
                "top-left": [-cornerOffset, -cornerOffset],
                "top-right": [cornerOffset, -cornerOffset],
            };
        }
        else {
            // input specifes a value for each position
            return {
                "bottom": offset.bottom || [0, 0],
                "bottom-left": offset.bottomLeft || [0, 0],
                "bottom-right": offset.bottomRight || [0, 0],
                "center": offset.center || [0, 0],
                "left": offset.left || [0, 0],
                "right": offset.right || [0, 0],
                "top": offset.top || [0, 0],
                "top-left": offset.topLeft || [0, 0],
                "top-right": offset.topRight || [0, 0],
            };
        }
    };
    Popup.prototype._pixelToFloats = function (pointPixel, size, width, height) {
        var floats = [];
        if (pointPixel[1] < height) {
            floats.push("bottom");
        }
        else if (pointPixel[1] > size.height - height) {
            floats.push("top");
        }
        if (pointPixel[0] < width / 2) {
            floats.push("right");
        }
        else if (pointPixel[0] > size.width - width / 2) {
            floats.push("left");
        }
        return floats;
    };
    Popup.prototype._pointFromRectPosition = function (rect, position) {
        var x0 = rect[0];
        var x1 = rect[0] < rect[2] ? rect[2] : rect[2] + 1;
        var y0 = rect[1];
        var y1 = rect[3];
        switch (position) {
            case "bottom":
                return [(x0 + x1) / 2, y1];
            case "bottom-left":
                return [x0, y1];
            case "bottom-right":
                return [x1, y1];
            case "center":
                return [(x0 + x1) / 2, (y0 + y1) / 2];
            case "left":
                return [x0, (y0 + y1) / 2];
            case "right":
                return [x1, (y0 + y1) / 2];
            case "top":
                return [(x0 + x1) / 2, y0];
            case "top-left":
                return [x0, y0];
            case "top-right":
                return [x1, y0];
            default:
                return [(x0 + x1) / 2, y1];
        }
    };
    return Popup;
}());
exports.Popup = Popup;
exports.default = Popup;

},{"../../../Geo":294,"../../../Utils":301,"../../../Viewer":302,"rxjs/Subject":34}],350:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/observable/combineLatest");
require("rxjs/add/observable/of");
require("rxjs/add/observable/concat");
require("rxjs/add/operator/auditTime");
require("rxjs/add/operator/bufferCount");
require("rxjs/add/operator/concat");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/finally");
require("rxjs/add/operator/first");
require("rxjs/add/operator/map");
require("rxjs/add/operator/publishReplay");
require("rxjs/add/operator/retry");
require("rxjs/add/operator/scan");
require("rxjs/add/operator/share");
require("rxjs/add/operator/switchMap");
require("rxjs/add/operator/takeUntil");
require("rxjs/add/operator/withLatestFrom");
var Component_1 = require("../../Component");
var Edge_1 = require("../../Edge");
var Graph_1 = require("../../Graph");
/**
 * @class SequenceComponent
 * @classdesc Component showing navigation arrows for sequence directions
 * as well as playing button. Exposes an API to start and stop play.
 */
var SequenceComponent = /** @class */ (function (_super) {
    __extends(SequenceComponent, _super);
    function SequenceComponent(name, container, navigator, renderer, scheduler) {
        var _this = _super.call(this, name, container, navigator) || this;
        _this._sequenceDOMRenderer = !!renderer ? renderer : new Component_1.SequenceDOMRenderer(container);
        _this._scheduler = scheduler;
        _this._containerWidth$ = new Subject_1.Subject();
        _this._hoveredKeySubject$ = new Subject_1.Subject();
        _this._hoveredKey$ = _this._hoveredKeySubject$.share();
        _this._navigator.playService.playing$
            .skip(1)
            .withLatestFrom(_this._configuration$)
            .subscribe(function (_a) {
            var playing = _a[0], configuration = _a[1];
            _this.fire(SequenceComponent.playingchanged, playing);
            if (playing === configuration.playing) {
                return;
            }
            if (playing) {
                _this.play();
            }
            else {
                _this.stop();
            }
        });
        _this._navigator.playService.direction$
            .skip(1)
            .withLatestFrom(_this._configuration$)
            .subscribe(function (_a) {
            var direction = _a[0], configuration = _a[1];
            if (direction !== configuration.direction) {
                _this.setDirection(direction);
            }
        });
        return _this;
    }
    Object.defineProperty(SequenceComponent.prototype, "hoveredKey$", {
        /**
         * Get hovered key observable.
         *
         * @description An observable emitting the key of the node for the direction
         * arrow that is being hovered. When the mouse leaves a direction arrow null
         * is emitted.
         *
         * @returns {Observable<string>}
         */
        get: function () {
            return this._hoveredKey$;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Start playing.
     *
     * @fires PlayerComponent#playingchanged
     */
    SequenceComponent.prototype.play = function () {
        this.configure({ playing: true });
    };
    /**
     * Stop playing.
     *
     * @fires PlayerComponent#playingchanged
     */
    SequenceComponent.prototype.stop = function () {
        this.configure({ playing: false });
    };
    /**
     * Set the direction to follow when playing.
     *
     * @param {EdgeDirection} direction - The direction that will be followed when playing.
     */
    SequenceComponent.prototype.setDirection = function (direction) {
        this.configure({ direction: direction });
    };
    /**
     * Set highlight key.
     *
     * @description The arrow pointing towards the node corresponding to the
     * highlight key will be highlighted.
     *
     * @param {string} highlightKey Key of node to be highlighted if existing.
     */
    SequenceComponent.prototype.setHighlightKey = function (highlightKey) {
        this.configure({ highlightKey: highlightKey });
    };
    /**
     * Set max width of container element.
     *
     * @description Set max width of the container element holding
     * the sequence navigation elements. If the min width is larger than the
     * max width the min width value will be used.
     *
     * The container element is automatically resized when the resize
     * method on the Viewer class is called.
     *
     * @param {number} minWidth
     */
    SequenceComponent.prototype.setMaxWidth = function (maxWidth) {
        this.configure({ maxWidth: maxWidth });
    };
    /**
     * Set min width of container element.
     *
     * @description Set min width of the container element holding
     * the sequence navigation elements. If the min width is larger than the
     * max width the min width value will be used.
     *
     * The container element is automatically resized when the resize
     * method on the Viewer class is called.
     *
     * @param {number} minWidth
     */
    SequenceComponent.prototype.setMinWidth = function (minWidth) {
        this.configure({ minWidth: minWidth });
    };
    /**
     * Set the value indicating whether the sequence UI elements should be visible.
     *
     * @param {boolean} visible
     */
    SequenceComponent.prototype.setVisible = function (visible) {
        this.configure({ visible: visible });
    };
    /** @inheritdoc */
    SequenceComponent.prototype.resize = function () {
        var _this = this;
        this._configuration$
            .first()
            .map(function (configuration) {
            return _this._sequenceDOMRenderer.getContainerWidth(_this._container.element, configuration);
        })
            .subscribe(function (containerWidth) {
            _this._containerWidth$.next(containerWidth);
        });
    };
    SequenceComponent.prototype._activate = function () {
        var _this = this;
        this._sequenceDOMRenderer.activate();
        var edgeStatus$ = this._navigator.stateService.currentNode$
            .switchMap(function (node) {
            return node.sequenceEdges$;
        })
            .publishReplay(1)
            .refCount();
        var sequence$ = this._navigator.stateService.currentNode$
            .distinctUntilChanged(undefined, function (node) {
            return node.sequenceKey;
        })
            .switchMap(function (node) {
            return Observable_1.Observable
                .concat(Observable_1.Observable.of(null), _this._navigator.graphService.cacheSequence$(node.sequenceKey)
                .retry(3)
                .catch(function (e) {
                console.error("Failed to cache sequence", e);
                return Observable_1.Observable.of(null);
            }));
        })
            .startWith(null)
            .publishReplay(1)
            .refCount();
        this._sequenceSubscription = sequence$.subscribe();
        var rendererKey$ = this._sequenceDOMRenderer.index$
            .withLatestFrom(sequence$)
            .map(function (_a) {
            var index = _a[0], sequence = _a[1];
            return sequence != null ? sequence.keys[index] : null;
        })
            .filter(function (key) {
            return !!key;
        })
            .distinctUntilChanged()
            .publish()
            .refCount();
        this._moveSubscription = Observable_1.Observable
            .merge(rendererKey$.debounceTime(100, this._scheduler), rendererKey$.auditTime(400, this._scheduler))
            .distinctUntilChanged()
            .switchMap(function (key) {
            return _this._navigator.moveToKey$(key)
                .catch(function (e) {
                return Observable_1.Observable.empty();
            });
        })
            .subscribe();
        this._setSequenceGraphModeSubscription = this._sequenceDOMRenderer.changingPositionChanged$
            .filter(function (changing) {
            return changing;
        })
            .subscribe(function () {
            _this._navigator.graphService.setGraphMode(Graph_1.GraphMode.Sequence);
        });
        this._setSpatialGraphModeSubscription = this._sequenceDOMRenderer.changingPositionChanged$
            .filter(function (changing) {
            return !changing;
        })
            .subscribe(function () {
            _this._navigator.graphService.setGraphMode(Graph_1.GraphMode.Spatial);
        });
        this._navigator.graphService.graphMode$
            .switchMap(function (mode) {
            return mode === Graph_1.GraphMode.Spatial ?
                _this._navigator.stateService.currentNode$
                    .take(2) :
                Observable_1.Observable.empty();
        })
            .filter(function (node) {
            return !node.spatialEdges.cached;
        })
            .switchMap(function (node) {
            return _this._navigator.graphService.cacheNode$(node.key)
                .catch(function (e) {
                return Observable_1.Observable.empty();
            });
        })
            .subscribe();
        this._stopSubscription = this._sequenceDOMRenderer.changingPositionChanged$
            .filter(function (changing) {
            return changing;
        })
            .subscribe(function () {
            _this._navigator.playService.stop();
        });
        this._cacheSequenceNodesSubscription = Observable_1.Observable
            .combineLatest(this._navigator.graphService.graphMode$, this._sequenceDOMRenderer.changingPositionChanged$
            .startWith(false)
            .distinctUntilChanged())
            .withLatestFrom(this._navigator.stateService.currentNode$)
            .switchMap(function (_a) {
            var _b = _a[0], mode = _b[0], changing = _b[1], node = _a[1];
            return changing && mode === Graph_1.GraphMode.Sequence ?
                _this._navigator.graphService.cacheSequenceNodes$(node.sequenceKey, node.key)
                    .retry(3)
                    .catch(function (error) {
                    console.error("Failed to cache sequence nodes.", error);
                    return Observable_1.Observable.empty();
                }) :
                Observable_1.Observable.empty();
        })
            .subscribe();
        var position$ = sequence$
            .switchMap(function (sequence) {
            if (!sequence) {
                return Observable_1.Observable.of({ index: null, max: null });
            }
            var firstCurrentKey = true;
            return _this._sequenceDOMRenderer.changingPositionChanged$
                .startWith(false)
                .distinctUntilChanged()
                .switchMap(function (changingPosition) {
                var skip = !changingPosition && firstCurrentKey ? 0 : 1;
                firstCurrentKey = false;
                return changingPosition ?
                    rendererKey$ :
                    _this._navigator.stateService.currentNode$
                        .map(function (node) {
                        return node.key;
                    })
                        .distinctUntilChanged()
                        .skip(skip);
            })
                .map(function (key) {
                var index = sequence.keys.indexOf(key);
                if (index === -1) {
                    return { index: null, max: null };
                }
                return { index: index, max: sequence.keys.length - 1 };
            });
        });
        this._renderSubscription = Observable_1.Observable
            .combineLatest(edgeStatus$, this._configuration$, this._containerWidth$, this._sequenceDOMRenderer.changed$.startWith(this._sequenceDOMRenderer), this._navigator.playService.speed$, position$)
            .map(function (_a) {
            var edgeStatus = _a[0], configuration = _a[1], containerWidth = _a[2], renderer = _a[3], speed = _a[4], position = _a[5];
            var vNode = _this._sequenceDOMRenderer
                .render(edgeStatus, configuration, containerWidth, speed, position.index, position.max, _this, _this._navigator);
            return { name: _this._name, vnode: vNode };
        })
            .subscribe(this._container.domRenderer.render$);
        this._setSpeedSubscription = this._sequenceDOMRenderer.speed$
            .subscribe(function (speed) {
            _this._navigator.playService.setSpeed(speed);
        });
        this._setDirectionSubscription = this._configuration$
            .map(function (configuration) {
            return configuration.direction;
        })
            .distinctUntilChanged()
            .subscribe(function (direction) {
            _this._navigator.playService.setDirection(direction);
        });
        this._containerWidthSubscription = this._configuration$
            .distinctUntilChanged(function (value1, value2) {
            return value1[0] === value2[0] && value1[1] === value2[1];
        }, function (configuration) {
            return [configuration.minWidth, configuration.maxWidth];
        })
            .map(function (configuration) {
            return _this._sequenceDOMRenderer.getContainerWidth(_this._container.element, configuration);
        })
            .subscribe(this._containerWidth$);
        this._playingSubscription = this._configuration$
            .map(function (configuration) {
            return configuration.playing;
        })
            .distinctUntilChanged()
            .subscribe(function (playing) {
            if (playing) {
                _this._navigator.playService.play();
            }
            else {
                _this._navigator.playService.stop();
            }
        });
        this._hoveredKeySubscription = this._sequenceDOMRenderer.mouseEnterDirection$
            .switchMap(function (direction) {
            return edgeStatus$
                .map(function (edgeStatus) {
                for (var _i = 0, _a = edgeStatus.edges; _i < _a.length; _i++) {
                    var edge = _a[_i];
                    if (edge.data.direction === direction) {
                        return edge.to;
                    }
                }
                return null;
            })
                .takeUntil(_this._sequenceDOMRenderer.mouseLeaveDirection$)
                .concat(Observable_1.Observable.of(null));
        })
            .distinctUntilChanged()
            .subscribe(this._hoveredKeySubject$);
    };
    SequenceComponent.prototype._deactivate = function () {
        this._renderSubscription.unsubscribe();
        this._playingSubscription.unsubscribe();
        this._containerWidthSubscription.unsubscribe();
        this._hoveredKeySubscription.unsubscribe();
        this._setSpeedSubscription.unsubscribe();
        this._setDirectionSubscription.unsubscribe();
        this._setSequenceGraphModeSubscription.unsubscribe();
        this._setSpatialGraphModeSubscription.unsubscribe();
        this._sequenceSubscription.unsubscribe();
        this._moveSubscription.unsubscribe();
        this._cacheSequenceNodesSubscription.unsubscribe();
        this._stopSubscription.unsubscribe();
        this._sequenceDOMRenderer.deactivate();
    };
    SequenceComponent.prototype._getDefaultConfiguration = function () {
        return {
            direction: Edge_1.EdgeDirection.Next,
            maxWidth: 108,
            minWidth: 70,
            playing: false,
            visible: true,
        };
    };
    /** @inheritdoc */
    SequenceComponent.componentName = "sequence";
    /**
     * Event fired when playing starts or stops.
     *
     * @event PlayerComponent#playingchanged
     * @type {boolean} Indicates whether the player is playing.
     */
    SequenceComponent.playingchanged = "playingchanged";
    return SequenceComponent;
}(Component_1.Component));
exports.SequenceComponent = SequenceComponent;
Component_1.ComponentService.register(SequenceComponent);
exports.default = SequenceComponent;

},{"../../Component":291,"../../Edge":292,"../../Graph":295,"rxjs/Observable":29,"rxjs/Subject":34,"rxjs/add/observable/combineLatest":38,"rxjs/add/observable/concat":39,"rxjs/add/observable/of":46,"rxjs/add/operator/auditTime":50,"rxjs/add/operator/bufferCount":52,"rxjs/add/operator/concat":56,"rxjs/add/operator/distinctUntilChanged":60,"rxjs/add/operator/filter":63,"rxjs/add/operator/finally":64,"rxjs/add/operator/first":65,"rxjs/add/operator/map":67,"rxjs/add/operator/publishReplay":74,"rxjs/add/operator/retry":76,"rxjs/add/operator/scan":78,"rxjs/add/operator/share":79,"rxjs/add/operator/switchMap":84,"rxjs/add/operator/takeUntil":86,"rxjs/add/operator/withLatestFrom":90}],351:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var vd = require("virtual-dom");
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
var Component_1 = require("../../Component");
var Edge_1 = require("../../Edge");
var Error_1 = require("../../Error");
var SequenceDOMRenderer = /** @class */ (function () {
    function SequenceDOMRenderer(container) {
        this._container = container;
        this._minThresholdWidth = 320;
        this._maxThresholdWidth = 1480;
        this._minThresholdHeight = 240;
        this._maxThresholdHeight = 820;
        this._stepperDefaultWidth = 108;
        this._controlsDefaultWidth = 88;
        this._defaultHeight = 30;
        this._expandControls = false;
        this._mode = Component_1.SequenceMode.Default;
        this._speed = 0.5;
        this._changingSpeed = false;
        this._index = null;
        this._changingPosition = false;
        this._mouseEnterDirection$ = new Subject_1.Subject();
        this._mouseLeaveDirection$ = new Subject_1.Subject();
        this._notifyChanged$ = new Subject_1.Subject();
        this._notifyChangingPositionChanged$ = new Subject_1.Subject();
        this._notifySpeedChanged$ = new Subject_1.Subject();
        this._notifyIndexChanged$ = new Subject_1.Subject();
    }
    Object.defineProperty(SequenceDOMRenderer.prototype, "changed$", {
        get: function () {
            return this._notifyChanged$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SequenceDOMRenderer.prototype, "changingPositionChanged$", {
        get: function () {
            return this._notifyChangingPositionChanged$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SequenceDOMRenderer.prototype, "speed$", {
        get: function () {
            return this._notifySpeedChanged$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SequenceDOMRenderer.prototype, "index$", {
        get: function () {
            return this._notifyIndexChanged$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SequenceDOMRenderer.prototype, "mouseEnterDirection$", {
        get: function () {
            return this._mouseEnterDirection$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SequenceDOMRenderer.prototype, "mouseLeaveDirection$", {
        get: function () {
            return this._mouseLeaveDirection$;
        },
        enumerable: true,
        configurable: true
    });
    SequenceDOMRenderer.prototype.activate = function () {
        var _this = this;
        if (!!this._changingSubscription) {
            return;
        }
        this._changingSubscription = Observable_1.Observable
            .merge(this._container.mouseService.documentMouseUp$, this._container.touchService.touchEnd$
            .filter(function (touchEvent) {
            return touchEvent.touches.length === 0;
        }))
            .subscribe(function (event) {
            if (_this._changingSpeed) {
                _this._changingSpeed = false;
            }
            if (_this._changingPosition) {
                _this._setChangingPosition(false);
            }
        });
    };
    SequenceDOMRenderer.prototype.deactivate = function () {
        if (!this._changingSubscription) {
            return;
        }
        this._changingSpeed = false;
        this._changingPosition = false;
        this._expandControls = false;
        this._mode = Component_1.SequenceMode.Default;
        this._changingSubscription.unsubscribe();
        this._changingSubscription = null;
    };
    SequenceDOMRenderer.prototype.render = function (edgeStatus, configuration, containerWidth, speed, index, max, component, navigator) {
        if (configuration.visible === false) {
            return vd.h("div.SequenceContainer", {}, []);
        }
        var stepper = this._createStepper(edgeStatus, configuration, containerWidth, component, navigator);
        var controls = this._createSequenceControls(containerWidth);
        var playback = this._createPlaybackControls(containerWidth, speed, component, configuration);
        var timeline = this._createTimelineControls(containerWidth, index, max);
        return vd.h("div.SequenceContainer", [stepper, controls, playback, timeline]);
    };
    SequenceDOMRenderer.prototype.getContainerWidth = function (element, configuration) {
        var elementWidth = element.offsetWidth;
        var elementHeight = element.offsetHeight;
        var minWidth = configuration.minWidth;
        var maxWidth = configuration.maxWidth;
        if (maxWidth < minWidth) {
            maxWidth = minWidth;
        }
        var relativeWidth = (elementWidth - this._minThresholdWidth) / (this._maxThresholdWidth - this._minThresholdWidth);
        var relativeHeight = (elementHeight - this._minThresholdHeight) / (this._maxThresholdHeight - this._minThresholdHeight);
        var coeff = Math.max(0, Math.min(1, Math.min(relativeWidth, relativeHeight)));
        return minWidth + coeff * (maxWidth - minWidth);
    };
    SequenceDOMRenderer.prototype._createPositionInput = function (index, max) {
        var _this = this;
        this._index = index;
        var onPosition = function (e) {
            _this._index = Number(e.target.value);
            _this._notifyIndexChanged$.next(_this._index);
        };
        var boundingRect = this._container.domContainer.getBoundingClientRect();
        var width = Math.max(276, Math.min(410, 5 + 0.8 * boundingRect.width)) - 65;
        var onStart = function (e) {
            e.stopPropagation();
            _this._setChangingPosition(true);
        };
        var onMove = function (e) {
            if (_this._changingPosition === true) {
                e.stopPropagation();
            }
        };
        var onKeyDown = function (e) {
            if (e.key === "ArrowDown" || e.key === "ArrowLeft" ||
                e.key === "ArrowRight" || e.key === "ArrowUp") {
                e.preventDefault();
            }
        };
        var positionInputProperties = {
            max: max != null ? max : 1,
            min: 0,
            onchange: onPosition,
            oninput: onPosition,
            onkeydown: onKeyDown,
            onmousedown: onStart,
            onmousemove: onMove,
            ontouchmove: onMove,
            ontouchstart: onStart,
            style: {
                width: width + "px",
            },
            type: "range",
            value: index != null ? index : 0,
        };
        var disabled = index == null || max == null || max <= 1;
        if (disabled) {
            positionInputProperties.disabled = "true";
        }
        var positionInput = vd.h("input.SequencePosition", positionInputProperties, []);
        var positionContainerClass = disabled ? ".SequencePositionContainerDisabled" : ".SequencePositionContainer";
        return vd.h("div" + positionContainerClass, [positionInput]);
    };
    SequenceDOMRenderer.prototype._createSpeedInput = function (speed) {
        var _this = this;
        this._speed = speed;
        var onSpeed = function (e) {
            _this._speed = Number(e.target.value) / 1000;
            _this._notifySpeedChanged$.next(_this._speed);
        };
        var boundingRect = this._container.domContainer.getBoundingClientRect();
        var width = Math.max(276, Math.min(410, 5 + 0.8 * boundingRect.width)) - 160;
        var onStart = function (e) {
            _this._changingSpeed = true;
            e.stopPropagation();
        };
        var onMove = function (e) {
            if (_this._changingSpeed === true) {
                e.stopPropagation();
            }
        };
        var onKeyDown = function (e) {
            if (e.key === "ArrowDown" || e.key === "ArrowLeft" ||
                e.key === "ArrowRight" || e.key === "ArrowUp") {
                e.preventDefault();
            }
        };
        var speedInput = vd.h("input.SequenceSpeed", {
            max: 1000,
            min: 0,
            onchange: onSpeed,
            oninput: onSpeed,
            onkeydown: onKeyDown,
            onmousedown: onStart,
            onmousemove: onMove,
            ontouchmove: onMove,
            ontouchstart: onStart,
            style: {
                width: width + "px",
            },
            type: "range",
            value: 1000 * speed,
        }, []);
        return vd.h("div.SequenceSpeedContainer", [speedInput]);
    };
    SequenceDOMRenderer.prototype._createPlaybackControls = function (containerWidth, speed, component, configuration) {
        var _this = this;
        if (this._mode !== Component_1.SequenceMode.Playback) {
            return vd.h("div.SequencePlayback", []);
        }
        var switchIcon = vd.h("div.SequenceSwitchIcon.SequenceIconVisible", []);
        var direction = configuration.direction === Edge_1.EdgeDirection.Next ?
            Edge_1.EdgeDirection.Prev : Edge_1.EdgeDirection.Next;
        var playing = configuration.playing;
        var switchButtonProperties = {
            onclick: function () {
                if (!playing) {
                    component.setDirection(direction);
                }
            },
        };
        var switchButtonClassName = configuration.playing ? ".SequenceSwitchButtonDisabled" : ".SequenceSwitchButton";
        var switchButton = vd.h("div" + switchButtonClassName, switchButtonProperties, [switchIcon]);
        var slowIcon = vd.h("div.SequenceSlowIcon.SequenceIconVisible", []);
        var slowContainer = vd.h("div.SequenceSlowContainer", [slowIcon]);
        var fastIcon = vd.h("div.SequenceFastIconGrey.SequenceIconVisible", []);
        var fastContainer = vd.h("div.SequenceFastContainer", [fastIcon]);
        var closeIcon = vd.h("div.SequenceCloseIcon.SequenceIconVisible", []);
        var closeButtonProperties = {
            onclick: function () {
                _this._mode = Component_1.SequenceMode.Default;
                _this._notifyChanged$.next(_this);
            },
        };
        var closeButton = vd.h("div.SequenceCloseButton", closeButtonProperties, [closeIcon]);
        var speedInput = this._createSpeedInput(speed);
        var playbackChildren = [switchButton, slowContainer, speedInput, fastContainer, closeButton];
        var top = Math.round(containerWidth / this._stepperDefaultWidth * this._defaultHeight + 10);
        var playbackProperties = { style: { top: top + "px" } };
        return vd.h("div.SequencePlayback", playbackProperties, playbackChildren);
    };
    SequenceDOMRenderer.prototype._createPlayingButton = function (nextKey, prevKey, configuration, component) {
        var canPlay = configuration.direction === Edge_1.EdgeDirection.Next && nextKey != null ||
            configuration.direction === Edge_1.EdgeDirection.Prev && prevKey != null;
        var onclick = configuration.playing ?
            function (e) { component.stop(); } :
            canPlay ? function (e) { component.play(); } : null;
        var buttonProperties = { onclick: onclick };
        var iconClass = configuration.playing ?
            "Stop" :
            canPlay ? "Play" : "PlayDisabled";
        var iconProperties = { className: iconClass };
        if (configuration.direction === Edge_1.EdgeDirection.Prev) {
            iconProperties.style = {
                transform: "rotate(180deg) translate(50%, 50%)",
            };
        }
        var icon = vd.h("div.SequenceComponentIcon", iconProperties, []);
        var buttonClass = canPlay ? "SequencePlay" : "SequencePlayDisabled";
        return vd.h("div." + buttonClass, buttonProperties, [icon]);
    };
    SequenceDOMRenderer.prototype._createSequenceControls = function (containerWidth) {
        var _this = this;
        var borderRadius = Math.round(8 / this._stepperDefaultWidth * containerWidth);
        var expanderProperties = {
            onclick: function () {
                _this._expandControls = !_this._expandControls;
                _this._mode = Component_1.SequenceMode.Default;
                _this._notifyChanged$.next(_this);
            },
            style: {
                "border-bottom-right-radius": borderRadius + "px",
                "border-top-right-radius": borderRadius + "px",
            },
        };
        var expanderBar = vd.h("div.SequenceExpanderBar", []);
        var expander = vd.h("div.SequenceExpanderButton", expanderProperties, [expanderBar]);
        var fastIconClassName = this._mode === Component_1.SequenceMode.Playback ?
            ".SequenceFastIconGrey.SequenceIconVisible" : ".SequenceFastIcon";
        var fastIcon = vd.h("div" + fastIconClassName, []);
        var playbackProperties = {
            onclick: function () {
                _this._mode = _this._mode === Component_1.SequenceMode.Playback ?
                    Component_1.SequenceMode.Default :
                    Component_1.SequenceMode.Playback;
                _this._notifyChanged$.next(_this);
            },
        };
        var playback = vd.h("div.SequencePlaybackButton", playbackProperties, [fastIcon]);
        var timelineIconClassName = this._mode === Component_1.SequenceMode.Timeline ?
            ".SequenceTimelineIconGrey.SequenceIconVisible" : ".SequenceTimelineIcon";
        var timelineIcon = vd.h("div" + timelineIconClassName, []);
        var timelineProperties = {
            onclick: function () {
                _this._mode = _this._mode === Component_1.SequenceMode.Timeline ?
                    Component_1.SequenceMode.Default :
                    Component_1.SequenceMode.Timeline;
                _this._notifyChanged$.next(_this);
            },
        };
        var timeline = vd.h("div.SequenceTimelineButton", timelineProperties, [timelineIcon]);
        var properties = {
            style: {
                height: (this._defaultHeight / this._stepperDefaultWidth * containerWidth) + "px",
                transform: "translate(" + (containerWidth / 2 + 2) + "px, 0)",
                width: (this._controlsDefaultWidth / this._stepperDefaultWidth * containerWidth) + "px",
            },
        };
        var className = ".SequenceControls" +
            (this._expandControls ? ".SequenceControlsExpanded" : "");
        return vd.h("div" + className, properties, [playback, timeline, expander]);
    };
    SequenceDOMRenderer.prototype._createSequenceArrows = function (nextKey, prevKey, containerWidth, configuration, navigator) {
        var _this = this;
        var nextProperties = {
            onclick: nextKey != null ?
                function (e) {
                    navigator.moveDir$(Edge_1.EdgeDirection.Next)
                        .subscribe(undefined, function (error) {
                        if (!(error instanceof Error_1.AbortMapillaryError)) {
                            console.error(error);
                        }
                    });
                } :
                null,
            onmouseenter: function (e) { _this._mouseEnterDirection$.next(Edge_1.EdgeDirection.Next); },
            onmouseleave: function (e) { _this._mouseLeaveDirection$.next(Edge_1.EdgeDirection.Next); },
        };
        var borderRadius = Math.round(8 / this._stepperDefaultWidth * containerWidth);
        var prevProperties = {
            onclick: prevKey != null ?
                function (e) {
                    navigator.moveDir$(Edge_1.EdgeDirection.Prev)
                        .subscribe(undefined, function (error) {
                        if (!(error instanceof Error_1.AbortMapillaryError)) {
                            console.error(error);
                        }
                    });
                } :
                null,
            onmouseenter: function (e) { _this._mouseEnterDirection$.next(Edge_1.EdgeDirection.Prev); },
            onmouseleave: function (e) { _this._mouseLeaveDirection$.next(Edge_1.EdgeDirection.Prev); },
            style: {
                "border-bottom-left-radius": borderRadius + "px",
                "border-top-left-radius": borderRadius + "px",
            },
        };
        var nextClass = this._getStepClassName(Edge_1.EdgeDirection.Next, nextKey, configuration.highlightKey);
        var prevClass = this._getStepClassName(Edge_1.EdgeDirection.Prev, prevKey, configuration.highlightKey);
        var nextIcon = vd.h("div.SequenceComponentIcon", []);
        var prevIcon = vd.h("div.SequenceComponentIcon", []);
        return [
            vd.h("div." + prevClass, prevProperties, [prevIcon]),
            vd.h("div." + nextClass, nextProperties, [nextIcon]),
        ];
    };
    SequenceDOMRenderer.prototype._createStepper = function (edgeStatus, configuration, containerWidth, component, navigator) {
        var nextKey = null;
        var prevKey = null;
        for (var _i = 0, _a = edgeStatus.edges; _i < _a.length; _i++) {
            var edge = _a[_i];
            if (edge.data.direction === Edge_1.EdgeDirection.Next) {
                nextKey = edge.to;
            }
            if (edge.data.direction === Edge_1.EdgeDirection.Prev) {
                prevKey = edge.to;
            }
        }
        var playingButton = this._createPlayingButton(nextKey, prevKey, configuration, component);
        var buttons = this._createSequenceArrows(nextKey, prevKey, containerWidth, configuration, navigator);
        buttons.splice(1, 0, playingButton);
        var containerProperties = {
            oncontextmenu: function (event) { event.preventDefault(); },
            style: {
                height: (this._defaultHeight / this._stepperDefaultWidth * containerWidth) + "px",
                width: containerWidth + "px",
            },
        };
        return vd.h("div.SequenceStepper", containerProperties, buttons);
    };
    SequenceDOMRenderer.prototype._createTimelineControls = function (containerWidth, index, max) {
        var _this = this;
        if (this._mode !== Component_1.SequenceMode.Timeline) {
            return vd.h("div.SequenceTimeline", []);
        }
        var positionInput = this._createPositionInput(index, max);
        var closeIcon = vd.h("div.SequenceCloseIcon.SequenceIconVisible", []);
        var closeButtonProperties = {
            onclick: function () {
                _this._mode = Component_1.SequenceMode.Default;
                _this._notifyChanged$.next(_this);
            },
        };
        var closeButton = vd.h("div.SequenceCloseButton", closeButtonProperties, [closeIcon]);
        var top = Math.round(containerWidth / this._stepperDefaultWidth * this._defaultHeight + 10);
        var playbackProperties = { style: { top: top + "px" } };
        return vd.h("div.SequenceTimeline", playbackProperties, [positionInput, closeButton]);
    };
    SequenceDOMRenderer.prototype._getStepClassName = function (direction, key, highlightKey) {
        var className = direction === Edge_1.EdgeDirection.Next ?
            "SequenceStepNext" :
            "SequenceStepPrev";
        if (key == null) {
            className += "Disabled";
        }
        else {
            if (highlightKey === key) {
                className += "Highlight";
            }
        }
        return className;
    };
    SequenceDOMRenderer.prototype._setChangingPosition = function (value) {
        this._changingPosition = value;
        this._notifyChangingPositionChanged$.next(value);
    };
    return SequenceDOMRenderer;
}());
exports.SequenceDOMRenderer = SequenceDOMRenderer;
exports.default = SequenceDOMRenderer;

},{"../../Component":291,"../../Edge":292,"../../Error":293,"rxjs/Observable":29,"rxjs/Subject":34,"virtual-dom":247}],352:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var SequenceMode;
(function (SequenceMode) {
    SequenceMode[SequenceMode["Default"] = 0] = "Default";
    SequenceMode[SequenceMode["Playback"] = 1] = "Playback";
    SequenceMode[SequenceMode["Timeline"] = 2] = "Timeline";
})(SequenceMode = exports.SequenceMode || (exports.SequenceMode = {}));
exports.default = SequenceMode;

},{}],353:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var GeometryTagError_1 = require("./error/GeometryTagError");
exports.GeometryTagError = GeometryTagError_1.GeometryTagError;
var PointGeometry_1 = require("./geometry/PointGeometry");
exports.PointGeometry = PointGeometry_1.PointGeometry;
var RectGeometry_1 = require("./geometry/RectGeometry");
exports.RectGeometry = RectGeometry_1.RectGeometry;
var PolygonGeometry_1 = require("./geometry/PolygonGeometry");
exports.PolygonGeometry = PolygonGeometry_1.PolygonGeometry;
var OutlineTag_1 = require("./tag/OutlineTag");
exports.OutlineTag = OutlineTag_1.OutlineTag;
var SpotTag_1 = require("./tag/SpotTag");
exports.SpotTag = SpotTag_1.SpotTag;
var TagComponent_1 = require("./TagComponent");
exports.TagComponent = TagComponent_1.TagComponent;
var TagMode_1 = require("./TagMode");
exports.TagMode = TagMode_1.TagMode;

},{"./TagComponent":354,"./TagMode":357,"./error/GeometryTagError":361,"./geometry/PointGeometry":363,"./geometry/PolygonGeometry":364,"./geometry/RectGeometry":365,"./tag/OutlineTag":377,"./tag/SpotTag":380}],354:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var when = require("when");
var Observable_1 = require("rxjs/Observable");
require("rxjs/add/observable/combineLatest");
require("rxjs/add/observable/empty");
require("rxjs/add/observable/from");
require("rxjs/add/observable/merge");
require("rxjs/add/observable/of");
require("rxjs/add/operator/combineLatest");
require("rxjs/add/operator/concat");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/do");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/map");
require("rxjs/add/operator/merge");
require("rxjs/add/operator/mergeMap");
require("rxjs/add/operator/publishReplay");
require("rxjs/add/operator/scan");
require("rxjs/add/operator/share");
require("rxjs/add/operator/skip");
require("rxjs/add/operator/skipUntil");
require("rxjs/add/operator/startWith");
require("rxjs/add/operator/switchMap");
require("rxjs/add/operator/take");
require("rxjs/add/operator/takeUntil");
require("rxjs/add/operator/withLatestFrom");
var Component_1 = require("../../Component");
var Geo_1 = require("../../Geo");
var Render_1 = require("../../Render");
/**
 * @class TagComponent
 *
 * @classdesc Component for showing and editing tags with different
 * geometries composed from 2D basic image coordinates (see the
 * {@link Viewer} class documentation for more information about coordinate
 * systems).
 *
 * The `add` method is used for adding new tags or replacing
 * tags already in the set. Tags are removed by id.
 *
 * If a tag already in the set has the same
 * id as one of the tags added, the old tag will be removed and
 * the added tag will take its place.
 *
 * The tag component mode can be set to either be non interactive or
 * to be in creating mode of a certain geometry type.
 *
 * The tag properties can be updated at any time and the change will
 * be visibile immediately.
 *
 * Tags are only relevant to a single image because they are based on
 * 2D basic image coordinates. Tags related to a certain image should
 * be removed when the viewer is moved to another node.
 *
 * To retrive and use the tag component
 *
 * @example
 * ```
 * var viewer = new Mapillary.Viewer(
 *     "<element-id>",
 *     "<client-id>",
 *     "<my key>",
 *     { component: { tag: true } });
 *
 * var tagComponent = viewer.getComponent("tag");
 * ```
 */
var TagComponent = /** @class */ (function (_super) {
    __extends(TagComponent, _super);
    function TagComponent(name, container, navigator) {
        var _this = _super.call(this, name, container, navigator) || this;
        _this._tagDomRenderer = new Component_1.TagDOMRenderer();
        _this._tagScene = new Component_1.TagScene();
        _this._tagSet = new Component_1.TagSet();
        _this._tagCreator = new Component_1.TagCreator(_this, navigator);
        _this._viewportCoords = new Geo_1.ViewportCoords();
        _this._createHandlers = {
            "CreatePoint": new Component_1.CreatePointHandler(_this, container, navigator, _this._viewportCoords, _this._tagCreator),
            "CreatePolygon": new Component_1.CreatePolygonHandler(_this, container, navigator, _this._viewportCoords, _this._tagCreator),
            "CreateRect": new Component_1.CreateRectHandler(_this, container, navigator, _this._viewportCoords, _this._tagCreator),
            "CreateRectDrag": new Component_1.CreateRectDragHandler(_this, container, navigator, _this._viewportCoords, _this._tagCreator),
            "Default": undefined,
        };
        _this._editVertexHandler = new Component_1.EditVertexHandler(_this, container, navigator, _this._viewportCoords, _this._tagSet);
        _this._renderTags$ = _this._tagSet.changed$
            .map(function (tagSet) {
            var tags = tagSet.getAll();
            // ensure that tags are always rendered in the same order
            // to avoid hover tracking problems on first resize.
            tags.sort(function (t1, t2) {
                var id1 = t1.tag.id;
                var id2 = t2.tag.id;
                if (id1 < id2) {
                    return -1;
                }
                if (id1 > id2) {
                    return 1;
                }
                return 0;
            });
            return tags;
        })
            .share();
        _this._tagChanged$ = _this._renderTags$
            .switchMap(function (tags) {
            return Observable_1.Observable
                .from(tags)
                .mergeMap(function (tag) {
                return Observable_1.Observable
                    .merge(tag.tag.changed$, tag.tag.geometryChanged$);
            });
        })
            .share();
        _this._renderTagGLChanged$ = _this._renderTags$
            .switchMap(function (tags) {
            return Observable_1.Observable
                .from(tags)
                .mergeMap(function (tag) {
                return tag.glObjectsChanged$;
            });
        })
            .share();
        _this._createGeometryChanged$ = _this._tagCreator.tag$
            .switchMap(function (tag) {
            return tag != null ?
                tag.geometryChanged$ :
                Observable_1.Observable.empty();
        })
            .share();
        _this._createGLObjectsChanged$ = _this._tagCreator.tag$
            .switchMap(function (tag) {
            return tag != null ?
                tag.glObjectsChanged$ :
                Observable_1.Observable.empty();
        })
            .share();
        _this._creatingConfiguration$ = _this._configuration$
            .distinctUntilChanged(function (c1, c2) {
            return c1.mode === c2.mode;
        }, function (configuration) {
            return {
                createColor: configuration.createColor,
                mode: configuration.mode,
            };
        })
            .publishReplay(1)
            .refCount();
        _this._creatingConfiguration$
            .subscribe(function (configuration) {
            _this.fire(TagComponent.modechanged, configuration.mode);
        });
        return _this;
    }
    /**
     * Add tags to the tag set or replace tags in the tag set.
     *
     * @description If a tag already in the set has the same
     * id as one of the tags added, the old tag will be removed
     * the added tag will take its place.
     *
     * @param {Array<Tag>} tags - Tags to add.
     *
     * @example ```tagComponent.add([tag1, tag2]);```
     */
    TagComponent.prototype.add = function (tags) {
        var _this = this;
        if (this._activated) {
            this._navigator.stateService.currentTransform$
                .first()
                .subscribe(function (transform) {
                _this._tagSet.add(tags, transform);
                var renderTags = tags
                    .map(function (tag) {
                    return _this._tagSet.get(tag.id);
                });
                _this._tagScene.add(renderTags);
            });
        }
        else {
            this._tagSet.addDeactivated(tags);
        }
    };
    /**
     * Change the current tag mode.
     *
     * @description Change the tag mode to one of the create modes for creating new geometries.
     *
     * @param {TagMode} mode - New tag mode.
     *
     * @fires TagComponent#modechanged
     *
     * @example ```tagComponent.changeMode(Mapillary.TagComponent.TagMode.CreateRect);```
     */
    TagComponent.prototype.changeMode = function (mode) {
        this.configure({ mode: mode });
    };
    /**
     * Returns the tag in the tag set with the specified id, or
     * undefined if the id matches no tag.
     *
     * @param {string} tagId - Id of the tag.
     *
     * @example ```var tag = tagComponent.get("tagId");```
     */
    TagComponent.prototype.get = function (tagId) {
        if (this._activated) {
            var renderTag = this._tagSet.get(tagId);
            return renderTag !== undefined ? renderTag.tag : undefined;
        }
        else {
            return this._tagSet.getDeactivated(tagId);
        }
    };
    /**
     * Returns an array of all tags.
     *
     * @example ```var tags = tagComponent.getAll();```
     */
    TagComponent.prototype.getAll = function () {
        if (this.activated) {
            return this._tagSet
                .getAll()
                .map(function (renderTag) {
                return renderTag.tag;
            });
        }
        else {
            return this._tagSet.getAllDeactivated();
        }
    };
    /**
     * Returns an array of tag ids for tags that contain the specified point.
     *
     * @description The pixel point must lie inside the polygon or rectangle
     * of an added tag for the tag id to be returned. Tag ids for
     * tags that do not have a fill will also be returned if the point is inside
     * the geometry of the tag. Tags with point geometries can not be retrieved.
     *
     * No tag ids will be returned for panoramas.
     *
     * Notice that the pixelPoint argument requires x, y coordinates from pixel space.
     *
     * With this function, you can use the coordinates provided by mouse
     * events to get information out of the tag component.
     *
     * If no tag at exist the pixel point, an empty array will be returned.
     *
     * @param {Array<number>} pixelPoint - Pixel coordinates on the viewer element.
     * @returns {Array<string>} Ids of the tags that contain the specified pixel point.
     *
     * @example
     * ```
     * tagComponent.getTagIdsAt([100, 100])
     *     .then((tagIds) => { console.log(tagIds); });
     * ```
     */
    TagComponent.prototype.getTagIdsAt = function (pixelPoint) {
        var _this = this;
        return when.promise(function (resolve, reject) {
            _this._container.renderService.renderCamera$
                .first()
                .map(function (render) {
                var viewport = _this._viewportCoords
                    .canvasToViewport(pixelPoint[0], pixelPoint[1], _this._container.element);
                var ids = _this._tagScene.intersectObjects(viewport, render.perspective);
                return ids;
            })
                .subscribe(function (ids) {
                resolve(ids);
            }, function (error) {
                reject(error);
            });
        });
    };
    /**
     * Check if a tag exist in the tag set.
     *
     * @param {string} tagId - Id of the tag.
     *
     * @example ```var tagExists = tagComponent.has("tagId");```
     */
    TagComponent.prototype.has = function (tagId) {
        return this._activated ? this._tagSet.has(tagId) : this._tagSet.hasDeactivated(tagId);
    };
    /**
     * Remove tags with the specified ids from the tag set.
     *
     * @param {Array<string>} tagIds - Ids for tags to remove.
     *
     * @example ```tagComponent.remove(["id-1", "id-2"]);```
     */
    TagComponent.prototype.remove = function (tagIds) {
        if (this._activated) {
            this._tagSet.remove(tagIds);
            this._tagScene.remove(tagIds);
        }
        else {
            this._tagSet.removeDeactivated(tagIds);
        }
    };
    /**
     * Remove all tags from the tag set.
     *
     * @example ```tagComponent.removeAll();```
     */
    TagComponent.prototype.removeAll = function () {
        if (this._activated) {
            this._tagSet.removeAll();
            this._tagScene.removeAll();
        }
        else {
            this._tagSet.removeAllDeactivated();
        }
    };
    TagComponent.prototype._activate = function () {
        var _this = this;
        this._editVertexHandler.enable();
        var handlerGeometryCreated$ = Observable_1.Observable
            .from(Object.keys(this._createHandlers))
            .map(function (key) {
            return _this._createHandlers[key];
        })
            .filter(function (handler) {
            return !!handler;
        })
            .mergeMap(function (handler) {
            return handler.geometryCreated$;
        })
            .share();
        this._fireGeometryCreatedSubscription = handlerGeometryCreated$
            .subscribe(function (geometry) {
            _this.fire(TagComponent.geometrycreated, geometry);
        });
        this._fireCreateGeometryEventSubscription = this._tagCreator.tag$
            .skipWhile(function (tag) {
            return tag == null;
        })
            .distinctUntilChanged()
            .subscribe(function (tag) {
            var eventType = tag != null ?
                TagComponent.creategeometrystart :
                TagComponent.creategeometryend;
            _this.fire(eventType, _this);
        });
        this._handlerStopCreateSubscription = handlerGeometryCreated$
            .subscribe(function () {
            _this.changeMode(Component_1.TagMode.Default);
        });
        this._handlerEnablerSubscription = this._creatingConfiguration$
            .subscribe(function (configuration) {
            _this._disableCreateHandlers();
            var mode = Component_1.TagMode[configuration.mode];
            var handler = _this._createHandlers[mode];
            if (!!handler) {
                handler.enable();
            }
        });
        this._fireTagsChangedSubscription = this._renderTags$
            .subscribe(function (tags) {
            _this.fire(TagComponent.tagschanged, _this);
        });
        this._stopCreateSubscription = this._tagCreator.tag$
            .switchMap(function (tag) {
            return tag != null ?
                tag.aborted$
                    .map(function (t) { return null; }) :
                Observable_1.Observable.empty();
        })
            .subscribe(function () { _this.changeMode(Component_1.TagMode.Default); });
        this._setGLCreateTagSubscription = this._tagCreator.tag$
            .subscribe(function (tag) {
            if (_this._tagScene.hasCreateTag()) {
                _this._tagScene.removeCreateTag();
            }
            if (tag != null) {
                _this._tagScene.addCreateTag(tag);
            }
        });
        this._createGLObjectsChangedSubscription = this._createGLObjectsChanged$
            .subscribe(function (tag) {
            _this._tagScene.updateCreateTagObjects(tag);
        });
        this._updateGLObjectsSubscription = this._renderTagGLChanged$
            .subscribe(function (tag) {
            _this._tagScene.updateObjects(tag);
        });
        this._updateTagSceneSubscription = this._tagChanged$
            .subscribe(function (tag) {
            _this._tagScene.update();
        });
        this._domSubscription = this._renderTags$
            .startWith([])
            .do(function (tags) {
            _this._container.domRenderer.render$.next({
                name: _this._name,
                vnode: _this._tagDomRenderer.clear(),
            });
        })
            .combineLatest(this._container.renderService.renderCamera$, this._container.spriteService.spriteAtlas$, this._container.renderService.size$, this._tagChanged$.startWith(null), this._tagCreator.tag$.merge(this._createGeometryChanged$).startWith(null), function (renderTags, rc, atlas, size, tag, ct) {
            return [rc, atlas, size, renderTags, tag, ct];
        })
            .map(function (args) {
            return {
                name: _this._name,
                vnode: _this._tagDomRenderer.render(args[3], args[5], args[1], args[0].perspective, args[2]),
            };
        })
            .subscribe(this._container.domRenderer.render$);
        this._glSubscription = this._navigator.stateService.currentState$
            .map(function (frame) {
            var tagScene = _this._tagScene;
            return {
                name: _this._name,
                render: {
                    frameId: frame.id,
                    needsRender: tagScene.needsRender,
                    render: tagScene.render.bind(tagScene),
                    stage: Render_1.GLRenderStage.Foreground,
                },
            };
        })
            .subscribe(this._container.glRenderer.render$);
        this._navigator.stateService.currentTransform$
            .first()
            .subscribe(function (transform) {
            _this._tagSet.activate(transform);
            _this._tagScene.add(_this._tagSet.getAll());
        });
    };
    TagComponent.prototype._deactivate = function () {
        this._editVertexHandler.disable();
        this._disableCreateHandlers();
        this._tagScene.clear();
        this._tagSet.deactivate();
        this._tagCreator.delete$.next(null);
        this._updateGLObjectsSubscription.unsubscribe();
        this._updateTagSceneSubscription.unsubscribe();
        this._stopCreateSubscription.unsubscribe();
        this._setGLCreateTagSubscription.unsubscribe();
        this._createGLObjectsChangedSubscription.unsubscribe();
        this._domSubscription.unsubscribe();
        this._glSubscription.unsubscribe();
        this._fireCreateGeometryEventSubscription.unsubscribe();
        this._fireGeometryCreatedSubscription.unsubscribe();
        this._fireTagsChangedSubscription.unsubscribe();
        this._handlerStopCreateSubscription.unsubscribe();
        this._handlerEnablerSubscription.unsubscribe();
        this._container.element.classList.remove("component-tag-create");
    };
    TagComponent.prototype._getDefaultConfiguration = function () {
        return {
            createColor: 0xFFFFFF,
            mode: Component_1.TagMode.Default,
        };
    };
    TagComponent.prototype._disableCreateHandlers = function () {
        var createHandlers = this._createHandlers;
        for (var key in createHandlers) {
            if (!createHandlers.hasOwnProperty(key)) {
                continue;
            }
            var handler = createHandlers[key];
            if (!!handler) {
                handler.disable();
            }
        }
    };
    /** @inheritdoc */
    TagComponent.componentName = "tag";
    /**
     * Event fired when an interaction to create a geometry ends.
     *
     * @description A create interaction can by a geometry being created
     * or by the creation being aborted.
     *
     * @event TagComponent#creategeometryend
     * @type {TagComponent} Tag component.
     * @example
     * ```
     * tagComponent.on("creategeometryend", function(component) {
     *     console.log(component);
     * });
     * ```
     */
    TagComponent.creategeometryend = "creategeometryend";
    /**
     * Event fired when an interaction to create a geometry starts.
     *
     * @description A create interaction starts when the first vertex
     * is created in the geometry.
     *
     * @event TagComponent#creategeometrystart
     * @type {TagComponent} Tag component.
     * @example
     * ```
     * tagComponent.on("creategeometrystart", function(component) {
     *     console.log(component);
     * });
     * ```
     */
    TagComponent.creategeometrystart = "creategeometrystart";
    /**
     * Event fired when the create mode is changed.
     *
     * @event TagComponent#modechanged
     * @type {TagMode} Tag mode
     * @example
     * ```
     * tagComponent.on("modechanged", function(mode) {
     *     console.log(mode);
     * });
     * ```
     */
    TagComponent.modechanged = "modechanged";
    /**
     * Event fired when a geometry has been created.
     *
     * @event TagComponent#geometrycreated
     * @type {Geometry} Created geometry.
     * @example
     * ```
     * tagComponent.on("geometrycreated", function(geometry) {
     *     console.log(geometry);
     * });
     * ```
     */
    TagComponent.geometrycreated = "geometrycreated";
    /**
     * Event fired when the tags collection has changed.
     *
     * @event TagComponent#tagschanged
     * @type {TagComponent} Tag component.
     * @example
     * ```
     * tagComponent.on("tagschanged", function(component) {
     *     console.log(component.getAll());
     * });
     * ```
     */
    TagComponent.tagschanged = "tagschanged";
    return TagComponent;
}(Component_1.Component));
exports.TagComponent = TagComponent;
Component_1.ComponentService.register(TagComponent);
exports.default = TagComponent;

},{"../../Component":291,"../../Geo":294,"../../Render":297,"rxjs/Observable":29,"rxjs/add/observable/combineLatest":38,"rxjs/add/observable/empty":41,"rxjs/add/observable/from":42,"rxjs/add/observable/merge":45,"rxjs/add/observable/of":46,"rxjs/add/operator/combineLatest":55,"rxjs/add/operator/concat":56,"rxjs/add/operator/distinctUntilChanged":60,"rxjs/add/operator/do":61,"rxjs/add/operator/filter":63,"rxjs/add/operator/map":67,"rxjs/add/operator/merge":68,"rxjs/add/operator/mergeMap":70,"rxjs/add/operator/publishReplay":74,"rxjs/add/operator/scan":78,"rxjs/add/operator/share":79,"rxjs/add/operator/skip":80,"rxjs/add/operator/skipUntil":81,"rxjs/add/operator/startWith":83,"rxjs/add/operator/switchMap":84,"rxjs/add/operator/take":85,"rxjs/add/operator/takeUntil":86,"rxjs/add/operator/withLatestFrom":90,"when":288}],355:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/operator/map");
require("rxjs/add/operator/scan");
require("rxjs/add/operator/share");
require("rxjs/add/operator/withLatestFrom");
var Component_1 = require("../../Component");
var TagCreator = /** @class */ (function () {
    function TagCreator(component, navigator) {
        this._component = component;
        this._navigator = navigator;
        this._tagOperation$ = new Subject_1.Subject();
        this._createPolygon$ = new Subject_1.Subject();
        this._createRect$ = new Subject_1.Subject();
        this._delete$ = new Subject_1.Subject();
        this._tag$ = this._tagOperation$
            .scan(function (tag, operation) {
            return operation(tag);
        }, null)
            .share();
        this._createRect$
            .withLatestFrom(this._component.configuration$, this._navigator.stateService.currentTransform$)
            .map(function (_a) {
            var coord = _a[0], conf = _a[1], transform = _a[2];
            return function (tag) {
                var geometry = new Component_1.RectGeometry([
                    coord[0],
                    coord[1],
                    coord[0],
                    coord[1],
                ]);
                return new Component_1.OutlineCreateTag(geometry, { color: conf.createColor }, transform);
            };
        })
            .subscribe(this._tagOperation$);
        this._createPolygon$
            .withLatestFrom(this._component.configuration$, this._navigator.stateService.currentTransform$)
            .map(function (_a) {
            var coord = _a[0], conf = _a[1], transform = _a[2];
            return function (tag) {
                var geometry = new Component_1.PolygonGeometry([
                    [coord[0], coord[1]],
                    [coord[0], coord[1]],
                    [coord[0], coord[1]],
                ]);
                return new Component_1.OutlineCreateTag(geometry, { color: conf.createColor }, transform);
            };
        })
            .subscribe(this._tagOperation$);
        this._delete$
            .map(function () {
            return function (tag) {
                return null;
            };
        })
            .subscribe(this._tagOperation$);
    }
    Object.defineProperty(TagCreator.prototype, "createRect$", {
        get: function () {
            return this._createRect$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TagCreator.prototype, "createPolygon$", {
        get: function () {
            return this._createPolygon$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TagCreator.prototype, "delete$", {
        get: function () {
            return this._delete$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TagCreator.prototype, "tag$", {
        get: function () {
            return this._tag$;
        },
        enumerable: true,
        configurable: true
    });
    return TagCreator;
}());
exports.TagCreator = TagCreator;
exports.default = TagCreator;

},{"../../Component":291,"rxjs/Subject":34,"rxjs/add/operator/map":67,"rxjs/add/operator/scan":78,"rxjs/add/operator/share":79,"rxjs/add/operator/withLatestFrom":90}],356:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var vd = require("virtual-dom");
var TagDOMRenderer = /** @class */ (function () {
    function TagDOMRenderer() {
    }
    TagDOMRenderer.prototype.render = function (tags, createTag, atlas, camera, size) {
        var vNodes = [];
        for (var _i = 0, tags_1 = tags; _i < tags_1.length; _i++) {
            var tag = tags_1[_i];
            vNodes = vNodes.concat(tag.getDOMObjects(atlas, camera, size));
        }
        if (createTag != null) {
            vNodes = vNodes.concat(createTag.getDOMObjects(camera, size));
        }
        return vd.h("div.TagContainer", {}, vNodes);
    };
    TagDOMRenderer.prototype.clear = function () {
        return vd.h("div", {}, []);
    };
    return TagDOMRenderer;
}());
exports.TagDOMRenderer = TagDOMRenderer;

},{"virtual-dom":247}],357:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Enumeration for tag modes
 * @enum {number}
 * @readonly
 * @description Modes for the interaction in the tag component.
 */
var TagMode;
(function (TagMode) {
    /**
     * Disables creating tags.
     */
    TagMode[TagMode["Default"] = 0] = "Default";
    /**
     * Create a point geometry through a click.
     */
    TagMode[TagMode["CreatePoint"] = 1] = "CreatePoint";
    /**
     * Create a polygon geometry through clicks.
     */
    TagMode[TagMode["CreatePolygon"] = 2] = "CreatePolygon";
    /**
     * Create a rect geometry through clicks.
     */
    TagMode[TagMode["CreateRect"] = 3] = "CreateRect";
    /**
     * Create a rect geometry through drag.
     *
     * @description Claims the mouse which results in mouse handlers like
     * drag pan and scroll zoom becoming inactive.
     */
    TagMode[TagMode["CreateRectDrag"] = 4] = "CreateRectDrag";
})(TagMode = exports.TagMode || (exports.TagMode = {}));
exports.default = TagMode;

},{}],358:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TagOperation;
(function (TagOperation) {
    TagOperation[TagOperation["None"] = 0] = "None";
    TagOperation[TagOperation["Centroid"] = 1] = "Centroid";
    TagOperation[TagOperation["Vertex"] = 2] = "Vertex";
})(TagOperation = exports.TagOperation || (exports.TagOperation = {}));
exports.default = TagOperation;

},{}],359:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var TagScene = /** @class */ (function () {
    function TagScene(scene, raycaster) {
        this._createTag = null;
        this._needsRender = false;
        this._raycaster = !!raycaster ? raycaster : new THREE.Raycaster();
        this._scene = !!scene ? scene : new THREE.Scene();
        this._objectTags = {};
        this._retrievableObjects = [];
        this._tags = {};
    }
    Object.defineProperty(TagScene.prototype, "needsRender", {
        get: function () {
            return this._needsRender;
        },
        enumerable: true,
        configurable: true
    });
    TagScene.prototype.add = function (tags) {
        for (var _i = 0, tags_1 = tags; _i < tags_1.length; _i++) {
            var tag = tags_1[_i];
            if (tag.tag.id in this._tags) {
                this._remove(tag.tag.id);
            }
            this._add(tag);
        }
        this._needsRender = true;
    };
    TagScene.prototype.addCreateTag = function (tag) {
        for (var _i = 0, _a = tag.glObjects; _i < _a.length; _i++) {
            var object = _a[_i];
            this._scene.add(object);
        }
        this._createTag = { tag: tag, objects: tag.glObjects };
        this._needsRender = true;
    };
    TagScene.prototype.clear = function () {
        for (var _i = 0, _a = Object.keys(this._tags); _i < _a.length; _i++) {
            var id = _a[_i];
            this._remove(id);
        }
        this._needsRender = false;
    };
    TagScene.prototype.get = function (id) {
        return this.has(id) ? this._tags[id].tag : undefined;
    };
    TagScene.prototype.has = function (id) {
        return id in this._tags;
    };
    TagScene.prototype.hasCreateTag = function () {
        return this._createTag != null;
    };
    TagScene.prototype.intersectObjects = function (_a, camera) {
        var viewportX = _a[0], viewportY = _a[1];
        this._raycaster.setFromCamera(new THREE.Vector2(viewportX, viewportY), camera);
        var intersects = this._raycaster.intersectObjects(this._retrievableObjects);
        var intersectedIds = [];
        for (var _i = 0, intersects_1 = intersects; _i < intersects_1.length; _i++) {
            var intersect = intersects_1[_i];
            if (intersect.object.uuid in this._objectTags) {
                intersectedIds.push(this._objectTags[intersect.object.uuid]);
            }
        }
        return intersectedIds;
    };
    TagScene.prototype.remove = function (ids) {
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var id = ids_1[_i];
            this._remove(id);
        }
        this._needsRender = true;
    };
    TagScene.prototype.removeAll = function () {
        for (var _i = 0, _a = Object.keys(this._tags); _i < _a.length; _i++) {
            var id = _a[_i];
            this._remove(id);
        }
        this._needsRender = true;
    };
    TagScene.prototype.removeCreateTag = function () {
        if (this._createTag == null) {
            return;
        }
        for (var _i = 0, _a = this._createTag.objects; _i < _a.length; _i++) {
            var object = _a[_i];
            this._scene.remove(object);
        }
        this._createTag.tag.dispose();
        this._createTag = null;
        this._needsRender = true;
    };
    TagScene.prototype.render = function (perspectiveCamera, renderer) {
        renderer.render(this._scene, perspectiveCamera);
        this._needsRender = false;
    };
    TagScene.prototype.update = function () {
        this._needsRender = true;
    };
    TagScene.prototype.updateCreateTagObjects = function (tag) {
        if (this._createTag.tag !== tag) {
            throw new Error("Create tags do not have the same reference.");
        }
        for (var _i = 0, _a = this._createTag.objects; _i < _a.length; _i++) {
            var object = _a[_i];
            this._scene.remove(object);
        }
        for (var _b = 0, _c = tag.glObjects; _b < _c.length; _b++) {
            var object = _c[_b];
            this._scene.add(object);
        }
        this._createTag.objects = tag.glObjects;
        this._needsRender = true;
    };
    TagScene.prototype.updateObjects = function (tag) {
        var id = tag.tag.id;
        if (this._tags[id].tag !== tag) {
            throw new Error("Tags do not have the same reference.");
        }
        var tagObjects = this._tags[id];
        this._removeObjects(tagObjects);
        delete this._tags[id];
        this._add(tag);
        this._needsRender = true;
    };
    TagScene.prototype._add = function (tag) {
        var id = tag.tag.id;
        var tagObjects = { tag: tag, objects: [], retrievableObjects: [] };
        this._tags[id] = tagObjects;
        for (var _i = 0, _a = tag.getGLObjects(); _i < _a.length; _i++) {
            var object = _a[_i];
            tagObjects.objects.push(object);
            this._scene.add(object);
        }
        for (var _b = 0, _c = tag.getRetrievableObjects(); _b < _c.length; _b++) {
            var retrievableObject = _c[_b];
            tagObjects.retrievableObjects.push(retrievableObject);
            this._retrievableObjects.push(retrievableObject);
            this._objectTags[retrievableObject.uuid] = tag.tag.id;
        }
    };
    TagScene.prototype._remove = function (id) {
        var tagObjects = this._tags[id];
        this._removeObjects(tagObjects);
        tagObjects.tag.dispose();
        delete this._tags[id];
    };
    TagScene.prototype._removeObjects = function (tagObjects) {
        for (var _i = 0, _a = tagObjects.objects; _i < _a.length; _i++) {
            var object = _a[_i];
            this._scene.remove(object);
        }
        for (var _b = 0, _c = tagObjects.retrievableObjects; _b < _c.length; _b++) {
            var retrievableObject = _c[_b];
            var index = this._retrievableObjects.indexOf(retrievableObject);
            if (index !== -1) {
                this._retrievableObjects.splice(index, 1);
            }
        }
    };
    return TagScene;
}());
exports.TagScene = TagScene;
exports.default = TagScene;

},{"three":241}],360:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/operator/map");
require("rxjs/add/operator/scan");
require("rxjs/add/operator/share");
var Component_1 = require("../../Component");
var TagSet = /** @class */ (function () {
    function TagSet() {
        this._active = false;
        this._hash = {};
        this._hashDeactivated = {};
        this._notifyChanged$ = new Subject_1.Subject();
    }
    Object.defineProperty(TagSet.prototype, "active", {
        get: function () {
            return this._active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TagSet.prototype, "changed$", {
        get: function () {
            return this._notifyChanged$;
        },
        enumerable: true,
        configurable: true
    });
    TagSet.prototype.activate = function (transform) {
        if (this._active) {
            return;
        }
        for (var id in this._hashDeactivated) {
            if (!this._hashDeactivated.hasOwnProperty(id)) {
                continue;
            }
            var tag = this._hashDeactivated[id];
            this._add(tag, transform);
        }
        this._hashDeactivated = {};
        this._active = true;
        this._notifyChanged$.next(this);
    };
    TagSet.prototype.deactivate = function () {
        if (!this._active) {
            return;
        }
        for (var id in this._hash) {
            if (!this._hash.hasOwnProperty(id)) {
                continue;
            }
            this._hashDeactivated[id] = this._hash[id].tag;
        }
        this._hash = {};
        this._active = false;
    };
    TagSet.prototype.add = function (tags, transform) {
        this._assertActivationState(true);
        for (var _i = 0, tags_1 = tags; _i < tags_1.length; _i++) {
            var tag = tags_1[_i];
            this._add(tag, transform);
        }
        this._notifyChanged$.next(this);
    };
    TagSet.prototype.addDeactivated = function (tags) {
        this._assertActivationState(false);
        for (var _i = 0, tags_2 = tags; _i < tags_2.length; _i++) {
            var tag = tags_2[_i];
            if (!(tag instanceof Component_1.OutlineTag || tag instanceof Component_1.SpotTag)) {
                throw new Error("Tag type not supported");
            }
            this._hashDeactivated[tag.id] = tag;
        }
    };
    TagSet.prototype.get = function (id) {
        return this.has(id) ? this._hash[id] : undefined;
    };
    TagSet.prototype.getAll = function () {
        var hash = this._hash;
        return Object.keys(hash)
            .map(function (id) {
            return hash[id];
        });
    };
    TagSet.prototype.getAllDeactivated = function () {
        var hashDeactivated = this._hashDeactivated;
        return Object.keys(hashDeactivated)
            .map(function (id) {
            return hashDeactivated[id];
        });
    };
    TagSet.prototype.getDeactivated = function (id) {
        return this.hasDeactivated(id) ? this._hashDeactivated[id] : undefined;
    };
    TagSet.prototype.has = function (id) {
        return id in this._hash;
    };
    TagSet.prototype.hasDeactivated = function (id) {
        return id in this._hashDeactivated;
    };
    TagSet.prototype.remove = function (ids) {
        this._assertActivationState(true);
        var hash = this._hash;
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var id = ids_1[_i];
            if (!(id in hash)) {
                continue;
            }
            delete hash[id];
        }
        this._notifyChanged$.next(this);
    };
    TagSet.prototype.removeAll = function () {
        this._assertActivationState(true);
        this._hash = {};
        this._notifyChanged$.next(this);
    };
    TagSet.prototype.removeAllDeactivated = function () {
        this._assertActivationState(false);
        this._hashDeactivated = {};
    };
    TagSet.prototype.removeDeactivated = function (ids) {
        this._assertActivationState(false);
        var hashDeactivated = this._hashDeactivated;
        for (var _i = 0, ids_2 = ids; _i < ids_2.length; _i++) {
            var id = ids_2[_i];
            if (!(id in hashDeactivated)) {
                continue;
            }
            delete hashDeactivated[id];
        }
    };
    TagSet.prototype._add = function (tag, transform) {
        if (tag instanceof Component_1.OutlineTag) {
            this._hash[tag.id] = new Component_1.OutlineRenderTag(tag, transform);
        }
        else if (tag instanceof Component_1.SpotTag) {
            this._hash[tag.id] = new Component_1.SpotRenderTag(tag, transform);
        }
        else {
            throw new Error("Tag type not supported");
        }
    };
    TagSet.prototype._assertActivationState = function (should) {
        if (should !== this._active) {
            throw new Error("Tag set not in correct state for operation.");
        }
    };
    return TagSet;
}());
exports.TagSet = TagSet;
exports.default = TagSet;

},{"../../Component":291,"rxjs/Subject":34,"rxjs/add/operator/map":67,"rxjs/add/operator/scan":78,"rxjs/add/operator/share":79}],361:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Error_1 = require("../../../Error");
var GeometryTagError = /** @class */ (function (_super) {
    __extends(GeometryTagError, _super);
    function GeometryTagError(message) {
        var _this = _super.call(this, message != null ? message : "The provided geometry value is incorrect") || this;
        _this.name = "GeometryTagError";
        return _this;
    }
    return GeometryTagError;
}(Error_1.MapillaryError));
exports.GeometryTagError = GeometryTagError;
exports.default = Error_1.MapillaryError;

},{"../../../Error":293}],362:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("rxjs/Subject");
/**
 * @class Geometry
 * @abstract
 * @classdesc Represents a geometry.
 */
var Geometry = /** @class */ (function () {
    /**
     * Create a geometry.
     *
     * @constructor
     */
    function Geometry() {
        this._notifyChanged$ = new Subject_1.Subject();
    }
    Object.defineProperty(Geometry.prototype, "changed$", {
        /**
         * Get changed observable.
         *
         * @description Emits the geometry itself every time the geometry
         * has changed.
         *
         * @returns {Observable<Geometry>} Observable emitting the geometry instance.
         * @ignore
         */
        get: function () {
            return this._notifyChanged$;
        },
        enumerable: true,
        configurable: true
    });
    return Geometry;
}());
exports.Geometry = Geometry;
exports.default = Geometry;

},{"rxjs/Subject":34}],363:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Component_1 = require("../../../Component");
/**
 * @class PointGeometry
 *
 * @classdesc Represents a point geometry in the 2D basic image coordinate system.
 *
 * @example
 * ```
 * var basicPoint = [0.5, 0.7];
 * var pointGeometry = new Mapillary.TagComponent.PointGeometry(basicPoint);
 * ```
 */
var PointGeometry = /** @class */ (function (_super) {
    __extends(PointGeometry, _super);
    /**
     * Create a point geometry.
     *
     * @constructor
     * @param {Array<number>} point - An array representing the basic coordinates of
     * the point.
     *
     * @throws {GeometryTagError} Point coordinates must be valid basic coordinates.
     */
    function PointGeometry(point) {
        var _this = _super.call(this) || this;
        var x = point[0];
        var y = point[1];
        if (x < 0 || x > 1 || y < 0 || y > 1) {
            throw new Component_1.GeometryTagError("Basic coordinates must be on the interval [0, 1].");
        }
        _this._point = point.slice();
        return _this;
    }
    Object.defineProperty(PointGeometry.prototype, "point", {
        /**
         * Get point property.
         * @returns {Array<number>} Array representing the basic coordinates of the point.
         */
        get: function () {
            return this._point;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the 2D basic coordinates for the centroid of the point, i.e. the 2D
     * basic coordinates of the point itself.
     *
     * @returns {Array<number>} 2D basic coordinates representing the centroid.
     */
    PointGeometry.prototype.getCentroid2d = function () {
        return this._point.slice();
    };
    /**
     * Get the 3D world coordinates for the centroid of the point, i.e. the 3D
     * world coordinates of the point itself.
     *
     * @param {Transform} transform - The transform of the node related to the point.
     * @returns {Array<number>} 3D world coordinates representing the centroid.
     */
    PointGeometry.prototype.getCentroid3d = function (transform) {
        return transform.unprojectBasic(this._point, 200);
    };
    /**
     * Set the centroid of the point, i.e. the point coordinates.
     *
     * @param {Array<number>} value - The new value of the centroid.
     * @param {Transform} transform - The transform of the node related to the point.
     */
    PointGeometry.prototype.setCentroid2d = function (value, transform) {
        var changed = [
            Math.max(0, Math.min(1, value[0])),
            Math.max(0, Math.min(1, value[1])),
        ];
        this._point[0] = changed[0];
        this._point[1] = changed[1];
        this._notifyChanged$.next(this);
    };
    return PointGeometry;
}(Component_1.Geometry));
exports.PointGeometry = PointGeometry;

},{"../../../Component":291}],364:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Component_1 = require("../../../Component");
/**
 * @class PolygonGeometry
 *
 * @classdesc Represents a polygon geometry in the 2D basic image coordinate system.
 * All polygons and holes provided to the constructor needs to be closed.
 *
 * @example
 * ```
 * var basicPolygon = [[0.5, 0.3], [0.7, 0.3], [0.6, 0.5], [0.5, 0.3]];
 * var polygonGeometry = new Mapillary.TagComponent.PointGeometry(basicPolygon);
 * ```
 */
var PolygonGeometry = /** @class */ (function (_super) {
    __extends(PolygonGeometry, _super);
    /**
     * Create a polygon geometry.
     *
     * @constructor
     * @param {Array<Array<number>>} polygon - Array of polygon vertices. Must be closed.
     * @param {Array<Array<Array<number>>>} [holes] - Array of arrays of hole vertices.
     * Each array of holes vertices must be closed.
     *
     * @throws {GeometryTagError} Polygon coordinates must be valid basic coordinates.
     */
    function PolygonGeometry(polygon, holes) {
        var _this = _super.call(this) || this;
        var polygonLength = polygon.length;
        if (polygonLength < 3) {
            throw new Component_1.GeometryTagError("A polygon must have three or more positions.");
        }
        if (polygon[0][0] !== polygon[polygonLength - 1][0] ||
            polygon[0][1] !== polygon[polygonLength - 1][1]) {
            throw new Component_1.GeometryTagError("First and last positions must be equivalent.");
        }
        _this._polygon = [];
        for (var _i = 0, polygon_1 = polygon; _i < polygon_1.length; _i++) {
            var vertex = polygon_1[_i];
            if (vertex[0] < 0 || vertex[0] > 1 ||
                vertex[1] < 0 || vertex[1] > 1) {
                throw new Component_1.GeometryTagError("Basic coordinates of polygon must be on the interval [0, 1].");
            }
            _this._polygon.push(vertex.slice());
        }
        _this._holes = [];
        if (holes == null) {
            return _this;
        }
        for (var i = 0; i < holes.length; i++) {
            var hole = holes[i];
            var holeLength = hole.length;
            if (holeLength < 3) {
                throw new Component_1.GeometryTagError("A polygon hole must have three or more positions.");
            }
            if (hole[0][0] !== hole[holeLength - 1][0] ||
                hole[0][1] !== hole[holeLength - 1][1]) {
                throw new Component_1.GeometryTagError("First and last positions of hole must be equivalent.");
            }
            _this._holes.push([]);
            for (var _a = 0, hole_1 = hole; _a < hole_1.length; _a++) {
                var vertex = hole_1[_a];
                if (vertex[0] < 0 || vertex[0] > 1 ||
                    vertex[1] < 0 || vertex[1] > 1) {
                    throw new Component_1.GeometryTagError("Basic coordinates of hole must be on the interval [0, 1].");
                }
                _this._holes[i].push(vertex.slice());
            }
        }
        return _this;
    }
    Object.defineProperty(PolygonGeometry.prototype, "polygon", {
        /**
         * Get polygon property.
         * @returns {Array<Array<number>>} Closed 2d polygon.
         */
        get: function () {
            return this._polygon;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PolygonGeometry.prototype, "holes", {
        /**
         * Get holes property.
         * @returns {Array<Array<Array<number>>>} Holes of 2d polygon.
         */
        get: function () {
            return this._holes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add a vertex to the polygon by appending it after the last vertex.
     *
     * @param {Array<number>} vertex - Vertex to add.
     */
    PolygonGeometry.prototype.addVertex2d = function (vertex) {
        var clamped = [
            Math.max(0, Math.min(1, vertex[0])),
            Math.max(0, Math.min(1, vertex[1])),
        ];
        this._polygon.splice(this._polygon.length - 1, 0, clamped);
        this._notifyChanged$.next(this);
    };
    /**
     * Get the coordinates of a vertex from the polygon representation of the geometry.
     *
     * @description The first vertex represents the bottom-left corner with the rest of
     * the vertices following in clockwise order.
     *
     * @param {number} index - Vertex index.
     * @returns {Array<number>} Array representing the 2D basic coordinates of the vertex.
     */
    PolygonGeometry.prototype.getVertex2d = function (index) {
        return this._polygon[index].slice();
    };
    /**
     * Remove a vertex from the polygon.
     *
     * @param {number} index - The index of the vertex to remove.
     */
    PolygonGeometry.prototype.removeVertex2d = function (index) {
        if (index < 0 ||
            index >= this._polygon.length ||
            this._polygon.length < 4) {
            throw new Component_1.GeometryTagError("Index for removed vertex must be valid.");
        }
        if (index > 0 && index < this._polygon.length - 1) {
            this._polygon.splice(index, 1);
        }
        else {
            this._polygon.splice(0, 1);
            this._polygon.pop();
            var closing = this._polygon[0].slice();
            this._polygon.push(closing);
        }
        this._notifyChanged$.next(this);
    };
    /** @inheritdoc */
    PolygonGeometry.prototype.setVertex2d = function (index, value, transform) {
        var changed = [
            Math.max(0, Math.min(1, value[0])),
            Math.max(0, Math.min(1, value[1])),
        ];
        if (index === 0 || index === this._polygon.length - 1) {
            this._polygon[0] = changed.slice();
            this._polygon[this._polygon.length - 1] = changed.slice();
        }
        else {
            this._polygon[index] = changed.slice();
        }
        this._notifyChanged$.next(this);
    };
    /** @inheritdoc */
    PolygonGeometry.prototype.setCentroid2d = function (value, transform) {
        var xs = this._polygon.map(function (point) { return point[0]; });
        var ys = this._polygon.map(function (point) { return point[1]; });
        var minX = Math.min.apply(Math, xs);
        var maxX = Math.max.apply(Math, xs);
        var minY = Math.min.apply(Math, ys);
        var maxY = Math.max.apply(Math, ys);
        var centroid = this.getCentroid2d();
        var minTranslationX = -minX;
        var maxTranslationX = 1 - maxX;
        var minTranslationY = -minY;
        var maxTranslationY = 1 - maxY;
        var translationX = Math.max(minTranslationX, Math.min(maxTranslationX, value[0] - centroid[0]));
        var translationY = Math.max(minTranslationY, Math.min(maxTranslationY, value[1] - centroid[1]));
        for (var _i = 0, _a = this._polygon; _i < _a.length; _i++) {
            var point = _a[_i];
            point[0] += translationX;
            point[1] += translationY;
        }
        this._notifyChanged$.next(this);
    };
    /** @inheritdoc */
    PolygonGeometry.prototype.getPoints3d = function (transform) {
        return this.getVertices3d(transform);
    };
    /** @inheritdoc */
    PolygonGeometry.prototype.getVertex3d = function (index, transform) {
        return transform.unprojectBasic(this._polygon[index], 200);
    };
    /** @inheritdoc */
    PolygonGeometry.prototype.getVertices2d = function () {
        return this._polygon.slice();
    };
    /** @inheritdoc */
    PolygonGeometry.prototype.getVertices3d = function (transform) {
        return this._polygon
            .map(function (point) {
            return transform.unprojectBasic(point, 200);
        });
    };
    /**
     * Get a polygon representation of the 3D coordinates for the vertices of each hole
     * of the geometry.
     *
     * @param {Transform} transform - The transform of the node related to the geometry.
     * @returns {Array<Array<Array<number>>>} Array of hole polygons in 3D world coordinates
     * representing the vertices of each hole of the geometry.
     */
    PolygonGeometry.prototype.getHoleVertices3d = function (transform) {
        var holes3d = [];
        for (var _i = 0, _a = this._holes; _i < _a.length; _i++) {
            var hole = _a[_i];
            var hole3d = hole
                .map(function (point) {
                return transform.unprojectBasic(point, 200);
            });
            holes3d.push(hole3d);
        }
        return holes3d;
    };
    /** @inheritdoc */
    PolygonGeometry.prototype.getCentroid2d = function () {
        var polygon = this._polygon;
        var area = 0;
        var centroidX = 0;
        var centroidY = 0;
        for (var i = 0; i < polygon.length - 1; i++) {
            var xi = polygon[i][0];
            var yi = polygon[i][1];
            var xi1 = polygon[i + 1][0];
            var yi1 = polygon[i + 1][1];
            var a = xi * yi1 - xi1 * yi;
            area += a;
            centroidX += (xi + xi1) * a;
            centroidY += (yi + yi1) * a;
        }
        area /= 2;
        centroidX /= 6 * area;
        centroidY /= 6 * area;
        return [centroidX, centroidY];
    };
    /** @inheritdoc */
    PolygonGeometry.prototype.getCentroid3d = function (transform) {
        var centroid2d = this.getCentroid2d();
        return transform.unprojectBasic(centroid2d, 200);
    };
    /** @inheritdoc */
    PolygonGeometry.prototype.getTriangles3d = function (transform) {
        return this._triangulate(this._polygon, this.getPoints3d(transform), this._holes, this.getHoleVertices3d(transform));
    };
    /** @inheritdoc */
    PolygonGeometry.prototype.getPoleOfAccessibility2d = function () {
        return this._getPoleOfInaccessibility2d(this._polygon.slice());
    };
    /** @inheritdoc */
    PolygonGeometry.prototype.getPoleOfAccessibility3d = function (transform) {
        var pole2d = this._getPoleOfInaccessibility2d(this._polygon.slice());
        return transform.unprojectBasic(pole2d, 200);
    };
    return PolygonGeometry;
}(Component_1.VertexGeometry));
exports.PolygonGeometry = PolygonGeometry;
exports.default = PolygonGeometry;

},{"../../../Component":291}],365:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Component_1 = require("../../../Component");
/**
 * @class RectGeometry
 *
 * @classdesc Represents a rectangle geometry in the 2D basic image coordinate system.
 *
 * @example
 * ```
 * var basicRect = [0.5, 0.3, 0.7, 0.4];
 * var rectGeometry = new Mapillary.TagComponent.RectGeometry(basicRect);
 * ```
 */
var RectGeometry = /** @class */ (function (_super) {
    __extends(RectGeometry, _super);
    /**
     * Create a rectangle geometry.
     *
     * @constructor
     * @param {Array<number>} rect - An array representing the top-left and bottom-right
     * corners of the rectangle in basic coordinates. Ordered according to [x0, y0, x1, y1].
     *
     * @throws {GeometryTagError} Rectangle coordinates must be valid basic coordinates.
     */
    function RectGeometry(rect) {
        var _this = _super.call(this) || this;
        if (rect[1] > rect[3]) {
            throw new Component_1.GeometryTagError("Basic Y coordinates values can not be inverted.");
        }
        for (var _i = 0, rect_1 = rect; _i < rect_1.length; _i++) {
            var coord = rect_1[_i];
            if (coord < 0 || coord > 1) {
                throw new Component_1.GeometryTagError("Basic coordinates must be on the interval [0, 1].");
            }
        }
        _this._anchorIndex = undefined;
        _this._rect = rect.slice(0, 4);
        _this._inverted = _this._rect[0] > _this._rect[2];
        return _this;
    }
    Object.defineProperty(RectGeometry.prototype, "anchorIndex", {
        /**
         * Get anchor index property.
         *
         * @returns {number} Index representing the current anchor property if
         * achoring indexing has been initialized. If anchor indexing has not been
         * initialized or has been terminated undefined will be returned.
         */
        get: function () {
            return this._anchorIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RectGeometry.prototype, "inverted", {
        /**
         * Get inverted property.
         *
         * @returns {boolean} Boolean determining whether the rect geometry is
         * inverted. For panoramas the rect geometrye may be inverted.
         */
        get: function () {
            return this._inverted;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RectGeometry.prototype, "rect", {
        /**
         * Get rect property.
         *
         * @returns {Array<number>} Array representing the top-left and bottom-right
         * corners of the rectangle in basic coordinates.
         */
        get: function () {
            return this._rect;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initialize anchor indexing to enable setting opposite vertex.
     *
     * @param {number} [index] - The index of the vertex to use as anchor.
     *
     * @throws {Error} If anchor indexing has already been initialized.
     * @throws {Error} If index is not valid (0 to 3).
     */
    RectGeometry.prototype.initializeAnchorIndexing = function (index) {
        if (this._anchorIndex !== undefined) {
            throw new Error("Anchor indexing is already initialized.");
        }
        if (index < 0 || index > 3) {
            throw new Error("Invalid anchor index: " + index + ".");
        }
        this._anchorIndex = index === undefined ? 0 : index;
    };
    /**
     * Terminate anchor indexing to disable setting pposite vertex.
     */
    RectGeometry.prototype.terminateAnchorIndexing = function () {
        this._anchorIndex = undefined;
    };
    /**
     * Set the value of the vertex opposite to the anchor in the polygon
     * representation of the rectangle.
     *
     * @description Setting the opposite vertex may change the anchor index.
     *
     * @param {Array<number>} opposite - The new value of the vertex opposite to the anchor.
     * @param {Transform} transform - The transform of the node related to the rectangle.
     *
     * @throws {Error} When anchor indexing has not been initialized.
     */
    RectGeometry.prototype.setOppositeVertex2d = function (opposite, transform) {
        if (this._anchorIndex === undefined) {
            throw new Error("Anchor indexing needs to be initialized.");
        }
        var changed = [
            Math.max(0, Math.min(1, opposite[0])),
            Math.max(0, Math.min(1, opposite[1])),
        ];
        var original = this._rect.slice();
        var anchor = this._anchorIndex === 0 ? [original[0], original[3]] :
            this._anchorIndex === 1 ? [original[0], original[1]] :
                this._anchorIndex === 2 ? [original[2], original[1]] :
                    [original[2], original[3]];
        if (transform.fullPano) {
            var deltaX = this._anchorIndex < 2 ?
                changed[0] - original[2] :
                changed[0] - original[0];
            if (!this._inverted && this._anchorIndex < 2 && changed[0] < 0.25 && original[2] > 0.75 && deltaX < -0.5) {
                // right side passes boundary rightward
                this._inverted = true;
                this._anchorIndex = anchor[1] > changed[1] ? 0 : 1;
            }
            else if (!this._inverted && this._anchorIndex >= 2 && changed[0] < 0.25 && original[2] > 0.75 && deltaX < -0.5) {
                // left side passes right side and boundary rightward
                this._inverted = true;
                this._anchorIndex = anchor[1] > changed[1] ? 0 : 1;
            }
            else if (this._inverted && this._anchorIndex >= 2 && changed[0] < 0.25 && original[0] > 0.75 && deltaX < -0.5) {
                this._inverted = false;
                if (anchor[0] > changed[0]) {
                    // left side passes boundary rightward
                    this._anchorIndex = anchor[1] > changed[1] ? 3 : 2;
                }
                else {
                    // left side passes right side and boundary rightward
                    this._anchorIndex = anchor[1] > changed[1] ? 0 : 1;
                }
            }
            else if (!this._inverted && this._anchorIndex >= 2 && changed[0] > 0.75 && original[0] < 0.25 && deltaX > 0.5) {
                // left side passes boundary leftward
                this._inverted = true;
                this._anchorIndex = anchor[1] > changed[1] ? 3 : 2;
            }
            else if (!this._inverted && this._anchorIndex < 2 && changed[0] > 0.75 && original[0] < 0.25 && deltaX > 0.5) {
                // right side passes left side and boundary leftward
                this._inverted = true;
                this._anchorIndex = anchor[1] > changed[1] ? 3 : 2;
            }
            else if (this._inverted && this._anchorIndex < 2 && changed[0] > 0.75 && original[2] < 0.25 && deltaX > 0.5) {
                this._inverted = false;
                if (anchor[0] > changed[0]) {
                    // right side passes boundary leftward
                    this._anchorIndex = anchor[1] > changed[1] ? 3 : 2;
                }
                else {
                    // right side passes left side and boundary leftward
                    this._anchorIndex = anchor[1] > changed[1] ? 0 : 1;
                }
            }
            else if (this._inverted && this._anchorIndex < 2 && changed[0] > original[0]) {
                // inverted and right side passes left side completing a loop
                this._inverted = false;
                this._anchorIndex = anchor[1] > changed[1] ? 0 : 1;
            }
            else if (this._inverted && this._anchorIndex >= 2 && changed[0] < original[2]) {
                // inverted and left side passes right side completing a loop
                this._inverted = false;
                this._anchorIndex = anchor[1] > changed[1] ? 3 : 2;
            }
            else if (this._inverted) {
                // if still inverted only top and bottom can switch
                if (this._anchorIndex < 2) {
                    this._anchorIndex = anchor[1] > changed[1] ? 0 : 1;
                }
                else {
                    this._anchorIndex = anchor[1] > changed[1] ? 3 : 2;
                }
            }
            else {
                // if still not inverted treat as non full pano
                if (anchor[0] <= changed[0] && anchor[1] > changed[1]) {
                    this._anchorIndex = 0;
                }
                else if (anchor[0] <= changed[0] && anchor[1] <= changed[1]) {
                    this._anchorIndex = 1;
                }
                else if (anchor[0] > changed[0] && anchor[1] <= changed[1]) {
                    this._anchorIndex = 2;
                }
                else {
                    this._anchorIndex = 3;
                }
            }
            var rect = [];
            if (this._anchorIndex === 0) {
                rect[0] = anchor[0];
                rect[1] = changed[1];
                rect[2] = changed[0];
                rect[3] = anchor[1];
            }
            else if (this._anchorIndex === 1) {
                rect[0] = anchor[0];
                rect[1] = anchor[1];
                rect[2] = changed[0];
                rect[3] = changed[1];
            }
            else if (this._anchorIndex === 2) {
                rect[0] = changed[0];
                rect[1] = anchor[1];
                rect[2] = anchor[0];
                rect[3] = changed[1];
            }
            else {
                rect[0] = changed[0];
                rect[1] = changed[1];
                rect[2] = anchor[0];
                rect[3] = anchor[1];
            }
            if (!this._inverted && rect[0] > rect[2] ||
                this._inverted && rect[0] < rect[2]) {
                rect[0] = original[0];
                rect[2] = original[2];
            }
            if (rect[1] > rect[3]) {
                rect[1] = original[1];
                rect[3] = original[3];
            }
            this._rect[0] = rect[0];
            this._rect[1] = rect[1];
            this._rect[2] = rect[2];
            this._rect[3] = rect[3];
        }
        else {
            if (anchor[0] <= changed[0] && anchor[1] > changed[1]) {
                this._anchorIndex = 0;
            }
            else if (anchor[0] <= changed[0] && anchor[1] <= changed[1]) {
                this._anchorIndex = 1;
            }
            else if (anchor[0] > changed[0] && anchor[1] <= changed[1]) {
                this._anchorIndex = 2;
            }
            else {
                this._anchorIndex = 3;
            }
            var rect = [];
            if (this._anchorIndex === 0) {
                rect[0] = anchor[0];
                rect[1] = changed[1];
                rect[2] = changed[0];
                rect[3] = anchor[1];
            }
            else if (this._anchorIndex === 1) {
                rect[0] = anchor[0];
                rect[1] = anchor[1];
                rect[2] = changed[0];
                rect[3] = changed[1];
            }
            else if (this._anchorIndex === 2) {
                rect[0] = changed[0];
                rect[1] = anchor[1];
                rect[2] = anchor[0];
                rect[3] = changed[1];
            }
            else {
                rect[0] = changed[0];
                rect[1] = changed[1];
                rect[2] = anchor[0];
                rect[3] = anchor[1];
            }
            if (rect[0] > rect[2]) {
                rect[0] = original[0];
                rect[2] = original[2];
            }
            if (rect[1] > rect[3]) {
                rect[1] = original[1];
                rect[3] = original[3];
            }
            this._rect[0] = rect[0];
            this._rect[1] = rect[1];
            this._rect[2] = rect[2];
            this._rect[3] = rect[3];
        }
        this._notifyChanged$.next(this);
    };
    /**
     * Set the value of a vertex in the polygon representation of the rectangle.
     *
     * @description The polygon is defined to have the first vertex at the
     * bottom-left corner with the rest of the vertices following in clockwise order.
     *
     * @param {number} index - The index of the vertex to be set.
     * @param {Array<number>} value - The new value of the vertex.
     * @param {Transform} transform - The transform of the node related to the rectangle.
     */
    RectGeometry.prototype.setVertex2d = function (index, value, transform) {
        var original = this._rect.slice();
        var changed = [
            Math.max(0, Math.min(1, value[0])),
            Math.max(0, Math.min(1, value[1])),
        ];
        var rect = [];
        if (index === 0) {
            rect[0] = changed[0];
            rect[1] = original[1];
            rect[2] = original[2];
            rect[3] = changed[1];
        }
        else if (index === 1) {
            rect[0] = changed[0];
            rect[1] = changed[1];
            rect[2] = original[2];
            rect[3] = original[3];
        }
        else if (index === 2) {
            rect[0] = original[0];
            rect[1] = changed[1];
            rect[2] = changed[0];
            rect[3] = original[3];
        }
        else if (index === 3) {
            rect[0] = original[0];
            rect[1] = original[1];
            rect[2] = changed[0];
            rect[3] = changed[1];
        }
        if (transform.fullPano) {
            var passingBoundaryLeftward = index < 2 && changed[0] > 0.75 && original[0] < 0.25 ||
                index >= 2 && this._inverted && changed[0] > 0.75 && original[2] < 0.25;
            var passingBoundaryRightward = index < 2 && this._inverted && changed[0] < 0.25 && original[0] > 0.75 ||
                index >= 2 && changed[0] < 0.25 && original[2] > 0.75;
            if (passingBoundaryLeftward || passingBoundaryRightward) {
                this._inverted = !this._inverted;
            }
            else {
                if (rect[0] - original[0] < -0.25) {
                    rect[0] = original[0];
                }
                if (rect[2] - original[2] > 0.25) {
                    rect[2] = original[2];
                }
            }
            if (!this._inverted && rect[0] > rect[2] ||
                this._inverted && rect[0] < rect[2]) {
                rect[0] = original[0];
                rect[2] = original[2];
            }
        }
        else {
            if (rect[0] > rect[2]) {
                rect[0] = original[0];
                rect[2] = original[2];
            }
        }
        if (rect[1] > rect[3]) {
            rect[1] = original[1];
            rect[3] = original[3];
        }
        this._rect[0] = rect[0];
        this._rect[1] = rect[1];
        this._rect[2] = rect[2];
        this._rect[3] = rect[3];
        this._notifyChanged$.next(this);
    };
    /** @inheritdoc */
    RectGeometry.prototype.setCentroid2d = function (value, transform) {
        var original = this._rect.slice();
        var x0 = original[0];
        var x1 = this._inverted ? original[2] + 1 : original[2];
        var y0 = original[1];
        var y1 = original[3];
        var centerX = x0 + (x1 - x0) / 2;
        var centerY = y0 + (y1 - y0) / 2;
        var translationX = 0;
        if (transform.gpano != null &&
            transform.gpano.CroppedAreaImageWidthPixels === transform.gpano.FullPanoWidthPixels) {
            translationX = this._inverted ? value[0] + 1 - centerX : value[0] - centerX;
        }
        else {
            var minTranslationX = -x0;
            var maxTranslationX = 1 - x1;
            translationX = Math.max(minTranslationX, Math.min(maxTranslationX, value[0] - centerX));
        }
        var minTranslationY = -y0;
        var maxTranslationY = 1 - y1;
        var translationY = Math.max(minTranslationY, Math.min(maxTranslationY, value[1] - centerY));
        this._rect[0] = original[0] + translationX;
        this._rect[1] = original[1] + translationY;
        this._rect[2] = original[2] + translationX;
        this._rect[3] = original[3] + translationY;
        if (this._rect[0] < 0) {
            this._rect[0] += 1;
            this._inverted = !this._inverted;
        }
        else if (this._rect[0] > 1) {
            this._rect[0] -= 1;
            this._inverted = !this._inverted;
        }
        if (this._rect[2] < 0) {
            this._rect[2] += 1;
            this._inverted = !this._inverted;
        }
        else if (this._rect[2] > 1) {
            this._rect[2] -= 1;
            this._inverted = !this._inverted;
        }
        this._notifyChanged$.next(this);
    };
    /**
     * Get the 3D coordinates for the vertices of the rectangle with
     * interpolated points along the lines.
     *
     * @param {Transform} transform - The transform of the node related to
     * the rectangle.
     * @returns {Array<Array<number>>} Polygon array of 3D world coordinates
     * representing the rectangle.
     */
    RectGeometry.prototype.getPoints3d = function (transform) {
        return this._getPoints2d(transform)
            .map(function (point) {
            return transform.unprojectBasic(point, 200);
        });
    };
    /**
     * Get the coordinates of a vertex from the polygon representation of the geometry.
     *
     * @description The first vertex represents the bottom-left corner with the rest of
     * the vertices following in clockwise order. The method shifts the right side
     * coordinates of the rectangle by one unit to ensure that the vertices are ordered
     * clockwise.
     *
     * @param {number} index - Vertex index.
     * @returns {Array<number>} Array representing the 2D basic coordinates of the vertex.
     */
    RectGeometry.prototype.getVertex2d = function (index) {
        return this._rectToVertices2d(this._rect)[index];
    };
    /**
     * Get the coordinates of a vertex from the polygon representation of the geometry.
     *
     * @description The first vertex represents the bottom-left corner with the rest of
     * the vertices following in clockwise order. The coordinates will not be shifted
     * so they may not appear in clockwise order when layed out on the plane.
     *
     * @param {number} index - Vertex index.
     * @returns {Array<number>} Array representing the 2D basic coordinates of the vertex.
     */
    RectGeometry.prototype.getNonAdjustedVertex2d = function (index) {
        return this._rectToNonAdjustedVertices2d(this._rect)[index];
    };
    /**
     * Get a vertex from the polygon representation of the 3D coordinates for the
     * vertices of the geometry.
     *
     * @description The first vertex represents the bottom-left corner with the rest of
     * the vertices following in clockwise order.
     *
     * @param {number} index - Vertex index.
     * @param {Transform} transform - The transform of the node related to the geometry.
     * @returns {Array<Array<number>>} Polygon array of 3D world coordinates representing
     * the vertices of the geometry.
     */
    RectGeometry.prototype.getVertex3d = function (index, transform) {
        return transform.unprojectBasic(this._rectToVertices2d(this._rect)[index], 200);
    };
    /**
     * Get a polygon representation of the 2D basic coordinates for the vertices of the rectangle.
     *
     * @description The first vertex represents the bottom-left corner with the rest of
     * the vertices following in clockwise order.
     *
     * @returns {Array<Array<number>>} Polygon array of 2D basic coordinates representing
     * the rectangle vertices.
     */
    RectGeometry.prototype.getVertices2d = function () {
        return this._rectToVertices2d(this._rect);
    };
    /**
     * Get a polygon representation of the 3D coordinates for the vertices of the rectangle.
     *
     * @description The first vertex represents the bottom-left corner with the rest of
     * the vertices following in clockwise order.
     *
     * @param {Transform} transform - The transform of the node related to the rectangle.
     * @returns {Array<Array<number>>} Polygon array of 3D world coordinates representing
     * the rectangle vertices.
     */
    RectGeometry.prototype.getVertices3d = function (transform) {
        return this._rectToVertices2d(this._rect)
            .map(function (vertex) {
            return transform.unprojectBasic(vertex, 200);
        });
    };
    /** @inheritdoc */
    RectGeometry.prototype.getCentroid2d = function () {
        var rect = this._rect;
        var x0 = rect[0];
        var x1 = this._inverted ? rect[2] + 1 : rect[2];
        var y0 = rect[1];
        var y1 = rect[3];
        var centroidX = x0 + (x1 - x0) / 2;
        var centroidY = y0 + (y1 - y0) / 2;
        return [centroidX, centroidY];
    };
    /** @inheritdoc */
    RectGeometry.prototype.getCentroid3d = function (transform) {
        var centroid2d = this.getCentroid2d();
        return transform.unprojectBasic(centroid2d, 200);
    };
    /** @inheritdoc */
    RectGeometry.prototype.getPoleOfAccessibility2d = function () {
        return this._getPoleOfInaccessibility2d(this._rectToVertices2d(this._rect));
    };
    /** @inheritdoc */
    RectGeometry.prototype.getPoleOfAccessibility3d = function (transform) {
        var pole2d = this._getPoleOfInaccessibility2d(this._rectToVertices2d(this._rect));
        return transform.unprojectBasic(pole2d, 200);
    };
    /** @inheritdoc */
    RectGeometry.prototype.getTriangles3d = function (transform) {
        return this._triangulate(this._rectToVertices2d(this._rect), this.getVertices3d(transform));
    };
    /**
     * Check if a particular bottom-right value is valid according to the current
     * rectangle coordinates.
     *
     * @param {Array<number>} bottomRight - The bottom-right coordinates to validate
     * @returns {boolean} Value indicating whether the provided bottom-right coordinates
     * are valid.
     */
    RectGeometry.prototype.validate = function (bottomRight) {
        var rect = this._rect;
        if (!this._inverted && bottomRight[0] < rect[0] ||
            bottomRight[0] - rect[2] > 0.25 ||
            bottomRight[1] < rect[1]) {
            return false;
        }
        return true;
    };
    /**
     * Get the 2D coordinates for the vertices of the rectangle with
     * interpolated points along the lines.
     *
     * @param {Transform} transform - The transform of the node related to
     * the rectangle.
     * @returns {Array<Array<number>>} Polygon array of 2D basic coordinates
     * representing the rectangle.
     */
    RectGeometry.prototype._getPoints2d = function (transform) {
        var vertices2d = this._rectToVertices2d(this._rect);
        var sides = vertices2d.length - 1;
        var sections = 10;
        var points2d = [];
        for (var i = 0; i < sides; ++i) {
            var startX = vertices2d[i][0];
            var startY = vertices2d[i][1];
            var endX = vertices2d[i + 1][0];
            var endY = vertices2d[i + 1][1];
            var intervalX = (endX - startX) / (sections - 1);
            var intervalY = (endY - startY) / (sections - 1);
            for (var j = 0; j < sections; ++j) {
                var point = [
                    startX + j * intervalX,
                    startY + j * intervalY,
                ];
                points2d.push(point);
            }
        }
        return points2d;
    };
    /**
     * Convert the top-left, bottom-right representation of a rectangle to a polygon
     * representation of the vertices starting at the bottom-left corner going
     * clockwise.
     *
     * @description The method shifts the right side coordinates of the rectangle
     * by one unit to ensure that the vertices are ordered clockwise.
     *
     * @param {Array<number>} rect - Top-left, bottom-right representation of a
     * rectangle.
     * @returns {Array<Array<number>>} Polygon representation of the vertices of the
     * rectangle.
     */
    RectGeometry.prototype._rectToVertices2d = function (rect) {
        return [
            [rect[0], rect[3]],
            [rect[0], rect[1]],
            [this._inverted ? rect[2] + 1 : rect[2], rect[1]],
            [this._inverted ? rect[2] + 1 : rect[2], rect[3]],
            [rect[0], rect[3]],
        ];
    };
    /**
     * Convert the top-left, bottom-right representation of a rectangle to a polygon
     * representation of the vertices starting at the bottom-left corner going
     * clockwise.
     *
     * @description The first vertex represents the bottom-left corner with the rest of
     * the vertices following in clockwise order. The coordinates will not be shifted
     * to ensure that the vertices are ordered clockwise when layed out on the plane.
     *
     * @param {Array<number>} rect - Top-left, bottom-right representation of a
     * rectangle.
     * @returns {Array<Array<number>>} Polygon representation of the vertices of the
     * rectangle.
     */
    RectGeometry.prototype._rectToNonAdjustedVertices2d = function (rect) {
        return [
            [rect[0], rect[3]],
            [rect[0], rect[1]],
            [rect[2], rect[1]],
            [rect[2], rect[3]],
            [rect[0], rect[3]],
        ];
    };
    return RectGeometry;
}(Component_1.VertexGeometry));
exports.RectGeometry = RectGeometry;
exports.default = RectGeometry;

},{"../../../Component":291}],366:[function(require,module,exports){
"use strict";
/// <reference path="../../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var earcut = require("earcut");
var polylabel = require("@mapbox/polylabel");
var Component_1 = require("../../../Component");
/**
 * @class VertexGeometry
 * @abstract
 * @classdesc Represents a vertex geometry.
 */
var VertexGeometry = /** @class */ (function (_super) {
    __extends(VertexGeometry, _super);
    /**
     * Create a vertex geometry.
     *
     * @constructor
     */
    function VertexGeometry() {
        return _super.call(this) || this;
    }
    /**
     * Finds the polygon pole of inaccessibility, the most distant internal
     * point from the polygon outline.
     *
     * @param {Array<Array<number>>} points2d - 2d points of outline to triangulate.
     * @returns {Array<number>} Point of inaccessibility.
     * @ignore
     */
    VertexGeometry.prototype._getPoleOfInaccessibility2d = function (points2d) {
        var pole2d = polylabel([points2d], 3e-2);
        return pole2d;
    };
    /**
     * Triangulates a 2d polygon and returns the triangle
     * representation as a flattened array of 3d points.
     *
     * @param {Array<Array<number>>} points2d - 2d points of outline to triangulate.
     * @param {Array<Array<number>>} points3d - 3d points of outline corresponding to the 2d points.
     * @param {Array<Array<Array<number>>>} [holes2d] - 2d points of holes to triangulate.
     * @param {Array<Array<Array<number>>>} [holes3d] - 3d points of holes corresponding to the 2d points.
     * @returns {Array<number>} Flattened array of 3d points ordered based on the triangles.
     * @ignore
     */
    VertexGeometry.prototype._triangulate = function (points2d, points3d, holes2d, holes3d) {
        var data = [points2d.slice(0, -1)];
        for (var _i = 0, _a = holes2d != null ? holes2d : []; _i < _a.length; _i++) {
            var hole2d = _a[_i];
            data.push(hole2d.slice(0, -1));
        }
        var points = points3d.slice(0, -1);
        for (var _b = 0, _c = holes3d != null ? holes3d : []; _b < _c.length; _b++) {
            var hole3d = _c[_b];
            points = points.concat(hole3d.slice(0, -1));
        }
        var flattened = earcut.flatten(data);
        var indices = earcut(flattened.vertices, flattened.holes, flattened.dimensions);
        var triangles = [];
        for (var i = 0; i < indices.length; ++i) {
            var point = points[indices[i]];
            triangles.push(point[0]);
            triangles.push(point[1]);
            triangles.push(point[2]);
        }
        return triangles;
    };
    return VertexGeometry;
}(Component_1.Geometry));
exports.VertexGeometry = VertexGeometry;
exports.default = VertexGeometry;

},{"../../../Component":291,"@mapbox/polylabel":1,"earcut":8}],367:[function(require,module,exports){
"use strict";
/// <reference path="../../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("rxjs/Subject");
var Component_1 = require("../../../Component");
var CreateHandlerBase = /** @class */ (function (_super) {
    __extends(CreateHandlerBase, _super);
    function CreateHandlerBase(component, container, navigator, viewportCoords, tagCreator) {
        var _this = _super.call(this, component, container, navigator, viewportCoords) || this;
        _this._tagCreator = tagCreator;
        _this._geometryCreated$ = new Subject_1.Subject();
        return _this;
    }
    Object.defineProperty(CreateHandlerBase.prototype, "geometryCreated$", {
        get: function () {
            return this._geometryCreated$;
        },
        enumerable: true,
        configurable: true
    });
    CreateHandlerBase.prototype._enable = function () {
        this._enableCreate();
        this._container.element.classList.add("component-tag-create");
    };
    CreateHandlerBase.prototype._disable = function () {
        this._container.element.classList.remove("component-tag-create");
        this._disableCreate();
    };
    CreateHandlerBase.prototype._validateBasic = function (basic) {
        var x = basic[0];
        var y = basic[1];
        return 0 <= x && x <= 1 && 0 <= y && y <= 1;
    };
    CreateHandlerBase.prototype._mouseEventToBasic$ = function (mouseEvent$) {
        var _this = this;
        return mouseEvent$
            .withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$)
            .map(function (_a) {
            var event = _a[0], camera = _a[1], transform = _a[2];
            return _this._mouseEventToBasic(event, _this._container.element, camera, transform);
        });
    };
    return CreateHandlerBase;
}(Component_1.TagHandlerBase));
exports.CreateHandlerBase = CreateHandlerBase;
exports.default = CreateHandlerBase;

},{"../../../Component":291,"rxjs/Subject":34}],368:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Component_1 = require("../../../Component");
var CreatePointHandler = /** @class */ (function (_super) {
    __extends(CreatePointHandler, _super);
    function CreatePointHandler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CreatePointHandler.prototype._enableCreate = function () {
        this._container.mouseService.deferPixels(this._name, 4);
        this._geometryCreatedSubscription = this._mouseEventToBasic$(this._container.mouseService.proximateClick$)
            .filter(this._validateBasic)
            .map(function (basic) {
            return new Component_1.PointGeometry(basic);
        })
            .subscribe(this._geometryCreated$);
    };
    CreatePointHandler.prototype._disableCreate = function () {
        this._container.mouseService.undeferPixels(this._name);
        this._geometryCreatedSubscription.unsubscribe();
    };
    CreatePointHandler.prototype._getNameExtension = function () {
        return "create-point";
    };
    return CreatePointHandler;
}(Component_1.CreateHandlerBase));
exports.CreatePointHandler = CreatePointHandler;
exports.default = CreatePointHandler;

},{"../../../Component":291}],369:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Component_1 = require("../../../Component");
var CreatePolygonHandler = /** @class */ (function (_super) {
    __extends(CreatePolygonHandler, _super);
    function CreatePolygonHandler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CreatePolygonHandler.prototype._addPoint = function (tag, basicPoint) {
        tag.addPoint(basicPoint);
    };
    Object.defineProperty(CreatePolygonHandler.prototype, "_create$", {
        get: function () {
            return this._tagCreator.createPolygon$;
        },
        enumerable: true,
        configurable: true
    });
    CreatePolygonHandler.prototype._getNameExtension = function () {
        return "create-polygon";
    };
    CreatePolygonHandler.prototype._setVertex2d = function (tag, basicPoint, transform) {
        tag.geometry.setVertex2d(tag.geometry.polygon.length - 2, basicPoint, transform);
    };
    return CreatePolygonHandler;
}(Component_1.CreateVertexHandler));
exports.CreatePolygonHandler = CreatePolygonHandler;
exports.default = CreatePolygonHandler;

},{"../../../Component":291}],370:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var Component_1 = require("../../../Component");
var CreateRectDragHandler = /** @class */ (function (_super) {
    __extends(CreateRectDragHandler, _super);
    function CreateRectDragHandler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CreateRectDragHandler.prototype._enableCreate = function () {
        var _this = this;
        this._container.mouseService.claimMouse(this._name, 2);
        this._deleteSubscription = this._navigator.stateService.currentTransform$
            .map(function (transform) { return null; })
            .skip(1)
            .subscribe(this._tagCreator.delete$);
        this._createSubscription = this._mouseEventToBasic$(this._container.mouseService.filtered$(this._name, this._container.mouseService.mouseDragStart$))
            .filter(this._validateBasic)
            .subscribe(this._tagCreator.createRect$);
        this._initializeAnchorIndexingSubscription = this._tagCreator.tag$
            .filter(function (tag) {
            return !!tag;
        })
            .subscribe(function (tag) {
            tag.geometry.initializeAnchorIndexing();
        });
        var basicMouse$ = Observable_1.Observable
            .merge(this._container.mouseService.filtered$(this._name, this._container.mouseService.mouseMove$), this._container.mouseService.filtered$(this._name, this._container.mouseService.domMouseMove$))
            .combineLatest(this._container.renderService.renderCamera$)
            .withLatestFrom(this._navigator.stateService.currentTransform$)
            .map(function (_a) {
            var _b = _a[0], event = _b[0], camera = _b[1], transform = _a[1];
            return _this._mouseEventToBasic(event, _this._container.element, camera, transform);
        });
        this._setVertexSubscription = this._tagCreator.tag$
            .switchMap(function (tag) {
            return !!tag ?
                Observable_1.Observable
                    .combineLatest(Observable_1.Observable.of(tag), basicMouse$, _this._navigator.stateService.currentTransform$) :
                Observable_1.Observable.empty();
        })
            .subscribe(function (_a) {
            var tag = _a[0], basicPoint = _a[1], transform = _a[2];
            tag.geometry.setOppositeVertex2d(basicPoint, transform);
        });
        var basicMouseDragEnd$ = this._container.mouseService.mouseDragEnd$
            .withLatestFrom(this._mouseEventToBasic$(this._container.mouseService.filtered$(this._name, this._container.mouseService.mouseDrag$))
            .filter(this._validateBasic), function (event, basicPoint) {
            return basicPoint;
        })
            .share();
        this._addPointSubscription = this._tagCreator.tag$
            .switchMap(function (tag) {
            return !!tag ?
                Observable_1.Observable
                    .combineLatest(Observable_1.Observable.of(tag), basicMouseDragEnd$) :
                Observable_1.Observable.empty();
        })
            .subscribe(function (_a) {
            var tag = _a[0], basicPoint = _a[1];
            var rectGeometry = tag.geometry;
            if (!rectGeometry.validate(basicPoint)) {
                basicPoint = rectGeometry.getNonAdjustedVertex2d(3);
            }
            tag.addPoint(basicPoint);
        });
        this._geometryCreatedSubscription = this._tagCreator.tag$
            .switchMap(function (tag) {
            return !!tag ?
                tag.created$
                    .map(function (t) {
                    return t.geometry;
                }) :
                Observable_1.Observable.empty();
        })
            .subscribe(this._geometryCreated$);
    };
    CreateRectDragHandler.prototype._disableCreate = function () {
        this._container.mouseService.unclaimMouse(this._name);
        this._tagCreator.delete$.next(null);
        this._addPointSubscription.unsubscribe();
        this._createSubscription.unsubscribe();
        this._deleteSubscription.unsubscribe();
        this._geometryCreatedSubscription.unsubscribe();
        this._initializeAnchorIndexingSubscription.unsubscribe();
        this._setVertexSubscription.unsubscribe();
    };
    CreateRectDragHandler.prototype._getNameExtension = function () {
        return "create-rect-drag";
    };
    return CreateRectDragHandler;
}(Component_1.CreateHandlerBase));
exports.CreateRectDragHandler = CreateRectDragHandler;
exports.default = CreateRectDragHandler;

},{"../../../Component":291,"rxjs/Observable":29}],371:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Component_1 = require("../../../Component");
var CreateRectHandler = /** @class */ (function (_super) {
    __extends(CreateRectHandler, _super);
    function CreateRectHandler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CreateRectHandler.prototype, "_create$", {
        get: function () {
            return this._tagCreator.createRect$;
        },
        enumerable: true,
        configurable: true
    });
    CreateRectHandler.prototype._addPoint = function (tag, basicPoint) {
        var rectGeometry = tag.geometry;
        if (!rectGeometry.validate(basicPoint)) {
            basicPoint = rectGeometry.getNonAdjustedVertex2d(3);
        }
        tag.addPoint(basicPoint);
    };
    CreateRectHandler.prototype._enable = function () {
        _super.prototype._enable.call(this);
        this._initializeAnchorIndexingSubscription = this._tagCreator.tag$
            .filter(function (tag) {
            return !!tag;
        })
            .subscribe(function (tag) {
            tag.geometry.initializeAnchorIndexing();
        });
    };
    CreateRectHandler.prototype._disable = function () {
        _super.prototype._disable.call(this);
        this._initializeAnchorIndexingSubscription.unsubscribe();
    };
    CreateRectHandler.prototype._getNameExtension = function () {
        return "create-rect";
    };
    CreateRectHandler.prototype._setVertex2d = function (tag, basicPoint, transform) {
        tag.geometry.setOppositeVertex2d(basicPoint, transform);
    };
    return CreateRectHandler;
}(Component_1.CreateVertexHandler));
exports.CreateRectHandler = CreateRectHandler;
exports.default = CreateRectHandler;

},{"../../../Component":291}],372:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var Component_1 = require("../../../Component");
var CreateVertexHandler = /** @class */ (function (_super) {
    __extends(CreateVertexHandler, _super);
    function CreateVertexHandler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CreateVertexHandler.prototype._enableCreate = function () {
        var _this = this;
        this._container.mouseService.deferPixels(this._name, 4);
        var transformChanged$ = this._navigator.stateService.currentTransform$
            .map(function (transform) { })
            .publishReplay(1)
            .refCount();
        this._deleteSubscription = transformChanged$
            .skip(1)
            .subscribe(this._tagCreator.delete$);
        var basicClick$ = this._mouseEventToBasic$(this._container.mouseService.proximateClick$).share();
        this._createSubscription = transformChanged$
            .switchMap(function () {
            return basicClick$
                .filter(_this._validateBasic)
                .take(1);
        })
            .subscribe(this._create$);
        this._setVertexSubscription = this._tagCreator.tag$
            .switchMap(function (tag) {
            return !!tag ?
                Observable_1.Observable
                    .combineLatest(Observable_1.Observable.of(tag), Observable_1.Observable
                    .merge(_this._container.mouseService.mouseMove$, _this._container.mouseService.domMouseMove$), _this._container.renderService.renderCamera$, _this._navigator.stateService.currentTransform$) :
                Observable_1.Observable.empty();
        })
            .subscribe(function (_a) {
            var tag = _a[0], event = _a[1], camera = _a[2], transform = _a[3];
            var basicPoint = _this._mouseEventToBasic(event, _this._container.element, camera, transform);
            _this._setVertex2d(tag, basicPoint, transform);
        });
        this._addPointSubscription = this._tagCreator.tag$
            .switchMap(function (tag) {
            return !!tag ?
                Observable_1.Observable
                    .combineLatest(Observable_1.Observable.of(tag), basicClick$) :
                Observable_1.Observable.empty();
        })
            .subscribe(function (_a) {
            var tag = _a[0], basicPoint = _a[1];
            _this._addPoint(tag, basicPoint);
        });
        this._geometryCreateSubscription = this._tagCreator.tag$
            .switchMap(function (tag) {
            return !!tag ?
                tag.created$
                    .map(function (t) {
                    return t.geometry;
                }) :
                Observable_1.Observable.empty();
        })
            .subscribe(this._geometryCreated$);
    };
    CreateVertexHandler.prototype._disableCreate = function () {
        this._container.mouseService.undeferPixels(this._name);
        this._tagCreator.delete$.next(null);
        this._addPointSubscription.unsubscribe();
        this._createSubscription.unsubscribe();
        this._deleteSubscription.unsubscribe();
        this._geometryCreateSubscription.unsubscribe();
        this._setVertexSubscription.unsubscribe();
    };
    return CreateVertexHandler;
}(Component_1.CreateHandlerBase));
exports.CreateVertexHandler = CreateVertexHandler;
exports.default = CreateVertexHandler;

},{"../../../Component":291,"rxjs/Observable":29}],373:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var Component_1 = require("../../../Component");
var EditVertexHandler = /** @class */ (function (_super) {
    __extends(EditVertexHandler, _super);
    function EditVertexHandler(component, container, navigator, viewportCoords, tagSet) {
        var _this = _super.call(this, component, container, navigator, viewportCoords) || this;
        _this._tagSet = tagSet;
        return _this;
    }
    EditVertexHandler.prototype._enable = function () {
        var _this = this;
        var interaction$ = this._tagSet.changed$
            .map(function (tagSet) {
            return tagSet.getAll();
        })
            .switchMap(function (tags) {
            return Observable_1.Observable
                .from(tags)
                .mergeMap(function (tag) {
                return tag.interact$;
            });
        })
            .switchMap(function (interaction) {
            return Observable_1.Observable
                .of(interaction)
                .concat(_this._container.mouseService.documentMouseUp$
                .map(function () {
                return { offsetX: 0, offsetY: 0, operation: Component_1.TagOperation.None, tag: null };
            })
                .first());
        })
            .share();
        var mouseMove$ = Observable_1.Observable
            .merge(this._container.mouseService.mouseMove$, this._container.mouseService.domMouseMove$)
            .share();
        this._claimMouseSubscription = interaction$
            .switchMap(function (interaction) {
            return !!interaction.tag ? _this._container.mouseService.domMouseDragStart$ : Observable_1.Observable.empty();
        })
            .subscribe(function () {
            _this._container.mouseService.claimMouse(_this._name, 3);
        });
        this._cursorSubscription = interaction$
            .map(function (interaction) {
            return interaction.cursor;
        })
            .distinctUntilChanged()
            .subscribe(function (cursor) {
            var interactionCursors = ["crosshair", "move", "nesw-resize", "nwse-resize"];
            for (var _i = 0, interactionCursors_1 = interactionCursors; _i < interactionCursors_1.length; _i++) {
                var interactionCursor = interactionCursors_1[_i];
                _this._container.element.classList.remove("component-tag-edit-" + interactionCursor);
            }
            if (!!cursor) {
                _this._container.element.classList.add("component-tag-edit-" + cursor);
            }
        });
        this._unclaimMouseSubscription = this._container.mouseService
            .filtered$(this._name, this._container.mouseService.domMouseDragEnd$)
            .subscribe(function (e) {
            _this._container.mouseService.unclaimMouse(_this._name);
        });
        this._preventDefaultSubscription = interaction$
            .switchMap(function (interaction) {
            return !!interaction.tag ?
                _this._container.mouseService.documentMouseMove$ :
                Observable_1.Observable.empty();
        })
            .subscribe(function (event) {
            event.preventDefault(); // prevent selection of content outside the viewer
        });
        this._updateGeometrySubscription = interaction$
            .withLatestFrom(mouseMove$)
            .switchMap(function (_a) {
            var interaction = _a[0], mouseMove = _a[1];
            if (interaction.operation === Component_1.TagOperation.None || !interaction.tag) {
                return Observable_1.Observable.empty();
            }
            var mouseDrag$ = Observable_1.Observable
                .of(mouseMove)
                .concat(_this._container.mouseService
                .filtered$(_this._name, _this._container.mouseService.domMouseDrag$)
                .filter(function (event) {
                return _this._viewportCoords.insideElement(event, _this._container.element);
            }));
            return Observable_1.Observable
                .combineLatest(mouseDrag$, _this._container.renderService.renderCamera$)
                .withLatestFrom(Observable_1.Observable.of(interaction), _this._navigator.stateService.currentTransform$, function (_a, i, transform) {
                var event = _a[0], render = _a[1];
                return [event, render, i, transform];
            });
        })
            .subscribe(function (_a) {
            var mouseEvent = _a[0], renderCamera = _a[1], interaction = _a[2], transform = _a[3];
            var basic = _this._mouseEventToBasic(mouseEvent, _this._container.element, renderCamera, transform, interaction.offsetX, interaction.offsetY);
            var geometry = interaction.tag.geometry;
            if (interaction.operation === Component_1.TagOperation.Centroid) {
                geometry.setCentroid2d(basic, transform);
            }
            else if (interaction.operation === Component_1.TagOperation.Vertex) {
                geometry.setVertex2d(interaction.vertexIndex, basic, transform);
            }
        });
    };
    EditVertexHandler.prototype._disable = function () {
        this._claimMouseSubscription.unsubscribe();
        this._cursorSubscription.unsubscribe();
        this._preventDefaultSubscription.unsubscribe();
        this._unclaimMouseSubscription.unsubscribe();
        this._updateGeometrySubscription.unsubscribe();
    };
    EditVertexHandler.prototype._getNameExtension = function () {
        return "edit-vertex";
    };
    return EditVertexHandler;
}(Component_1.TagHandlerBase));
exports.EditVertexHandler = EditVertexHandler;
exports.default = EditVertexHandler;

},{"../../../Component":291,"rxjs/Observable":29}],374:[function(require,module,exports){
"use strict";
/// <reference path="../../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Component_1 = require("../../../Component");
var TagHandlerBase = /** @class */ (function (_super) {
    __extends(TagHandlerBase, _super);
    function TagHandlerBase(component, container, navigator, viewportCoords) {
        var _this = _super.call(this, component, container, navigator) || this;
        _this._name = _this._component.name + "-" + _this._getNameExtension();
        _this._viewportCoords = viewportCoords;
        return _this;
    }
    TagHandlerBase.prototype._getConfiguration = function (enable) {
        return {};
    };
    TagHandlerBase.prototype._mouseEventToBasic = function (event, element, camera, transform, offsetX, offsetY) {
        offsetX = offsetX != null ? offsetX : 0;
        offsetY = offsetY != null ? offsetY : 0;
        var _a = this._viewportCoords.canvasPosition(event, element), canvasX = _a[0], canvasY = _a[1];
        var basic = this._viewportCoords.canvasToBasic(canvasX - offsetX, canvasY - offsetY, element, transform, camera.perspective);
        return basic;
    };
    return TagHandlerBase;
}(Component_1.HandlerBase));
exports.TagHandlerBase = TagHandlerBase;
exports.default = TagHandlerBase;

},{"../../../Component":291}],375:[function(require,module,exports){
"use strict";
/// <reference path="../../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var vd = require("virtual-dom");
var Subject_1 = require("rxjs/Subject");
var Component_1 = require("../../../Component");
var Geo_1 = require("../../../Geo");
var OutlineCreateTag = /** @class */ (function () {
    function OutlineCreateTag(geometry, options, transform, viewportCoords) {
        var _this = this;
        this._geometry = geometry;
        this._options = { color: options.color == null ? 0xFFFFFF : options.color };
        this._transform = transform;
        this._viewportCoords = !!viewportCoords ? viewportCoords : new Geo_1.ViewportCoords();
        this._outline = this._createOutine();
        this._glObjects = [this._outline];
        this._aborted$ = new Subject_1.Subject();
        this._created$ = new Subject_1.Subject();
        this._glObjectsChanged$ = new Subject_1.Subject();
        this._geometryChangedSubscription = this._geometry.changed$
            .subscribe(function (vertexGeometry) {
            _this._disposeOutline();
            _this._outline = _this._createOutine();
            _this._glObjects = [_this._outline];
            _this._glObjectsChanged$.next(_this);
        });
    }
    Object.defineProperty(OutlineCreateTag.prototype, "geometry", {
        get: function () {
            return this._geometry;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineCreateTag.prototype, "glObjects", {
        get: function () {
            return this._glObjects;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineCreateTag.prototype, "aborted$", {
        get: function () {
            return this._aborted$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineCreateTag.prototype, "created$", {
        get: function () {
            return this._created$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineCreateTag.prototype, "glObjectsChanged$", {
        get: function () {
            return this._glObjectsChanged$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineCreateTag.prototype, "geometryChanged$", {
        get: function () {
            var _this = this;
            return this._geometry.changed$
                .map(function (geometry) {
                return _this;
            });
        },
        enumerable: true,
        configurable: true
    });
    OutlineCreateTag.prototype.dispose = function () {
        this._disposeOutline();
        this._geometryChangedSubscription.unsubscribe();
    };
    OutlineCreateTag.prototype.getDOMObjects = function (camera, size) {
        var _this = this;
        var vNodes = [];
        var container = {
            offsetHeight: size.height, offsetWidth: size.width,
        };
        var abort = function (e) {
            e.stopPropagation();
            _this._aborted$.next(_this);
        };
        if (this._geometry instanceof Component_1.RectGeometry) {
            var anchorIndex = this._geometry.anchorIndex;
            var vertexIndex = anchorIndex === undefined ? 1 : anchorIndex;
            var _a = this._geometry.getVertex2d(vertexIndex), basicX = _a[0], basicY = _a[1];
            var canvasPoint = this._viewportCoords.basicToCanvasSafe(basicX, basicY, container, this._transform, camera);
            if (canvasPoint != null) {
                var background = this._colorToBackground(this._options.color);
                var transform = this._canvasToTransform(canvasPoint);
                var pointProperties = {
                    style: { background: background, transform: transform },
                };
                var completerProperties = {
                    onclick: abort,
                    style: { transform: transform },
                };
                vNodes.push(vd.h("div.TagInteractor", completerProperties, []));
                vNodes.push(vd.h("div.TagVertex", pointProperties, []));
            }
        }
        else if (this._geometry instanceof Component_1.PolygonGeometry) {
            var polygonGeometry_1 = this._geometry;
            var _b = polygonGeometry_1.getVertex2d(0), firstVertexBasicX = _b[0], firstVertexBasicY = _b[1];
            var firstVertexCanvas = this._viewportCoords.basicToCanvasSafe(firstVertexBasicX, firstVertexBasicY, container, this._transform, camera);
            if (firstVertexCanvas != null) {
                var firstOnclick = polygonGeometry_1.polygon.length > 4 ?
                    function (e) {
                        e.stopPropagation();
                        polygonGeometry_1.removeVertex2d(polygonGeometry_1.polygon.length - 2);
                        _this._created$.next(_this);
                    } :
                    abort;
                var transform = this._canvasToTransform(firstVertexCanvas);
                var completerProperties = {
                    onclick: firstOnclick,
                    style: { transform: transform },
                };
                var firstClass = polygonGeometry_1.polygon.length > 4 ?
                    "TagCompleter" :
                    "TagInteractor";
                vNodes.push(vd.h("div." + firstClass, completerProperties, []));
            }
            if (polygonGeometry_1.polygon.length > 3) {
                var _c = polygonGeometry_1.getVertex2d(polygonGeometry_1.polygon.length - 3), lastVertexBasicX = _c[0], lastVertexBasicY = _c[1];
                var lastVertexCanvas = this._viewportCoords.basicToCanvasSafe(lastVertexBasicX, lastVertexBasicY, container, this._transform, camera);
                if (lastVertexCanvas != null) {
                    var remove = function (e) {
                        e.stopPropagation();
                        polygonGeometry_1.removeVertex2d(polygonGeometry_1.polygon.length - 3);
                    };
                    var transform = this._canvasToTransform(lastVertexCanvas);
                    var completerProperties = {
                        onclick: remove,
                        style: { transform: transform },
                    };
                    vNodes.push(vd.h("div.TagInteractor", completerProperties, []));
                }
            }
            var verticesBasic = polygonGeometry_1.polygon.slice();
            verticesBasic.splice(-2, 2);
            for (var _i = 0, verticesBasic_1 = verticesBasic; _i < verticesBasic_1.length; _i++) {
                var vertexBasic = verticesBasic_1[_i];
                var vertexCanvas = this._viewportCoords.basicToCanvasSafe(vertexBasic[0], vertexBasic[1], container, this._transform, camera);
                if (vertexCanvas != null) {
                    var background = this._colorToBackground(this._options.color);
                    var transform = this._canvasToTransform(vertexCanvas);
                    var pointProperties = {
                        style: {
                            background: background,
                            transform: transform,
                        },
                    };
                    vNodes.push(vd.h("div.TagVertex", pointProperties, []));
                }
            }
        }
        return vNodes;
    };
    OutlineCreateTag.prototype.addPoint = function (point) {
        if (this._geometry instanceof Component_1.RectGeometry) {
            var rectGeometry = this._geometry;
            if (!rectGeometry.validate(point)) {
                return;
            }
            this._created$.next(this);
        }
        else if (this._geometry instanceof Component_1.PolygonGeometry) {
            var polygonGeometry = this._geometry;
            polygonGeometry.addVertex2d(point);
        }
    };
    OutlineCreateTag.prototype._canvasToTransform = function (canvas) {
        var canvasX = Math.round(canvas[0]);
        var canvasY = Math.round(canvas[1]);
        var transform = "translate(-50%,-50%) translate(" + canvasX + "px," + canvasY + "px)";
        return transform;
    };
    OutlineCreateTag.prototype._colorToBackground = function (color) {
        return "#" + ("000000" + color.toString(16)).substr(-6);
    };
    OutlineCreateTag.prototype._createOutine = function () {
        var polygon3d = this._geometry.getPoints3d(this._transform);
        var positions = this._getLinePositions(polygon3d);
        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute("position", new THREE.BufferAttribute(positions, 3));
        var material = new THREE.LineBasicMaterial({
            color: this._options.color,
            linewidth: 1,
        });
        return new THREE.Line(geometry, material);
    };
    OutlineCreateTag.prototype._disposeOutline = function () {
        if (this._outline == null) {
            return;
        }
        var line = this._outline;
        line.geometry.dispose();
        line.material.dispose();
        this._outline = null;
        this._glObjects = [];
    };
    OutlineCreateTag.prototype._getLinePositions = function (polygon3d) {
        var length = polygon3d.length;
        var positions = new Float32Array(length * 3);
        for (var i = 0; i < length; ++i) {
            var index = 3 * i;
            var position = polygon3d[i];
            positions[index] = position[0];
            positions[index + 1] = position[1];
            positions[index + 2] = position[2];
        }
        return positions;
    };
    return OutlineCreateTag;
}());
exports.OutlineCreateTag = OutlineCreateTag;
exports.default = OutlineCreateTag;

},{"../../../Component":291,"../../../Geo":294,"rxjs/Subject":34,"three":241,"virtual-dom":247}],376:[function(require,module,exports){
"use strict";
/// <reference path="../../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var vd = require("virtual-dom");
var Component_1 = require("../../../Component");
/**
 * @class OutlineRenderTag
 * @classdesc Tag visualizing the properties of an OutlineTag.
 */
var OutlineRenderTag = /** @class */ (function (_super) {
    __extends(OutlineRenderTag, _super);
    function OutlineRenderTag(tag, transform) {
        var _this = _super.call(this, tag, transform) || this;
        _this._fill = !transform.gpano ?
            _this._createFill() :
            null;
        _this._holes = _this._tag.lineWidth >= 1 ?
            _this._createHoles() :
            [];
        _this._outline = _this._tag.lineWidth >= 1 ?
            _this._createOutline() :
            null;
        _this._geometryChangedSubscription = _this._tag.geometry.changed$
            .subscribe(function (geometry) {
            if (_this._fill != null) {
                _this._updateFillGeometry();
            }
            if (_this._holes.length > 0) {
                _this._updateHoleGeometries();
            }
            if (_this._outline != null) {
                _this._updateOulineGeometry();
            }
        });
        _this._changedSubscription = _this._tag.changed$
            .subscribe(function (changedTag) {
            var glObjectsChanged = false;
            if (_this._fill != null) {
                _this._updateFillMaterial(_this._fill.material);
            }
            if (_this._outline == null) {
                if (_this._tag.lineWidth >= 1) {
                    _this._holes = _this._createHoles();
                    _this._outline = _this._createOutline();
                    glObjectsChanged = true;
                }
            }
            else {
                _this._updateHoleMaterials();
                _this._updateOutlineMaterial();
            }
            if (glObjectsChanged) {
                _this._glObjectsChanged$.next(_this);
            }
        });
        return _this;
    }
    OutlineRenderTag.prototype.dispose = function () {
        this._disposeFill();
        this._disposeHoles();
        this._disposeOutline();
        this._changedSubscription.unsubscribe();
        this._geometryChangedSubscription.unsubscribe();
    };
    OutlineRenderTag.prototype.getDOMObjects = function (atlas, camera, size) {
        var _this = this;
        var vNodes = [];
        var isRect = this._tag.geometry instanceof Component_1.RectGeometry;
        var isPerspective = !this._transform.gpano;
        var container = {
            offsetHeight: size.height, offsetWidth: size.width,
        };
        if (this._tag.icon != null && (isRect || isPerspective)) {
            var _a = this._tag.geometry instanceof Component_1.RectGeometry ?
                this._tag.geometry.getVertex2d(this._tag.iconIndex) :
                this._tag.geometry.getPoleOfAccessibility2d(), iconBasicX = _a[0], iconBasicY = _a[1];
            var iconCanvas = this._viewportCoords.basicToCanvasSafe(iconBasicX, iconBasicY, container, this._transform, camera);
            if (iconCanvas != null) {
                var interact = function (e) {
                    _this._interact$.next({ offsetX: 0, offsetY: 0, operation: Component_1.TagOperation.None, tag: _this._tag });
                };
                if (atlas.loaded) {
                    var sprite = atlas.getDOMSprite(this._tag.icon, this._tag.iconFloat);
                    var iconCanvasX = Math.round(iconCanvas[0]);
                    var iconCanvasY = Math.round(iconCanvas[1]);
                    var transform = "translate(" + iconCanvasX + "px," + iconCanvasY + "px)";
                    var click = function (e) {
                        e.stopPropagation();
                        _this._tag.click$.next(_this._tag);
                    };
                    var properties = {
                        onclick: click,
                        onmousedown: interact,
                        style: { transform: transform },
                    };
                    vNodes.push(vd.h("div.TagSymbol", properties, [sprite]));
                }
            }
        }
        else if (this._tag.text != null && (isRect || isPerspective)) {
            var _b = this._tag.geometry instanceof Component_1.RectGeometry ?
                this._tag.geometry.getVertex2d(3) :
                this._tag.geometry.getPoleOfAccessibility2d(), textBasicX = _b[0], textBasicY = _b[1];
            var textCanvas = this._viewportCoords.basicToCanvasSafe(textBasicX, textBasicY, container, this._transform, camera);
            if (textCanvas != null) {
                var textCanvasX = Math.round(textCanvas[0]);
                var textCanvasY = Math.round(textCanvas[1]);
                var transform = this._tag.geometry instanceof Component_1.RectGeometry ?
                    "translate(" + textCanvasX + "px," + textCanvasY + "px)" :
                    "translate(-50%, -50%) translate(" + textCanvasX + "px," + textCanvasY + "px)";
                var interact = function (e) {
                    _this._interact$.next({ offsetX: 0, offsetY: 0, operation: Component_1.TagOperation.None, tag: _this._tag });
                };
                var properties = {
                    onmousedown: interact,
                    style: {
                        color: this._colorToCss(this._tag.textColor),
                        transform: transform,
                    },
                    textContent: this._tag.text,
                };
                vNodes.push(vd.h("span.TagSymbol", properties, []));
            }
        }
        if (!this._tag.editable) {
            return vNodes;
        }
        var lineColor = this._colorToCss(this._tag.lineColor);
        if (this._tag.geometry instanceof Component_1.RectGeometry) {
            var _c = this._tag.geometry.getCentroid2d(), centroidBasicX = _c[0], centroidBasicY = _c[1];
            var centroidCanvas = this._viewportCoords.basicToCanvasSafe(centroidBasicX, centroidBasicY, container, this._transform, camera);
            if (centroidCanvas != null) {
                var interact = this._interact(Component_1.TagOperation.Centroid, "move");
                var centroidCanvasX = Math.round(centroidCanvas[0]);
                var centroidCanvasY = Math.round(centroidCanvas[1]);
                var transform = "translate(-50%, -50%) translate(" + centroidCanvasX + "px," + centroidCanvasY + "px)";
                var properties = {
                    onmousedown: interact,
                    style: { background: lineColor, transform: transform },
                };
                vNodes.push(vd.h("div.TagMover", properties, []));
            }
        }
        var vertices2d = this._tag.geometry.getVertices2d();
        for (var i = 0; i < vertices2d.length - 1; i++) {
            if (isRect &&
                ((this._tag.icon != null && i === this._tag.iconIndex) ||
                    (this._tag.icon == null && this._tag.text != null && i === 3))) {
                continue;
            }
            var _d = vertices2d[i], vertexBasicX = _d[0], vertexBasicY = _d[1];
            var vertexCanvas = this._viewportCoords.basicToCanvasSafe(vertexBasicX, vertexBasicY, container, this._transform, camera);
            if (vertexCanvas == null) {
                continue;
            }
            var cursor = isRect ?
                i % 2 === 0 ? "nesw-resize" : "nwse-resize" :
                "crosshair";
            var interact = this._interact(Component_1.TagOperation.Vertex, cursor, i);
            var vertexCanvasX = Math.round(vertexCanvas[0]);
            var vertexCanvasY = Math.round(vertexCanvas[1]);
            var transform = "translate(-50%, -50%) translate(" + vertexCanvasX + "px," + vertexCanvasY + "px)";
            var properties = {
                onmousedown: interact,
                style: { background: lineColor, transform: transform, cursor: cursor },
            };
            vNodes.push(vd.h("div.TagResizer", properties, []));
            if (!this._tag.indicateVertices) {
                continue;
            }
            var pointProperties = {
                style: { background: lineColor, transform: transform },
            };
            vNodes.push(vd.h("div.TagVertex", pointProperties, []));
        }
        return vNodes;
    };
    OutlineRenderTag.prototype.getGLObjects = function () {
        var glObjects = [];
        if (this._fill != null) {
            glObjects.push(this._fill);
        }
        for (var _i = 0, _a = this._holes; _i < _a.length; _i++) {
            var hole = _a[_i];
            glObjects.push(hole);
        }
        if (this._outline != null) {
            glObjects.push(this._outline);
        }
        return glObjects;
    };
    OutlineRenderTag.prototype.getRetrievableObjects = function () {
        return this._fill != null ? [this._fill] : [];
    };
    OutlineRenderTag.prototype._colorToCss = function (color) {
        return "#" + ("000000" + color.toString(16)).substr(-6);
    };
    OutlineRenderTag.prototype._createFill = function () {
        var triangles = this._tag.geometry.getTriangles3d(this._transform);
        var positions = new Float32Array(triangles);
        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute("position", new THREE.BufferAttribute(positions, 3));
        geometry.computeBoundingSphere();
        var material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent: true });
        this._updateFillMaterial(material);
        return new THREE.Mesh(geometry, material);
    };
    OutlineRenderTag.prototype._createHoles = function () {
        var holes = [];
        if (this._tag.geometry instanceof Component_1.PolygonGeometry) {
            var polygonGeometry = this._tag.geometry;
            var holes3d = polygonGeometry.getHoleVertices3d(this._transform);
            for (var _i = 0, holes3d_1 = holes3d; _i < holes3d_1.length; _i++) {
                var holePoints3d = holes3d_1[_i];
                var hole = this._createLine(holePoints3d);
                holes.push(hole);
            }
        }
        return holes;
    };
    OutlineRenderTag.prototype._createLine = function (points3d) {
        var positions = this._getLinePositions(points3d);
        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute("position", new THREE.BufferAttribute(positions, 3));
        geometry.computeBoundingSphere();
        var material = new THREE.LineBasicMaterial();
        this._updateLineBasicMaterial(material);
        var line = new THREE.Line(geometry, material);
        line.renderOrder = 1;
        return line;
    };
    OutlineRenderTag.prototype._createOutline = function () {
        var points3d = this._tag.geometry.getPoints3d(this._transform);
        return this._createLine(points3d);
    };
    OutlineRenderTag.prototype._disposeFill = function () {
        if (this._fill == null) {
            return;
        }
        this._fill.geometry.dispose();
        this._fill.material.dispose();
        this._fill = null;
    };
    OutlineRenderTag.prototype._disposeHoles = function () {
        for (var _i = 0, _a = this._holes; _i < _a.length; _i++) {
            var hole = _a[_i];
            hole.geometry.dispose();
            hole.material.dispose();
        }
        this._holes = [];
    };
    OutlineRenderTag.prototype._disposeOutline = function () {
        if (this._outline == null) {
            return;
        }
        this._outline.geometry.dispose();
        this._outline.material.dispose();
        this._outline = null;
    };
    OutlineRenderTag.prototype._getLinePositions = function (points3d) {
        var length = points3d.length;
        var positions = new Float32Array(length * 3);
        for (var i = 0; i < length; ++i) {
            var index = 3 * i;
            var position = points3d[i];
            positions[index + 0] = position[0];
            positions[index + 1] = position[1];
            positions[index + 2] = position[2];
        }
        return positions;
    };
    OutlineRenderTag.prototype._interact = function (operation, cursor, vertexIndex) {
        var _this = this;
        return function (e) {
            var offsetX = e.offsetX - e.target.offsetWidth / 2;
            var offsetY = e.offsetY - e.target.offsetHeight / 2;
            _this._interact$.next({
                cursor: cursor,
                offsetX: offsetX,
                offsetY: offsetY,
                operation: operation,
                tag: _this._tag,
                vertexIndex: vertexIndex,
            });
        };
    };
    OutlineRenderTag.prototype._updateFillGeometry = function () {
        var triangles = this._tag.geometry.getTriangles3d(this._transform);
        var positions = new Float32Array(triangles);
        var geometry = this._fill.geometry;
        var attribute = geometry.getAttribute("position");
        if (attribute.array.length === positions.length) {
            attribute.set(positions);
            attribute.needsUpdate = true;
        }
        else {
            geometry.removeAttribute("position");
            geometry.addAttribute("position", new THREE.BufferAttribute(positions, 3));
        }
        geometry.computeBoundingSphere();
    };
    OutlineRenderTag.prototype._updateFillMaterial = function (material) {
        material.color = new THREE.Color(this._tag.fillColor);
        material.opacity = this._tag.fillOpacity;
        material.needsUpdate = true;
    };
    OutlineRenderTag.prototype._updateHoleGeometries = function () {
        var polygonGeometry = this._tag.geometry;
        var holes3d = polygonGeometry.getHoleVertices3d(this._transform);
        if (holes3d.length !== this._holes.length) {
            throw new Error("Changing the number of holes is not supported.");
        }
        for (var i = 0; i < this._holes.length; i++) {
            var holePoints3d = holes3d[i];
            var hole = this._holes[i];
            this._updateLine(hole, holePoints3d);
        }
    };
    OutlineRenderTag.prototype._updateHoleMaterials = function () {
        for (var _i = 0, _a = this._holes; _i < _a.length; _i++) {
            var hole = _a[_i];
            var material = hole.material;
            this._updateLineBasicMaterial(material);
        }
    };
    OutlineRenderTag.prototype._updateLine = function (line, points3d) {
        var positions = this._getLinePositions(points3d);
        var geometry = line.geometry;
        var attribute = geometry.getAttribute("position");
        attribute.set(positions);
        attribute.needsUpdate = true;
        geometry.computeBoundingSphere();
    };
    OutlineRenderTag.prototype._updateOulineGeometry = function () {
        var points3d = this._tag.geometry.getPoints3d(this._transform);
        this._updateLine(this._outline, points3d);
    };
    OutlineRenderTag.prototype._updateOutlineMaterial = function () {
        var material = this._outline.material;
        this._updateLineBasicMaterial(material);
    };
    OutlineRenderTag.prototype._updateLineBasicMaterial = function (material) {
        material.color = new THREE.Color(this._tag.lineColor);
        material.linewidth = Math.max(this._tag.lineWidth, 1);
        material.visible = this._tag.lineWidth >= 1 && this._tag.lineOpacity > 0;
        material.opacity = this._tag.lineOpacity;
        material.transparent = this._tag.lineOpacity < 1;
        material.needsUpdate = true;
    };
    return OutlineRenderTag;
}(Component_1.RenderTag));
exports.OutlineRenderTag = OutlineRenderTag;

},{"../../../Component":291,"three":241,"virtual-dom":247}],377:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("rxjs/Subject");
var Component_1 = require("../../../Component");
var Viewer_1 = require("../../../Viewer");
/**
 * @class OutlineTag
 *
 * @classdesc Tag holding properties for visualizing a geometry outline.
 *
 * @example
 * ```
 * var geometry = new Mapillary.TagComponent.RectGeometry([0.3, 0.3, 0.5, 0.4]);
 * var tag = new Mapillary.TagComponent.OutlineTag(
 *     "id-1",
 *     geometry
 *     { editable: true, lineColor: 0xff0000 });
 *
 * tagComponent.add([tag]);
 * ```
 */
var OutlineTag = /** @class */ (function (_super) {
    __extends(OutlineTag, _super);
    /**
     * Create an outline tag.
     *
     * @override
     * @constructor
     * @param {string} id - Unique identifier of the tag.
     * @param {VertexGeometry} geometry - Geometry defining vertices of tag.
     * @param {IOutlineTagOptions} options - Options defining the visual appearance and
     * behavior of the outline tag.
     */
    function OutlineTag(id, geometry, options) {
        var _this = _super.call(this, id, geometry) || this;
        options = !!options ? options : {};
        _this._editable = options.editable == null ? false : options.editable;
        _this._fillColor = options.fillColor == null ? 0xFFFFFF : options.fillColor;
        _this._fillOpacity = options.fillOpacity == null ? 0.0 : options.fillOpacity;
        _this._icon = options.icon === undefined ? null : options.icon;
        _this._iconFloat = options.iconFloat == null ? Viewer_1.Alignment.Center : options.iconFloat;
        _this._iconIndex = options.iconIndex == null ? 3 : options.iconIndex;
        _this._indicateVertices = options.indicateVertices == null ? true : options.indicateVertices;
        _this._lineColor = options.lineColor == null ? 0xFFFFFF : options.lineColor;
        _this._lineOpacity = options.lineOpacity == null ? 1 : options.lineOpacity;
        _this._lineWidth = options.lineWidth == null ? 1 : options.lineWidth;
        _this._text = options.text === undefined ? null : options.text;
        _this._textColor = options.textColor == null ? 0xFFFFFF : options.textColor;
        _this._click$ = new Subject_1.Subject();
        _this._click$
            .subscribe(function (t) {
            _this.fire(OutlineTag.click, _this);
        });
        return _this;
    }
    Object.defineProperty(OutlineTag.prototype, "click$", {
        /**
         * Click observable.
         *
         * @description An observable emitting the tag when the icon of the
         * tag has been clicked.
         *
         * @returns {Observable<Tag>}
         */
        get: function () {
            return this._click$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineTag.prototype, "editable", {
        /**
         * Get editable property.
         * @returns {boolean} Value indicating if tag is editable.
         */
        get: function () {
            return this._editable;
        },
        /**
         * Set editable property.
         * @param {boolean}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._editable = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineTag.prototype, "fillColor", {
        /**
         * Get fill color property.
         * @returns {number}
         */
        get: function () {
            return this._fillColor;
        },
        /**
         * Set fill color property.
         * @param {number}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._fillColor = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineTag.prototype, "fillOpacity", {
        /**
         * Get fill opacity property.
         * @returns {number}
         */
        get: function () {
            return this._fillOpacity;
        },
        /**
         * Set fill opacity property.
         * @param {number}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._fillOpacity = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineTag.prototype, "geometry", {
        /** @inheritdoc */
        get: function () {
            return this._geometry;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineTag.prototype, "icon", {
        /**
         * Get icon property.
         * @returns {string}
         */
        get: function () {
            return this._icon;
        },
        /**
         * Set icon property.
         * @param {string}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._icon = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineTag.prototype, "iconFloat", {
        /**
         * Get icon float property.
         * @returns {Alignment}
         */
        get: function () {
            return this._iconFloat;
        },
        /**
         * Set icon float property.
         * @param {Alignment}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._iconFloat = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineTag.prototype, "iconIndex", {
        /**
         * Get icon index property.
         * @returns {number}
         */
        get: function () {
            return this._iconIndex;
        },
        /**
         * Set icon index property.
         * @param {number}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._iconIndex = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineTag.prototype, "indicateVertices", {
        /**
         * Get indicate vertices property.
         * @returns {boolean} Value indicating if vertices should be indicated
         * when tag is editable.
         */
        get: function () {
            return this._indicateVertices;
        },
        /**
         * Set indicate vertices property.
         * @param {boolean}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._indicateVertices = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineTag.prototype, "lineColor", {
        /**
         * Get line color property.
         * @returns {number}
         */
        get: function () {
            return this._lineColor;
        },
        /**
         * Set line color property.
         * @param {number}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._lineColor = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineTag.prototype, "lineOpacity", {
        /**
         * Get line opacity property.
         * @returns {number}
         */
        get: function () {
            return this._lineOpacity;
        },
        /**
         * Set line opacity property.
         * @param {number}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._lineOpacity = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineTag.prototype, "lineWidth", {
        /**
         * Get line width property.
         * @returns {number}
         */
        get: function () {
            return this._lineWidth;
        },
        /**
         * Set line width property.
         * @param {number}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._lineWidth = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineTag.prototype, "text", {
        /**
         * Get text property.
         * @returns {string}
         */
        get: function () {
            return this._text;
        },
        /**
         * Set text property.
         * @param {string}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._text = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutlineTag.prototype, "textColor", {
        /**
         * Get text color property.
         * @returns {number}
         */
        get: function () {
            return this._textColor;
        },
        /**
         * Set text color property.
         * @param {number}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._textColor = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set options for tag.
     *
     * @description Sets all the option properties provided and keeps
     * the rest of the values as is.
     *
     * @param {IOutlineTagOptions} options - Outline tag options
     *
     * @fires {Tag#changed}
     */
    OutlineTag.prototype.setOptions = function (options) {
        this._editable = options.editable == null ? this._editable : options.editable;
        this._icon = options.icon === undefined ? this._icon : options.icon;
        this._iconFloat = options.iconFloat == null ? this._iconFloat : options.iconFloat;
        this._iconIndex = options.iconIndex == null ? this._iconIndex : options.iconIndex;
        this._indicateVertices = options.indicateVertices == null ? this._indicateVertices : options.indicateVertices;
        this._lineColor = options.lineColor == null ? this._lineColor : options.lineColor;
        this._lineWidth = options.lineWidth == null ? this._lineWidth : options.lineWidth;
        this._fillColor = options.fillColor == null ? this._fillColor : options.fillColor;
        this._fillOpacity = options.fillOpacity == null ? this._fillOpacity : options.fillOpacity;
        this._text = options.text === undefined ? this._text : options.text;
        this._textColor = options.textColor == null ? this._textColor : options.textColor;
        this._notifyChanged$.next(this);
    };
    /**
     * Event fired when the icon of the outline tag is clicked.
     *
     * @event OutlineTag#click
     * @type {OutlineTag} The tag instance that was clicked.
     */
    OutlineTag.click = "click";
    return OutlineTag;
}(Component_1.Tag));
exports.OutlineTag = OutlineTag;
exports.default = OutlineTag;

},{"../../../Component":291,"../../../Viewer":302,"rxjs/Subject":34}],378:[function(require,module,exports){
"use strict";
/// <reference path="../../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("rxjs/Subject");
var Geo_1 = require("../../../Geo");
var RenderTag = /** @class */ (function () {
    function RenderTag(tag, transform, viewportCoords) {
        this._tag = tag;
        this._transform = transform;
        this._viewportCoords = !!viewportCoords ? viewportCoords : new Geo_1.ViewportCoords();
        this._glObjectsChanged$ = new Subject_1.Subject();
        this._interact$ = new Subject_1.Subject();
    }
    Object.defineProperty(RenderTag.prototype, "glObjectsChanged$", {
        get: function () {
            return this._glObjectsChanged$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderTag.prototype, "interact$", {
        get: function () {
            return this._interact$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderTag.prototype, "tag", {
        get: function () {
            return this._tag;
        },
        enumerable: true,
        configurable: true
    });
    return RenderTag;
}());
exports.RenderTag = RenderTag;
exports.default = RenderTag;

},{"../../../Geo":294,"rxjs/Subject":34}],379:[function(require,module,exports){
"use strict";
/// <reference path="../../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var vd = require("virtual-dom");
var Component_1 = require("../../../Component");
var Viewer_1 = require("../../../Viewer");
/**
 * @class SpotRenderTag
 * @classdesc Tag visualizing the properties of a SpotTag.
 */
var SpotRenderTag = /** @class */ (function (_super) {
    __extends(SpotRenderTag, _super);
    function SpotRenderTag() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SpotRenderTag.prototype.dispose = function () { };
    SpotRenderTag.prototype.getDOMObjects = function (atlas, camera, size) {
        var _this = this;
        var tag = this._tag;
        var container = {
            offsetHeight: size.height, offsetWidth: size.width,
        };
        var vNodes = [];
        var _a = tag.geometry.getCentroid2d(), centroidBasicX = _a[0], centroidBasicY = _a[1];
        var centroidCanvas = this._viewportCoords.basicToCanvasSafe(centroidBasicX, centroidBasicY, container, this._transform, camera);
        if (centroidCanvas != null) {
            var interactNone = function (e) {
                _this._interact$.next({ offsetX: 0, offsetY: 0, operation: Component_1.TagOperation.None, tag: tag });
            };
            var canvasX = Math.round(centroidCanvas[0]);
            var canvasY = Math.round(centroidCanvas[1]);
            if (tag.icon != null) {
                if (atlas.loaded) {
                    var sprite = atlas.getDOMSprite(tag.icon, Viewer_1.Alignment.Bottom);
                    var iconTransform = "translate(" + canvasX + "px," + (canvasY + 8) + "px)";
                    var properties = {
                        onmousedown: interactNone,
                        style: {
                            pointerEvents: "all",
                            transform: iconTransform,
                        },
                    };
                    vNodes.push(vd.h("div", properties, [sprite]));
                }
            }
            else if (tag.text != null) {
                var textTransform = "translate(-50%,0%) translate(" + canvasX + "px," + (canvasY + 8) + "px)";
                var properties = {
                    onmousedown: interactNone,
                    style: {
                        color: this._colorToCss(tag.textColor),
                        transform: textTransform,
                    },
                    textContent: tag.text,
                };
                vNodes.push(vd.h("span.TagSymbol", properties, []));
            }
            var interact = this._interact(Component_1.TagOperation.Centroid, tag, "move");
            var background = this._colorToCss(tag.color);
            var transform = "translate(-50%,-50%) translate(" + canvasX + "px," + canvasY + "px)";
            if (tag.editable) {
                var interactorProperties = {
                    onmousedown: interact,
                    style: {
                        background: background,
                        transform: transform,
                    },
                };
                vNodes.push(vd.h("div.TagSpotInteractor", interactorProperties, []));
            }
            var pointProperties = {
                style: {
                    background: background,
                    transform: transform,
                },
            };
            vNodes.push(vd.h("div.TagVertex", pointProperties, []));
        }
        return vNodes;
    };
    SpotRenderTag.prototype.getGLObjects = function () { return []; };
    SpotRenderTag.prototype.getRetrievableObjects = function () { return []; };
    SpotRenderTag.prototype._colorToCss = function (color) {
        return "#" + ("000000" + color.toString(16)).substr(-6);
    };
    SpotRenderTag.prototype._interact = function (operation, tag, cursor, vertexIndex) {
        var _this = this;
        return function (e) {
            var offsetX = e.offsetX - e.target.offsetWidth / 2;
            var offsetY = e.offsetY - e.target.offsetHeight / 2;
            _this._interact$.next({
                cursor: cursor,
                offsetX: offsetX,
                offsetY: offsetY,
                operation: operation,
                tag: tag,
                vertexIndex: vertexIndex,
            });
        };
    };
    return SpotRenderTag;
}(Component_1.RenderTag));
exports.SpotRenderTag = SpotRenderTag;

},{"../../../Component":291,"../../../Viewer":302,"virtual-dom":247}],380:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Component_1 = require("../../../Component");
/**
 * @class SpotTag
 *
 * @classdesc Tag holding properties for visualizing the centroid of a geometry.
 *
 * @example
 * ```
 * var geometry = new Mapillary.TagComponent.PointGeometry([0.3, 0.3]);
 * var tag = new Mapillary.TagComponent.SpotTag(
 *     "id-1",
 *     geometry
 *     { editable: true, color: 0xff0000 });
 *
 * tagComponent.add([tag]);
 * ```
 */
var SpotTag = /** @class */ (function (_super) {
    __extends(SpotTag, _super);
    /**
     * Create a spot tag.
     *
     * @override
     * @constructor
     * @param {string} id
     * @param {Geometry} geometry
     * @param {IOutlineTagOptions} options - Options defining the visual appearance and
     * behavior of the spot tag.
     */
    function SpotTag(id, geometry, options) {
        var _this = _super.call(this, id, geometry) || this;
        options = !!options ? options : {};
        _this._color = options.color == null ? 0xFFFFFF : options.color;
        _this._editable = options.editable == null ? false : options.editable;
        _this._icon = options.icon === undefined ? null : options.icon;
        _this._text = options.text === undefined ? null : options.text;
        _this._textColor = options.textColor == null ? 0xFFFFFF : options.textColor;
        return _this;
    }
    Object.defineProperty(SpotTag.prototype, "color", {
        /**
         * Get color property.
         * @returns {number} The color of the spot as a hexagonal number;
         */
        get: function () {
            return this._color;
        },
        /**
         * Set color property.
         * @param {number}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._color = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpotTag.prototype, "editable", {
        /**
         * Get editable property.
         * @returns {boolean} Value indicating if tag is editable.
         */
        get: function () {
            return this._editable;
        },
        /**
         * Set editable property.
         * @param {boolean}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._editable = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpotTag.prototype, "icon", {
        /**
         * Get icon property.
         * @returns {string}
         */
        get: function () {
            return this._icon;
        },
        /**
         * Set icon property.
         * @param {string}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._icon = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpotTag.prototype, "text", {
        /**
         * Get text property.
         * @returns {string}
         */
        get: function () {
            return this._text;
        },
        /**
         * Set text property.
         * @param {string}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._text = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpotTag.prototype, "textColor", {
        /**
         * Get text color property.
         * @returns {number}
         */
        get: function () {
            return this._textColor;
        },
        /**
         * Set text color property.
         * @param {number}
         *
         * @fires Tag#changed
         */
        set: function (value) {
            this._textColor = value;
            this._notifyChanged$.next(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set options for tag.
     *
     * @description Sets all the option properties provided and keps
     * the rest of the values as is.
     *
     * @param {ISpotTagOptions} options - Spot tag options
     *
     * @fires {Tag#changed}
     */
    SpotTag.prototype.setOptions = function (options) {
        this._color = options.color == null ? this._color : options.color;
        this._editable = options.editable == null ? this._editable : options.editable;
        this._icon = options.icon === undefined ? this._icon : options.icon;
        this._text = options.text === undefined ? this._text : options.text;
        this._textColor = options.textColor == null ? this._textColor : options.textColor;
        this._notifyChanged$.next(this);
    };
    return SpotTag;
}(Component_1.Tag));
exports.SpotTag = SpotTag;
exports.default = SpotTag;

},{"../../../Component":291}],381:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/operator/map");
require("rxjs/add/operator/share");
var Utils_1 = require("../../../Utils");
/**
 * @class Tag
 * @abstract
 * @classdesc Abstract class representing the basic functionality of for a tag.
 */
var Tag = /** @class */ (function (_super) {
    __extends(Tag, _super);
    /**
     * Create a tag.
     *
     * @constructor
     * @param {string} id
     * @param {Geometry} geometry
     */
    function Tag(id, geometry) {
        var _this = _super.call(this) || this;
        _this._id = id;
        _this._geometry = geometry;
        _this._notifyChanged$ = new Subject_1.Subject();
        _this._notifyChanged$
            .subscribe(function (t) {
            _this.fire(Tag.changed, _this);
        });
        _this._geometry.changed$
            .subscribe(function (g) {
            _this.fire(Tag.geometrychanged, _this);
        });
        return _this;
    }
    Object.defineProperty(Tag.prototype, "id", {
        /**
         * Get id property.
         * @returns {string}
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tag.prototype, "geometry", {
        /**
         * Get geometry property.
         * @returns {Geometry} The geometry of the tag.
         */
        get: function () {
            return this._geometry;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tag.prototype, "changed$", {
        /**
         * Get changed observable.
         * @returns {Observable<Tag>}
         * @ignore
         */
        get: function () {
            return this._notifyChanged$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tag.prototype, "geometryChanged$", {
        /**
         * Get geometry changed observable.
         * @returns {Observable<Tag>}
         * @ignore
         */
        get: function () {
            var _this = this;
            return this._geometry.changed$
                .map(function (geometry) {
                return _this;
            })
                .share();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Event fired when a property related to the visual appearance of the
     * tag has changed.
     *
     * @event Tag#changed
     * @type {Tag} The tag instance that has changed.
     */
    Tag.changed = "changed";
    /**
     * Event fired when the geometry of the tag has changed.
     *
     * @event Tag#geometrychanged
     * @type {Tag} The tag instance whose geometry has changed.
     */
    Tag.geometrychanged = "geometrychanged";
    return Tag;
}(Utils_1.EventEmitter));
exports.Tag = Tag;
exports.default = Tag;

},{"../../../Utils":301,"rxjs/Subject":34,"rxjs/add/operator/map":67,"rxjs/add/operator/share":79}],382:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var HandlerBase = /** @class */ (function () {
    function HandlerBase(component, container, navigator) {
        this._component = component;
        this._container = container;
        this._navigator = navigator;
        this._enabled = false;
    }
    Object.defineProperty(HandlerBase.prototype, "isEnabled", {
        /**
         * Returns a Boolean indicating whether the interaction is enabled.
         *
         * @returns {boolean} `true` if the interaction is enabled.
         */
        get: function () {
            return this._enabled;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Enables the interaction.
     *
     * @example ```<component-name>.<handler-name>.enable();```
     */
    HandlerBase.prototype.enable = function () {
        if (this._enabled || !this._component.activated) {
            return;
        }
        this._enable();
        this._enabled = true;
        this._component.configure(this._getConfiguration(true));
    };
    /**
     * Disables the interaction.
     *
     * @example ```<component-name>.<handler-name>.disable();```
     */
    HandlerBase.prototype.disable = function () {
        if (!this._enabled) {
            return;
        }
        this._disable();
        this._enabled = false;
        if (this._component.activated) {
            this._component.configure(this._getConfiguration(false));
        }
    };
    return HandlerBase;
}());
exports.HandlerBase = HandlerBase;
exports.default = HandlerBase;

},{}],383:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MapillaryError_1 = require("./MapillaryError");
var AbortMapillaryError = /** @class */ (function (_super) {
    __extends(AbortMapillaryError, _super);
    function AbortMapillaryError(message) {
        var _this = _super.call(this, message != null ? message : "The request was aborted.") || this;
        Object.setPrototypeOf(_this, AbortMapillaryError.prototype);
        _this.name = "AbortMapillaryError";
        return _this;
    }
    return AbortMapillaryError;
}(MapillaryError_1.MapillaryError));
exports.AbortMapillaryError = AbortMapillaryError;
exports.default = AbortMapillaryError;

},{"./MapillaryError":386}],384:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MapillaryError_1 = require("./MapillaryError");
var ArgumentMapillaryError = /** @class */ (function (_super) {
    __extends(ArgumentMapillaryError, _super);
    function ArgumentMapillaryError(message) {
        var _this = _super.call(this, message != null ? message : "The argument is not valid.") || this;
        Object.setPrototypeOf(_this, ArgumentMapillaryError.prototype);
        _this.name = "ArgumentMapillaryError";
        return _this;
    }
    return ArgumentMapillaryError;
}(MapillaryError_1.MapillaryError));
exports.ArgumentMapillaryError = ArgumentMapillaryError;
exports.default = ArgumentMapillaryError;

},{"./MapillaryError":386}],385:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MapillaryError_1 = require("./MapillaryError");
var GraphMapillaryError = /** @class */ (function (_super) {
    __extends(GraphMapillaryError, _super);
    function GraphMapillaryError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, GraphMapillaryError.prototype);
        _this.name = "GraphMapillaryError";
        return _this;
    }
    return GraphMapillaryError;
}(MapillaryError_1.MapillaryError));
exports.GraphMapillaryError = GraphMapillaryError;
exports.default = GraphMapillaryError;

},{"./MapillaryError":386}],386:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MapillaryError = /** @class */ (function (_super) {
    __extends(MapillaryError, _super);
    function MapillaryError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, MapillaryError.prototype);
        _this.name = "MapillaryError";
        return _this;
    }
    return MapillaryError;
}(Error));
exports.MapillaryError = MapillaryError;
exports.default = MapillaryError;

},{}],387:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
/**
 * @class Camera
 *
 * @classdesc Holds information about a camera.
 */
var Camera = /** @class */ (function () {
    /**
     * Create a new camera instance.
     * @param {Transform} [transform] - Optional transform instance.
     */
    function Camera(transform) {
        if (transform != null) {
            this._position = new THREE.Vector3().fromArray(transform.unprojectSfM([0, 0], 0));
            this._lookat = new THREE.Vector3().fromArray(transform.unprojectSfM([0, 0], 10));
            this._up = transform.upVector();
            this._focal = this._getFocal(transform);
        }
        else {
            this._position = new THREE.Vector3(0, 0, 0);
            this._lookat = new THREE.Vector3(0, 0, 1);
            this._up = new THREE.Vector3(0, -1, 0);
            this._focal = 1;
        }
    }
    Object.defineProperty(Camera.prototype, "position", {
        /**
         * Get position.
         * @returns {THREE.Vector3} The position vector.
         */
        get: function () {
            return this._position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "lookat", {
        /**
         * Get lookat.
         * @returns {THREE.Vector3} The lookat vector.
         */
        get: function () {
            return this._lookat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "up", {
        /**
         * Get up.
         * @returns {THREE.Vector3} The up vector.
         */
        get: function () {
            return this._up;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "focal", {
        /**
         * Get focal.
         * @returns {number} The focal length.
         */
        get: function () {
            return this._focal;
        },
        /**
         * Set focal.
         */
        set: function (value) {
            this._focal = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Update this camera to the linearly interpolated value of two other cameras.
     *
     * @param {Camera} a - First camera.
     * @param {Camera} b - Second camera.
     * @param {number} alpha - Interpolation value on the interval [0, 1].
     */
    Camera.prototype.lerpCameras = function (a, b, alpha) {
        this._position.subVectors(b.position, a.position).multiplyScalar(alpha).add(a.position);
        this._lookat.subVectors(b.lookat, a.lookat).multiplyScalar(alpha).add(a.lookat);
        this._up.subVectors(b.up, a.up).multiplyScalar(alpha).add(a.up);
        this._focal = (1 - alpha) * a.focal + alpha * b.focal;
    };
    /**
     * Copy the properties of another camera to this camera.
     *
     * @param {Camera} other - Another camera.
     */
    Camera.prototype.copy = function (other) {
        this._position.copy(other.position);
        this._lookat.copy(other.lookat);
        this._up.copy(other.up);
        this._focal = other.focal;
    };
    /**
     * Clone this camera.
     *
     * @returns {Camera} A camera with cloned properties equal to this camera.
     */
    Camera.prototype.clone = function () {
        var camera = new Camera();
        camera.position.copy(this._position);
        camera.lookat.copy(this._lookat);
        camera.up.copy(this._up);
        camera.focal = this._focal;
        return camera;
    };
    /**
     * Determine the distance between this camera and another camera.
     *
     * @param {Camera} other - Another camera.
     * @returns {number} The distance between the cameras.
     */
    Camera.prototype.diff = function (other) {
        var pd = this._position.distanceToSquared(other.position);
        var ld = this._lookat.distanceToSquared(other.lookat);
        var ud = this._up.distanceToSquared(other.up);
        var fd = 100 * Math.abs(this._focal - other.focal);
        return Math.max(pd, ld, ud, fd);
    };
    /**
     * Get the focal length based on the transform.
     *
     * @description Returns the focal length of the transform if gpano info is not available.
     * Returns a focal length corresponding to a vertical fov clamped to [45, 90] degrees based on
     * the gpano information if available.
     *
     * @returns {number} Focal length.
     */
    Camera.prototype._getFocal = function (transform) {
        if (transform.gpano == null) {
            return transform.focal;
        }
        var vFov = Math.PI * transform.gpano.CroppedAreaImageHeightPixels / transform.gpano.FullPanoHeightPixels;
        var focal = 0.5 / Math.tan(vFov / 2);
        return Math.min(1 / (2 * (Math.sqrt(2) - 1)), Math.max(0.5, focal));
    };
    return Camera;
}());
exports.Camera = Camera;

},{"three":241}],388:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @class GeoCoords
 *
 * @classdesc Converts coordinates between the geodetic (WGS84),
 * Earth-Centered, Earth-Fixed (ECEF) and local topocentric
 * East, North, Up (ENU) reference frames.
 *
 * The WGS84 has latitude (degrees), longitude (degrees) and
 * altitude (meters) values.
 *
 * The ECEF Z-axis pierces the north pole and the
 * XY-axis defines the equatorial plane. The X-axis extends
 * from the geocenter to the intersection of the Equator and
 * the Greenwich Meridian. All values in meters.
 *
 * The WGS84 parameters are:
 *
 * a = 6378137
 * b = a * (1 - f)
 * f = 1 / 298.257223563
 * e = Math.sqrt((a^2 - b^2) / a^2)
 * e' = Math.sqrt((a^2 - b^2) / b^2)
 *
 * The WGS84 to ECEF conversion is performed using the following:
 *
 * X = (N - h) * cos(phi) * cos(lambda)
 * Y = (N + h) * cos(phi) * sin(lambda)
 * Z = (b^2 * N / a^2 + h) * sin(phi)
 *
 * where
 *
 * phi = latitude
 * lambda = longitude
 * h = height above ellipsoid (altitude)
 * N = Radius of curvature (meters)
 *   = a / Math.sqrt(1 - e^2 * sin(phi)^2)
 *
 * The ECEF to WGS84 conversion is performed using the following:
 *
 * phi = arctan((Z + e'^2 * b * sin(theta)^3) / (p - e^2 * a * cos(theta)^3))
 * lambda = arctan(Y / X)
 * h = p / cos(phi) - N
 *
 * where
 *
 * p = Math.sqrt(X^2 + Y^2)
 * theta = arctan(Z * a / p * b)
 *
 * In the ENU reference frame the x-axis points to the
 * East, the y-axis to the North and the z-axis Up. All values
 * in meters.
 *
 * The ECEF to ENU conversion is performed using the following:
 *
 * | x |   |       -sin(lambda_r)                cos(lambda_r)             0      | | X - X_r |
 * | y | = | -sin(phi_r) * cos(lambda_r)  -sin(phi_r) * sin(lambda_r)  cos(phi_r) | | Y - Y_r |
 * | z |   |  cos(phi_r) * cos(lambda_r)   cos(phi_r) * sin(lambda_r)  sin(phi_r) | | Z - Z_r |
 *
 * where
 *
 * phi_r = latitude of reference
 * lambda_r = longitude of reference
 * X_r, Y_r, Z_r = ECEF coordinates of reference
 *
 * The ENU to ECEF conversion is performed by solving the above equation for X, Y, Z.
 *
 * WGS84 to ENU and ENU to WGS84 are two step conversions with ECEF calculated in
 * the first step for both conversions.
 */
var GeoCoords = /** @class */ (function () {
    function GeoCoords() {
        this._wgs84a = 6378137.0;
        this._wgs84b = 6356752.31424518;
    }
    /**
     * Convert coordinates from geodetic (WGS84) reference to local topocentric
     * (ENU) reference.
     *
     * @param {number} lat Latitude in degrees.
     * @param {number} lon Longitude in degrees.
     * @param {number} alt Altitude in meters.
     * @param {number} refLat Reference latitude in degrees.
     * @param {number} refLon Reference longitude in degrees.
     * @param {number} refAlt Reference altitude in meters.
     * @returns {Array<number>} The x, y, z local topocentric ENU coordinates.
     */
    GeoCoords.prototype.geodeticToEnu = function (lat, lon, alt, refLat, refLon, refAlt) {
        var ecef = this.geodeticToEcef(lat, lon, alt);
        return this.ecefToEnu(ecef[0], ecef[1], ecef[2], refLat, refLon, refAlt);
    };
    /**
     * Convert coordinates from local topocentric (ENU) reference to
     * geodetic (WGS84) reference.
     *
     * @param {number} x Topocentric ENU coordinate in East direction.
     * @param {number} y Topocentric ENU coordinate in North direction.
     * @param {number} z Topocentric ENU coordinate in Up direction.
     * @param {number} refLat Reference latitude in degrees.
     * @param {number} refLon Reference longitude in degrees.
     * @param {number} refAlt Reference altitude in meters.
     * @returns {Array<number>} The latitude and longitude in degrees
     *                          as well as altitude in meters.
     */
    GeoCoords.prototype.enuToGeodetic = function (x, y, z, refLat, refLon, refAlt) {
        var ecef = this.enuToEcef(x, y, z, refLat, refLon, refAlt);
        return this.ecefToGeodetic(ecef[0], ecef[1], ecef[2]);
    };
    /**
     * Convert coordinates from Earth-Centered, Earth-Fixed (ECEF) reference
     * to local topocentric (ENU) reference.
     *
     * @param {number} X ECEF X-value.
     * @param {number} Y ECEF Y-value.
     * @param {number} Z ECEF Z-value.
     * @param {number} refLat Reference latitude in degrees.
     * @param {number} refLon Reference longitude in degrees.
     * @param {number} refAlt Reference altitude in meters.
     * @returns {Array<number>} The x, y, z topocentric ENU coordinates in East, North
     * and Up directions respectively.
     */
    GeoCoords.prototype.ecefToEnu = function (X, Y, Z, refLat, refLon, refAlt) {
        var refEcef = this.geodeticToEcef(refLat, refLon, refAlt);
        var V = [X - refEcef[0], Y - refEcef[1], Z - refEcef[2]];
        refLat = refLat * Math.PI / 180.0;
        refLon = refLon * Math.PI / 180.0;
        var cosLat = Math.cos(refLat);
        var sinLat = Math.sin(refLat);
        var cosLon = Math.cos(refLon);
        var sinLon = Math.sin(refLon);
        var x = -sinLon * V[0] + cosLon * V[1];
        var y = -sinLat * cosLon * V[0] - sinLat * sinLon * V[1] + cosLat * V[2];
        var z = cosLat * cosLon * V[0] + cosLat * sinLon * V[1] + sinLat * V[2];
        return [x, y, z];
    };
    /**
     * Convert coordinates from local topocentric (ENU) reference
     * to Earth-Centered, Earth-Fixed (ECEF) reference.
     *
     * @param {number} x Topocentric ENU coordinate in East direction.
     * @param {number} y Topocentric ENU coordinate in North direction.
     * @param {number} z Topocentric ENU coordinate in Up direction.
     * @param {number} refLat Reference latitude in degrees.
     * @param {number} refLon Reference longitude in degrees.
     * @param {number} refAlt Reference altitude in meters.
     * @returns {Array<number>} The X, Y, Z ECEF coordinates.
     */
    GeoCoords.prototype.enuToEcef = function (x, y, z, refLat, refLon, refAlt) {
        var refEcef = this.geodeticToEcef(refLat, refLon, refAlt);
        refLat = refLat * Math.PI / 180.0;
        refLon = refLon * Math.PI / 180.0;
        var cosLat = Math.cos(refLat);
        var sinLat = Math.sin(refLat);
        var cosLon = Math.cos(refLon);
        var sinLon = Math.sin(refLon);
        var X = -sinLon * x - sinLat * cosLon * y + cosLat * cosLon * z + refEcef[0];
        var Y = cosLon * x - sinLat * sinLon * y + cosLat * sinLon * z + refEcef[1];
        var Z = cosLat * y + sinLat * z + refEcef[2];
        return [X, Y, Z];
    };
    /**
     * Convert coordinates from geodetic reference (WGS84) to Earth-Centered,
     * Earth-Fixed (ECEF) reference.
     *
     * @param {number} lat Latitude in degrees.
     * @param {number} lon Longitude in degrees.
     * @param {number} alt Altitude in meters.
     * @returns {Array<number>} The X, Y, Z ECEF coordinates.
     */
    GeoCoords.prototype.geodeticToEcef = function (lat, lon, alt) {
        var a = this._wgs84a;
        var b = this._wgs84b;
        lat = lat * Math.PI / 180.0;
        lon = lon * Math.PI / 180.0;
        var cosLat = Math.cos(lat);
        var sinLat = Math.sin(lat);
        var cosLon = Math.cos(lon);
        var sinLon = Math.sin(lon);
        var a2 = a * a;
        var b2 = b * b;
        var L = 1.0 / Math.sqrt(a2 * cosLat * cosLat + b2 * sinLat * sinLat);
        var nhcl = (a2 * L + alt) * cosLat;
        var X = nhcl * cosLon;
        var Y = nhcl * sinLon;
        var Z = (b2 * L + alt) * sinLat;
        return [X, Y, Z];
    };
    /**
     * Convert coordinates from Earth-Centered, Earth-Fixed (ECEF) reference
     * to geodetic reference (WGS84).
     *
     * @param {number} X ECEF X-value.
     * @param {number} Y ECEF Y-value.
     * @param {number} Z ECEF Z-value.
     * @returns {Array<number>} The latitude and longitude in degrees
     *                          as well as altitude in meters.
     */
    GeoCoords.prototype.ecefToGeodetic = function (X, Y, Z) {
        var a = this._wgs84a;
        var b = this._wgs84b;
        var a2 = a * a;
        var b2 = b * b;
        var a2mb2 = a2 - b2;
        var ea = Math.sqrt(a2mb2 / a2);
        var eb = Math.sqrt(a2mb2 / b2);
        var p = Math.sqrt(X * X + Y * Y);
        var theta = Math.atan2(Z * a, p * b);
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta);
        var lon = Math.atan2(Y, X);
        var lat = Math.atan2(Z + eb * eb * b * sinTheta * sinTheta * sinTheta, p - ea * ea * a * cosTheta * cosTheta * cosTheta);
        var sinLat = Math.sin(lat);
        var cosLat = Math.cos(lat);
        var N = a / Math.sqrt(1 - ea * ea * sinLat * sinLat);
        var alt = p / cosLat - N;
        return [lat * 180.0 / Math.PI, lon * 180.0 / Math.PI, alt];
    };
    return GeoCoords;
}());
exports.GeoCoords = GeoCoords;
exports.default = GeoCoords;

},{}],389:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
/**
 * @class Spatial
 *
 * @classdesc Provides methods for scalar, vector and matrix calculations.
 */
var Spatial = /** @class */ (function () {
    function Spatial() {
        this._epsilon = 1e-9;
    }
    /**
     * Converts azimuthal phi rotation (counter-clockwise with origin on X-axis) to
     * bearing (clockwise with origin at north or Y-axis).
     *
     * @param {number} phi - Azimuthal phi angle in radians.
     * @returns {number} Bearing in radians.
     */
    Spatial.prototype.azimuthalToBearing = function (phi) {
        return -phi + Math.PI / 2;
    };
    /**
     * Converts degrees to radians.
     *
     * @param {number} deg - Degrees.
     * @returns {number} Radians.
     */
    Spatial.prototype.degToRad = function (deg) {
        return Math.PI * deg / 180;
    };
    /**
     * Converts radians to degrees.
     *
     * @param {number} rad - Radians.
     * @returns {number} Degrees.
     */
    Spatial.prototype.radToDeg = function (rad) {
        return 180 * rad / Math.PI;
    };
    /**
     * Creates a rotation matrix from an angle-axis vector.
     *
     * @param {Array<number>} angleAxis - Angle-axis representation of a rotation.
     * @returns {THREE.Matrix4} Rotation matrix.
     */
    Spatial.prototype.rotationMatrix = function (angleAxis) {
        var axis = new THREE.Vector3(angleAxis[0], angleAxis[1], angleAxis[2]);
        var angle = axis.length();
        if (angle > 0) {
            axis.normalize();
        }
        return new THREE.Matrix4().makeRotationAxis(axis, angle);
    };
    /**
     * Rotates a vector according to a angle-axis rotation vector.
     *
     * @param {Array<number>} vector - Vector to rotate.
     * @param {Array<number>} angleAxis - Angle-axis representation of a rotation.
     * @returns {THREE.Vector3} Rotated vector.
     */
    Spatial.prototype.rotate = function (vector, angleAxis) {
        var v = new THREE.Vector3(vector[0], vector[1], vector[2]);
        var rotationMatrix = this.rotationMatrix(angleAxis);
        v.applyMatrix4(rotationMatrix);
        return v;
    };
    /**
     * Calculates the optical center from a rotation vector
     * on the angle-axis representation and a translation vector
     * according to C = -R^T t.
     *
     * @param {Array<number>} rotation - Angle-axis representation of a rotation.
     * @param {Array<number>} translation - Translation vector.
     * @returns {THREE.Vector3} Optical center.
     */
    Spatial.prototype.opticalCenter = function (rotation, translation) {
        var angleAxis = [-rotation[0], -rotation[1], -rotation[2]];
        var vector = [-translation[0], -translation[1], -translation[2]];
        return this.rotate(vector, angleAxis);
    };
    /**
     * Calculates the viewing direction from a rotation vector
     * on the angle-axis representation.
     *
     * @param {number[]} rotation - Angle-axis representation of a rotation.
     * @returns {THREE.Vector3} Viewing direction.
     */
    Spatial.prototype.viewingDirection = function (rotation) {
        var angleAxis = [-rotation[0], -rotation[1], -rotation[2]];
        return this.rotate([0, 0, 1], angleAxis);
    };
    /**
     * Wrap a number on the interval [min, max].
     *
     * @param {number} value - Value to wrap.
     * @param {number} min - Lower endpoint of interval.
     * @param {number} max - Upper endpoint of interval.
     * @returns {number} The wrapped number.
     */
    Spatial.prototype.wrap = function (value, min, max) {
        if (max < min) {
            throw new Error("Invalid arguments: max must be larger than min.");
        }
        var interval = (max - min);
        while (value > max || value < min) {
            if (value > max) {
                value = value - interval;
            }
            else if (value < min) {
                value = value + interval;
            }
        }
        return value;
    };
    /**
     * Wrap an angle on the interval [-Pi, Pi].
     *
     * @param {number} angle - Value to wrap.
     * @returns {number} Wrapped angle.
     */
    Spatial.prototype.wrapAngle = function (angle) {
        return this.wrap(angle, -Math.PI, Math.PI);
    };
    /**
     * Limit the value to the interval [min, max] by changing the value to
     * the nearest available one when it is outside the interval.
     *
     * @param {number} value - Value to clamp.
     * @param {number} min - Minimum of the interval.
     * @param {number} max - Maximum of the interval.
     * @returns {number} Clamped value.
     */
    Spatial.prototype.clamp = function (value, min, max) {
        if (value < min) {
            return min;
        }
        if (value > max) {
            return max;
        }
        return value;
    };
    /**
     * Calculates the counter-clockwise angle from the first
     * vector (x1, y1)^T to the second (x2, y2)^T.
     *
     * @param {number} x1 - X coordinate of first vector.
     * @param {number} y1 - Y coordinate of first vector.
     * @param {number} x2 - X coordinate of second vector.
     * @param {number} y2 - Y coordinate of second vector.
     * @returns {number} Counter clockwise angle between the vectors.
     */
    Spatial.prototype.angleBetweenVector2 = function (x1, y1, x2, y2) {
        var angle = Math.atan2(y2, x2) - Math.atan2(y1, x1);
        return this.wrapAngle(angle);
    };
    /**
     * Calculates the minimum (absolute) angle change for rotation
     * from one angle to another on the [-Pi, Pi] interval.
     *
     * @param {number} angle1 - Start angle.
     * @param {number} angle2 - Destination angle.
     * @returns {number} Absolute angle change between angles.
     */
    Spatial.prototype.angleDifference = function (angle1, angle2) {
        var angle = angle2 - angle1;
        return this.wrapAngle(angle);
    };
    /**
     * Calculates the relative rotation angle between two
     * angle-axis vectors.
     *
     * @param {number} rotation1 - First angle-axis vector.
     * @param {number} rotation2 - Second angle-axis vector.
     * @returns {number} Relative rotation angle.
     */
    Spatial.prototype.relativeRotationAngle = function (rotation1, rotation2) {
        var R1T = this.rotationMatrix([-rotation1[0], -rotation1[1], -rotation1[2]]);
        var R2 = this.rotationMatrix(rotation2);
        var R = R1T.multiply(R2);
        var elements = R.elements;
        // from Tr(R) = 1 + 2*cos(theta)
        var theta = Math.acos((elements[0] + elements[5] + elements[10] - 1) / 2);
        return theta;
    };
    /**
     * Calculates the angle from a vector to a plane.
     *
     * @param {Array<number>} vector - The vector.
     * @param {Array<number>} planeNormal - Normal of the plane.
     * @returns {number} Angle from between plane and vector.
     */
    Spatial.prototype.angleToPlane = function (vector, planeNormal) {
        var v = new THREE.Vector3().fromArray(vector);
        var norm = v.length();
        if (norm < this._epsilon) {
            return 0;
        }
        var projection = v.dot(new THREE.Vector3().fromArray(planeNormal));
        return Math.asin(projection / norm);
    };
    /**
     * Calculates the distance between two coordinates
     * (latitude longitude pairs) in meters according to
     * the haversine formula.
     *
     * @param {number} lat1 - Latitude of the first coordinate in degrees.
     * @param {number} lon1 - Longitude of the first coordinate in degrees.
     * @param {number} lat2 - Latitude of the second coordinate in degrees.
     * @param {number} lon2 - Longitude of the second coordinate in degrees.
     * @returns {number} Distance between lat lon positions in meters.
     */
    Spatial.prototype.distanceFromLatLon = function (lat1, lon1, lat2, lon2) {
        var r = 6371000;
        var dLat = this.degToRad(lat2 - lat1);
        var dLon = this.degToRad(lon2 - lon1);
        var hav = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(this.degToRad(lat1)) * Math.cos(this.degToRad(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
        var d = 2 * r * Math.atan2(Math.sqrt(hav), Math.sqrt(1 - hav));
        return d;
    };
    return Spatial;
}());
exports.Spatial = Spatial;
exports.default = Spatial;

},{"three":241}],390:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
/**
 * @class Transform
 *
 * @classdesc Class used for calculating coordinate transformations
 * and projections.
 */
var Transform = /** @class */ (function () {
    /**
     * Create a new transform instance.
     * @param {Node} apiNavImIm - Node properties.
     * @param {HTMLImageElement} image - Node image.
     * @param {Array<number>} translation - Node translation vector in three dimensions.
     */
    function Transform(node, image, translation) {
        this._orientation = this._getValue(node.orientation, 1);
        var imageWidth = image != null ? image.width : 4;
        var imageHeight = image != null ? image.height : 3;
        var keepOrientation = this._orientation < 5;
        this._width = this._getValue(node.width, keepOrientation ? imageWidth : imageHeight);
        this._height = this._getValue(node.height, keepOrientation ? imageHeight : imageWidth);
        this._basicAspect = keepOrientation ?
            this._width / this._height :
            this._height / this._width;
        this._basicWidth = keepOrientation ? node.width : node.height;
        this._basicHeight = keepOrientation ? node.height : node.width;
        this._focal = this._getValue(node.focal, 1);
        this._scale = this._getValue(node.scale, 0);
        this._gpano = node.gpano != null ? node.gpano : null;
        this._rt = this._getRt(node.rotation, translation);
        this._srt = this._getSrt(this._rt, this._scale);
    }
    Object.defineProperty(Transform.prototype, "basicAspect", {
        /**
         * Get basic aspect.
         * @returns {number} The orientation adjusted aspect ratio.
         */
        get: function () {
            return this._basicAspect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "basicHeight", {
        /**
         * Get basic height.
         *
         * @description Does not fall back to node image height but
         * uses original value from API so can be faulty.
         *
         * @returns {number} The height of the basic version image
         * (adjusted for orientation).
         */
        get: function () {
            return this._basicHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "basicWidth", {
        /**
         * Get basic width.
         *
         * @description Does not fall back to node image width but
         * uses original value from API so can be faulty.
         *
         * @returns {number} The width of the basic version image
         * (adjusted for orientation).
         */
        get: function () {
            return this._basicWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "focal", {
        /**
         * Get focal.
         * @returns {number} The node focal length.
         */
        get: function () {
            return this._focal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "fullPano", {
        /**
         * Get fullPano.
         *
         * @returns {boolean} Value indicating whether the node is a complete
         * 360 panorama.
         */
        get: function () {
            return this._gpano != null &&
                this._gpano.CroppedAreaLeftPixels === 0 &&
                this._gpano.CroppedAreaTopPixels === 0 &&
                this._gpano.CroppedAreaImageWidthPixels === this._gpano.FullPanoWidthPixels &&
                this._gpano.CroppedAreaImageHeightPixels === this._gpano.FullPanoHeightPixels;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "gpano", {
        /**
         * Get gpano.
         * @returns {number} The node gpano information.
         */
        get: function () {
            return this._gpano;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "height", {
        /**
         * Get height.
         *
         * @description Falls back to the node image height if
         * the API data is faulty.
         *
         * @returns {number} The orientation adjusted image height.
         */
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "orientation", {
        /**
         * Get orientation.
         * @returns {number} The image orientation.
         */
        get: function () {
            return this._orientation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "rt", {
        /**
         * Get rt.
         * @returns {THREE.Matrix4} The extrinsic camera matrix.
         */
        get: function () {
            return this._rt;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "srt", {
        /**
         * Get srt.
         * @returns {THREE.Matrix4} The scaled extrinsic camera matrix.
         */
        get: function () {
            return this._srt;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "scale", {
        /**
         * Get scale.
         * @returns {number} The node atomic reconstruction scale.
         */
        get: function () {
            return this._scale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "hasValidScale", {
        /**
         * Get has valid scale.
         * @returns {boolean} Value indicating if the scale of the transform is valid.
         */
        get: function () {
            return this._scale > 1e-2 && this._scale < 50;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "width", {
        /**
         * Get width.
         *
         * @description Falls back to the node image width if
         * the API data is faulty.
         *
         * @returns {number} The orientation adjusted image width.
         */
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Calculate the up vector for the node transform.
     *
     * @returns {THREE.Vector3} Normalized and orientation adjusted up vector.
     */
    Transform.prototype.upVector = function () {
        var rte = this._rt.elements;
        switch (this._orientation) {
            case 1:
                return new THREE.Vector3(-rte[1], -rte[5], -rte[9]);
            case 3:
                return new THREE.Vector3(rte[1], rte[5], rte[9]);
            case 6:
                return new THREE.Vector3(-rte[0], -rte[4], -rte[8]);
            case 8:
                return new THREE.Vector3(rte[0], rte[4], rte[8]);
            default:
                return new THREE.Vector3(-rte[1], -rte[5], -rte[9]);
        }
    };
    /**
     * Calculate projector matrix for projecting 3D points to texture map
     * coordinates (u and v).
     *
     * @returns {THREE.Matrix4} Projection matrix for 3D point to texture
     * map coordinate calculations.
     */
    Transform.prototype.projectorMatrix = function () {
        var projector = this._normalizedToTextureMatrix();
        var f = this._focal;
        var projection = new THREE.Matrix4().set(f, 0, 0, 0, 0, f, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0);
        projector.multiply(projection);
        projector.multiply(this._rt);
        return projector;
    };
    /**
     * Project 3D world coordinates to basic coordinates.
     *
     * @param {Array<number>} point3d - 3D world coordinates.
     * @return {Array<number>} 2D basic coordinates.
     */
    Transform.prototype.projectBasic = function (point3d) {
        var sfm = this.projectSfM(point3d);
        return this._sfmToBasic(sfm);
    };
    /**
     * Unproject basic coordinates to 3D world coordinates.
     *
     * @param {Array<number>} basic - 2D basic coordinates.
     * @param {Array<number>} distance - Depth to unproject from camera center.
     * @returns {Array<number>} Unprojected 3D world coordinates.
     */
    Transform.prototype.unprojectBasic = function (basic, distance) {
        var sfm = this._basicToSfm(basic);
        return this.unprojectSfM(sfm, distance);
    };
    /**
     * Project 3D world coordinates to SfM coordinates.
     *
     * @param {Array<number>} point3d - 3D world coordinates.
     * @return {Array<number>} 2D SfM coordinates.
     */
    Transform.prototype.projectSfM = function (point3d) {
        var v = new THREE.Vector4(point3d[0], point3d[1], point3d[2], 1);
        v.applyMatrix4(this._rt);
        return this._bearingToSfm([v.x, v.y, v.z]);
    };
    /**
     * Unproject SfM coordinates to a 3D world coordinates.
     *
     * @param {Array<number>} sfm - 2D SfM coordinates.
     * @param {Array<number>} distance - Depth to unproject from camera center.
     * @returns {Array<number>} Unprojected 3D world coordinates.
     */
    Transform.prototype.unprojectSfM = function (sfm, distance) {
        var bearing = this._sfmToBearing(sfm);
        var v = new THREE.Vector4(distance * bearing[0], distance * bearing[1], distance * bearing[2], 1);
        v.applyMatrix4(new THREE.Matrix4().getInverse(this._rt));
        return [v.x / v.w, v.y / v.w, v.z / v.w];
    };
    /**
     * Transform SfM coordinates to bearing vector (3D cartesian
     * coordinates on the unit sphere).
     *
     * @param {Array<number>} sfm - 2D SfM coordinates.
     * @returns {Array<number>} Bearing vector (3D cartesian coordinates
     * on the unit sphere).
     */
    Transform.prototype._sfmToBearing = function (sfm) {
        if (this._fullPano()) {
            var lon = sfm[0] * 2 * Math.PI;
            var lat = -sfm[1] * 2 * Math.PI;
            var x = Math.cos(lat) * Math.sin(lon);
            var y = -Math.sin(lat);
            var z = Math.cos(lat) * Math.cos(lon);
            return [x, y, z];
        }
        else if (this._gpano) {
            var size = Math.max(this.gpano.CroppedAreaImageWidthPixels, this.gpano.CroppedAreaImageHeightPixels);
            var fullPanoPixel = [
                sfm[0] * size + this.gpano.CroppedAreaImageWidthPixels / 2 + this.gpano.CroppedAreaLeftPixels,
                sfm[1] * size + this.gpano.CroppedAreaImageHeightPixels / 2 + this.gpano.CroppedAreaTopPixels,
            ];
            var lon = 2 * Math.PI * (fullPanoPixel[0] / this.gpano.FullPanoWidthPixels - 0.5);
            var lat = -Math.PI * (fullPanoPixel[1] / this.gpano.FullPanoHeightPixels - 0.5);
            var x = Math.cos(lat) * Math.sin(lon);
            var y = -Math.sin(lat);
            var z = Math.cos(lat) * Math.cos(lon);
            return [x, y, z];
        }
        else {
            var v = new THREE.Vector3(sfm[0], sfm[1], this._focal);
            v.normalize();
            return [v.x, v.y, v.z];
        }
    };
    /**
     * Transform bearing vector (3D cartesian coordiantes on the unit sphere) to
     * SfM coordinates.
     *
     * @param {Array<number>} bearing - Bearing vector (3D cartesian coordinates on the
     * unit sphere).
     * @returns {Array<number>} 2D SfM coordinates.
     */
    Transform.prototype._bearingToSfm = function (bearing) {
        if (this._fullPano()) {
            var x = bearing[0];
            var y = bearing[1];
            var z = bearing[2];
            var lon = Math.atan2(x, z);
            var lat = Math.atan2(-y, Math.sqrt(x * x + z * z));
            return [lon / (2 * Math.PI), -lat / (2 * Math.PI)];
        }
        else if (this._gpano) {
            var x = bearing[0];
            var y = bearing[1];
            var z = bearing[2];
            var lon = Math.atan2(x, z);
            var lat = Math.atan2(-y, Math.sqrt(x * x + z * z));
            var fullPanoPixel = [
                (lon / (2 * Math.PI) + 0.5) * this.gpano.FullPanoWidthPixels,
                (-lat / Math.PI + 0.5) * this.gpano.FullPanoHeightPixels,
            ];
            var size = Math.max(this.gpano.CroppedAreaImageWidthPixels, this.gpano.CroppedAreaImageHeightPixels);
            return [
                (fullPanoPixel[0] - this.gpano.CroppedAreaLeftPixels - this.gpano.CroppedAreaImageWidthPixels / 2) / size,
                (fullPanoPixel[1] - this.gpano.CroppedAreaTopPixels - this.gpano.CroppedAreaImageHeightPixels / 2) / size,
            ];
        }
        else {
            if (bearing[2] > 0) {
                return [
                    bearing[0] * this._focal / bearing[2],
                    bearing[1] * this._focal / bearing[2],
                ];
            }
            else {
                return [
                    bearing[0] < 0 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
                    bearing[1] < 0 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
                ];
            }
        }
    };
    /**
     * Convert basic coordinates to SfM coordinates.
     *
     * @param {Array<number>} basic - 2D basic coordinates.
     * @returns {Array<number>} 2D SfM coordinates.
     */
    Transform.prototype._basicToSfm = function (basic) {
        var rotatedX;
        var rotatedY;
        switch (this._orientation) {
            case 1:
                rotatedX = basic[0];
                rotatedY = basic[1];
                break;
            case 3:
                rotatedX = 1 - basic[0];
                rotatedY = 1 - basic[1];
                break;
            case 6:
                rotatedX = basic[1];
                rotatedY = 1 - basic[0];
                break;
            case 8:
                rotatedX = 1 - basic[1];
                rotatedY = basic[0];
                break;
            default:
                rotatedX = basic[0];
                rotatedY = basic[1];
                break;
        }
        var w = this._width;
        var h = this._height;
        var s = Math.max(w, h);
        var sfmX = rotatedX * w / s - w / s / 2;
        var sfmY = rotatedY * h / s - h / s / 2;
        return [sfmX, sfmY];
    };
    /**
     * Convert SfM coordinates to basic coordinates.
     *
     * @param {Array<number>} sfm - 2D SfM coordinates.
     * @returns {Array<number>} 2D basic coordinates.
     */
    Transform.prototype._sfmToBasic = function (sfm) {
        var w = this._width;
        var h = this._height;
        var s = Math.max(w, h);
        var rotatedX = (sfm[0] + w / s / 2) / w * s;
        var rotatedY = (sfm[1] + h / s / 2) / h * s;
        var basicX;
        var basicY;
        switch (this._orientation) {
            case 1:
                basicX = rotatedX;
                basicY = rotatedY;
                break;
            case 3:
                basicX = 1 - rotatedX;
                basicY = 1 - rotatedY;
                break;
            case 6:
                basicX = 1 - rotatedY;
                basicY = rotatedX;
                break;
            case 8:
                basicX = rotatedY;
                basicY = 1 - rotatedX;
                break;
            default:
                basicX = rotatedX;
                basicY = rotatedY;
                break;
        }
        return [basicX, basicY];
    };
    /**
     * Determines if the gpano information indicates a full panorama.
     *
     * @returns {boolean} Value determining if the gpano information indicates
     * a full panorama.
     */
    Transform.prototype._fullPano = function () {
        return this.gpano != null &&
            this.gpano.CroppedAreaLeftPixels === 0 &&
            this.gpano.CroppedAreaTopPixels === 0 &&
            this.gpano.CroppedAreaImageWidthPixels === this.gpano.FullPanoWidthPixels &&
            this.gpano.CroppedAreaImageHeightPixels === this.gpano.FullPanoHeightPixels;
    };
    /**
     * Checks a value and returns it if it exists and is larger than 0.
     * Fallbacks if it is null.
     *
     * @param {number} value - Value to check.
     * @param {number} fallback - Value to fall back to.
     * @returns {number} The value or its fallback value if it is not defined or negative.
     */
    Transform.prototype._getValue = function (value, fallback) {
        return value != null && value > 0 ? value : fallback;
    };
    /**
     * Creates the extrinsic camera matrix [ R | t ].
     *
     * @param {Array<number>} rotation - Rotation vector in angle axis representation.
     * @param {Array<number>} translation - Translation vector.
     * @returns {THREE.Matrix4} Extrisic camera matrix.
     */
    Transform.prototype._getRt = function (rotation, translation) {
        var axis = new THREE.Vector3(rotation[0], rotation[1], rotation[2]);
        var angle = axis.length();
        if (angle > 0) {
            axis.normalize();
        }
        var rt = new THREE.Matrix4();
        rt.makeRotationAxis(axis, angle);
        rt.setPosition(new THREE.Vector3(translation[0], translation[1], translation[2]));
        return rt;
    };
    /**
     * Calculates the scaled extrinsic camera matrix scale * [ R | t ].
     *
     * @param {THREE.Matrix4} rt - Extrisic camera matrix.
     * @param {number} scale - Scale factor.
     * @returns {THREE.Matrix4} Scaled extrisic camera matrix.
     */
    Transform.prototype._getSrt = function (rt, scale) {
        var srt = rt.clone();
        var elements = srt.elements;
        elements[12] = scale * elements[12];
        elements[13] = scale * elements[13];
        elements[14] = scale * elements[14];
        srt.scale(new THREE.Vector3(scale, scale, scale));
        return srt;
    };
    /**
     * Calculate a transformation matrix from normalized coordinates for
     * texture map coordinates.
     *
     * @returns {THREE.Matrix4} Normalized coordinates to texture map
     * coordinates transformation matrix.
     */
    Transform.prototype._normalizedToTextureMatrix = function () {
        var size = Math.max(this._width, this._height);
        var w = size / this._width;
        var h = size / this._height;
        switch (this._orientation) {
            case 1:
                return new THREE.Matrix4().set(w, 0, 0, 0.5, 0, -h, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1);
            case 3:
                return new THREE.Matrix4().set(-w, 0, 0, 0.5, 0, h, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1);
            case 6:
                return new THREE.Matrix4().set(0, -h, 0, 0.5, -w, 0, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1);
            case 8:
                return new THREE.Matrix4().set(0, h, 0, 0.5, w, 0, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1);
            default:
                return new THREE.Matrix4().set(w, 0, 0, 0.5, 0, -h, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1);
        }
    };
    return Transform;
}());
exports.Transform = Transform;

},{"three":241}],391:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
/**
 * @class ViewportCoords
 *
 * @classdesc Provides methods for calculating 2D coordinate conversions
 * as well as 3D projection and unprojection.
 *
 * Basic coordinates are 2D coordinates on the [0, 1] interval and
 * have the origin point, (0, 0), at the top left corner and the
 * maximum value, (1, 1), at the bottom right corner of the original
 * image.
 *
 * Viewport coordinates are 2D coordinates on the [-1, 1] interval and
 * have the origin point in the center. The bottom left corner point is
 * (-1, -1) and the top right corner point is (1, 1).
 *
 * Canvas coordiantes are 2D pixel coordinates on the [0, canvasWidth] and
 * [0, canvasHeight] intervals. The origin point (0, 0) is in the top left
 * corner and the maximum value is (canvasWidth, canvasHeight) is in the
 * bottom right corner.
 *
 * 3D coordinates are in the topocentric world reference frame.
 */
var ViewportCoords = /** @class */ (function () {
    function ViewportCoords() {
        this._unprojectDepth = 200;
    }
    /**
     * Convert basic coordinates to canvas coordinates.
     *
     * @description Transform origin and camera position needs to be the
     * equal for reliable return value.
     *
     * @param {number} basicX - Basic X coordinate.
     * @param {number} basicY - Basic Y coordinate.
     * @param {HTMLElement} container - The viewer container.
     * @param {Transform} transform - Transform of the node to unproject from.
     * @param {THREE.Camera} camera - Camera used in rendering.
     * @returns {Array<number>} 2D canvas coordinates.
     */
    ViewportCoords.prototype.basicToCanvas = function (basicX, basicY, container, transform, camera) {
        var point3d = transform.unprojectBasic([basicX, basicY], this._unprojectDepth);
        var canvas = this.projectToCanvas(point3d, container, camera);
        return canvas;
    };
    /**
     * Convert basic coordinates to canvas coordinates safely. If 3D point is
     * behind camera null will be returned.
     *
     * @description Transform origin and camera position needs to be the
     * equal for reliable return value.
     *
     * @param {number} basicX - Basic X coordinate.
     * @param {number} basicY - Basic Y coordinate.
     * @param {HTMLElement} container - The viewer container.
     * @param {Transform} transform - Transform of the node to unproject from.
     * @param {THREE.Camera} camera - Camera used in rendering.
     * @returns {Array<number>} 2D canvas coordinates if the basic point represents a 3D point
     * in front of the camera, otherwise null.
     */
    ViewportCoords.prototype.basicToCanvasSafe = function (basicX, basicY, container, transform, camera) {
        var point3d = transform.unprojectBasic([basicX, basicY], this._unprojectDepth);
        var pointCamera = this.worldToCamera(point3d, camera);
        if (pointCamera[2] > 0) {
            return null;
        }
        var _a = this.cameraToViewport(pointCamera, camera), viewportX = _a[0], viewportY = _a[1];
        var canvas = this.viewportToCanvas(viewportX, viewportY, container);
        return canvas;
    };
    /**
     * Convert basic coordinates to viewport coordinates.
     *
     * @description Transform origin and camera position needs to be the
     * equal for reliable return value.
     *
     * @param {number} basicX - Basic X coordinate.
     * @param {number} basicY - Basic Y coordinate.
     * @param {Transform} transform - Transform of the node to unproject from.
     * @param {THREE.Camera} camera - Camera used in rendering.
     * @returns {Array<number>} 2D viewport coordinates.
     */
    ViewportCoords.prototype.basicToViewport = function (basicX, basicY, transform, camera) {
        var point3d = transform.unprojectBasic([basicX, basicY], this._unprojectDepth);
        var viewport = this.projectToViewport(point3d, camera);
        return viewport;
    };
    /**
     * Convert camera 3D coordinates to viewport coordinates.
     *
     * @param {number} pointCamera - 3D point in camera coordinate system.
     * @param {THREE.Camera} camera - Camera used in rendering.
     * @returns {Array<number>} 2D viewport coordinates.
     */
    ViewportCoords.prototype.cameraToViewport = function (pointCamera, camera) {
        var viewport = new THREE.Vector3().fromArray(pointCamera)
            .applyMatrix4(camera.projectionMatrix);
        return [viewport.x, viewport.y];
    };
    /**
     * Get canvas pixel position from event.
     *
     * @param {Event} event - Event containing clientX and clientY properties.
     * @param {HTMLElement} element - HTML element.
     * @returns {Array<number>} 2D canvas coordinates.
     */
    ViewportCoords.prototype.canvasPosition = function (event, element) {
        var clientRect = element.getBoundingClientRect();
        var canvasX = event.clientX - clientRect.left - element.clientLeft;
        var canvasY = event.clientY - clientRect.top - element.clientTop;
        return [canvasX, canvasY];
    };
    /**
     * Convert canvas coordinates to basic coordinates.
     *
     * @description Transform origin and camera position needs to be the
     * equal for reliable return value.
     *
     * @param {number} canvasX - Canvas X coordinate.
     * @param {number} canvasY - Canvas Y coordinate.
     * @param {HTMLElement} container - The viewer container.
     * @param {Transform} transform - Transform of the node to unproject from.
     * @param {THREE.Camera} camera - Camera used in rendering.
     * @returns {Array<number>} 2D basic coordinates.
     */
    ViewportCoords.prototype.canvasToBasic = function (canvasX, canvasY, container, transform, camera) {
        var point3d = this.unprojectFromCanvas(canvasX, canvasY, container, camera)
            .toArray();
        var basic = transform.projectBasic(point3d);
        return basic;
    };
    /**
     * Convert canvas coordinates to viewport coordinates.
     *
     * @param {number} canvasX - Canvas X coordinate.
     * @param {number} canvasY - Canvas Y coordinate.
     * @param {HTMLElement} container - The viewer container.
     * @returns {Array<number>} 2D viewport coordinates.
     */
    ViewportCoords.prototype.canvasToViewport = function (canvasX, canvasY, container) {
        var _a = this.containerToCanvas(container), canvasWidth = _a[0], canvasHeight = _a[1];
        var viewportX = 2 * canvasX / canvasWidth - 1;
        var viewportY = 1 - 2 * canvasY / canvasHeight;
        return [viewportX, viewportY];
    };
    /**
     * Determines the width and height of the container in canvas coordinates.
     *
     * @param {HTMLElement} container - The viewer container.
     * @returns {Array<number>} 2D canvas coordinates.
     */
    ViewportCoords.prototype.containerToCanvas = function (container) {
        return [container.offsetWidth, container.offsetHeight];
    };
    /**
     * Determine basic distances from image to canvas corners.
     *
     * @description Transform origin and camera position needs to be the
     * equal for reliable return value.
     *
     * Determines the smallest basic distance for every side of the canvas.
     *
     * @param {Transform} transform - Transform of the node to unproject from.
     * @param {THREE.Camera} camera - Camera used in rendering.
     * @returns {Array<number>} Array of basic distances as [top, right, bottom, left].
     */
    ViewportCoords.prototype.getBasicDistances = function (transform, camera) {
        var topLeftBasic = this.viewportToBasic(-1, 1, transform, camera);
        var topRightBasic = this.viewportToBasic(1, 1, transform, camera);
        var bottomRightBasic = this.viewportToBasic(1, -1, transform, camera);
        var bottomLeftBasic = this.viewportToBasic(-1, -1, transform, camera);
        var topBasicDistance = 0;
        var rightBasicDistance = 0;
        var bottomBasicDistance = 0;
        var leftBasicDistance = 0;
        if (topLeftBasic[1] < 0 && topRightBasic[1] < 0) {
            topBasicDistance = topLeftBasic[1] > topRightBasic[1] ?
                -topLeftBasic[1] :
                -topRightBasic[1];
        }
        if (topRightBasic[0] > 1 && bottomRightBasic[0] > 1) {
            rightBasicDistance = topRightBasic[0] < bottomRightBasic[0] ?
                topRightBasic[0] - 1 :
                bottomRightBasic[0] - 1;
        }
        if (bottomRightBasic[1] > 1 && bottomLeftBasic[1] > 1) {
            bottomBasicDistance = bottomRightBasic[1] < bottomLeftBasic[1] ?
                bottomRightBasic[1] - 1 :
                bottomLeftBasic[1] - 1;
        }
        if (bottomLeftBasic[0] < 0 && topLeftBasic[0] < 0) {
            leftBasicDistance = bottomLeftBasic[0] > topLeftBasic[0] ?
                -bottomLeftBasic[0] :
                -topLeftBasic[0];
        }
        return [topBasicDistance, rightBasicDistance, bottomBasicDistance, leftBasicDistance];
    };
    /**
     * Determine pixel distances from image to canvas corners.
     *
     * @description Transform origin and camera position needs to be the
     * equal for reliable return value.
     *
     * Determines the smallest pixel distance for every side of the canvas.
     *
     * @param {HTMLElement} container - The viewer container.
     * @param {Transform} transform - Transform of the node to unproject from.
     * @param {THREE.Camera} camera - Camera used in rendering.
     * @returns {Array<number>} Array of pixel distances as [top, right, bottom, left].
     */
    ViewportCoords.prototype.getPixelDistances = function (container, transform, camera) {
        var topLeftBasic = this.viewportToBasic(-1, 1, transform, camera);
        var topRightBasic = this.viewportToBasic(1, 1, transform, camera);
        var bottomRightBasic = this.viewportToBasic(1, -1, transform, camera);
        var bottomLeftBasic = this.viewportToBasic(-1, -1, transform, camera);
        var topPixelDistance = 0;
        var rightPixelDistance = 0;
        var bottomPixelDistance = 0;
        var leftPixelDistance = 0;
        var _a = this.containerToCanvas(container), canvasWidth = _a[0], canvasHeight = _a[1];
        if (topLeftBasic[1] < 0 && topRightBasic[1] < 0) {
            var basicX = topLeftBasic[1] > topRightBasic[1] ?
                topLeftBasic[0] :
                topRightBasic[0];
            var canvas = this.basicToCanvas(basicX, 0, container, transform, camera);
            topPixelDistance = canvas[1] > 0 ? canvas[1] : 0;
        }
        if (topRightBasic[0] > 1 && bottomRightBasic[0] > 1) {
            var basicY = topRightBasic[0] < bottomRightBasic[0] ?
                topRightBasic[1] :
                bottomRightBasic[1];
            var canvas = this.basicToCanvas(1, basicY, container, transform, camera);
            rightPixelDistance = canvas[0] < canvasWidth ? canvasWidth - canvas[0] : 0;
        }
        if (bottomRightBasic[1] > 1 && bottomLeftBasic[1] > 1) {
            var basicX = bottomRightBasic[1] < bottomLeftBasic[1] ?
                bottomRightBasic[0] :
                bottomLeftBasic[0];
            var canvas = this.basicToCanvas(basicX, 1, container, transform, camera);
            bottomPixelDistance = canvas[1] < canvasHeight ? canvasHeight - canvas[1] : 0;
        }
        if (bottomLeftBasic[0] < 0 && topLeftBasic[0] < 0) {
            var basicY = bottomLeftBasic[0] > topLeftBasic[0] ?
                bottomLeftBasic[1] :
                topLeftBasic[1];
            var canvas = this.basicToCanvas(0, basicY, container, transform, camera);
            leftPixelDistance = canvas[0] > 0 ? canvas[0] : 0;
        }
        return [topPixelDistance, rightPixelDistance, bottomPixelDistance, leftPixelDistance];
    };
    /**
     * Determine if an event occured inside an element.
     *
     * @param {Event} event - Event containing clientX and clientY properties.
     * @param {HTMLElement} element - HTML element.
     * @returns {boolean} Value indicating if the event occured inside the element or not.
     */
    ViewportCoords.prototype.insideElement = function (event, element) {
        var clientRect = element.getBoundingClientRect();
        var minX = clientRect.left + element.clientLeft;
        var maxX = minX + element.clientWidth;
        var minY = clientRect.top + element.clientTop;
        var maxY = minY + element.clientHeight;
        return event.clientX > minX &&
            event.clientX < maxX &&
            event.clientY > minY &&
            event.clientY < maxY;
    };
    /**
     * Project 3D world coordinates to canvas coordinates.
     *
     * @param {Array<number>} point3D - 3D world coordinates.
     * @param {HTMLElement} container - The viewer container.
     * @param {THREE.Camera} camera - Camera used in rendering.
     * @returns {Array<number>} 2D canvas coordinates.
     */
    ViewportCoords.prototype.projectToCanvas = function (point3d, container, camera) {
        var viewport = this.projectToViewport(point3d, camera);
        var canvas = this.viewportToCanvas(viewport[0], viewport[1], container);
        return canvas;
    };
    /**
     * Project 3D world coordinates to viewport coordinates.
     *
     * @param {Array<number>} point3D - 3D world coordinates.
     * @param {THREE.Camera} camera - Camera used in rendering.
     * @returns {Array<number>} 2D viewport coordinates.
     */
    ViewportCoords.prototype.projectToViewport = function (point3d, camera) {
        var viewport = new THREE.Vector3(point3d[0], point3d[1], point3d[2])
            .project(camera);
        return [viewport.x, viewport.y];
    };
    /**
     * Uproject canvas coordinates to 3D world coordinates.
     *
     * @param {number} canvasX - Canvas X coordinate.
     * @param {number} canvasY - Canvas Y coordinate.
     * @param {HTMLElement} container - The viewer container.
     * @param {THREE.Camera} camera - Camera used in rendering.
     * @returns {Array<number>} 3D world coordinates.
     */
    ViewportCoords.prototype.unprojectFromCanvas = function (canvasX, canvasY, container, camera) {
        var viewport = this.canvasToViewport(canvasX, canvasY, container);
        var point3d = this.unprojectFromViewport(viewport[0], viewport[1], camera);
        return point3d;
    };
    /**
     * Unproject viewport coordinates to 3D world coordinates.
     *
     * @param {number} viewportX - Viewport X coordinate.
     * @param {number} viewportY - Viewport Y coordinate.
     * @param {THREE.Camera} camera - Camera used in rendering.
     * @returns {Array<number>} 3D world coordinates.
     */
    ViewportCoords.prototype.unprojectFromViewport = function (viewportX, viewportY, camera) {
        var point3d = new THREE.Vector3(viewportX, viewportY, 1)
            .unproject(camera);
        return point3d;
    };
    /**
     * Convert viewport coordinates to basic coordinates.
     *
     * @description Transform origin and camera position needs to be the
     * equal for reliable return value.
     *
     * @param {number} viewportX - Viewport X coordinate.
     * @param {number} viewportY - Viewport Y coordinate.
     * @param {Transform} transform - Transform of the node to unproject from.
     * @param {THREE.Camera} camera - Camera used in rendering.
     * @returns {Array<number>} 2D basic coordinates.
     */
    ViewportCoords.prototype.viewportToBasic = function (viewportX, viewportY, transform, camera) {
        var point3d = new THREE.Vector3(viewportX, viewportY, 1)
            .unproject(camera)
            .toArray();
        var basic = transform.projectBasic(point3d);
        return basic;
    };
    /**
     * Convert viewport coordinates to canvas coordinates.
     *
     * @param {number} viewportX - Viewport X coordinate.
     * @param {number} viewportY - Viewport Y coordinate.
     * @param {HTMLElement} container - The viewer container.
     * @returns {Array<number>} 2D canvas coordinates.
     */
    ViewportCoords.prototype.viewportToCanvas = function (viewportX, viewportY, container) {
        var _a = this.containerToCanvas(container), canvasWidth = _a[0], canvasHeight = _a[1];
        var canvasX = canvasWidth * (viewportX + 1) / 2;
        var canvasY = -canvasHeight * (viewportY - 1) / 2;
        return [canvasX, canvasY];
    };
    /**
     * Convert 3D world coordinates to 3D camera coordinates.
     *
     * @param {number} point3D - 3D point in world coordinate system.
     * @param {THREE.Camera} camera - Camera used in rendering.
     * @returns {Array<number>} 3D camera coordinates.
     */
    ViewportCoords.prototype.worldToCamera = function (point3d, camera) {
        var pointCamera = new THREE.Vector3(point3d[0], point3d[1], point3d[2])
            .applyMatrix4(camera.matrixWorldInverse);
        return pointCamera.toArray();
    };
    return ViewportCoords;
}());
exports.ViewportCoords = ViewportCoords;
exports.default = ViewportCoords;

},{"three":241}],392:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @class Filter
 *
 * @classdesc Represents a class for creating node filters. Implementation and
 * definitions based on https://github.com/mapbox/feature-filter.
 */
var FilterCreator = /** @class */ (function () {
    function FilterCreator() {
    }
    /**
     * Create a filter from a filter expression.
     *
     * @description The following filters are supported:
     *
     * Comparison
     * `==`
     * `!=`
     * `<`
     * `<=`
     * `>`
     * `>=`
     *
     * Set membership
     * `in`
     * `!in`
     *
     * Combining
     * `all`
     *
     * @param {FilterExpression} filter - Comparison, set membership or combinding filter
     * expression.
     * @returns {FilterFunction} Function taking a node and returning a boolean that
     * indicates whether the node passed the test or not.
     */
    FilterCreator.prototype.createFilter = function (filter) {
        return new Function("node", "return " + this._compile(filter) + ";");
    };
    FilterCreator.prototype._compile = function (filter) {
        if (filter == null || filter.length <= 1) {
            return "true";
        }
        var operator = filter[0];
        var operation = operator === "==" ? this._compileComparisonOp("===", filter[1], filter[2], false) :
            operator === "!=" ? this._compileComparisonOp("!==", filter[1], filter[2], false) :
                operator === ">" ||
                    operator === ">=" ||
                    operator === "<" ||
                    operator === "<=" ? this._compileComparisonOp(operator, filter[1], filter[2], true) :
                    operator === "in" ?
                        this._compileInOp(filter[1], filter.slice(2)) :
                        operator === "!in" ?
                            this._compileNegation(this._compileInOp(filter[1], filter.slice(2))) :
                            operator === "all" ? this._compileLogicalOp(filter.slice(1), "&&") :
                                "true";
        return "(" + operation + ")";
    };
    FilterCreator.prototype._compare = function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    };
    FilterCreator.prototype._compileComparisonOp = function (operator, property, value, checkType) {
        var left = this._compilePropertyReference(property);
        var right = JSON.stringify(value);
        return (checkType ? "typeof " + left + "===typeof " + right + "&&" : "") + left + operator + right;
    };
    FilterCreator.prototype._compileInOp = function (property, values) {
        var compare = this._compare;
        var left = JSON.stringify(values.sort(compare));
        var right = this._compilePropertyReference(property);
        return left + ".indexOf(" + right + ")!==-1";
    };
    FilterCreator.prototype._compileLogicalOp = function (filters, operator) {
        var compile = this._compile.bind(this);
        return filters.map(compile).join(operator);
    };
    FilterCreator.prototype._compileNegation = function (expression) {
        return "!(" + expression + ")";
    };
    FilterCreator.prototype._compilePropertyReference = function (property) {
        return "node[" + JSON.stringify(property) + "]";
    };
    return FilterCreator;
}());
exports.FilterCreator = FilterCreator;
exports.default = FilterCreator;

},{}],393:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var rbush = require("rbush");
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/observable/from");
require("rxjs/add/operator/catch");
require("rxjs/add/operator/do");
require("rxjs/add/operator/finally");
require("rxjs/add/operator/last");
require("rxjs/add/operator/map");
require("rxjs/add/operator/publish");
require("rxjs/add/operator/reduce");
var Edge_1 = require("../Edge");
var Error_1 = require("../Error");
var Graph_1 = require("../Graph");
/**
 * @class Graph
 *
 * @classdesc Represents a graph of nodes with edges.
 */
var Graph = /** @class */ (function () {
    /**
     * Create a new graph instance.
     *
     * @param {APIv3} [apiV3] - API instance for retrieving data.
     * @param {rbush.RBush<NodeIndexItem>} [nodeIndex] - Node index for fast spatial retreival.
     * @param {GraphCalculator} [graphCalculator] - Instance for graph calculations.
     * @param {EdgeCalculator} [edgeCalculator] - Instance for edge calculations.
     * @param {FilterCreator} [filterCreator] - Instance for  filter creation.
     * @param {IGraphConfiguration} [configuration] - Configuration struct.
     */
    function Graph(apiV3, nodeIndex, graphCalculator, edgeCalculator, filterCreator, configuration) {
        this._apiV3 = apiV3;
        this._cachedNodes = {};
        this._cachedNodeTiles = {};
        this._cachedSequenceNodes = {};
        this._cachedSpatialEdges = {};
        this._cachedTiles = {};
        this._cachingFill$ = {};
        this._cachingFull$ = {};
        this._cachingSequenceNodes$ = {};
        this._cachingSequences$ = {};
        this._cachingSpatialArea$ = {};
        this._cachingTiles$ = {};
        this._changed$ = new Subject_1.Subject();
        this._defaultAlt = 2;
        this._edgeCalculator = edgeCalculator != null ? edgeCalculator : new Edge_1.EdgeCalculator();
        this._filterCreator = filterCreator != null ? filterCreator : new Graph_1.FilterCreator();
        this._filter = this._filterCreator.createFilter(undefined);
        this._graphCalculator = graphCalculator != null ? graphCalculator : new Graph_1.GraphCalculator();
        this._configuration = configuration != null ?
            configuration :
            {
                maxSequences: 50,
                maxUnusedNodes: 100,
                maxUnusedPreStoredNodes: 30,
                maxUnusedTiles: 20,
            };
        this._nodes = {};
        this._nodeIndex = nodeIndex != null ? nodeIndex : rbush(16, [".lat", ".lon", ".lat", ".lon"]);
        this._nodeIndexTiles = {};
        this._nodeToTile = {};
        this._preStored = {};
        this._requiredNodeTiles = {};
        this._requiredSpatialArea = {};
        this._sequences = {};
        this._tilePrecision = 7;
        this._tileThreshold = 20;
    }
    Object.defineProperty(Graph.prototype, "changed$", {
        /**
         * Get changed$.
         *
         * @returns {Observable<Graph>} Observable emitting
         * the graph every time it has changed.
         */
        get: function () {
            return this._changed$;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Caches the full node data for all images within a bounding
     * box.
     *
     * @description The node assets are not cached.
     *
     * @param {ILatLon} sw - South west corner of bounding box.
     * @param {ILatLon} ne - North east corner of bounding box.
     * @returns {Observable<Graph>} Observable emitting the full
     * nodes in the bounding box.
     */
    Graph.prototype.cacheBoundingBox$ = function (sw, ne) {
        var _this = this;
        var cacheTiles$ = this._graphCalculator.encodeHsFromBoundingBox(sw, ne)
            .filter(function (h) {
            return !(h in _this._cachedTiles);
        })
            .map(function (h) {
            return h in _this._cachingTiles$ ?
                _this._cachingTiles$[h] :
                _this._cacheTile$(h);
        });
        if (cacheTiles$.length === 0) {
            cacheTiles$.push(Observable_1.Observable.of(this));
        }
        return Observable_1.Observable
            .from(cacheTiles$)
            .mergeAll()
            .last()
            .mergeMap(function (graph) {
            var nodes = _this._nodeIndex
                .search({
                maxX: ne.lat,
                maxY: ne.lon,
                minX: sw.lat,
                minY: sw.lon,
            })
                .map(function (item) {
                return item.node;
            });
            var fullNodes = [];
            var coreNodes = [];
            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                var node = nodes_1[_i];
                if (node.full) {
                    fullNodes.push(node);
                }
                else {
                    coreNodes.push(node.key);
                }
            }
            var coreNodeBatches = [];
            var batchSize = 200;
            while (coreNodes.length > 0) {
                coreNodeBatches.push(coreNodes.splice(0, batchSize));
            }
            var fullNodes$ = Observable_1.Observable.of(fullNodes);
            var fillNodes$ = coreNodeBatches
                .map(function (batch) {
                return _this._apiV3.imageByKeyFill$(batch)
                    .map(function (imageByKeyFill) {
                    var filledNodes = [];
                    for (var fillKey in imageByKeyFill) {
                        if (!imageByKeyFill.hasOwnProperty(fillKey)) {
                            continue;
                        }
                        if (_this.hasNode(fillKey)) {
                            var node = _this.getNode(fillKey);
                            if (!node.full) {
                                _this._makeFull(node, imageByKeyFill[fillKey]);
                            }
                            filledNodes.push(node);
                        }
                    }
                    return filledNodes;
                });
            });
            return Observable_1.Observable
                .merge(fullNodes$, Observable_1.Observable
                .from(fillNodes$)
                .mergeAll());
        })
            .reduce(function (acc, value) {
            return acc.concat(value);
        });
    };
    /**
     * Retrieve and cache node fill properties.
     *
     * @param {string} key - Key of node to fill.
     * @returns {Observable<Graph>} Observable emitting the graph
     * when the node has been updated.
     * @throws {GraphMapillaryError} When the operation is not valid on the
     * current graph.
     */
    Graph.prototype.cacheFill$ = function (key) {
        var _this = this;
        if (key in this._cachingFull$) {
            throw new Error_1.GraphMapillaryError("Cannot fill node while caching full (" + key + ").");
        }
        if (!this.hasNode(key)) {
            throw new Error_1.GraphMapillaryError("Cannot fill node that does not exist in graph (" + key + ").");
        }
        if (key in this._cachingFill$) {
            return this._cachingFill$[key];
        }
        var node = this.getNode(key);
        if (node.full) {
            throw new Error_1.GraphMapillaryError("Cannot fill node that is already full (" + key + ").");
        }
        this._cachingFill$[key] = this._apiV3.imageByKeyFill$([key])
            .do(function (imageByKeyFill) {
            if (!node.full) {
                _this._makeFull(node, imageByKeyFill[key]);
            }
            delete _this._cachingFill$[key];
        })
            .map(function (imageByKeyFill) {
            return _this;
        })
            .finally(function () {
            if (key in _this._cachingFill$) {
                delete _this._cachingFill$[key];
            }
            _this._changed$.next(_this);
        })
            .publish()
            .refCount();
        return this._cachingFill$[key];
    };
    /**
     * Retrieve and cache full node properties.
     *
     * @param {string} key - Key of node to fill.
     * @returns {Observable<Graph>} Observable emitting the graph
     * when the node has been updated.
     * @throws {GraphMapillaryError} When the operation is not valid on the
     * current graph.
     */
    Graph.prototype.cacheFull$ = function (key) {
        var _this = this;
        if (key in this._cachingFull$) {
            return this._cachingFull$[key];
        }
        if (this.hasNode(key)) {
            throw new Error_1.GraphMapillaryError("Cannot cache full node that already exist in graph (" + key + ").");
        }
        this._cachingFull$[key] = this._apiV3.imageByKeyFull$([key])
            .do(function (imageByKeyFull) {
            var fn = imageByKeyFull[key];
            if (_this.hasNode(key)) {
                var node = _this.getNode(key);
                if (!node.full) {
                    _this._makeFull(node, fn);
                }
            }
            else {
                if (fn.sequence_key == null) {
                    throw new Error_1.GraphMapillaryError("Node has no sequence key (" + key + ").");
                }
                var node = new Graph_1.Node(fn);
                _this._makeFull(node, fn);
                var h = _this._graphCalculator.encodeH(node.originalLatLon, _this._tilePrecision);
                _this._preStore(h, node);
                _this._setNode(node);
                delete _this._cachingFull$[key];
            }
        })
            .map(function (imageByKeyFull) {
            return _this;
        })
            .finally(function () {
            if (key in _this._cachingFull$) {
                delete _this._cachingFull$[key];
            }
            _this._changed$.next(_this);
        })
            .publish()
            .refCount();
        return this._cachingFull$[key];
    };
    /**
     * Retrieve and cache a node sequence.
     *
     * @param {string} key - Key of node for which to retrieve sequence.
     * @returns {Observable<Graph>} Observable emitting the graph
     * when the sequence has been retrieved.
     * @throws {GraphMapillaryError} When the operation is not valid on the
     * current graph.
     */
    Graph.prototype.cacheNodeSequence$ = function (key) {
        if (!this.hasNode(key)) {
            throw new Error_1.GraphMapillaryError("Cannot cache sequence edges of node that does not exist in graph (" + key + ").");
        }
        var node = this.getNode(key);
        if (node.sequenceKey in this._sequences) {
            throw new Error_1.GraphMapillaryError("Sequence already cached (" + key + "), (" + node.sequenceKey + ").");
        }
        return this._cacheSequence$(node.sequenceKey);
    };
    /**
     * Retrieve and cache a sequence.
     *
     * @param {string} sequenceKey - Key of sequence to cache.
     * @returns {Observable<Graph>} Observable emitting the graph
     * when the sequence has been retrieved.
     * @throws {GraphMapillaryError} When the operation is not valid on the
     * current graph.
     */
    Graph.prototype.cacheSequence$ = function (sequenceKey) {
        if (sequenceKey in this._sequences) {
            throw new Error_1.GraphMapillaryError("Sequence already cached (" + sequenceKey + ")");
        }
        return this._cacheSequence$(sequenceKey);
    };
    /**
     * Cache sequence edges for a node.
     *
     * @param {string} key - Key of node.
     * @throws {GraphMapillaryError} When the operation is not valid on the
     * current graph.
     */
    Graph.prototype.cacheSequenceEdges = function (key) {
        var node = this.getNode(key);
        if (!(node.sequenceKey in this._sequences)) {
            throw new Error_1.GraphMapillaryError("Sequence is not cached (" + key + "), (" + node.sequenceKey + ")");
        }
        var sequence = this._sequences[node.sequenceKey].sequence;
        var edges = this._edgeCalculator.computeSequenceEdges(node, sequence);
        node.cacheSequenceEdges(edges);
    };
    /**
     * Retrieve and cache full nodes for all keys in a sequence.
     *
     * @param {string} sequenceKey - Key of sequence.
     * @param {string} referenceNodeKey - Key of node to use as reference
     * for optimized caching.
     * @returns {Observable<Graph>} Observable emitting the graph
     * when the nodes of the sequence has been cached.
     */
    Graph.prototype.cacheSequenceNodes$ = function (sequenceKey, referenceNodeKey) {
        var _this = this;
        if (!this.hasSequence(sequenceKey)) {
            throw new Error_1.GraphMapillaryError("Cannot cache sequence nodes of sequence that does not exist in graph (" + sequenceKey + ").");
        }
        if (this.hasSequenceNodes(sequenceKey)) {
            throw new Error_1.GraphMapillaryError("Sequence nodes already cached (" + sequenceKey + ").");
        }
        var sequence = this.getSequence(sequenceKey);
        if (sequence.key in this._cachingSequenceNodes$) {
            return this._cachingSequenceNodes$[sequence.key];
        }
        var batches = [];
        var keys = sequence.keys.slice();
        var referenceBatchSize = 50;
        if (!!referenceNodeKey && keys.length > referenceBatchSize) {
            var referenceIndex = keys.indexOf(referenceNodeKey);
            var startIndex = Math.max(0, Math.min(referenceIndex - referenceBatchSize / 2, keys.length - referenceBatchSize));
            batches.push(keys.splice(startIndex, referenceBatchSize));
        }
        var batchSize = 200;
        while (keys.length > 0) {
            batches.push(keys.splice(0, batchSize));
        }
        var batchesToCache = batches.length;
        var sequenceNodes$ = Observable_1.Observable
            .from(batches)
            .mergeMap(function (batch) {
            return _this._apiV3.imageByKeyFull$(batch)
                .do(function (imageByKeyFull) {
                for (var fullKey in imageByKeyFull) {
                    if (!imageByKeyFull.hasOwnProperty(fullKey)) {
                        continue;
                    }
                    var fn = imageByKeyFull[fullKey];
                    if (_this.hasNode(fullKey)) {
                        var node = _this.getNode(fn.key);
                        if (!node.full) {
                            _this._makeFull(node, fn);
                        }
                    }
                    else {
                        if (fn.sequence_key == null) {
                            console.warn("Sequence missing, discarding node (" + fn.key + ")");
                        }
                        var node = new Graph_1.Node(fn);
                        _this._makeFull(node, fn);
                        var h = _this._graphCalculator.encodeH(node.originalLatLon, _this._tilePrecision);
                        _this._preStore(h, node);
                        _this._setNode(node);
                    }
                }
                batchesToCache--;
            })
                .map(function (imageByKeyFull) {
                return _this;
            });
        }, 6)
            .last()
            .finally(function () {
            delete _this._cachingSequenceNodes$[sequence.key];
            if (batchesToCache === 0) {
                _this._cachedSequenceNodes[sequence.key] = true;
            }
        })
            .publish()
            .refCount();
        this._cachingSequenceNodes$[sequence.key] = sequenceNodes$;
        return sequenceNodes$;
    };
    /**
     * Retrieve and cache full nodes for a node spatial area.
     *
     * @param {string} key - Key of node for which to retrieve sequence.
     * @returns {Observable<Graph>} Observable emitting the graph
     * when the nodes in the spatial area has been made full.
     * @throws {GraphMapillaryError} When the operation is not valid on the
     * current graph.
     */
    Graph.prototype.cacheSpatialArea$ = function (key) {
        var _this = this;
        if (!this.hasNode(key)) {
            throw new Error_1.GraphMapillaryError("Cannot cache spatial area of node that does not exist in graph (" + key + ").");
        }
        if (key in this._cachedSpatialEdges) {
            throw new Error_1.GraphMapillaryError("Node already spatially cached (" + key + ").");
        }
        if (!(key in this._requiredSpatialArea)) {
            throw new Error_1.GraphMapillaryError("Spatial area not determined (" + key + ").");
        }
        var spatialArea = this._requiredSpatialArea[key];
        if (Object.keys(spatialArea.cacheNodes).length === 0) {
            throw new Error_1.GraphMapillaryError("Spatial nodes already cached (" + key + ").");
        }
        if (key in this._cachingSpatialArea$) {
            return this._cachingSpatialArea$[key];
        }
        var batches = [];
        while (spatialArea.cacheKeys.length > 0) {
            batches.push(spatialArea.cacheKeys.splice(0, 200));
        }
        var batchesToCache = batches.length;
        var spatialNodes$ = [];
        var _loop_1 = function (batch) {
            var spatialNodeBatch$ = this_1._apiV3.imageByKeyFill$(batch)
                .do(function (imageByKeyFill) {
                for (var fillKey in imageByKeyFill) {
                    if (!imageByKeyFill.hasOwnProperty(fillKey)) {
                        continue;
                    }
                    var spatialNode = spatialArea.cacheNodes[fillKey];
                    if (spatialNode.full) {
                        delete spatialArea.cacheNodes[fillKey];
                        continue;
                    }
                    var fillNode = imageByKeyFill[fillKey];
                    _this._makeFull(spatialNode, fillNode);
                    delete spatialArea.cacheNodes[fillKey];
                }
                if (--batchesToCache === 0) {
                    delete _this._cachingSpatialArea$[key];
                }
            })
                .map(function (imageByKeyFill) {
                return _this;
            })
                .catch(function (error) {
                for (var _i = 0, batch_1 = batch; _i < batch_1.length; _i++) {
                    var batchKey = batch_1[_i];
                    if (batchKey in spatialArea.all) {
                        delete spatialArea.all[batchKey];
                    }
                    if (batchKey in spatialArea.cacheNodes) {
                        delete spatialArea.cacheNodes[batchKey];
                    }
                }
                if (--batchesToCache === 0) {
                    delete _this._cachingSpatialArea$[key];
                }
                throw error;
            })
                .finally(function () {
                if (Object.keys(spatialArea.cacheNodes).length === 0) {
                    _this._changed$.next(_this);
                }
            })
                .publish()
                .refCount();
            spatialNodes$.push(spatialNodeBatch$);
        };
        var this_1 = this;
        for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {
            var batch = batches_1[_i];
            _loop_1(batch);
        }
        this._cachingSpatialArea$[key] = spatialNodes$;
        return spatialNodes$;
    };
    /**
     * Cache spatial edges for a node.
     *
     * @param {string} key - Key of node.
     * @throws {GraphMapillaryError} When the operation is not valid on the
     * current graph.
     */
    Graph.prototype.cacheSpatialEdges = function (key) {
        if (key in this._cachedSpatialEdges) {
            throw new Error_1.GraphMapillaryError("Spatial edges already cached (" + key + ").");
        }
        var node = this.getNode(key);
        var sequence = this._sequences[node.sequenceKey].sequence;
        var fallbackKeys = [];
        var prevKey = sequence.findPrevKey(node.key);
        if (prevKey != null) {
            fallbackKeys.push(prevKey);
        }
        var nextKey = sequence.findNextKey(node.key);
        if (nextKey != null) {
            fallbackKeys.push(nextKey);
        }
        var allSpatialNodes = this._requiredSpatialArea[key].all;
        var potentialNodes = [];
        var filter = this._filter;
        for (var spatialNodeKey in allSpatialNodes) {
            if (!allSpatialNodes.hasOwnProperty(spatialNodeKey)) {
                continue;
            }
            var spatialNode = allSpatialNodes[spatialNodeKey];
            if (filter(spatialNode)) {
                potentialNodes.push(spatialNode);
            }
        }
        var potentialEdges = this._edgeCalculator.getPotentialEdges(node, potentialNodes, fallbackKeys);
        var edges = this._edgeCalculator.computeStepEdges(node, potentialEdges, prevKey, nextKey);
        edges = edges.concat(this._edgeCalculator.computeTurnEdges(node, potentialEdges));
        edges = edges.concat(this._edgeCalculator.computePanoEdges(node, potentialEdges));
        edges = edges.concat(this._edgeCalculator.computePerspectiveToPanoEdges(node, potentialEdges));
        edges = edges.concat(this._edgeCalculator.computeSimilarEdges(node, potentialEdges));
        node.cacheSpatialEdges(edges);
        this._cachedSpatialEdges[key] = node;
        delete this._requiredSpatialArea[key];
        delete this._cachedNodeTiles[key];
    };
    /**
     * Retrieve and cache geohash tiles for a node.
     *
     * @param {string} key - Key of node for which to retrieve tiles.
     * @returns {Array<Observable<Graph>>} Array of observables emitting
     * the graph for each tile required for the node has been cached.
     * @throws {GraphMapillaryError} When the operation is not valid on the
     * current graph.
     */
    Graph.prototype.cacheTiles$ = function (key) {
        var _this = this;
        if (key in this._cachedNodeTiles) {
            throw new Error_1.GraphMapillaryError("Tiles already cached (" + key + ").");
        }
        if (key in this._cachedSpatialEdges) {
            throw new Error_1.GraphMapillaryError("Spatial edges already cached so tiles considered cached (" + key + ").");
        }
        if (!(key in this._requiredNodeTiles)) {
            throw new Error_1.GraphMapillaryError("Tiles have not been determined (" + key + ").");
        }
        var nodeTiles = this._requiredNodeTiles[key];
        if (nodeTiles.cache.length === 0 &&
            nodeTiles.caching.length === 0) {
            throw new Error_1.GraphMapillaryError("Tiles already cached (" + key + ").");
        }
        if (!this.hasNode(key)) {
            throw new Error_1.GraphMapillaryError("Cannot cache tiles of node that does not exist in graph (" + key + ").");
        }
        var hs = nodeTiles.cache.slice();
        nodeTiles.caching = this._requiredNodeTiles[key].caching.concat(hs);
        nodeTiles.cache = [];
        var cacheTiles$ = [];
        var _loop_2 = function (h) {
            var cacheTile$ = h in this_2._cachingTiles$ ?
                this_2._cachingTiles$[h] :
                this_2._cacheTile$(h);
            cacheTiles$.push(cacheTile$
                .do(function (graph) {
                var index = nodeTiles.caching.indexOf(h);
                if (index > -1) {
                    nodeTiles.caching.splice(index, 1);
                }
                if (nodeTiles.caching.length === 0 &&
                    nodeTiles.cache.length === 0) {
                    delete _this._requiredNodeTiles[key];
                    _this._cachedNodeTiles[key] = true;
                }
            })
                .catch(function (error) {
                var index = nodeTiles.caching.indexOf(h);
                if (index > -1) {
                    nodeTiles.caching.splice(index, 1);
                }
                if (nodeTiles.caching.length === 0 &&
                    nodeTiles.cache.length === 0) {
                    delete _this._requiredNodeTiles[key];
                    _this._cachedNodeTiles[key] = true;
                }
                throw error;
            })
                .finally(function () {
                _this._changed$.next(_this);
            })
                .publish()
                .refCount());
        };
        var this_2 = this;
        for (var _i = 0, _a = nodeTiles.caching; _i < _a.length; _i++) {
            var h = _a[_i];
            _loop_2(h);
        }
        return cacheTiles$;
    };
    /**
     * Initialize the cache for a node.
     *
     * @param {string} key - Key of node.
     * @throws {GraphMapillaryError} When the operation is not valid on the
     * current graph.
     */
    Graph.prototype.initializeCache = function (key) {
        if (key in this._cachedNodes) {
            throw new Error_1.GraphMapillaryError("Node already in cache (" + key + ").");
        }
        var node = this.getNode(key);
        node.initializeCache(new Graph_1.NodeCache());
        var accessed = new Date().getTime();
        this._cachedNodes[key] = { accessed: accessed, node: node };
        this._updateCachedTileAccess(key, accessed);
    };
    /**
     * Get a value indicating if the graph is fill caching a node.
     *
     * @param {string} key - Key of node.
     * @returns {boolean} Value indicating if the node is being fill cached.
     */
    Graph.prototype.isCachingFill = function (key) {
        return key in this._cachingFill$;
    };
    /**
     * Get a value indicating if the graph is fully caching a node.
     *
     * @param {string} key - Key of node.
     * @returns {boolean} Value indicating if the node is being fully cached.
     */
    Graph.prototype.isCachingFull = function (key) {
        return key in this._cachingFull$;
    };
    /**
     * Get a value indicating if the graph is caching a sequence of a node.
     *
     * @param {string} key - Key of node.
     * @returns {boolean} Value indicating if the sequence of a node is
     * being cached.
     */
    Graph.prototype.isCachingNodeSequence = function (key) {
        var node = this.getNode(key);
        return node.sequenceKey in this._cachingSequences$;
    };
    /**
     * Get a value indicating if the graph is caching a sequence.
     *
     * @param {string} sequenceKey - Key of sequence.
     * @returns {boolean} Value indicating if the sequence is
     * being cached.
     */
    Graph.prototype.isCachingSequence = function (sequenceKey) {
        return sequenceKey in this._cachingSequences$;
    };
    /**
     * Get a value indicating if the graph is caching sequence nodes.
     *
     * @param {string} sequenceKey - Key of sequence.
     * @returns {boolean} Value indicating if the sequence nodes are
     * being cached.
     */
    Graph.prototype.isCachingSequenceNodes = function (sequenceKey) {
        return sequenceKey in this._cachingSequenceNodes$;
    };
    /**
     * Get a value indicating if the graph is caching the tiles
     * required for calculating spatial edges of a node.
     *
     * @param {string} key - Key of node.
     * @returns {boolean} Value indicating if the tiles of
     * a node are being cached.
     */
    Graph.prototype.isCachingTiles = function (key) {
        return key in this._requiredNodeTiles &&
            this._requiredNodeTiles[key].cache.length === 0 &&
            this._requiredNodeTiles[key].caching.length > 0;
    };
    /**
     * Get a value indicating if the cache has been initialized
     * for a node.
     *
     * @param {string} key - Key of node.
     * @returns {boolean} Value indicating if the cache has been
     * initialized for a node.
     */
    Graph.prototype.hasInitializedCache = function (key) {
        return key in this._cachedNodes;
    };
    /**
     * Get a value indicating if a node exist in the graph.
     *
     * @param {string} key - Key of node.
     * @returns {boolean} Value indicating if a node exist in the graph.
     */
    Graph.prototype.hasNode = function (key) {
        var accessed = new Date().getTime();
        this._updateCachedNodeAccess(key, accessed);
        this._updateCachedTileAccess(key, accessed);
        return key in this._nodes;
    };
    /**
     * Get a value indicating if a node sequence exist in the graph.
     *
     * @param {string} key - Key of node.
     * @returns {boolean} Value indicating if a node sequence exist
     * in the graph.
     */
    Graph.prototype.hasNodeSequence = function (key) {
        var node = this.getNode(key);
        var sequenceKey = node.sequenceKey;
        var hasNodeSequence = sequenceKey in this._sequences;
        if (hasNodeSequence) {
            this._sequences[sequenceKey].accessed = new Date().getTime();
        }
        return hasNodeSequence;
    };
    /**
     * Get a value indicating if a sequence exist in the graph.
     *
     * @param {string} sequenceKey - Key of sequence.
     * @returns {boolean} Value indicating if a sequence exist
     * in the graph.
     */
    Graph.prototype.hasSequence = function (sequenceKey) {
        var hasSequence = sequenceKey in this._sequences;
        if (hasSequence) {
            this._sequences[sequenceKey].accessed = new Date().getTime();
        }
        return hasSequence;
    };
    /**
     * Get a value indicating if sequence nodes has been cached in the graph.
     *
     * @param {string} sequenceKey - Key of sequence.
     * @returns {boolean} Value indicating if a sequence nodes has been
     * cached in the graph.
     */
    Graph.prototype.hasSequenceNodes = function (sequenceKey) {
        return sequenceKey in this._cachedSequenceNodes;
    };
    /**
     * Get a value indicating if the graph has fully cached
     * all nodes in the spatial area of a node.
     *
     * @param {string} key - Key of node.
     * @returns {boolean} Value indicating if the spatial area
     * of a node has been cached.
     */
    Graph.prototype.hasSpatialArea = function (key) {
        if (!this.hasNode(key)) {
            throw new Error_1.GraphMapillaryError("Spatial area nodes cannot be determined if node not in graph (" + key + ").");
        }
        if (key in this._cachedSpatialEdges) {
            return true;
        }
        if (key in this._requiredSpatialArea) {
            return Object.keys(this._requiredSpatialArea[key].cacheNodes).length === 0;
        }
        var node = this.getNode(key);
        var bbox = this._graphCalculator.boundingBoxCorners(node.latLon, this._tileThreshold);
        var spatialItems = this._nodeIndex.search({
            maxX: bbox[1].lat,
            maxY: bbox[1].lon,
            minX: bbox[0].lat,
            minY: bbox[0].lon,
        });
        var spatialNodes = {
            all: {},
            cacheKeys: [],
            cacheNodes: {},
        };
        for (var _i = 0, spatialItems_1 = spatialItems; _i < spatialItems_1.length; _i++) {
            var spatialItem = spatialItems_1[_i];
            spatialNodes.all[spatialItem.node.key] = spatialItem.node;
            if (!spatialItem.node.full) {
                spatialNodes.cacheKeys.push(spatialItem.node.key);
                spatialNodes.cacheNodes[spatialItem.node.key] = spatialItem.node;
            }
        }
        this._requiredSpatialArea[key] = spatialNodes;
        return spatialNodes.cacheKeys.length === 0;
    };
    /**
     * Get a value indicating if the graph has a tiles required
     * for a node.
     *
     * @param {string} key - Key of node.
     * @returns {boolean} Value indicating if the the tiles required
     * by a node has been cached.
     */
    Graph.prototype.hasTiles = function (key) {
        var _this = this;
        if (key in this._cachedNodeTiles) {
            return true;
        }
        if (key in this._cachedSpatialEdges) {
            return true;
        }
        if (!this.hasNode(key)) {
            throw new Error_1.GraphMapillaryError("Node does not exist in graph (" + key + ").");
        }
        var nodeTiles = { cache: [], caching: [] };
        if (!(key in this._requiredNodeTiles)) {
            var node = this.getNode(key);
            nodeTiles.cache = this._graphCalculator
                .encodeHs(node.latLon, this._tilePrecision, this._tileThreshold)
                .filter(function (h) {
                return !(h in _this._cachedTiles);
            });
            if (nodeTiles.cache.length > 0) {
                this._requiredNodeTiles[key] = nodeTiles;
            }
        }
        else {
            nodeTiles = this._requiredNodeTiles[key];
        }
        return nodeTiles.cache.length === 0 && nodeTiles.caching.length === 0;
    };
    /**
     * Get a node.
     *
     * @param {string} key - Key of node.
     * @returns {Node} Retrieved node.
     */
    Graph.prototype.getNode = function (key) {
        var accessed = new Date().getTime();
        this._updateCachedNodeAccess(key, accessed);
        this._updateCachedTileAccess(key, accessed);
        return this._nodes[key];
    };
    /**
     * Get a sequence.
     *
     * @param {string} sequenceKey - Key of sequence.
     * @returns {Node} Retrieved sequence.
     */
    Graph.prototype.getSequence = function (sequenceKey) {
        var sequenceAccess = this._sequences[sequenceKey];
        sequenceAccess.accessed = new Date().getTime();
        return sequenceAccess.sequence;
    };
    /**
     * Reset all spatial edges of the graph nodes.
     */
    Graph.prototype.resetSpatialEdges = function () {
        var cachedKeys = Object.keys(this._cachedSpatialEdges);
        for (var _i = 0, cachedKeys_1 = cachedKeys; _i < cachedKeys_1.length; _i++) {
            var cachedKey = cachedKeys_1[_i];
            var node = this._cachedSpatialEdges[cachedKey];
            node.resetSpatialEdges();
            delete this._cachedSpatialEdges[cachedKey];
        }
    };
    /**
     * Reset the complete graph but keep the nodes corresponding
     * to the supplied keys. All other nodes will be disposed.
     *
     * @param {Array<string>} keepKeys - Keys for nodes to keep
     * in graph after reset.
     */
    Graph.prototype.reset = function (keepKeys) {
        var nodes = [];
        for (var _i = 0, keepKeys_1 = keepKeys; _i < keepKeys_1.length; _i++) {
            var key = keepKeys_1[_i];
            if (!this.hasNode(key)) {
                throw new Error("Node does not exist " + key);
            }
            var node = this.getNode(key);
            node.resetSequenceEdges();
            node.resetSpatialEdges();
            nodes.push(node);
        }
        for (var _a = 0, _b = Object.keys(this._cachedNodes); _a < _b.length; _a++) {
            var cachedKey = _b[_a];
            if (keepKeys.indexOf(cachedKey) !== -1) {
                continue;
            }
            this._cachedNodes[cachedKey].node.dispose();
            delete this._cachedNodes[cachedKey];
        }
        this._cachedNodeTiles = {};
        this._cachedSpatialEdges = {};
        this._cachedTiles = {};
        this._cachingFill$ = {};
        this._cachingFull$ = {};
        this._cachingSequences$ = {};
        this._cachingSpatialArea$ = {};
        this._cachingTiles$ = {};
        this._nodes = {};
        this._nodeToTile = {};
        this._preStored = {};
        for (var _c = 0, nodes_2 = nodes; _c < nodes_2.length; _c++) {
            var node = nodes_2[_c];
            this._nodes[node.key] = node;
            var h = this._graphCalculator.encodeH(node.originalLatLon, this._tilePrecision);
            this._preStore(h, node);
        }
        this._requiredNodeTiles = {};
        this._requiredSpatialArea = {};
        this._sequences = {};
        this._nodeIndexTiles = {};
        this._nodeIndex.clear();
    };
    /**
     * Set the spatial node filter.
     *
     * @param {FilterExpression} filter - Filter expression to be applied
     * when calculating spatial edges.
     */
    Graph.prototype.setFilter = function (filter) {
        this._filter = this._filterCreator.createFilter(filter);
    };
    /**
     * Uncache the graph according to the graph configuration.
     *
     * @description Uncaches unused tiles, unused nodes and
     * sequences according to the numbers specified in the
     * graph configuration. Sequences does not have a direct
     * reference to either tiles or nodes and may be uncached
     * even if they are related to the nodes that should be kept.
     *
     * @param {Array<string>} keepKeys - Keys of nodes to keep in
     * graph unrelated to last access. Tiles related to those keys
     * will also be kept in graph.
     * @param {string} keepSequenceKey - Optional key of sequence
     * for which the belonging nodes should not be disposed or
     * removed from the graph. These nodes may still be uncached if
     * not specified in keep keys param.
     */
    Graph.prototype.uncache = function (keepKeys, keepSequenceKey) {
        var keysInUse = {};
        this._addNewKeys(keysInUse, this._cachingFull$);
        this._addNewKeys(keysInUse, this._cachingFill$);
        this._addNewKeys(keysInUse, this._cachingSpatialArea$);
        this._addNewKeys(keysInUse, this._requiredNodeTiles);
        this._addNewKeys(keysInUse, this._requiredSpatialArea);
        for (var _i = 0, keepKeys_2 = keepKeys; _i < keepKeys_2.length; _i++) {
            var key = keepKeys_2[_i];
            if (key in keysInUse) {
                continue;
            }
            keysInUse[key] = true;
        }
        var keepHs = {};
        for (var key in keysInUse) {
            if (!keysInUse.hasOwnProperty(key)) {
                continue;
            }
            var node = this._nodes[key];
            var nodeHs = this._graphCalculator.encodeHs(node.latLon);
            for (var _a = 0, nodeHs_1 = nodeHs; _a < nodeHs_1.length; _a++) {
                var nodeH = nodeHs_1[_a];
                if (!(nodeH in keepHs)) {
                    keepHs[nodeH] = true;
                }
            }
        }
        var potentialHs = [];
        for (var h in this._cachedTiles) {
            if (!this._cachedTiles.hasOwnProperty(h) || h in keepHs) {
                continue;
            }
            potentialHs.push([h, this._cachedTiles[h]]);
        }
        var uncacheHs = potentialHs
            .sort(function (h1, h2) {
            return h2[1].accessed - h1[1].accessed;
        })
            .slice(this._configuration.maxUnusedTiles)
            .map(function (h) {
            return h[0];
        });
        for (var _b = 0, uncacheHs_1 = uncacheHs; _b < uncacheHs_1.length; _b++) {
            var uncacheH = uncacheHs_1[_b];
            this._uncacheTile(uncacheH, keepSequenceKey);
        }
        var potentialPreStored = [];
        var nonCachedPreStored = [];
        for (var h in this._preStored) {
            if (!this._preStored.hasOwnProperty(h) || h in this._cachingTiles$) {
                continue;
            }
            var prestoredNodes = this._preStored[h];
            for (var key in prestoredNodes) {
                if (!prestoredNodes.hasOwnProperty(key) || key in keysInUse) {
                    continue;
                }
                if (prestoredNodes[key].sequenceKey === keepSequenceKey) {
                    continue;
                }
                if (key in this._cachedNodes) {
                    potentialPreStored.push([this._cachedNodes[key], h]);
                }
                else {
                    nonCachedPreStored.push([key, h]);
                }
            }
        }
        var uncachePreStored = potentialPreStored
            .sort(function (_a, _b) {
            var na1 = _a[0], h1 = _a[1];
            var na2 = _b[0], h2 = _b[1];
            return na2.accessed - na1.accessed;
        })
            .slice(this._configuration.maxUnusedPreStoredNodes)
            .map(function (_a) {
            var na = _a[0], h = _a[1];
            return [na.node.key, h];
        });
        this._uncachePreStored(nonCachedPreStored);
        this._uncachePreStored(uncachePreStored);
        var potentialNodes = [];
        for (var key in this._cachedNodes) {
            if (!this._cachedNodes.hasOwnProperty(key) || key in keysInUse) {
                continue;
            }
            potentialNodes.push(this._cachedNodes[key]);
        }
        var uncacheNodes = potentialNodes
            .sort(function (n1, n2) {
            return n2.accessed - n1.accessed;
        })
            .slice(this._configuration.maxUnusedNodes);
        for (var _c = 0, uncacheNodes_1 = uncacheNodes; _c < uncacheNodes_1.length; _c++) {
            var nodeAccess = uncacheNodes_1[_c];
            nodeAccess.node.uncache();
            var key = nodeAccess.node.key;
            delete this._cachedNodes[key];
            if (key in this._cachedNodeTiles) {
                delete this._cachedNodeTiles[key];
            }
            if (key in this._cachedSpatialEdges) {
                delete this._cachedSpatialEdges[key];
            }
        }
        var potentialSequences = [];
        for (var sequenceKey in this._sequences) {
            if (!this._sequences.hasOwnProperty(sequenceKey) ||
                sequenceKey in this._cachingSequences$ ||
                sequenceKey === keepSequenceKey) {
                continue;
            }
            potentialSequences.push(this._sequences[sequenceKey]);
        }
        var uncacheSequences = potentialSequences
            .sort(function (s1, s2) {
            return s2.accessed - s1.accessed;
        })
            .slice(this._configuration.maxSequences);
        for (var _d = 0, uncacheSequences_1 = uncacheSequences; _d < uncacheSequences_1.length; _d++) {
            var sequenceAccess = uncacheSequences_1[_d];
            var sequenceKey = sequenceAccess.sequence.key;
            delete this._sequences[sequenceKey];
            if (sequenceKey in this._cachedSequenceNodes) {
                delete this._cachedSequenceNodes[sequenceKey];
            }
            sequenceAccess.sequence.dispose();
        }
    };
    Graph.prototype._addNewKeys = function (keys, dict) {
        for (var key in dict) {
            if (!dict.hasOwnProperty(key) || !this.hasNode(key)) {
                continue;
            }
            if (!(key in keys)) {
                keys[key] = true;
            }
        }
    };
    Graph.prototype._cacheSequence$ = function (sequenceKey) {
        var _this = this;
        if (sequenceKey in this._cachingSequences$) {
            return this._cachingSequences$[sequenceKey];
        }
        this._cachingSequences$[sequenceKey] = this._apiV3.sequenceByKey$([sequenceKey])
            .do(function (sequenceByKey) {
            if (!(sequenceKey in _this._sequences)) {
                _this._sequences[sequenceKey] = {
                    accessed: new Date().getTime(),
                    sequence: new Graph_1.Sequence(sequenceByKey[sequenceKey]),
                };
            }
            delete _this._cachingSequences$[sequenceKey];
        })
            .map(function (sequenceByKey) {
            return _this;
        })
            .finally(function () {
            if (sequenceKey in _this._cachingSequences$) {
                delete _this._cachingSequences$[sequenceKey];
            }
            _this._changed$.next(_this);
        })
            .publish()
            .refCount();
        return this._cachingSequences$[sequenceKey];
    };
    Graph.prototype._cacheTile$ = function (h) {
        var _this = this;
        this._cachingTiles$[h] = this._apiV3.imagesByH$([h])
            .do(function (imagesByH) {
            var coreNodes = imagesByH[h];
            if (h in _this._cachedTiles) {
                return;
            }
            _this._nodeIndexTiles[h] = [];
            _this._cachedTiles[h] = { accessed: new Date().getTime(), nodes: [] };
            var hCache = _this._cachedTiles[h].nodes;
            var preStored = _this._removeFromPreStore(h);
            for (var index in coreNodes) {
                if (!coreNodes.hasOwnProperty(index)) {
                    continue;
                }
                var coreNode = coreNodes[index];
                if (coreNode == null) {
                    break;
                }
                if (coreNode.sequence_key == null) {
                    console.warn("Sequence missing, discarding node (" + coreNode.key + ")");
                    continue;
                }
                if (preStored != null && coreNode.key in preStored) {
                    var preStoredNode = preStored[coreNode.key];
                    delete preStored[coreNode.key];
                    hCache.push(preStoredNode);
                    var preStoredNodeIndexItem = {
                        lat: preStoredNode.latLon.lat,
                        lon: preStoredNode.latLon.lon,
                        node: preStoredNode,
                    };
                    _this._nodeIndex.insert(preStoredNodeIndexItem);
                    _this._nodeIndexTiles[h].push(preStoredNodeIndexItem);
                    _this._nodeToTile[preStoredNode.key] = h;
                    continue;
                }
                var node = new Graph_1.Node(coreNode);
                hCache.push(node);
                var nodeIndexItem = {
                    lat: node.latLon.lat,
                    lon: node.latLon.lon,
                    node: node,
                };
                _this._nodeIndex.insert(nodeIndexItem);
                _this._nodeIndexTiles[h].push(nodeIndexItem);
                _this._nodeToTile[node.key] = h;
                _this._setNode(node);
            }
            delete _this._cachingTiles$[h];
        })
            .map(function (imagesByH) {
            return _this;
        })
            .catch(function (error) {
            delete _this._cachingTiles$[h];
            throw error;
        })
            .publish()
            .refCount();
        return this._cachingTiles$[h];
    };
    Graph.prototype._makeFull = function (node, fillNode) {
        if (fillNode.calt == null) {
            fillNode.calt = this._defaultAlt;
        }
        if (fillNode.c_rotation == null) {
            fillNode.c_rotation = this._graphCalculator.rotationFromCompass(fillNode.ca, fillNode.orientation);
        }
        node.makeFull(fillNode);
    };
    Graph.prototype._preStore = function (h, node) {
        if (!(h in this._preStored)) {
            this._preStored[h] = {};
        }
        this._preStored[h][node.key] = node;
    };
    Graph.prototype._removeFromPreStore = function (h) {
        var preStored = null;
        if (h in this._preStored) {
            preStored = this._preStored[h];
            delete this._preStored[h];
        }
        return preStored;
    };
    Graph.prototype._setNode = function (node) {
        var key = node.key;
        if (this.hasNode(key)) {
            throw new Error_1.GraphMapillaryError("Node already exist (" + key + ").");
        }
        this._nodes[key] = node;
    };
    Graph.prototype._uncacheTile = function (h, keepSequenceKey) {
        for (var _i = 0, _a = this._cachedTiles[h].nodes; _i < _a.length; _i++) {
            var node = _a[_i];
            var key = node.key;
            delete this._nodeToTile[key];
            if (key in this._cachedNodes) {
                delete this._cachedNodes[key];
            }
            if (key in this._cachedNodeTiles) {
                delete this._cachedNodeTiles[key];
            }
            if (key in this._cachedSpatialEdges) {
                delete this._cachedSpatialEdges[key];
            }
            if (node.sequenceKey === keepSequenceKey) {
                this._preStore(h, node);
                node.uncache();
            }
            else {
                delete this._nodes[key];
                if (node.sequenceKey in this._cachedSequenceNodes) {
                    delete this._cachedSequenceNodes[node.sequenceKey];
                }
                node.dispose();
            }
        }
        for (var _b = 0, _c = this._nodeIndexTiles[h]; _b < _c.length; _b++) {
            var nodeIndexItem = _c[_b];
            this._nodeIndex.remove(nodeIndexItem);
        }
        delete this._nodeIndexTiles[h];
        delete this._cachedTiles[h];
    };
    Graph.prototype._uncachePreStored = function (preStored) {
        var hs = {};
        for (var _i = 0, preStored_1 = preStored; _i < preStored_1.length; _i++) {
            var _a = preStored_1[_i], key = _a[0], h = _a[1];
            if (key in this._nodes) {
                delete this._nodes[key];
            }
            if (key in this._cachedNodes) {
                delete this._cachedNodes[key];
            }
            var node = this._preStored[h][key];
            if (node.sequenceKey in this._cachedSequenceNodes) {
                delete this._cachedSequenceNodes[node.sequenceKey];
            }
            delete this._preStored[h][key];
            node.dispose();
            hs[h] = true;
        }
        for (var h in hs) {
            if (!hs.hasOwnProperty(h)) {
                continue;
            }
            if (Object.keys(this._preStored[h]).length === 0) {
                delete this._preStored[h];
            }
        }
    };
    Graph.prototype._updateCachedTileAccess = function (key, accessed) {
        if (key in this._nodeToTile) {
            this._cachedTiles[this._nodeToTile[key]].accessed = accessed;
        }
    };
    Graph.prototype._updateCachedNodeAccess = function (key, accessed) {
        if (key in this._cachedNodes) {
            this._cachedNodes[key].accessed = accessed;
        }
    };
    return Graph;
}());
exports.Graph = Graph;
exports.default = Graph;

},{"../Edge":292,"../Error":293,"../Graph":295,"rbush":25,"rxjs/Observable":29,"rxjs/Subject":34,"rxjs/add/observable/from":42,"rxjs/add/operator/catch":54,"rxjs/add/operator/do":61,"rxjs/add/operator/finally":64,"rxjs/add/operator/last":66,"rxjs/add/operator/map":67,"rxjs/add/operator/publish":73,"rxjs/add/operator/reduce":75}],394:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var geohash = require("latlon-geohash");
var THREE = require("three");
var Error_1 = require("../Error");
var Geo_1 = require("../Geo");
var GeoHashDirections = /** @class */ (function () {
    function GeoHashDirections() {
    }
    GeoHashDirections.n = "n";
    GeoHashDirections.nw = "nw";
    GeoHashDirections.w = "w";
    GeoHashDirections.sw = "sw";
    GeoHashDirections.s = "s";
    GeoHashDirections.se = "se";
    GeoHashDirections.e = "e";
    GeoHashDirections.ne = "ne";
    return GeoHashDirections;
}());
/**
 * @class GraphCalculator
 *
 * @classdesc Represents a calculator for graph entities.
 */
var GraphCalculator = /** @class */ (function () {
    /**
     * Create a new graph calculator instance.
     *
     * @param {GeoCoords} geoCoords - Geo coords instance.
     */
    function GraphCalculator(geoCoords) {
        this._geoCoords = geoCoords != null ? geoCoords : new Geo_1.GeoCoords();
    }
    /**
     * Encode the geohash tile for geodetic coordinates.
     *
     * @param {ILatLon} latlon - Latitude and longitude to encode.
     * @param {number} precision - Precision of the encoding.
     *
     * @returns {string} The geohash tile for the lat, lon and precision.
     */
    GraphCalculator.prototype.encodeH = function (latLon, precision) {
        if (precision === void 0) { precision = 7; }
        return geohash.encode(latLon.lat, latLon.lon, precision);
    };
    /**
     * Encode the geohash tiles within a threshold from a position
     * using Manhattan distance.
     *
     * @param {ILatLon} latlon - Latitude and longitude to encode.
     * @param {number} precision - Precision of the encoding.
     * @param {number} threshold - Threshold of the encoding in meters.
     *
     * @returns {string} The geohash tiles reachable within the threshold.
     */
    GraphCalculator.prototype.encodeHs = function (latLon, precision, threshold) {
        if (precision === void 0) { precision = 7; }
        if (threshold === void 0) { threshold = 20; }
        var h = geohash.encode(latLon.lat, latLon.lon, precision);
        var bounds = geohash.bounds(h);
        var ne = bounds.ne;
        var sw = bounds.sw;
        var neighbours = geohash.neighbours(h);
        var bl = [0, 0, 0];
        var tr = this._geoCoords.geodeticToEnu(ne.lat, ne.lon, 0, sw.lat, sw.lon, 0);
        var position = this._geoCoords.geodeticToEnu(latLon.lat, latLon.lon, 0, sw.lat, sw.lon, 0);
        var left = position[0] - bl[0];
        var right = tr[0] - position[0];
        var bottom = position[1] - bl[1];
        var top = tr[1] - position[1];
        var l = left < threshold;
        var r = right < threshold;
        var b = bottom < threshold;
        var t = top < threshold;
        var hs = [h];
        if (t) {
            hs.push(neighbours[GeoHashDirections.n]);
        }
        if (t && l) {
            hs.push(neighbours[GeoHashDirections.nw]);
        }
        if (l) {
            hs.push(neighbours[GeoHashDirections.w]);
        }
        if (l && b) {
            hs.push(neighbours[GeoHashDirections.sw]);
        }
        if (b) {
            hs.push(neighbours[GeoHashDirections.s]);
        }
        if (b && r) {
            hs.push(neighbours[GeoHashDirections.se]);
        }
        if (r) {
            hs.push(neighbours[GeoHashDirections.e]);
        }
        if (r && t) {
            hs.push(neighbours[GeoHashDirections.ne]);
        }
        return hs;
    };
    /**
     * Encode the minimum set of geohash tiles containing a bounding box.
     *
     * @description The current algorithm does expect the bounding box
     * to be sufficiently small to be contained in an area with the size
     * of maximally four tiles. Up to nine adjacent tiles may be returned.
     * The method currently uses the largest side as the threshold leading to
     * more tiles being returned than needed in edge cases.
     *
     * @param {ILatLon} sw - South west corner of bounding box.
     * @param {ILatLon} ne - North east corner of bounding box.
     * @param {number} precision - Precision of the encoding.
     *
     * @returns {string} The geohash tiles containing the bounding box.
     */
    GraphCalculator.prototype.encodeHsFromBoundingBox = function (sw, ne, precision) {
        if (precision === void 0) { precision = 7; }
        if (ne.lat <= sw.lat || ne.lon <= sw.lon) {
            throw new Error_1.GraphMapillaryError("North east needs to be top right of south west");
        }
        var centerLat = (sw.lat + ne.lat) / 2;
        var centerLon = (sw.lon + ne.lon) / 2;
        var enu = this._geoCoords.geodeticToEnu(ne.lat, ne.lon, 0, centerLat, centerLon, 0);
        var threshold = Math.max(enu[0], enu[1]);
        return this.encodeHs({ lat: centerLat, lon: centerLon }, precision, threshold);
    };
    /**
     * Get the bounding box corners for a circle with radius of a threshold
     * with center in a geodetic position.
     *
     * @param {ILatLon} latlon - Latitude and longitude to encode.
     * @param {number} threshold - Threshold distance from the position in meters.
     *
     * @returns {Array<ILatLon>} The south west and north east corners of the
     * bounding box.
     */
    GraphCalculator.prototype.boundingBoxCorners = function (latLon, threshold) {
        var bl = this._geoCoords.enuToGeodetic(-threshold, -threshold, 0, latLon.lat, latLon.lon, 0);
        var tr = this._geoCoords.enuToGeodetic(threshold, threshold, 0, latLon.lat, latLon.lon, 0);
        return [
            { lat: bl[0], lon: bl[1] },
            { lat: tr[0], lon: tr[1] },
        ];
    };
    /**
     * Convert a compass angle to an angle axis rotation vector.
     *
     * @param {number} compassAngle - The compass angle in degrees.
     * @param {number} orientation - The orientation of the original image.
     *
     * @returns {Array<number>} Angle axis rotation vector.
     */
    GraphCalculator.prototype.rotationFromCompass = function (compassAngle, orientation) {
        var x = 0;
        var y = 0;
        var z = 0;
        switch (orientation) {
            case 1:
                x = Math.PI / 2;
                break;
            case 3:
                x = -Math.PI / 2;
                z = Math.PI;
                break;
            case 6:
                y = -Math.PI / 2;
                z = -Math.PI / 2;
                break;
            case 8:
                y = Math.PI / 2;
                z = Math.PI / 2;
                break;
            default:
                break;
        }
        var rz = new THREE.Matrix4().makeRotationZ(z);
        var euler = new THREE.Euler(x, y, compassAngle * Math.PI / 180, "XYZ");
        var re = new THREE.Matrix4().makeRotationFromEuler(euler);
        var rotation = new THREE.Vector4().setAxisAngleFromRotationMatrix(re.multiply(rz));
        return rotation.multiplyScalar(rotation.w).toArray().slice(0, 3);
    };
    return GraphCalculator;
}());
exports.GraphCalculator = GraphCalculator;
exports.default = GraphCalculator;

},{"../Error":293,"../Geo":294,"latlon-geohash":21,"three":241}],395:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Enumeration for graph modes.
 * @enum {number}
 * @readonly
 * @description Modes for the retrieval and caching performed
 * by the graph service on the graph.
 */
var GraphMode;
(function (GraphMode) {
    /**
     * Caching is performed on sequences only and sequence edges are
     * calculated. Spatial tiles
     * are not retrieved and spatial edges are not calculated when
     * caching nodes. Complete sequences are being cached for requested
     * nodes within the graph.
     */
    GraphMode[GraphMode["Sequence"] = 0] = "Sequence";
    /**
     * Caching is performed with emphasis on spatial data. Sequence edges
     * as well as spatial edges are cached. Sequence data
     * is still requested but complete sequences are not being cached
     * for requested nodes.
     *
     * This is the initial mode of the graph service.
     */
    GraphMode[GraphMode["Spatial"] = 1] = "Spatial";
})(GraphMode = exports.GraphMode || (exports.GraphMode = {}));
exports.default = GraphMode;

},{}],396:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/operator/catch");
require("rxjs/add/operator/concat");
require("rxjs/add/operator/do");
require("rxjs/add/operator/expand");
require("rxjs/add/operator/finally");
require("rxjs/add/operator/first");
require("rxjs/add/operator/last");
require("rxjs/add/operator/map");
require("rxjs/add/operator/mergeMap");
require("rxjs/add/operator/publishReplay");
var Graph_1 = require("../Graph");
/**
 * @class GraphService
 *
 * @classdesc Represents a service for graph operations.
 */
var GraphService = /** @class */ (function () {
    /**
     * Create a new graph service instance.
     *
     * @param {Graph} graph - Graph instance to be operated on.
     */
    function GraphService(graph, imageLoadingService) {
        this._graph$ = Observable_1.Observable
            .of(graph)
            .concat(graph.changed$)
            .publishReplay(1)
            .refCount();
        this._graph$.subscribe(function () { });
        this._graphMode = Graph_1.GraphMode.Spatial;
        this._graphModeSubject$ = new Subject_1.Subject();
        this._graphMode$ = this._graphModeSubject$
            .startWith(this._graphMode)
            .publishReplay(1)
            .refCount();
        this._graphMode$.subscribe(function () { });
        this._imageLoadingService = imageLoadingService;
        this._firstGraphSubjects$ = [];
        this._initializeCacheSubscriptions = [];
        this._sequenceSubscriptions = [];
        this._spatialSubscriptions = [];
    }
    Object.defineProperty(GraphService.prototype, "graphMode$", {
        /**
         * Get graph mode observable.
         *
         * @description Emits the current graph mode.
         *
         * @returns {Observable<GraphMode>} Observable
         * emitting the current graph mode when it changes.
         */
        get: function () {
            return this._graphMode$;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Cache full nodes in a bounding box.
     *
     * @description When called, the full properties of
     * the node are retrieved. The node cache is not initialized
     * for any new nodes retrieved and the node assets are not
     * retrieved, {@link cacheNode$} needs to be called for caching
     * assets.
     *
     * @param {ILatLon} sw - South west corner of bounding box.
     * @param {ILatLon} ne - North east corner of bounding box.
     * @return {Observable<Array<Node>>} Observable emitting a single item,
     * the nodes of the bounding box, when they have all been retrieved.
     * @throws {Error} Propagates any IO node caching errors to the caller.
     */
    GraphService.prototype.cacheBoundingBox$ = function (sw, ne) {
        return this._graph$
            .first()
            .mergeMap(function (graph) {
            return graph.cacheBoundingBox$(sw, ne);
        });
    };
    /**
     * Cache a node in the graph and retrieve it.
     *
     * @description When called, the full properties of
     * the node are retrieved and the node cache is initialized.
     * After that the node assets are cached and the node
     * is emitted to the observable when.
     * In parallel to caching the node assets, the sequence and
     * spatial edges of the node are cached. For this, the sequence
     * of the node and the required tiles and spatial nodes are
     * retrieved. The sequence and spatial edges may be set before
     * or after the node is returned.
     *
     * @param {string} key - Key of the node to cache.
     * @return {Observable<Node>} Observable emitting a single item,
     * the node, when it has been retrieved and its assets are cached.
     * @throws {Error} Propagates any IO node caching errors to the caller.
     */
    GraphService.prototype.cacheNode$ = function (key) {
        var _this = this;
        var firstGraphSubject$ = new Subject_1.Subject();
        this._firstGraphSubjects$.push(firstGraphSubject$);
        var firstGraph$ = firstGraphSubject$
            .publishReplay(1)
            .refCount();
        var node$ = firstGraph$
            .map(function (graph) {
            return graph.getNode(key);
        })
            .mergeMap(function (node) {
            return node.assetsCached ?
                Observable_1.Observable.of(node) :
                node.cacheAssets$();
        })
            .publishReplay(1)
            .refCount();
        node$.subscribe(function (node) {
            _this._imageLoadingService.loadnode$.next(node);
        }, function (error) {
            console.error("Failed to cache node (" + key + ")", error);
        });
        var initializeCacheSubscription = this._graph$
            .first()
            .mergeMap(function (graph) {
            if (graph.isCachingFull(key) || !graph.hasNode(key)) {
                return graph.cacheFull$(key);
            }
            if (graph.isCachingFill(key) || !graph.getNode(key).full) {
                return graph.cacheFill$(key);
            }
            return Observable_1.Observable.of(graph);
        })
            .do(function (graph) {
            if (!graph.hasInitializedCache(key)) {
                graph.initializeCache(key);
            }
        })
            .finally(function () {
            if (initializeCacheSubscription == null) {
                return;
            }
            _this._removeFromArray(initializeCacheSubscription, _this._initializeCacheSubscriptions);
            _this._removeFromArray(firstGraphSubject$, _this._firstGraphSubjects$);
        })
            .subscribe(function (graph) {
            firstGraphSubject$.next(graph);
            firstGraphSubject$.complete();
        }, function (error) {
            firstGraphSubject$.error(error);
        });
        if (!initializeCacheSubscription.closed) {
            this._initializeCacheSubscriptions.push(initializeCacheSubscription);
        }
        var graphSequence$ = firstGraph$
            .mergeMap(function (graph) {
            if (graph.isCachingNodeSequence(key) || !graph.hasNodeSequence(key)) {
                return graph.cacheNodeSequence$(key);
            }
            return Observable_1.Observable.of(graph);
        })
            .publishReplay(1)
            .refCount();
        var sequenceSubscription = graphSequence$
            .do(function (graph) {
            if (!graph.getNode(key).sequenceEdges.cached) {
                graph.cacheSequenceEdges(key);
            }
        })
            .finally(function () {
            if (sequenceSubscription == null) {
                return;
            }
            _this._removeFromArray(sequenceSubscription, _this._sequenceSubscriptions);
        })
            .subscribe(function (graph) { return; }, function (error) {
            console.error("Failed to cache sequence edges (" + key + ").", error);
        });
        if (!sequenceSubscription.closed) {
            this._sequenceSubscriptions.push(sequenceSubscription);
        }
        if (this._graphMode === Graph_1.GraphMode.Spatial) {
            var spatialSubscription_1 = firstGraph$
                .expand(function (graph) {
                if (graph.hasTiles(key)) {
                    return Observable_1.Observable.empty();
                }
                return Observable_1.Observable
                    .from(graph.cacheTiles$(key))
                    .mergeMap(function (graph$) {
                    return graph$
                        .mergeMap(function (g) {
                        if (g.isCachingTiles(key)) {
                            return Observable_1.Observable.empty();
                        }
                        return Observable_1.Observable.of(g);
                    })
                        .catch(function (error, caught$) {
                        console.error("Failed to cache tile data (" + key + ").", error);
                        return Observable_1.Observable.empty();
                    });
                });
            })
                .last()
                .mergeMap(function (graph) {
                if (graph.hasSpatialArea(key)) {
                    return Observable_1.Observable.of(graph);
                }
                return Observable_1.Observable
                    .from(graph.cacheSpatialArea$(key))
                    .mergeMap(function (graph$) {
                    return graph$
                        .catch(function (error, caught$) {
                        console.error("Failed to cache spatial nodes (" + key + ").", error);
                        return Observable_1.Observable.empty();
                    });
                });
            })
                .last()
                .mergeMap(function (graph) {
                return graph.hasNodeSequence(key) ?
                    Observable_1.Observable.of(graph) :
                    graph.cacheNodeSequence$(key);
            })
                .do(function (graph) {
                if (!graph.getNode(key).spatialEdges.cached) {
                    graph.cacheSpatialEdges(key);
                }
            })
                .finally(function () {
                if (spatialSubscription_1 == null) {
                    return;
                }
                _this._removeFromArray(spatialSubscription_1, _this._spatialSubscriptions);
            })
                .subscribe(function (graph) { return; }, function (error) {
                console.error("Failed to cache spatial edges (" + key + ").", error);
            });
            if (!spatialSubscription_1.closed) {
                this._spatialSubscriptions.push(spatialSubscription_1);
            }
        }
        return node$
            .first(function (node) {
            return node.assetsCached;
        });
    };
    /**
     * Cache a sequence in the graph and retrieve it.
     *
     * @param {string} sequenceKey - Sequence key.
     * @returns {Observable<Sequence>} Observable emitting a single item,
     * the sequence, when it has been retrieved and its assets are cached.
     * @throws {Error} Propagates any IO node caching errors to the caller.
     */
    GraphService.prototype.cacheSequence$ = function (sequenceKey) {
        return this._graph$
            .first()
            .mergeMap(function (graph) {
            if (graph.isCachingSequence(sequenceKey) || !graph.hasSequence(sequenceKey)) {
                return graph.cacheSequence$(sequenceKey);
            }
            return Observable_1.Observable.of(graph);
        })
            .map(function (graph) {
            return graph.getSequence(sequenceKey);
        });
    };
    /**
     * Cache a sequence and its nodes in the graph and retrieve the sequence.
     *
     * @description Caches a sequence and its assets are cached and
     * retrieves all nodes belonging to the sequence. The node assets
     * or edges will not be cached.
     *
     * @param {string} sequenceKey - Sequence key.
     * @param {string} referenceNodeKey - Key of node to use as reference
     * for optimized caching.
     * @returns {Observable<Sequence>} Observable emitting a single item,
     * the sequence, when it has been retrieved, its assets are cached and
     * all nodes belonging to the sequence has been retrieved.
     * @throws {Error} Propagates any IO node caching errors to the caller.
     */
    GraphService.prototype.cacheSequenceNodes$ = function (sequenceKey, referenceNodeKey) {
        return this._graph$
            .first()
            .mergeMap(function (graph) {
            if (graph.isCachingSequence(sequenceKey) || !graph.hasSequence(sequenceKey)) {
                return graph.cacheSequence$(sequenceKey);
            }
            return Observable_1.Observable.of(graph);
        })
            .mergeMap(function (graph) {
            if (graph.isCachingSequenceNodes(sequenceKey) || !graph.hasSequenceNodes(sequenceKey)) {
                return graph.cacheSequenceNodes$(sequenceKey, referenceNodeKey);
            }
            return Observable_1.Observable.of(graph);
        })
            .map(function (graph) {
            return graph.getSequence(sequenceKey);
        });
    };
    /**
     * Set a spatial edge filter on the graph.
     *
     * @description Resets the spatial edges of all cached nodes.
     *
     * @param {FilterExpression} filter - Filter expression to be applied.
     * @return {Observable<Graph>} Observable emitting a single item,
     * the graph, when the spatial edges have been reset.
     */
    GraphService.prototype.setFilter$ = function (filter) {
        this._resetSubscriptions(this._spatialSubscriptions);
        return this._graph$
            .first()
            .do(function (graph) {
            graph.resetSpatialEdges();
            graph.setFilter(filter);
        })
            .map(function (graph) {
            return undefined;
        });
    };
    /**
     * Set the graph mode.
     *
     * @description If graph mode is set to spatial, caching
     * is performed with emphasis on spatial edges. If graph
     * mode is set to sequence no tile data is requested and
     * no spatial edges are computed.
     *
     * When setting graph mode to sequence all spatial
     * subscriptions are aborted.
     *
     * @param {GraphMode} mode - Graph mode to set.
     */
    GraphService.prototype.setGraphMode = function (mode) {
        if (this._graphMode === mode) {
            return;
        }
        if (mode === Graph_1.GraphMode.Sequence) {
            this._resetSubscriptions(this._spatialSubscriptions);
        }
        this._graphMode = mode;
        this._graphModeSubject$.next(this._graphMode);
    };
    /**
     * Reset the graph.
     *
     * @description Resets the graph but keeps the nodes of the
     * supplied keys.
     *
     * @param {Array<string>} keepKeys - Keys of nodes to keep in graph.
     * @return {Observable<Node>} Observable emitting a single item,
     * the graph, when it has been reset.
     */
    GraphService.prototype.reset$ = function (keepKeys) {
        this._abortSubjects(this._firstGraphSubjects$);
        this._resetSubscriptions(this._initializeCacheSubscriptions);
        this._resetSubscriptions(this._sequenceSubscriptions);
        this._resetSubscriptions(this._spatialSubscriptions);
        return this._graph$
            .first()
            .do(function (graph) {
            graph.reset(keepKeys);
        })
            .map(function (graph) {
            return undefined;
        });
    };
    /**
     * Uncache the graph.
     *
     * @description Uncaches the graph by removing tiles, nodes and
     * sequences. Keeps the nodes of the supplied keys and the tiles
     * related to those nodes.
     *
     * @param {Array<string>} keepKeys - Keys of nodes to keep in graph.
     * @param {string} keepSequenceKey - Optional key of sequence
     * for which the belonging nodes should not be disposed or
     * removed from the graph. These nodes may still be uncached if
     * not specified in keep keys param.
     * @return {Observable<Graph>} Observable emitting a single item,
     * the graph, when the graph has been uncached.
     */
    GraphService.prototype.uncache$ = function (keepKeys, keepSequenceKey) {
        return this._graph$
            .first()
            .do(function (graph) {
            graph.uncache(keepKeys, keepSequenceKey);
        })
            .map(function (graph) {
            return undefined;
        });
    };
    GraphService.prototype._abortSubjects = function (subjects) {
        for (var _i = 0, _a = subjects.slice(); _i < _a.length; _i++) {
            var subject = _a[_i];
            this._removeFromArray(subject, subjects);
            subject.error(new Error("Cache node request was aborted."));
        }
    };
    GraphService.prototype._removeFromArray = function (object, objects) {
        var index = objects.indexOf(object);
        if (index !== -1) {
            objects.splice(index, 1);
        }
    };
    GraphService.prototype._resetSubscriptions = function (subscriptions) {
        for (var _i = 0, _a = subscriptions.slice(); _i < _a.length; _i++) {
            var subscription = _a[_i];
            this._removeFromArray(subscription, subscriptions);
            if (!subscription.closed) {
                subscription.unsubscribe();
            }
        }
    };
    return GraphService;
}());
exports.GraphService = GraphService;
exports.default = GraphService;

},{"../Graph":295,"rxjs/Observable":29,"rxjs/Subject":34,"rxjs/add/operator/catch":54,"rxjs/add/operator/concat":56,"rxjs/add/operator/do":61,"rxjs/add/operator/expand":62,"rxjs/add/operator/finally":64,"rxjs/add/operator/first":65,"rxjs/add/operator/last":66,"rxjs/add/operator/map":67,"rxjs/add/operator/mergeMap":70,"rxjs/add/operator/publishReplay":74}],397:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("rxjs/Subject");
var ImageLoadingService = /** @class */ (function () {
    function ImageLoadingService() {
        this._loadnode$ = new Subject_1.Subject();
        this._loadstatus$ = this._loadnode$
            .scan(function (_a, node) {
            var nodes = _a[0];
            var changed = false;
            if (node.loadStatus.total === 0 || node.loadStatus.loaded === node.loadStatus.total) {
                if (node.key in nodes) {
                    delete nodes[node.key];
                    changed = true;
                }
            }
            else {
                nodes[node.key] = node.loadStatus;
                changed = true;
            }
            return [nodes, changed];
        }, [{}, false])
            .filter(function (_a) {
            var nodes = _a[0], changed = _a[1];
            return changed;
        })
            .map(function (_a) {
            var nodes = _a[0];
            return nodes;
        })
            .publishReplay(1)
            .refCount();
        this._loadstatus$.subscribe(function () { });
    }
    Object.defineProperty(ImageLoadingService.prototype, "loadnode$", {
        get: function () {
            return this._loadnode$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageLoadingService.prototype, "loadstatus$", {
        get: function () {
            return this._loadstatus$;
        },
        enumerable: true,
        configurable: true
    });
    return ImageLoadingService;
}());
exports.ImageLoadingService = ImageLoadingService;

},{"rxjs/Subject":34}],398:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var Pbf = require("pbf");
var MeshReader = /** @class */ (function () {
    function MeshReader() {
    }
    MeshReader.read = function (buffer) {
        var pbf = new Pbf(buffer);
        return pbf.readFields(MeshReader._readMeshField, { faces: [], vertices: [] });
    };
    MeshReader._readMeshField = function (tag, mesh, pbf) {
        if (tag === 1) {
            mesh.vertices.push(pbf.readFloat());
        }
        else if (tag === 2) {
            mesh.faces.push(pbf.readVarint());
        }
    };
    return MeshReader;
}());
exports.MeshReader = MeshReader;

},{"pbf":23}],399:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("rxjs/add/observable/combineLatest");
require("rxjs/add/operator/map");
/**
 * @class Node
 *
 * @classdesc Represents a node in the navigation graph.
 *
 * Explanation of position and bearing properties:
 *
 * When images are uploaded they will have GPS information in the EXIF, this is what
 * is called `originalLatLon` {@link Node.originalLatLon}.
 *
 * When Structure from Motions has been run for a node a `computedLatLon` that
 * differs from the `originalLatLon` will be created. It is different because
 * GPS positions are not very exact and SfM aligns the camera positions according
 * to the 3D reconstruction {@link Node.computedLatLon}.
 *
 * At last there exist a `latLon` property which evaluates to
 * the `computedLatLon` from SfM if it exists but falls back
 * to the `originalLatLon` from the EXIF GPS otherwise {@link Node.latlon}.
 *
 * Everything that is done in in the Viewer is based on the SfM positions,
 * i.e. `computedLatLon`. That is why the smooth transitions go in the right
 * direction (nd not in strange directions because of bad GPS).
 *
 * E.g. when placing a marker in the Viewer it is relative to the SfM
 * position i.e. the `computedLatLon`.
 *
 * The same concept as above also applies to the compass angle (or bearing) properties
 * `originalCa`, `computedCa` and `ca`.
 */
var Node = /** @class */ (function () {
    /**
     * Create a new node instance.
     *
     * @description Nodes are always created internally by the library.
     * Nodes can not be added to the library through any API method.
     *
     * @param {ICoreNode} coreNode - Raw core node data.
     */
    function Node(core) {
        this._cache = null;
        this._core = core;
        this._fill = null;
    }
    Object.defineProperty(Node.prototype, "assetsCached", {
        /**
         * Get assets cached.
         *
         * @description The assets that need to be cached for this property
         * to report true are the following: fill properties, image and mesh.
         * The library ensures that the current node will always have the
         * assets cached.
         *
         * @returns {boolean} Value indicating whether all assets have been
         * cached.
         */
        get: function () {
            return this._core != null &&
                this._fill != null &&
                this._cache != null &&
                this._cache.image != null &&
                this._cache.mesh != null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "alt", {
        /**
         * Get alt.
         *
         * @description If SfM has not been run the computed altitude is
         * set to a default value of two meters.
         *
         * @returns {number} Altitude, in meters.
         */
        get: function () {
            return this._fill.calt;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "ca", {
        /**
         * Get ca.
         *
         * @description If the SfM computed compass angle exists it will
         * be returned, otherwise the original EXIF compass angle.
         *
         * @returns {number} Compass angle, measured in degrees.
         */
        get: function () {
            return this._fill.cca != null ? this._fill.cca : this._fill.ca;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "capturedAt", {
        /**
         * Get capturedAt.
         *
         * @returns {number} Timestamp when the image was captured.
         */
        get: function () {
            return this._fill.captured_at;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "cameraUuid", {
        /**
         * Get camera uuid.
         *
         * @description Will be undefined if the camera uuid was not
         * recorded in the image exif information.
         *
         * @returns {string} Universally unique id for camera used
         * when capturing image.
         */
        get: function () {
            return this._fill.captured_with_camera_uuid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "computedCA", {
        /**
         * Get computedCA.
         *
         * @description Will not be set if SfM has not been run.
         *
         * @returns {number} SfM computed compass angle, measured in degrees.
         */
        get: function () {
            return this._fill.cca;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "computedLatLon", {
        /**
         * Get computedLatLon.
         *
         * @description Will not be set if SfM has not been run.
         *
         * @returns {ILatLon} SfM computed latitude longitude in WGS84 datum,
         * measured in degrees.
         */
        get: function () {
            return this._core.cl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "focal", {
        /**
         * Get focal.
         *
         * @description Will not be set if SfM has not been run.
         *
         * @returns {number} SfM computed focal length.
         */
        get: function () {
            return this._fill.cfocal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "full", {
        /**
         * Get full.
         *
         * @description The library ensures that the current node will
         * always be full.
         *
         * @returns {boolean} Value indicating whether the node has all
         * properties filled.
         */
        get: function () {
            return this._fill != null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "fullPano", {
        /**
         * Get fullPano.
         *
         * @returns {boolean} Value indicating whether the node is a complete
         * 360 panorama.
         */
        get: function () {
            return this._fill.gpano != null &&
                this._fill.gpano.CroppedAreaLeftPixels === 0 &&
                this._fill.gpano.CroppedAreaTopPixels === 0 &&
                this._fill.gpano.CroppedAreaImageWidthPixels === this._fill.gpano.FullPanoWidthPixels &&
                this._fill.gpano.CroppedAreaImageHeightPixels === this._fill.gpano.FullPanoHeightPixels;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "gpano", {
        /**
         * Get gpano.
         *
         * @description Will not be set for non panoramic images.
         *
         * @returns {IGPano} Panorama information for panorama images.
         */
        get: function () {
            return this._fill.gpano;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "height", {
        /**
         * Get height.
         *
         * @returns {number} Height of original image, not adjusted
         * for orientation.
         */
        get: function () {
            return this._fill.height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "image", {
        /**
         * Get image.
         *
         * @description The image will always be set on the current node.
         *
         * @returns {HTMLImageElement} Cached image element of the node.
         */
        get: function () {
            return this._cache.image;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "key", {
        /**
         * Get key.
         *
         * @returns {string} Unique key of the node.
         */
        get: function () {
            return this._core.key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "latLon", {
        /**
         * Get latLon.
         *
         * @description If the SfM computed latitude longitude exist
         * it will be returned, otherwise the original EXIF latitude
         * longitude.
         *
         * @returns {ILatLon} Latitude longitude in WGS84 datum,
         * measured in degrees.
         */
        get: function () {
            return this._core.cl != null ? this._core.cl : this._core.l;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "loadStatus", {
        /**
         * Get loadStatus.
         *
         * @returns {ILoadStatus} Value indicating the load status
         * of the mesh and image.
         */
        get: function () {
            return this._cache.loadStatus;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "merged", {
        /**
         * Get merged.
         *
         * @returns {boolean} Value indicating whether SfM has been
         * run on the node and the node has been merged into a
         * connected component.
         */
        get: function () {
            return this._fill != null &&
                this._fill.merge_version != null &&
                this._fill.merge_version > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "mergeCC", {
        /**
         * Get mergeCC.
         *
         * @description Will not be set if SfM has not yet been run on
         * node.
         *
         * @returns {number} SfM connected component key to which
         * image belongs.
         */
        get: function () {
            return this._fill.merge_cc;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "mergeVersion", {
        /**
         * Get mergeVersion.
         *
         * @returns {number} Version for which SfM was run and image was merged.
         */
        get: function () {
            return this._fill.merge_version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "mesh", {
        /**
         * Get mesh.
         *
         * @description The mesh will always be set on the current node.
         *
         * @returns {IMesh} SfM triangulated mesh of reconstructed
         * atomic 3D points.
         */
        get: function () {
            return this._cache.mesh;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "organizationKey", {
        /**
         * Get organizationKey.
         *
         * @returns {string} Unique key of the organization to which
         * the node belongs. If the node does not belong to an
         * organization the organization key will be undefined.
         */
        get: function () {
            return this._fill.organization_key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "orientation", {
        /**
         * Get orientation.
         *
         * @returns {number} EXIF orientation of original image.
         */
        get: function () {
            return this._fill.orientation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "originalCA", {
        /**
         * Get originalCA.
         *
         * @returns {number} Original EXIF compass angle, measured in
         * degrees.
         */
        get: function () {
            return this._fill.ca;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "originalLatLon", {
        /**
         * Get originalLatLon.
         *
         * @returns {ILatLon} Original EXIF latitude longitude in
         * WGS84 datum, measured in degrees.
         */
        get: function () {
            return this._core.l;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "pano", {
        /**
         * Get pano.
         *
         * @returns {boolean} Value indicating whether the node is a panorama.
         * It could be a cropped or full panorama.
         */
        get: function () {
            return this._fill.gpano != null &&
                this._fill.gpano.FullPanoWidthPixels != null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "private", {
        /**
         * Get private.
         *
         * @returns {boolean} Value specifying if image is accessible to
         * organization members only or to everyone.
         */
        get: function () {
            return this._fill.private;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "projectKey", {
        /**
         * Get projectKey.
         *
         * @returns {string} Unique key of the project to which
         * the node belongs. If the node does not belong to a
         * project the project key will be undefined.
         *
         * @deprecated This property will be deprecated in favor
         * of the organization key and private properties.
         */
        get: function () {
            return this._fill.project != null ?
                this._fill.project.key :
                null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "rotation", {
        /**
         * Get rotation.
         *
         * @description Will not be set if SfM has not been run.
         *
         * @returns {Array<number>} Rotation vector in angle axis representation.
         */
        get: function () {
            return this._fill.c_rotation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "scale", {
        /**
         * Get scale.
         *
         * @description Will not be set if SfM has not been run.
         *
         * @returns {number} Scale of atomic reconstruction.
         */
        get: function () {
            return this._fill.atomic_scale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "sequenceKey", {
        /**
         * Get sequenceKey.
         *
         * @returns {string} Unique key of the sequence to which
         * the node belongs.
         */
        get: function () {
            return this._core.sequence_key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "sequenceEdges", {
        /**
         * Get sequenceEdges.
         *
         * @returns {IEdgeStatus} Value describing the status of the
         * sequence edges.
         */
        get: function () {
            return this._cache.sequenceEdges;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "sequenceEdges$", {
        /**
         * Get sequenceEdges$.
         *
         * @returns {Observable<IEdgeStatus>} Observable emitting
         * values describing the status of the sequence edges.
         */
        get: function () {
            return this._cache.sequenceEdges$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "spatialEdges", {
        /**
         * Get spatialEdges.
         *
         * @returns {IEdgeStatus} Value describing the status of the
         * spatial edges.
         */
        get: function () {
            return this._cache.spatialEdges;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "spatialEdges$", {
        /**
         * Get spatialEdges$.
         *
         * @returns {Observable<IEdgeStatus>} Observable emitting
         * values describing the status of the spatial edges.
         */
        get: function () {
            return this._cache.spatialEdges$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "userKey", {
        /**
         * Get userKey.
         *
         * @returns {string} Unique key of the user who uploaded
         * the image.
         */
        get: function () {
            return this._fill.user.key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "username", {
        /**
         * Get username.
         *
         * @returns {string} Username of the user who uploaded
         * the image.
         */
        get: function () {
            return this._fill.user.username;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "width", {
        /**
         * Get width.
         *
         * @returns {number} Width of original image, not
         * adjusted for orientation.
         */
        get: function () {
            return this._fill.width;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Cache the image and mesh assets.
     *
     * @description The assets are always cached internally by the
     * library prior to setting a node as the current node.
     *
     * @returns {Observable<Node>} Observable emitting this node whenever the
     * load status has changed and when the mesh or image has been fully loaded.
     */
    Node.prototype.cacheAssets$ = function () {
        var _this = this;
        return this._cache.cacheAssets$(this.key, this.pano, this.merged)
            .map(function (cache) {
            return _this;
        });
    };
    Node.prototype.cacheImage$ = function (imageSize) {
        var _this = this;
        return this._cache.cacheImage$(this.key, imageSize)
            .map(function (cache) {
            return _this;
        });
    };
    /**
     * Cache the sequence edges.
     *
     * @description The sequence edges are cached asynchronously
     * internally by the library.
     *
     * @param {Array<IEdge>} edges - Sequence edges to cache.
     */
    Node.prototype.cacheSequenceEdges = function (edges) {
        this._cache.cacheSequenceEdges(edges);
    };
    /**
     * Cache the spatial edges.
     *
     * @description The spatial edges are cached asynchronously
     * internally by the library.
     *
     * @param {Array<IEdge>} edges - Spatial edges to cache.
     */
    Node.prototype.cacheSpatialEdges = function (edges) {
        this._cache.cacheSpatialEdges(edges);
    };
    /**
     * Dispose the node.
     *
     * @description Disposes all cached assets.
     */
    Node.prototype.dispose = function () {
        if (this._cache != null) {
            this._cache.dispose();
            this._cache = null;
        }
        this._core = null;
        this._fill = null;
    };
    /**
     * Initialize the node cache.
     *
     * @description The node cache is initialized internally by
     * the library.
     *
     * @param {NodeCache} cache - The node cache to set as cache.
     */
    Node.prototype.initializeCache = function (cache) {
        if (this._cache != null) {
            throw new Error("Node cache already initialized (" + this.key + ").");
        }
        this._cache = cache;
    };
    /**
     * Fill the node with all properties.
     *
     * @description The node is filled internally by
     * the library.
     *
     * @param {IFillNode} fill - The fill node struct.
     */
    Node.prototype.makeFull = function (fill) {
        if (fill == null) {
            throw new Error("Fill can not be null.");
        }
        this._fill = fill;
    };
    /**
     * Reset the sequence edges.
     */
    Node.prototype.resetSequenceEdges = function () {
        this._cache.resetSequenceEdges();
    };
    /**
     * Reset the spatial edges.
     */
    Node.prototype.resetSpatialEdges = function () {
        this._cache.resetSpatialEdges();
    };
    /**
     * Clears the image and mesh assets, aborts
     * any outstanding requests and resets edges.
     */
    Node.prototype.uncache = function () {
        if (this._cache == null) {
            return;
        }
        this._cache.dispose();
        this._cache = null;
    };
    return Node;
}());
exports.Node = Node;
exports.default = Node;

},{"rxjs/add/observable/combineLatest":38,"rxjs/add/operator/map":67}],400:[function(require,module,exports){
(function (Buffer){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("rxjs/Subject");
var Observable_1 = require("rxjs/Observable");
require("rxjs/add/observable/combineLatest");
require("rxjs/add/operator/publishReplay");
var Graph_1 = require("../Graph");
var Utils_1 = require("../Utils");
/**
 * @class NodeCache
 *
 * @classdesc Represents the cached properties of a node.
 */
var NodeCache = /** @class */ (function () {
    /**
     * Create a new node cache instance.
     */
    function NodeCache() {
        this._disposed = false;
        this._image = null;
        this._loadStatus = { loaded: 0, total: 0 };
        this._mesh = null;
        this._sequenceEdges = { cached: false, edges: [] };
        this._spatialEdges = { cached: false, edges: [] };
        this._sequenceEdgesChanged$ = new Subject_1.Subject();
        this._sequenceEdges$ = this._sequenceEdgesChanged$
            .startWith(this._sequenceEdges)
            .publishReplay(1)
            .refCount();
        this._sequenceEdgesSubscription = this._sequenceEdges$.subscribe(function () { });
        this._spatialEdgesChanged$ = new Subject_1.Subject();
        this._spatialEdges$ = this._spatialEdgesChanged$
            .startWith(this._spatialEdges)
            .publishReplay(1)
            .refCount();
        this._spatialEdgesSubscription = this._spatialEdges$.subscribe(function () { });
        this._cachingAssets$ = null;
    }
    Object.defineProperty(NodeCache.prototype, "image", {
        /**
         * Get image.
         *
         * @description Will not be set when assets have not been cached
         * or when the object has been disposed.
         *
         * @returns {HTMLImageElement} Cached image element of the node.
         */
        get: function () {
            return this._image;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeCache.prototype, "loadStatus", {
        /**
         * Get loadStatus.
         *
         * @returns {ILoadStatus} Value indicating the load status
         * of the mesh and image.
         */
        get: function () {
            return this._loadStatus;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeCache.prototype, "mesh", {
        /**
         * Get mesh.
         *
         * @description Will not be set when assets have not been cached
         * or when the object has been disposed.
         *
         * @returns {IMesh} SfM triangulated mesh of reconstructed
         * atomic 3D points.
         */
        get: function () {
            return this._mesh;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeCache.prototype, "sequenceEdges", {
        /**
         * Get sequenceEdges.
         *
         * @returns {IEdgeStatus} Value describing the status of the
         * sequence edges.
         */
        get: function () {
            return this._sequenceEdges;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeCache.prototype, "sequenceEdges$", {
        /**
         * Get sequenceEdges$.
         *
         * @returns {Observable<IEdgeStatus>} Observable emitting
         * values describing the status of the sequence edges.
         */
        get: function () {
            return this._sequenceEdges$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeCache.prototype, "spatialEdges", {
        /**
         * Get spatialEdges.
         *
         * @returns {IEdgeStatus} Value describing the status of the
         * spatial edges.
         */
        get: function () {
            return this._spatialEdges;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeCache.prototype, "spatialEdges$", {
        /**
         * Get spatialEdges$.
         *
         * @returns {Observable<IEdgeStatus>} Observable emitting
         * values describing the status of the spatial edges.
         */
        get: function () {
            return this._spatialEdges$;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Cache the image and mesh assets.
     *
     * @param {string} key - Key of the node to cache.
     * @param {boolean} pano - Value indicating whether node is a panorama.
     * @param {boolean} merged - Value indicating whether node is merged.
     * @returns {Observable<NodeCache>} Observable emitting this node
     * cache whenever the load status has changed and when the mesh or image
     * has been fully loaded.
     */
    NodeCache.prototype.cacheAssets$ = function (key, pano, merged) {
        var _this = this;
        if (this._cachingAssets$ != null) {
            return this._cachingAssets$;
        }
        var imageSize = pano ?
            Utils_1.Settings.basePanoramaSize :
            Utils_1.Settings.baseImageSize;
        this._cachingAssets$ = Observable_1.Observable
            .combineLatest(this._cacheImage$(key, imageSize), this._cacheMesh$(key, merged), function (imageStatus, meshStatus) {
            _this._loadStatus.loaded = 0;
            _this._loadStatus.total = 0;
            if (meshStatus) {
                _this._mesh = meshStatus.object;
                _this._loadStatus.loaded += meshStatus.loaded.loaded;
                _this._loadStatus.total += meshStatus.loaded.total;
            }
            if (imageStatus) {
                _this._image = imageStatus.object;
                _this._loadStatus.loaded += imageStatus.loaded.loaded;
                _this._loadStatus.total += imageStatus.loaded.total;
            }
            return _this;
        })
            .finally(function () {
            _this._cachingAssets$ = null;
        })
            .publishReplay(1)
            .refCount();
        return this._cachingAssets$;
    };
    /**
     * Cache an image with a higher resolution than the current one.
     *
     * @param {string} key - Key of the node to cache.
     * @param {ImageSize} imageSize - The size to cache.
     * @returns {Observable<NodeCache>} Observable emitting a single item,
     * the node cache, when the image has been cached. If supplied image
     * size is not larger than the current image size the node cache is
     * returned immediately.
     */
    NodeCache.prototype.cacheImage$ = function (key, imageSize) {
        var _this = this;
        if (this._image != null && imageSize <= Math.max(this._image.width, this._image.height)) {
            return Observable_1.Observable.of(this);
        }
        return this._cacheImage$(key, imageSize)
            .first(function (status) {
            return status.object != null;
        })
            .do(function (status) {
            _this._disposeImage();
            _this._image = status.object;
        })
            .map(function (imageStatus) {
            return _this;
        });
    };
    /**
     * Cache the sequence edges.
     *
     * @param {Array<IEdge>} edges - Sequence edges to cache.
     */
    NodeCache.prototype.cacheSequenceEdges = function (edges) {
        this._sequenceEdges = { cached: true, edges: edges };
        this._sequenceEdgesChanged$.next(this._sequenceEdges);
    };
    /**
     * Cache the spatial edges.
     *
     * @param {Array<IEdge>} edges - Spatial edges to cache.
     */
    NodeCache.prototype.cacheSpatialEdges = function (edges) {
        this._spatialEdges = { cached: true, edges: edges };
        this._spatialEdgesChanged$.next(this._spatialEdges);
    };
    /**
     * Dispose the node cache.
     *
     * @description Disposes all cached assets and unsubscribes to
     * all streams.
     */
    NodeCache.prototype.dispose = function () {
        this._sequenceEdgesSubscription.unsubscribe();
        this._spatialEdgesSubscription.unsubscribe();
        this._disposeImage();
        this._mesh = null;
        this._loadStatus.loaded = 0;
        this._loadStatus.total = 0;
        this._sequenceEdges = { cached: false, edges: [] };
        this._spatialEdges = { cached: false, edges: [] };
        this._sequenceEdgesChanged$.next(this._sequenceEdges);
        this._spatialEdgesChanged$.next(this._spatialEdges);
        this._disposed = true;
        if (this._imageRequest != null) {
            this._imageRequest.abort();
        }
        if (this._meshRequest != null) {
            this._meshRequest.abort();
        }
    };
    /**
     * Reset the sequence edges.
     */
    NodeCache.prototype.resetSequenceEdges = function () {
        this._sequenceEdges = { cached: false, edges: [] };
        this._sequenceEdgesChanged$.next(this._sequenceEdges);
    };
    /**
     * Reset the spatial edges.
     */
    NodeCache.prototype.resetSpatialEdges = function () {
        this._spatialEdges = { cached: false, edges: [] };
        this._spatialEdgesChanged$.next(this._spatialEdges);
    };
    /**
     * Cache the image.
     *
     * @param {string} key - Key of the node to cache.
     * @param {boolean} pano - Value indicating whether node is a panorama.
     * @returns {Observable<ILoadStatusObject<HTMLImageElement>>} Observable
     * emitting a load status object every time the load status changes
     * and completes when the image is fully loaded.
     */
    NodeCache.prototype._cacheImage$ = function (key, imageSize) {
        var _this = this;
        return Observable_1.Observable.create(function (subscriber) {
            var xmlHTTP = new XMLHttpRequest();
            xmlHTTP.open("GET", Utils_1.Urls.thumbnail(key, imageSize, Utils_1.Urls.origin), true);
            xmlHTTP.responseType = "arraybuffer";
            xmlHTTP.timeout = 15000;
            xmlHTTP.onload = function (pe) {
                if (xmlHTTP.status !== 200) {
                    _this._imageRequest = null;
                    subscriber.error(new Error("Failed to fetch image (" + key + "). Status: " + xmlHTTP.status + ", " + xmlHTTP.statusText));
                    return;
                }
                var image = new Image();
                image.crossOrigin = "Anonymous";
                image.onload = function (e) {
                    _this._imageRequest = null;
                    if (_this._disposed) {
                        window.URL.revokeObjectURL(image.src);
                        subscriber.error(new Error("Image load was aborted (" + key + ")"));
                        return;
                    }
                    subscriber.next({ loaded: { loaded: pe.loaded, total: pe.total }, object: image });
                    subscriber.complete();
                };
                image.onerror = function (error) {
                    _this._imageRequest = null;
                    subscriber.error(new Error("Failed to load image (" + key + ")"));
                };
                var blob = new Blob([xmlHTTP.response]);
                image.src = window.URL.createObjectURL(blob);
            };
            xmlHTTP.onprogress = function (pe) {
                if (_this._disposed) {
                    return;
                }
                subscriber.next({ loaded: { loaded: pe.loaded, total: pe.total }, object: null });
            };
            xmlHTTP.onerror = function (error) {
                _this._imageRequest = null;
                subscriber.error(new Error("Failed to fetch image (" + key + ")"));
            };
            xmlHTTP.ontimeout = function (e) {
                _this._imageRequest = null;
                subscriber.error(new Error("Image request timed out (" + key + ")"));
            };
            xmlHTTP.onabort = function (event) {
                _this._imageRequest = null;
                subscriber.error(new Error("Image request was aborted (" + key + ")"));
            };
            _this._imageRequest = xmlHTTP;
            xmlHTTP.send(null);
        });
    };
    /**
     * Cache the mesh.
     *
     * @param {string} key - Key of the node to cache.
     * @param {boolean} merged - Value indicating whether node is merged.
     * @returns {Observable<ILoadStatusObject<IMesh>>} Observable emitting
     * a load status object every time the load status changes and completes
     * when the mesh is fully loaded.
     */
    NodeCache.prototype._cacheMesh$ = function (key, merged) {
        var _this = this;
        return Observable_1.Observable.create(function (subscriber) {
            if (!merged) {
                subscriber.next(_this._createEmptyMeshLoadStatus());
                subscriber.complete();
                return;
            }
            var xmlHTTP = new XMLHttpRequest();
            xmlHTTP.open("GET", Utils_1.Urls.protoMesh(key), true);
            xmlHTTP.responseType = "arraybuffer";
            xmlHTTP.timeout = 15000;
            xmlHTTP.onload = function (pe) {
                _this._meshRequest = null;
                if (_this._disposed) {
                    return;
                }
                var mesh = xmlHTTP.status === 200 ?
                    Graph_1.MeshReader.read(new Buffer(xmlHTTP.response)) :
                    { faces: [], vertices: [] };
                subscriber.next({ loaded: { loaded: pe.loaded, total: pe.total }, object: mesh });
                subscriber.complete();
            };
            xmlHTTP.onprogress = function (pe) {
                if (_this._disposed) {
                    return;
                }
                subscriber.next({ loaded: { loaded: pe.loaded, total: pe.total }, object: null });
            };
            xmlHTTP.onerror = function (e) {
                _this._meshRequest = null;
                console.error("Failed to cache mesh (" + key + ")");
                subscriber.next(_this._createEmptyMeshLoadStatus());
                subscriber.complete();
            };
            xmlHTTP.ontimeout = function (e) {
                _this._meshRequest = null;
                console.error("Mesh request timed out (" + key + ")");
                subscriber.next(_this._createEmptyMeshLoadStatus());
                subscriber.complete();
            };
            xmlHTTP.onabort = function (e) {
                _this._meshRequest = null;
                subscriber.error(new Error("Mesh request was aborted (" + key + ")"));
            };
            _this._meshRequest = xmlHTTP;
            xmlHTTP.send(null);
        });
    };
    /**
     * Create a load status object with an empty mesh.
     *
     * @returns {ILoadStatusObject<IMesh>} Load status object
     * with empty mesh.
     */
    NodeCache.prototype._createEmptyMeshLoadStatus = function () {
        return {
            loaded: { loaded: 0, total: 0 },
            object: { faces: [], vertices: [] },
        };
    };
    NodeCache.prototype._disposeImage = function () {
        if (this._image != null) {
            window.URL.revokeObjectURL(this._image.src);
        }
        this._image = null;
    };
    return NodeCache;
}());
exports.NodeCache = NodeCache;
exports.default = NodeCache;

}).call(this,require("buffer").Buffer)

},{"../Graph":295,"../Utils":301,"buffer":7,"rxjs/Observable":29,"rxjs/Subject":34,"rxjs/add/observable/combineLatest":38,"rxjs/add/operator/publishReplay":74}],401:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("underscore");
/**
 * @class Sequence
 *
 * @classdesc Represents a sequence of ordered nodes.
 */
var Sequence = /** @class */ (function () {
    /**
     * Create a new sequene instance.
     *
     * @param {ISequence} sequence - Raw sequence data.
     */
    function Sequence(sequence) {
        this._key = sequence.key;
        this._keys = sequence.keys;
    }
    Object.defineProperty(Sequence.prototype, "key", {
        /**
         * Get key.
         *
         * @returns {string} Unique sequence key.
         */
        get: function () {
            return this._key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sequence.prototype, "keys", {
        /**
         * Get keys.
         *
         * @returns {Array<string>} Array of ordered node keys in the sequence.
         */
        get: function () {
            return this._keys;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose the sequence.
     *
     * @description Disposes all cached assets.
     */
    Sequence.prototype.dispose = function () {
        this._key = null;
        this._keys = null;
    };
    /**
     * Find the next node key in the sequence with respect to
     * the provided node key.
     *
     * @param {string} key - Reference node key.
     * @returns {string} Next key in sequence if it exists, null otherwise.
     */
    Sequence.prototype.findNextKey = function (key) {
        var i = _.indexOf(this._keys, key);
        if ((i + 1) >= this._keys.length || i === -1) {
            return null;
        }
        else {
            return this._keys[i + 1];
        }
    };
    /**
     * Find the previous node key in the sequence with respect to
     * the provided node key.
     *
     * @param {string} key - Reference node key.
     * @returns {string} Previous key in sequence if it exists, null otherwise.
     */
    Sequence.prototype.findPrevKey = function (key) {
        var i = _.indexOf(this._keys, key);
        if (i === 0 || i === -1) {
            return null;
        }
        else {
            return this._keys[i - 1];
        }
    };
    return Sequence;
}());
exports.Sequence = Sequence;
exports.default = Sequence;

},{"underscore":243}],402:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var Edge_1 = require("../../Edge");
var Error_1 = require("../../Error");
var Geo_1 = require("../../Geo");
/**
 * @class EdgeCalculator
 *
 * @classdesc Represents a class for calculating node edges.
 */
var EdgeCalculator = /** @class */ (function () {
    /**
     * Create a new edge calculator instance.
     *
     * @param {EdgeCalculatorSettings} settings - Settings struct.
     * @param {EdgeCalculatorDirections} directions - Directions struct.
     * @param {EdgeCalculatorCoefficients} coefficients - Coefficients struct.
     */
    function EdgeCalculator(settings, directions, coefficients) {
        this._spatial = new Geo_1.Spatial();
        this._geoCoords = new Geo_1.GeoCoords();
        this._settings = settings != null ? settings : new Edge_1.EdgeCalculatorSettings();
        this._directions = directions != null ? directions : new Edge_1.EdgeCalculatorDirections();
        this._coefficients = coefficients != null ? coefficients : new Edge_1.EdgeCalculatorCoefficients();
    }
    /**
     * Returns the potential edges to destination nodes for a set
     * of nodes with respect to a source node.
     *
     * @param {Node} node - Source node.
     * @param {Array<Node>} nodes - Potential destination nodes.
     * @param {Array<string>} fallbackKeys - Keys for destination nodes that should
     * be returned even if they do not meet the criteria for a potential edge.
     * @throws {ArgumentMapillaryError} If node is not full.
     */
    EdgeCalculator.prototype.getPotentialEdges = function (node, potentialNodes, fallbackKeys) {
        if (!node.full) {
            throw new Error_1.ArgumentMapillaryError("Node has to be full.");
        }
        if (!node.merged) {
            return [];
        }
        var currentDirection = this._spatial.viewingDirection(node.rotation);
        var currentVerticalDirection = this._spatial.angleToPlane(currentDirection.toArray(), [0, 0, 1]);
        var potentialEdges = [];
        for (var _i = 0, potentialNodes_1 = potentialNodes; _i < potentialNodes_1.length; _i++) {
            var potential = potentialNodes_1[_i];
            if (!potential.merged ||
                potential.key === node.key) {
                continue;
            }
            var enu = this._geoCoords.geodeticToEnu(potential.latLon.lat, potential.latLon.lon, potential.alt, node.latLon.lat, node.latLon.lon, node.alt);
            var motion = new THREE.Vector3(enu[0], enu[1], enu[2]);
            var distance = motion.length();
            if (distance > this._settings.maxDistance &&
                fallbackKeys.indexOf(potential.key) < 0) {
                continue;
            }
            var motionChange = this._spatial.angleBetweenVector2(currentDirection.x, currentDirection.y, motion.x, motion.y);
            var verticalMotion = this._spatial.angleToPlane(motion.toArray(), [0, 0, 1]);
            var direction = this._spatial.viewingDirection(potential.rotation);
            var directionChange = this._spatial.angleBetweenVector2(currentDirection.x, currentDirection.y, direction.x, direction.y);
            var verticalDirection = this._spatial.angleToPlane(direction.toArray(), [0, 0, 1]);
            var verticalDirectionChange = verticalDirection - currentVerticalDirection;
            var rotation = this._spatial.relativeRotationAngle(node.rotation, potential.rotation);
            var worldMotionAzimuth = this._spatial.angleBetweenVector2(1, 0, motion.x, motion.y);
            var sameSequence = potential.sequenceKey != null &&
                node.sequenceKey != null &&
                potential.sequenceKey === node.sequenceKey;
            var sameMergeCC = (potential.mergeCC == null && node.mergeCC == null) ||
                potential.mergeCC === node.mergeCC;
            var sameUser = potential.userKey === node.userKey;
            var potentialEdge = {
                capturedAt: potential.capturedAt,
                croppedPano: potential.pano && !potential.fullPano,
                directionChange: directionChange,
                distance: distance,
                fullPano: potential.fullPano,
                key: potential.key,
                motionChange: motionChange,
                rotation: rotation,
                sameMergeCC: sameMergeCC,
                sameSequence: sameSequence,
                sameUser: sameUser,
                sequenceKey: potential.sequenceKey,
                verticalDirectionChange: verticalDirectionChange,
                verticalMotion: verticalMotion,
                worldMotionAzimuth: worldMotionAzimuth,
            };
            potentialEdges.push(potentialEdge);
        }
        return potentialEdges;
    };
    /**
     * Computes the sequence edges for a node.
     *
     * @param {Node} node - Source node.
     * @throws {ArgumentMapillaryError} If node is not full.
     */
    EdgeCalculator.prototype.computeSequenceEdges = function (node, sequence) {
        if (!node.full) {
            throw new Error_1.ArgumentMapillaryError("Node has to be full.");
        }
        if (node.sequenceKey !== sequence.key) {
            throw new Error_1.ArgumentMapillaryError("Node and sequence does not correspond.");
        }
        var edges = [];
        var nextKey = sequence.findNextKey(node.key);
        if (nextKey != null) {
            edges.push({
                data: {
                    direction: Edge_1.EdgeDirection.Next,
                    worldMotionAzimuth: Number.NaN,
                },
                from: node.key,
                to: nextKey,
            });
        }
        var prevKey = sequence.findPrevKey(node.key);
        if (prevKey != null) {
            edges.push({
                data: {
                    direction: Edge_1.EdgeDirection.Prev,
                    worldMotionAzimuth: Number.NaN,
                },
                from: node.key,
                to: prevKey,
            });
        }
        return edges;
    };
    /**
     * Computes the similar edges for a node.
     *
     * @description Similar edges for perspective images and cropped panoramas
     * look roughly in the same direction and are positioned closed to the node.
     * Similar edges for full panoramas only target other full panoramas.
     *
     * @param {Node} node - Source node.
     * @param {Array<IPotentialEdge>} potentialEdges - Potential edges.
     * @throws {ArgumentMapillaryError} If node is not full.
     */
    EdgeCalculator.prototype.computeSimilarEdges = function (node, potentialEdges) {
        var _this = this;
        if (!node.full) {
            throw new Error_1.ArgumentMapillaryError("Node has to be full.");
        }
        var nodeFullPano = node.fullPano;
        var sequenceGroups = {};
        for (var _i = 0, potentialEdges_1 = potentialEdges; _i < potentialEdges_1.length; _i++) {
            var potentialEdge = potentialEdges_1[_i];
            if (potentialEdge.sequenceKey == null) {
                continue;
            }
            if (potentialEdge.sameSequence ||
                !potentialEdge.sameMergeCC) {
                continue;
            }
            if (nodeFullPano) {
                if (!potentialEdge.fullPano) {
                    continue;
                }
            }
            else {
                if (!potentialEdge.fullPano &&
                    Math.abs(potentialEdge.directionChange) > this._settings.similarMaxDirectionChange) {
                    continue;
                }
            }
            if (potentialEdge.distance > this._settings.similarMaxDistance) {
                continue;
            }
            if (potentialEdge.sameUser &&
                Math.abs(potentialEdge.capturedAt - node.capturedAt) <
                    this._settings.similarMinTimeDifference) {
                continue;
            }
            if (sequenceGroups[potentialEdge.sequenceKey] == null) {
                sequenceGroups[potentialEdge.sequenceKey] = [];
            }
            sequenceGroups[potentialEdge.sequenceKey].push(potentialEdge);
        }
        var similarEdges = [];
        var calculateScore = node.fullPano ?
            function (potentialEdge) {
                return potentialEdge.distance;
            } :
            function (potentialEdge) {
                return _this._coefficients.similarDistance * potentialEdge.distance +
                    _this._coefficients.similarRotation * potentialEdge.rotation;
            };
        for (var sequenceKey in sequenceGroups) {
            if (!sequenceGroups.hasOwnProperty(sequenceKey)) {
                continue;
            }
            var lowestScore = Number.MAX_VALUE;
            var similarEdge = null;
            for (var _a = 0, _b = sequenceGroups[sequenceKey]; _a < _b.length; _a++) {
                var potentialEdge = _b[_a];
                var score = calculateScore(potentialEdge);
                if (score < lowestScore) {
                    lowestScore = score;
                    similarEdge = potentialEdge;
                }
            }
            if (similarEdge == null) {
                continue;
            }
            similarEdges.push(similarEdge);
        }
        return similarEdges
            .map(function (potentialEdge) {
            return {
                data: {
                    direction: Edge_1.EdgeDirection.Similar,
                    worldMotionAzimuth: potentialEdge.worldMotionAzimuth,
                },
                from: node.key,
                to: potentialEdge.key,
            };
        });
    };
    /**
     * Computes the step edges for a perspective node.
     *
     * @description Step edge targets can only be other perspective nodes.
     * Returns an empty array for cropped and full panoramas.
     *
     * @param {Node} node - Source node.
     * @param {Array<IPotentialEdge>} potentialEdges - Potential edges.
     * @param {string} prevKey - Key of previous node in sequence.
     * @param {string} prevKey - Key of next node in sequence.
     * @throws {ArgumentMapillaryError} If node is not full.
     */
    EdgeCalculator.prototype.computeStepEdges = function (node, potentialEdges, prevKey, nextKey) {
        if (!node.full) {
            throw new Error_1.ArgumentMapillaryError("Node has to be full.");
        }
        var edges = [];
        if (node.pano) {
            return edges;
        }
        for (var k in this._directions.steps) {
            if (!this._directions.steps.hasOwnProperty(k)) {
                continue;
            }
            var step = this._directions.steps[k];
            var lowestScore = Number.MAX_VALUE;
            var edge = null;
            var fallback = null;
            for (var _i = 0, potentialEdges_2 = potentialEdges; _i < potentialEdges_2.length; _i++) {
                var potential = potentialEdges_2[_i];
                if (potential.croppedPano || potential.fullPano) {
                    continue;
                }
                if (Math.abs(potential.directionChange) > this._settings.stepMaxDirectionChange) {
                    continue;
                }
                var motionDifference = this._spatial.angleDifference(step.motionChange, potential.motionChange);
                var directionMotionDifference = this._spatial.angleDifference(potential.directionChange, motionDifference);
                var drift = Math.max(Math.abs(motionDifference), Math.abs(directionMotionDifference));
                if (Math.abs(drift) > this._settings.stepMaxDrift) {
                    continue;
                }
                var potentialKey = potential.key;
                if (step.useFallback && (potentialKey === prevKey || potentialKey === nextKey)) {
                    fallback = potential;
                }
                if (potential.distance > this._settings.stepMaxDistance) {
                    continue;
                }
                motionDifference = Math.sqrt(motionDifference * motionDifference +
                    potential.verticalMotion * potential.verticalMotion);
                var score = this._coefficients.stepPreferredDistance *
                    Math.abs(potential.distance - this._settings.stepPreferredDistance) /
                    this._settings.stepMaxDistance +
                    this._coefficients.stepMotion * motionDifference / this._settings.stepMaxDrift +
                    this._coefficients.stepRotation * potential.rotation / this._settings.stepMaxDirectionChange +
                    this._coefficients.stepSequencePenalty * (potential.sameSequence ? 0 : 1) +
                    this._coefficients.stepMergeCCPenalty * (potential.sameMergeCC ? 0 : 1);
                if (score < lowestScore) {
                    lowestScore = score;
                    edge = potential;
                }
            }
            edge = edge == null ? fallback : edge;
            if (edge != null) {
                edges.push({
                    data: {
                        direction: step.direction,
                        worldMotionAzimuth: edge.worldMotionAzimuth,
                    },
                    from: node.key,
                    to: edge.key,
                });
            }
        }
        return edges;
    };
    /**
     * Computes the turn edges for a perspective node.
     *
     * @description Turn edge targets can only be other perspective images.
     * Returns an empty array for cropped and full panoramas.
     *
     * @param {Node} node - Source node.
     * @param {Array<IPotentialEdge>} potentialEdges - Potential edges.
     * @throws {ArgumentMapillaryError} If node is not full.
     */
    EdgeCalculator.prototype.computeTurnEdges = function (node, potentialEdges) {
        if (!node.full) {
            throw new Error_1.ArgumentMapillaryError("Node has to be full.");
        }
        var edges = [];
        if (node.pano) {
            return edges;
        }
        for (var k in this._directions.turns) {
            if (!this._directions.turns.hasOwnProperty(k)) {
                continue;
            }
            var turn = this._directions.turns[k];
            var lowestScore = Number.MAX_VALUE;
            var edge = null;
            for (var _i = 0, potentialEdges_3 = potentialEdges; _i < potentialEdges_3.length; _i++) {
                var potential = potentialEdges_3[_i];
                if (potential.croppedPano || potential.fullPano) {
                    continue;
                }
                if (potential.distance > this._settings.turnMaxDistance) {
                    continue;
                }
                var rig = turn.direction !== Edge_1.EdgeDirection.TurnU &&
                    potential.distance < this._settings.turnMaxRigDistance &&
                    Math.abs(potential.directionChange) > this._settings.turnMinRigDirectionChange;
                var directionDifference = this._spatial.angleDifference(turn.directionChange, potential.directionChange);
                var score = void 0;
                if (rig &&
                    potential.directionChange * turn.directionChange > 0 &&
                    Math.abs(potential.directionChange) < Math.abs(turn.directionChange)) {
                    score = -Math.PI / 2 + Math.abs(potential.directionChange);
                }
                else {
                    if (Math.abs(directionDifference) > this._settings.turnMaxDirectionChange) {
                        continue;
                    }
                    var motionDifference = turn.motionChange ?
                        this._spatial.angleDifference(turn.motionChange, potential.motionChange) : 0;
                    motionDifference = Math.sqrt(motionDifference * motionDifference +
                        potential.verticalMotion * potential.verticalMotion);
                    score =
                        this._coefficients.turnDistance * potential.distance /
                            this._settings.turnMaxDistance +
                            this._coefficients.turnMotion * motionDifference / Math.PI +
                            this._coefficients.turnSequencePenalty * (potential.sameSequence ? 0 : 1) +
                            this._coefficients.turnMergeCCPenalty * (potential.sameMergeCC ? 0 : 1);
                }
                if (score < lowestScore) {
                    lowestScore = score;
                    edge = potential;
                }
            }
            if (edge != null) {
                edges.push({
                    data: {
                        direction: turn.direction,
                        worldMotionAzimuth: edge.worldMotionAzimuth,
                    },
                    from: node.key,
                    to: edge.key,
                });
            }
        }
        return edges;
    };
    /**
     * Computes the pano edges for a perspective node.
     *
     * @description Perspective to pano edge targets can only be
     * full pano nodes. Returns an empty array for cropped and full panoramas.
     *
     * @param {Node} node - Source node.
     * @param {Array<IPotentialEdge>} potentialEdges - Potential edges.
     * @throws {ArgumentMapillaryError} If node is not full.
     */
    EdgeCalculator.prototype.computePerspectiveToPanoEdges = function (node, potentialEdges) {
        if (!node.full) {
            throw new Error_1.ArgumentMapillaryError("Node has to be full.");
        }
        if (node.pano) {
            return [];
        }
        var lowestScore = Number.MAX_VALUE;
        var edge = null;
        for (var _i = 0, potentialEdges_4 = potentialEdges; _i < potentialEdges_4.length; _i++) {
            var potential = potentialEdges_4[_i];
            if (!potential.fullPano) {
                continue;
            }
            var score = this._coefficients.panoPreferredDistance *
                Math.abs(potential.distance - this._settings.panoPreferredDistance) /
                this._settings.panoMaxDistance +
                this._coefficients.panoMotion * Math.abs(potential.motionChange) / Math.PI +
                this._coefficients.panoMergeCCPenalty * (potential.sameMergeCC ? 0 : 1);
            if (score < lowestScore) {
                lowestScore = score;
                edge = potential;
            }
        }
        if (edge == null) {
            return [];
        }
        return [
            {
                data: {
                    direction: Edge_1.EdgeDirection.Pano,
                    worldMotionAzimuth: edge.worldMotionAzimuth,
                },
                from: node.key,
                to: edge.key,
            },
        ];
    };
    /**
     * Computes the full pano and step edges for a full pano node.
     *
     * @description Pano to pano edge targets can only be
     * full pano nodes. Pano to step edge targets can only be perspective
     * nodes.
     * Returns an empty array for cropped panoramas and perspective nodes.
     *
     * @param {Node} node - Source node.
     * @param {Array<IPotentialEdge>} potentialEdges - Potential edges.
     * @throws {ArgumentMapillaryError} If node is not full.
     */
    EdgeCalculator.prototype.computePanoEdges = function (node, potentialEdges) {
        if (!node.full) {
            throw new Error_1.ArgumentMapillaryError("Node has to be full.");
        }
        if (!node.fullPano) {
            return [];
        }
        var panoEdges = [];
        var potentialPanos = [];
        var potentialSteps = [];
        for (var _i = 0, potentialEdges_5 = potentialEdges; _i < potentialEdges_5.length; _i++) {
            var potential = potentialEdges_5[_i];
            if (potential.distance > this._settings.panoMaxDistance) {
                continue;
            }
            if (potential.fullPano) {
                if (potential.distance < this._settings.panoMinDistance) {
                    continue;
                }
                potentialPanos.push(potential);
            }
            else {
                if (potential.croppedPano) {
                    continue;
                }
                for (var k in this._directions.panos) {
                    if (!this._directions.panos.hasOwnProperty(k)) {
                        continue;
                    }
                    var pano = this._directions.panos[k];
                    var turn = this._spatial.angleDifference(potential.directionChange, potential.motionChange);
                    var turnChange = this._spatial.angleDifference(pano.directionChange, turn);
                    if (Math.abs(turnChange) > this._settings.panoMaxStepTurnChange) {
                        continue;
                    }
                    potentialSteps.push([pano.direction, potential]);
                    // break if step direction found
                    break;
                }
            }
        }
        var maxRotationDifference = Math.PI / this._settings.panoMaxItems;
        var occupiedAngles = [];
        var stepAngles = [];
        for (var index = 0; index < this._settings.panoMaxItems; index++) {
            var rotation = index / this._settings.panoMaxItems * 2 * Math.PI;
            var lowestScore = Number.MAX_VALUE;
            var edge = null;
            for (var _a = 0, potentialPanos_1 = potentialPanos; _a < potentialPanos_1.length; _a++) {
                var potential = potentialPanos_1[_a];
                var motionDifference = this._spatial.angleDifference(rotation, potential.motionChange);
                if (Math.abs(motionDifference) > maxRotationDifference) {
                    continue;
                }
                var occupiedDifference = Number.MAX_VALUE;
                for (var _b = 0, occupiedAngles_1 = occupiedAngles; _b < occupiedAngles_1.length; _b++) {
                    var occupiedAngle = occupiedAngles_1[_b];
                    var difference = Math.abs(this._spatial.angleDifference(occupiedAngle, potential.motionChange));
                    if (difference < occupiedDifference) {
                        occupiedDifference = difference;
                    }
                }
                if (occupiedDifference <= maxRotationDifference) {
                    continue;
                }
                var score = this._coefficients.panoPreferredDistance *
                    Math.abs(potential.distance - this._settings.panoPreferredDistance) /
                    this._settings.panoMaxDistance +
                    this._coefficients.panoMotion * Math.abs(motionDifference) / maxRotationDifference +
                    this._coefficients.panoSequencePenalty * (potential.sameSequence ? 0 : 1) +
                    this._coefficients.panoMergeCCPenalty * (potential.sameMergeCC ? 0 : 1);
                if (score < lowestScore) {
                    lowestScore = score;
                    edge = potential;
                }
            }
            if (edge != null) {
                occupiedAngles.push(edge.motionChange);
                panoEdges.push({
                    data: {
                        direction: Edge_1.EdgeDirection.Pano,
                        worldMotionAzimuth: edge.worldMotionAzimuth,
                    },
                    from: node.key,
                    to: edge.key,
                });
            }
            else {
                stepAngles.push(rotation);
            }
        }
        var occupiedStepAngles = {};
        occupiedStepAngles[Edge_1.EdgeDirection.Pano] = occupiedAngles;
        occupiedStepAngles[Edge_1.EdgeDirection.StepForward] = [];
        occupiedStepAngles[Edge_1.EdgeDirection.StepLeft] = [];
        occupiedStepAngles[Edge_1.EdgeDirection.StepBackward] = [];
        occupiedStepAngles[Edge_1.EdgeDirection.StepRight] = [];
        for (var _c = 0, stepAngles_1 = stepAngles; _c < stepAngles_1.length; _c++) {
            var stepAngle = stepAngles_1[_c];
            var occupations = [];
            for (var k in this._directions.panos) {
                if (!this._directions.panos.hasOwnProperty(k)) {
                    continue;
                }
                var pano = this._directions.panos[k];
                var allOccupiedAngles = occupiedStepAngles[Edge_1.EdgeDirection.Pano]
                    .concat(occupiedStepAngles[pano.direction])
                    .concat(occupiedStepAngles[pano.prev])
                    .concat(occupiedStepAngles[pano.next]);
                var lowestScore = Number.MAX_VALUE;
                var edge = null;
                for (var _d = 0, potentialSteps_1 = potentialSteps; _d < potentialSteps_1.length; _d++) {
                    var potential = potentialSteps_1[_d];
                    if (potential[0] !== pano.direction) {
                        continue;
                    }
                    var motionChange = this._spatial.angleDifference(stepAngle, potential[1].motionChange);
                    if (Math.abs(motionChange) > maxRotationDifference) {
                        continue;
                    }
                    var minOccupiedDifference = Number.MAX_VALUE;
                    for (var _e = 0, allOccupiedAngles_1 = allOccupiedAngles; _e < allOccupiedAngles_1.length; _e++) {
                        var occupiedAngle = allOccupiedAngles_1[_e];
                        var occupiedDifference = Math.abs(this._spatial.angleDifference(occupiedAngle, potential[1].motionChange));
                        if (occupiedDifference < minOccupiedDifference) {
                            minOccupiedDifference = occupiedDifference;
                        }
                    }
                    if (minOccupiedDifference <= maxRotationDifference) {
                        continue;
                    }
                    var score = this._coefficients.panoPreferredDistance *
                        Math.abs(potential[1].distance - this._settings.panoPreferredDistance) /
                        this._settings.panoMaxDistance +
                        this._coefficients.panoMotion * Math.abs(motionChange) / maxRotationDifference +
                        this._coefficients.panoMergeCCPenalty * (potential[1].sameMergeCC ? 0 : 1);
                    if (score < lowestScore) {
                        lowestScore = score;
                        edge = potential;
                    }
                }
                if (edge != null) {
                    occupations.push(edge);
                    panoEdges.push({
                        data: {
                            direction: edge[0],
                            worldMotionAzimuth: edge[1].worldMotionAzimuth,
                        },
                        from: node.key,
                        to: edge[1].key,
                    });
                }
            }
            for (var _f = 0, occupations_1 = occupations; _f < occupations_1.length; _f++) {
                var occupation = occupations_1[_f];
                occupiedStepAngles[occupation[0]].push(occupation[1].motionChange);
            }
        }
        return panoEdges;
    };
    return EdgeCalculator;
}());
exports.EdgeCalculator = EdgeCalculator;
exports.default = EdgeCalculator;

},{"../../Edge":292,"../../Error":293,"../../Geo":294,"three":241}],403:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EdgeCalculatorCoefficients = /** @class */ (function () {
    function EdgeCalculatorCoefficients() {
        this.panoPreferredDistance = 2;
        this.panoMotion = 2;
        this.panoSequencePenalty = 1;
        this.panoMergeCCPenalty = 4;
        this.stepPreferredDistance = 4;
        this.stepMotion = 3;
        this.stepRotation = 4;
        this.stepSequencePenalty = 2;
        this.stepMergeCCPenalty = 6;
        this.similarDistance = 2;
        this.similarRotation = 3;
        this.turnDistance = 4;
        this.turnMotion = 2;
        this.turnSequencePenalty = 1;
        this.turnMergeCCPenalty = 4;
    }
    return EdgeCalculatorCoefficients;
}());
exports.EdgeCalculatorCoefficients = EdgeCalculatorCoefficients;
exports.default = EdgeCalculatorCoefficients;

},{}],404:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Edge_1 = require("../../Edge");
var EdgeCalculatorDirections = /** @class */ (function () {
    function EdgeCalculatorDirections() {
        this.steps = {};
        this.turns = {};
        this.panos = {};
        this.steps[Edge_1.EdgeDirection.StepForward] = {
            direction: Edge_1.EdgeDirection.StepForward,
            motionChange: 0,
            useFallback: true,
        };
        this.steps[Edge_1.EdgeDirection.StepBackward] = {
            direction: Edge_1.EdgeDirection.StepBackward,
            motionChange: Math.PI,
            useFallback: true,
        };
        this.steps[Edge_1.EdgeDirection.StepLeft] = {
            direction: Edge_1.EdgeDirection.StepLeft,
            motionChange: Math.PI / 2,
            useFallback: false,
        };
        this.steps[Edge_1.EdgeDirection.StepRight] = {
            direction: Edge_1.EdgeDirection.StepRight,
            motionChange: -Math.PI / 2,
            useFallback: false,
        };
        this.turns[Edge_1.EdgeDirection.TurnLeft] = {
            direction: Edge_1.EdgeDirection.TurnLeft,
            directionChange: Math.PI / 2,
            motionChange: Math.PI / 4,
        };
        this.turns[Edge_1.EdgeDirection.TurnRight] = {
            direction: Edge_1.EdgeDirection.TurnRight,
            directionChange: -Math.PI / 2,
            motionChange: -Math.PI / 4,
        };
        this.turns[Edge_1.EdgeDirection.TurnU] = {
            direction: Edge_1.EdgeDirection.TurnU,
            directionChange: Math.PI,
            motionChange: null,
        };
        this.panos[Edge_1.EdgeDirection.StepForward] = {
            direction: Edge_1.EdgeDirection.StepForward,
            directionChange: 0,
            next: Edge_1.EdgeDirection.StepLeft,
            prev: Edge_1.EdgeDirection.StepRight,
        };
        this.panos[Edge_1.EdgeDirection.StepBackward] = {
            direction: Edge_1.EdgeDirection.StepBackward,
            directionChange: Math.PI,
            next: Edge_1.EdgeDirection.StepRight,
            prev: Edge_1.EdgeDirection.StepLeft,
        };
        this.panos[Edge_1.EdgeDirection.StepLeft] = {
            direction: Edge_1.EdgeDirection.StepLeft,
            directionChange: Math.PI / 2,
            next: Edge_1.EdgeDirection.StepBackward,
            prev: Edge_1.EdgeDirection.StepForward,
        };
        this.panos[Edge_1.EdgeDirection.StepRight] = {
            direction: Edge_1.EdgeDirection.StepRight,
            directionChange: -Math.PI / 2,
            next: Edge_1.EdgeDirection.StepForward,
            prev: Edge_1.EdgeDirection.StepBackward,
        };
    }
    return EdgeCalculatorDirections;
}());
exports.EdgeCalculatorDirections = EdgeCalculatorDirections;

},{"../../Edge":292}],405:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EdgeCalculatorSettings = /** @class */ (function () {
    function EdgeCalculatorSettings() {
        this.panoMinDistance = 0.1;
        this.panoMaxDistance = 20;
        this.panoPreferredDistance = 5;
        this.panoMaxItems = 4;
        this.panoMaxStepTurnChange = Math.PI / 8;
        this.rotationMaxDistance = this.turnMaxRigDistance;
        this.rotationMaxDirectionChange = Math.PI / 6;
        this.rotationMaxVerticalDirectionChange = Math.PI / 8;
        this.similarMaxDirectionChange = Math.PI / 8;
        this.similarMaxDistance = 12;
        this.similarMinTimeDifference = 12 * 3600 * 1000;
        this.stepMaxDistance = 20;
        this.stepMaxDirectionChange = Math.PI / 6;
        this.stepMaxDrift = Math.PI / 6;
        this.stepPreferredDistance = 4;
        this.turnMaxDistance = 15;
        this.turnMaxDirectionChange = 2 * Math.PI / 9;
        this.turnMaxRigDistance = 0.65;
        this.turnMinRigDirectionChange = Math.PI / 6;
    }
    Object.defineProperty(EdgeCalculatorSettings.prototype, "maxDistance", {
        get: function () {
            return Math.max(this.panoMaxDistance, this.similarMaxDistance, this.stepMaxDistance, this.turnMaxDistance);
        },
        enumerable: true,
        configurable: true
    });
    return EdgeCalculatorSettings;
}());
exports.EdgeCalculatorSettings = EdgeCalculatorSettings;
exports.default = EdgeCalculatorSettings;

},{}],406:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Enumeration for edge directions
 * @enum {number}
 * @readonly
 * @description Directions for edges in node graph describing
 * sequence, spatial and node type relations between nodes.
 */
var EdgeDirection;
(function (EdgeDirection) {
    /**
     * Next node in the sequence.
     */
    EdgeDirection[EdgeDirection["Next"] = 0] = "Next";
    /**
     * Previous node in the sequence.
     */
    EdgeDirection[EdgeDirection["Prev"] = 1] = "Prev";
    /**
     * Step to the left keeping viewing direction.
     */
    EdgeDirection[EdgeDirection["StepLeft"] = 2] = "StepLeft";
    /**
     * Step to the right keeping viewing direction.
     */
    EdgeDirection[EdgeDirection["StepRight"] = 3] = "StepRight";
    /**
     * Step forward keeping viewing direction.
     */
    EdgeDirection[EdgeDirection["StepForward"] = 4] = "StepForward";
    /**
     * Step backward keeping viewing direction.
     */
    EdgeDirection[EdgeDirection["StepBackward"] = 5] = "StepBackward";
    /**
     * Turn 90 degrees counter clockwise.
     */
    EdgeDirection[EdgeDirection["TurnLeft"] = 6] = "TurnLeft";
    /**
     * Turn 90 degrees clockwise.
     */
    EdgeDirection[EdgeDirection["TurnRight"] = 7] = "TurnRight";
    /**
     * Turn 180 degrees.
     */
    EdgeDirection[EdgeDirection["TurnU"] = 8] = "TurnU";
    /**
     * Panorama in general direction.
     */
    EdgeDirection[EdgeDirection["Pano"] = 9] = "Pano";
    /**
     * Looking in roughly the same direction at rougly the same position.
     */
    EdgeDirection[EdgeDirection["Similar"] = 10] = "Similar";
})(EdgeDirection = exports.EdgeDirection || (exports.EdgeDirection = {}));

},{}],407:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("underscore");
var vd = require("virtual-dom");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/operator/combineLatest");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/map");
require("rxjs/add/operator/pluck");
require("rxjs/add/operator/scan");
var Render_1 = require("../Render");
var DOMRenderer = /** @class */ (function () {
    function DOMRenderer(element, renderService, currentFrame$) {
        this._adaptiveOperation$ = new Subject_1.Subject();
        this._render$ = new Subject_1.Subject();
        this._renderAdaptive$ = new Subject_1.Subject();
        this._renderService = renderService;
        this._currentFrame$ = currentFrame$;
        var rootNode = vd.create(vd.h("div.domRenderer", []));
        element.appendChild(rootNode);
        this._offset$ = this._adaptiveOperation$
            .scan(function (adaptive, operation) {
            return operation(adaptive);
        }, {
            elementHeight: element.offsetHeight,
            elementWidth: element.offsetWidth,
            imageAspect: 0,
            renderMode: Render_1.RenderMode.Fill,
        })
            .filter(function (adaptive) {
            return adaptive.imageAspect > 0 && adaptive.elementWidth > 0 && adaptive.elementHeight > 0;
        })
            .map(function (adaptive) {
            var elementAspect = adaptive.elementWidth / adaptive.elementHeight;
            var ratio = adaptive.imageAspect / elementAspect;
            var verticalOffset = 0;
            var horizontalOffset = 0;
            if (adaptive.renderMode === Render_1.RenderMode.Letterbox) {
                if (adaptive.imageAspect > elementAspect) {
                    verticalOffset = adaptive.elementHeight * (1 - 1 / ratio) / 2;
                }
                else {
                    horizontalOffset = adaptive.elementWidth * (1 - ratio) / 2;
                }
            }
            else {
                if (adaptive.imageAspect > elementAspect) {
                    horizontalOffset = -adaptive.elementWidth * (ratio - 1) / 2;
                }
                else {
                    verticalOffset = -adaptive.elementHeight * (1 / ratio - 1) / 2;
                }
            }
            return {
                bottom: verticalOffset,
                left: horizontalOffset,
                right: horizontalOffset,
                top: verticalOffset,
            };
        });
        this._currentFrame$
            .filter(function (frame) {
            return frame.state.currentNode != null;
        })
            .distinctUntilChanged(function (k1, k2) {
            return k1 === k2;
        }, function (frame) {
            return frame.state.currentNode.key;
        })
            .map(function (frame) {
            return frame.state.currentTransform.basicAspect;
        })
            .map(function (aspect) {
            return function (adaptive) {
                adaptive.imageAspect = aspect;
                return adaptive;
            };
        })
            .subscribe(this._adaptiveOperation$);
        this._renderAdaptive$
            .scan(function (vNodeHashes, vNodeHash) {
            if (vNodeHash.vnode == null) {
                delete vNodeHashes[vNodeHash.name];
            }
            else {
                vNodeHashes[vNodeHash.name] = vNodeHash.vnode;
            }
            return vNodeHashes;
        }, {})
            .combineLatest(this._offset$)
            .map(function (vo) {
            var vNodes = _.values(vo[0]);
            var offset = vo[1];
            var properties = {
                style: {
                    bottom: offset.bottom + "px",
                    left: offset.left + "px",
                    "pointer-events": "none",
                    position: "absolute",
                    right: offset.right + "px",
                    top: offset.top + "px",
                },
            };
            return {
                name: "adaptiveDomRenderer",
                vnode: vd.h("div.adaptiveDomRenderer", properties, vNodes),
            };
        })
            .subscribe(this._render$);
        this._vNode$ = this._render$
            .scan(function (vNodeHashes, vNodeHash) {
            if (vNodeHash.vnode == null) {
                delete vNodeHashes[vNodeHash.name];
            }
            else {
                vNodeHashes[vNodeHash.name] = vNodeHash.vnode;
            }
            return vNodeHashes;
        }, {})
            .map(function (vNodeHashes) {
            var vNodes = _.values(vNodeHashes);
            return vd.h("div.domRenderer", vNodes);
        });
        this._vPatch$ = this._vNode$
            .scan(function (nodePatch, vNode) {
            nodePatch.vpatch = vd.diff(nodePatch.vnode, vNode);
            nodePatch.vnode = vNode;
            return nodePatch;
        }, { vnode: vd.h("div.domRenderer", []), vpatch: null })
            .pluck("vpatch");
        this._element$ = this._vPatch$
            .scan(function (oldElement, vPatch) {
            return vd.patch(oldElement, vPatch);
        }, rootNode)
            .publishReplay(1)
            .refCount();
        this._element$.subscribe(function () { });
        this._renderService.size$
            .map(function (size) {
            return function (adaptive) {
                adaptive.elementWidth = size.width;
                adaptive.elementHeight = size.height;
                return adaptive;
            };
        })
            .subscribe(this._adaptiveOperation$);
        this._renderService.renderMode$
            .map(function (renderMode) {
            return function (adaptive) {
                adaptive.renderMode = renderMode;
                return adaptive;
            };
        })
            .subscribe(this._adaptiveOperation$);
    }
    Object.defineProperty(DOMRenderer.prototype, "element$", {
        get: function () {
            return this._element$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMRenderer.prototype, "render$", {
        get: function () {
            return this._render$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMRenderer.prototype, "renderAdaptive$", {
        get: function () {
            return this._renderAdaptive$;
        },
        enumerable: true,
        configurable: true
    });
    DOMRenderer.prototype.clear = function (name) {
        this._renderAdaptive$.next({ name: name, vnode: null });
        this._render$.next({ name: name, vnode: null });
    };
    return DOMRenderer;
}());
exports.DOMRenderer = DOMRenderer;
exports.default = DOMRenderer;

},{"../Render":297,"rxjs/Subject":34,"rxjs/add/operator/combineLatest":55,"rxjs/add/operator/distinctUntilChanged":60,"rxjs/add/operator/filter":63,"rxjs/add/operator/map":67,"rxjs/add/operator/pluck":72,"rxjs/add/operator/scan":78,"underscore":243,"virtual-dom":247}],408:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var GLRenderStage;
(function (GLRenderStage) {
    GLRenderStage[GLRenderStage["Background"] = 0] = "Background";
    GLRenderStage[GLRenderStage["Foreground"] = 1] = "Foreground";
})(GLRenderStage = exports.GLRenderStage || (exports.GLRenderStage = {}));
exports.default = GLRenderStage;

},{}],409:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/observable/combineLatest");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/first");
require("rxjs/add/operator/map");
require("rxjs/add/operator/merge");
require("rxjs/add/operator/mergeMap");
require("rxjs/add/operator/scan");
require("rxjs/add/operator/share");
require("rxjs/add/operator/startWith");
var Render_1 = require("../Render");
var Utils_1 = require("../Utils");
var GLRenderer = /** @class */ (function () {
    function GLRenderer(canvasContainer, renderService, dom) {
        var _this = this;
        this._renderFrame$ = new Subject_1.Subject();
        this._renderCameraOperation$ = new Subject_1.Subject();
        this._render$ = new Subject_1.Subject();
        this._clear$ = new Subject_1.Subject();
        this._renderOperation$ = new Subject_1.Subject();
        this._rendererOperation$ = new Subject_1.Subject();
        this._eraserOperation$ = new Subject_1.Subject();
        this._renderService = renderService;
        this._dom = !!dom ? dom : new Utils_1.DOM();
        this._renderer$ = this._rendererOperation$
            .scan(function (renderer, operation) {
            return operation(renderer);
        }, { needsRender: false, renderer: null });
        this._renderCollection$ = this._renderOperation$
            .scan(function (hashes, operation) {
            return operation(hashes);
        }, {})
            .share();
        this._renderCamera$ = this._renderCameraOperation$
            .scan(function (rc, operation) {
            return operation(rc);
        }, { frameId: -1, needsRender: false, perspective: null });
        this._eraser$ = this._eraserOperation$
            .startWith(function (eraser) {
            return eraser;
        })
            .scan(function (eraser, operation) {
            return operation(eraser);
        }, { needsRender: false });
        Observable_1.Observable
            .combineLatest([this._renderer$, this._renderCollection$, this._renderCamera$, this._eraser$], function (renderer, hashes, rc, eraser) {
            var renders = Object.keys(hashes)
                .map(function (key) {
                return hashes[key];
            });
            return { camera: rc, eraser: eraser, renderer: renderer, renders: renders };
        })
            .filter(function (co) {
            var needsRender = co.renderer.needsRender ||
                co.camera.needsRender ||
                co.eraser.needsRender;
            var frameId = co.camera.frameId;
            for (var _i = 0, _a = co.renders; _i < _a.length; _i++) {
                var render = _a[_i];
                if (render.frameId !== frameId) {
                    return false;
                }
                needsRender = needsRender || render.needsRender;
            }
            return needsRender;
        })
            .distinctUntilChanged(function (n1, n2) {
            return n1 === n2;
        }, function (co) {
            return co.eraser.needsRender ? -1 : co.camera.frameId;
        })
            .subscribe(function (co) {
            co.renderer.needsRender = false;
            co.camera.needsRender = false;
            co.eraser.needsRender = false;
            var perspectiveCamera = co.camera.perspective;
            var backgroundRenders = [];
            var foregroundRenders = [];
            for (var _i = 0, _a = co.renders; _i < _a.length; _i++) {
                var render = _a[_i];
                if (render.stage === Render_1.GLRenderStage.Background) {
                    backgroundRenders.push(render.render);
                }
                else if (render.stage === Render_1.GLRenderStage.Foreground) {
                    foregroundRenders.push(render.render);
                }
            }
            var renderer = co.renderer.renderer;
            renderer.clear();
            for (var _b = 0, backgroundRenders_1 = backgroundRenders; _b < backgroundRenders_1.length; _b++) {
                var render = backgroundRenders_1[_b];
                render(perspectiveCamera, renderer);
            }
            renderer.clearDepth();
            for (var _c = 0, foregroundRenders_1 = foregroundRenders; _c < foregroundRenders_1.length; _c++) {
                var render = foregroundRenders_1[_c];
                render(perspectiveCamera, renderer);
            }
        });
        this._renderFrame$
            .map(function (rc) {
            return function (irc) {
                irc.frameId = rc.frameId;
                irc.perspective = rc.perspective;
                if (rc.changed === true) {
                    irc.needsRender = true;
                }
                return irc;
            };
        })
            .subscribe(this._renderCameraOperation$);
        this._renderFrameSubscribe();
        var renderHash$ = this._render$
            .map(function (hash) {
            return function (hashes) {
                hashes[hash.name] = hash.render;
                return hashes;
            };
        });
        var clearHash$ = this._clear$
            .map(function (name) {
            return function (hashes) {
                delete hashes[name];
                return hashes;
            };
        });
        Observable_1.Observable
            .merge(renderHash$, clearHash$)
            .subscribe(this._renderOperation$);
        this._webGLRenderer$ = this._render$
            .first()
            .map(function (hash) {
            var canvas = _this._dom.createElement("canvas", "mapillary-js-canvas");
            canvas.style.position = "absolute";
            canvas.setAttribute("tabindex", "0");
            canvasContainer.appendChild(canvas);
            var element = renderService.element;
            var webGLRenderer = new THREE.WebGLRenderer({ canvas: canvas });
            webGLRenderer.setPixelRatio(window.devicePixelRatio);
            webGLRenderer.setSize(element.offsetWidth, element.offsetHeight);
            webGLRenderer.setClearColor(new THREE.Color(0x202020), 1.0);
            webGLRenderer.autoClear = false;
            return webGLRenderer;
        })
            .publishReplay(1)
            .refCount();
        this._webGLRenderer$.subscribe(function () { });
        var createRenderer$ = this._webGLRenderer$
            .first()
            .map(function (webGLRenderer) {
            return function (renderer) {
                renderer.needsRender = true;
                renderer.renderer = webGLRenderer;
                return renderer;
            };
        });
        var resizeRenderer$ = this._renderService.size$
            .map(function (size) {
            return function (renderer) {
                if (renderer.renderer == null) {
                    return renderer;
                }
                renderer.renderer.setSize(size.width, size.height);
                renderer.needsRender = true;
                return renderer;
            };
        });
        var clearRenderer$ = this._clear$
            .map(function (name) {
            return function (renderer) {
                if (renderer.renderer == null) {
                    return renderer;
                }
                renderer.needsRender = true;
                return renderer;
            };
        });
        Observable_1.Observable
            .merge(createRenderer$, resizeRenderer$, clearRenderer$)
            .subscribe(this._rendererOperation$);
        var renderCollectionEmpty$ = this._renderCollection$
            .filter(function (hashes) {
            return Object.keys(hashes).length === 0;
        })
            .share();
        renderCollectionEmpty$
            .subscribe(function (hashes) {
            if (_this._renderFrameSubscription == null) {
                return;
            }
            _this._renderFrameSubscription.unsubscribe();
            _this._renderFrameSubscription = null;
            _this._renderFrameSubscribe();
        });
        renderCollectionEmpty$
            .map(function (hashes) {
            return function (eraser) {
                eraser.needsRender = true;
                return eraser;
            };
        })
            .subscribe(this._eraserOperation$);
    }
    Object.defineProperty(GLRenderer.prototype, "render$", {
        get: function () {
            return this._render$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLRenderer.prototype, "webGLRenderer$", {
        get: function () {
            return this._webGLRenderer$;
        },
        enumerable: true,
        configurable: true
    });
    GLRenderer.prototype.clear = function (name) {
        this._clear$.next(name);
    };
    GLRenderer.prototype._renderFrameSubscribe = function () {
        var _this = this;
        this._render$
            .first()
            .map(function (renderHash) {
            return function (irc) {
                irc.needsRender = true;
                return irc;
            };
        })
            .subscribe(function (operation) {
            _this._renderCameraOperation$.next(operation);
        });
        this._renderFrameSubscription = this._render$
            .first()
            .mergeMap(function (hash) {
            return _this._renderService.renderCameraFrame$;
        })
            .subscribe(this._renderFrame$);
    };
    return GLRenderer;
}());
exports.GLRenderer = GLRenderer;
exports.default = GLRenderer;

},{"../Render":297,"../Utils":301,"rxjs/Observable":29,"rxjs/Subject":34,"rxjs/add/observable/combineLatest":38,"rxjs/add/operator/distinctUntilChanged":60,"rxjs/add/operator/filter":63,"rxjs/add/operator/first":65,"rxjs/add/operator/map":67,"rxjs/add/operator/merge":68,"rxjs/add/operator/mergeMap":70,"rxjs/add/operator/scan":78,"rxjs/add/operator/share":79,"rxjs/add/operator/startWith":83,"three":241}],410:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var Geo_1 = require("../Geo");
var Render_1 = require("../Render");
var RenderCamera = /** @class */ (function () {
    function RenderCamera(elementWidth, elementHeight, renderMode) {
        this.alpha = -1;
        this.zoom = 0;
        this._frameId = -1;
        this._changed = false;
        this._changedForFrame = -1;
        this.currentAspect = 1;
        this.currentPano = false;
        this.previousAspect = 1;
        this.previousPano = false;
        this.renderMode = renderMode;
        this._spatial = new Geo_1.Spatial();
        this._camera = new Geo_1.Camera();
        var perspectiveCameraAspect = this._getPerspectiveCameraAspect(elementWidth, elementHeight);
        this._perspective = new THREE.PerspectiveCamera(50, perspectiveCameraAspect, 0.4, 10000);
        this._perspective.matrixAutoUpdate = false;
        this._rotation = { phi: 0, theta: 0 };
    }
    Object.defineProperty(RenderCamera.prototype, "camera", {
        get: function () {
            return this._camera;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderCamera.prototype, "changed", {
        get: function () {
            return this.frameId === this._changedForFrame;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderCamera.prototype, "frameId", {
        get: function () {
            return this._frameId;
        },
        set: function (value) {
            this._frameId = value;
            if (this._changed) {
                this._changed = false;
                this._changedForFrame = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderCamera.prototype, "perspective", {
        get: function () {
            return this._perspective;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderCamera.prototype, "rotation", {
        get: function () {
            return this._rotation;
        },
        enumerable: true,
        configurable: true
    });
    RenderCamera.prototype.updateAspect = function (elementWidth, elementHeight) {
        var perspectiveCameraAspect = this._getPerspectiveCameraAspect(elementWidth, elementHeight);
        this._perspective.aspect = perspectiveCameraAspect;
        this._changed = true;
    };
    RenderCamera.prototype.updateProjection = function () {
        var currentAspect = this._getAspect(this.currentAspect, this.currentPano, this.perspective.aspect);
        var previousAspect = this._getAspect(this.previousAspect, this.previousPano, this.perspective.aspect);
        var aspect = (1 - this.alpha) * previousAspect + this.alpha * currentAspect;
        var verticalFov = this._getVerticalFov(aspect, this._camera.focal, this.zoom);
        this._perspective.fov = verticalFov;
        this._perspective.updateProjectionMatrix();
        this._changed = true;
    };
    RenderCamera.prototype.updatePerspective = function (camera) {
        this._perspective.up.copy(camera.up);
        this._perspective.position.copy(camera.position);
        this._perspective.lookAt(camera.lookat);
        this._perspective.updateMatrix();
        this._perspective.updateMatrixWorld(false);
        this._changed = true;
    };
    RenderCamera.prototype.updateRotation = function (camera) {
        this._rotation = this._getRotation(camera);
    };
    RenderCamera.prototype._getVerticalFov = function (aspect, focal, zoom) {
        return 2 * Math.atan(0.5 / (Math.pow(2, zoom) * aspect * focal)) * 180 / Math.PI;
    };
    RenderCamera.prototype._getAspect = function (nodeAspect, pano, perspectiveCameraAspect) {
        if (pano) {
            return 1;
        }
        var coeff = Math.max(1, 1 / nodeAspect);
        var usePerspective = this.renderMode === Render_1.RenderMode.Letterbox ?
            nodeAspect > perspectiveCameraAspect :
            nodeAspect < perspectiveCameraAspect;
        var aspect = usePerspective ?
            coeff * perspectiveCameraAspect :
            coeff * nodeAspect;
        return aspect;
    };
    RenderCamera.prototype._getPerspectiveCameraAspect = function (elementWidth, elementHeight) {
        return elementWidth === 0 ? 0 : elementWidth / elementHeight;
    };
    RenderCamera.prototype._getRotation = function (camera) {
        var direction = camera.lookat.clone().sub(camera.position);
        var up = camera.up.clone();
        var upProjection = direction.clone().dot(up);
        var planeProjection = direction.clone().sub(up.clone().multiplyScalar(upProjection));
        var phi = Math.atan2(planeProjection.y, planeProjection.x);
        var theta = Math.PI / 2 - this._spatial.angleToPlane(direction.toArray(), [0, 0, 1]);
        return { phi: phi, theta: theta };
    };
    return RenderCamera;
}());
exports.RenderCamera = RenderCamera;
exports.default = RenderCamera;

},{"../Geo":294,"../Render":297,"three":241}],411:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Enumeration for render mode
 * @enum {number}
 * @readonly
 * @description Modes for specifying how rendering is done
 * in the viewer. All modes preserves the original aspect
 * ratio of the images.
 */
var RenderMode;
(function (RenderMode) {
    /**
     * Displays all content within the viewer.
     *
     * @description Black bars shown on both
     * sides of the content. Bars are shown
     * either below and above or to the left
     * and right of the content depending on
     * the aspect ratio relation between the
     * image and the viewer.
     */
    RenderMode[RenderMode["Letterbox"] = 0] = "Letterbox";
    /**
     * Fills the viewer by cropping content.
     *
     * @description Cropping is done either
     * in horizontal or vertical direction
     * depending on the aspect ratio relation
     * between the image and the viewer.
     */
    RenderMode[RenderMode["Fill"] = 1] = "Fill";
})(RenderMode = exports.RenderMode || (exports.RenderMode = {}));
exports.default = RenderMode;

},{}],412:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("rxjs/Subject");
var BehaviorSubject_1 = require("rxjs/BehaviorSubject");
require("rxjs/add/observable/combineLatest");
require("rxjs/add/operator/do");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/map");
require("rxjs/add/operator/publishReplay");
require("rxjs/add/operator/scan");
require("rxjs/add/operator/skip");
require("rxjs/add/operator/startWith");
require("rxjs/add/operator/withLatestFrom");
var Geo_1 = require("../Geo");
var Render_1 = require("../Render");
var RenderService = /** @class */ (function () {
    function RenderService(element, currentFrame$, renderMode) {
        var _this = this;
        this._element = element;
        this._currentFrame$ = currentFrame$;
        this._spatial = new Geo_1.Spatial();
        renderMode = renderMode != null ? renderMode : Render_1.RenderMode.Fill;
        this._resize$ = new Subject_1.Subject();
        this._renderCameraOperation$ = new Subject_1.Subject();
        this._size$ =
            new BehaviorSubject_1.BehaviorSubject({
                height: this._element.offsetHeight,
                width: this._element.offsetWidth,
            });
        this._resize$
            .map(function () {
            return { height: _this._element.offsetHeight, width: _this._element.offsetWidth };
        })
            .subscribe(this._size$);
        this._renderMode$ = new BehaviorSubject_1.BehaviorSubject(renderMode);
        this._renderCameraHolder$ = this._renderCameraOperation$
            .startWith(function (rc) {
            return rc;
        })
            .scan(function (rc, operation) {
            return operation(rc);
        }, new Render_1.RenderCamera(this._element.offsetWidth, this._element.offsetHeight, renderMode))
            .publishReplay(1)
            .refCount();
        this._renderCameraFrame$ = this._currentFrame$
            .withLatestFrom(this._renderCameraHolder$, function (frame, renderCamera) {
            return [frame, renderCamera];
        })
            .do(function (args) {
            var frame = args[0];
            var rc = args[1];
            var camera = frame.state.camera;
            if (rc.alpha !== frame.state.alpha ||
                rc.zoom !== frame.state.zoom ||
                rc.camera.diff(camera) > 1e-9) {
                var currentTransform = frame.state.currentTransform;
                var previousTransform = frame.state.previousTransform != null ?
                    frame.state.previousTransform :
                    frame.state.currentTransform;
                var previousNode = frame.state.previousNode != null ?
                    frame.state.previousNode :
                    frame.state.currentNode;
                rc.currentAspect = currentTransform.basicAspect;
                rc.currentPano = frame.state.currentNode.pano;
                rc.previousAspect = previousTransform.basicAspect;
                rc.previousPano = previousNode.pano;
                rc.alpha = frame.state.alpha;
                rc.zoom = frame.state.zoom;
                rc.camera.copy(camera);
                rc.updatePerspective(camera);
                rc.updateRotation(camera);
                rc.updateProjection();
            }
            rc.frameId = frame.id;
        })
            .map(function (args) {
            return args[1];
        })
            .publishReplay(1)
            .refCount();
        this._renderCamera$ = this._renderCameraFrame$
            .filter(function (rc) {
            return rc.changed;
        })
            .publishReplay(1)
            .refCount();
        this._bearing$ = this._renderCamera$
            .map(function (renderCamera) {
            var bearing = _this._spatial.radToDeg(_this._spatial.azimuthalToBearing(renderCamera.rotation.phi));
            return _this._spatial.wrap(bearing, 0, 360);
        })
            .publishReplay(1)
            .refCount();
        this._size$
            .skip(1)
            .map(function (size) {
            return function (rc) {
                rc.updateAspect(size.width, size.height);
                rc.updateProjection();
                return rc;
            };
        })
            .subscribe(this._renderCameraOperation$);
        this._renderMode$
            .skip(1)
            .map(function (rm) {
            return function (rc) {
                rc.renderMode = rm;
                rc.updateProjection();
                return rc;
            };
        })
            .subscribe(this._renderCameraOperation$);
        this._bearing$.subscribe(function () { });
        this._renderCameraHolder$.subscribe(function () { });
        this._size$.subscribe(function () { });
        this._renderMode$.subscribe(function () { });
        this._renderCamera$.subscribe(function () { });
        this._renderCameraFrame$.subscribe(function () { });
    }
    Object.defineProperty(RenderService.prototype, "bearing$", {
        get: function () {
            return this._bearing$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderService.prototype, "element", {
        get: function () {
            return this._element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderService.prototype, "resize$", {
        get: function () {
            return this._resize$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderService.prototype, "size$", {
        get: function () {
            return this._size$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderService.prototype, "renderMode$", {
        get: function () {
            return this._renderMode$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderService.prototype, "renderCameraFrame$", {
        get: function () {
            return this._renderCameraFrame$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderService.prototype, "renderCamera$", {
        get: function () {
            return this._renderCamera$;
        },
        enumerable: true,
        configurable: true
    });
    return RenderService;
}());
exports.RenderService = RenderService;
exports.default = RenderService;

},{"../Geo":294,"../Render":297,"rxjs/BehaviorSubject":26,"rxjs/Subject":34,"rxjs/add/observable/combineLatest":38,"rxjs/add/operator/do":61,"rxjs/add/operator/filter":63,"rxjs/add/operator/map":67,"rxjs/add/operator/publishReplay":74,"rxjs/add/operator/scan":78,"rxjs/add/operator/skip":80,"rxjs/add/operator/startWith":83,"rxjs/add/operator/withLatestFrom":90}],413:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var State;
(function (State) {
    State[State["Traversing"] = 0] = "Traversing";
    State[State["Waiting"] = 1] = "Waiting";
})(State = exports.State || (exports.State = {}));
exports.default = State;

},{}],414:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var State_1 = require("../State");
var Geo_1 = require("../Geo");
var StateContext = /** @class */ (function () {
    function StateContext(transitionMode) {
        this._state = new State_1.TraversingState({
            alpha: 1,
            camera: new Geo_1.Camera(),
            currentIndex: -1,
            reference: { alt: 0, lat: 0, lon: 0 },
            trajectory: [],
            transitionMode: transitionMode == null ? State_1.TransitionMode.Default : transitionMode,
            zoom: 0,
        });
    }
    StateContext.prototype.traverse = function () {
        this._state = this._state.traverse();
    };
    StateContext.prototype.wait = function () {
        this._state = this._state.wait();
    };
    Object.defineProperty(StateContext.prototype, "state", {
        get: function () {
            if (this._state instanceof State_1.TraversingState) {
                return State_1.State.Traversing;
            }
            else if (this._state instanceof State_1.WaitingState) {
                return State_1.State.Waiting;
            }
            throw new Error("Invalid state");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateContext.prototype, "reference", {
        get: function () {
            return this._state.reference;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateContext.prototype, "alpha", {
        get: function () {
            return this._state.alpha;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateContext.prototype, "camera", {
        get: function () {
            return this._state.camera;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateContext.prototype, "zoom", {
        get: function () {
            return this._state.zoom;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateContext.prototype, "currentNode", {
        get: function () {
            return this._state.currentNode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateContext.prototype, "previousNode", {
        get: function () {
            return this._state.previousNode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateContext.prototype, "currentCamera", {
        get: function () {
            return this._state.currentCamera;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateContext.prototype, "currentTransform", {
        get: function () {
            return this._state.currentTransform;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateContext.prototype, "previousTransform", {
        get: function () {
            return this._state.previousTransform;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateContext.prototype, "trajectory", {
        get: function () {
            return this._state.trajectory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateContext.prototype, "currentIndex", {
        get: function () {
            return this._state.currentIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateContext.prototype, "lastNode", {
        get: function () {
            return this._state.trajectory[this._state.trajectory.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateContext.prototype, "nodesAhead", {
        get: function () {
            return this._state.trajectory.length - 1 - this._state.currentIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateContext.prototype, "motionless", {
        get: function () {
            return this._state.motionless;
        },
        enumerable: true,
        configurable: true
    });
    StateContext.prototype.getCenter = function () {
        return this._state.getCenter();
    };
    StateContext.prototype.setCenter = function (center) {
        this._state.setCenter(center);
    };
    StateContext.prototype.setZoom = function (zoom) {
        this._state.setZoom(zoom);
    };
    StateContext.prototype.update = function (fps) {
        this._state.update(fps);
    };
    StateContext.prototype.append = function (nodes) {
        this._state.append(nodes);
    };
    StateContext.prototype.prepend = function (nodes) {
        this._state.prepend(nodes);
    };
    StateContext.prototype.remove = function (n) {
        this._state.remove(n);
    };
    StateContext.prototype.clear = function () {
        this._state.clear();
    };
    StateContext.prototype.clearPrior = function () {
        this._state.clearPrior();
    };
    StateContext.prototype.cut = function () {
        this._state.cut();
    };
    StateContext.prototype.set = function (nodes) {
        this._state.set(nodes);
    };
    StateContext.prototype.rotate = function (delta) {
        this._state.rotate(delta);
    };
    StateContext.prototype.rotateBasic = function (basicRotation) {
        this._state.rotateBasic(basicRotation);
    };
    StateContext.prototype.rotateBasicUnbounded = function (basicRotation) {
        this._state.rotateBasicUnbounded(basicRotation);
    };
    StateContext.prototype.rotateBasicWithoutInertia = function (basicRotation) {
        this._state.rotateBasicWithoutInertia(basicRotation);
    };
    StateContext.prototype.rotateToBasic = function (basic) {
        this._state.rotateToBasic(basic);
    };
    StateContext.prototype.move = function (delta) {
        this._state.move(delta);
    };
    StateContext.prototype.moveTo = function (delta) {
        this._state.moveTo(delta);
    };
    StateContext.prototype.zoomIn = function (delta, reference) {
        this._state.zoomIn(delta, reference);
    };
    StateContext.prototype.setSpeed = function (speed) {
        this._state.setSpeed(speed);
    };
    StateContext.prototype.setTransitionMode = function (mode) {
        this._state.setTransitionMode(mode);
    };
    return StateContext;
}());
exports.StateContext = StateContext;

},{"../Geo":294,"../State":298}],415:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var BehaviorSubject_1 = require("rxjs/BehaviorSubject");
var Subject_1 = require("rxjs/Subject");
var AnimationFrame_1 = require("rxjs/util/AnimationFrame");
require("rxjs/add/operator/bufferCount");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/do");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/first");
require("rxjs/add/operator/map");
require("rxjs/add/operator/pairwise");
require("rxjs/add/operator/publishReplay");
require("rxjs/add/operator/scan");
require("rxjs/add/operator/startWith");
require("rxjs/add/operator/switchMap");
require("rxjs/add/operator/withLatestFrom");
var State_1 = require("../State");
var StateService = /** @class */ (function () {
    function StateService(transitionMode) {
        var _this = this;
        this._appendNode$ = new Subject_1.Subject();
        this._start$ = new Subject_1.Subject();
        this._frame$ = new Subject_1.Subject();
        this._fpsSampleRate = 30;
        this._contextOperation$ = new BehaviorSubject_1.BehaviorSubject(function (context) {
            return context;
        });
        this._context$ = this._contextOperation$
            .scan(function (context, operation) {
            return operation(context);
        }, new State_1.StateContext(transitionMode))
            .publishReplay(1)
            .refCount();
        this._state$ = this._context$
            .map(function (context) {
            return context.state;
        })
            .distinctUntilChanged()
            .publishReplay(1)
            .refCount();
        this._fps$ = this._start$
            .switchMap(function () {
            return _this._frame$
                .bufferCount(1, _this._fpsSampleRate)
                .map(function (frameIds) {
                return new Date().getTime();
            })
                .pairwise()
                .map(function (times) {
                return Math.max(20, 1000 * _this._fpsSampleRate / (times[1] - times[0]));
            })
                .startWith(60);
        })
            .share();
        this._currentState$ = this._frame$
            .withLatestFrom(this._fps$, this._context$, function (frameId, fps, context) {
            return [frameId, fps, context];
        })
            .filter(function (fc) {
            return fc[2].currentNode != null;
        })
            .do(function (fc) {
            fc[2].update(fc[1]);
        })
            .map(function (fc) {
            return { fps: fc[1], id: fc[0], state: fc[2] };
        })
            .share();
        this._lastState$ = this._currentState$
            .publishReplay(1)
            .refCount();
        var nodeChanged$ = this._currentState$
            .distinctUntilChanged(undefined, function (f) {
            return f.state.currentNode.key;
        })
            .publishReplay(1)
            .refCount();
        var nodeChangedSubject$ = new Subject_1.Subject();
        nodeChanged$
            .subscribe(nodeChangedSubject$);
        this._currentKey$ = new BehaviorSubject_1.BehaviorSubject(null);
        nodeChangedSubject$
            .map(function (f) {
            return f.state.currentNode.key;
        })
            .subscribe(this._currentKey$);
        this._currentNode$ = nodeChangedSubject$
            .map(function (f) {
            return f.state.currentNode;
        })
            .publishReplay(1)
            .refCount();
        this._currentCamera$ = nodeChangedSubject$
            .map(function (f) {
            return f.state.currentCamera;
        })
            .publishReplay(1)
            .refCount();
        this._currentTransform$ = nodeChangedSubject$
            .map(function (f) {
            return f.state.currentTransform;
        })
            .publishReplay(1)
            .refCount();
        this._reference$ = nodeChangedSubject$
            .map(function (f) {
            return f.state.reference;
        })
            .distinctUntilChanged(function (r1, r2) {
            return r1.lat === r2.lat && r1.lon === r2.lon;
        }, function (reference) {
            return { lat: reference.lat, lon: reference.lon };
        })
            .publishReplay(1)
            .refCount();
        this._currentNodeExternal$ = nodeChanged$
            .map(function (f) {
            return f.state.currentNode;
        })
            .publishReplay(1)
            .refCount();
        this._appendNode$
            .map(function (node) {
            return function (context) {
                context.append([node]);
                return context;
            };
        })
            .subscribe(this._contextOperation$);
        this._inMotionOperation$ = new Subject_1.Subject();
        nodeChanged$
            .map(function (frame) {
            return true;
        })
            .subscribe(this._inMotionOperation$);
        this._inMotionOperation$
            .distinctUntilChanged()
            .filter(function (moving) {
            return moving;
        })
            .switchMap(function (moving) {
            return _this._currentState$
                .filter(function (frame) {
                return frame.state.nodesAhead === 0;
            })
                .map(function (frame) {
                return [frame.state.camera.clone(), frame.state.zoom];
            })
                .pairwise()
                .map(function (pair) {
                var c1 = pair[0][0];
                var c2 = pair[1][0];
                var z1 = pair[0][1];
                var z2 = pair[1][1];
                return c1.diff(c2) > 1e-5 || Math.abs(z1 - z2) > 1e-5;
            })
                .first(function (changed) {
                return !changed;
            });
        })
            .subscribe(this._inMotionOperation$);
        this._inMotion$ = this._inMotionOperation$
            .distinctUntilChanged()
            .publishReplay(1)
            .refCount();
        this._inTranslationOperation$ = new Subject_1.Subject();
        nodeChanged$
            .map(function (frame) {
            return true;
        })
            .subscribe(this._inTranslationOperation$);
        this._inTranslationOperation$
            .distinctUntilChanged()
            .filter(function (inTranslation) {
            return inTranslation;
        })
            .switchMap(function (inTranslation) {
            return _this._currentState$
                .filter(function (frame) {
                return frame.state.nodesAhead === 0;
            })
                .map(function (frame) {
                return frame.state.camera.position.clone();
            })
                .pairwise()
                .map(function (pair) {
                return pair[0].distanceToSquared(pair[1]) !== 0;
            })
                .first(function (changed) {
                return !changed;
            });
        })
            .subscribe(this._inTranslationOperation$);
        this._inTranslation$ = this._inTranslationOperation$
            .distinctUntilChanged()
            .publishReplay(1)
            .refCount();
        this._state$.subscribe(function () { });
        this._currentNode$.subscribe(function () { });
        this._currentCamera$.subscribe(function () { });
        this._currentTransform$.subscribe(function () { });
        this._reference$.subscribe(function () { });
        this._currentNodeExternal$.subscribe(function () { });
        this._lastState$.subscribe(function () { });
        this._inMotion$.subscribe(function () { });
        this._inTranslation$.subscribe(function () { });
        this._frameId = null;
        this._frameGenerator = new AnimationFrame_1.RequestAnimationFrameDefinition(window);
    }
    Object.defineProperty(StateService.prototype, "currentState$", {
        get: function () {
            return this._currentState$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "currentNode$", {
        get: function () {
            return this._currentNode$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "currentKey$", {
        get: function () {
            return this._currentKey$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "currentNodeExternal$", {
        get: function () {
            return this._currentNodeExternal$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "currentCamera$", {
        get: function () {
            return this._currentCamera$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "currentTransform$", {
        get: function () {
            return this._currentTransform$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "state$", {
        get: function () {
            return this._state$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "reference$", {
        get: function () {
            return this._reference$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "inMotion$", {
        get: function () {
            return this._inMotion$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "inTranslation$", {
        get: function () {
            return this._inTranslation$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "appendNode$", {
        get: function () {
            return this._appendNode$;
        },
        enumerable: true,
        configurable: true
    });
    StateService.prototype.traverse = function () {
        this._inMotionOperation$.next(true);
        this._invokeContextOperation(function (context) { context.traverse(); });
    };
    StateService.prototype.wait = function () {
        this._invokeContextOperation(function (context) { context.wait(); });
    };
    StateService.prototype.appendNodes = function (nodes) {
        this._invokeContextOperation(function (context) { context.append(nodes); });
    };
    StateService.prototype.prependNodes = function (nodes) {
        this._invokeContextOperation(function (context) { context.prepend(nodes); });
    };
    StateService.prototype.removeNodes = function (n) {
        this._invokeContextOperation(function (context) { context.remove(n); });
    };
    StateService.prototype.clearNodes = function () {
        this._invokeContextOperation(function (context) { context.clear(); });
    };
    StateService.prototype.clearPriorNodes = function () {
        this._invokeContextOperation(function (context) { context.clearPrior(); });
    };
    StateService.prototype.cutNodes = function () {
        this._invokeContextOperation(function (context) { context.cut(); });
    };
    StateService.prototype.setNodes = function (nodes) {
        this._invokeContextOperation(function (context) { context.set(nodes); });
    };
    StateService.prototype.rotate = function (delta) {
        this._inMotionOperation$.next(true);
        this._invokeContextOperation(function (context) { context.rotate(delta); });
    };
    StateService.prototype.rotateBasic = function (basicRotation) {
        this._inMotionOperation$.next(true);
        this._invokeContextOperation(function (context) { context.rotateBasic(basicRotation); });
    };
    StateService.prototype.rotateBasicUnbounded = function (basicRotation) {
        this._inMotionOperation$.next(true);
        this._invokeContextOperation(function (context) { context.rotateBasicUnbounded(basicRotation); });
    };
    StateService.prototype.rotateBasicWithoutInertia = function (basicRotation) {
        this._inMotionOperation$.next(true);
        this._invokeContextOperation(function (context) { context.rotateBasicWithoutInertia(basicRotation); });
    };
    StateService.prototype.rotateToBasic = function (basic) {
        this._inMotionOperation$.next(true);
        this._invokeContextOperation(function (context) { context.rotateToBasic(basic); });
    };
    StateService.prototype.move = function (delta) {
        this._inMotionOperation$.next(true);
        this._invokeContextOperation(function (context) { context.move(delta); });
    };
    StateService.prototype.moveTo = function (position) {
        this._inMotionOperation$.next(true);
        this._invokeContextOperation(function (context) { context.moveTo(position); });
    };
    /**
     * Change zoom level while keeping the reference point position approximately static.
     *
     * @parameter {number} delta - Change in zoom level.
     * @parameter {Array<number>} reference - Reference point in basic coordinates.
     */
    StateService.prototype.zoomIn = function (delta, reference) {
        this._inMotionOperation$.next(true);
        this._invokeContextOperation(function (context) { context.zoomIn(delta, reference); });
    };
    StateService.prototype.getCenter = function () {
        return this._lastState$
            .first()
            .map(function (frame) {
            return frame.state.getCenter();
        });
    };
    StateService.prototype.getZoom = function () {
        return this._lastState$
            .first()
            .map(function (frame) {
            return frame.state.zoom;
        });
    };
    StateService.prototype.setCenter = function (center) {
        this._inMotionOperation$.next(true);
        this._invokeContextOperation(function (context) { context.setCenter(center); });
    };
    StateService.prototype.setSpeed = function (speed) {
        this._invokeContextOperation(function (context) { context.setSpeed(speed); });
    };
    StateService.prototype.setTransitionMode = function (mode) {
        this._invokeContextOperation(function (context) { context.setTransitionMode(mode); });
    };
    StateService.prototype.setZoom = function (zoom) {
        this._inMotionOperation$.next(true);
        this._invokeContextOperation(function (context) { context.setZoom(zoom); });
    };
    StateService.prototype.start = function () {
        if (this._frameId == null) {
            this._start$.next(null);
            this._frameId = this._frameGenerator.requestAnimationFrame(this._frame.bind(this));
            this._frame$.next(this._frameId);
        }
    };
    StateService.prototype.stop = function () {
        if (this._frameId != null) {
            this._frameGenerator.cancelAnimationFrame(this._frameId);
            this._frameId = null;
        }
    };
    StateService.prototype._invokeContextOperation = function (action) {
        this._contextOperation$
            .next(function (context) {
            action(context);
            return context;
        });
    };
    StateService.prototype._frame = function (time) {
        this._frameId = this._frameGenerator.requestAnimationFrame(this._frame.bind(this));
        this._frame$.next(this._frameId);
    };
    return StateService;
}());
exports.StateService = StateService;

},{"../State":298,"rxjs/BehaviorSubject":26,"rxjs/Subject":34,"rxjs/add/operator/bufferCount":52,"rxjs/add/operator/distinctUntilChanged":60,"rxjs/add/operator/do":61,"rxjs/add/operator/filter":63,"rxjs/add/operator/first":65,"rxjs/add/operator/map":67,"rxjs/add/operator/pairwise":71,"rxjs/add/operator/publishReplay":74,"rxjs/add/operator/scan":78,"rxjs/add/operator/startWith":83,"rxjs/add/operator/switchMap":84,"rxjs/add/operator/withLatestFrom":90,"rxjs/util/AnimationFrame":218}],416:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Enumeration for transition mode
 * @enum {number}
 * @readonly
 * @description Modes for specifying how transitions
 * between nodes are performed.
 */
var TransitionMode;
(function (TransitionMode) {
    /**
     * Default transitions.
     *
     * @description The viewer dynamically determines
     * whether transitions should be performed with or
     * without motion and blending for each transition
     * based on the underlying data.
     */
    TransitionMode[TransitionMode["Default"] = 0] = "Default";
    /**
     * Instantaneous transitions.
     *
     * @description All transitions are performed
     * without motion or blending.
     */
    TransitionMode[TransitionMode["Instantaneous"] = 1] = "Instantaneous";
})(TransitionMode = exports.TransitionMode || (exports.TransitionMode = {}));
exports.default = TransitionMode;

},{}],417:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var Error_1 = require("../../Error");
var Geo_1 = require("../../Geo");
var State_1 = require("../../State");
var StateBase = /** @class */ (function () {
    function StateBase(state) {
        this._spatial = new Geo_1.Spatial();
        this._geoCoords = new Geo_1.GeoCoords();
        this._referenceThreshold = 0.01;
        this._transitionMode = state.transitionMode;
        this._reference = state.reference;
        this._alpha = state.alpha;
        this._camera = state.camera.clone();
        this._zoom = state.zoom;
        this._currentIndex = state.currentIndex;
        this._trajectory = state.trajectory.slice();
        this._trajectoryTransforms = [];
        this._trajectoryCameras = [];
        for (var _i = 0, _a = this._trajectory; _i < _a.length; _i++) {
            var node = _a[_i];
            var translation = this._nodeToTranslation(node);
            var transform = new Geo_1.Transform(node, node.image, translation);
            this._trajectoryTransforms.push(transform);
            this._trajectoryCameras.push(new Geo_1.Camera(transform));
        }
        this._currentNode = this._trajectory.length > 0 ?
            this._trajectory[this._currentIndex] :
            null;
        this._previousNode = this._trajectory.length > 1 && this.currentIndex > 0 ?
            this._trajectory[this._currentIndex - 1] :
            null;
        this._currentCamera = this._trajectoryCameras.length > 0 ?
            this._trajectoryCameras[this._currentIndex].clone() :
            new Geo_1.Camera();
        this._previousCamera = this._trajectoryCameras.length > 1 && this.currentIndex > 0 ?
            this._trajectoryCameras[this._currentIndex - 1].clone() :
            this._currentCamera.clone();
    }
    Object.defineProperty(StateBase.prototype, "reference", {
        get: function () {
            return this._reference;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateBase.prototype, "alpha", {
        get: function () {
            return this._getAlpha();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateBase.prototype, "camera", {
        get: function () {
            return this._camera;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateBase.prototype, "zoom", {
        get: function () {
            return this._zoom;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateBase.prototype, "trajectory", {
        get: function () {
            return this._trajectory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateBase.prototype, "currentIndex", {
        get: function () {
            return this._currentIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateBase.prototype, "currentNode", {
        get: function () {
            return this._currentNode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateBase.prototype, "previousNode", {
        get: function () {
            return this._previousNode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateBase.prototype, "currentCamera", {
        get: function () {
            return this._currentCamera;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateBase.prototype, "currentTransform", {
        get: function () {
            return this._trajectoryTransforms.length > 0 ?
                this._trajectoryTransforms[this.currentIndex] : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateBase.prototype, "previousTransform", {
        get: function () {
            return this._trajectoryTransforms.length > 1 && this.currentIndex > 0 ?
                this._trajectoryTransforms[this.currentIndex - 1] : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateBase.prototype, "motionless", {
        get: function () {
            return this._motionless;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateBase.prototype, "transitionMode", {
        get: function () {
            return this._transitionMode;
        },
        enumerable: true,
        configurable: true
    });
    StateBase.prototype.append = function (nodes) {
        if (nodes.length < 1) {
            throw Error("Trajectory can not be empty");
        }
        if (this._currentIndex < 0) {
            this.set(nodes);
        }
        else {
            this._trajectory = this._trajectory.concat(nodes);
            this._appendToTrajectories(nodes);
        }
    };
    StateBase.prototype.prepend = function (nodes) {
        if (nodes.length < 1) {
            throw Error("Trajectory can not be empty");
        }
        this._trajectory = nodes.slice().concat(this._trajectory);
        this._currentIndex += nodes.length;
        this._setCurrentNode();
        var referenceReset = this._setReference(this._currentNode);
        if (referenceReset) {
            this._setTrajectories();
        }
        else {
            this._prependToTrajectories(nodes);
        }
        this._setCurrentCamera();
    };
    StateBase.prototype.remove = function (n) {
        if (n < 0) {
            throw Error("n must be a positive integer");
        }
        if (this._currentIndex - 1 < n) {
            throw Error("Current and previous nodes can not be removed");
        }
        for (var i = 0; i < n; i++) {
            this._trajectory.shift();
            this._trajectoryTransforms.shift();
            this._trajectoryCameras.shift();
            this._currentIndex--;
        }
        this._setCurrentNode();
    };
    StateBase.prototype.clearPrior = function () {
        if (this._currentIndex > 0) {
            this.remove(this._currentIndex - 1);
        }
    };
    StateBase.prototype.clear = function () {
        this.cut();
        if (this._currentIndex > 0) {
            this.remove(this._currentIndex - 1);
        }
    };
    StateBase.prototype.cut = function () {
        while (this._trajectory.length - 1 > this._currentIndex) {
            this._trajectory.pop();
            this._trajectoryTransforms.pop();
            this._trajectoryCameras.pop();
        }
    };
    StateBase.prototype.set = function (nodes) {
        this._setTrajectory(nodes);
        this._setCurrentNode();
        this._setReference(this._currentNode);
        this._setTrajectories();
        this._setCurrentCamera();
    };
    StateBase.prototype.getCenter = function () {
        return this._currentNode != null ?
            this.currentTransform.projectBasic(this._camera.lookat.toArray()) :
            [0.5, 0.5];
    };
    StateBase.prototype.setTransitionMode = function (mode) {
        this._transitionMode = mode;
    };
    StateBase.prototype._setCurrent = function () {
        this._setCurrentNode();
        var referenceReset = this._setReference(this._currentNode);
        if (referenceReset) {
            this._setTrajectories();
        }
        this._setCurrentCamera();
    };
    StateBase.prototype._setCurrentCamera = function () {
        this._currentCamera = this._trajectoryCameras[this._currentIndex].clone();
        this._previousCamera = this._currentIndex > 0 ?
            this._trajectoryCameras[this._currentIndex - 1].clone() :
            this._currentCamera.clone();
    };
    StateBase.prototype._motionlessTransition = function () {
        var nodesSet = this._currentNode != null && this._previousNode != null;
        return nodesSet && (this._transitionMode === State_1.TransitionMode.Instantaneous || !(this._currentNode.merged &&
            this._previousNode.merged &&
            this._withinOriginalDistance() &&
            this._sameConnectedComponent()));
    };
    StateBase.prototype._setReference = function (node) {
        // do not reset reference if node is within threshold distance
        if (Math.abs(node.latLon.lat - this.reference.lat) < this._referenceThreshold &&
            Math.abs(node.latLon.lon - this.reference.lon) < this._referenceThreshold) {
            return false;
        }
        // do not reset reference if previous node exist and transition is with motion
        if (this._previousNode != null && !this._motionlessTransition()) {
            return false;
        }
        this._reference.lat = node.latLon.lat;
        this._reference.lon = node.latLon.lon;
        this._reference.alt = node.alt;
        return true;
    };
    StateBase.prototype._setCurrentNode = function () {
        this._currentNode = this._trajectory.length > 0 ?
            this._trajectory[this._currentIndex] :
            null;
        this._previousNode = this._currentIndex > 0 ?
            this._trajectory[this._currentIndex - 1] :
            null;
    };
    StateBase.prototype._setTrajectory = function (nodes) {
        if (nodes.length < 1) {
            throw new Error_1.ArgumentMapillaryError("Trajectory can not be empty");
        }
        if (this._currentNode != null) {
            this._trajectory = [this._currentNode].concat(nodes);
            this._currentIndex = 1;
        }
        else {
            this._trajectory = nodes.slice();
            this._currentIndex = 0;
        }
    };
    StateBase.prototype._setTrajectories = function () {
        this._trajectoryTransforms.length = 0;
        this._trajectoryCameras.length = 0;
        this._appendToTrajectories(this._trajectory);
    };
    StateBase.prototype._appendToTrajectories = function (nodes) {
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
            var node = nodes_1[_i];
            if (!node.assetsCached) {
                throw new Error_1.ArgumentMapillaryError("Assets must be cached when node is added to trajectory");
            }
            var translation = this._nodeToTranslation(node);
            var transform = new Geo_1.Transform(node, node.image, translation);
            this._trajectoryTransforms.push(transform);
            this._trajectoryCameras.push(new Geo_1.Camera(transform));
        }
    };
    StateBase.prototype._prependToTrajectories = function (nodes) {
        for (var _i = 0, _a = nodes.reverse(); _i < _a.length; _i++) {
            var node = _a[_i];
            if (!node.assetsCached) {
                throw new Error_1.ArgumentMapillaryError("Assets must be cached when added to trajectory");
            }
            var translation = this._nodeToTranslation(node);
            var transform = new Geo_1.Transform(node, node.image, translation);
            this._trajectoryTransforms.unshift(transform);
            this._trajectoryCameras.unshift(new Geo_1.Camera(transform));
        }
    };
    StateBase.prototype._nodeToTranslation = function (node) {
        var C = this._geoCoords.geodeticToEnu(node.latLon.lat, node.latLon.lon, node.alt, this._reference.lat, this._reference.lon, this._reference.alt);
        var RC = this._spatial.rotate(C, node.rotation);
        return [-RC.x, -RC.y, -RC.z];
    };
    StateBase.prototype._sameConnectedComponent = function () {
        var current = this._currentNode;
        var previous = this._previousNode;
        if (!current ||
            !current.mergeCC ||
            !previous ||
            !previous.mergeCC) {
            return true;
        }
        return current.mergeCC === previous.mergeCC;
    };
    StateBase.prototype._withinOriginalDistance = function () {
        var current = this._currentNode;
        var previous = this._previousNode;
        if (!current || !previous) {
            return true;
        }
        // 50 km/h moves 28m in 2s
        var distance = this._spatial.distanceFromLatLon(current.originalLatLon.lat, current.originalLatLon.lon, previous.originalLatLon.lat, previous.originalLatLon.lon);
        return distance < 25;
    };
    return StateBase;
}());
exports.StateBase = StateBase;

},{"../../Error":293,"../../Geo":294,"../../State":298}],418:[function(require,module,exports){
"use strict";
/// <reference path="../../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var UnitBezier = require("@mapbox/unitbezier");
var State_1 = require("../../State");
var RotationDelta = /** @class */ (function () {
    function RotationDelta(phi, theta) {
        this._phi = phi;
        this._theta = theta;
    }
    Object.defineProperty(RotationDelta.prototype, "phi", {
        get: function () {
            return this._phi;
        },
        set: function (value) {
            this._phi = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RotationDelta.prototype, "theta", {
        get: function () {
            return this._theta;
        },
        set: function (value) {
            this._theta = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RotationDelta.prototype, "isZero", {
        get: function () {
            return this._phi === 0 && this._theta === 0;
        },
        enumerable: true,
        configurable: true
    });
    RotationDelta.prototype.copy = function (delta) {
        this._phi = delta.phi;
        this._theta = delta.theta;
    };
    RotationDelta.prototype.lerp = function (other, alpha) {
        this._phi = (1 - alpha) * this._phi + alpha * other.phi;
        this._theta = (1 - alpha) * this._theta + alpha * other.theta;
    };
    RotationDelta.prototype.multiply = function (value) {
        this._phi *= value;
        this._theta *= value;
    };
    RotationDelta.prototype.threshold = function (value) {
        this._phi = Math.abs(this._phi) > value ? this._phi : 0;
        this._theta = Math.abs(this._theta) > value ? this._theta : 0;
    };
    RotationDelta.prototype.lengthSquared = function () {
        return this._phi * this._phi + this._theta * this._theta;
    };
    RotationDelta.prototype.reset = function () {
        this._phi = 0;
        this._theta = 0;
    };
    return RotationDelta;
}());
var TraversingState = /** @class */ (function (_super) {
    __extends(TraversingState, _super);
    function TraversingState(state) {
        var _this = _super.call(this, state) || this;
        _this._adjustCameras();
        _this._motionless = _this._motionlessTransition();
        _this._baseAlpha = _this._alpha;
        _this._animationSpeed = 1 / 40;
        _this._speedCoefficient = 1;
        _this._unitBezier = new UnitBezier(0.74, 0.67, 0.38, 0.96);
        _this._useBezier = false;
        _this._rotationDelta = new RotationDelta(0, 0);
        _this._requestedRotationDelta = null;
        _this._basicRotation = [0, 0];
        _this._requestedBasicRotation = null;
        _this._requestedBasicRotationUnbounded = null;
        _this._rotationAcceleration = 0.86;
        _this._rotationIncreaseAlpha = 0.97;
        _this._rotationDecreaseAlpha = 0.9;
        _this._rotationThreshold = 1e-3;
        _this._unboundedRotationAlpha = 0.8;
        _this._desiredZoom = state.zoom;
        _this._minZoom = 0;
        _this._maxZoom = 3;
        _this._lookatDepth = 10;
        _this._desiredLookat = null;
        _this._desiredCenter = null;
        return _this;
    }
    TraversingState.prototype.traverse = function () {
        throw new Error("Not implemented");
    };
    TraversingState.prototype.wait = function () {
        return new State_1.WaitingState(this);
    };
    TraversingState.prototype.append = function (nodes) {
        var emptyTrajectory = this._trajectory.length === 0;
        if (emptyTrajectory) {
            this._resetTransition();
        }
        _super.prototype.append.call(this, nodes);
        if (emptyTrajectory) {
            this._setDesiredCenter();
            this._setDesiredZoom();
        }
    };
    TraversingState.prototype.prepend = function (nodes) {
        var emptyTrajectory = this._trajectory.length === 0;
        if (emptyTrajectory) {
            this._resetTransition();
        }
        _super.prototype.prepend.call(this, nodes);
        if (emptyTrajectory) {
            this._setDesiredCenter();
            this._setDesiredZoom();
        }
    };
    TraversingState.prototype.set = function (nodes) {
        _super.prototype.set.call(this, nodes);
        this._desiredLookat = null;
        this._resetTransition();
        this._clearRotation();
        this._setDesiredCenter();
        this._setDesiredZoom();
        if (this._trajectory.length < 3) {
            this._useBezier = true;
        }
    };
    TraversingState.prototype.move = function (delta) {
        throw new Error("Not implemented");
    };
    TraversingState.prototype.moveTo = function (delta) {
        throw new Error("Not implemented");
    };
    TraversingState.prototype.rotate = function (rotationDelta) {
        if (this._currentNode == null) {
            return;
        }
        this._desiredZoom = this._zoom;
        this._desiredLookat = null;
        this._requestedBasicRotation = null;
        if (this._requestedRotationDelta != null) {
            this._requestedRotationDelta.phi = this._requestedRotationDelta.phi + rotationDelta.phi;
            this._requestedRotationDelta.theta = this._requestedRotationDelta.theta + rotationDelta.theta;
        }
        else {
            this._requestedRotationDelta = new RotationDelta(rotationDelta.phi, rotationDelta.theta);
        }
    };
    TraversingState.prototype.rotateBasic = function (basicRotation) {
        if (this._currentNode == null) {
            return;
        }
        this._desiredZoom = this._zoom;
        this._desiredLookat = null;
        this._requestedRotationDelta = null;
        if (this._requestedBasicRotation != null) {
            this._requestedBasicRotation[0] += basicRotation[0];
            this._requestedBasicRotation[1] += basicRotation[1];
            var threshold = 0.05 / Math.pow(2, this._zoom);
            this._requestedBasicRotation[0] =
                this._spatial.clamp(this._requestedBasicRotation[0], -threshold, threshold);
            this._requestedBasicRotation[1] =
                this._spatial.clamp(this._requestedBasicRotation[1], -threshold, threshold);
        }
        else {
            this._requestedBasicRotation = basicRotation.slice();
        }
    };
    TraversingState.prototype.rotateBasicUnbounded = function (basicRotation) {
        if (this._currentNode == null) {
            return;
        }
        if (this._requestedBasicRotationUnbounded != null) {
            this._requestedBasicRotationUnbounded[0] += basicRotation[0];
            this._requestedBasicRotationUnbounded[1] += basicRotation[1];
        }
        else {
            this._requestedBasicRotationUnbounded = basicRotation.slice();
        }
    };
    TraversingState.prototype.rotateBasicWithoutInertia = function (basic) {
        if (this._currentNode == null) {
            return;
        }
        this._desiredZoom = this._zoom;
        this._desiredLookat = null;
        this._requestedRotationDelta = null;
        this._requestedBasicRotation = null;
        var threshold = 0.05 / Math.pow(2, this._zoom);
        var basicRotation = basic.slice();
        basicRotation[0] = this._spatial.clamp(basicRotation[0], -threshold, threshold);
        basicRotation[1] = this._spatial.clamp(basicRotation[1], -threshold, threshold);
        this._applyRotationBasic(basicRotation);
    };
    TraversingState.prototype.rotateToBasic = function (basic) {
        if (this._currentNode == null) {
            return;
        }
        this._desiredZoom = this._zoom;
        this._desiredLookat = null;
        basic[0] = this._spatial.clamp(basic[0], 0, 1);
        basic[1] = this._spatial.clamp(basic[1], 0, 1);
        var lookat = this.currentTransform.unprojectBasic(basic, this._lookatDepth);
        this._currentCamera.lookat.fromArray(lookat);
    };
    TraversingState.prototype.setSpeed = function (speed) {
        this._speedCoefficient = this._spatial.clamp(speed, 0, 10);
    };
    TraversingState.prototype.zoomIn = function (delta, reference) {
        if (this._currentNode == null) {
            return;
        }
        this._desiredZoom = Math.max(this._minZoom, Math.min(this._maxZoom, this._desiredZoom + delta));
        var currentCenter = this.currentTransform.projectBasic(this._currentCamera.lookat.toArray());
        var currentCenterX = currentCenter[0];
        var currentCenterY = currentCenter[1];
        var zoom0 = Math.pow(2, this._zoom);
        var zoom1 = Math.pow(2, this._desiredZoom);
        var refX = reference[0];
        var refY = reference[1];
        if (this.currentTransform.gpano != null &&
            this.currentTransform.gpano.CroppedAreaImageWidthPixels === this.currentTransform.gpano.FullPanoWidthPixels) {
            if (refX - currentCenterX > 0.5) {
                refX = refX - 1;
            }
            else if (currentCenterX - refX > 0.5) {
                refX = 1 + refX;
            }
        }
        var newCenterX = refX - zoom0 / zoom1 * (refX - currentCenterX);
        var newCenterY = refY - zoom0 / zoom1 * (refY - currentCenterY);
        var gpano = this.currentTransform.gpano;
        if (this._currentNode.fullPano) {
            newCenterX = this._spatial.wrap(newCenterX + this._basicRotation[0], 0, 1);
            newCenterY = this._spatial.clamp(newCenterY + this._basicRotation[1], 0.05, 0.95);
        }
        else if (gpano != null &&
            this.currentTransform.gpano.CroppedAreaImageWidthPixels === this.currentTransform.gpano.FullPanoWidthPixels) {
            newCenterX = this._spatial.wrap(newCenterX + this._basicRotation[0], 0, 1);
            newCenterY = this._spatial.clamp(newCenterY + this._basicRotation[1], 0, 1);
        }
        else {
            newCenterX = this._spatial.clamp(newCenterX, 0, 1);
            newCenterY = this._spatial.clamp(newCenterY, 0, 1);
        }
        this._desiredLookat = new THREE.Vector3()
            .fromArray(this.currentTransform.unprojectBasic([newCenterX, newCenterY], this._lookatDepth));
    };
    TraversingState.prototype.setCenter = function (center) {
        this._desiredLookat = null;
        this._requestedRotationDelta = null;
        this._requestedBasicRotation = null;
        this._desiredZoom = this._zoom;
        var clamped = [
            this._spatial.clamp(center[0], 0, 1),
            this._spatial.clamp(center[1], 0, 1),
        ];
        if (this._currentNode == null) {
            this._desiredCenter = clamped;
            return;
        }
        this._desiredCenter = null;
        var currentLookat = new THREE.Vector3()
            .fromArray(this.currentTransform.unprojectBasic(clamped, this._lookatDepth));
        var previousTransform = this.previousTransform != null ?
            this.previousTransform :
            this.currentTransform;
        var previousLookat = new THREE.Vector3()
            .fromArray(previousTransform.unprojectBasic(clamped, this._lookatDepth));
        this._currentCamera.lookat.copy(currentLookat);
        this._previousCamera.lookat.copy(previousLookat);
    };
    TraversingState.prototype.setZoom = function (zoom) {
        this._desiredLookat = null;
        this._requestedRotationDelta = null;
        this._requestedBasicRotation = null;
        this._zoom = this._spatial.clamp(zoom, this._minZoom, this._maxZoom);
        this._desiredZoom = this._zoom;
    };
    TraversingState.prototype.update = function (fps) {
        if (this._alpha === 1 && this._currentIndex + this._alpha < this._trajectory.length) {
            this._currentIndex += 1;
            this._useBezier = this._trajectory.length < 3 &&
                this._currentIndex + 1 === this._trajectory.length;
            this._setCurrent();
            this._resetTransition();
            this._clearRotation();
            this._desiredZoom = this._currentNode.fullPano ? this._zoom : 0;
            this._desiredLookat = null;
        }
        var animationSpeed = this._animationSpeed * (60 / fps);
        this._baseAlpha = Math.min(1, this._baseAlpha + this._speedCoefficient * animationSpeed);
        if (this._useBezier) {
            this._alpha = this._unitBezier.solve(this._baseAlpha);
        }
        else {
            this._alpha = this._baseAlpha;
        }
        this._updateRotation();
        if (!this._rotationDelta.isZero) {
            this._applyRotation(this._previousCamera);
            this._applyRotation(this._currentCamera);
        }
        this._updateRotationBasic();
        if (this._basicRotation[0] !== 0 || this._basicRotation[1] !== 0) {
            this._applyRotationBasic(this._basicRotation);
        }
        this._updateZoom(animationSpeed);
        this._updateLookat(animationSpeed);
        this._camera.lerpCameras(this._previousCamera, this._currentCamera, this.alpha);
    };
    TraversingState.prototype._getAlpha = function () {
        return this._motionless ? Math.ceil(this._alpha) : this._alpha;
    };
    TraversingState.prototype._setCurrentCamera = function () {
        _super.prototype._setCurrentCamera.call(this);
        this._adjustCameras();
    };
    TraversingState.prototype._adjustCameras = function () {
        if (this._previousNode == null) {
            return;
        }
        var lookat = this._camera.lookat.clone().sub(this._camera.position);
        this._previousCamera.lookat.copy(lookat.clone().add(this._previousCamera.position));
        if (this._currentNode.fullPano) {
            this._currentCamera.lookat.copy(lookat.clone().add(this._currentCamera.position));
        }
    };
    TraversingState.prototype._resetTransition = function () {
        this._alpha = 0;
        this._baseAlpha = 0;
        this._motionless = this._motionlessTransition();
    };
    TraversingState.prototype._applyRotation = function (camera) {
        if (camera == null) {
            return;
        }
        var q = new THREE.Quaternion().setFromUnitVectors(camera.up, new THREE.Vector3(0, 0, 1));
        var qInverse = q.clone().inverse();
        var offset = new THREE.Vector3();
        offset.copy(camera.lookat).sub(camera.position);
        offset.applyQuaternion(q);
        var length = offset.length();
        var phi = Math.atan2(offset.y, offset.x);
        phi += this._rotationDelta.phi;
        var theta = Math.atan2(Math.sqrt(offset.x * offset.x + offset.y * offset.y), offset.z);
        theta += this._rotationDelta.theta;
        theta = Math.max(0.1, Math.min(Math.PI - 0.1, theta));
        offset.x = Math.sin(theta) * Math.cos(phi);
        offset.y = Math.sin(theta) * Math.sin(phi);
        offset.z = Math.cos(theta);
        offset.applyQuaternion(qInverse);
        camera.lookat.copy(camera.position).add(offset.multiplyScalar(length));
    };
    TraversingState.prototype._applyRotationBasic = function (basicRotation) {
        var currentNode = this._currentNode;
        var previousNode = this._previousNode != null ?
            this.previousNode :
            this.currentNode;
        var currentCamera = this._currentCamera;
        var previousCamera = this._previousCamera;
        var currentTransform = this.currentTransform;
        var previousTransform = this.previousTransform != null ?
            this.previousTransform :
            this.currentTransform;
        var currentBasic = currentTransform.projectBasic(currentCamera.lookat.toArray());
        var previousBasic = previousTransform.projectBasic(previousCamera.lookat.toArray());
        var currentGPano = currentTransform.gpano;
        var previousGPano = previousTransform.gpano;
        if (currentNode.fullPano) {
            currentBasic[0] = this._spatial.wrap(currentBasic[0] + basicRotation[0], 0, 1);
            currentBasic[1] = this._spatial.clamp(currentBasic[1] + basicRotation[1], 0.05, 0.95);
        }
        else if (currentGPano != null &&
            currentTransform.gpano.CroppedAreaImageWidthPixels === currentTransform.gpano.FullPanoWidthPixels) {
            currentBasic[0] = this._spatial.wrap(currentBasic[0] + basicRotation[0], 0, 1);
            currentBasic[1] = this._spatial.clamp(currentBasic[1] + basicRotation[1], 0, 1);
        }
        else {
            currentBasic[0] = this._spatial.clamp(currentBasic[0] + basicRotation[0], 0, 1);
            currentBasic[1] = this._spatial.clamp(currentBasic[1] + basicRotation[1], 0, 1);
        }
        if (previousNode.fullPano) {
            previousBasic[0] = this._spatial.wrap(previousBasic[0] + basicRotation[0], 0, 1);
            previousBasic[1] = this._spatial.clamp(previousBasic[1] + basicRotation[1], 0.05, 0.95);
        }
        else if (previousGPano != null &&
            previousTransform.gpano.CroppedAreaImageWidthPixels === previousTransform.gpano.FullPanoWidthPixels) {
            previousBasic[0] = this._spatial.wrap(previousBasic[0] + basicRotation[0], 0, 1);
            previousBasic[1] = this._spatial.clamp(previousBasic[1] + basicRotation[1], 0, 1);
        }
        else {
            previousBasic[0] = this._spatial.clamp(previousBasic[0] + basicRotation[0], 0, 1);
            previousBasic[1] = this._spatial.clamp(currentBasic[1] + basicRotation[1], 0, 1);
        }
        var currentLookat = currentTransform.unprojectBasic(currentBasic, this._lookatDepth);
        currentCamera.lookat.fromArray(currentLookat);
        var previousLookat = previousTransform.unprojectBasic(previousBasic, this._lookatDepth);
        previousCamera.lookat.fromArray(previousLookat);
    };
    TraversingState.prototype._updateZoom = function (animationSpeed) {
        var diff = this._desiredZoom - this._zoom;
        var sign = diff > 0 ? 1 : diff < 0 ? -1 : 0;
        if (diff === 0) {
            return;
        }
        else if (Math.abs(diff) < 2e-3) {
            this._zoom = this._desiredZoom;
            if (this._desiredLookat != null) {
                this._desiredLookat = null;
            }
        }
        else {
            this._zoom += sign * Math.max(Math.abs(5 * animationSpeed * diff), 2e-3);
        }
    };
    TraversingState.prototype._updateLookat = function (animationSpeed) {
        if (this._desiredLookat === null) {
            return;
        }
        var diff = this._desiredLookat.distanceToSquared(this._currentCamera.lookat);
        if (Math.abs(diff) < 1e-6) {
            this._currentCamera.lookat.copy(this._desiredLookat);
            this._desiredLookat = null;
        }
        else {
            this._currentCamera.lookat.lerp(this._desiredLookat, 5 * animationSpeed);
        }
    };
    TraversingState.prototype._updateRotation = function () {
        if (this._requestedRotationDelta != null) {
            var length_1 = this._rotationDelta.lengthSquared();
            var requestedLength = this._requestedRotationDelta.lengthSquared();
            if (requestedLength > length_1) {
                this._rotationDelta.lerp(this._requestedRotationDelta, this._rotationIncreaseAlpha);
            }
            else {
                this._rotationDelta.lerp(this._requestedRotationDelta, this._rotationDecreaseAlpha);
            }
            this._requestedRotationDelta = null;
            return;
        }
        if (this._rotationDelta.isZero) {
            return;
        }
        this._rotationDelta.multiply(this._rotationAcceleration);
        this._rotationDelta.threshold(this._rotationThreshold);
    };
    TraversingState.prototype._updateRotationBasic = function () {
        if (this._requestedBasicRotation != null) {
            var x = this._basicRotation[0];
            var y = this._basicRotation[1];
            var reqX = this._requestedBasicRotation[0];
            var reqY = this._requestedBasicRotation[1];
            if (Math.abs(reqX) > Math.abs(x)) {
                this._basicRotation[0] = (1 - this._rotationIncreaseAlpha) * x + this._rotationIncreaseAlpha * reqX;
            }
            else {
                this._basicRotation[0] = (1 - this._rotationDecreaseAlpha) * x + this._rotationDecreaseAlpha * reqX;
            }
            if (Math.abs(reqY) > Math.abs(y)) {
                this._basicRotation[1] = (1 - this._rotationIncreaseAlpha) * y + this._rotationIncreaseAlpha * reqY;
            }
            else {
                this._basicRotation[1] = (1 - this._rotationDecreaseAlpha) * y + this._rotationDecreaseAlpha * reqY;
            }
            this._requestedBasicRotation = null;
            return;
        }
        if (this._requestedBasicRotationUnbounded != null) {
            var reqX = this._requestedBasicRotationUnbounded[0];
            var reqY = this._requestedBasicRotationUnbounded[1];
            if (Math.abs(reqX) > 0) {
                this._basicRotation[0] = (1 - this._unboundedRotationAlpha) * this._basicRotation[0] + this._unboundedRotationAlpha * reqX;
            }
            if (Math.abs(reqY) > 0) {
                this._basicRotation[1] = (1 - this._unboundedRotationAlpha) * this._basicRotation[1] + this._unboundedRotationAlpha * reqY;
            }
            if (this._desiredLookat != null) {
                var desiredBasicLookat = this.currentTransform.projectBasic(this._desiredLookat.toArray());
                desiredBasicLookat[0] += reqX;
                desiredBasicLookat[1] += reqY;
                this._desiredLookat = new THREE.Vector3()
                    .fromArray(this.currentTransform.unprojectBasic(desiredBasicLookat, this._lookatDepth));
            }
            this._requestedBasicRotationUnbounded = null;
        }
        if (this._basicRotation[0] === 0 && this._basicRotation[1] === 0) {
            return;
        }
        this._basicRotation[0] = this._rotationAcceleration * this._basicRotation[0];
        this._basicRotation[1] = this._rotationAcceleration * this._basicRotation[1];
        if (Math.abs(this._basicRotation[0]) < this._rotationThreshold / Math.pow(2, this._zoom) &&
            Math.abs(this._basicRotation[1]) < this._rotationThreshold / Math.pow(2, this._zoom)) {
            this._basicRotation = [0, 0];
        }
    };
    TraversingState.prototype._clearRotation = function () {
        if (this._currentNode.fullPano) {
            return;
        }
        if (this._requestedRotationDelta != null) {
            this._requestedRotationDelta = null;
        }
        if (!this._rotationDelta.isZero) {
            this._rotationDelta.reset();
        }
        if (this._requestedBasicRotation != null) {
            this._requestedBasicRotation = null;
        }
        if (this._basicRotation[0] > 0 || this._basicRotation[1] > 0) {
            this._basicRotation = [0, 0];
        }
    };
    TraversingState.prototype._setDesiredCenter = function () {
        if (this._desiredCenter == null) {
            return;
        }
        var lookatDirection = new THREE.Vector3()
            .fromArray(this.currentTransform.unprojectBasic(this._desiredCenter, this._lookatDepth))
            .sub(this._currentCamera.position);
        this._currentCamera.lookat.copy(this._currentCamera.position.clone().add(lookatDirection));
        this._previousCamera.lookat.copy(this._previousCamera.position.clone().add(lookatDirection));
        this._desiredCenter = null;
    };
    TraversingState.prototype._setDesiredZoom = function () {
        this._desiredZoom =
            this._currentNode.fullPano || this._previousNode == null ?
                this._zoom : 0;
    };
    return TraversingState;
}(State_1.StateBase));
exports.TraversingState = TraversingState;

},{"../../State":298,"@mapbox/unitbezier":2,"three":241}],419:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var State_1 = require("../../State");
var WaitingState = /** @class */ (function (_super) {
    __extends(WaitingState, _super);
    function WaitingState(state) {
        var _this = _super.call(this, state) || this;
        _this._zoom = 0;
        _this._adjustCameras();
        _this._motionless = _this._motionlessTransition();
        return _this;
    }
    WaitingState.prototype.traverse = function () {
        return new State_1.TraversingState(this);
    };
    WaitingState.prototype.wait = function () {
        throw new Error("Not implemented");
    };
    WaitingState.prototype.prepend = function (nodes) {
        _super.prototype.prepend.call(this, nodes);
        this._motionless = this._motionlessTransition();
    };
    WaitingState.prototype.set = function (nodes) {
        _super.prototype.set.call(this, nodes);
        this._motionless = this._motionlessTransition();
    };
    WaitingState.prototype.rotate = function (delta) { return; };
    WaitingState.prototype.rotateBasic = function (basicRotation) { return; };
    WaitingState.prototype.rotateBasicUnbounded = function (basicRotation) { return; };
    WaitingState.prototype.rotateBasicWithoutInertia = function (basicRotation) { return; };
    WaitingState.prototype.rotateToBasic = function (basic) { return; };
    WaitingState.prototype.setSpeed = function (speed) { return; };
    WaitingState.prototype.zoomIn = function (delta, reference) { return; };
    WaitingState.prototype.move = function (delta) {
        this._alpha = Math.max(0, Math.min(1, this._alpha + delta));
    };
    WaitingState.prototype.moveTo = function (position) {
        this._alpha = Math.max(0, Math.min(1, position));
    };
    WaitingState.prototype.update = function (fps) {
        this._camera.lerpCameras(this._previousCamera, this._currentCamera, this.alpha);
    };
    WaitingState.prototype.setCenter = function (center) { return; };
    WaitingState.prototype.setZoom = function (zoom) { return; };
    WaitingState.prototype._getAlpha = function () {
        return this._motionless ? Math.round(this._alpha) : this._alpha;
    };
    WaitingState.prototype._setCurrentCamera = function () {
        _super.prototype._setCurrentCamera.call(this);
        this._adjustCameras();
    };
    WaitingState.prototype._adjustCameras = function () {
        if (this._previousNode == null) {
            return;
        }
        if (this._currentNode.fullPano) {
            var lookat = this._camera.lookat.clone().sub(this._camera.position);
            this._currentCamera.lookat.copy(lookat.clone().add(this._currentCamera.position));
        }
        if (this._previousNode.fullPano) {
            var lookat = this._currentCamera.lookat.clone().sub(this._currentCamera.position);
            this._previousCamera.lookat.copy(lookat.clone().add(this._previousCamera.position));
        }
    };
    return WaitingState;
}(State_1.StateBase));
exports.WaitingState = WaitingState;

},{"../../State":298}],420:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
/**
 * @class ImageTileLoader
 *
 * @classdesc Represents a loader of image tiles.
 */
var ImageTileLoader = /** @class */ (function () {
    /**
     * Create a new node image tile loader instance.
     *
     * @param {string} scheme - The URI scheme.
     * @param {string} host - The URI host.
     * @param {string} [origin] - The origin query param.
     */
    function ImageTileLoader(scheme, host, origin) {
        this._scheme = scheme;
        this._host = host;
        this._origin = origin != null ? "?origin=" + origin : "";
    }
    /**
     * Retrieve an image tile.
     *
     * @description Retrieve an image tile by specifying the area
     * as well as the scaled size.
     *
     * @param {string} identifier - The identifier of the image.
     * @param {number} x - The top left x pixel coordinate for the tile
     * in the original image.
     * @param {number} y - The top left y pixel coordinate for the tile
     * in the original image.
     * @param {number} w - The pixel width of the tile in the original image.
     * @param {number} h - The pixel height of the tile in the original image.
     * @param {number} scaledW - The scaled width of the returned tile.
     * @param {number} scaledH - The scaled height of the returned tile.
     */
    ImageTileLoader.prototype.getTile = function (identifier, x, y, w, h, scaledW, scaledH) {
        var characteristics = "/" + identifier + "/" + x + "," + y + "," + w + "," + h + "/" + scaledW + "," + scaledH + "/0/default.jpg";
        var url = this._scheme +
            "://" +
            this._host +
            characteristics +
            this._origin;
        var xmlHTTP = null;
        return [Observable_1.Observable.create(function (subscriber) {
                xmlHTTP = new XMLHttpRequest();
                xmlHTTP.open("GET", url, true);
                xmlHTTP.responseType = "arraybuffer";
                xmlHTTP.timeout = 15000;
                xmlHTTP.onload = function (event) {
                    if (xmlHTTP.status !== 200) {
                        subscriber.error(new Error("Failed to fetch tile (" + identifier + ": " + x + "," + y + "," + w + "," + h + "). " +
                            ("Status: " + xmlHTTP.status + ", " + xmlHTTP.statusText)));
                        return;
                    }
                    var image = new Image();
                    image.crossOrigin = "Anonymous";
                    image.onload = function (e) {
                        subscriber.next(image);
                        subscriber.complete();
                    };
                    image.onerror = function (error) {
                        subscriber.error(new Error("Failed to load tile image (" + identifier + ": " + x + "," + y + "," + w + "," + h + ")"));
                    };
                    var blob = new Blob([xmlHTTP.response]);
                    image.src = window.URL.createObjectURL(blob);
                };
                xmlHTTP.onerror = function (error) {
                    subscriber.error(new Error("Failed to fetch tile (" + identifier + ": " + x + "," + y + "," + w + "," + h + ")"));
                };
                xmlHTTP.ontimeout = function (error) {
                    subscriber.error(new Error("Tile request timed out (" + identifier + ": " + x + "," + y + "," + w + "," + h + ")"));
                };
                xmlHTTP.onabort = function (event) {
                    subscriber.error(new Error("Tile request was aborted (" + identifier + ": " + x + "," + y + "," + w + "," + h + ")"));
                };
                xmlHTTP.send(null);
            }),
            function () {
                if (xmlHTTP != null) {
                    xmlHTTP.abort();
                }
            },
        ];
    };
    return ImageTileLoader;
}());
exports.ImageTileLoader = ImageTileLoader;
exports.default = ImageTileLoader;

},{"rxjs/Observable":29}],421:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @class ImageTileStore
 *
 * @classdesc Represents a store for image tiles.
 */
var ImageTileStore = /** @class */ (function () {
    /**
     * Create a new node image tile store instance.
     */
    function ImageTileStore() {
        this._images = {};
    }
    /**
     * Add an image tile to the store.
     *
     * @param {HTMLImageElement} image - The image tile.
     * @param {string} key - The identifier for the tile.
     * @param {number} level - The level of the tile.
     */
    ImageTileStore.prototype.addImage = function (image, key, level) {
        if (!(level in this._images)) {
            this._images[level] = {};
        }
        this._images[level][key] = image;
    };
    /**
     * Dispose the store.
     *
     * @description Disposes all cached assets.
     */
    ImageTileStore.prototype.dispose = function () {
        for (var _i = 0, _a = Object.keys(this._images); _i < _a.length; _i++) {
            var level = _a[_i];
            var levelImages = this._images[level];
            for (var _b = 0, _c = Object.keys(levelImages); _b < _c.length; _b++) {
                var key = _c[_b];
                window.URL.revokeObjectURL(levelImages[key].src);
                delete levelImages[key];
            }
            delete this._images[level];
        }
    };
    /**
     * Get an image tile from the store.
     *
     * @param {string} key - The identifier for the tile.
     * @param {number} level - The level of the tile.
     */
    ImageTileStore.prototype.getImage = function (key, level) {
        return this._images[level][key];
    };
    /**
     * Check if an image tile exist in the store.
     *
     * @param {string} key - The identifier for the tile.
     * @param {number} level - The level of the tile.
     */
    ImageTileStore.prototype.hasImage = function (key, level) {
        return level in this._images && key in this._images[level];
    };
    return ImageTileStore;
}());
exports.ImageTileStore = ImageTileStore;
exports.default = ImageTileStore;

},{}],422:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var Geo_1 = require("../Geo");
/**
 * @class RegionOfInterestCalculator
 *
 * @classdesc Represents a calculator for regions of interest.
 */
var RegionOfInterestCalculator = /** @class */ (function () {
    function RegionOfInterestCalculator() {
        this._viewportCoords = new Geo_1.ViewportCoords();
    }
    /**
     * Compute a region of interest based on the current render camera
     * and the viewport size.
     *
     * @param {RenderCamera} renderCamera - Render camera used for unprojections.
     * @param {ISize} size - Viewport size in pixels.
     * @param {Transform} transform - Transform used for projections.
     *
     * @returns {IRegionOfInterest} A region of interest.
     */
    RegionOfInterestCalculator.prototype.computeRegionOfInterest = function (renderCamera, size, transform) {
        var viewportBoundaryPoints = this._viewportBoundaryPoints(4);
        var bbox = this._viewportPointsBoundingBox(viewportBoundaryPoints, renderCamera, transform);
        this._clipBoundingBox(bbox);
        var viewportPixelWidth = 2 / size.width;
        var viewportPixelHeight = 2 / size.height;
        var centralViewportPixel = [
            [-0.5 * viewportPixelWidth, 0.5 * viewportPixelHeight],
            [0.5 * viewportPixelWidth, 0.5 * viewportPixelHeight],
            [0.5 * viewportPixelWidth, -0.5 * viewportPixelHeight],
            [-0.5 * viewportPixelWidth, -0.5 * viewportPixelHeight],
        ];
        var cpbox = this._viewportPointsBoundingBox(centralViewportPixel, renderCamera, transform);
        return {
            bbox: bbox,
            pixelHeight: cpbox.maxY - cpbox.minY,
            pixelWidth: cpbox.maxX - cpbox.minX + (cpbox.minX < cpbox.maxX ? 0 : 1),
        };
    };
    RegionOfInterestCalculator.prototype._viewportBoundaryPoints = function (pointsPerSide) {
        var points = [];
        var os = [[-1, 1], [1, 1], [1, -1], [-1, -1]];
        var ds = [[2, 0], [0, -2], [-2, 0], [0, 2]];
        for (var side = 0; side < 4; ++side) {
            var o = os[side];
            var d = ds[side];
            for (var i = 0; i < pointsPerSide; ++i) {
                points.push([o[0] + d[0] * i / pointsPerSide,
                    o[1] + d[1] * i / pointsPerSide]);
            }
        }
        return points;
    };
    RegionOfInterestCalculator.prototype._viewportPointsBoundingBox = function (viewportPoints, renderCamera, transform) {
        var _this = this;
        var basicPoints = viewportPoints
            .map(function (point) {
            return _this._viewportCoords
                .viewportToBasic(point[0], point[1], transform, renderCamera.perspective);
        });
        if (transform.gpano != null) {
            return this._boundingBoxPano(basicPoints);
        }
        else {
            return this._boundingBox(basicPoints);
        }
    };
    RegionOfInterestCalculator.prototype._boundingBox = function (points) {
        var bbox = {
            maxX: Number.NEGATIVE_INFINITY,
            maxY: Number.NEGATIVE_INFINITY,
            minX: Number.POSITIVE_INFINITY,
            minY: Number.POSITIVE_INFINITY,
        };
        for (var i = 0; i < points.length; ++i) {
            bbox.minX = Math.min(bbox.minX, points[i][0]);
            bbox.maxX = Math.max(bbox.maxX, points[i][0]);
            bbox.minY = Math.min(bbox.minY, points[i][1]);
            bbox.maxY = Math.max(bbox.maxY, points[i][1]);
        }
        return bbox;
    };
    RegionOfInterestCalculator.prototype._boundingBoxPano = function (points) {
        var _this = this;
        var xs = [];
        var ys = [];
        for (var i = 0; i < points.length; ++i) {
            xs.push(points[i][0]);
            ys.push(points[i][1]);
        }
        xs.sort(function (a, b) { return _this._sign(a - b); });
        ys.sort(function (a, b) { return _this._sign(a - b); });
        var intervalX = this._intervalPano(xs);
        return {
            maxX: intervalX[1],
            maxY: ys[ys.length - 1],
            minX: intervalX[0],
            minY: ys[0],
        };
    };
    /**
     * Find the max interval between consecutive numbers.
     * Assumes numbers are between 0 and 1, sorted and that
     * x is equivalent to x + 1.
     */
    RegionOfInterestCalculator.prototype._intervalPano = function (xs) {
        var maxdx = 0;
        var maxi = -1;
        for (var i = 0; i < xs.length - 1; ++i) {
            var dx = xs[i + 1] - xs[i];
            if (dx > maxdx) {
                maxdx = dx;
                maxi = i;
            }
        }
        var loopdx = xs[0] + 1 - xs[xs.length - 1];
        if (loopdx > maxdx) {
            return [xs[0], xs[xs.length - 1]];
        }
        else {
            return [xs[maxi + 1], xs[maxi]];
        }
    };
    RegionOfInterestCalculator.prototype._clipBoundingBox = function (bbox) {
        bbox.minX = Math.max(0, Math.min(1, bbox.minX));
        bbox.maxX = Math.max(0, Math.min(1, bbox.maxX));
        bbox.minY = Math.max(0, Math.min(1, bbox.minY));
        bbox.maxY = Math.max(0, Math.min(1, bbox.maxY));
    };
    RegionOfInterestCalculator.prototype._sign = function (n) {
        return n > 0 ? 1 : n < 0 ? -1 : 0;
    };
    return RegionOfInterestCalculator;
}());
exports.RegionOfInterestCalculator = RegionOfInterestCalculator;
exports.default = RegionOfInterestCalculator;

},{"../Geo":294}],423:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var Subject_1 = require("rxjs/Subject");
/**
 * @class TextureProvider
 *
 * @classdesc Represents a provider of textures.
 */
var TextureProvider = /** @class */ (function () {
    /**
     * Create a new node texture provider instance.
     *
     * @param {string} key - The identifier of the image for which to request tiles.
     * @param {number} width - The full width of the original image.
     * @param {number} height - The full height of the original image.
     * @param {number} tileSize - The size used when requesting tiles.
     * @param {HTMLImageElement} background - Image to use as background.
     * @param {ImageTileLoader} imageTileLoader - Loader for retrieving tiles.
     * @param {ImageTileStore} imageTileStore - Store for saving tiles.
     * @param {THREE.WebGLRenderer} renderer - Renderer used for rendering tiles to texture.
     */
    function TextureProvider(key, width, height, tileSize, background, imageTileLoader, imageTileStore, renderer) {
        this._disposed = false;
        this._key = key;
        if (width <= 0 || height <= 0) {
            console.warn("Original image size (" + width + ", " + height + ") is invalid (" + key + "). Tiles will not be loaded.");
        }
        this._width = width;
        this._height = height;
        this._maxLevel = Math.ceil(Math.log(Math.max(height, width)) / Math.log(2));
        this._currentLevel = -1;
        this._tileSize = tileSize;
        this._updated$ = new Subject_1.Subject();
        this._createdSubject$ = new Subject_1.Subject();
        this._created$ = this._createdSubject$
            .publishReplay(1)
            .refCount();
        this._createdSubscription = this._created$.subscribe(function () { });
        this._hasSubject$ = new Subject_1.Subject();
        this._has$ = this._hasSubject$
            .startWith(false)
            .publishReplay(1)
            .refCount();
        this._hasSubscription = this._has$.subscribe(function () { });
        this._abortFunctions = [];
        this._tileSubscriptions = {};
        this._renderedCurrentLevelTiles = {};
        this._renderedTiles = {};
        this._background = background;
        this._camera = null;
        this._imageTileLoader = imageTileLoader;
        this._imageTileStore = imageTileStore;
        this._renderer = renderer;
        this._renderTarget = null;
        this._roi = null;
    }
    Object.defineProperty(TextureProvider.prototype, "disposed", {
        /**
         * Get disposed.
         *
         * @returns {boolean} Value indicating whether provider has
         * been disposed.
         */
        get: function () {
            return this._disposed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureProvider.prototype, "hasTexture$", {
        /**
         * Get hasTexture$.
         *
         * @returns {Observable<boolean>} Observable emitting
         * values indicating when the existance of a texture
         * changes.
         */
        get: function () {
            return this._has$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureProvider.prototype, "key", {
        /**
         * Get key.
         *
         * @returns {boolean} The identifier of the image for
         * which to render textures.
         */
        get: function () {
            return this._key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureProvider.prototype, "textureUpdated$", {
        /**
         * Get textureUpdated$.
         *
         * @returns {Observable<boolean>} Observable emitting
         * values when an existing texture has been updated.
         */
        get: function () {
            return this._updated$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureProvider.prototype, "textureCreated$", {
        /**
         * Get textureCreated$.
         *
         * @returns {Observable<boolean>} Observable emitting
         * values when a new texture has been created.
         */
        get: function () {
            return this._created$;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Abort all outstanding image tile requests.
     */
    TextureProvider.prototype.abort = function () {
        for (var key in this._tileSubscriptions) {
            if (!this._tileSubscriptions.hasOwnProperty(key)) {
                continue;
            }
            this._tileSubscriptions[key].unsubscribe();
        }
        this._tileSubscriptions = {};
        for (var _i = 0, _a = this._abortFunctions; _i < _a.length; _i++) {
            var abort = _a[_i];
            abort();
        }
        this._abortFunctions = [];
    };
    /**
     * Dispose the provider.
     *
     * @description Disposes all cached assets and
     * aborts all outstanding image tile requests.
     */
    TextureProvider.prototype.dispose = function () {
        if (this._disposed) {
            console.warn("Texture already disposed (" + this._key + ")");
            return;
        }
        this.abort();
        if (this._renderTarget != null) {
            this._renderTarget.dispose();
            this._renderTarget = null;
        }
        this._imageTileStore.dispose();
        this._imageTileStore = null;
        this._background = null;
        this._camera = null;
        this._imageTileLoader = null;
        this._renderer = null;
        this._roi = null;
        this._createdSubscription.unsubscribe();
        this._hasSubscription.unsubscribe();
        this._disposed = true;
    };
    /**
     * Set the region of interest.
     *
     * @description When the region of interest is set the
     * the tile level is determined and tiles for the region
     * are fetched from the store or the loader and renderedLevel
     * to the texture.
     *
     * @param {IRegionOfInterest} roi - Spatial edges to cache.
     */
    TextureProvider.prototype.setRegionOfInterest = function (roi) {
        if (this._width <= 0 || this._height <= 0) {
            return;
        }
        this._roi = roi;
        var width = 1 / this._roi.pixelWidth;
        var height = 1 / this._roi.pixelHeight;
        var size = Math.max(height, width);
        var currentLevel = Math.max(0, Math.min(this._maxLevel, Math.ceil(Math.log(size) / Math.log(2))));
        if (currentLevel !== this._currentLevel) {
            this.abort();
            this._currentLevel = currentLevel;
            if (!(this._currentLevel in this._renderedTiles)) {
                this._renderedTiles[this._currentLevel] = [];
            }
            this._renderedCurrentLevelTiles = {};
            for (var _i = 0, _a = this._renderedTiles[this._currentLevel]; _i < _a.length; _i++) {
                var tile = _a[_i];
                this._renderedCurrentLevelTiles[this._tileKey(this._tileSize, tile)] = true;
            }
        }
        var topLeft = this._getTileCoords([this._roi.bbox.minX, this._roi.bbox.minY]);
        var bottomRight = this._getTileCoords([this._roi.bbox.maxX, this._roi.bbox.maxY]);
        var tiles = this._getTiles(topLeft, bottomRight);
        if (this._camera == null) {
            this._camera = new THREE.OrthographicCamera(-this._width / 2, this._width / 2, this._height / 2, -this._height / 2, -1, 1);
            this._camera.position.z = 1;
            var gl = this._renderer.getContext();
            var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            var backgroundSize = Math.max(this._width, this._height);
            var scale = maxTextureSize > backgroundSize ? 1 : maxTextureSize / backgroundSize;
            var targetWidth = Math.floor(scale * this._width);
            var targetHeight = Math.floor(scale * this._height);
            this._renderTarget = new THREE.WebGLRenderTarget(targetWidth, targetHeight, {
                depthBuffer: false,
                format: THREE.RGBFormat,
                magFilter: THREE.LinearFilter,
                minFilter: THREE.LinearFilter,
                stencilBuffer: false,
            });
            this._renderToTarget(0, 0, this._width, this._height, this._background);
            this._createdSubject$.next(this._renderTarget.texture);
            this._hasSubject$.next(true);
        }
        this._fetchTiles(tiles);
    };
    TextureProvider.prototype.setTileSize = function (tileSize) {
        this._tileSize = tileSize;
    };
    /**
     * Update the image used as background for the texture.
     *
     * @param {HTMLImageElement} background - The background image.
     */
    TextureProvider.prototype.updateBackground = function (background) {
        this._background = background;
    };
    /**
     * Retrieve an image tile.
     *
     * @description Retrieve an image tile and render it to the
     * texture. Add the tile to the store and emit to the updated
     * observable.
     *
     * @param {Array<number>} tile - The tile coordinates.
     * @param {number} level - The tile level.
     * @param {number} x - The top left x pixel coordinate of the tile.
     * @param {number} y - The top left y pixel coordinate of the tile.
     * @param {number} w - The pixel width of the tile.
     * @param {number} h - The pixel height of the tile.
     * @param {number} scaledW - The scaled width of the returned tile.
     * @param {number} scaledH - The scaled height of the returned tile.
     */
    TextureProvider.prototype._fetchTile = function (tile, level, x, y, w, h, scaledX, scaledY) {
        var _this = this;
        var getTile = this._imageTileLoader.getTile(this._key, x, y, w, h, scaledX, scaledY);
        var tile$ = getTile[0];
        var abort = getTile[1];
        this._abortFunctions.push(abort);
        var tileKey = this._tileKey(this._tileSize, tile);
        var subscription = tile$
            .subscribe(function (image) {
            _this._renderToTarget(x, y, w, h, image);
            _this._removeFromDictionary(tileKey, _this._tileSubscriptions);
            _this._removeFromArray(abort, _this._abortFunctions);
            _this._setTileRendered(tile, _this._currentLevel);
            _this._imageTileStore.addImage(image, tileKey, level);
            _this._updated$.next(true);
        }, function (error) {
            _this._removeFromDictionary(tileKey, _this._tileSubscriptions);
            _this._removeFromArray(abort, _this._abortFunctions);
            console.error(error);
        });
        if (!subscription.closed) {
            this._tileSubscriptions[tileKey] = subscription;
        }
    };
    /**
     * Retrieve image tiles.
     *
     * @description Retrieve a image tiles and render them to the
     * texture. Retrieve from store if it exists, otherwise Retrieve
     * from loader.
     *
     * @param {Array<Array<number>>} tiles - Array of tile coordinates to
     * retrieve.
     */
    TextureProvider.prototype._fetchTiles = function (tiles) {
        var tileSize = this._tileSize * Math.pow(2, this._maxLevel - this._currentLevel);
        for (var _i = 0, tiles_1 = tiles; _i < tiles_1.length; _i++) {
            var tile = tiles_1[_i];
            var tileKey = this._tileKey(this._tileSize, tile);
            if (tileKey in this._renderedCurrentLevelTiles ||
                tileKey in this._tileSubscriptions) {
                continue;
            }
            var tileX = tileSize * tile[0];
            var tileY = tileSize * tile[1];
            var tileWidth = tileX + tileSize > this._width ? this._width - tileX : tileSize;
            var tileHeight = tileY + tileSize > this._height ? this._height - tileY : tileSize;
            if (this._imageTileStore.hasImage(tileKey, this._currentLevel)) {
                this._renderToTarget(tileX, tileY, tileWidth, tileHeight, this._imageTileStore.getImage(tileKey, this._currentLevel));
                this._setTileRendered(tile, this._currentLevel);
                this._updated$.next(true);
                continue;
            }
            var scaledX = Math.floor(tileWidth / tileSize * this._tileSize);
            var scaledY = Math.floor(tileHeight / tileSize * this._tileSize);
            this._fetchTile(tile, this._currentLevel, tileX, tileY, tileWidth, tileHeight, scaledX, scaledY);
        }
    };
    /**
     * Get tile coordinates for a point using the current level.
     *
     * @param {Array<number>} point - Point in basic coordinates.
     *
     * @returns {Array<number>} x and y tile coodinates.
     */
    TextureProvider.prototype._getTileCoords = function (point) {
        var tileSize = this._tileSize * Math.pow(2, this._maxLevel - this._currentLevel);
        var maxX = Math.ceil(this._width / tileSize) - 1;
        var maxY = Math.ceil(this._height / tileSize) - 1;
        return [
            Math.min(Math.floor(this._width * point[0] / tileSize), maxX),
            Math.min(Math.floor(this._height * point[1] / tileSize), maxY),
        ];
    };
    /**
     * Get tile coordinates for all tiles contained in a bounding
     * box.
     *
     * @param {Array<number>} topLeft - Top left tile coordinate of bounding box.
     * @param {Array<number>} bottomRight - Bottom right tile coordinate of bounding box.
     *
     * @returns {Array<Array<number>>} Array of x, y tile coodinates.
     */
    TextureProvider.prototype._getTiles = function (topLeft, bottomRight) {
        var xs = [];
        if (topLeft[0] > bottomRight[0]) {
            var tileSize = this._tileSize * Math.pow(2, this._maxLevel - this._currentLevel);
            var maxX = Math.ceil(this._width / tileSize) - 1;
            for (var x = topLeft[0]; x <= maxX; x++) {
                xs.push(x);
            }
            for (var x = 0; x <= bottomRight[0]; x++) {
                xs.push(x);
            }
        }
        else {
            for (var x = topLeft[0]; x <= bottomRight[0]; x++) {
                xs.push(x);
            }
        }
        var tiles = [];
        for (var _i = 0, xs_1 = xs; _i < xs_1.length; _i++) {
            var x = xs_1[_i];
            for (var y = topLeft[1]; y <= bottomRight[1]; y++) {
                tiles.push([x, y]);
            }
        }
        return tiles;
    };
    /**
     * Remove an item from an array if it exists in array.
     *
     * @param {T} item - Item to remove.
     * @param {Array<T>} array - Array from which item should be removed.
     */
    TextureProvider.prototype._removeFromArray = function (item, array) {
        var index = array.indexOf(item);
        if (index !== -1) {
            array.splice(index, 1);
        }
    };
    /**
     * Remove an item from a dictionary.
     *
     * @param {string} key - Key of the item to remove.
     * @param {Object} dict - Dictionary from which item should be removed.
     */
    TextureProvider.prototype._removeFromDictionary = function (key, dict) {
        if (key in dict) {
            delete dict[key];
        }
    };
    /**
     * Render an image tile to the target texture.
     *
     * @param {number} x - The top left x pixel coordinate of the tile.
     * @param {number} y - The top left y pixel coordinate of the tile.
     * @param {number} w - The pixel width of the tile.
     * @param {number} h - The pixel height of the tile.
     * @param {HTMLImageElement} background - The image tile to render.
     */
    TextureProvider.prototype._renderToTarget = function (x, y, w, h, image) {
        var texture = new THREE.Texture(image);
        texture.minFilter = THREE.LinearFilter;
        texture.needsUpdate = true;
        var geometry = new THREE.PlaneGeometry(w, h);
        var material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.FrontSide });
        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = -this._width / 2 + x + w / 2;
        mesh.position.y = this._height / 2 - y - h / 2;
        var scene = new THREE.Scene();
        scene.add(mesh);
        this._renderer.render(scene, this._camera, this._renderTarget);
        this._renderer.setRenderTarget(undefined);
        scene.remove(mesh);
        geometry.dispose();
        material.dispose();
        texture.dispose();
    };
    /**
     * Mark a tile as rendered.
     *
     * @description Clears tiles marked as rendered in other
     * levels of the tile pyramid  if they were rendered on
     * top of or below the tile.
     *
     * @param {Arrary<number>} tile - The tile coordinates.
     * @param {number} level - Tile level of the tile coordinates.
     */
    TextureProvider.prototype._setTileRendered = function (tile, level) {
        var otherLevels = Object.keys(this._renderedTiles)
            .map(function (key) {
            return parseInt(key, 10);
        })
            .filter(function (renderedLevel) {
            return renderedLevel !== level;
        });
        for (var _i = 0, otherLevels_1 = otherLevels; _i < otherLevels_1.length; _i++) {
            var otherLevel = otherLevels_1[_i];
            var scale = Math.pow(2, otherLevel - level);
            if (otherLevel < level) {
                var x = Math.floor(scale * tile[0]);
                var y = Math.floor(scale * tile[1]);
                for (var _a = 0, _b = this._renderedTiles[otherLevel].slice(); _a < _b.length; _a++) {
                    var otherTile = _b[_a];
                    if (otherTile[0] === x && otherTile[1] === y) {
                        var index = this._renderedTiles[otherLevel].indexOf(otherTile);
                        this._renderedTiles[otherLevel].splice(index, 1);
                    }
                }
            }
            else {
                var startX = scale * tile[0];
                var endX = startX + scale - 1;
                var startY = scale * tile[1];
                var endY = startY + scale - 1;
                for (var _c = 0, _d = this._renderedTiles[otherLevel].slice(); _c < _d.length; _c++) {
                    var otherTile = _d[_c];
                    if (otherTile[0] >= startX && otherTile[0] <= endX &&
                        otherTile[1] >= startY && otherTile[1] <= endY) {
                        var index = this._renderedTiles[otherLevel].indexOf(otherTile);
                        this._renderedTiles[otherLevel].splice(index, 1);
                    }
                }
            }
            if (this._renderedTiles[otherLevel].length === 0) {
                delete this._renderedTiles[otherLevel];
            }
        }
        this._renderedTiles[level].push(tile);
        this._renderedCurrentLevelTiles[this._tileKey(this._tileSize, tile)] = true;
    };
    /**
     * Create a tile key from a tile coordinates.
     *
     * @description Tile keys are used as a hash for
     * storing the tile in a dictionary.
     *
     * @param {number} tileSize - The tile size.
     * @param {Arrary<number>} tile - The tile coordinates.
     */
    TextureProvider.prototype._tileKey = function (tileSize, tile) {
        return tileSize + "-" + tile[0] + "-" + tile[1];
    };
    return TextureProvider;
}());
exports.TextureProvider = TextureProvider;
exports.default = TextureProvider;

},{"rxjs/Subject":34,"three":241}],424:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DOM = /** @class */ (function () {
    function DOM(doc) {
        this._document = !!doc ? doc : document;
    }
    Object.defineProperty(DOM.prototype, "document", {
        get: function () {
            return this._document;
        },
        enumerable: true,
        configurable: true
    });
    DOM.prototype.createElement = function (tagName, className, container) {
        var element = this._document.createElement(tagName);
        if (!!className) {
            element.className = className;
        }
        if (!!container) {
            container.appendChild(element);
        }
        return element;
    };
    return DOM;
}());
exports.DOM = DOM;
exports.default = DOM;

},{}],425:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this._events = {};
    }
    /**
     * Subscribe to an event by its name.
     * @param {string }eventType - The name of the event to subscribe to.
     * @param {any} fn - The handler called when the event occurs.
     */
    EventEmitter.prototype.on = function (eventType, fn) {
        this._events[eventType] = this._events[eventType] || [];
        this._events[eventType].push(fn);
        return;
    };
    /**
     * Unsubscribe from an event by its name.
     * @param {string} eventType - The name of the event to subscribe to.
     * @param {any} fn - The handler to remove.
     */
    EventEmitter.prototype.off = function (eventType, fn) {
        if (!eventType) {
            this._events = {};
            return;
        }
        if (!this._listens(eventType)) {
            var idx = this._events[eventType].indexOf(fn);
            if (idx >= 0) {
                this._events[eventType].splice(idx, 1);
            }
            if (this._events[eventType].length) {
                delete this._events[eventType];
            }
        }
        else {
            delete this._events[eventType];
        }
        return;
    };
    EventEmitter.prototype.fire = function (eventType, data) {
        if (!this._listens(eventType)) {
            return;
        }
        for (var _i = 0, _a = this._events[eventType]; _i < _a.length; _i++) {
            var fn = _a[_i];
            fn.call(this, data);
        }
        return;
    };
    EventEmitter.prototype._listens = function (eventType) {
        return !!(this._events && this._events[eventType]);
    };
    return EventEmitter;
}());
exports.EventEmitter = EventEmitter;
exports.default = EventEmitter;

},{}],426:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Viewer_1 = require("../Viewer");
var Settings = /** @class */ (function () {
    function Settings() {
    }
    Settings.setOptions = function (options) {
        Settings._baseImageSize = options.baseImageSize != null ?
            options.baseImageSize :
            Viewer_1.ImageSize.Size640;
        Settings._basePanoramaSize = options.basePanoramaSize != null ?
            options.basePanoramaSize :
            Viewer_1.ImageSize.Size2048;
        Settings._maxImageSize = options.maxImageSize != null ?
            options.maxImageSize :
            Viewer_1.ImageSize.Size2048;
    };
    Object.defineProperty(Settings, "baseImageSize", {
        get: function () {
            return Settings._baseImageSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Settings, "basePanoramaSize", {
        get: function () {
            return Settings._basePanoramaSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Settings, "maxImageSize", {
        get: function () {
            return Settings._maxImageSize;
        },
        enumerable: true,
        configurable: true
    });
    return Settings;
}());
exports.Settings = Settings;
exports.default = Settings;

},{"../Viewer":302}],427:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isBrowser() {
    return typeof window !== "undefined" && typeof document !== "undefined";
}
exports.isBrowser = isBrowser;
function isArraySupported() {
    return !!(Array.prototype &&
        Array.prototype.filter &&
        Array.prototype.indexOf &&
        Array.prototype.map &&
        Array.prototype.reverse);
}
exports.isArraySupported = isArraySupported;
function isFunctionSupported() {
    return !!(Function.prototype && Function.prototype.bind);
}
exports.isFunctionSupported = isFunctionSupported;
function isJSONSupported() {
    return "JSON" in window && "parse" in JSON && "stringify" in JSON;
}
exports.isJSONSupported = isJSONSupported;
function isObjectSupported() {
    return !!(Object.keys &&
        Object.assign);
}
exports.isObjectSupported = isObjectSupported;
var isWebGLSupportedCache = undefined;
function isWebGLSupportedCached() {
    if (isWebGLSupportedCache === undefined) {
        isWebGLSupportedCache = isWebGLSupported();
    }
    return isWebGLSupportedCache;
}
exports.isWebGLSupportedCached = isWebGLSupportedCached;
function isWebGLSupported() {
    var webGLContextAttributes = {
        alpha: false,
        antialias: false,
        depth: true,
        failIfMajorPerformanceCaveat: false,
        premultipliedAlpha: true,
        preserveDrawingBuffer: false,
        stencil: true,
    };
    var canvas = document.createElement("canvas");
    var context = canvas.getContext("webgl", webGLContextAttributes) ||
        canvas.getContext("experimental-webgl", webGLContextAttributes);
    if (!context) {
        return false;
    }
    var requiredExtensions = [
        "OES_standard_derivatives",
    ];
    var supportedExtensions = context.getSupportedExtensions();
    for (var _i = 0, requiredExtensions_1 = requiredExtensions; _i < requiredExtensions_1.length; _i++) {
        var requiredExtension = requiredExtensions_1[_i];
        if (supportedExtensions.indexOf(requiredExtension) === -1) {
            return false;
        }
    }
    return true;
}
exports.isWebGLSupported = isWebGLSupported;

},{}],428:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Urls = /** @class */ (function () {
    function Urls() {
    }
    Object.defineProperty(Urls, "explore", {
        get: function () {
            return Urls._scheme + "://" + Urls._exploreHost;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Urls, "origin", {
        get: function () {
            return Urls._origin;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Urls, "tileScheme", {
        get: function () {
            return Urls._scheme;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Urls, "tileDomain", {
        get: function () {
            return Urls._imageTileHost;
        },
        enumerable: true,
        configurable: true
    });
    Urls.exporeImage = function (key) {
        return Urls._scheme + "://" + Urls._exploreHost + "/app/?pKey=" + key + "&focus=photo";
    };
    Urls.exporeUser = function (username) {
        return Urls._scheme + "://" + Urls._exploreHost + "/app/user/" + username;
    };
    Urls.falcorModel = function (clientId) {
        return Urls._scheme + "://" + Urls._apiHost + "/v3/model.json?client_id=" + clientId;
    };
    Urls.protoMesh = function (key) {
        return Urls._scheme + "://" + Urls._meshHost + "/v2/mesh/" + key;
    };
    Urls.thumbnail = function (key, size, origin) {
        var query = !!origin ? "?origin=" + origin : "";
        return Urls._scheme + "://" + Urls._imageHost + "/" + key + "/thumb-" + size + ".jpg" + query;
    };
    Urls.setOptions = function (options) {
        if (!options) {
            return;
        }
        if (!!options.apiHost) {
            Urls._apiHost = options.apiHost;
        }
        if (!!options.exploreHost) {
            Urls._exploreHost = options.exploreHost;
        }
        if (!!options.imageHost) {
            Urls._imageHost = options.imageHost;
        }
        if (!!options.imageTileHost) {
            Urls._imageTileHost = options.imageTileHost;
        }
        if (!!options.meshHost) {
            Urls._meshHost = options.meshHost;
        }
        if (!!options.scheme) {
            Urls._scheme = options.scheme;
        }
    };
    Urls._apiHost = "a.mapillary.com";
    Urls._exploreHost = "www.mapillary.com";
    Urls._imageHost = "d1cuyjsrcm0gby.cloudfront.net";
    Urls._imageTileHost = "d2qb1440i7l50o.cloudfront.net";
    Urls._meshHost = "d1brzeo354iq2l.cloudfront.net";
    Urls._origin = "mapillary.webgl";
    Urls._scheme = "https";
    return Urls;
}());
exports.Urls = Urls;
exports.default = Urls;

},{}],429:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Enumeration for alignments
 * @enum {number}
 * @readonly
 */
var Alignment;
(function (Alignment) {
    /**
     * Align to bottom
     */
    Alignment[Alignment["Bottom"] = 0] = "Bottom";
    /**
     * Align to bottom left
     */
    Alignment[Alignment["BottomLeft"] = 1] = "BottomLeft";
    /**
     * Align to bottom right
     */
    Alignment[Alignment["BottomRight"] = 2] = "BottomRight";
    /**
     * Align to center
     */
    Alignment[Alignment["Center"] = 3] = "Center";
    /**
     * Align to left
     */
    Alignment[Alignment["Left"] = 4] = "Left";
    /**
     * Align to right
     */
    Alignment[Alignment["Right"] = 5] = "Right";
    /**
     * Align to top
     */
    Alignment[Alignment["Top"] = 6] = "Top";
    /**
     * Align to top left
     */
    Alignment[Alignment["TopLeft"] = 7] = "TopLeft";
    /**
     * Align to top right
     */
    Alignment[Alignment["TopRight"] = 8] = "TopRight";
})(Alignment = exports.Alignment || (exports.Alignment = {}));
exports.default = Alignment;

},{}],430:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
require("rxjs/add/operator/bufferCount");
require("rxjs/add/operator/delay");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/map");
require("rxjs/add/operator/switchMap");
require("rxjs/add/operator/timeout");
var Graph_1 = require("../Graph");
var CacheService = /** @class */ (function () {
    function CacheService(graphService, stateService) {
        this._graphService = graphService;
        this._stateService = stateService;
        this._started = false;
    }
    Object.defineProperty(CacheService.prototype, "started", {
        get: function () {
            return this._started;
        },
        enumerable: true,
        configurable: true
    });
    CacheService.prototype.start = function () {
        var _this = this;
        if (this._started) {
            return;
        }
        this._uncacheSubscription = this._stateService.currentState$
            .distinctUntilChanged(undefined, function (frame) {
            return frame.state.currentNode.key;
        })
            .map(function (frame) {
            var trajectory = frame.state.trajectory;
            var trajectoryKeys = trajectory
                .map(function (n) {
                return n.key;
            });
            var sequenceKey = trajectory[trajectory.length - 1].sequenceKey;
            return [trajectoryKeys, sequenceKey];
        })
            .bufferCount(1, 5)
            .withLatestFrom(this._graphService.graphMode$)
            .switchMap(function (_a) {
            var keepBuffer = _a[0], graphMode = _a[1];
            var keepKeys = keepBuffer[0][0];
            var keepSequenceKey = graphMode === Graph_1.GraphMode.Sequence ?
                keepBuffer[0][1] : undefined;
            return _this._graphService.uncache$(keepKeys, keepSequenceKey);
        })
            .subscribe(function () { });
        this._cacheNodeSubscription = this._graphService.graphMode$
            .skip(1)
            .withLatestFrom(this._stateService.currentState$)
            .switchMap(function (_a) {
            var mode = _a[0], frame = _a[1];
            return mode === Graph_1.GraphMode.Sequence ?
                _this._keyToEdges(frame.state.currentNode.key, function (node) {
                    return node.sequenceEdges$;
                }) :
                Observable_1.Observable
                    .from(frame.state.trajectory
                    .map(function (node) {
                    return node.key;
                })
                    .slice(frame.state.currentIndex))
                    .mergeMap(function (key) {
                    return _this._keyToEdges(key, function (node) {
                        return node.spatialEdges$;
                    });
                }, 6);
        })
            .subscribe(function () { });
        this._started = true;
    };
    CacheService.prototype.stop = function () {
        if (!this._started) {
            return;
        }
        this._uncacheSubscription.unsubscribe();
        this._uncacheSubscription = null;
        this._cacheNodeSubscription.unsubscribe();
        this._cacheNodeSubscription = null;
        this._started = false;
    };
    CacheService.prototype._keyToEdges = function (key, nodeToEdgeMap) {
        return this._graphService.cacheNode$(key)
            .switchMap(nodeToEdgeMap)
            .first(function (status) {
            return status.cached;
        })
            .timeout(15000)
            .catch(function (error) {
            console.error("Failed to cache edges (" + key + ").", error);
            return Observable_1.Observable.empty();
        });
    };
    return CacheService;
}());
exports.CacheService = CacheService;
exports.default = CacheService;

},{"../Graph":295,"rxjs/Observable":29,"rxjs/add/operator/bufferCount":52,"rxjs/add/operator/delay":58,"rxjs/add/operator/distinctUntilChanged":60,"rxjs/add/operator/map":67,"rxjs/add/operator/switchMap":84,"rxjs/add/operator/timeout":89}],431:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Component_1 = require("../Component");
var ComponentController = /** @class */ (function () {
    function ComponentController(container, navigator, observer, key, options, componentService) {
        var _this = this;
        this._container = container;
        this._observer = observer;
        this._navigator = navigator;
        this._options = options != null ? options : {};
        this._key = key;
        this._navigable = key == null;
        this._componentService = !!componentService ?
            componentService :
            new Component_1.ComponentService(this._container, this._navigator);
        this._coverComponent = this._componentService.getCover();
        this._initializeComponents();
        if (key) {
            this._initilizeCoverComponent();
            this._subscribeCoverComponent();
        }
        else {
            this._navigator.movedToKey$
                .first(function (k) {
                return k != null;
            })
                .subscribe(function (k) {
                _this._key = k;
                _this._componentService.deactivateCover();
                _this._coverComponent.configure({ key: _this._key, state: Component_1.CoverState.Hidden });
                _this._subscribeCoverComponent();
                _this._navigator.stateService.start();
                _this._navigator.cacheService.start();
                _this._observer.startEmit();
            });
        }
    }
    Object.defineProperty(ComponentController.prototype, "navigable", {
        get: function () {
            return this._navigable;
        },
        enumerable: true,
        configurable: true
    });
    ComponentController.prototype.get = function (name) {
        return this._componentService.get(name);
    };
    ComponentController.prototype.activate = function (name) {
        this._componentService.activate(name);
    };
    ComponentController.prototype.activateCover = function () {
        this._coverComponent.configure({ state: Component_1.CoverState.Visible });
    };
    ComponentController.prototype.deactivate = function (name) {
        this._componentService.deactivate(name);
    };
    ComponentController.prototype.deactivateCover = function () {
        this._coverComponent.configure({ state: Component_1.CoverState.Loading });
    };
    ComponentController.prototype.resize = function () {
        this._componentService.resize();
    };
    ComponentController.prototype._initializeComponents = function () {
        var options = this._options;
        this._uFalse(options.background, "background");
        this._uFalse(options.debug, "debug");
        this._uFalse(options.image, "image");
        this._uFalse(options.marker, "marker");
        this._uFalse(options.navigation, "navigation");
        this._uFalse(options.popup, "popup");
        this._uFalse(options.route, "route");
        this._uFalse(options.slider, "slider");
        this._uFalse(options.tag, "tag");
        this._uTrue(options.attribution, "attribution");
        this._uTrue(options.bearing, "bearing");
        this._uTrue(options.cache, "cache");
        this._uTrue(options.direction, "direction");
        this._uTrue(options.imagePlane, "imagePlane");
        this._uTrue(options.keyboard, "keyboard");
        this._uTrue(options.loading, "loading");
        this._uTrue(options.mouse, "mouse");
        this._uTrue(options.sequence, "sequence");
        this._uTrue(options.stats, "stats");
    };
    ComponentController.prototype._initilizeCoverComponent = function () {
        var options = this._options;
        this._coverComponent.configure({ key: this._key });
        if (options.cover === undefined || options.cover) {
            this.activateCover();
        }
        else {
            this.deactivateCover();
        }
    };
    ComponentController.prototype._setNavigable = function (navigable) {
        if (this._navigable === navigable) {
            return;
        }
        this._navigable = navigable;
        this._observer.navigable$.next(navigable);
    };
    ComponentController.prototype._subscribeCoverComponent = function () {
        var _this = this;
        this._coverComponent.configuration$.subscribe(function (conf) {
            if (conf.state === Component_1.CoverState.Loading) {
                _this._navigator.stateService.currentKey$
                    .first()
                    .switchMap(function (key) {
                    var keyChanged = key == null || key !== conf.key;
                    if (keyChanged) {
                        _this._setNavigable(false);
                    }
                    return keyChanged ?
                        _this._navigator.moveToKey$(conf.key) :
                        _this._navigator.stateService.currentNode$
                            .first();
                })
                    .subscribe(function (node) {
                    _this._navigator.stateService.start();
                    _this._navigator.cacheService.start();
                    _this._observer.startEmit();
                    _this._coverComponent.configure({ state: Component_1.CoverState.Hidden });
                    _this._componentService.deactivateCover();
                    _this._setNavigable(true);
                }, function (error) {
                    console.error("Failed to deactivate cover.", error);
                    _this._coverComponent.configure({ state: Component_1.CoverState.Visible });
                });
            }
            else if (conf.state === Component_1.CoverState.Visible) {
                _this._observer.stopEmit();
                _this._navigator.stateService.stop();
                _this._navigator.cacheService.stop();
                _this._navigator.playService.stop();
                _this._componentService.activateCover();
                _this._setNavigable(conf.key == null);
            }
        });
    };
    ComponentController.prototype._uFalse = function (option, name) {
        if (option === undefined) {
            this._componentService.deactivate(name);
            return;
        }
        if (typeof option === "boolean") {
            if (option) {
                this._componentService.activate(name);
            }
            else {
                this._componentService.deactivate(name);
            }
            return;
        }
        this._componentService.configure(name, option);
        this._componentService.activate(name);
    };
    ComponentController.prototype._uTrue = function (option, name) {
        if (option === undefined) {
            this._componentService.activate(name);
            return;
        }
        if (typeof option === "boolean") {
            if (option) {
                this._componentService.activate(name);
            }
            else {
                this._componentService.deactivate(name);
            }
            return;
        }
        this._componentService.configure(name, option);
        this._componentService.activate(name);
    };
    return ComponentController;
}());
exports.ComponentController = ComponentController;

},{"../Component":291}],432:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Render_1 = require("../Render");
var Utils_1 = require("../Utils");
var Viewer_1 = require("../Viewer");
var Container = /** @class */ (function () {
    function Container(id, stateService, options, dom) {
        this.id = id;
        this._dom = !!dom ? dom : new Utils_1.DOM();
        this._container = this._dom.document.getElementById(id);
        if (!this._container) {
            throw new Error("Container '" + id + "' not found.");
        }
        this._container.classList.add("mapillary-js");
        this._canvasContainer = this._dom.createElement("div", "mapillary-js-interactive", this._container);
        this._domContainer = this._dom.createElement("div", "mapillary-js-dom", this._container);
        this.renderService = new Render_1.RenderService(this._container, stateService.currentState$, options.renderMode);
        this.glRenderer = new Render_1.GLRenderer(this._canvasContainer, this.renderService, this._dom);
        this.domRenderer = new Render_1.DOMRenderer(this._domContainer, this.renderService, stateService.currentState$);
        this.keyboardService = new Viewer_1.KeyboardService(this._canvasContainer);
        this.mouseService = new Viewer_1.MouseService(this._container, this._canvasContainer, this._domContainer, document);
        this.touchService = new Viewer_1.TouchService(this._canvasContainer, this._domContainer);
        this.spriteService = new Viewer_1.SpriteService(options.sprite);
    }
    Object.defineProperty(Container.prototype, "element", {
        get: function () {
            return this._container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "canvasContainer", {
        get: function () {
            return this._canvasContainer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "domContainer", {
        get: function () {
            return this._domContainer;
        },
        enumerable: true,
        configurable: true
    });
    return Container;
}());
exports.Container = Container;
exports.default = Container;

},{"../Render":297,"../Utils":301,"../Viewer":302}],433:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Enumeration for image sizes
 * @enum {number}
 * @readonly
 * @description Image sizes in pixels for the long side of the image.
 */
var ImageSize;
(function (ImageSize) {
    /**
     * 320 pixels image size
     */
    ImageSize[ImageSize["Size320"] = 320] = "Size320";
    /**
     * 640 pixels image size
     */
    ImageSize[ImageSize["Size640"] = 640] = "Size640";
    /**
     * 1024 pixels image size
     */
    ImageSize[ImageSize["Size1024"] = 1024] = "Size1024";
    /**
     * 2048 pixels image size
     */
    ImageSize[ImageSize["Size2048"] = 2048] = "Size2048";
})(ImageSize = exports.ImageSize || (exports.ImageSize = {}));

},{}],434:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var KeyboardService = /** @class */ (function () {
    function KeyboardService(canvasContainer) {
        this._keyDown$ = Observable_1.Observable.fromEvent(canvasContainer, "keydown");
    }
    Object.defineProperty(KeyboardService.prototype, "keyDown$", {
        get: function () {
            return this._keyDown$;
        },
        enumerable: true,
        configurable: true
    });
    return KeyboardService;
}());
exports.KeyboardService = KeyboardService;
exports.default = KeyboardService;

},{"rxjs/Observable":29}],435:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("underscore");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/operator/debounceTime");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/map");
require("rxjs/add/operator/publishReplay");
require("rxjs/add/operator/scan");
require("rxjs/add/operator/startWith");
var LoadingService = /** @class */ (function () {
    function LoadingService() {
        this._loadersSubject$ = new Subject_1.Subject();
        this._loaders$ = this._loadersSubject$
            .scan(function (loaders, loader) {
            if (loader.task !== undefined) {
                loaders[loader.task] = loader.loading;
            }
            return loaders;
        }, {})
            .startWith({})
            .publishReplay(1)
            .refCount();
    }
    Object.defineProperty(LoadingService.prototype, "loading$", {
        get: function () {
            return this._loaders$
                .map(function (loaders) {
                return _.reduce(loaders, function (loader, acc) {
                    return (loader || acc);
                }, false);
            })
                .debounceTime(100)
                .distinctUntilChanged();
        },
        enumerable: true,
        configurable: true
    });
    LoadingService.prototype.taskLoading$ = function (task) {
        return this._loaders$
            .map(function (loaders) {
            return !!loaders[task];
        })
            .debounceTime(100)
            .distinctUntilChanged();
    };
    LoadingService.prototype.startLoading = function (task) {
        this._loadersSubject$.next({ loading: true, task: task });
    };
    LoadingService.prototype.stopLoading = function (task) {
        this._loadersSubject$.next({ loading: false, task: task });
    };
    return LoadingService;
}());
exports.LoadingService = LoadingService;
exports.default = LoadingService;

},{"rxjs/Subject":34,"rxjs/add/operator/debounceTime":57,"rxjs/add/operator/distinctUntilChanged":60,"rxjs/add/operator/map":67,"rxjs/add/operator/publishReplay":74,"rxjs/add/operator/scan":78,"rxjs/add/operator/startWith":83,"underscore":243}],436:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var BehaviorSubject_1 = require("rxjs/BehaviorSubject");
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/observable/fromEvent");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/map");
require("rxjs/add/operator/merge");
require("rxjs/add/operator/mergeMap");
require("rxjs/add/operator/publishReplay");
require("rxjs/add/operator/scan");
require("rxjs/add/operator/switchMap");
require("rxjs/add/operator/withLatestFrom");
var Geo_1 = require("../Geo");
var MouseService = /** @class */ (function () {
    function MouseService(container, canvasContainer, domContainer, doc, viewportCoords) {
        var _this = this;
        viewportCoords = viewportCoords != null ? viewportCoords : new Geo_1.ViewportCoords();
        this._activeSubject$ = new BehaviorSubject_1.BehaviorSubject(false);
        this._active$ = this._activeSubject$
            .distinctUntilChanged()
            .publishReplay(1)
            .refCount();
        this._claimMouse$ = new Subject_1.Subject();
        this._claimWheel$ = new Subject_1.Subject();
        this._deferPixelClaims$ = new Subject_1.Subject();
        this._deferPixels$ = this._deferPixelClaims$
            .scan(function (claims, claim) {
            if (claim.deferPixels == null) {
                delete claims[claim.name];
            }
            else {
                claims[claim.name] = claim.deferPixels;
            }
            return claims;
        }, {})
            .map(function (claims) {
            var deferPixelMax = -1;
            for (var key in claims) {
                if (!claims.hasOwnProperty(key)) {
                    continue;
                }
                var deferPixels = claims[key];
                if (deferPixels > deferPixelMax) {
                    deferPixelMax = deferPixels;
                }
            }
            return deferPixelMax;
        })
            .startWith(-1)
            .publishReplay(1)
            .refCount();
        this._deferPixels$.subscribe(function () { });
        this._documentMouseMove$ = Observable_1.Observable.fromEvent(doc, "mousemove");
        this._documentMouseUp$ = Observable_1.Observable.fromEvent(doc, "mouseup");
        this._mouseDown$ = Observable_1.Observable.fromEvent(canvasContainer, "mousedown");
        this._mouseLeave$ = Observable_1.Observable.fromEvent(canvasContainer, "mouseleave");
        this._mouseMove$ = Observable_1.Observable.fromEvent(canvasContainer, "mousemove");
        this._mouseUp$ = Observable_1.Observable.fromEvent(canvasContainer, "mouseup");
        this._mouseOut$ = Observable_1.Observable.fromEvent(canvasContainer, "mouseout");
        this._mouseOver$ = Observable_1.Observable.fromEvent(canvasContainer, "mouseover");
        this._domMouseDown$ = Observable_1.Observable.fromEvent(domContainer, "mousedown");
        this._domMouseMove$ = Observable_1.Observable.fromEvent(domContainer, "mousemove");
        this._click$ = Observable_1.Observable.fromEvent(canvasContainer, "click");
        this._contextMenu$ = Observable_1.Observable.fromEvent(canvasContainer, "contextmenu");
        this._dblClick$ = Observable_1.Observable
            .merge(Observable_1.Observable.fromEvent(container, "click"), Observable_1.Observable.fromEvent(canvasContainer, "dblclick"))
            .bufferCount(3, 1)
            .filter(function (events) {
            var event1 = events[0];
            var event2 = events[1];
            var event3 = events[2];
            return event1.type === "click" &&
                event2.type === "click" &&
                event3.type === "dblclick" &&
                event1.target.parentNode === canvasContainer &&
                event2.target.parentNode === canvasContainer;
        })
            .map(function (events) {
            return events[2];
        })
            .share();
        Observable_1.Observable
            .merge(this._domMouseDown$, this._domMouseMove$, this._dblClick$, this._contextMenu$)
            .subscribe(function (event) {
            event.preventDefault();
        });
        this._mouseWheel$ = Observable_1.Observable
            .merge(Observable_1.Observable.fromEvent(canvasContainer, "wheel"), Observable_1.Observable.fromEvent(domContainer, "wheel"))
            .share();
        this._consistentContextMenu$ = Observable_1.Observable
            .merge(this._mouseDown$, this._mouseMove$, this._mouseOut$, this._mouseUp$, this._contextMenu$)
            .bufferCount(3, 1)
            .filter(function (events) {
            // fire context menu on mouse up both on mac and windows
            return events[0].type === "mousedown" &&
                events[1].type === "contextmenu" &&
                events[2].type === "mouseup";
        })
            .map(function (events) {
            return events[1];
        })
            .share();
        var dragStop$ = Observable_1.Observable
            .merge(Observable_1.Observable.fromEvent(window, "blur"), this._documentMouseUp$
            .filter(function (e) {
            return e.button === 0;
        }))
            .share();
        var mouseDragInitiate$ = this._createMouseDragInitiate$(this._mouseDown$, dragStop$, true).share();
        this._mouseDragStart$ = this._createMouseDragStart$(mouseDragInitiate$).share();
        this._mouseDrag$ = this._createMouseDrag$(mouseDragInitiate$, dragStop$).share();
        this._mouseDragEnd$ = this._createMouseDragEnd$(this._mouseDragStart$, dragStop$).share();
        var domMouseDragInitiate$ = this._createMouseDragInitiate$(this._domMouseDown$, dragStop$, false).share();
        this._domMouseDragStart$ = this._createMouseDragStart$(domMouseDragInitiate$).share();
        this._domMouseDrag$ = this._createMouseDrag$(domMouseDragInitiate$, dragStop$).share();
        this._domMouseDragEnd$ = this._createMouseDragEnd$(this._domMouseDragStart$, dragStop$).share();
        this._proximateClick$ = this._mouseDown$
            .switchMap(function (mouseDown) {
            return _this._click$
                .takeUntil(_this._createDeferredMouseMove$(mouseDown, _this._documentMouseMove$))
                .take(1);
        })
            .share();
        this._staticClick$ = this._mouseDown$
            .switchMap(function (e) {
            return _this._click$
                .takeUntil(_this._documentMouseMove$)
                .take(1);
        })
            .share();
        this._mouseDragStart$.subscribe();
        this._mouseDrag$.subscribe();
        this._mouseDragEnd$.subscribe();
        this._domMouseDragStart$.subscribe();
        this._domMouseDrag$.subscribe();
        this._domMouseDragEnd$.subscribe();
        this._staticClick$.subscribe();
        this._mouseOwner$ = this._createOwner$(this._claimMouse$)
            .publishReplay(1)
            .refCount();
        this._wheelOwner$ = this._createOwner$(this._claimWheel$)
            .publishReplay(1)
            .refCount();
        this._mouseOwner$.subscribe(function () { });
        this._wheelOwner$.subscribe(function () { });
    }
    Object.defineProperty(MouseService.prototype, "active$", {
        get: function () {
            return this._active$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "activate$", {
        get: function () {
            return this._activeSubject$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "documentMouseMove$", {
        get: function () {
            return this._documentMouseMove$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "documentMouseUp$", {
        get: function () {
            return this._documentMouseUp$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "domMouseDragStart$", {
        get: function () {
            return this._domMouseDragStart$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "domMouseDrag$", {
        get: function () {
            return this._domMouseDrag$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "domMouseDragEnd$", {
        get: function () {
            return this._domMouseDragEnd$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "domMouseDown$", {
        get: function () {
            return this._domMouseDown$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "domMouseMove$", {
        get: function () {
            return this._domMouseMove$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "mouseOwner$", {
        get: function () {
            return this._mouseOwner$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "mouseDown$", {
        get: function () {
            return this._mouseDown$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "mouseMove$", {
        get: function () {
            return this._mouseMove$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "mouseLeave$", {
        get: function () {
            return this._mouseLeave$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "mouseOut$", {
        get: function () {
            return this._mouseOut$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "mouseOver$", {
        get: function () {
            return this._mouseOver$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "mouseUp$", {
        get: function () {
            return this._mouseUp$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "click$", {
        get: function () {
            return this._click$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "dblClick$", {
        get: function () {
            return this._dblClick$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "contextMenu$", {
        get: function () {
            return this._consistentContextMenu$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "mouseWheel$", {
        get: function () {
            return this._mouseWheel$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "mouseDragStart$", {
        get: function () {
            return this._mouseDragStart$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "mouseDrag$", {
        get: function () {
            return this._mouseDrag$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "mouseDragEnd$", {
        get: function () {
            return this._mouseDragEnd$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "proximateClick$", {
        get: function () {
            return this._proximateClick$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseService.prototype, "staticClick$", {
        get: function () {
            return this._staticClick$;
        },
        enumerable: true,
        configurable: true
    });
    MouseService.prototype.claimMouse = function (name, zindex) {
        this._claimMouse$.next({ name: name, zindex: zindex });
    };
    MouseService.prototype.unclaimMouse = function (name) {
        this._claimMouse$.next({ name: name, zindex: null });
    };
    MouseService.prototype.deferPixels = function (name, deferPixels) {
        this._deferPixelClaims$.next({ name: name, deferPixels: deferPixels });
    };
    MouseService.prototype.undeferPixels = function (name) {
        this._deferPixelClaims$.next({ name: name, deferPixels: null });
    };
    MouseService.prototype.claimWheel = function (name, zindex) {
        this._claimWheel$.next({ name: name, zindex: zindex });
    };
    MouseService.prototype.unclaimWheel = function (name) {
        this._claimWheel$.next({ name: name, zindex: null });
    };
    MouseService.prototype.filtered$ = function (name, observable$) {
        return this._filtered(name, observable$, this._mouseOwner$);
    };
    MouseService.prototype.filteredWheel$ = function (name, observable$) {
        return this._filtered(name, observable$, this._wheelOwner$);
    };
    MouseService.prototype._createDeferredMouseMove$ = function (origin, mouseMove$) {
        return mouseMove$
            .map(function (mouseMove) {
            var deltaX = mouseMove.clientX - origin.clientX;
            var deltaY = mouseMove.clientY - origin.clientY;
            return [mouseMove, Math.sqrt(deltaX * deltaX + deltaY * deltaY)];
        })
            .withLatestFrom(this._deferPixels$)
            .filter(function (_a) {
            var _b = _a[0], mouseMove = _b[0], delta = _b[1], deferPixels = _a[1];
            return delta > deferPixels;
        })
            .map(function (_a) {
            var _b = _a[0], mouseMove = _b[0], delta = _b[1], deferPixels = _a[1];
            return mouseMove;
        });
    };
    MouseService.prototype._createMouseDrag$ = function (mouseDragStartInitiate$, stop$) {
        var _this = this;
        return mouseDragStartInitiate$
            .map(function (_a) {
            var mouseDown = _a[0], mouseMove = _a[1];
            return mouseMove;
        })
            .switchMap(function (mouseMove) {
            return Observable_1.Observable
                .of(mouseMove)
                .concat(_this._documentMouseMove$)
                .takeUntil(stop$);
        });
    };
    MouseService.prototype._createMouseDragEnd$ = function (mouseDragStart$, stop$) {
        return mouseDragStart$
            .switchMap(function (event) {
            return stop$.first();
        });
    };
    MouseService.prototype._createMouseDragStart$ = function (mouseDragStartInitiate$) {
        return mouseDragStartInitiate$
            .map(function (_a) {
            var mouseDown = _a[0], mouseMove = _a[1];
            return mouseDown;
        });
    };
    MouseService.prototype._createMouseDragInitiate$ = function (mouseDown$, stop$, defer) {
        var _this = this;
        return mouseDown$
            .filter(function (mouseDown) {
            return mouseDown.button === 0;
        })
            .switchMap(function (mouseDown) {
            return Observable_1.Observable
                .combineLatest(Observable_1.Observable.of(mouseDown), defer ?
                _this._createDeferredMouseMove$(mouseDown, _this._documentMouseMove$) :
                _this._documentMouseMove$)
                .takeUntil(stop$)
                .take(1);
        });
    };
    MouseService.prototype._createOwner$ = function (claim$) {
        return claim$
            .scan(function (claims, claim) {
            if (claim.zindex == null) {
                delete claims[claim.name];
            }
            else {
                claims[claim.name] = claim.zindex;
            }
            return claims;
        }, {})
            .map(function (claims) {
            var owner = null;
            var zIndexMax = -1;
            for (var name_1 in claims) {
                if (!claims.hasOwnProperty(name_1)) {
                    continue;
                }
                if (claims[name_1] > zIndexMax) {
                    zIndexMax = claims[name_1];
                    owner = name_1;
                }
            }
            return owner;
        })
            .startWith(null);
    };
    MouseService.prototype._filtered = function (name, observable$, owner$) {
        return observable$
            .withLatestFrom(owner$)
            .filter(function (_a) {
            var item = _a[0], owner = _a[1];
            return owner === name;
        })
            .map(function (_a) {
            var item = _a[0], owner = _a[1];
            return item;
        });
    };
    return MouseService;
}());
exports.MouseService = MouseService;
exports.default = MouseService;

},{"../Geo":294,"rxjs/BehaviorSubject":26,"rxjs/Observable":29,"rxjs/Subject":34,"rxjs/add/observable/fromEvent":43,"rxjs/add/operator/distinctUntilChanged":60,"rxjs/add/operator/filter":63,"rxjs/add/operator/map":67,"rxjs/add/operator/merge":68,"rxjs/add/operator/mergeMap":70,"rxjs/add/operator/publishReplay":74,"rxjs/add/operator/scan":78,"rxjs/add/operator/switchMap":84,"rxjs/add/operator/withLatestFrom":90}],437:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var BehaviorSubject_1 = require("rxjs/BehaviorSubject");
var Observable_1 = require("rxjs/Observable");
var ReplaySubject_1 = require("rxjs/ReplaySubject");
require("rxjs/add/observable/throw");
require("rxjs/add/operator/do");
require("rxjs/add/operator/finally");
require("rxjs/add/operator/first");
require("rxjs/add/operator/map");
require("rxjs/add/operator/mergeMap");
var API_1 = require("../API");
var Graph_1 = require("../Graph");
var Edge_1 = require("../Edge");
var Error_1 = require("../Error");
var State_1 = require("../State");
var Viewer_1 = require("../Viewer");
var Navigator = /** @class */ (function () {
    function Navigator(clientId, options, token, apiV3, graphService, imageLoadingService, loadingService, stateService, cacheService, playService) {
        this._apiV3 = apiV3 != null ? apiV3 : new API_1.APIv3(clientId, token);
        this._imageLoadingService = imageLoadingService != null ? imageLoadingService : new Graph_1.ImageLoadingService();
        this._graphService = graphService != null ?
            graphService :
            new Graph_1.GraphService(new Graph_1.Graph(this.apiV3), this._imageLoadingService);
        this._loadingService = loadingService != null ? loadingService : new Viewer_1.LoadingService();
        this._loadingName = "navigator";
        this._stateService = stateService != null ? stateService : new State_1.StateService(options.transitionMode);
        this._cacheService = cacheService != null ?
            cacheService :
            new Viewer_1.CacheService(this._graphService, this._stateService);
        this._playService = playService != null ?
            playService :
            new Viewer_1.PlayService(this._graphService, this._stateService);
        this._keyRequested$ = new BehaviorSubject_1.BehaviorSubject(null);
        this._movedToKey$ = new BehaviorSubject_1.BehaviorSubject(null);
        this._request$ = null;
        this._requestSubscription = null;
        this._nodeRequestSubscription = null;
    }
    Object.defineProperty(Navigator.prototype, "apiV3", {
        get: function () {
            return this._apiV3;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Navigator.prototype, "cacheService", {
        get: function () {
            return this._cacheService;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Navigator.prototype, "graphService", {
        get: function () {
            return this._graphService;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Navigator.prototype, "imageLoadingService", {
        get: function () {
            return this._imageLoadingService;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Navigator.prototype, "loadingService", {
        get: function () {
            return this._loadingService;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Navigator.prototype, "movedToKey$", {
        get: function () {
            return this._movedToKey$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Navigator.prototype, "playService", {
        get: function () {
            return this._playService;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Navigator.prototype, "stateService", {
        get: function () {
            return this._stateService;
        },
        enumerable: true,
        configurable: true
    });
    Navigator.prototype.moveToKey$ = function (key) {
        this._abortRequest("to key " + key);
        this._loadingService.startLoading(this._loadingName);
        var node$ = this._moveToKey$(key);
        return this._makeRequest$(node$);
    };
    Navigator.prototype.moveDir$ = function (direction) {
        var _this = this;
        this._abortRequest("in dir " + Edge_1.EdgeDirection[direction]);
        this._loadingService.startLoading(this._loadingName);
        var node$ = this.stateService.currentNode$
            .first()
            .mergeMap(function (node) {
            return ([Edge_1.EdgeDirection.Next, Edge_1.EdgeDirection.Prev].indexOf(direction) > -1 ?
                node.sequenceEdges$ :
                node.spatialEdges$)
                .first()
                .map(function (status) {
                for (var _i = 0, _a = status.edges; _i < _a.length; _i++) {
                    var edge = _a[_i];
                    if (edge.data.direction === direction) {
                        return edge.to;
                    }
                }
                return null;
            });
        })
            .mergeMap(function (directionKey) {
            if (directionKey == null) {
                _this._loadingService.stopLoading(_this._loadingName);
                return Observable_1.Observable
                    .throw(new Error("Direction (" + direction + ") does not exist for current node."));
            }
            return _this._moveToKey$(directionKey);
        });
        return this._makeRequest$(node$);
    };
    Navigator.prototype.moveCloseTo$ = function (lat, lon) {
        var _this = this;
        this._abortRequest("to lat " + lat + ", lon " + lon);
        this._loadingService.startLoading(this._loadingName);
        var node$ = this.apiV3.imageCloseTo$(lat, lon)
            .mergeMap(function (fullNode) {
            if (fullNode == null) {
                _this._loadingService.stopLoading(_this._loadingName);
                return Observable_1.Observable
                    .throw(new Error("No image found close to lat " + lat + ", lon " + lon + "."));
            }
            return _this._moveToKey$(fullNode.key);
        });
        return this._makeRequest$(node$);
    };
    Navigator.prototype.setFilter$ = function (filter) {
        var _this = this;
        this._stateService.clearNodes();
        return this._movedToKey$
            .first()
            .mergeMap(function (key) {
            if (key != null) {
                return _this._trajectoryKeys$()
                    .mergeMap(function (keys) {
                    return _this._graphService.setFilter$(filter)
                        .mergeMap(function () {
                        return _this._cacheKeys$(keys);
                    });
                })
                    .last();
            }
            return _this._keyRequested$
                .first()
                .mergeMap(function (requestedKey) {
                if (requestedKey != null) {
                    return _this._graphService.setFilter$(filter)
                        .mergeMap(function () {
                        return _this._graphService.cacheNode$(requestedKey);
                    });
                }
                return _this._graphService.setFilter$(filter)
                    .map(function () {
                    return undefined;
                });
            });
        })
            .map(function (node) {
            return undefined;
        });
    };
    Navigator.prototype.setToken$ = function (token) {
        var _this = this;
        this._abortRequest("to set token");
        this._stateService.clearNodes();
        return this._movedToKey$
            .first()
            .do(function (key) {
            _this._apiV3.setToken(token);
        })
            .mergeMap(function (key) {
            return key == null ?
                _this._graphService.reset$([]) :
                _this._trajectoryKeys$()
                    .mergeMap(function (keys) {
                    return _this._graphService.reset$(keys)
                        .mergeMap(function () {
                        return _this._cacheKeys$(keys);
                    });
                })
                    .last()
                    .map(function (node) {
                    return undefined;
                });
        });
    };
    Navigator.prototype._cacheKeys$ = function (keys) {
        var _this = this;
        var cacheNodes$ = keys
            .map(function (key) {
            return _this._graphService.cacheNode$(key);
        });
        return Observable_1.Observable
            .from(cacheNodes$)
            .mergeAll();
    };
    Navigator.prototype._abortRequest = function (reason) {
        if (this._requestSubscription != null) {
            this._requestSubscription.unsubscribe();
            this._requestSubscription = null;
        }
        if (this._nodeRequestSubscription != null) {
            this._nodeRequestSubscription.unsubscribe();
            this._nodeRequestSubscription = null;
        }
        if (this._request$ != null) {
            this._request$.error(new Error_1.AbortMapillaryError("Request aborted by a subsequent request " + reason + "."));
            this._request$ = null;
        }
    };
    Navigator.prototype._makeRequest$ = function (node$) {
        var _this = this;
        this._request$ = new ReplaySubject_1.ReplaySubject(1);
        this._requestSubscription = this._request$
            .subscribe(undefined, function (e) { });
        this._nodeRequestSubscription = node$
            .subscribe(function (node) {
            _this._request$.next(node);
            _this._request$.complete();
        }, function (error) {
            _this._request$.error(error);
        });
        return this._request$;
    };
    Navigator.prototype._moveToKey$ = function (key) {
        var _this = this;
        this._keyRequested$.next(key);
        return this._graphService.cacheNode$(key)
            .do(function (node) {
            _this._stateService.setNodes([node]);
            _this._movedToKey$.next(node.key);
        })
            .finally(function () {
            _this._loadingService.stopLoading(_this._loadingName);
        });
    };
    Navigator.prototype._trajectoryKeys$ = function () {
        return this._stateService.currentState$
            .first()
            .map(function (frame) {
            return frame.state.trajectory
                .map(function (node) {
                return node.key;
            });
        });
    };
    return Navigator;
}());
exports.Navigator = Navigator;
exports.default = Navigator;

},{"../API":290,"../Edge":292,"../Error":293,"../Graph":295,"../State":298,"../Viewer":302,"rxjs/BehaviorSubject":26,"rxjs/Observable":29,"rxjs/ReplaySubject":32,"rxjs/add/observable/throw":47,"rxjs/add/operator/do":61,"rxjs/add/operator/finally":64,"rxjs/add/operator/first":65,"rxjs/add/operator/map":67,"rxjs/add/operator/mergeMap":70}],438:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/observable/combineLatest");
require("rxjs/add/operator/distinctUntilChanged");
require("rxjs/add/operator/map");
require("rxjs/add/operator/throttleTime");
var Viewer_1 = require("../Viewer");
var Observer = /** @class */ (function () {
    function Observer(eventEmitter, navigator, container) {
        var _this = this;
        this._container = container;
        this._eventEmitter = eventEmitter;
        this._navigator = navigator;
        this._projection = new Viewer_1.Projection();
        this._started = false;
        this._navigable$ = new Subject_1.Subject();
        // navigable and loading should always emit, also when cover is activated.
        this._navigable$
            .subscribe(function (navigable) {
            _this._eventEmitter.fire(Viewer_1.Viewer.navigablechanged, navigable);
        });
        this._navigator.loadingService.loading$
            .subscribe(function (loading) {
            _this._eventEmitter.fire(Viewer_1.Viewer.loadingchanged, loading);
        });
    }
    Object.defineProperty(Observer.prototype, "started", {
        get: function () {
            return this._started;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Observer.prototype, "navigable$", {
        get: function () {
            return this._navigable$;
        },
        enumerable: true,
        configurable: true
    });
    Observer.prototype.projectBasic$ = function (basicPoint) {
        var _this = this;
        return Observable_1.Observable
            .combineLatest(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$)
            .first()
            .map(function (_a) {
            var render = _a[0], transform = _a[1];
            var canvasPoint = _this._projection.basicToCanvas(basicPoint, _this._container.element, render, transform);
            return [Math.round(canvasPoint[0]), Math.round(canvasPoint[1])];
        });
    };
    Observer.prototype.startEmit = function () {
        var _this = this;
        if (this._started) {
            return;
        }
        this._started = true;
        this._currentNodeSubscription = this._navigator.stateService.currentNodeExternal$
            .subscribe(function (node) {
            _this._eventEmitter.fire(Viewer_1.Viewer.nodechanged, node);
        });
        this._sequenceEdgesSubscription = this._navigator.stateService.currentNodeExternal$
            .switchMap(function (node) {
            return node.sequenceEdges$;
        })
            .subscribe(function (status) {
            _this._eventEmitter.fire(Viewer_1.Viewer.sequenceedgeschanged, status);
        });
        this._spatialEdgesSubscription = this._navigator.stateService.currentNodeExternal$
            .switchMap(function (node) {
            return node.spatialEdges$;
        })
            .subscribe(function (status) {
            _this._eventEmitter.fire(Viewer_1.Viewer.spatialedgeschanged, status);
        });
        this._moveSubscription = Observable_1.Observable
            .combineLatest(this._navigator.stateService.inMotion$, this._container.mouseService.active$, this._container.touchService.active$)
            .map(function (values) {
            return values[0] || values[1] || values[2];
        })
            .distinctUntilChanged()
            .subscribe(function (started) {
            if (started) {
                _this._eventEmitter.fire(Viewer_1.Viewer.movestart, null);
            }
            else {
                _this._eventEmitter.fire(Viewer_1.Viewer.moveend, null);
            }
        });
        this._bearingSubscription = this._container.renderService.bearing$
            .throttleTime(100)
            .distinctUntilChanged(function (b1, b2) {
            return Math.abs(b2 - b1) < 1;
        })
            .subscribe(function (bearing) {
            _this._eventEmitter.fire(Viewer_1.Viewer.bearingchanged, bearing);
        });
        var mouseMove$ = this._container.mouseService.active$
            .switchMap(function (active) {
            return active ?
                Observable_1.Observable.empty() :
                _this._container.mouseService.mouseMove$;
        });
        this._viewerMouseEventSubscription = Observable_1.Observable
            .merge(this._mapMouseEvent$(Viewer_1.Viewer.click, this._container.mouseService.staticClick$), this._mapMouseEvent$(Viewer_1.Viewer.contextmenu, this._container.mouseService.contextMenu$), this._mapMouseEvent$(Viewer_1.Viewer.dblclick, this._container.mouseService.dblClick$), this._mapMouseEvent$(Viewer_1.Viewer.mousedown, this._container.mouseService.mouseDown$), this._mapMouseEvent$(Viewer_1.Viewer.mousemove, mouseMove$), this._mapMouseEvent$(Viewer_1.Viewer.mouseout, this._container.mouseService.mouseOut$), this._mapMouseEvent$(Viewer_1.Viewer.mouseover, this._container.mouseService.mouseOver$), this._mapMouseEvent$(Viewer_1.Viewer.mouseup, this._container.mouseService.mouseUp$))
            .withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.reference$, this._navigator.stateService.currentTransform$)
            .map(function (_a) {
            var _b = _a[0], type = _b[0], event = _b[1], render = _a[1], reference = _a[2], transform = _a[3];
            var unprojection = _this._projection.eventToUnprojection(event, _this._container.element, render, reference, transform);
            return {
                basicPoint: unprojection.basicPoint,
                latLon: unprojection.latLon,
                originalEvent: event,
                pixelPoint: unprojection.pixelPoint,
                target: _this._eventEmitter,
                type: type,
            };
        })
            .subscribe(function (event) {
            _this._eventEmitter.fire(event.type, event);
        });
    };
    Observer.prototype.stopEmit = function () {
        if (!this.started) {
            return;
        }
        this._started = false;
        this._bearingSubscription.unsubscribe();
        this._currentNodeSubscription.unsubscribe();
        this._moveSubscription.unsubscribe();
        this._sequenceEdgesSubscription.unsubscribe();
        this._spatialEdgesSubscription.unsubscribe();
        this._viewerMouseEventSubscription.unsubscribe();
        this._bearingSubscription = null;
        this._currentNodeSubscription = null;
        this._moveSubscription = null;
        this._sequenceEdgesSubscription = null;
        this._spatialEdgesSubscription = null;
        this._viewerMouseEventSubscription = null;
    };
    Observer.prototype.unproject$ = function (canvasPoint) {
        var _this = this;
        return Observable_1.Observable
            .combineLatest(this._container.renderService.renderCamera$, this._navigator.stateService.reference$, this._navigator.stateService.currentTransform$)
            .first()
            .map(function (_a) {
            var render = _a[0], reference = _a[1], transform = _a[2];
            var unprojection = _this._projection.canvasToUnprojection(canvasPoint, _this._container.element, render, reference, transform);
            return unprojection.latLon;
        });
    };
    Observer.prototype.unprojectBasic$ = function (canvasPoint) {
        var _this = this;
        return Observable_1.Observable
            .combineLatest(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$)
            .first()
            .map(function (_a) {
            var render = _a[0], transform = _a[1];
            return _this._projection.canvasToBasic(canvasPoint, _this._container.element, render, transform);
        });
    };
    Observer.prototype._mapMouseEvent$ = function (type, mouseEvent$) {
        return mouseEvent$.map(function (event) {
            return [type, event];
        });
    };
    return Observer;
}());
exports.Observer = Observer;
exports.default = Observer;

},{"../Viewer":302,"rxjs/Observable":29,"rxjs/Subject":34,"rxjs/add/observable/combineLatest":38,"rxjs/add/operator/distinctUntilChanged":60,"rxjs/add/operator/map":67,"rxjs/add/operator/throttleTime":88}],439:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/operator/timeout");
var Edge_1 = require("../Edge");
var Graph_1 = require("../Graph");
var PlayService = /** @class */ (function () {
    function PlayService(graphService, stateService, graphCalculator) {
        this._graphService = graphService;
        this._stateService = stateService;
        this._graphCalculator = !!graphCalculator ? graphCalculator : new Graph_1.GraphCalculator();
        this._directionSubject$ = new Subject_1.Subject();
        this._direction$ = this._directionSubject$
            .startWith(Edge_1.EdgeDirection.Next)
            .publishReplay(1)
            .refCount();
        this._direction$.subscribe();
        this._playing = false;
        this._playingSubject$ = new Subject_1.Subject();
        this._playing$ = this._playingSubject$
            .startWith(this._playing)
            .publishReplay(1)
            .refCount();
        this._playing$.subscribe();
        this._speed = 0.5;
        this._speedSubject$ = new Subject_1.Subject();
        this._speed$ = this._speedSubject$
            .startWith(this._speed)
            .publishReplay(1)
            .refCount();
        this._speed$.subscribe();
        this._nodesAhead = this._mapNodesAhead(this._mapSpeed(this._speed));
        this._bridging$ = null;
    }
    Object.defineProperty(PlayService.prototype, "playing", {
        get: function () {
            return this._playing;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlayService.prototype, "direction$", {
        get: function () {
            return this._direction$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlayService.prototype, "playing$", {
        get: function () {
            return this._playing$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlayService.prototype, "speed$", {
        get: function () {
            return this._speed$;
        },
        enumerable: true,
        configurable: true
    });
    PlayService.prototype.play = function () {
        var _this = this;
        if (this._playing) {
            return;
        }
        this._stateService.cutNodes();
        var stateSpeed = this._setSpeed(this._speed);
        this._stateService.setSpeed(stateSpeed);
        this._graphModeSubscription = this._speed$
            .map(function (speed) {
            return speed > 0.54 ? Graph_1.GraphMode.Sequence : Graph_1.GraphMode.Spatial;
        })
            .distinctUntilChanged()
            .subscribe(function (mode) {
            _this._graphService.setGraphMode(mode);
        });
        this._cacheSubscription = this._stateService.currentNode$
            .map(function (node) {
            return [node.sequenceKey, node.key];
        })
            .distinctUntilChanged(undefined, function (_a) {
            var sequenceKey = _a[0], nodeKey = _a[1];
            return sequenceKey;
        })
            .combineLatest(this._graphService.graphMode$, this._direction$)
            .switchMap(function (_a) {
            var _b = _a[0], sequenceKey = _b[0], nodeKey = _b[1], mode = _a[1], direction = _a[2];
            if (direction !== Edge_1.EdgeDirection.Next && direction !== Edge_1.EdgeDirection.Prev) {
                return Observable_1.Observable.of([undefined, direction]);
            }
            var sequence$ = (mode === Graph_1.GraphMode.Sequence ?
                _this._graphService.cacheSequenceNodes$(sequenceKey, nodeKey) :
                _this._graphService.cacheSequence$(sequenceKey))
                .retry(3)
                .catch(function (error) {
                console.error(error);
                return Observable_1.Observable.of(undefined);
            });
            return Observable_1.Observable
                .combineLatest(sequence$, Observable_1.Observable.of(direction));
        })
            .switchMap(function (_a) {
            var sequence = _a[0], direction = _a[1];
            if (sequence === undefined) {
                return Observable_1.Observable.empty();
            }
            var sequenceKeys = sequence.keys.slice();
            if (direction === Edge_1.EdgeDirection.Prev) {
                sequenceKeys.reverse();
            }
            return _this._stateService.currentState$
                .map(function (frame) {
                return [frame.state.trajectory[frame.state.trajectory.length - 1].key, frame.state.nodesAhead];
            })
                .scan(function (_a, _b) {
                var lastRequestKey = _a[0], previousRequestKeys = _a[1];
                var lastTrajectoryKey = _b[0], nodesAhead = _b[1];
                if (lastRequestKey === undefined) {
                    lastRequestKey = lastTrajectoryKey;
                }
                var lastIndex = sequenceKeys.length - 1;
                if (nodesAhead >= _this._nodesAhead || sequenceKeys[lastIndex] === lastRequestKey) {
                    return [lastRequestKey, []];
                }
                var current = sequenceKeys.indexOf(lastTrajectoryKey);
                var start = sequenceKeys.indexOf(lastRequestKey) + 1;
                var end = Math.min(lastIndex, current + _this._nodesAhead - nodesAhead) + 1;
                if (end <= start) {
                    return [lastRequestKey, []];
                }
                return [sequenceKeys[end - 1], sequenceKeys.slice(start, end)];
            }, [undefined, []])
                .mergeMap(function (_a) {
                var lastRequestKey = _a[0], newRequestKeys = _a[1];
                return Observable_1.Observable.from(newRequestKeys);
            });
        })
            .mergeMap(function (key) {
            return _this._graphService.cacheNode$(key)
                .catch(function () {
                return Observable_1.Observable.empty();
            });
        }, 6)
            .subscribe();
        this._playingSubscription = this._stateService.currentState$
            .filter(function (frame) {
            return frame.state.nodesAhead < _this._nodesAhead;
        })
            .distinctUntilChanged(undefined, function (frame) {
            return frame.state.lastNode.key;
        })
            .map(function (frame) {
            var lastNode = frame.state.lastNode;
            var trajectory = frame.state.trajectory;
            var increasingTime = undefined;
            for (var i = trajectory.length - 2; i >= 0; i--) {
                var node = trajectory[i];
                if (node.sequenceKey !== lastNode.sequenceKey) {
                    break;
                }
                if (node.capturedAt !== lastNode.capturedAt) {
                    increasingTime = node.capturedAt < lastNode.capturedAt;
                    break;
                }
            }
            return [frame.state.lastNode, increasingTime];
        })
            .withLatestFrom(this._direction$)
            .switchMap(function (_a) {
            var _b = _a[0], node = _b[0], increasingTime = _b[1], direction = _a[1];
            return ([Edge_1.EdgeDirection.Next, Edge_1.EdgeDirection.Prev].indexOf(direction) > -1 ?
                node.sequenceEdges$ :
                node.spatialEdges$)
                .first(function (status) {
                return status.cached;
            })
                .timeout(15000)
                .zip(Observable_1.Observable.of(direction))
                .map(function (_a) {
                var s = _a[0], d = _a[1];
                for (var _i = 0, _b = s.edges; _i < _b.length; _i++) {
                    var edge = _b[_i];
                    if (edge.data.direction === d) {
                        return edge.to;
                    }
                }
                return null;
            })
                .switchMap(function (key) {
                return key != null ?
                    _this._graphService.cacheNode$(key) :
                    _this._bridge$(node, increasingTime)
                        .filter(function (n) {
                        return !!n;
                    });
            });
        })
            .subscribe(function (node) {
            _this._stateService.appendNodes([node]);
        }, function (error) {
            console.error(error);
            _this.stop();
        });
        this._clearSubscription = this._stateService.currentNode$
            .bufferCount(1, 10)
            .subscribe(function (nodes) {
            _this._stateService.clearPriorNodes();
        });
        this._setPlaying(true);
        var currentLastNodes$ = this._stateService.currentState$
            .map(function (frame) {
            return frame.state;
        })
            .distinctUntilChanged(function (_a, _b) {
            var kc1 = _a[0], kl1 = _a[1];
            var kc2 = _b[0], kl2 = _b[1];
            return kc1 === kc2 && kl1 === kl2;
        }, function (state) {
            return [state.currentNode.key, state.lastNode.key];
        })
            .filter(function (state) {
            return state.currentNode.key === state.lastNode.key &&
                state.currentIndex === state.trajectory.length - 1;
        })
            .map(function (state) {
            return state.currentNode;
        });
        this._stopSubscription = Observable_1.Observable
            .combineLatest(currentLastNodes$, this._direction$)
            .switchMap(function (_a) {
            var node = _a[0], direction = _a[1];
            var edgeStatus$ = ([Edge_1.EdgeDirection.Next, Edge_1.EdgeDirection.Prev].indexOf(direction) > -1 ?
                node.sequenceEdges$ :
                node.spatialEdges$)
                .first(function (status) {
                return status.cached;
            })
                .timeout(15000)
                .catch(function (error) {
                console.error(error);
                return Observable_1.Observable.of({ cached: false, edges: [] });
            });
            return Observable_1.Observable
                .combineLatest(Observable_1.Observable.of(direction), edgeStatus$)
                .map(function (_a) {
                var d = _a[0], es = _a[1];
                for (var _i = 0, _b = es.edges; _i < _b.length; _i++) {
                    var edge = _b[_i];
                    if (edge.data.direction === d) {
                        return true;
                    }
                }
                return false;
            });
        })
            .mergeMap(function (hasEdge) {
            if (hasEdge || !_this._bridging$) {
                return Observable_1.Observable.of(hasEdge);
            }
            return _this._bridging$
                .map(function (node) {
                return node != null;
            })
                .catch(function (error) {
                console.error(error);
                return Observable_1.Observable.of(false);
            });
        })
            .first(function (hasEdge) {
            return !hasEdge;
        })
            .subscribe(undefined, undefined, function () { _this.stop(); });
        if (this._stopSubscription.closed) {
            this._stopSubscription = null;
        }
    };
    PlayService.prototype.setDirection = function (direction) {
        this._directionSubject$.next(direction);
    };
    PlayService.prototype.setSpeed = function (speed) {
        speed = Math.max(0, Math.min(1, speed));
        if (speed === this._speed) {
            return;
        }
        var stateSpeed = this._setSpeed(speed);
        if (this._playing) {
            this._stateService.setSpeed(stateSpeed);
        }
        this._speedSubject$.next(this._speed);
    };
    PlayService.prototype.stop = function () {
        if (!this._playing) {
            return;
        }
        if (!!this._stopSubscription) {
            if (!this._stopSubscription.closed) {
                this._stopSubscription.unsubscribe();
            }
            this._stopSubscription = null;
        }
        this._graphModeSubscription.unsubscribe();
        this._graphModeSubscription = null;
        this._cacheSubscription.unsubscribe();
        this._cacheSubscription = null;
        this._playingSubscription.unsubscribe();
        this._playingSubscription = null;
        this._clearSubscription.unsubscribe();
        this._clearSubscription = null;
        this._stateService.setSpeed(1);
        this._stateService.cutNodes();
        this._graphService.setGraphMode(Graph_1.GraphMode.Spatial);
        this._setPlaying(false);
    };
    PlayService.prototype._bridge$ = function (node, increasingTime) {
        var _this = this;
        if (increasingTime === undefined) {
            return Observable_1.Observable.of(null);
        }
        var boundingBox = this._graphCalculator.boundingBoxCorners(node.latLon, 25);
        this._bridging$ = this._graphService.cacheBoundingBox$(boundingBox[0], boundingBox[1])
            .mergeMap(function (nodes) {
            var nextNode = null;
            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                var n = nodes_1[_i];
                if (n.sequenceKey === node.sequenceKey ||
                    !n.cameraUuid ||
                    n.cameraUuid !== node.cameraUuid ||
                    n.capturedAt === node.capturedAt ||
                    n.capturedAt > node.capturedAt !== increasingTime) {
                    continue;
                }
                var delta = Math.abs(n.capturedAt - node.capturedAt);
                if (delta > 15000) {
                    continue;
                }
                if (!nextNode || delta < Math.abs(nextNode.capturedAt - node.capturedAt)) {
                    nextNode = n;
                }
            }
            return !!nextNode ?
                _this._graphService.cacheNode$(nextNode.key) :
                Observable_1.Observable.of(null);
        })
            .finally(function () {
            _this._bridging$ = null;
        })
            .publish()
            .refCount();
        return this._bridging$;
    };
    PlayService.prototype._mapSpeed = function (speed) {
        var x = 2 * speed - 1;
        return Math.pow(10, x) - 0.2 * x;
    };
    PlayService.prototype._mapNodesAhead = function (stateSpeed) {
        return Math.round(Math.max(10, Math.min(50, 8 + 6 * stateSpeed)));
    };
    PlayService.prototype._setPlaying = function (playing) {
        this._playing = playing;
        this._playingSubject$.next(playing);
    };
    PlayService.prototype._setSpeed = function (speed) {
        this._speed = speed;
        var stateSpeed = this._mapSpeed(this._speed);
        this._nodesAhead = this._mapNodesAhead(stateSpeed);
        return stateSpeed;
    };
    return PlayService;
}());
exports.PlayService = PlayService;
exports.default = PlayService;

},{"../Edge":292,"../Graph":295,"rxjs/Observable":29,"rxjs/Subject":34,"rxjs/add/operator/timeout":89}],440:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var Geo_1 = require("../Geo");
var Projection = /** @class */ (function () {
    function Projection(geoCoords, viewportCoords) {
        this._geoCoords = !!geoCoords ? geoCoords : new Geo_1.GeoCoords();
        this._viewportCoords = !!viewportCoords ? viewportCoords : new Geo_1.ViewportCoords();
    }
    Projection.prototype.basicToCanvas = function (basicPoint, container, render, transform) {
        return this._viewportCoords
            .basicToCanvas(basicPoint[0], basicPoint[1], container, transform, render.perspective);
    };
    Projection.prototype.canvasToBasic = function (canvasPoint, container, render, transform) {
        var basicPoint = this._viewportCoords
            .canvasToBasic(canvasPoint[0], canvasPoint[1], container, transform, render.perspective);
        if (basicPoint[0] < 0 || basicPoint[0] > 1 || basicPoint[1] < 0 || basicPoint[1] > 1) {
            basicPoint = null;
        }
        return basicPoint;
    };
    Projection.prototype.eventToUnprojection = function (event, container, render, reference, transform) {
        var pixelPoint = this._viewportCoords.canvasPosition(event, container);
        return this.canvasToUnprojection(pixelPoint, container, render, reference, transform);
    };
    Projection.prototype.canvasToUnprojection = function (canvasPoint, container, render, reference, transform) {
        var canvasX = canvasPoint[0];
        var canvasY = canvasPoint[1];
        var _a = this._viewportCoords.canvasToViewport(canvasX, canvasY, container), viewportX = _a[0], viewportY = _a[1];
        var point3d = new THREE.Vector3(viewportX, viewportY, 1)
            .unproject(render.perspective);
        var basicPoint = transform.projectBasic(point3d.toArray());
        if (basicPoint[0] < 0 || basicPoint[0] > 1 || basicPoint[1] < 0 || basicPoint[1] > 1) {
            basicPoint = null;
        }
        var direction3d = point3d.clone().sub(render.camera.position).normalize();
        var dist = -2 / direction3d.z;
        var latLon = null;
        if (dist > 0 && dist < 100 && !!basicPoint) {
            var point = direction3d.clone().multiplyScalar(dist).add(render.camera.position);
            var latLonArray = this._geoCoords
                .enuToGeodetic(point.x, point.y, point.z, reference.lat, reference.lon, reference.alt)
                .slice(0, 2);
            latLon = { lat: latLonArray[0], lon: latLonArray[1] };
        }
        var unprojection = {
            basicPoint: basicPoint,
            latLon: latLon,
            pixelPoint: [canvasX, canvasY],
        };
        return unprojection;
    };
    return Projection;
}());
exports.Projection = Projection;
exports.default = Projection;

},{"../Geo":294,"three":241}],441:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
var vd = require("virtual-dom");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/operator/publishReplay");
require("rxjs/add/operator/scan");
require("rxjs/add/operator/startWith");
var Viewer_1 = require("../Viewer");
var SpriteAtlas = /** @class */ (function () {
    function SpriteAtlas() {
    }
    Object.defineProperty(SpriteAtlas.prototype, "json", {
        set: function (value) {
            this._json = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteAtlas.prototype, "image", {
        set: function (value) {
            this._image = value;
            this._texture = new THREE.Texture(this._image);
            this._texture.minFilter = THREE.NearestFilter;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteAtlas.prototype, "loaded", {
        get: function () {
            return !!(this._image && this._json);
        },
        enumerable: true,
        configurable: true
    });
    SpriteAtlas.prototype.getGLSprite = function (name) {
        if (!this.loaded) {
            throw new Error("Sprites cannot be retrieved before the atlas is loaded.");
        }
        var definition = this._json[name];
        if (!definition) {
            console.warn("Sprite with key" + name + "does not exist in sprite definition.");
            return new THREE.Object3D();
        }
        var texture = this._texture.clone();
        texture.needsUpdate = true;
        var width = this._image.width;
        var height = this._image.height;
        texture.offset.x = definition.x / width;
        texture.offset.y = (height - definition.y - definition.height) / height;
        texture.repeat.x = definition.width / width;
        texture.repeat.y = definition.height / height;
        var material = new THREE.SpriteMaterial({ map: texture });
        return new THREE.Sprite(material);
    };
    SpriteAtlas.prototype.getDOMSprite = function (name, float) {
        if (!this.loaded) {
            throw new Error("Sprites cannot be retrieved before the atlas is loaded.");
        }
        if (float == null) {
            float = Viewer_1.Alignment.Center;
        }
        var definition = this._json[name];
        if (!definition) {
            console.warn("Sprite with key" + name + "does not exist in sprite definition.");
            return vd.h("div", {}, []);
        }
        var clipTop = definition.y;
        var clipRigth = definition.x + definition.width;
        var clipBottom = definition.y + definition.height;
        var clipLeft = definition.x;
        var left = -definition.x;
        var top = -definition.y;
        var height = this._image.height;
        var width = this._image.width;
        switch (float) {
            case Viewer_1.Alignment.Bottom:
            case Viewer_1.Alignment.Center:
            case Viewer_1.Alignment.Top:
                left -= definition.width / 2;
                break;
            case Viewer_1.Alignment.BottomLeft:
            case Viewer_1.Alignment.Left:
            case Viewer_1.Alignment.TopLeft:
                left -= definition.width;
                break;
            case Viewer_1.Alignment.BottomRight:
            case Viewer_1.Alignment.Right:
            case Viewer_1.Alignment.TopRight:
            default:
                break;
        }
        switch (float) {
            case Viewer_1.Alignment.Center:
            case Viewer_1.Alignment.Left:
            case Viewer_1.Alignment.Right:
                top -= definition.height / 2;
                break;
            case Viewer_1.Alignment.Top:
            case Viewer_1.Alignment.TopLeft:
            case Viewer_1.Alignment.TopRight:
                top -= definition.height;
                break;
            case Viewer_1.Alignment.Bottom:
            case Viewer_1.Alignment.BottomLeft:
            case Viewer_1.Alignment.BottomRight:
            default:
                break;
        }
        var pixelRatioInverse = 1 / definition.pixelRatio;
        clipTop *= pixelRatioInverse;
        clipRigth *= pixelRatioInverse;
        clipBottom *= pixelRatioInverse;
        clipLeft *= pixelRatioInverse;
        left *= pixelRatioInverse;
        top *= pixelRatioInverse;
        height *= pixelRatioInverse;
        width *= pixelRatioInverse;
        var properties = {
            src: this._image.src,
            style: {
                clip: "rect(" + clipTop + "px, " + clipRigth + "px, " + clipBottom + "px, " + clipLeft + "px)",
                height: height + "px",
                left: left + "px",
                position: "absolute",
                top: top + "px",
                width: width + "px",
            },
        };
        return vd.h("img", properties, []);
    };
    return SpriteAtlas;
}());
var SpriteService = /** @class */ (function () {
    function SpriteService(sprite) {
        var _this = this;
        this._retina = window.devicePixelRatio > 1;
        this._spriteAtlasOperation$ = new Subject_1.Subject();
        this._spriteAtlas$ = this._spriteAtlasOperation$
            .startWith(function (atlas) {
            return atlas;
        })
            .scan(function (atlas, operation) {
            return operation(atlas);
        }, new SpriteAtlas())
            .publishReplay(1)
            .refCount();
        this._spriteAtlas$.subscribe(function () { });
        if (sprite == null) {
            return;
        }
        var format = this._retina ? "@2x" : "";
        var imageXmlHTTP = new XMLHttpRequest();
        imageXmlHTTP.open("GET", sprite + format + ".png", true);
        imageXmlHTTP.responseType = "arraybuffer";
        imageXmlHTTP.onload = function () {
            var image = new Image();
            image.onload = function () {
                _this._spriteAtlasOperation$.next(function (atlas) {
                    atlas.image = image;
                    return atlas;
                });
            };
            var blob = new Blob([imageXmlHTTP.response]);
            image.src = window.URL.createObjectURL(blob);
        };
        imageXmlHTTP.onerror = function (error) {
            console.error(new Error("Failed to fetch sprite sheet (" + sprite + format + ".png)"));
        };
        imageXmlHTTP.send();
        var jsonXmlHTTP = new XMLHttpRequest();
        jsonXmlHTTP.open("GET", sprite + format + ".json", true);
        jsonXmlHTTP.responseType = "text";
        jsonXmlHTTP.onload = function () {
            var json = JSON.parse(jsonXmlHTTP.response);
            _this._spriteAtlasOperation$.next(function (atlas) {
                atlas.json = json;
                return atlas;
            });
        };
        jsonXmlHTTP.onerror = function (error) {
            console.error(new Error("Failed to fetch sheet (" + sprite + format + ".json)"));
        };
        jsonXmlHTTP.send();
    }
    Object.defineProperty(SpriteService.prototype, "spriteAtlas$", {
        get: function () {
            return this._spriteAtlas$;
        },
        enumerable: true,
        configurable: true
    });
    return SpriteService;
}());
exports.SpriteService = SpriteService;
exports.default = SpriteService;

},{"../Viewer":302,"rxjs/Subject":34,"rxjs/add/operator/publishReplay":74,"rxjs/add/operator/scan":78,"rxjs/add/operator/startWith":83,"three":241,"virtual-dom":247}],442:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var BehaviorSubject_1 = require("rxjs/BehaviorSubject");
var Observable_1 = require("rxjs/Observable");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/observable/timer");
require("rxjs/add/operator/bufferWhen");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/map");
require("rxjs/add/operator/merge");
require("rxjs/add/operator/scan");
require("rxjs/add/operator/switchMap");
var TouchService = /** @class */ (function () {
    function TouchService(canvasContainer, domContainer) {
        var _this = this;
        this._activeSubject$ = new BehaviorSubject_1.BehaviorSubject(false);
        this._active$ = this._activeSubject$
            .distinctUntilChanged()
            .publishReplay(1)
            .refCount();
        Observable_1.Observable.fromEvent(domContainer, "touchmove")
            .subscribe(function (event) {
            event.preventDefault();
        });
        this._touchStart$ = Observable_1.Observable.fromEvent(canvasContainer, "touchstart");
        this._touchMove$ = Observable_1.Observable.fromEvent(canvasContainer, "touchmove");
        this._touchEnd$ = Observable_1.Observable.fromEvent(canvasContainer, "touchend");
        this._touchCancel$ = Observable_1.Observable.fromEvent(canvasContainer, "touchcancel");
        var tapStart$ = this._touchStart$
            .filter(function (te) {
            return te.touches.length === 1 && te.targetTouches.length === 1;
        })
            .share();
        this._doubleTap$ = tapStart$
            .bufferWhen(function () {
            return tapStart$
                .first()
                .switchMap(function (event) {
                return Observable_1.Observable
                    .timer(300)
                    .merge(tapStart$)
                    .take(1);
            });
        })
            .filter(function (events) {
            return events.length === 2;
        })
            .map(function (events) {
            return events[events.length - 1];
        })
            .share();
        this._doubleTap$
            .subscribe(function (event) {
            event.preventDefault();
        });
        this._singleTouchMove$ = this._touchMove$
            .filter(function (te) {
            return te.touches.length === 1 && te.targetTouches.length === 1;
        })
            .share();
        var singleTouchStart$ = Observable_1.Observable
            .merge(this._touchStart$, this._touchEnd$, this._touchCancel$)
            .filter(function (te) {
            return te.touches.length === 1 && te.targetTouches.length === 1;
        });
        var multipleTouchStart$ = Observable_1.Observable
            .merge(this._touchStart$, this._touchEnd$, this._touchCancel$)
            .filter(function (te) {
            return te.touches.length >= 1;
        });
        var touchStop$ = Observable_1.Observable
            .merge(this._touchEnd$, this._touchCancel$)
            .filter(function (te) {
            return te.touches.length === 0;
        });
        this._singleTouchDragStart$ = singleTouchStart$
            .mergeMap(function (e) {
            return _this._singleTouchMove$
                .takeUntil(Observable_1.Observable.merge(touchStop$, multipleTouchStart$))
                .take(1);
        });
        this._singleTouchDragEnd$ = singleTouchStart$
            .mergeMap(function (e) {
            return Observable_1.Observable
                .merge(touchStop$, multipleTouchStart$)
                .first();
        });
        this._singleTouchDrag$ = singleTouchStart$
            .switchMap(function (te) {
            return _this._singleTouchMove$
                .skip(1)
                .takeUntil(Observable_1.Observable
                .merge(multipleTouchStart$, touchStop$));
        });
        var touchesChanged$ = Observable_1.Observable
            .merge(this._touchStart$, this._touchEnd$, this._touchCancel$);
        this._pinchStart$ = touchesChanged$
            .filter(function (te) {
            return te.touches.length === 2 && te.targetTouches.length === 2;
        });
        this._pinchEnd$ = touchesChanged$
            .filter(function (te) {
            return te.touches.length !== 2 || te.targetTouches.length !== 2;
        });
        this._pinchOperation$ = new Subject_1.Subject();
        this._pinch$ = this._pinchOperation$
            .scan(function (pinch, operation) {
            return operation(pinch);
        }, {
            changeX: 0,
            changeY: 0,
            clientX: 0,
            clientY: 0,
            distance: 0,
            distanceChange: 0,
            distanceX: 0,
            distanceY: 0,
            originalEvent: null,
            pageX: 0,
            pageY: 0,
            screenX: 0,
            screenY: 0,
            touch1: null,
            touch2: null,
        });
        this._touchMove$
            .filter(function (te) {
            return te.touches.length === 2 && te.targetTouches.length === 2;
        })
            .map(function (te) {
            return function (previous) {
                var touch1 = te.touches[0];
                var touch2 = te.touches[1];
                var minX = Math.min(touch1.clientX, touch2.clientX);
                var maxX = Math.max(touch1.clientX, touch2.clientX);
                var minY = Math.min(touch1.clientY, touch2.clientY);
                var maxY = Math.max(touch1.clientY, touch2.clientY);
                var centerClientX = minX + (maxX - minX) / 2;
                var centerClientY = minY + (maxY - minY) / 2;
                var centerPageX = centerClientX + touch1.pageX - touch1.clientX;
                var centerPageY = centerClientY + touch1.pageY - touch1.clientY;
                var centerScreenX = centerClientX + touch1.screenX - touch1.clientX;
                var centerScreenY = centerClientY + touch1.screenY - touch1.clientY;
                var distanceX = Math.abs(touch1.clientX - touch2.clientX);
                var distanceY = Math.abs(touch1.clientY - touch2.clientY);
                var distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                var distanceChange = distance - previous.distance;
                var changeX = distanceX - previous.distanceX;
                var changeY = distanceY - previous.distanceY;
                var current = {
                    changeX: changeX,
                    changeY: changeY,
                    clientX: centerClientX,
                    clientY: centerClientY,
                    distance: distance,
                    distanceChange: distanceChange,
                    distanceX: distanceX,
                    distanceY: distanceY,
                    originalEvent: te,
                    pageX: centerPageX,
                    pageY: centerPageY,
                    screenX: centerScreenX,
                    screenY: centerScreenY,
                    touch1: touch1,
                    touch2: touch2,
                };
                return current;
            };
        })
            .subscribe(this._pinchOperation$);
        this._pinchChange$ = this._pinchStart$
            .switchMap(function (te) {
            return _this._pinch$
                .skip(1)
                .takeUntil(_this._pinchEnd$);
        });
    }
    Object.defineProperty(TouchService.prototype, "active$", {
        get: function () {
            return this._active$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchService.prototype, "activate$", {
        get: function () {
            return this._activeSubject$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchService.prototype, "doubleTap$", {
        get: function () {
            return this._doubleTap$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchService.prototype, "touchStart$", {
        get: function () {
            return this._touchStart$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchService.prototype, "touchMove$", {
        get: function () {
            return this._touchMove$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchService.prototype, "touchEnd$", {
        get: function () {
            return this._touchEnd$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchService.prototype, "touchCancel$", {
        get: function () {
            return this._touchCancel$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchService.prototype, "singleTouchDragStart$", {
        get: function () {
            return this._singleTouchDragStart$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchService.prototype, "singleTouchDrag$", {
        get: function () {
            return this._singleTouchDrag$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchService.prototype, "singleTouchDragEnd$", {
        get: function () {
            return this._singleTouchDragEnd$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchService.prototype, "pinch$", {
        get: function () {
            return this._pinchChange$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchService.prototype, "pinchStart$", {
        get: function () {
            return this._pinchStart$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchService.prototype, "pinchEnd$", {
        get: function () {
            return this._pinchEnd$;
        },
        enumerable: true,
        configurable: true
    });
    return TouchService;
}());
exports.TouchService = TouchService;

},{"rxjs/BehaviorSubject":26,"rxjs/Observable":29,"rxjs/Subject":34,"rxjs/add/observable/timer":48,"rxjs/add/operator/bufferWhen":53,"rxjs/add/operator/filter":63,"rxjs/add/operator/map":67,"rxjs/add/operator/merge":68,"rxjs/add/operator/scan":78,"rxjs/add/operator/switchMap":84}],443:[function(require,module,exports){
"use strict";
/// <reference path="../../typings/index.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var when = require("when");
var Observable_1 = require("rxjs/Observable");
var Viewer_1 = require("../Viewer");
var Utils_1 = require("../Utils");
/**
 * @class Viewer
 *
 * @classdesc The Viewer object represents the navigable image viewer.
 * Create a Viewer by specifying a container, client ID, image key and
 * other options. The viewer exposes methods and events for programmatic
 * interaction.
 *
 * The viewer works with a few different coordinate systems.
 *
 * Container pixel coordinates
 *
 * Pixel coordinates are coordinates on the viewer container. The origin is
 * in the top left corner of the container. The axes are
 * directed according to the following for a viewer container with a width
 * of 640 pixels and height of 480 pixels.
 *
 * ```
 * (0,0)                          (640, 0)
 *      +------------------------>
 *      |
 *      |
 *      |
 *      v                        +
 * (0, 480)                       (640, 480)
 * ```
 *
 * Basic image coordinates
 *
 * Basic image coordinates represents points in the original image adjusted for
 * orientation. They range from 0 to 1 on both axes. The origin is in the top left
 * corner of the image and the axes are directed
 * according to the following for all image types.
 *
 * ```
 * (0,0)                          (1, 0)
 *      +------------------------>
 *      |
 *      |
 *      |
 *      v                        +
 * (0, 1)                         (1, 1)
 * ```
 *
 * For every camera viewing direction it is possible to convert between these
 * two coordinate systems for the current node. The image can be panned and
 * zoomed independently of the size of the viewer container resulting in
 * different conversion results for different viewing directions.
 */
var Viewer = /** @class */ (function (_super) {
    __extends(Viewer, _super);
    /**
     * Create a new viewer instance.
     *
     * @description It is possible to initialize the viewer with or
     * without a key.
     *
     * When you want to show a specific image in the viewer from
     * the start you should initialize it with a key.
     *
     * When you do not know the first image key at implementation
     * time, e.g. in a map-viewer application you should initialize
     * the viewer without a key and call `moveToKey` instead.
     *
     * When initializing with a key the viewer is bound to that key
     * until the node for that key has been successfully loaded.
     * Also, a cover with the image of the key will be shown.
     * If the data for that key can not be loaded because the key is
     * faulty or other errors occur it is not possible to navigate
     * to another key because the viewer is not navigable. The viewer
     * becomes navigable when the data for the key has been loaded and
     * the image is shown in the viewer. This way of initializing
     * the viewer is mostly for embedding in blog posts and similar
     * where one wants to show a specific image initially.
     *
     * If the viewer is initialized without a key (with null or
     * undefined) it is not bound to any particular key and it is
     * possible to move to any key with `viewer.moveToKey("<my-image-key>")`.
     * If the first move to a key fails it is possible to move to another
     * key. The viewer will show a black background until a move
     * succeeds. This way of intitializing is suited for a map-viewer
     * application when the initial key is not known at implementation
     * time.
     *
     * @param {string} id - Required `id` of a DOM element which will
     * be transformed into the viewer.
     * @param {string} clientId - Required `Mapillary API ClientID`. Can
     * be obtained from https://www.mapillary.com/app/settings/developers.
     * @param {string} key - Optional `image-key` to start from. The key
     * can be any Mapillary image. If a key is provided the viewer is
     * bound to that key until it has been fully loaded. If null is provided
     * no image is loaded at viewer initialization and the viewer is not
     * bound to any particular key. Any image can then be navigated to
     * with e.g. `viewer.moveToKey("<my-image-key>")`.
     * @param {IViewerOptions} options - Optional configuration object
     * specifing Viewer's and the components' initial setup.
     * @param {string} token - Optional bearer token for API requests of
     * protected resources.
     *
     * @example
     * ```
     * var viewer = new Mapillary.Viewer("<element-id>", "<client-id>", "<image-key>");
     * ```
     */
    function Viewer(id, clientId, key, options, token) {
        var _this = _super.call(this) || this;
        options = options != null ? options : {};
        Utils_1.Settings.setOptions(options);
        Utils_1.Urls.setOptions(options.url);
        _this._navigator = new Viewer_1.Navigator(clientId, options, token);
        _this._container = new Viewer_1.Container(id, _this._navigator.stateService, options);
        _this._observer = new Viewer_1.Observer(_this, _this._navigator, _this._container);
        _this._componentController = new Viewer_1.ComponentController(_this._container, _this._navigator, _this._observer, key, options.component);
        return _this;
    }
    Object.defineProperty(Viewer.prototype, "isNavigable", {
        /**
         * Return a boolean indicating if the viewer is in a navigable state.
         *
         * @description The navigable state indicates if the viewer supports
         * moving, i.e. calling the {@link moveToKey}, {@link moveDir`}
         * and {@link moveCloseTo} methods or changing the authentication state,
         * i.e. calling {@link setAuthToken}. The viewer will not be in a navigable
         * state if the cover is activated and the viewer has been supplied a key.
         * When the cover is deactivated or the viewer is activated without being
         * supplied a key it will be navigable.
         *
         * @returns {boolean} Boolean indicating whether the viewer is navigable.
         */
        get: function () {
            return this._componentController.navigable;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Activate a component.
     *
     * @param {string} name - Name of the component which will become active.
     *
     * @example
     * ```
     * viewer.activateComponent("marker");
     * ```
     */
    Viewer.prototype.activateComponent = function (name) {
        this._componentController.activate(name);
    };
    /**
     * Activate the cover (deactivates all other components).
     */
    Viewer.prototype.activateCover = function () {
        this._componentController.activateCover();
    };
    /**
     * Deactivate a component.
     *
     * @param {string} name - Name of component which become inactive.
     *
     * @example
     * ```
     * viewer.deactivateComponent("mouse");
     * ```
     */
    Viewer.prototype.deactivateComponent = function (name) {
        this._componentController.deactivate(name);
    };
    /**
     * Deactivate the cover (activates all components marked as active).
     */
    Viewer.prototype.deactivateCover = function () {
        this._componentController.deactivateCover();
    };
    /**
     * Get the bearing of the current viewer camera.
     *
     * @description The bearing depends on how the camera
     * is currently rotated and does not correspond
     * to the compass angle of the current node if the view
     * has been panned.
     *
     * Bearing is measured in degrees clockwise with respect to
     * north.
     *
     * @returns {Promise<number>} Promise to the bearing
     * of the current viewer camera.
     *
     * @example
     * ```
     * viewer.getBearing().then((b) => { console.log(b); });
     * ```
     */
    Viewer.prototype.getBearing = function () {
        var _this = this;
        return when.promise(function (resolve, reject) {
            _this._container.renderService.bearing$
                .first()
                .subscribe(function (bearing) {
                resolve(bearing);
            }, function (error) {
                reject(error);
            });
        });
    };
    /**
     * Get the basic coordinates of the current image that is
     * at the center of the viewport.
     *
     * @description Basic coordinates are 2D coordinates on the [0, 1] interval
     * and have the origin point, (0, 0), at the top left corner and the
     * maximum value, (1, 1), at the bottom right corner of the original
     * image.
     *
     * @returns {Promise<number[]>} Promise to the basic coordinates
     * of the current image at the center for the viewport.
     *
     * @example
     * ```
     * viewer.getCenter().then((c) => { console.log(c); });
     * ```
     */
    Viewer.prototype.getCenter = function () {
        var _this = this;
        return when.promise(function (resolve, reject) {
            _this._navigator.stateService.getCenter()
                .subscribe(function (center) {
                resolve(center);
            }, function (error) {
                reject(error);
            });
        });
    };
    /**
     * Get a component.
     *
     * @param {string} name - Name of component.
     * @returns {Component} The requested component.
     *
     * @example
     * ```
     * var mouseComponent = viewer.getComponent("mouse");
     * ```
     */
    Viewer.prototype.getComponent = function (name) {
        return this._componentController.get(name);
    };
    /**
     * Returns the viewer's containing HTML element.
     *
     * @returns {HTMLElement} The viewer's container.
     */
    Viewer.prototype.getContainer = function () {
        return this._container.element;
    };
    /**
     * Get the image's current zoom level.
     *
     * @returns {Promise<number>} Promise to the viewers's current
     * zoom level.
     *
     * @example
     * ```
     * viewer.getZoom().then((z) => { console.log(z); });
     * ```
     */
    Viewer.prototype.getZoom = function () {
        var _this = this;
        return when.promise(function (resolve, reject) {
            _this._navigator.stateService.getZoom()
                .subscribe(function (zoom) {
                resolve(zoom);
            }, function (error) {
                reject(error);
            });
        });
    };
    /**
     * Move close to given latitude and longitude.
     *
     * @description Because the method propagates IO errors, these potential errors
     * need to be handled by the method caller (see example).
     *
     * @param {Number} lat - Latitude, in degrees.
     * @param {Number} lon - Longitude, in degrees.
     * @returns {Promise<Node>} Promise to the node that was navigated to.
     * @throws {Error} If no nodes exist close to provided latitude
     * longitude.
     * @throws {Error} Propagates any IO errors to the caller.
     * @throws {Error} When viewer is not navigable.
     *
     * @example
     * ```
     * viewer.moveCloseTo(0, 0).then(
     *     (n) => { console.log(n); },
     *     (e) => { console.error(e); });
     * ```
     */
    Viewer.prototype.moveCloseTo = function (lat, lon) {
        var moveCloseTo$ = this.isNavigable ?
            this._navigator.moveCloseTo$(lat, lon) :
            Observable_1.Observable.throw(new Error("Calling moveCloseTo is not supported when viewer is not navigable."));
        return when.promise(function (resolve, reject) {
            moveCloseTo$.subscribe(function (node) {
                resolve(node);
            }, function (error) {
                reject(error);
            });
        });
    };
    /**
     * Navigate in a given direction.
     *
     * @description This method has to be called through EdgeDirection enumeration as in the example.
     *
     * @param {EdgeDirection} dir - Direction in which which to move.
     * @returns {Promise<Node>} Promise to the node that was navigated to.
     * @throws {Error} If the current node does not have the edge direction
     * or the edges has not yet been cached.
     * @throws {Error} Propagates any IO errors to the caller.
     * @throws {Error} When viewer is not navigable.
     *
     * @example
     * ```
     * viewer.moveDir(Mapillary.EdgeDirection.Next).then(
     *     (n) => { console.log(n); },
     *     (e) => { console.error(e); });
     * ```
     */
    Viewer.prototype.moveDir = function (dir) {
        var moveDir$ = this.isNavigable ?
            this._navigator.moveDir$(dir) :
            Observable_1.Observable.throw(new Error("Calling moveDir is not supported when viewer is not navigable."));
        return when.promise(function (resolve, reject) {
            moveDir$.subscribe(function (node) {
                resolve(node);
            }, function (error) {
                reject(error);
            });
        });
    };
    /**
     * Navigate to a given image key.
     *
     * @param {string} key - A valid Mapillary image key.
     * @returns {Promise<Node>} Promise to the node that was navigated to.
     * @throws {Error} Propagates any IO errors to the caller.
     * @throws {Error} When viewer is not navigable.
     *
     * @example
     * ```
     * viewer.moveToKey("<my key>").then(
     *     (n) => { console.log(n); },
     *     (e) => { console.error(e); });
     * ```
     */
    Viewer.prototype.moveToKey = function (key) {
        var moveToKey$ = this.isNavigable ?
            this._navigator.moveToKey$(key) :
            Observable_1.Observable.throw(new Error("Calling moveToKey is not supported when viewer is not navigable."));
        return when.promise(function (resolve, reject) {
            moveToKey$.subscribe(function (node) {
                resolve(node);
            }, function (error) {
                reject(error);
            });
        });
    };
    /**
     * Project basic image coordinates for the current node to canvas pixel
     * coordinates.
     *
     * @description The basic image coordinates may not always correspond to a
     * pixel point that lies in the visible area of the viewer container.
     *
     * @param {Array<number>} basicPoint - Basic images coordinates to project.
     * @returns {Promise<Array<number>>} Promise to the pixel coordinates corresponding
     * to the basic image point.
     *
     * @example
     * ```
     * viewer.projectFromBasic([0.3, 0.7])
     *     .then((pixelPoint) => { console.log(pixelPoint); });
     * ```
     */
    Viewer.prototype.projectFromBasic = function (basicPoint) {
        var _this = this;
        return when.promise(function (resolve, reject) {
            _this._observer.projectBasic$(basicPoint)
                .subscribe(function (pixelPoint) {
                resolve(pixelPoint);
            }, function (error) {
                reject(error);
            });
        });
    };
    /**
     * Detect the viewer's new width and height and resize it.
     *
     * @description The components will also detect the viewer's
     * new size and resize their rendered elements if needed.
     *
     * @example
     * ```
     * viewer.resize();
     * ```
     */
    Viewer.prototype.resize = function () {
        this._container.renderService.resize$.next(null);
        this._componentController.resize();
    };
    /**
     * Set a bearer token for authenticated API requests of
     * protected resources.
     *
     * @description When the supplied token is null or undefined,
     * any previously set bearer token will be cleared and the
     * viewer will make unauthenticated requests.
     *
     * Calling setAuthToken aborts all outstanding move requests.
     * The promises of those move requests will be rejected and
     * the rejections need to be caught.
     *
     * Calling setAuthToken also resets the complete viewer cache
     * so it should not be called repeatedly.
     *
     * @param {string} [token] token - Bearer token.
     * @returns {Promise<void>} Promise that resolves after token
     * is set.
     *
     * @throws {Error} When viewer is not navigable.
     *
     * @example
     * ```
     * viewer.setAuthToken("<my token>")
     *     .then(() => { console.log("token set"); });
     * ```
     */
    Viewer.prototype.setAuthToken = function (token) {
        var setToken$ = this.isNavigable ?
            this._navigator.setToken$(token) :
            Observable_1.Observable.throw(new Error("Calling setAuthToken is not supported when viewer is not navigable."));
        return when.promise(function (resolve, reject) {
            setToken$
                .subscribe(function () {
                resolve(undefined);
            }, function (error) {
                reject(error);
            });
        });
    };
    /**
     * Set the basic coordinates of the current image to be in the
     * center of the viewport.
     *
     * @description Basic coordinates are 2D coordinates on the [0, 1] interval
     * and has the origin point, (0, 0), at the top left corner and the
     * maximum value, (1, 1), at the bottom right corner of the original
     * image.
     *
     * @param {number[]} The basic coordinates of the current
     * image to be at the center for the viewport.
     *
     * @example
     * ```
     * viewer.setCenter([0.5, 0.5]);
     * ```
     */
    Viewer.prototype.setCenter = function (center) {
        this._navigator.stateService.setCenter(center);
    };
    /**
     * Set the filter selecting nodes to use when calculating
     * the spatial edges.
     *
     * @description The following filter types are supported:
     *
     * Comparison
     *
     * `["==", key, value]` equality: `node[key] = value`
     *
     * `["!=", key, value]` inequality: `node[key]  value`
     *
     * `["<", key, value]` less than: `node[key] < value`
     *
     * `["<=", key, value]` less than or equal: `node[key]  value`
     *
     * `[">", key, value]` greater than: `node[key] > value`
     *
     * `[">=", key, value]` greater than or equal: `node[key]  value`
     *
     * Set membership
     *
     * `["in", key, v0, ..., vn]` set inclusion: `node[key]  {v0, ..., vn}`
     *
     * `["!in", key, v0, ..., vn]` set exclusion: `node[key]  {v0, ..., vn}`
     *
     * Combining
     *
     * `["all", f0, ..., fn]` logical `AND`: `f0  ...  fn`
     *
     * A key must be a string that identifies a property name of a
     * simple {@link Node} property. A value must be a string, number, or
     * boolean. Strictly-typed comparisons are used. The values
     * `f0, ..., fn` of the combining filter must be filter expressions.
     *
     * Clear the filter by setting it to null or empty array.
     *
     * @param {FilterExpression} filter - The filter expression.
     * @returns {Promise<void>} Promise that resolves after filter is applied.
     *
     * @example
     * ```
     * viewer.setFilter(["==", "sequenceKey", "<my sequence key>"]);
     * ```
     */
    Viewer.prototype.setFilter = function (filter) {
        var _this = this;
        return when.promise(function (resolve, reject) {
            _this._navigator.setFilter$(filter)
                .subscribe(function () {
                resolve(undefined);
            }, function (error) {
                reject(error);
            });
        });
    };
    /**
     * Set the viewer's render mode.
     *
     * @param {RenderMode} renderMode - Render mode.
     *
     * @example
     * ```
     * viewer.setRenderMode(Mapillary.RenderMode.Letterbox);
     * ```
     */
    Viewer.prototype.setRenderMode = function (renderMode) {
        this._container.renderService.renderMode$.next(renderMode);
    };
    /**
     * Set the viewer's transition mode.
     *
     * @param {TransitionMode} transitionMode - Transition mode.
     *
     * @example
     * ```
     * viewer.setTransitionMode(Mapillary.TransitionMode.Instantaneous);
     * ```
     */
    Viewer.prototype.setTransitionMode = function (transitionMode) {
        this._navigator.stateService.setTransitionMode(transitionMode);
    };
    /**
     * Set the image's current zoom level.
     *
     * @description Possible zoom level values are on the [0, 3] interval.
     * Zero means zooming out to fit the image to the view whereas three
     * shows the highest level of detail.
     *
     * @param {number} The image's current zoom level.
     *
     * @example
     * ```
     * viewer.setZoom(2);
     * ```
     */
    Viewer.prototype.setZoom = function (zoom) {
        this._navigator.stateService.setZoom(zoom);
    };
    /**
     * Unproject canvas pixel coordinates to an ILatLon representing geographical
     * coordinates.
     *
     * @description The pixel point may not always correspond to geographical
     * coordinates. In the case of no correspondence the returned value will
     * be `null`.
     *
     * @param {Array<number>} pixelPoint - Pixel coordinates to unproject.
     * @returns {Promise<ILatLon>} Promise to the latLon corresponding to the pixel point.
     *
     * @example
     * ```
     * viewer.unproject([100, 100])
     *     .then((latLon) => { console.log(latLon); });
     * ```
     */
    Viewer.prototype.unproject = function (pixelPoint) {
        var _this = this;
        return when.promise(function (resolve, reject) {
            _this._observer.unproject$(pixelPoint)
                .subscribe(function (latLon) {
                resolve(latLon);
            }, function (error) {
                reject(error);
            });
        });
    };
    /**
     * Unproject canvas pixel coordinates to basic image coordinates for the
     * current node.
     *
     * @description The pixel point may not always correspond to basic image
     * coordinates. In the case of no correspondence the returned value will
     * be `null`.
     *
     * @param {Array<number>} pixelPoint - Pixel coordinates to unproject.
     * @returns {Promise<ILatLon>} Promise to the basic coordinates corresponding
     * to the pixel point.
     *
     * @example
     * ```
     * viewer.unprojectToBasic([100, 100])
     *     .then((basicPoint) => { console.log(basicPoint); });
     * ```
     */
    Viewer.prototype.unprojectToBasic = function (pixelPoint) {
        var _this = this;
        return when.promise(function (resolve, reject) {
            _this._observer.unprojectBasic$(pixelPoint)
                .subscribe(function (basicPoint) {
                resolve(basicPoint);
            }, function (error) {
                reject(error);
            });
        });
    };
    /**
     * Fired when the viewing direction of the camera changes.
     * @event
     * @type {number} bearing - Value indicating the current bearing
     * measured in degrees clockwise with respect to north.
     */
    Viewer.bearingchanged = "bearingchanged";
    /**
     * Fired when a pointing device (usually a mouse) is pressed and released at
     * the same point in the viewer.
     * @event
     * @type {IViewerMouseEvent} event - Viewer mouse event data.
     */
    Viewer.click = "click";
    /**
     * Fired when the right button of the mouse is clicked within the viewer.
     * @event
     * @type {IViewerMouseEvent} event - Viewer mouse event data.
     */
    Viewer.contextmenu = "contextmenu";
    /**
     * Fired when a pointing device (usually a mouse) is clicked twice at
     * the same point in the viewer.
     * @event
     * @type {IViewerMouseEvent} event - Viewer mouse event data.
     */
    Viewer.dblclick = "dblclick";
    /**
     * Fired when the viewer is loading more data.
     * @event
     * @type {boolean} loading - Boolean indicating whether the viewer is loading.
     */
    Viewer.loadingchanged = "loadingchanged";
    /**
     * Fired when a pointing device (usually a mouse) is pressed within the viewer.
     * @event
     * @type {IViewerMouseEvent} event - Viewer mouse event data.
     */
    Viewer.mousedown = "mousedown";
    /**
     * Fired when a pointing device (usually a mouse) is moved within the viewer.
     * @description Will not fire when the mouse is actively used, e.g. for drag pan.
     * @event
     * @type {IViewerMouseEvent} event - Viewer mouse event data.
     */
    Viewer.mousemove = "mousemove";
    /**
     * Fired when a pointing device (usually a mouse) leaves the viewer's canvas.
     * @event
     * @type {IViewerMouseEvent} event - Viewer mouse event data.
     */
    Viewer.mouseout = "mouseout";
    /**
     * Fired when a pointing device (usually a mouse) is moved onto the viewer's canvas.
     * @event
     * @type {IViewerMouseEvent} event - Viewer mouse event data.
     */
    Viewer.mouseover = "mouseover";
    /**
     * Fired when a pointing device (usually a mouse) is released within the viewer.
     * @event
     * @type {IViewerMouseEvent} event - Viewer mouse event data.
     */
    Viewer.mouseup = "mouseup";
    /**
     * Fired when the viewer motion stops and it is in a fixed
     * position with a fixed point of view.
     * @event
     */
    Viewer.moveend = "moveend";
    /**
     * Fired when the motion from one view to another start,
     * either by changing the position (e.g. when changing node) or
     * when changing point of view (e.g. by interaction such as pan and zoom).
     * @event
     */
    Viewer.movestart = "movestart";
    /**
     * Fired when the navigable state of the viewer changes.
     *
     * @description The navigable state indicates if the viewer supports
     * moving, i.e. calling the `moveToKey`, `moveDir` and `moveCloseTo`
     * methods. The viewer will not be in a navigable state if the cover
     * is activated and the viewer has been supplied a key. When the cover
     * is deactivated or activated without being supplied a key it will
     * be navigable.
     *
     * @event
     * @type {boolean} navigable - Boolean indicating whether the viewer is navigable.
     */
    Viewer.navigablechanged = "navigablechanged";
    /**
     * Fired every time the viewer navigates to a new node.
     * @event
     * @type {Node} node - Current node.
     */
    Viewer.nodechanged = "nodechanged";
    /**
     * Fired every time the sequence edges of the current node changes.
     * @event
     * @type {IEdgeStatus} status - The edge status object.
     */
    Viewer.sequenceedgeschanged = "sequenceedgeschanged";
    /**
     * Fired every time the spatial edges of the current node changes.
     * @event
     * @type {IEdgeStatus} status - The edge status object.
     */
    Viewer.spatialedgeschanged = "spatialedgeschanged";
    return Viewer;
}(Utils_1.EventEmitter));
exports.Viewer = Viewer;

},{"../Utils":301,"../Viewer":302,"rxjs/Observable":29,"when":288}]},{},[296])(296)
});
//# sourceMappingURL=mapillary.js.map
